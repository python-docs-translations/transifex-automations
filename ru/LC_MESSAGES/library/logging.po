# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-11 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/logging.rst:2
msgid ":mod:`!logging` --- Logging facility for Python"
msgstr ":mod:`!logging` --- Возможность ведения журналов для Python"

#: ../../library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**Исходный код:** :source:`Lib/logging/__init__.py`"

#: ../../library/logging.rst:16
msgid ""
"This page contains the API reference information. For tutorial information "
"and discussion of more advanced topics, see"
msgstr ""
"Эта страница содержит справочную информацию по API. Учебную информацию и "
"обсуждение более сложных тем см."

#: ../../library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Basic Tutorial <logging-basic-tutorial>`"

#: ../../library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"

#: ../../library/logging.rst:21
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../../library/logging.rst:25
msgid ""
"This module defines functions and classes which implement a flexible event "
"logging system for applications and libraries."
msgstr ""
"Этот модуль определяет функции и классы, которые реализуют гибкую систему "
"регистрации событий для приложений и библиотек."

#: ../../library/logging.rst:28
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages from "
"third-party modules."
msgstr ""
"Ключевым преимуществом использования API ведения журналов, предоставляемого "
"стандартным библиотечным модулем, является то, что все модули Python могут "
"участвовать в журналировании, поэтому журнал вашего приложения может "
"включать ваши собственные сообщения, интегрированные с сообщениями из "
"сторонних модулей."

#: ../../library/logging.rst:33
msgid "Here's a simple example of idiomatic usage: ::"
msgstr "Вот простой пример идиоматического употребления:::"

#: ../../library/logging.rst:35
msgid ""
"# myapp.py\n"
"import logging\n"
"import mylib\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def main():\n"
"    logging.basicConfig(filename='myapp.log', level=logging.INFO)\n"
"    logger.info('Started')\n"
"    mylib.do_something()\n"
"    logger.info('Finished')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"# myapp.py\n"
"import logging\n"
"import mylib\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def main():\n"
"    logging.basicConfig(filename='myapp.log', level=logging.INFO)\n"
"    logger.info('Started')\n"
"    mylib.do_something()\n"
"    logger.info('Finished')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../library/logging.rst:51
msgid ""
"# mylib.py\n"
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def do_something():\n"
"    logger.info('Doing something')"
msgstr ""
"# mylib.py\n"
"import logging\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def do_something():\n"
"    logger.info('Doing something')"

#: ../../library/logging.rst:58
msgid "If you run *myapp.py*, you should see this in *myapp.log*:"
msgstr "Если вы запустите *myapp.py*, вы увидите это в *myapp.log*:"

#: ../../library/logging.rst:60
msgid ""
"INFO:__main__:Started\n"
"INFO:mylib:Doing something\n"
"INFO:__main__:Finished"
msgstr ""
"INFO:__main__:Started\n"
"INFO:mylib:Doing something\n"
"INFO:__main__:Finished"

#: ../../library/logging.rst:66
msgid ""
"The key feature of this idiomatic usage is that the majority of code is "
"simply creating a module level logger with ``getLogger(__name__)``, and "
"using that logger to do any needed logging. This is concise, while allowing "
"downstream code fine-grained control if needed. Logged messages to the "
"module-level logger get forwarded to handlers of loggers in higher-level "
"modules, all the way up to the highest-level logger known as the root "
"logger; this approach is known as hierarchical logging."
msgstr ""
"Ключевой особенностью этого идиоматического использования является то, что "
"большая часть кода просто создает регистратор уровня модуля с помощью "
"getLogger(__name__)`` и использует этот регистратор для выполнения любой "
"необходимой регистрации. Это лаконично, но при необходимости позволяет "
"осуществлять детальный контроль последующего кода. Сообщения, "
"зарегистрированные в регистраторе уровня модуля, пересылаются обработчикам "
"регистраторов в модулях более высокого уровня, вплоть до регистратора самого "
"высокого уровня, известного как корневой регистратор; этот подход известен "
"как иерархическое журналирование."

#: ../../library/logging.rst:74
msgid ""
"For logging to be useful, it needs to be configured: setting the levels and "
"destinations for each logger, potentially changing how specific modules log, "
"often based on command-line arguments or application configuration. In most "
"cases, like the one above, only the root logger needs to be so configured, "
"since all the lower level loggers at module level eventually forward their "
"messages to its handlers.  :func:`~logging.basicConfig` provides a quick way "
"to configure the root logger that handles many use cases."
msgstr ""
"Чтобы ведение журнала было полезным, его необходимо настроить: установить "
"уровни и места назначения для каждого средства ведения журнала, потенциально "
"изменить способ ведения журнала конкретных модулей, часто на основе "
"аргументов командной строки или конфигурации приложения. В большинстве "
"случаев, как в приведенном выше, необходимо настроить только корневой "
"регистратор, поскольку все регистраторы нижнего уровня на уровне модуля в "
"конечном итоге пересылают свои сообщения своим обработчикам. :func:`~logging."
"basicConfig` предоставляет быстрый способ настройки корневого регистратора, "
"который обрабатывает множество вариантов использования."

#: ../../library/logging.rst:82
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to view the "
"tutorials (**see the links above and on the right**)."
msgstr ""
"Модуль обеспечивает большую функциональность и гибкость. Если вы не знакомы "
"с ведением журналов, лучший способ освоить их — просмотреть учебные пособия "
"(**см. ссылки выше и справа**)."

#: ../../library/logging.rst:86
msgid ""
"The basic classes defined by the module, together with their attributes and "
"methods, are listed in the sections below."
msgstr ""
"Базовые классы, определенные модулем, вместе с их атрибутами и методами "
"перечислены в разделах ниже."

#: ../../library/logging.rst:89
msgid "Loggers expose the interface that application code directly uses."
msgstr ""
"Регистраторы предоставляют интерфейс, который напрямую использует код "
"приложения."

#: ../../library/logging.rst:90
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr ""
"Обработчики отправляют записи журнала (созданные регистраторами) в "
"соответствующее место назначения."

#: ../../library/logging.rst:92
msgid ""
"Filters provide a finer grained facility for determining which log records "
"to output."
msgstr ""
"Фильтры предоставляют более детальную возможность определения того, какие "
"записи журнала следует выводить."

#: ../../library/logging.rst:94
msgid "Formatters specify the layout of log records in the final output."
msgstr "Форматтеры определяют расположение записей журнала в конечном выводе."

#: ../../library/logging.rst:100
msgid "Logger Objects"
msgstr "Объекты регистратора"

#: ../../library/logging.rst:102
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers should "
"*NEVER* be instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to :func:`getLogger` "
"with the same name will always return a reference to the same Logger object."
msgstr ""
"Регистраторы имеют следующие атрибуты и методы. Обратите внимание, что "
"экземпляры Logger *НИКОГДА* не должны создаваться напрямую, а всегда через "
"функцию уровня модуля ``logging.getLogger(name)``. Множественные вызовы :"
"func:`getLogger` с одним и тем же именем всегда будут возвращать ссылку на "
"один и тот же объект Logger."

#: ../../library/logging.rst:107
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for example). "
"Loggers that are further down in the hierarchical list are children of "
"loggers higher up in the list.  For example, given a logger with a name of "
"``foo``, loggers with names of ``foo.bar``, ``foo.bar.baz``, and ``foo.bam`` "
"are all descendants of ``foo``.  In addition, all loggers are descendants of "
"the root logger. The logger name hierarchy is analogous to the Python "
"package hierarchy, and identical to it if you organise your loggers on a per-"
"module basis using the recommended construction ``logging."
"getLogger(__name__)``.  That's because in a module, ``__name__`` is the "
"module's name in the Python package namespace."
msgstr ""
"Имя ``name`` потенциально является иерархическим значением, разделенным "
"точкой, например ``foo.bar.baz`` (хотя оно также может быть, например, "
"просто ``foo``). Регистраторы, находящиеся ниже в иерархическом списке, "
"являются дочерними элементами регистраторов, находящихся выше в списке. "
"Например, для данного регистратора с именем ``foo`` все регистраторы с "
"именами ``foo.bar``, ``foo.bar.baz`` и ``foo.bam`` являются потомками "
"``фу``. Кроме того, все регистраторы являются потомками корневого "
"регистратора. Иерархия имен регистраторов аналогична иерархии пакетов Python "
"и идентична ей, если вы организуете свои регистраторы для каждого модуля, "
"используя рекомендуемую конструкцию ``logging.getLogger(__name__)``. Это "
"потому, что в модуле ``__name__`` — это имя модуля в пространстве имен "
"пакета Python."

#: ../../library/logging.rst:123
msgid ""
"This is the logger's name, and is the value that was passed to :func:"
"`getLogger` to obtain the logger."
msgstr ""
"Это имя регистратора и значение, которое было передано в :func:`getLogger` "
"для получения регистратора."

#: ../../library/logging.rst:126 ../../library/logging.rst:186
msgid "This attribute should be treated as read-only."
msgstr "Этот атрибут следует рассматривать как доступный только для чтения."

#: ../../library/logging.rst:130
msgid "The threshold of this logger, as set by the :meth:`setLevel` method."
msgstr "Порог этого регистратора, установленный методом :meth:`setLevel`."

#: ../../library/logging.rst:132
msgid ""
"Do not set this attribute directly - always use :meth:`setLevel`, which has "
"checks for the level passed to it."
msgstr ""
"Не устанавливайте этот атрибут напрямую — всегда используйте :meth:"
"`setLevel`, который проверяет переданный ему уровень."

#: ../../library/logging.rst:137
msgid ""
"The parent logger of this logger. It may change based on later instantiation "
"of loggers which are higher up in the namespace hierarchy."
msgstr ""
"Родительский регистратор этого регистратора. Оно может измениться в "
"зависимости от более позднего создания экземпляров средств ведения журнала, "
"которые находятся выше в иерархии пространства имен."

#: ../../library/logging.rst:140
msgid "This value should be treated as read-only."
msgstr "Это значение следует рассматривать как доступное только для чтения."

#: ../../library/logging.rst:144
msgid ""
"If this attribute evaluates to true, events logged to this logger will be "
"passed to the handlers of higher level (ancestor) loggers, in addition to "
"any handlers attached to this logger. Messages are passed directly to the "
"ancestor loggers' handlers - neither the level nor filters of the ancestor "
"loggers in question are considered."
msgstr ""
"Если этот атрибут имеет значение true, события, зарегистрированные в этом "
"регистраторе, будут переданы обработчикам регистраторов более высокого "
"уровня (предков) в дополнение к любым обработчикам, прикрепленным к этому "
"регистратору. Сообщения передаются непосредственно обработчикам "
"регистраторов-предков — ни уровень, ни фильтры рассматриваемых регистраторов-"
"предков не учитываются."

#: ../../library/logging.rst:150
msgid ""
"If this evaluates to false, logging messages are not passed to the handlers "
"of ancestor loggers."
msgstr ""
"Если это значение равно false, сообщения журнала не передаются обработчикам "
"средств ведения журнала-предка."

#: ../../library/logging.rst:153
msgid ""
"Spelling it out with an example: If the propagate attribute of the logger "
"named ``A.B.C`` evaluates to true, any event logged to ``A.B.C`` via a "
"method call such as ``logging.getLogger('A.B.C').error(...)`` will [subject "
"to passing that logger's level and filter settings] be passed in turn to any "
"handlers attached to loggers named ``A.B``, ``A`` and the root logger, after "
"first being passed to any handlers attached to ``A.B.C``. If any logger in "
"the chain ``A.B.C``, ``A.B``, ``A`` has its ``propagate`` attribute set to "
"false, then that is the last logger whose handlers are offered the event to "
"handle, and propagation stops at that point."
msgstr ""
"Поясним это на примере: если атрибут распространения средства ведения "
"журнала с именем ``ABC`` имеет значение true, любое событие регистрируется в "
"``ABC`` посредством вызова метода, такого как ``logging.getLogger('ABC'). "
"error(...)`` будет [при условии передачи уровня этого регистратора и "
"настроек фильтра] поочередно передаваться любым обработчикам, прикрепленным "
"к регистраторам с именами ``AB``, ``A`` и корневому регистратору, после "
"первого передается любым обработчикам, прикрепленным к ``ABC``. Если какой-"
"либо регистратор в цепочке ``ABC``, ``AB``, ``A`` имеет атрибут "
"``propagate``, установленный в значение false, то это последний регистратор, "
"чьим обработчикам предлагается событие для обработки, и распространение "
"останавливается в этой точке."

#: ../../library/logging.rst:162
msgid "The constructor sets this attribute to ``True``."
msgstr "Конструктор устанавливает для этого атрибута значение True."

#: ../../library/logging.rst:164
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, it "
"may emit the same record multiple times. In general, you should not need to "
"attach a handler to more than one logger - if you just attach it to the "
"appropriate logger which is highest in the logger hierarchy, then it will "
"see all events logged by all descendant loggers, provided that their "
"propagate setting is left set to ``True``. A common scenario is to attach "
"handlers only to the root logger, and to let propagation take care of the "
"rest."
msgstr ""
"Если вы прикрепите обработчик к регистратору *и* одному или нескольким его "
"предкам, он может выдать одну и ту же запись несколько раз. В общем, вам не "
"нужно прикреплять обработчик более чем к одному регистратору - если вы "
"просто прикрепите его к соответствующему регистратору, который находится на "
"самом высоком уровне в иерархии регистраторов, тогда он будет видеть все "
"события, зарегистрированные всеми дочерними регистраторами, при условии, что "
"их распространение параметр остается установленным на ``True``. "
"Распространенный сценарий — прикрепить обработчики только к корневому "
"регистратору, а распространение позаботится обо всем остальном."

#: ../../library/logging.rst:175
msgid "The list of handlers directly attached to this logger instance."
msgstr ""
"Список обработчиков, непосредственно прикрепленных к этому экземпляру "
"средства ведения журнала."

#: ../../library/logging.rst:177
msgid ""
"This attribute should be treated as read-only; it is normally changed via "
"the :meth:`addHandler` and :meth:`removeHandler` methods, which use locks to "
"ensure thread-safe operation."
msgstr ""
"Этот атрибут следует рассматривать как доступный только для чтения; обычно "
"он изменяется с помощью методов :meth:`addHandler` и :meth:`removeHandler`, "
"которые используют блокировки для обеспечения потокобезопасной работы."

#: ../../library/logging.rst:183
msgid ""
"This attribute disables handling of any events. It is set to ``False`` in "
"the initializer, and only changed by logging configuration code."
msgstr ""
"Этот атрибут отключает обработку любых событий. В инициализаторе для него "
"установлено значение False, и его можно изменить только при регистрации кода "
"конфигурации."

#: ../../library/logging.rst:190
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are "
"less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or handlers "
"service this logger, unless a handler's level has been set to a higher "
"severity level than *level*."
msgstr ""
"Устанавливает порог для этого регистратора на *уровень*. Сообщения журнала, "
"которые менее серьезны, чем *уровень*, будут игнорироваться; Сообщения "
"регистрации, имеющие уровень серьезности *level* или выше, будут "
"генерироваться любым обработчиком или обработчиками, обслуживающими этот "
"регистратор, если только уровень обработчика не установлен на более высокий "
"уровень серьезности, чем *level*."

#: ../../library/logging.rst:195
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which causes "
"all messages to be processed when the logger is the root logger, or "
"delegation to the parent when the logger is a non-root logger). Note that "
"the root logger is created with level :const:`WARNING`."
msgstr ""
"При создании средства ведения журнала устанавливается уровень :const:"
"`NOTSET` (что приводит к обработке всех сообщений, если средство ведения "
"журнала является корневым, или к делегированию родительскому средству, если "
"средство ведения журнала не является корневым). Обратите внимание, что "
"корневой регистратор создается с уровнем :const:`WARNING`."

#: ../../library/logging.rst:200
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of "
"NOTSET, its chain of ancestor loggers is traversed until either an ancestor "
"with a level other than NOTSET is found, or the root is reached."
msgstr ""
"Термин «делегирование родительскому элементу» означает, что если регистратор "
"имеет уровень NOTSET, его цепочка регистраторов-предков просматривается до "
"тех пор, пока не будет найден предок с уровнем, отличным от NOTSET, или не "
"будет достигнут корень."

#: ../../library/logging.rst:204
msgid ""
"If an ancestor is found with a level other than NOTSET, then that ancestor's "
"level is treated as the effective level of the logger where the ancestor "
"search began, and is used to determine how a logging event is handled."
msgstr ""
"Если найден предок с уровнем, отличным от NOTSET, то уровень этого предка "
"рассматривается как эффективный уровень средства ведения журнала, на котором "
"начался поиск предка, и используется для определения того, как "
"обрабатывается событие регистрации."

#: ../../library/logging.rst:208
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages will "
"be processed. Otherwise, the root's level will be used as the effective "
"level."
msgstr ""
"Если корень достигнут и он имеет уровень NOTSET, то все сообщения будут "
"обработаны. В противном случае в качестве эффективного уровня будет "
"использоваться корневой уровень."

#: ../../library/logging.rst:211 ../../library/logging.rst:555
msgid "See :ref:`levels` for a list of levels."
msgstr "См. список уровней в :ref:`levels`."

#: ../../library/logging.rst:213
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`. "
"Note, however, that levels are internally stored as integers, and methods "
"such as e.g. :meth:`getEffectiveLevel` and :meth:`isEnabledFor` will return/"
"expect to be passed integers."
msgstr ""
"Параметр *level* теперь принимает строковое представление уровня, например "
"INFO, в качестве альтернативы целочисленным константам, таким как :const:"
"`INFO`. Однако обратите внимание, что уровни внутренне сохраняются как целые "
"числа, и такие методы, как, например, :meth:`getEffectiveLevel` и :meth:"
"`isEnabledFor`, будут возвращать/ожидать передачи целых чисел."

#: ../../library/logging.rst:223
msgid ""
"Indicates if a message of severity *level* would be processed by this "
"logger. This method checks first the module-level level set by ``logging."
"disable(level)`` and then the logger's effective level as determined by :"
"meth:`getEffectiveLevel`."
msgstr ""
"Указывает, будет ли этим средством ведения журнала обрабатываться сообщение "
"уровня серьезности*. Этот метод сначала проверяет уровень уровня модуля, "
"установленный ``logging.disable(level)``, а затем эффективный уровень "
"регистратора, определенный :meth:`getEffectiveLevel`."

#: ../../library/logging.rst:231
msgid ""
"Indicates the effective level for this logger. If a value other than :const:"
"`NOTSET` has been set using :meth:`setLevel`, it is returned. Otherwise, the "
"hierarchy is traversed towards the root until a value other than :const:"
"`NOTSET` is found, and that value is returned. The value returned is an "
"integer, typically one of :const:`logging.DEBUG`, :const:`logging.INFO` etc."
msgstr ""
"Указывает эффективный уровень для этого регистратора. Если с помощью :meth:"
"`setLevel` было установлено значение, отличное от :const:`NOTSET`, оно "
"возвращается. В противном случае иерархия перемещается к корню, пока не "
"будет найдено значение, отличное от :const:`NOTSET`, и это значение не будет "
"возвращено. Возвращаемое значение является целым числом, обычно одним из "
"следующих: :const:`logging.DEBUG`, :const:`logging.INFO` и т. д."

#: ../../library/logging.rst:241
msgid ""
"Returns a logger which is a descendant to this logger, as determined by the "
"suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would return "
"the same logger as would be returned by ``logging.getLogger('abc.def."
"ghi')``. This is a convenience method, useful when the parent logger is "
"named using e.g. ``__name__`` rather than a literal string."
msgstr ""
"Возвращает регистратор, который является потомком этого регистратора, как "
"определено суффиксом. Таким образом, ``logging.getLogger('abc')."
"getChild('def.ghi')`` вернет тот же регистратор, который был бы возвращен "
"``logging.getLogger('abc.def.ghi')``. Это удобный метод, полезный, когда имя "
"родительского регистратора используется, например, с использованием "
"``__name__``, а не буквальной строки."

#: ../../library/logging.rst:252
msgid ""
"Returns a set of loggers which are immediate children of this logger. So for "
"example ``logging.getLogger().getChildren()`` might return a set containing "
"loggers named ``foo`` and ``bar``, but a logger named ``foo.bar`` wouldn't "
"be included in the set. Likewise, ``logging.getLogger('foo').getChildren()`` "
"might return a set including a logger named ``foo.bar``, but it wouldn't "
"include one named ``foo.bar.baz``."
msgstr ""
"Возвращает набор средств ведения журнала, которые являются непосредственными "
"дочерними элементами данного средства ведения журнала. Так, например, "
"``logging.getLogger().getChildren()`` может возвращать набор, содержащий "
"регистраторы с именами ``foo`` и ``bar``, но регистратор с именем ``foo."
"bar`` не будет входит в комплект. Аналогично, logging.getLogger('foo')."
"getChildren() может возвращать набор, включающий регистратор с именем foo."
"bar, но не будет включать в себя регистратор с именем foo.bar.baz. `."

#: ../../library/logging.rst:264
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the "
"message format string, and the *args* are the arguments which are merged "
"into *msg* using the string formatting operator. (Note that this means that "
"you can use keywords in the format string, together with a single dictionary "
"argument.) No % formatting operation is performed on *msg* when no *args* "
"are supplied."
msgstr ""
"Регистрирует сообщение с уровнем :const:`DEBUG` в этом регистраторе. *msg* — "
"это строка формата сообщения, а *args* — это аргументы, которые объединяются "
"в *msg* с помощью оператора форматирования строки. (Обратите внимание, что "
"это означает, что вы можете использовать ключевые слова в строке формата "
"вместе с одним аргументом словаря.) Никакая операция форматирования % не "
"выполняется для *msg*, если не указаны *args*."

#: ../../library/logging.rst:270
msgid ""
"There are four keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, *stacklevel* and *extra*."
msgstr ""
"В *kwargs* проверяются четыре ключевых аргумента: *exc_info*, *stack_info*, "
"*stacklevel* и *extra*."

#: ../../library/logging.rst:273
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information to "
"be added to the logging message. If an exception tuple (in the format "
"returned by :func:`sys.exc_info`) or an exception instance is provided, it "
"is used; otherwise, :func:`sys.exc_info` is called to get the exception "
"information."
msgstr ""
"Если *exc_info* не оценивается как ложное, это приводит к добавлению "
"информации об исключении в сообщение журнала. Если предоставлен кортеж "
"исключения (в формате, возвращаемом :func:`sys.exc_info`) или экземпляр "
"исключения, он используется; в противном случае вызывается :func:`sys."
"exc_info` для получения информации об исключении."

#: ../../library/logging.rst:278
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former is "
"stack frames from the bottom of the stack up to the logging call in the "
"current thread, whereas the latter is information about stack frames which "
"have been unwound, following an exception, while searching for exception "
"handlers."
msgstr ""
"Второй необязательный аргумент ключевого слова — *stack_info*, который по "
"умолчанию имеет значение «False». Если это правда, к сообщению журнала "
"добавляется информация о стеке, включая фактический вызов журнала. Обратите "
"внимание, что это не та же самая информация стека, которая отображается при "
"указании *exc_info*: первая представляет собой кадры стека от нижней части "
"стека до вызова журнала в текущем потоке, тогда как последняя представляет "
"собой информацию о кадрах стека, которые были раскручивается после "
"исключения, при поиске обработчиков исключений."

#: ../../library/logging.rst:287
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just show "
"how you got to a certain point in your code, even when no exceptions were "
"raised. The stack frames are printed following a header line which says:"
msgstr ""
"Вы можете указать *stack_info* независимо от *exc_info*, например, чтобы "
"просто показать, как вы дошли до определенного момента в вашем коде, даже "
"если никаких исключений не возникло. Кадры стека печатаются после строки "
"заголовка, в которой говорится:"

#: ../../library/logging.rst:291
msgid "Stack (most recent call last):"
msgstr "Стек (последний вызов последний):"

#: ../../library/logging.rst:295
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when "
"displaying exception frames."
msgstr ""
"Это имитирует ``Traceback (последний вызов последний):``, который "
"используется при отображении кадров исключений."

#: ../../library/logging.rst:298
msgid ""
"The third optional keyword argument is *stacklevel*, which defaults to "
"``1``. If greater than 1, the corresponding number of stack frames are "
"skipped when computing the line number and function name set in the :class:"
"`LogRecord` created for the logging event. This can be used in logging "
"helpers so that the function name, filename and line number recorded are not "
"the information for the helper function/method, but rather its caller. The "
"name of this parameter mirrors the equivalent one in the :mod:`warnings` "
"module."
msgstr ""
"Третий необязательный аргумент ключевого слова — *stacklevel*, который по "
"умолчанию равен «1». Если значение больше 1, соответствующее количество "
"кадров стека пропускается при вычислении номера строки и имени функции, "
"заданных в классе LogRecord, созданном для события регистрации. Это можно "
"использовать в вспомогательных функциях журналирования, чтобы записанные имя "
"функции, имя файла и номер строки не были информацией для вспомогательной "
"функции/метода, а скорее ее вызывающей стороны. Имя этого параметра "
"повторяет эквивалентное имя в модуле :mod:`warnings`."

#: ../../library/logging.rst:306
msgid ""
"The fourth keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the :attr:`~object.__dict__` of the :"
"class:`LogRecord` created for the logging event with user-defined "
"attributes. These custom attributes can then be used as you like. For "
"example, they could be incorporated into logged messages. For example::"
msgstr ""
"Четвертый аргумент ключевого слова — *extra*, который можно использовать для "
"передачи словаря, который используется для заполнения :attr:`~object."
"__dict__` :class:`LogRecord`, созданного для события регистрации, "
"определяемыми пользователем атрибутами. Эти пользовательские атрибуты затем "
"можно использовать по своему усмотрению. Например, они могут быть включены в "
"зарегистрированные сообщения. Например::"

#: ../../library/logging.rst:313
msgid ""
"FORMAT = '%(asctime)s %(clientip)-15s %(user)-8s %(message)s'\n"
"logging.basicConfig(format=FORMAT)\n"
"d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}\n"
"logger = logging.getLogger('tcpserver')\n"
"logger.warning('Protocol problem: %s', 'connection reset', extra=d)"
msgstr ""
"FORMAT = '%(asctime)s %(clientip)-15s %(user)-8s %(message)s'\n"
"logging.basicConfig(format=FORMAT)\n"
"d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}\n"
"logger = logging.getLogger('tcpserver')\n"
"logger.warning('Protocol problem: %s', 'connection reset', extra=d)"

#: ../../library/logging.rst:319
msgid "would print something like"
msgstr "напечатал бы что-то вроде"

#: ../../library/logging.rst:321
msgid ""
"2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection "
"reset"
msgstr ""
"2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection "
"reset"

#: ../../library/logging.rst:325
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the keys "
"used by the logging system. (See the section on :ref:`logrecord-attributes` "
"for more information on which keys are used by the logging system.)"
msgstr ""
"Ключи в словаре, переданные в *extra*, не должны конфликтовать с ключами, "
"используемыми системой журналирования. (Для получения дополнительной "
"информации о том, какие ключи используются системой журналирования, см. "
"раздел :ref:`logrecord-attributes`.)"

#: ../../library/logging.rst:329
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the :class:"
"`Formatter` has been set up with a format string which expects 'clientip' "
"and 'user' in the attribute dictionary of the :class:`LogRecord`. If these "
"are missing, the message will not be logged because a string formatting "
"exception will occur. So in this case, you always need to pass the *extra* "
"dictionary with these keys."
msgstr ""
"Если вы решите использовать эти атрибуты в зарегистрированных сообщениях, "
"вам необходимо проявить некоторую осторожность. В приведенном выше примере, "
"например, :class:`Formatter` был настроен со строкой формата, которая "
"ожидает \"clientip\" и \"user\" в словаре атрибутов :class:`LogRecord`. Если "
"они отсутствуют, сообщение не будет зарегистрировано, поскольку возникнет "
"исключение форматирования строки. Поэтому в этом случае вам всегда нужно "
"передавать *дополнительный* словарь с помощью этих ключей."

#: ../../library/logging.rst:336
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise are "
"dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it is "
"likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"Хотя это может раздражать, эта функция предназначена для использования в "
"особых обстоятельствах, таких как многопоточные серверы, где один и тот же "
"код выполняется во многих контекстах, и возникающие интересные условия "
"зависят от этого контекста (например, IP-адрес удаленного клиента и "
"аутентифицированный имя пользователя в приведенном выше примере). В таких "
"обстоятельствах вполне вероятно, что специализированные :class:`Formatter`\\ "
"будут использоваться с конкретными :class:`Handler`\\ s."

#: ../../library/logging.rst:343
msgid ""
"If no handler is attached to this logger (or any of its ancestors, taking "
"into account the relevant :attr:`Logger.propagate` attributes), the message "
"will be sent to the handler set on :data:`lastResort`."
msgstr ""
"Если к этому регистратору (или любому из его предков, принимая во внимание "
"соответствующие атрибуты :attr:`Logger.propagate`) не прикреплен обработчик, "
"сообщение будет отправлено обработчику, установленному в :data:`lastResort`."

#: ../../library/logging.rst:347
msgid "The *stack_info* parameter was added."
msgstr "Добавлен параметр *stack_info*."

#: ../../library/logging.rst:350
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "Параметр *exc_info* теперь может принимать экземпляры исключений."

#: ../../library/logging.rst:353
msgid "The *stacklevel* parameter was added."
msgstr "Был добавлен параметр *stacklevel*."

#: ../../library/logging.rst:359
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`INFO` в этом регистраторе. "
"Аргументы интерпретируются как для :meth:`debug`."

#: ../../library/logging.rst:365
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`WARNING` в этом регистраторе. "
"Аргументы интерпретируются как для :meth:`debug`."

#: ../../library/logging.rst:368
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"Существует устаревший метод «warn», который функционально идентичен "
"«предупреждению». Поскольку ``warn`` устарел, пожалуйста, не используйте его "
"- вместо этого используйте ``warning``."

#: ../../library/logging.rst:374
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`ERROR` в этом регистраторе. "
"Аргументы интерпретируются как для :meth:`debug`."

#: ../../library/logging.rst:380
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`CRITICAL` в этом регистраторе. "
"Аргументы интерпретируются как для :meth:`debug`."

#: ../../library/logging.rst:386
msgid ""
"Logs a message with integer level *level* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr ""
"Регистрирует сообщение целочисленного уровня *level* в этом регистраторе. "
"Остальные аргументы интерпретируются как для :meth:`debug`."

#: ../../library/logging.rst:392
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments are "
"interpreted as for :meth:`debug`. Exception info is added to the logging "
"message. This method should only be called from an exception handler."
msgstr ""
"Регистрирует сообщение с уровнем :const:`ERROR` в этом регистраторе. "
"Аргументы интерпретируются как для :meth:`debug`. Информация об исключении "
"добавляется в сообщение журнала. Этот метод следует вызывать только из "
"обработчика исключений."

#: ../../library/logging.rst:399
msgid "Adds the specified filter *filter* to this logger."
msgstr "Добавляет указанный фильтр *filter* в этот регистратор."

#: ../../library/logging.rst:404
msgid "Removes the specified filter *filter* from this logger."
msgstr "Удаляет указанный фильтр *filter* из этого регистратора."

#: ../../library/logging.rst:409
msgid ""
"Apply this logger's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be processed (passed to handlers). If one returns a false value, no further "
"processing of the record occurs."
msgstr ""
"Примените фильтры этого регистратора к записи и верните «True», если запись "
"должна быть обработана. Фильтры проверяются по очереди, пока один из них не "
"вернет ложное значение. Если ни один из них не вернет ложное значение, "
"запись будет обработана (передана обработчикам). Если возвращается ложное "
"значение, дальнейшая обработка записи не происходит."

#: ../../library/logging.rst:418
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "Добавляет указанный обработчик *hdlr* в этот регистратор."

#: ../../library/logging.rst:423
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "Удаляет указанный обработчик *hdlr* из этого регистратора."

#: ../../library/logging.rst:428
msgid ""
"Finds the caller's source filename and line number. Returns the filename, "
"line number, function name and stack information as a 4-element tuple. The "
"stack information is returned as ``None`` unless *stack_info* is ``True``."
msgstr ""
"Находит имя исходного файла и номер строки вызывающего абонента. Возвращает "
"имя файла, номер строки, имя функции и информацию о стеке в виде кортежа из "
"4 элементов. Информация стека возвращается как None, если *stack_info* не "
"имеет значения True."

#: ../../library/logging.rst:432
msgid ""
"The *stacklevel* parameter is passed from code calling the :meth:`debug` and "
"other APIs. If greater than 1, the excess is used to skip stack frames "
"before determining the values to be returned. This will generally be useful "
"when calling logging APIs from helper/wrapper code, so that the information "
"in the event log refers not to the helper/wrapper code, but to the code that "
"calls it."
msgstr ""
"Параметр *stacklevel* передается из кода, вызывающего :meth:`debug` и другие "
"API. Если значение больше 1, превышение используется для пропуска кадров "
"стека перед определением возвращаемых значений. Обычно это бывает полезно "
"при вызове API-интерфейсов ведения журнала из вспомогательного кода/кода-"
"оболочки, чтобы информация в журнале событий относилась не к "
"вспомогательному коду/коду-оболочке, а к коду, который его вызывает."

#: ../../library/logging.rst:442
msgid ""
"Handles a record by passing it to all handlers associated with this logger "
"and its ancestors (until a false value of *propagate* is found). This method "
"is used for unpickled records received from a socket, as well as those "
"created locally. Logger-level filtering is applied using :meth:`~Logger."
"filter`."
msgstr ""
"Обрабатывает запись, передавая ее всем обработчикам, связанным с этим "
"средством ведения журнала и его предками (до тех пор, пока не будет найдено "
"ложное значение *propagate*). Этот метод используется для незамеченных "
"записей, полученных из сокета, а также созданных локально. Фильтрация на "
"уровне регистратора применяется с помощью :meth:`~Logger.filter`."

#: ../../library/logging.rst:450
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr ""
"Это фабричный метод, который можно переопределить в подклассах для создания "
"специализированных экземпляров :class:`LogRecord`."

#: ../../library/logging.rst:455
msgid ""
"Checks to see if this logger has any handlers configured. This is done by "
"looking for handlers in this logger and its parents in the logger hierarchy. "
"Returns ``True`` if a handler was found, else ``False``. The method stops "
"searching up the hierarchy whenever a logger with the 'propagate' attribute "
"set to false is found - that will be the last logger which is checked for "
"the existence of handlers."
msgstr ""
"Проверяет, настроены ли для этого регистратора какие-либо обработчики. Это "
"делается путем поиска обработчиков в этом регистраторе и его родителях в "
"иерархии регистраторов. Возвращает ``True``, если обработчик был найден, "
"иначе ``False``. Метод прекращает поиск вверх по иерархии всякий раз, когда "
"обнаруживается средство ведения журнала с атрибутом «propagate», "
"установленным в значение false — это будет последнее средство ведения "
"журнала, которое проверяется на наличие обработчиков."

#: ../../library/logging.rst:464
msgid "Loggers can now be pickled and unpickled."
msgstr "Loggers can now be pickled and unpickled."

#: ../../library/logging.rst:470
msgid "Logging Levels"
msgstr "Уровни логирования"

#: ../../library/logging.rst:472
msgid ""
"The numeric values of logging levels are given in the following table. These "
"are primarily of interest if you want to define your own levels, and need "
"them to have specific values relative to the predefined levels. If you "
"define a level with the same numeric value, it overwrites the predefined "
"value; the predefined name is lost."
msgstr ""
"Числовые значения уровней ведения журнала приведены в следующей таблице. Они "
"в первую очередь представляют интерес, если вы хотите определить свои "
"собственные уровни и хотите, чтобы они имели определенные значения "
"относительно предопределенных уровней. Если вы определяете уровень с тем же "
"числовым значением, он перезаписывает предопределенное значение; "
"предопределенное имя потеряно."

#: ../../library/logging.rst:479
msgid "Level"
msgstr "Уровень"

#: ../../library/logging.rst:479
msgid "Numeric value"
msgstr "Числовое значение"

#: ../../library/logging.rst:479
msgid "What it means / When to use it"
msgstr "Что это значит / Когда это использовать"

#: ../../library/logging.rst:481
msgid "0"
msgstr "0"

#: ../../library/logging.rst:481
msgid ""
"When set on a logger, indicates that ancestor loggers are to be consulted to "
"determine the effective level. If that still resolves to :const:`!NOTSET`, "
"then all events are logged. When set on a handler, all events are handled."
msgstr ""
"При установке на регистраторе указывает, что для определения эффективного "
"уровня необходимо проконсультироваться с родительскими регистраторами. Если "
"это по-прежнему приводит к :const:`!NOTSET`, то все события записываются. "
"Если он установлен в обработчике, обрабатываются все события."

#: ../../library/logging.rst:489
msgid "10"
msgstr "10"

#: ../../library/logging.rst:489
msgid ""
"Detailed information, typically only of interest to a developer trying to "
"diagnose a problem."
msgstr ""
"Подробная информация, обычно представляющая интерес только для разработчика, "
"пытающегося диагностировать проблему."

#: ../../library/logging.rst:493
msgid "20"
msgstr "20"

#: ../../library/logging.rst:493
msgid "Confirmation that things are working as expected."
msgstr "Подтверждение того, что все работает так, как ожидалось."

#: ../../library/logging.rst:496
msgid "30"
msgstr "30"

#: ../../library/logging.rst:496
msgid ""
"An indication that something unexpected happened, or that a problem might "
"occur in the near future (e.g. 'disk space low'). The software is still "
"working as expected."
msgstr ""
"Указание на то, что произошло что-то неожиданное или что в ближайшем будущем "
"может возникнуть проблема (например, «недостаточно места на диске»). "
"Программное обеспечение по-прежнему работает должным образом."

#: ../../library/logging.rst:503
msgid "40"
msgstr "40"

#: ../../library/logging.rst:503
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr ""
"Из-за более серьезной проблемы программное обеспечение не смогло выполнить "
"некоторые функции."

#: ../../library/logging.rst:507
msgid "50"
msgstr "50"

#: ../../library/logging.rst:507
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr ""
"Серьезная ошибка, указывающая на то, что сама программа, возможно, не сможет "
"продолжить работу."

#: ../../library/logging.rst:516
msgid "Handler Objects"
msgstr "Объекты-обработчики"

#: ../../library/logging.rst:518
msgid ""
"Handlers have the following attributes and methods. Note that :class:"
"`Handler` is never instantiated directly; this class acts as a base for more "
"useful subclasses. However, the :meth:`!__init__` method in subclasses needs "
"to call :meth:`Handler.__init__`."
msgstr ""
"Обработчики имеют следующие атрибуты и методы. Обратите внимание, что :class:"
"`Handler` никогда не создается напрямую; этот класс служит основой для более "
"полезных подклассов. Однако метод :meth:`!__init__` в подклассах должен "
"вызывать :meth:`Handler.__init__`."

#: ../../library/logging.rst:527
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting the "
"list of filters to the empty list and creating a lock (using :meth:"
"`createLock`) for serializing access to an I/O mechanism."
msgstr ""
"Инициализирует экземпляр :class:`Handler`, устанавливая его уровень, "
"устанавливая пустой список фильтров и создавая блокировку (используя :meth:"
"`createLock`) для сериализации доступа к механизму ввода-вывода."

#: ../../library/logging.rst:534
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr ""
"Инициализирует блокировку потока, которую можно использовать для "
"сериализации доступа к базовым функциям ввода-вывода, которые могут не быть "
"потокобезопасными."

#: ../../library/logging.rst:540
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr "Получает блокировку потока, созданную с помощью :meth:`createLock`."

#: ../../library/logging.rst:545
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr "Освобождает блокировку потока, полученную с помощью :meth:`acquire`."

#: ../../library/logging.rst:550
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which are "
"less severe than *level* will be ignored. When a handler is created, the "
"level is set to :const:`NOTSET` (which causes all messages to be processed)."
msgstr ""
"Устанавливает порог для этого обработчика на *уровень*. Сообщения журнала, "
"менее серьезные, чем *уровень*, будут игнорироваться. При создании "
"обработчика устанавливается уровень :const:`NOTSET` (что приводит к "
"обработке всех сообщений)."

#: ../../library/logging.rst:557
msgid ""
"The *level* parameter now accepts a string representation of the level such "
"as 'INFO' as an alternative to the integer constants such as :const:`INFO`."
msgstr ""
"Параметр *level* теперь принимает строковое представление уровня, например "
"INFO, в качестве альтернативы целочисленным константам, таким как :const:"
"`INFO`."

#: ../../library/logging.rst:565
msgid ""
"Sets the formatter for this handler to *fmt*. The *fmt* argument must be a :"
"class:`Formatter` instance or ``None``."
msgstr ""

#: ../../library/logging.rst:571
msgid "Adds the specified filter *filter* to this handler."
msgstr "Добавляет указанный фильтр *filter* к этому обработчику."

#: ../../library/logging.rst:576
msgid "Removes the specified filter *filter* from this handler."
msgstr "Удаляет указанный фильтр *filter* из этого обработчика."

#: ../../library/logging.rst:581
msgid ""
"Apply this handler's filters to the record and return ``True`` if the record "
"is to be processed. The filters are consulted in turn, until one of them "
"returns a false value. If none of them return a false value, the record will "
"be emitted. If one returns a false value, the handler will not emit the "
"record."
msgstr ""
"Примените фильтры этого обработчика к записи и верните True, если запись "
"должна быть обработана. Фильтры проверяются по очереди, пока один из них не "
"вернет ложное значение. Если ни один из них не вернет ложное значение, "
"запись будет создана. Если возвращается ложное значение, обработчик не "
"выдаст запись."

#: ../../library/logging.rst:590
msgid ""
"Ensure all logging output has been flushed. This version does nothing and is "
"intended to be implemented by subclasses."
msgstr ""
"Убедитесь, что все выходные данные журнала очищены. Эта версия ничего не "
"делает и предназначена для реализации в подклассах."

#: ../../library/logging.rst:596
msgid ""
"Tidy up any resources used by the handler. This version does no output but "
"removes the handler from an internal map of handlers, which is used for "
"handler lookup by name."
msgstr ""
"Очистите все ресурсы, используемые обработчиком. Эта версия не выводит "
"данные, но удаляет обработчик из внутренней карты обработчиков, которая "
"используется для поиска обработчика по имени."

#: ../../library/logging.rst:600
msgid ""
"Subclasses should ensure that this gets called from overridden :meth:`close` "
"methods."
msgstr ""

#: ../../library/logging.rst:606
msgid ""
"Conditionally emits the specified logging record, depending on filters which "
"may have been added to the handler. Wraps the actual emission of the record "
"with acquisition/release of the I/O thread lock."
msgstr ""
"Условно выдает указанную запись журнала, в зависимости от фильтров, которые "
"могли быть добавлены в обработчик. Обертывает фактическую отправку записи с "
"получением/снятием блокировки потока ввода-вывода."

#: ../../library/logging.rst:613
msgid ""
"This method should be called from handlers when an exception is encountered "
"during an :meth:`emit` call. If the module-level attribute :data:"
"`raiseExceptions` is ``False``, exceptions get silently ignored. This is "
"what is mostly wanted for a logging system - most users will not care about "
"errors in the logging system, they are more interested in application "
"errors. You could, however, replace this with a custom handler if you wish. "
"The specified record is the one which was being processed when the exception "
"occurred. (The default value of :data:`raiseExceptions` is ``True``, as that "
"is more useful during development)."
msgstr ""
"Этот метод следует вызывать из обработчиков, когда во время вызова :meth:"
"`emit` встречается исключение. Если атрибут уровня модуля :data:"
"`raiseExceptions` имеет значение ``False``, исключения игнорируются. Это то, "
"чего больше всего хотят от системы журналирования — большинство "
"пользователей не будут интересоваться ошибками в системе журналирования, их "
"больше интересуют ошибки приложений. Однако при желании вы можете заменить "
"его собственным обработчиком. Указанная запись — это та, которая "
"обрабатывалась в момент возникновения исключения. (Значение по умолчанию :"
"data:`raiseExceptions` — ``True``, так как это более полезно во время "
"разработки)."

#: ../../library/logging.rst:626
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, use "
"the default formatter for the module."
msgstr ""
"Выполнить форматирование записи – если установлен форматтер, используйте "
"его. В противном случае используйте форматировщик по умолчанию для модуля."

#: ../../library/logging.rst:632
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a :exc:"
"`NotImplementedError`."
msgstr ""
"Сделайте все возможное, чтобы фактически зарегистрировать указанную запись "
"журнала. Эта версия предназначена для реализации подклассами и поэтому "
"вызывает ошибку :exc:`NotImplementedError`."

#: ../../library/logging.rst:636
msgid ""
"This method is called after a handler-level lock is acquired, which is "
"released after this method returns. When you override this method, note that "
"you should be careful when calling anything that invokes other parts of the "
"logging API which might do locking, because that might result in a deadlock. "
"Specifically:"
msgstr ""
"Этот метод вызывается после получения блокировки на уровне обработчика, "
"которая снимается после возврата этого метода. При переопределении этого "
"метода обратите внимание, что вам следует быть осторожным при вызове всего, "
"что вызывает другие части API ведения журнала, которые могут выполнять "
"блокировку, поскольку это может привести к взаимоблокировке. Конкретно:"

#: ../../library/logging.rst:642
msgid ""
"Logging configuration APIs acquire the module-level lock, and then "
"individual handler-level locks as those handlers are configured."
msgstr ""
"API конфигурации ведения журнала получают блокировку на уровне модуля, а "
"затем отдельные блокировки на уровне обработчика по мере настройки этих "
"обработчиков."

#: ../../library/logging.rst:645
msgid ""
"Many logging APIs lock the module-level lock. If such an API is called from "
"this method, it could cause a deadlock if a configuration call is made on "
"another thread, because that thread will try to acquire the module-level "
"lock *before* the handler-level lock, whereas this thread tries to acquire "
"the module-level lock *after* the handler-level lock (because in this "
"method, the handler-level lock has already been acquired)."
msgstr ""
"Многие API-интерфейсы ведения журналов блокируют блокировку на уровне "
"модуля. Если такой API вызывается из этого метода, это может вызвать "
"взаимоблокировку, если вызов конфигурации выполняется в другом потоке, "
"поскольку этот поток попытается получить блокировку уровня модуля *перед* "
"блокировкой уровня обработчика, тогда как этот поток пытается для получения "
"блокировки уровня модуля *после* блокировки уровня обработчика (поскольку в "
"этом методе блокировка уровня обработчика уже получена)."

#: ../../library/logging.rst:652
msgid ""
"For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr "Список стандартных обработчиков см. в разделе :mod:`logging.handlers`."

#: ../../library/logging.rst:657
msgid "Formatter Objects"
msgstr "Объекты форматера"

#: ../../library/logging.rst:663
msgid ""
"Responsible for converting a :class:`LogRecord` to an output string to be "
"interpreted by a human or external system."
msgstr ""
"Отвечает за преобразование :class:`LogRecord` в выходную строку, которая "
"будет интерпретирована человеком или внешней системой."

#: ../../library/logging.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../../library/logging.rst:666
msgid ""
"A format string in the given *style* for the logged output as a whole. The "
"possible mapping keys are drawn from the :class:`LogRecord` object's :ref:"
"`logrecord-attributes`. If not specified, ``'%(message)s'`` is used, which "
"is just the logged message."
msgstr ""
"Строка формата в заданном *стиле* для зарегистрированного вывода в целом. "
"Возможные ключи сопоставления извлекаются из объекта :class:`LogRecord` :ref:"
"`logrecord-attributes`. Если не указано, ``' %(сообщение)с используется '``, "
"который представляет собой просто зарегистрированное сообщение."

#: ../../library/logging.rst:674
msgid ""
"A format string in the given *style* for the date/time portion of the logged "
"output. If not specified, the default described in :meth:`formatTime` is "
"used."
msgstr ""
"Строка формата в заданном *стиле* для части даты/времени записываемого "
"вывода. Если не указано, используется значение по умолчанию, описанное в :"
"meth:`formatTime`."

#: ../../library/logging.rst:679
msgid ""
"Can be one of ``'%'``, ``'{'`` or ``'$'`` and determines how the format "
"string will be merged with its data: using one of :ref:`old-string-"
"formatting` (``%``), :meth:`str.format` (``{``) or :class:`string.Template` "
"(``$``). This only applies to *fmt* and *datefmt* (e.g. ``'%(message)s'`` "
"versus ``'{message}'``), not to the actual log messages passed to the "
"logging methods. However, there are :ref:`other ways <formatting-styles>` to "
"use ``{``- and ``$``-formatting for log messages."
msgstr ""
"Может быть одним из ``'%'``, ``'{'`` или ``'$'`` и определяет, как строка "
"формата будет объединена с ее данными: используя один из :ref:`old-string -"
"formatting` (``%``), :meth:`str.format` (``{``) или :class:`string.Template` "
"(``$``). Это применимо только к *fmt* и *datefmt* (например, ``' "
"%(сообщение)с '`` по сравнению с ``'{message}'``), а не фактическими "
"сообщениями журнала, передаваемыми методам журналирования. Однако "
"существуют :ref:`другие способы <formatting-styles>` использовать ``{``- и "
"``$``-форматирование для сообщений журнала."

#: ../../library/logging.rst:689
msgid ""
"If ``True`` (the default), incorrect or mismatched *fmt* and *style* will "
"raise a :exc:`ValueError`; for example, ``logging.Formatter('%(asctime)s - "
"%(message)s', style='{')``."
msgstr ""
"Если ``True`` (по умолчанию), неправильные или несовпадающие *fmt* и *style* "
"вызовут ошибку :exc:`ValueError`; например, ``logging.Formatter(' %(время по "
"возрастанию) с - %(сообщение)с ', стиль='{')``."

#: ../../library/logging.rst:694
msgid ""
"A dictionary with default values to use in custom fields. For example, "
"``logging.Formatter('%(ip)s %(message)s', defaults={\"ip\": None})``"
msgstr ""
"Словарь со значениями по умолчанию для использования в настраиваемых полях. "
"Например, ``logging.Formatter(' %(ip)с %(сообщение)с ', defaults={\"ip\": "
"Нет})``"

#: ../../library/logging.rst:699
msgid "Added the *style* parameter."
msgstr "Добавлен параметр *style*."

#: ../../library/logging.rst:702
msgid "Added the *validate* parameter."
msgstr "Добавлен параметр *validate*."

#: ../../library/logging.rst:705
msgid "Added the *defaults* parameter."
msgstr "Добавлен параметр *defaults*."

#: ../../library/logging.rst:711
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the "
"dictionary, a couple of preparatory steps are carried out. The *message* "
"attribute of the record is computed using *msg* % *args*. If the formatting "
"string contains ``'(asctime)'``, :meth:`formatTime` is called to format the "
"event time. If there is exception information, it is formatted using :meth:"
"`formatException` and appended to the message. Note that the formatted "
"exception information is cached in attribute *exc_text*. This is useful "
"because the exception information can be pickled and sent across the wire, "
"but you should be careful if you have more than one :class:`Formatter` "
"subclass which customizes the formatting of exception information. In this "
"case, you will have to clear the cached value (by setting the *exc_text* "
"attribute to ``None``) after a formatter has done its formatting, so that "
"the next formatter to handle the event doesn't use the cached value, but "
"recalculates it afresh."
msgstr ""
"Словарь атрибутов записи используется в качестве операнда операции "
"форматирования строки. Возвращает результирующую строку. Перед "
"форматированием словаря проводится пара подготовительных действий. Атрибут "
"*message* записи вычисляется с использованием *msg* % *args*. Если строка "
"форматирования содержит ``'(asctime)'`, :meth:`formatTime` вызывается для "
"форматирования времени события. Если есть информация об исключении, она "
"форматируется с использованием :meth:`formatException` и добавляется к "
"сообщению. Обратите внимание, что форматированная информация об исключении "
"кэшируется в атрибуте *exc_text*. Это полезно, поскольку информацию об "
"исключении можно собрать и отправить по сети, но следует быть осторожным, "
"если у вас имеется более одного подкласса :class:`Formatter`, который "
"настраивает форматирование информации об исключении. В этом случае вам "
"придется очистить кэшированное значение (установив для атрибута *exc_text* "
"значение ``None``) после того, как форматтер выполнит форматирование, чтобы "
"следующий форматтер, обрабатывающий событие, не использовал кэшированное "
"значение. значение, но пересчитывает его заново."

#: ../../library/logging.rst:727
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr ""
"Если информация стека доступна, она добавляется после информации об "
"исключении, используя :meth:`formatStack` для ее преобразования при "
"необходимости."

#: ../../library/logging.rst:733
msgid ""
"This method should be called from :meth:`format` by a formatter which wants "
"to make use of a formatted time. This method can be overridden in formatters "
"to provide for any specific requirement, but the basic behavior is as "
"follows: if *datefmt* (a string) is specified, it is used with :func:`time."
"strftime` to format the creation time of the record. Otherwise, the format "
"'%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part is a millisecond value "
"and the other letters are as per the :func:`time.strftime` documentation.  "
"An example time in this format is ``2003-01-23 00:29:50,411``.  The "
"resulting string is returned."
msgstr ""
"Этот метод должен вызываться из :meth:`format` формататором, который хочет "
"использовать форматированное время. Этот метод можно переопределить в "
"средствах форматирования для удовлетворения любых конкретных требований, но "
"основное поведение заключается в следующем: если указан *datefmt* (строка), "
"он используется с :func:`time.strftime` для форматирования времени создания. "
"записи. В противном случае формат '%Y-%m- %д Используется %H:%M:%S,uuu', где "
"часть uuu представляет собой значение в миллисекундах, а остальные буквы "
"соответствуют документации :func:`time.strftime`. Пример времени в этом "
"формате: «2003-01-23 00:29:50,411». Возвращается результирующая строка."

#: ../../library/logging.rst:743
msgid ""
"This function uses a user-configurable function to convert the creation time "
"to a tuple. By default, :func:`time.localtime` is used; to change this for a "
"particular formatter instance, set the ``converter`` attribute to a function "
"with the same signature as :func:`time.localtime` or :func:`time.gmtime`. To "
"change it for all formatters, for example if you want all logging times to "
"be shown in GMT, set the ``converter`` attribute in the ``Formatter`` class."
msgstr ""
"Эта функция использует настраиваемую пользователем функцию для "
"преобразования времени создания в кортеж. По умолчанию используется :func:"
"`time.localtime`; чтобы изменить это для конкретного экземпляра форматтера, "
"установите атрибут ``converter`` для функции с той же сигнатурой, что и :"
"func:`time.localtime` или :func:`time.gmtime`. Чтобы изменить его для всех "
"форматтеров, например, если вы хотите, чтобы все время регистрации "
"отображалось по Гринвичу, установите атрибут ``converter`` в классе "
"``Formatter``."

#: ../../library/logging.rst:751
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by a "
"strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after the "
"comma is a millisecond value. Because strptime does not have a format "
"placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings "
"have been hardcoded into this method. With the change, these strings are "
"defined as class-level attributes which can be overridden at the instance "
"level when desired. The names of the attributes are ``default_time_format`` "
"(for the strptime format string) and ``default_msec_format`` (for appending "
"the millisecond value)."
msgstr ""
"Раньше формат по умолчанию был жестко запрограммирован, как в этом примере: "
"``2010-09-06 22:38:15,292``, где часть перед запятой обрабатывалась строкой "
"формата strptime (``'%Y-%m - %д %H:%M:%S'``), а часть после запятой "
"представляет собой значение в миллисекундах. Поскольку в strptime нет "
"заполнителя формата для миллисекунд, значение миллисекунды добавляется с "
"использованием другой строки формата ``' %s , %03d '`` --- и обе эти строки "
"формата жестко закодированы в этом методе. После изменения эти строки "
"определяются как атрибуты уровня класса, которые при желании можно "
"переопределить на уровне экземпляра. Имена атрибутов: "
"«default_time_format» (для строки формата strptime) и "
"«default_msec_format» (для добавления значения миллисекунды)."

#: ../../library/logging.rst:764
msgid "The ``default_msec_format`` can be ``None``."
msgstr "``default_msec_format`` может быть ``None``."

#: ../../library/logging.rst:769
msgid ""
"Formats the specified exception information (a standard exception tuple as "
"returned by :func:`sys.exc_info`) as a string. This default implementation "
"just uses :func:`traceback.print_exception`. The resulting string is "
"returned."
msgstr ""
"Форматирует указанную информацию об исключении (стандартный кортеж "
"исключения, возвращаемый :func:`sys.exc_info`) в виде строки. Эта реализация "
"по умолчанию просто использует :func:`traceback.print_Exception`. "
"Возвращается результирующая строка."

#: ../../library/logging.rst:776
msgid ""
"Formats the specified stack information (a string as returned by :func:"
"`traceback.print_stack`, but with the last newline removed) as a string. "
"This default implementation just returns the input value."
msgstr ""
"Форматирует указанную информацию стека (строку, возвращаемую :func:"
"`traceback.print_stack`, но с удаленной последней новой строкой) как строку. "
"Эта реализация по умолчанию просто возвращает входное значение."

#: ../../library/logging.rst:782
msgid ""
"A base formatter class suitable for subclassing when you want to format a "
"number of records. You can pass a :class:`Formatter` instance which you want "
"to use to format each line (that corresponds to a single record). If not "
"specified, the default formatter (which just outputs the event message) is "
"used as the line formatter."
msgstr ""
"Базовый класс форматтера, подходящий для создания подклассов, если вы хотите "
"отформатировать несколько записей. Вы можете передать экземпляр :class:"
"`Formatter`, который вы хотите использовать для форматирования каждой строки "
"(которая соответствует одной записи). Если не указано, форматировщик по "
"умолчанию (который просто выводит сообщение о событии) используется в "
"качестве форматировщика строки."

#: ../../library/logging.rst:790
msgid ""
"Return a header for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records, a title or a "
"separator line."
msgstr ""
"Возвращает заголовок списка *записей*. Базовая реализация просто возвращает "
"пустую строку. Вам нужно будет переопределить этот метод, если вы хотите "
"определенное поведение, например, чтобы показать количество записей, "
"заголовок или разделительную строку."

#: ../../library/logging.rst:797
msgid ""
"Return a footer for a list of *records*. The base implementation just "
"returns the empty string. You will need to override this method if you want "
"specific behaviour, e.g. to show the count of records or a separator line."
msgstr ""
"Возвращает нижний колонтитул для списка *записей*. Базовая реализация просто "
"возвращает пустую строку. Вам нужно будет переопределить этот метод, если вы "
"хотите определенное поведение, например, чтобы показать количество записей "
"или разделительную линию."

#: ../../library/logging.rst:804
msgid ""
"Return formatted text for a list of *records*. The base implementation just "
"returns the empty string if there are no records; otherwise, it returns the "
"concatenation of the header, each record formatted with the line formatter, "
"and the footer."
msgstr ""
"Возвращает форматированный текст для списка *записей*. Базовая реализация "
"просто возвращает пустую строку, если записей нет; в противном случае он "
"возвращает объединение заголовка, каждой записи, отформатированной с помощью "
"средства форматирования строк, и нижнего колонтитула."

#: ../../library/logging.rst:812
msgid "Filter Objects"
msgstr "Фильтр объектов"

#: ../../library/logging.rst:814
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class "
"only allows events which are below a certain point in the logger hierarchy. "
"For example, a filter initialized with 'A.B' will allow events logged by "
"loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not 'A.BB', 'B.A.B' etc. "
"If initialized with the empty string, all events are passed."
msgstr ""
"``Фильтры`` могут использоваться ``Handlers`` и ``Loggers`` для более "
"сложной фильтрации, чем предусмотрено уровнями. Базовый класс фильтра "
"допускает только события, находящиеся ниже определенной точки в иерархии "
"журнала. Например, фильтр, инициализированный с помощью «AB», будет "
"разрешать события, регистрируемые регистраторами «AB», «ABC», «ABCD», «ABD» "
"и т. д., но не «A.BB», «BAB» и т. д. Если инициализироваться с помощью "
"пустая строка, все события передаются."

#: ../../library/logging.rst:824
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified, it "
"names a logger which, together with its children, will have its events "
"allowed through the filter. If *name* is the empty string, allows every "
"event."
msgstr ""
"Возвращает экземпляр класса :class:`Filter`. Если указано *name*, оно дает "
"имя регистратору, события которого вместе с его дочерними элементами будут "
"разрешены через фильтр. Если *name* — пустая строка, разрешено любое событие."

#: ../../library/logging.rst:831
msgid ""
"Is the specified record to be logged? Returns false for no, true for yes. "
"Filters can either modify log records in-place or return a completely "
"different record instance which will replace the original log record in any "
"future processing of the event."
msgstr ""
"Должна ли быть зарегистрирована указанная запись? Возвращает false в случае "
"«нет», true в случае «да». Фильтры могут либо изменять записи журнала на "
"месте, либо возвращать совершенно другой экземпляр записи, который заменит "
"исходную запись журнала при любой будущей обработке события."

#: ../../library/logging.rst:836
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted "
"whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have been "
"generated by descendant loggers will not be filtered by a logger's filter "
"setting, unless the filter has also been applied to those descendant loggers."
msgstr ""
"Обратите внимание, что к фильтрам, прикрепленным к обработчикам, обращаются "
"до того, как обработчик генерирует событие, тогда как к фильтрам, "
"прикрепленным к средствам ведения журнала, обращаются всякий раз, когда "
"событие регистрируется (с использованием :meth:`debug`, :meth:`info` и "
"т. д.), прежде чем отправка события обработчикам. Это означает, что события, "
"сгенерированные дочерними регистраторами, не будут фильтроваться настройкой "
"фильтра регистратора, если только фильтр не был также применен к этим "
"дочерним регистраторам."

#: ../../library/logging.rst:843
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance "
"which has a ``filter`` method with the same semantics."
msgstr ""
"На самом деле вам не нужно создавать подкласс ``Filter``: вы можете передать "
"любой экземпляр, имеющий метод ``filter`` с той же семантикой."

#: ../../library/logging.rst:846
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other callable) "
"as a filter. The filtering logic will check to see if the filter object has "
"a ``filter`` attribute: if it does, it's assumed to be a ``Filter`` and its :"
"meth:`~Filter.filter` method is called. Otherwise, it's assumed to be a "
"callable and called with the record as the single parameter. The returned "
"value should conform to that returned by :meth:`~Filter.filter`."
msgstr ""
"Вам не нужно создавать специализированные классы Filter или использовать "
"другие классы с методом filter: вы можете использовать функцию (или другой "
"вызываемый объект) в качестве фильтра. Логика фильтрации проверит, имеет ли "
"объект фильтра атрибут filter: если да, то предполагается, что это фильтр, и "
"вызывается его метод :meth:`~Filter.filter`. В противном случае "
"предполагается, что он является вызываемым и вызывается с записью в качестве "
"единственного параметра. Возвращаемое значение должно соответствовать "
"значению, возвращаемому :meth:`~Filter.filter`."

#: ../../library/logging.rst:856
msgid ""
"You can now return a :class:`LogRecord` instance from filters to replace the "
"log record rather than modifying it in place. This allows filters attached "
"to a :class:`Handler` to modify the log record before it is emitted, without "
"having side effects on other handlers."
msgstr ""
"Теперь вы можете вернуть экземпляр :class:`LogRecord` из фильтров, чтобы "
"заменить запись журнала, а не изменять ее на месте. Это позволяет фильтрам, "
"прикрепленным к :class:`Handler`, изменять запись журнала до ее создания, не "
"оказывая побочных эффектов на другие обработчики."

#: ../../library/logging.rst:862
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is "
"processed by the handler or logger they're attached to: this can be useful "
"if you want to do things like counting how many records were processed by a "
"particular logger or handler, or adding, changing or removing attributes in "
"the :class:`LogRecord` being processed. Obviously changing the LogRecord "
"needs to be done with some care, but it does allow the injection of "
"contextual information into logs (see :ref:`filters-contextual`)."
msgstr ""
"Хотя фильтры используются в основном для фильтрации записей на основе более "
"сложных критериев, чем уровни, они могут видеть каждую запись, обработанную "
"обработчиком или регистратором, к которому они подключены: это может быть "
"полезно, если вы хотите делать такие вещи, как подсчет количества записи "
"были обработаны определенным регистратором или обработчиком, а также были "
"добавлены, изменены или удалены атрибуты в обрабатываемом :class:"
"`LogRecord`. Очевидно, что изменение LogRecord требует некоторой "
"осторожности, но оно позволяет вводить контекстную информацию в журналы "
"(см. :ref:`filters-contextual`)."

#: ../../library/logging.rst:875
msgid "LogRecord Objects"
msgstr "Объекты записи журнала"

#: ../../library/logging.rst:877
msgid ""
":class:`LogRecord` instances are created automatically by the :class:"
"`Logger` every time something is logged, and can be created manually via :"
"func:`makeLogRecord` (for example, from a pickled event received over the "
"wire)."
msgstr ""
"Экземпляры :class:`LogRecord` создаются автоматически :class:`Logger` каждый "
"раз, когда что-то регистрируется, и могут быть созданы вручную с помощью :"
"func:`makeLogRecord` (например, из маринованного события, полученного по "
"сети)."

#: ../../library/logging.rst:885
msgid "Contains all the information pertinent to the event being logged."
msgstr "Содержит всю информацию, относящуюся к регистрируемому событию."

#: ../../library/logging.rst:887
msgid ""
"The primary information is passed in *msg* and *args*, which are combined "
"using ``msg % args`` to create the :attr:`!message` attribute of the record."
msgstr ""
"Первичная информация передается в *msg* и *args*, которые объединяются с "
"помощью ``msg % args`` для создания атрибута :attr:`!message` записи."

#: ../../library/logging.rst:891
msgid ""
"The name of the logger used to log the event represented by this :class:`!"
"LogRecord`. Note that the logger name in the :class:`!LogRecord` will always "
"have this value, even though it may be emitted by a handler attached to a "
"different (ancestor) logger."
msgstr ""
"Имя регистратора, используемого для регистрации события, представленного "
"этим :class:`!LogRecord`. Обратите внимание, что имя регистратора в :class:`!"
"LogRecord` всегда будет иметь это значение, даже если оно может быть выдано "
"обработчиком, прикрепленным к другому (предковому) регистратору."

#: ../../library/logging.rst:899
msgid ""
"The :ref:`numeric level <levels>` of the logging event (such as ``10`` for "
"``DEBUG``, ``20`` for ``INFO``, etc). Note that this is converted to *two* "
"attributes of the LogRecord: :attr:`!levelno` for the numeric value and :"
"attr:`!levelname` for the corresponding level name."
msgstr ""
":ref:`числовой уровень <levels>` события регистрации (например, ``10`` для "
"``DEBUG``, ``20`` для ``INFO`` и т. д.). Обратите внимание, что это "
"преобразуется в *два* атрибута LogRecord: :attr:`!levelno` для числового "
"значения и :attr:`!levelname` для соответствующего имени уровня."

#: ../../library/logging.rst:906
msgid ""
"The full string path of the source file where the logging call was made."
msgstr ""
"Полный строковый путь к исходному файлу, в котором был выполнен вызов "
"журнала."

#: ../../library/logging.rst:910
msgid "The line number in the source file where the logging call was made."
msgstr "Номер строки в исходном файле, где был выполнен вызов журнала."

#: ../../library/logging.rst:914
msgid ""
"The event description message, which can be a %-format string with "
"placeholders for variable data, or an arbitrary object (see :ref:`arbitrary-"
"object-messages`)."
msgstr ""
"Сообщение с описанием события, которое может быть %-f Строка формата с "
"заполнителями для переменных данных или произвольного объекта (см. :ref:"
"`произвольные-объектные-сообщения`)."

#: ../../library/logging.rst:919
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr ""
"Переменные данные, которые нужно объединить с аргументом *msg* для получения "
"описания события."

#: ../../library/logging.rst:923
msgid ""
"An exception tuple with the current exception information, as returned by :"
"func:`sys.exc_info`, or ``None`` if no exception information is available."
msgstr ""
"Кортеж исключений с текущей информацией об исключении, возвращаемой :func:"
"`sys.exc_info`, или ``None``, если информация об исключении недоступна."

#: ../../library/logging.rst:928
msgid ""
"The name of the function or method from which the logging call was invoked."
msgstr "Имя функции или метода, из которого был вызван вызов журнала."

#: ../../library/logging.rst:932
msgid ""
"A text string representing stack information from the base of the stack in "
"the current thread, up to the logging call."
msgstr ""
"Текстовая строка, представляющая информацию о стеке от основания стека в "
"текущем потоке до вызова журнала."

#: ../../library/logging.rst:939
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging any "
"user-supplied arguments with the message. If the user-supplied message "
"argument to the logging call is not a string, :func:`str` is called on it to "
"convert it to a string. This allows use of user-defined classes as messages, "
"whose ``__str__`` method can return the actual format string to be used."
msgstr ""
"Возвращает сообщение для этого экземпляра :class:`LogRecord` после "
"объединения любых предоставленных пользователем аргументов с сообщением. "
"Если аргумент сообщения, предоставленный пользователем для вызова журнала, "
"не является строкой, для него вызывается :func:`str` для преобразования его "
"в строку. Это позволяет использовать определяемые пользователем классы в "
"качестве сообщений, чей метод ``__str__`` может возвращать фактическую "
"строку формата, которая будет использоваться."

#: ../../library/logging.rst:946
msgid ""
"The creation of a :class:`LogRecord` has been made more configurable by "
"providing a factory which is used to create the record. The factory can be "
"set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` (see "
"this for the factory's signature)."
msgstr ""
"Создание :class:`LogRecord` стало более настраиваемым благодаря "
"предоставлению фабрики, которая используется для создания записи. Фабрику "
"можно установить с помощью :func:`getLogRecordFactory` и :func:"
"`setLogRecordFactory` (см. здесь сигнатуру фабрики)."

#: ../../library/logging.rst:952
msgid ""
"This functionality can be used to inject your own values into a :class:"
"`LogRecord` at creation time. You can use the following pattern::"
msgstr ""
"Эту функциональность можно использовать для добавления ваших собственных "
"значений в LogRecord во время создания. Вы можете использовать следующий "
"шаблон:"

#: ../../library/logging.rst:955
msgid ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"
msgstr ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"

#: ../../library/logging.rst:964
msgid ""
"With this pattern, multiple factories could be chained, and as long as they "
"don't overwrite each other's attributes or unintentionally overwrite the "
"standard attributes listed above, there should be no surprises."
msgstr ""
"С помощью этого шаблона можно объединить несколько фабрик в цепочку, и пока "
"они не перезаписывают атрибуты друг друга или непреднамеренно не "
"перезаписывают стандартные атрибуты, перечисленные выше, сюрпризов быть не "
"должно."

#: ../../library/logging.rst:973
msgid "LogRecord attributes"
msgstr "Атрибуты записи журнала"

#: ../../library/logging.rst:975
msgid ""
"The LogRecord has a number of attributes, most of which are derived from the "
"parameters to the constructor. (Note that the names do not always correspond "
"exactly between the LogRecord constructor parameters and the LogRecord "
"attributes.) These attributes can be used to merge data from the record into "
"the format string. The following table lists (in alphabetical order) the "
"attribute names, their meanings and the corresponding placeholder in a %-"
"style format string."
msgstr ""
"LogRecord имеет ряд атрибутов, большинство из которых являются производными "
"от параметров конструктора. (Обратите внимание, что имена не всегда точно "
"соответствуют параметрам конструктора LogRecord и атрибутам LogRecord.) Эти "
"атрибуты можно использовать для объединения данных из записи в строку "
"формата. В следующей таблице перечислены (в алфавитном порядке) имена "
"атрибутов, их значения и соответствующий заполнитель в %-s это строковый "
"формат."

#: ../../library/logging.rst:983
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use ``{attrname}"
"`` as the placeholder in the format string. If you are using $-formatting (:"
"class:`string.Template`), use the form ``${attrname}``. In both cases, of "
"course, replace ``attrname`` with the actual attribute name you want to use."
msgstr ""
"Если вы используете {}-форматирование (:func:`str.format`), вы можете "
"использовать ``{attrname}`` в качестве заполнителя в строке формата. Если вы "
"используете $-форматирование (:class:`string.Template`), используйте форму "
"``${attrname}``. В обоих случаях, конечно, замените ``attrname`` фактическим "
"именем атрибута, который вы хотите использовать."

#: ../../library/logging.rst:989
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing "
"them after the attribute name, separated from it with a colon. For example: "
"a placeholder of ``{msecs:03.0f}`` would format a millisecond value of ``4`` "
"as ``004``. Refer to the :meth:`str.format` documentation for full details "
"on the options available to you."
msgstr ""
"В случае {}-форматирования вы можете указать флаги форматирования, поместив "
"их после имени атрибута, отделив от него двоеточием. Например: заполнитель "
"``{msecs:03.0f}`` будет форматировать миллисекундное значение ``4`` как "
"``004``. Обратитесь к документации :meth:`str.format` для получения полной "
"информации о доступных вам опциях."

#: ../../library/logging.rst:996
msgid "Attribute name"
msgstr "Имя атрибута"

#: ../../library/logging.rst:996 ../../library/logging.rst:1358
msgid "Format"
msgstr "Формат"

#: ../../library/logging.rst:996 ../../library/logging.rst:1358
msgid "Description"
msgstr "Описание"

#: ../../library/logging.rst:0 ../../library/logging.rst:998
msgid "args"
msgstr "args"

#: ../../library/logging.rst:998 ../../library/logging.rst:1012
#: ../../library/logging.rst:1040 ../../library/logging.rst:1058
msgid "You shouldn't need to format this yourself."
msgstr "Вам не нужно будет форматировать это самостоятельно."

#: ../../library/logging.rst:998
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a dict "
"whose values are used for the merge (when there is only one argument, and it "
"is a dictionary)."
msgstr ""
"Кортеж аргументов, объединенный в ``msg``, для создания ``message`` или "
"словаря, значения которого используются для слияния (когда есть только один "
"аргумент и это словарь)."

#: ../../library/logging.rst:1003
msgid "asctime"
msgstr "asctime"

#: ../../library/logging.rst:1003
msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

#: ../../library/logging.rst:1003
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the comma "
"are millisecond portion of the time)."
msgstr ""
"Понятное для человека время создания :class:`LogRecord`. По умолчанию это "
"значение имеет вид \"2003-07-08 16:49:45,896\" (цифры после запятой "
"относятся к миллисекундной доле времени)."

#: ../../library/logging.rst:1009
msgid "created"
msgstr "created"

#: ../../library/logging.rst:1009
msgid "``%(created)f``"
msgstr "``%(created)f``"

#: ../../library/logging.rst:1009
msgid ""
"Time when the :class:`LogRecord` was created (as returned by :func:`time."
"time`)."
msgstr "Время создания :class:`LogRecord` (возвращенное :func:`time.time`)."

#: ../../library/logging.rst:0 ../../library/logging.rst:1012
msgid "exc_info"
msgstr "exc_info"

#: ../../library/logging.rst:1012
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred, "
"``None``."
msgstr ""
"Кортеж исключений (как ``sys.exc_info``) или, если исключений не произошло, "
"``None``."

#: ../../library/logging.rst:1015
msgid "filename"
msgstr "имя файла"

#: ../../library/logging.rst:1015
msgid "``%(filename)s``"
msgstr "``%(filename)s``"

#: ../../library/logging.rst:1015
msgid "Filename portion of ``pathname``."
msgstr "Часть имени файла в ``pathname``."

#: ../../library/logging.rst:1017
msgid "funcName"
msgstr "funcName"

#: ../../library/logging.rst:1017
msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

#: ../../library/logging.rst:1017
msgid "Name of function containing the logging call."
msgstr "Имя функции, содержащей вызов журнала."

#: ../../library/logging.rst:1019
msgid "levelname"
msgstr "levelname"

#: ../../library/logging.rst:1019
msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

#: ../../library/logging.rst:1019
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, "
"``'ERROR'``, ``'CRITICAL'``)."
msgstr ""
"Уровень текстового протоколирования сообщения (``'DEBUG'``, ``'INFO'``, "
"``'WARNING'``, ``'ERROR'``, ``'CRITICAL'``)."

#: ../../library/logging.rst:1023
msgid "levelno"
msgstr "levelno"

#: ../../library/logging.rst:1023
msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

#: ../../library/logging.rst:1023
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, :const:"
"`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""
"Числовой уровень регистрации сообщения (:const:`DEBUG`, :const:`INFO`, :"
"const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."

#: ../../library/logging.rst:1028
msgid "lineno"
msgstr "lineno"

#: ../../library/logging.rst:1028
msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

#: ../../library/logging.rst:1028
msgid "Source line number where the logging call was issued (if available)."
msgstr ""
"Номер исходной строки, в которой был выполнен вызов журнала (если доступен)."

#: ../../library/logging.rst:1031
msgid "message"
msgstr "сообщение"

#: ../../library/logging.rst:1031
msgid "``%(message)s``"
msgstr "``%(message)s``"

#: ../../library/logging.rst:1031
msgid ""
"The logged message, computed as ``msg % args``. This is set when :meth:"
"`Formatter.format` is invoked."
msgstr ""
"Зарегистрированное сообщение, вычисляемое как ``msg % args``. Это "
"устанавливается при вызове :meth:`Formatter.format`."

#: ../../library/logging.rst:1035
msgid "module"
msgstr "модуль"

#: ../../library/logging.rst:1035
msgid "``%(module)s``"
msgstr "``%(module)s``"

#: ../../library/logging.rst:1035
msgid "Module (name portion of ``filename``)."
msgstr "Модуль (часть имени ``filename``)."

#: ../../library/logging.rst:1037
msgid "msecs"
msgstr "мсек"

#: ../../library/logging.rst:1037
msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

#: ../../library/logging.rst:1037
msgid ""
"Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr "Миллисекундная часть времени создания :class:`LogRecord`."

#: ../../library/logging.rst:0 ../../library/logging.rst:1040
msgid "msg"
msgstr "msg"

#: ../../library/logging.rst:1040
msgid ""
"The format string passed in the original logging call. Merged with ``args`` "
"to produce ``message``, or an arbitrary object (see :ref:`arbitrary-object-"
"messages`)."
msgstr ""
"Строка формата, переданная в исходном вызове журнала. Объединяется с args "
"для создания сообщения или произвольного объекта (см. :ref:`произвольные-"
"объектные-сообщения`)."

#: ../../library/logging.rst:0 ../../library/logging.rst:1045
msgid "name"
msgstr "имя"

#: ../../library/logging.rst:1045
msgid "``%(name)s``"
msgstr "``%(name)s``"

#: ../../library/logging.rst:1045
msgid "Name of the logger used to log the call."
msgstr "Имя регистратора, используемого для регистрации вызова."

#: ../../library/logging.rst:1047
msgid "pathname"
msgstr "имя пути"

#: ../../library/logging.rst:1047
msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

#: ../../library/logging.rst:1047
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr ""
"Полный путь к исходному файлу, в котором был выполнен вызов журнала (если "
"доступен)."

#: ../../library/logging.rst:1050
msgid "process"
msgstr "процесс"

#: ../../library/logging.rst:1050
msgid "``%(process)d``"
msgstr "``%(process)d``"

#: ../../library/logging.rst:1050
msgid "Process ID (if available)."
msgstr "Идентификатор процесса (если имеется)."

#: ../../library/logging.rst:1052
msgid "processName"
msgstr "processName"

#: ../../library/logging.rst:1052
msgid "``%(processName)s``"
msgstr "``%(processName)s``"

#: ../../library/logging.rst:1052
msgid "Process name (if available)."
msgstr "Имя процесса (если имеется)."

#: ../../library/logging.rst:1054
msgid "relativeCreated"
msgstr "relativeCreated"

#: ../../library/logging.rst:1054
msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

#: ../../library/logging.rst:1054
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time "
"the logging module was loaded."
msgstr ""
"Время в миллисекундах, когда был создан LogRecord, относительно времени "
"загрузки модуля журналирования."

#: ../../library/logging.rst:1058
msgid "stack_info"
msgstr "stack_info"

#: ../../library/logging.rst:1058
msgid ""
"Stack frame information (where available) from the bottom of the stack in "
"the current thread, up to and including the stack frame of the logging call "
"which resulted in the creation of this record."
msgstr ""
"Информация о кадре стека (если доступна) от нижней части стека в текущем "
"потоке до кадра стека вызова журнала, который привел к созданию этой записи, "
"включительно."

#: ../../library/logging.rst:1064
msgid "thread"
msgstr "поток"

#: ../../library/logging.rst:1064
msgid "``%(thread)d``"
msgstr "``%(thread)d``"

#: ../../library/logging.rst:1064
msgid "Thread ID (if available)."
msgstr "Идентификатор потока (если таковой имеется)."

#: ../../library/logging.rst:1066
msgid "threadName"
msgstr "threadName"

#: ../../library/logging.rst:1066
msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

#: ../../library/logging.rst:1066
msgid "Thread name (if available)."
msgstr "Название потока (если таковое имеется)."

#: ../../library/logging.rst:1068
msgid "taskName"
msgstr "taskName"

#: ../../library/logging.rst:1068
msgid "``%(taskName)s``"
msgstr "``%(taskName)s``"

#: ../../library/logging.rst:1068
msgid ":class:`asyncio.Task` name (if available)."
msgstr ":class:`asyncio.Task` имя (если доступно)."

#: ../../library/logging.rst:1071
msgid "*processName* was added."
msgstr "Было добавлено *processName*."

#: ../../library/logging.rst:1074
msgid "*taskName* was added."
msgstr "*taskName* добавлено."

#: ../../library/logging.rst:1080
msgid "LoggerAdapter Objects"
msgstr "Объекты LoggerAdapter"

#: ../../library/logging.rst:1082
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual "
"information into logging calls. For a usage example, see the section on :ref:"
"`adding contextual information to your logging output <context-info>`."
msgstr ""
"Экземпляры :class:`LoggerAdapter` используются для удобной передачи "
"контекстной информации в журналируемые вызовы. Пример использования см. в "
"разделе :ref:`добавление контекстной информации к выходным данным журнала "
"<context-info>`."

#: ../../library/logging.rst:1088
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr ""
"Возвращает экземпляр :class:`LoggerAdapter`, инициализированный базовым "
"экземпляром :class:`Logger` и объектом, подобным dict."

#: ../../library/logging.rst:1093
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in "
"order to insert contextual information. This implementation takes the object "
"passed as *extra* to the constructor and adds it to *kwargs* using key "
"'extra'. The return value is a (*msg*, *kwargs*) tuple which has the "
"(possibly modified) versions of the arguments passed in."
msgstr ""
"Изменяет аргументы сообщения и/или ключевого слова, передаваемые в вызов "
"журнала, для вставки контекстной информации. Эта реализация принимает "
"объект, переданный как *extra* в конструктор, и добавляет его в *kwargs*, "
"используя ключ «extra». Возвращаемое значение представляет собой кортеж "
"(*msg*, *kwargs*), который содержит (возможно, измененные) версии переданных "
"аргументов."

#: ../../library/logging.rst:1101
msgid "Delegates to the underlying :attr:`!manager` on *logger*."
msgstr "Делегирует базовый :attr:`!manager` на *logger*."

#: ../../library/logging.rst:1105
msgid "Delegates to the underlying :meth:`!_log` method on *logger*."
msgstr "Делегирует базовый метод :meth:`!_log` в *logger*."

#: ../../library/logging.rst:1107
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :"
"meth:`~Logger.warning`, :meth:`~Logger.error`, :meth:`~Logger.exception`, :"
"meth:`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger.isEnabledFor`, :"
"meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` and :meth:"
"`~Logger.hasHandlers`. These methods have the same signatures as their "
"counterparts in :class:`Logger`, so you can use the two types of instances "
"interchangeably."
msgstr ""
"В дополнение к вышесказанному, :class:`LoggerAdapter` поддерживает следующие "
"методы :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, :meth:"
"`~Logger .warning`, :meth:`~Logger.error`, :meth:`~Logger.Exception`, :meth:"
"`~Logger.critical`, :meth:`~Logger.log`, :meth:`~Logger .isEnabledFor`, :"
"meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` и :meth:`~Logger."
"hasHandlers`. Эти методы имеют те же сигнатуры, что и их аналоги в :class:"
"`Logger`, поэтому вы можете использовать эти два типа экземпляров "
"взаимозаменяемо."

#: ../../library/logging.rst:1118
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:"
"`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were added to :"
"class:`LoggerAdapter`.  These methods delegate to the underlying logger."
msgstr ""
"В :class:`LoggerAdapter` были добавлены методы :meth:`~Logger."
"isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, :meth:`~Logger.setLevel` "
"и :meth:`~Logger.hasHandlers`. . Эти методы делегируют базовому средству "
"ведения журнала."

#: ../../library/logging.rst:1124
msgid ""
"Attribute :attr:`!manager` and method :meth:`!_log` were added, which "
"delegate to the underlying logger and allow adapters to be nested."
msgstr ""
"Были добавлены атрибут :attr:`!manager` и метод :meth:`!_log`, которые "
"делегируют базовому регистратору и позволяют вкладывать адаптеры."

#: ../../library/logging.rst:1129
msgid "Thread Safety"
msgstr "Безопасность потоков"

#: ../../library/logging.rst:1131
msgid ""
"The logging module is intended to be thread-safe without any special work "
"needing to be done by its clients. It achieves this though using threading "
"locks; there is one lock to serialize access to the module's shared data, "
"and each handler also creates a lock to serialize access to its underlying I/"
"O."
msgstr ""
"Модуль журналирования предназначен для потоковой безопасности, поэтому его "
"клиентам не требуется выполнять какую-либо специальную работу. Это "
"достигается за счет использования блокировок потоков; существует одна "
"блокировка для сериализации доступа к общим данным модуля, и каждый "
"обработчик также создает блокировку для сериализации доступа к базовому "
"вводу-выводу."

#: ../../library/logging.rst:1136
msgid ""
"If you are implementing asynchronous signal handlers using the :mod:`signal` "
"module, you may not be able to use logging from within such handlers. This "
"is because lock implementations in the :mod:`threading` module are not "
"always re-entrant, and so cannot be invoked from such signal handlers."
msgstr ""
"Если вы реализуете асинхронные обработчики сигналов с помощью модуля :mod:"
"`signal`, возможно, вы не сможете использовать ведение журнала внутри таких "
"обработчиков. Это связано с тем, что реализации блокировок в модуле :mod:"
"`threading` не всегда являются реентерабельными и поэтому не могут быть "
"вызваны из таких обработчиков сигналов."

#: ../../library/logging.rst:1143
msgid "Module-Level Functions"
msgstr "Функции на уровне модуля"

#: ../../library/logging.rst:1145
msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr "Помимо описанных выше классов, существует ряд функций уровня модуля."

#: ../../library/logging.rst:1151
msgid ""
"Return a logger with the specified name or, if name is ``None``, return the "
"root logger of the hierarchy. If specified, the name is typically a dot-"
"separated hierarchical name like *'a'*, *'a.b'* or *'a.b.c.d'*. Choice of "
"these names is entirely up to the developer who is using logging, though it "
"is recommended that ``__name__`` be used unless you have a specific reason "
"for not doing that, as mentioned in :ref:`logger`."
msgstr ""
"Возвращает регистратор с указанным именем или, если имя равно «Нет», "
"возвращает корневой регистратор иерархии. Если указано, имя обычно "
"представляет собой иерархическое имя, разделенное точкой, например *'a'*, "
"*'ab'* или *'abcd'*. Выбор этих имен полностью зависит от разработчика, "
"использующего журналирование, хотя рекомендуется использовать ``__name__``, "
"если у вас нет особой причины не делать этого, как указано в :ref:`logger`."

#: ../../library/logging.rst:1158
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed between "
"different parts of an application."
msgstr ""
"Все вызовы этой функции с заданным именем возвращают один и тот же экземпляр "
"журнала. Это означает, что экземпляры регистратора никогда не нужно "
"передавать между разными частями приложения."

#: ../../library/logging.rst:1165
msgid ""
"Return either the standard :class:`Logger` class, or the last class passed "
"to :func:`setLoggerClass`. This function may be called from within a new "
"class definition, to ensure that installing a customized :class:`Logger` "
"class will not undo customizations already applied by other code. For "
"example::"
msgstr ""
"Возвращает либо стандартный класс :class:`Logger`, либо последний класс, "
"переданный в :func:`setLoggerClass`. Эту функцию можно вызвать из "
"определения нового класса, чтобы гарантировать, что установка настроенного "
"класса :class:`Logger` не приведет к отмене настроек, уже примененных другим "
"кодом. Например::"

#: ../../library/logging.rst:1170
msgid ""
"class MyLogger(logging.getLoggerClass()):\n"
"    # ... override behaviour here"
msgstr ""
"class MyLogger(logging.getLoggerClass()):\n"
"    # ... override behaviour here"

#: ../../library/logging.rst:1176
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr ""
"Возвращает вызываемый объект, который используется для создания :class:"
"`LogRecord`."

#: ../../library/logging.rst:1178
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"Эта функция была предоставлена ​​вместе с :func:`setLogRecordFactory`, чтобы "
"дать разработчикам больше контроля над тем, как создается :class:"
"`LogRecord`, представляющий событие регистрации."

#: ../../library/logging.rst:1183
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr ""
"См. :func:`setLogRecordFactory` для получения дополнительной информации о "
"том, как вызывается фабрика."

#: ../../library/logging.rst:1188
msgid ""
"This is a convenience function that calls :meth:`Logger.debug`, on the root "
"logger. The handling of the arguments is in every way identical to what is "
"described in that method."
msgstr ""
"Это удобная функция, которая вызывает :meth:`Logger.debug` в корневом "
"регистраторе. Обработка аргументов во всех отношениях идентична описанной в "
"этом методе."

#: ../../library/logging.rst:1192
msgid ""
"The only difference is that if the root logger has no handlers, then :func:"
"`basicConfig` is called, prior to calling ``debug`` on the root logger."
msgstr ""
"Единственное отличие состоит в том, что если корневой регистратор не имеет "
"обработчиков, то вызывается :func:`basicConfig` перед вызовом ``debug`` на "
"корневом регистраторе."

#: ../../library/logging.rst:1195
msgid ""
"For very short scripts or quick demonstrations of ``logging`` facilities, "
"``debug`` and the other module-level functions may be convenient. However, "
"most programs will want to carefully and explicitly control the logging "
"configuration, and should therefore prefer creating a module-level logger "
"and calling :meth:`Logger.debug` (or other level-specific methods) on it, as "
"described at the beginnning of this documentation."
msgstr ""
"Для очень коротких сценариев или быстрой демонстрации возможностей "
"протоколирования могут оказаться удобными функции debug и другие функции "
"уровня модуля. Однако большинству программ необходимо тщательно и явно "
"контролировать конфигурацию журналирования, и поэтому им следует предпочесть "
"создание регистратора уровня модуля и вызов :meth:`Logger.debug` (или других "
"методов, специфичных для уровня), как описано в разделе начало этой "
"документации."

#: ../../library/logging.rst:1205
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`INFO` в корневом регистраторе. "
"Аргументы и поведение в остальном такие же, как и для :func:`debug`."

#: ../../library/logging.rst:1211
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`WARNING` в корневом регистраторе. "
"Аргументы и поведение в остальном такие же, как и для :func:`debug`."

#: ../../library/logging.rst:1214
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"Существует устаревшая функция «warn», которая функционально идентична "
"«предупреждению». Поскольку ``warn`` устарел, пожалуйста, не используйте его "
"- вместо этого используйте ``warning``."

#: ../../library/logging.rst:1221
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`ERROR` в корневом регистраторе. "
"Аргументы и поведение в остальном такие же, как и для :func:`debug`."

#: ../../library/logging.rst:1227
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments and behavior are otherwise the same as for :func:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем :const:`CRITICAL` в корневом регистраторе. "
"Аргументы и поведение в остальном такие же, как и для :func:`debug`."

#: ../../library/logging.rst:1233
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The arguments "
"and behavior are otherwise the same as for :func:`debug`. Exception info is "
"added to the logging message. This function should only be called from an "
"exception handler."
msgstr ""
"Регистрирует сообщение с уровнем :const:`ERROR` в корневом регистраторе. "
"Аргументы и поведение в остальном такие же, как и для :func:`debug`. "
"Информация об исключении добавляется в сообщение журнала. Эту функцию "
"следует вызывать только из обработчика исключений."

#: ../../library/logging.rst:1239
msgid ""
"Logs a message with level *level* on the root logger. The arguments and "
"behavior are otherwise the same as for :func:`debug`."
msgstr ""
"Регистрирует сообщение с уровнем *level* в корневом регистраторе. Аргументы "
"и поведение в остальном такие же, как и для :func:`debug`."

#: ../../library/logging.rst:1244
msgid ""
"Provides an overriding level *level* for all loggers which takes precedence "
"over the logger's own level. When the need arises to temporarily throttle "
"logging output down across the whole application, this function can be "
"useful. Its effect is to disable all logging calls of severity *level* and "
"below, so that if you call it with a value of INFO, then all INFO and DEBUG "
"events would be discarded, whereas those of severity WARNING and above would "
"be processed according to the logger's effective level. If ``logging."
"disable(logging.NOTSET)`` is called, it effectively removes this overriding "
"level, so that logging output again depends on the effective levels of "
"individual loggers."
msgstr ""
"Предоставляет переопределяющий уровень *level* для всех средств ведения "
"журнала, который имеет приоритет над собственным уровнем средства ведения "
"журнала. Эта функция может оказаться полезной, когда возникает необходимость "
"временно ограничить вывод журналов во всем приложении. Его эффект "
"заключается в отключении всех вызовов журналирования с уровнем серьезности "
"*уровень* и ниже, так что если вы вызовете его со значением INFO, все "
"события INFO и DEBUG будут отброшены, тогда как события с уровнем "
"серьезности WARNING и выше будут обработаны в соответствии с эффективный "
"уровень регистратора. Если вызывается ``logging.disable(logging.NOTSET)``, "
"он эффективно удаляет этот переопределяющий уровень, так что выходные данные "
"журналирования снова зависят от эффективных уровней отдельных средств "
"журналирования."

#: ../../library/logging.rst:1255
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *level* parameter, but will have to explicitly supply "
"a suitable value."
msgstr ""
"Обратите внимание: если вы определили какой-либо уровень ведения журнала "
"выше «CRITICAL» (это не рекомендуется), вы не сможете полагаться на значение "
"по умолчанию для параметра *level*, но вам придется явно указать подходящее "
"значение."

#: ../../library/logging.rst:1260
msgid ""
"The *level* parameter was defaulted to level ``CRITICAL``. See :issue:"
"`28524` for more information about this change."
msgstr ""
"Параметр *level* по умолчанию был установлен на уровень ``CRITICAL``. "
"Дополнительную информацию об этом изменении см. в :issue:`28524`."

#: ../../library/logging.rst:1266
msgid ""
"Associates level *level* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for example "
"when a :class:`Formatter` formats a message. This function can also be used "
"to define your own levels. The only constraints are that all levels used "
"must be registered using this function, levels should be positive integers "
"and they should increase in increasing order of severity."
msgstr ""
"Связывает уровень *level* с текстом *levelName* во внутреннем словаре, "
"который используется для сопоставления числовых уровней с текстовым "
"представлением, например, когда :class:`Formatter` форматирует сообщение. "
"Эту функцию также можно использовать для определения собственных уровней. "
"Единственным ограничением является то, что все используемые уровни должны "
"быть зарегистрированы с помощью этой функции, уровни должны быть "
"положительными целыми числами и увеличиваться в порядке возрастания "
"серьезности."

#: ../../library/logging.rst:1273
msgid ""
"If you are thinking of defining your own levels, please see the section on :"
"ref:`custom-levels`."
msgstr ""
"Если вы думаете об определении собственных уровней, обратитесь к разделу :"
"ref:`custom-levels`."

#: ../../library/logging.rst:1278
msgid ""
"Returns a mapping from level names to their corresponding logging levels. "
"For example, the string \"CRITICAL\" maps to :const:`CRITICAL`. The returned "
"mapping is copied from an internal mapping on each call to this function."
msgstr ""
"Возвращает сопоставление имен уровней с соответствующими уровнями ведения "
"журнала. Например, строка «CRITICAL» отображается в :const:`CRITICAL`. "
"Возвращенное сопоставление копируется из внутреннего сопоставления при "
"каждом вызове этой функции."

#: ../../library/logging.rst:1286
msgid "Returns the textual or numeric representation of logging level *level*."
msgstr ""
"Возвращает текстовое или числовое представление уровня ведения журнала "
"*level*."

#: ../../library/logging.rst:1288
msgid ""
"If *level* is one of the predefined levels :const:`CRITICAL`, :const:"
"`ERROR`, :const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the "
"corresponding string. If you have associated levels with names using :func:"
"`addLevelName` then the name you have associated with *level* is returned. "
"If a numeric value corresponding to one of the defined levels is passed in, "
"the corresponding string representation is returned."
msgstr ""
"Если *level* является одним из предопределенных уровней :const:`CRITICAL`, :"
"const:`ERROR`, :const:`WARNING`, :const:`INFO` или :const:`DEBUG`, вы "
"получите соответствующую строку. . Если вы связали уровни с именами, "
"используя :func:`addLevelName`, то возвращается имя, которое вы связали с "
"*level*. Если передается числовое значение, соответствующее одному из "
"определенных уровней, возвращается соответствующее строковое представление."

#: ../../library/logging.rst:1295
msgid ""
"The *level* parameter also accepts a string representation of the level such "
"as 'INFO'. In such cases, this functions returns the corresponding numeric "
"value of the level."
msgstr ""
"Параметр *level* также принимает строковое представление уровня, например "
"INFO. В таких случаях эта функция возвращает соответствующее числовое "
"значение уровня."

#: ../../library/logging.rst:1299
msgid ""
"If no matching numeric or string value is passed in, the string 'Level %s' % "
"level is returned."
msgstr ""
"Если не передано ни одного соответствующего числового или строкового "
"значения, строка Level %s '% уровень возвращается."

#: ../../library/logging.rst:1302
msgid ""
"Levels are internally integers (as they need to be compared in the logging "
"logic). This function is used to convert between an integer level and the "
"level name displayed in the formatted log output by means of the "
"``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`), and "
"vice versa."
msgstr ""
"Уровни внутренне являются целыми числами (поскольку их необходимо сравнивать "
"в логике журналирования). Эта функция используется для преобразования между "
"целочисленным уровнем и именем уровня, отображаемым в выводе "
"форматированного журнала, с помощью `` %(имя уровня)s `` Спецификатор "
"формата (см. :ref:`logrecord-attributes`), и наоборот."

#: ../../library/logging.rst:1308
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a "
"text level, and would return the corresponding numeric value of the level. "
"This undocumented behaviour was considered a mistake, and was removed in "
"Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility."
msgstr ""
"В версиях Python ниже 3.4 этой функции также можно было передать текстовый "
"уровень, и она возвращала соответствующее числовое значение уровня. Это "
"недокументированное поведение было сочтено ошибкой и было удалено в Python "
"3.4, но восстановлено в версии 3.4.2 из-за сохранения обратной совместимости."

#: ../../library/logging.rst:1316
msgid ""
"Returns a handler with the specified *name*, or ``None`` if there is no "
"handler with that name."
msgstr ""
"Возвращает обработчик с указанным *имя* или ``None``, если обработчика с "
"таким именем нет."

#: ../../library/logging.rst:1323
msgid "Returns an immutable set of all known handler names."
msgstr ""
"Возвращает обработчик с указанным *имя* или ``None``, если обработчика с "
"таким именем нет."

#: ../../library/logging.rst:1329
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes are "
"defined by *attrdict*. This function is useful for taking a pickled :class:"
"`LogRecord` attribute dictionary, sent over a socket, and reconstituting it "
"as a :class:`LogRecord` instance at the receiving end."
msgstr ""
"Создает и возвращает новый экземпляр :class:`LogRecord`, атрибуты которого "
"определяются *attrdict*. Эта функция полезна для получения маринованного "
"словаря атрибутов :class:`LogRecord`, отправленного через сокет, и "
"воссоздания его как экземпляра :class:`LogRecord` на принимающей стороне."

#: ../../library/logging.rst:1337
msgid ""
"Does basic configuration for the logging system by creating a :class:"
"`StreamHandler` with a default :class:`Formatter` and adding it to the root "
"logger. The functions :func:`debug`, :func:`info`, :func:`warning`, :func:"
"`error` and :func:`critical` will call :func:`basicConfig` automatically if "
"no handlers are defined for the root logger."
msgstr ""
"Выполняет базовую настройку системы журналирования, создавая :class:"
"`StreamHandler` со стандартным :class:`Formatter` и добавляя его в корневой "
"регистратор. Функции :func:`debug`, :func:`info`, :func:`warning`, :func:"
"`error` и :func:`critical` будут вызывать :func:`basicConfig` автоматически, "
"если обработчики не определены. для корневого регистратора."

#: ../../library/logging.rst:1343
msgid ""
"This function does nothing if the root logger already has handlers "
"configured, unless the keyword argument *force* is set to ``True``."
msgstr ""
"Эта функция ничего не делает, если в корневом регистраторе уже настроены "
"обработчики, если только аргумент ключевого слова *force* не установлен в "
"``True``."

#: ../../library/logging.rst:1346
msgid ""
"This function should be called from the main thread before other threads are "
"started. In versions of Python prior to 2.7.1 and 3.2, if this function is "
"called from multiple threads, it is possible (in rare circumstances) that a "
"handler will be added to the root logger more than once, leading to "
"unexpected results such as messages being duplicated in the log."
msgstr ""
"Эту функцию следует вызывать из основного потока до запуска других потоков. "
"В версиях Python до 2.7.1 и 3.2, если эта функция вызывается из нескольких "
"потоков, возможно (в редких случаях), что обработчик будет добавлен к "
"корневому регистратору более одного раза, что приведет к неожиданным "
"результатам, таким как сообщения. дублируется в журнале."

#: ../../library/logging.rst:1353
msgid "The following keyword arguments are supported."
msgstr "Поддерживаются следующие именованные аргументы."

#: ../../library/logging.rst:1360
msgid "*filename*"
msgstr "*filename*"

#: ../../library/logging.rst:1360
msgid ""
"Specifies that a :class:`FileHandler` be created, using the specified "
"filename, rather than a :class:`StreamHandler`."
msgstr ""
"Указывает, что будет создан :class:`FileHandler` с использованием указанного "
"имени файла, а не :class:`StreamHandler`."

#: ../../library/logging.rst:1364
msgid "*filemode*"
msgstr "*filemode*"

#: ../../library/logging.rst:1364
msgid ""
"If *filename* is specified, open the file in this :ref:`mode <filemodes>`. "
"Defaults to ``'a'``."
msgstr ""
"Если указано *filename*, откройте файл в этом :ref:`режиме <filemodes>`. По "
"умолчанию ``'a'``."

#: ../../library/logging.rst:1368
msgid "*format*"
msgstr "*format*"

#: ../../library/logging.rst:1368
msgid ""
"Use the specified format string for the handler. Defaults to attributes "
"``levelname``, ``name`` and ``message`` separated by colons."
msgstr ""
"Используйте указанную строку формата для обработчика. По умолчанию атрибуты "
"``levelname``, ``name`` и ``message`` разделены двоеточиями."

#: ../../library/logging.rst:1373
msgid "*datefmt*"
msgstr "*datefmt*"

#: ../../library/logging.rst:1373
msgid ""
"Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr ""
"Используйте указанный формат даты/времени, принятый :func:`time.strftime`."

#: ../../library/logging.rst:1376
msgid "*style*"
msgstr "*стиль*"

#: ../../library/logging.rst:1376
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` respectively. "
"Defaults to ``'%'``."
msgstr ""
"Если указан *format*, используйте этот стиль для строки формата. Один из "
"``'%'``, ``'{'`` или ``'$'`` для :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` или :class:`string.Template` "
"соответственно. По умолчанию ``'%'``."

#: ../../library/logging.rst:1384
msgid "*level*"
msgstr "*уровень*"

#: ../../library/logging.rst:1384
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr ""
"Установите уровень корневого регистратора на указанный :ref:`level <levels>`."

#: ../../library/logging.rst:1387
msgid "*stream*"
msgstr "*поток*"

#: ../../library/logging.rst:1387
msgid ""
"Use the specified stream to initialize the :class:`StreamHandler`. Note that "
"this argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""
"Используйте указанный поток для инициализации :class:`StreamHandler`. "
"Обратите внимание, что этот аргумент несовместим с *filename* — если "
"присутствуют оба, выдается ``ValueError``."

#: ../../library/logging.rst:1393
msgid "*handlers*"
msgstr "*обработчики*"

#: ../../library/logging.rst:1393
msgid ""
"If specified, this should be an iterable of already created handlers to add "
"to the root logger. Any handlers which don't already have a formatter set "
"will be assigned the default formatter created in this function. Note that "
"this argument is incompatible with *filename* or *stream* - if both are "
"present, a ``ValueError`` is raised."
msgstr ""
"Если указано, это должна быть итерация уже созданных обработчиков для "
"добавления в корневой регистратор. Любым обработчикам, у которых еще не "
"установлен форматтер, будет назначен форматтер по умолчанию, созданный в "
"этой функции. Обратите внимание, что этот аргумент несовместим с *имя_файла* "
"или *поток* — если оба они присутствуют, выдается ``ValueError``."

#: ../../library/logging.rst:1402
msgid "*force*"
msgstr "*force*"

#: ../../library/logging.rst:1402
msgid ""
"If this keyword argument is specified as true, any existing handlers "
"attached to the root logger are removed and closed, before carrying out the "
"configuration as specified by the other arguments."
msgstr ""
"Если для этого ключевого аргумента указано значение true, все существующие "
"обработчики, прикрепленные к корневому регистратору, удаляются и закрываются "
"перед выполнением настройки, указанной другими аргументами."

#: ../../library/logging.rst:1408
msgid "*encoding*"
msgstr "*кодирование*"

#: ../../library/logging.rst:1408
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file."
msgstr ""
"Если этот аргумент ключевого слова указан вместе с *filename*, его значение "
"используется при создании :class:`FileHandler` и, таким образом, "
"используется при открытии выходного файла."

#: ../../library/logging.rst:1413
msgid "*errors*"
msgstr "*ошибки*"

#: ../../library/logging.rst:1413
msgid ""
"If this keyword argument is specified along with *filename*, its value is "
"used when the :class:`FileHandler` is created, and thus used when opening "
"the output file. If not specified, the value 'backslashreplace' is used. "
"Note that if ``None`` is specified, it will be passed as such to :func:"
"`open`, which means that it will be treated the same as passing 'errors'."
msgstr ""
"Если этот аргумент ключевого слова указан вместе с *filename*, его значение "
"используется при создании :class:`FileHandler` и, таким образом, "
"используется при открытии выходного файла. Если не указано, используется "
"значение «обратная косая черта». Обратите внимание, что если указано "
"``None``, оно будет передано в :func:`open` как таковое, что означает, что "
"оно будет обрабатываться так же, как передача \"ошибок\"."

#: ../../library/logging.rst:1424
msgid "The *style* argument was added."
msgstr "Был добавлен аргумент *style*."

#: ../../library/logging.rst:1427
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with *filename*)."
msgstr ""
"Был добавлен аргумент *handlers*. Были добавлены дополнительные проверки для "
"выявления ситуаций, в которых указаны несовместимые аргументы (например, "
"*handlers* вместе с *stream* или *filename* или *stream* вместе с "
"*filename*)."

#: ../../library/logging.rst:1433
msgid "The *force* argument was added."
msgstr "Был добавлен аргумент *force*."

#: ../../library/logging.rst:1436
msgid "The *encoding* and *errors* arguments were added."
msgstr "Были добавлены аргументы *encoding* и *errors*."

#: ../../library/logging.rst:1441
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and "
"closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr ""
"Сообщает системе журналирования о необходимости выполнить упорядоченное "
"завершение работы путем очистки и закрытия всех обработчиков. Этот вызов "
"следует вызывать при выходе из приложения, и после этого вызова нельзя "
"использовать систему журналирования."

#: ../../library/logging.rst:1445
msgid ""
"When the logging module is imported, it registers this function as an exit "
"handler (see :mod:`atexit`), so normally there's no need to do that manually."
msgstr ""
"Когда модуль журналирования импортируется, он регистрирует эту функцию как "
"обработчик выхода (см. :mod:`atexit`), поэтому обычно нет необходимости "
"делать это вручную."

#: ../../library/logging.rst:1452
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`!__init__` such that only a name "
"argument is required, and the :meth:`!__init__` should call :meth:`!Logger."
"__init__`. This function is typically called before any loggers are "
"instantiated by applications which need to use custom logger behavior. After "
"this call, as at any other time, do not instantiate loggers directly using "
"the subclass: continue to use the :func:`logging.getLogger` API to get your "
"loggers."
msgstr ""
"Сообщает системе журналирования использовать класс *klass* при создании "
"экземпляра регистратора. Класс должен определить :meth:`!__init__` так, "
"чтобы требовался только аргумент имени, а :meth:`!__init__` должен вызывать :"
"meth:`!Logger.__init__`. Эта функция обычно вызывается перед созданием "
"экземпляров средств ведения журнала приложениями, которым необходимо "
"использовать настраиваемое поведение средства ведения журнала. После этого "
"вызова, как и в любое другое время, не создавайте экземпляры регистраторов "
"напрямую с помощью подкласса: продолжайте использовать API :func:`logging."
"getLogger` для получения ваших логгеров."

#: ../../library/logging.rst:1463
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr ""
"Установите вызываемый объект, который используется для создания :class:"
"`LogRecord`."

#: ../../library/logging.rst:1465
msgid "The factory callable to be used to instantiate a log record."
msgstr ""
"Вызываемый объект фабрики, который будет использоваться для создания "
"экземпляра записи журнала."

#: ../../library/logging.rst:1467
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, to "
"allow developers more control over how the :class:`LogRecord` representing a "
"logging event is constructed."
msgstr ""
"Эта функция была предоставлена ​​вместе с :func:`getLogRecordFactory`, чтобы "
"дать разработчикам больше контроля над тем, как создается :class:"
"`LogRecord`, представляющий событие регистрации."

#: ../../library/logging.rst:1472
msgid "The factory has the following signature:"
msgstr "На заводе имеется следующая подпись:"

#: ../../library/logging.rst:1474
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"
msgstr ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, "
"**kwargs)``"

#: ../../library/logging.rst:1476
msgid "The logger name."
msgstr "Имя регистратора."

#: ../../library/logging.rst:0
msgid "level"
msgstr "level"

#: ../../library/logging.rst:1477
msgid "The logging level (numeric)."
msgstr "Уровень ведения журнала (числовой)."

#: ../../library/logging.rst:0
msgid "fn"
msgstr "fn"

#: ../../library/logging.rst:1478
msgid "The full pathname of the file where the logging call was made."
msgstr "Полный путь к файлу, в котором был выполнен вызов журнала."

#: ../../library/logging.rst:0
msgid "lno"
msgstr "lno"

#: ../../library/logging.rst:1479
msgid "The line number in the file where the logging call was made."
msgstr "Номер строки в файле, где был выполнен вызов журнала."

#: ../../library/logging.rst:1480
msgid "The logging message."
msgstr "Сообщение о регистрации."

#: ../../library/logging.rst:1481
msgid "The arguments for the logging message."
msgstr "Аргументы сообщения журнала."

#: ../../library/logging.rst:1482
msgid "An exception tuple, or ``None``."
msgstr "Кортеж исключений или ``None``."

#: ../../library/logging.rst:0
msgid "func"
msgstr "func"

#: ../../library/logging.rst:1483
msgid "The name of the function or method which invoked the logging call."
msgstr "Имя функции или метода, вызвавшего вызов журнала."

#: ../../library/logging.rst:0
msgid "sinfo"
msgstr "sinfo"

#: ../../library/logging.rst:1485
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr ""
"Обратная трассировка стека, например, предоставляемая :func:`traceback."
"print_stack`, показывает иерархию вызовов."

#: ../../library/logging.rst:0
msgid "kwargs"
msgstr "kwargs"

#: ../../library/logging.rst:1487
msgid "Additional keyword arguments."
msgstr "Дополнительные аргументы ключевого слова."

#: ../../library/logging.rst:1491
msgid "Module-Level Attributes"
msgstr "Атрибуты на уровне модуля"

#: ../../library/logging.rst:1495
msgid ""
"A \"handler of last resort\" is available through this attribute. This is a :"
"class:`StreamHandler` writing to ``sys.stderr`` with a level of ``WARNING``, "
"and is used to handle logging events in the absence of any logging "
"configuration. The end result is to just print the message to ``sys."
"stderr``. This replaces the earlier error message saying that \"no handlers "
"could be found for logger XYZ\". If you need the earlier behaviour for some "
"reason, ``lastResort`` can be set to ``None``."
msgstr ""
"Через этот атрибут доступен «обработчик последней инстанции». Это :class:"
"`StreamHandler`, записывающий в ``sys.stderr`` с уровнем ``WARNING`` и "
"используемый для обработки событий регистрации при отсутствии какой-либо "
"конфигурации журналирования. Конечным результатом будет просто напечатать "
"сообщение в ``sys.stderr``. Это заменяет более раннее сообщение об ошибке, в "
"котором говорилось, что «не удалось найти обработчики для средства ведения "
"журнала XYZ». Если по какой-то причине вам нужно более раннее поведение, для "
"LastResort можно установить значение None."

#: ../../library/logging.rst:1507
msgid "Used to see if exceptions during handling should be propagated."
msgstr ""
"Используется для проверки того, следует ли распространять исключения во "
"время обработки."

#: ../../library/logging.rst:1509
msgid "Default: ``True``."
msgstr "По умолчанию: ``Истина``."

#: ../../library/logging.rst:1511
msgid ""
"If :data:`raiseExceptions` is ``False``, exceptions get silently ignored. "
"This is what is mostly wanted for a logging system - most users will not "
"care about errors in the logging system, they are more interested in "
"application errors."
msgstr ""
"Если :data:`raiseExceptions` имеет значение ``False``, исключения "
"игнорируются. Это то, чего больше всего хотят от системы журналирования — "
"большинство пользователей не будут интересоваться ошибками в системе "
"журналирования, их больше интересуют ошибки приложений."

#: ../../library/logging.rst:1518
msgid "Integration with the warnings module"
msgstr "Интеграция с модулем предупреждений"

#: ../../library/logging.rst:1520
msgid ""
"The :func:`captureWarnings` function can be used to integrate :mod:`logging` "
"with the :mod:`warnings` module."
msgstr ""
"Функцию :func:`captureWarnings` можно использовать для интеграции :mod:"
"`logging` с модулем :mod:`warnings`."

#: ../../library/logging.rst:1525
msgid ""
"This function is used to turn the capture of warnings by logging on and off."
msgstr ""
"Эта функция используется для включения и выключения сбора предупреждений при "
"входе в систему."

#: ../../library/logging.rst:1528
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module will "
"be redirected to the logging system. Specifically, a warning will be "
"formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of :const:"
"`WARNING`."
msgstr ""
"Если *capture* имеет значение «True», предупреждения, выдаваемые модулем :"
"mod:`warnings`, будут перенаправлены в систему журналирования. В частности, "
"предупреждение будет отформатировано с использованием :func:`warnings."
"formatwarning`, а полученная строка будет записана в регистратор с именем "
"``'py.warnings'`` с уровнем серьезности :const:`WARNING`."

#: ../../library/logging.rst:1533
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging system "
"will stop, and warnings will be redirected to their original destinations (i."
"e. those in effect before ``captureWarnings(True)`` was called)."
msgstr ""
"Если *capture* имеет значение «False», перенаправление предупреждений в "
"систему журналирования будет остановлено, а предупреждения будут "
"перенаправлены в исходные пункты назначения (т. е. те, которые действовали "
"до вызова captureWarnings(True))."

#: ../../library/logging.rst:1540
msgid "Module :mod:`logging.config`"
msgstr "Модуль :mod:`logging.config`"

#: ../../library/logging.rst:1541
msgid "Configuration API for the logging module."
msgstr "API конфигурации для модуля журналирования."

#: ../../library/logging.rst:1543
msgid "Module :mod:`logging.handlers`"
msgstr "Модуль :mod:`logging.handlers`"

#: ../../library/logging.rst:1544
msgid "Useful handlers included with the logging module."
msgstr "Полезные обработчики, включенные в модуль журналирования."

#: ../../library/logging.rst:1546
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - Система журналирования"

#: ../../library/logging.rst:1547
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr ""
"Предложение, описывающее эту функцию для включения в стандартную библиотеку "
"Python."

#: ../../library/logging.rst:1550
msgid ""
"`Original Python logging package <https://old.red-dove.com/python_logging."
"html>`_"
msgstr ""
"Предложение, описывающее эту функцию для включения в стандартную библиотеку "
"Python."

#: ../../library/logging.rst:1551
msgid ""
"This is the original source for the :mod:`logging` package.  The version of "
"the package available from this site is suitable for use with Python 1.5.2, "
"2.1.x and 2.2.x, which do not include the :mod:`logging` package in the "
"standard library."
msgstr ""
"Это исходный код пакета :mod:`logging`. Версия пакета, доступная на этом "
"сайте, подходит для использования с Python 1.5.2, 2.1.x и 2.2.x, которые не "
"включают пакет :mod:`logging` в стандартную библиотеку."

#: ../../library/logging.rst:12
msgid "Errors"
msgstr "Ошибки"

#: ../../library/logging.rst:12
msgid "logging"
msgstr "логирование"
