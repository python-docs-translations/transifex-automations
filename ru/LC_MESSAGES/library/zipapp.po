# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:49+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/zipapp.rst:2
msgid ":mod:`!zipapp` --- Manage executable Python zip archives"
msgstr ":mod:`!zipapp` --- Управление исполняемыми zip-архивами Python."

#: ../../library/zipapp.rst:9
msgid "**Source code:** :source:`Lib/zipapp.py`"
msgstr "**Исходный код:** :source:`Lib/zipapp.py`"

#: ../../library/zipapp.rst:16
msgid ""
"This module provides tools to manage the creation of zip files containing "
"Python code, which can be  :ref:`executed directly by the Python interpreter "
"<using-on-interface-options>`.  The module provides both a :ref:`zipapp-"
"command-line-interface` and a :ref:`zipapp-python-api`."
msgstr ""
"Этот модуль предоставляет инструменты для управления созданием zip-файлов, "
"содержащих код Python, который может :ref:`выполняться непосредственно "
"интерпретатором Python <using-on-interface-options>`. Модуль предоставляет "
"как :ref:`zipapp-command-line-interface`, так и :ref:`zipapp-python-api`."

#: ../../library/zipapp.rst:23
msgid "Basic Example"
msgstr "Базовый пример"

#: ../../library/zipapp.rst:25
msgid ""
"The following example shows how the :ref:`zipapp-command-line-interface` can "
"be used to create an executable archive from a directory containing Python "
"code.  When run, the archive will execute the ``main`` function from the "
"module ``myapp`` in the archive."
msgstr ""
"В следующем примере показано, как можно использовать :ref:`zipapp-command-"
"line-interface` для создания исполняемого архива из каталога, содержащего "
"код Python. При запуске архив выполнит функцию ``main`` из модуля ``myapp`` "
"в архиве."

#: ../../library/zipapp.rst:30
msgid ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp -m \"myapp:main\"\n"
"$ python myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:40
msgid "Command-Line Interface"
msgstr "Интерфейс командной строки"

#: ../../library/zipapp.rst:42
msgid ""
"When called as a program from the command line, the following form is used:"
msgstr "При вызове программы из командной строки используется следующая форма:"

#: ../../library/zipapp.rst:44
msgid "$ python -m zipapp source [options]"
msgstr "$ python -m zipapp source [options]"

#: ../../library/zipapp.rst:48
msgid ""
"If *source* is a directory, this will create an archive from the contents of "
"*source*.  If *source* is a file, it should be an archive, and it will be "
"copied to the target archive (or the contents of its shebang line will be "
"displayed if the --info option is specified)."
msgstr ""
"Если *source* — это каталог, из содержимого *source* будет создан архив. "
"Если *source* — это файл, это должен быть архив, и он будет скопирован в "
"целевой архив (или будет отображено содержимое его строки shebang, если "
"указана опция --info)."

#: ../../library/zipapp.rst:53
msgid "The following options are understood:"
msgstr "Подразумеваются следующие варианты:"

#: ../../library/zipapp.rst:59
msgid ""
"Write the output to a file named *output*.  If this option is not specified, "
"the output filename will be the same as the input *source*, with the "
"extension ``.pyz`` added.  If an explicit filename is given, it is used as "
"is (so a ``.pyz`` extension should be included if required)."
msgstr ""
"Запишите вывод в файл с именем *output*. Если эта опция не указана, имя "
"выходного файла будет таким же, как входное *source*, с добавлением "
"расширения ``.pyz``. Если указано явное имя файла, оно используется как есть "
"(поэтому при необходимости следует включить расширение ``.pyz``)."

#: ../../library/zipapp.rst:64
msgid ""
"An output filename must be specified if the *source* is an archive (and in "
"that case, *output* must not be the same as *source*)."
msgstr ""
"Имя выходного файла должно быть указано, если *source* является архивом (и в "
"этом случае *output* не должно совпадать с *source*)."

#: ../../library/zipapp.rst:69
msgid ""
"Add a ``#!`` line to the archive specifying *interpreter* as the command to "
"run.  Also, on POSIX, make the archive executable.  The default is to write "
"no ``#!`` line, and not make the file executable."
msgstr ""
"Добавьте в архив строку ``#!``, указав *interpreter* в качестве команды для "
"запуска. Кроме того, в POSIX сделайте архив исполняемым. По умолчанию строка "
"``#!`` не пишется и файл не становится исполняемым."

#: ../../library/zipapp.rst:75
msgid ""
"Write a ``__main__.py`` file to the archive that executes *mainfn*.  The "
"*mainfn* argument should have the form \"pkg.mod:fn\", where \"pkg.mod\" is "
"a package/module in the archive, and \"fn\" is a callable in the given "
"module. The ``__main__.py`` file will execute that callable."
msgstr ""
"Запишите файл ``__main__.py`` в архив, который выполняет *mainfn*. Аргумент "
"*mainfn* должен иметь форму «pkg.mod:fn», где «pkg.mod» — это пакет/модуль в "
"архиве, а «fn» — вызываемый объект в данном модуле. Файл ``__main__.py`` "
"выполнит этот вызываемый объект."

#: ../../library/zipapp.rst:80
msgid ":option:`--main` cannot be specified when copying an archive."
msgstr ":option:`--main` нельзя указать при копировании архива."

#: ../../library/zipapp.rst:84
msgid ""
"Compress files with the deflate method, reducing the size of the output "
"file. By default, files are stored uncompressed in the archive."
msgstr ""
"Сжимайте файлы методом deflate, уменьшая размер выходного файла. По "
"умолчанию файлы хранятся в архиве в несжатом виде."

#: ../../library/zipapp.rst:87
msgid ":option:`--compress` has no effect when copying an archive."
msgstr ":option:`--compress` не действует при копировании архива."

#: ../../library/zipapp.rst:93
msgid ""
"Display the interpreter embedded in the archive, for diagnostic purposes.  "
"In this case, any other options are ignored and SOURCE must be an archive, "
"not a directory."
msgstr ""
"Отобразить встроенный в архив интерпретатор, для диагностических целей. В "
"этом случае любые другие параметры игнорируются, а SOURCE должен быть "
"архивом, а не каталогом."

#: ../../library/zipapp.rst:99
msgid "Print a short usage message and exit."
msgstr "Распечатайте короткое сообщение об использовании и выйдите."

#: ../../library/zipapp.rst:105
msgid "Python API"
msgstr "Python API"

#: ../../library/zipapp.rst:107
msgid "The module defines two convenience functions:"
msgstr "Модуль определяет две удобные функции:"

#: ../../library/zipapp.rst:112
msgid ""
"Create an application archive from *source*.  The source can be any of the "
"following:"
msgstr ""
"Создайте архив приложения из *источника*. Источником может быть любой из "
"следующих:"

#: ../../library/zipapp.rst:115
msgid ""
"The name of a directory, or a :term:`path-like object` referring to a "
"directory, in which case a new application archive will be created from the "
"content of that directory."
msgstr ""
"Имя каталога или объект, подобный пути, ссылающийся на каталог; в этом "
"случае новый архив приложения будет создан из содержимого этого каталога."

#: ../../library/zipapp.rst:118
msgid ""
"The name of an existing application archive file, or a :term:`path-like "
"object` referring to such a file, in which case the file is copied to the "
"target (modifying it to reflect the value given for the *interpreter* "
"argument).  The file name should include the ``.pyz`` extension, if required."
msgstr ""
"Имя существующего файла архива приложения или объект, подобный пути, "
"ссылающийся на такой файл; в этом случае файл копируется в целевой объект "
"(изменивая его так, чтобы он отражал значение, заданное для аргумента "
"*интерпретатор*). ). Имя файла должно включать расширение .pyz, если это "
"необходимо."

#: ../../library/zipapp.rst:122
msgid ""
"A file object open for reading in bytes mode.  The content of the file "
"should be an application archive, and the file object is assumed to be "
"positioned at the start of the archive."
msgstr ""
"Файловый объект, открытый для чтения в байтовом режиме. Содержимым файла "
"должен быть архив приложения, и предполагается, что файловый объект "
"расположен в начале архива."

#: ../../library/zipapp.rst:126
msgid ""
"The *target* argument determines where the resulting archive will be written:"
msgstr "Аргумент *target* определяет, куда будет записан результирующий архив:"

#: ../../library/zipapp.rst:129
msgid ""
"If it is the name of a file, or a :term:`path-like object`, the archive will "
"be written to that file."
msgstr ""
"Если это имя файла или объект, подобный пути, архив будет записан в этот "
"файл."

#: ../../library/zipapp.rst:131
msgid ""
"If it is an open file object, the archive will be written to that file "
"object, which must be open for writing in bytes mode."
msgstr ""
"Если это открытый файловый объект, архив будет записан в этот файловый "
"объект, который должен быть открыт для записи в байтовом режиме."

#: ../../library/zipapp.rst:133
msgid ""
"If the target is omitted (or ``None``), the source must be a directory and "
"the target will be a file with the same name as the source, with a ``.pyz`` "
"extension added."
msgstr ""
"Если цель опущена (или «Нет»), источником должен быть каталог, а целью будет "
"файл с тем же именем, что и у источника, с добавленным расширением «.pyz»."

#: ../../library/zipapp.rst:137
msgid ""
"The *interpreter* argument specifies the name of the Python interpreter with "
"which the archive will be executed.  It is written as a \"shebang\" line at "
"the start of the archive.  On POSIX, this will be interpreted by the OS, and "
"on Windows it will be handled by the Python launcher.  Omitting the "
"*interpreter* results in no shebang line being written.  If an interpreter "
"is specified, and the target is a filename, the executable bit of the target "
"file will be set."
msgstr ""
"Аргумент *interpreter* указывает имя интерпретатора Python, с помощью "
"которого будет выполнен архив. Это написано в виде строки «шебанг» в начале "
"архива. В POSIX это будет интерпретироваться операционной системой, а в "
"Windows — средством запуска Python. Если оставить *интерпретатор*, строка "
"shebang не будет записана. Если указан интерпретатор, а целью является имя "
"файла, будет установлен исполняемый бит целевого файла."

#: ../../library/zipapp.rst:145
msgid ""
"The *main* argument specifies the name of a callable which will be used as "
"the main program for the archive.  It can only be specified if the source is "
"a directory, and the source does not already contain a ``__main__.py`` "
"file.  The *main* argument should take the form \"pkg.module:callable\" and "
"the archive will be run by importing \"pkg.module\" and executing the given "
"callable with no arguments.  It is an error to omit *main* if the source is "
"a directory and does not contain a ``__main__.py`` file, as otherwise the "
"resulting archive would not be executable."
msgstr ""
"Аргумент *main* указывает имя вызываемого объекта, который будет "
"использоваться в качестве основной программы для архива. Его можно указать "
"только в том случае, если источником является каталог и источник еще не "
"содержит файла ``__main__.py``. Аргумент *main* должен иметь форму «pkg."
"module:callable», и архив будет запущен путем импорта «pkg.module» и "
"выполнения данного вызываемого объекта без аргументов. Опущение *main* "
"является ошибкой, если источником является каталог и не содержит файл "
"``__main__.py``, поскольку в противном случае полученный архив не будет "
"исполняемым."

#: ../../library/zipapp.rst:155
msgid ""
"The optional *filter* argument specifies a callback function that is passed "
"a Path object representing the path to the file being added (relative to the "
"source directory).  It should return ``True`` if the file is to be added."
msgstr ""
"Необязательный аргумент *filter* указывает функцию обратного вызова, которой "
"передается объект Path, представляющий путь к добавляемому файлу "
"(относительно исходного каталога). Он должен возвращать ``True``, если файл "
"должен быть добавлен."

#: ../../library/zipapp.rst:160
msgid ""
"The optional *compressed* argument determines whether files are compressed.  "
"If set to ``True``, files in the archive are compressed with the deflate "
"method; otherwise, files are stored uncompressed. This argument has no "
"effect when copying an existing archive."
msgstr ""
"Необязательный аргумент *compressed* определяет, сжаты ли файлы. Если "
"установлено значение True, файлы в архиве сжимаются методом deflate; в "
"противном случае файлы сохраняются в несжатом виде. Этот аргумент не "
"действует при копировании существующего архива."

#: ../../library/zipapp.rst:165
msgid ""
"If a file object is specified for *source* or *target*, it is the caller's "
"responsibility to close it after calling create_archive."
msgstr ""
"Если файловый объект указан для *source* или *target*, ответственность за "
"его закрытие после вызова create_archive лежит на вызывающей стороне."

#: ../../library/zipapp.rst:168
msgid ""
"When copying an existing archive, file objects supplied only need ``read`` "
"and ``readline``, or ``write`` methods.  When creating an archive from a "
"directory, if the target is a file object it will be passed to the ``zipfile."
"ZipFile`` class, and must supply the methods needed by that class."
msgstr ""
"При копировании существующего архива предоставленным файловым объектам "
"требуются только методы ``read`` и ``readline`` или ``write``. При создании "
"архива из каталога, если целью является файловый объект, он будет передан в "
"класс ``zipfile.ZipFile`` и должен предоставить методы, необходимые этому "
"классу."

#: ../../library/zipapp.rst:174
msgid "Added the *filter* and *compressed* parameters."
msgstr "Добавлены параметры *filter* и *compressed*."

#: ../../library/zipapp.rst:179
msgid ""
"Return the interpreter specified in the ``#!`` line at the start of the "
"archive.  If there is no ``#!`` line, return :const:`None`. The *archive* "
"argument can be a filename or a file-like object open for reading in bytes "
"mode.  It is assumed to be at the start of the archive."
msgstr ""
"Вернуть интерпретатор, указанный в строке ``#!`` в начале архива. Если "
"строка ``#!`` отсутствует, верните :const:`None`. Аргумент *archive* может "
"быть именем файла или файловоподобным объектом, открытым для чтения в "
"байтовом режиме. Предполагается, что он находится в начале архива."

#: ../../library/zipapp.rst:188
msgid "Examples"
msgstr "Примеры"

#: ../../library/zipapp.rst:190
msgid "Pack up a directory into an archive, and run it."
msgstr "Упакуйте каталог в архив и запустите его."

#: ../../library/zipapp.rst:192
msgid ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp\n"
"$ python myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:198
msgid "The same can be done using the :func:`create_archive` function::"
msgstr "То же самое можно сделать с помощью функции :func:`create_archive`::"

#: ../../library/zipapp.rst:200
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"
msgstr ""
">>> import zipapp\n"
">>> zipapp.create_archive('myapp', 'myapp.pyz')"

#: ../../library/zipapp.rst:203
msgid ""
"To make the application directly executable on POSIX, specify an interpreter "
"to use."
msgstr ""
"Чтобы сделать приложение исполняемым непосредственно в POSIX, укажите "
"используемый интерпретатор."

#: ../../library/zipapp.rst:206
msgid ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"
msgstr ""
"$ python -m zipapp myapp -p \"/usr/bin/env python\"\n"
"$ ./myapp.pyz\n"
"<output from myapp>"

#: ../../library/zipapp.rst:212
msgid ""
"To replace the shebang line on an existing archive, create a modified "
"archive using the :func:`create_archive` function::"
msgstr ""
"Чтобы заменить строку shebang в существующем архиве, создайте измененный "
"архив с помощью функции :func:`create_archive`::"

#: ../../library/zipapp.rst:215
msgid ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', '/usr/bin/"
"python3')"
msgstr ""
">>> import zipapp\n"
">>> zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', '/usr/bin/"
"python3')"

#: ../../library/zipapp.rst:218
msgid ""
"To update the file in place, do the replacement in memory using a :class:"
"`~io.BytesIO` object, and then overwrite the source afterwards.  Note that "
"there is a risk when overwriting a file in place that an error will result "
"in the loss of the original file.  This code does not protect against such "
"errors, but production code should do so.  Also, this method will only work "
"if the archive fits in memory::"
msgstr ""
"Чтобы обновить файл на месте, выполните замену в памяти, используя объект :"
"class:`~io.BytesIO`, а затем перезапишите исходный код. Обратите внимание, "
"что при перезаписи файла существует риск того, что ошибка приведет к потере "
"исходного файла. Этот код не защищает от таких ошибок, но рабочий код должен "
"это делать. Также этот метод будет работать только в том случае, если архив "
"умещается в памяти::"

#: ../../library/zipapp.rst:225
msgid ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"
msgstr ""
">>> import zipapp\n"
">>> import io\n"
">>> temp = io.BytesIO()\n"
">>> zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')\n"
">>> with open('myapp.pyz', 'wb') as f:\n"
">>>     f.write(temp.getvalue())"

#: ../../library/zipapp.rst:236
msgid "Specifying the Interpreter"
msgstr "Указание интерпретатора"

#: ../../library/zipapp.rst:238
msgid ""
"Note that if you specify an interpreter and then distribute your application "
"archive, you need to ensure that the interpreter used is portable.  The "
"Python launcher for Windows supports most common forms of POSIX ``#!`` line, "
"but there are other issues to consider:"
msgstr ""
"Обратите внимание: если вы указываете интерпретатор, а затем распространяете "
"архив приложения, вам необходимо убедиться, что используемый интерпретатор "
"является переносимым. Средство запуска Python для Windows поддерживает "
"наиболее распространенные формы строки POSIX ``#!``, но есть и другие "
"проблемы, которые следует учитывать:"

#: ../../library/zipapp.rst:243
msgid ""
"If you use \"/usr/bin/env python\" (or other forms of the \"python\" "
"command, such as \"/usr/bin/python\"), you need to consider that your users "
"may have either Python 2 or Python 3 as their default, and write your code "
"to work under both versions."
msgstr ""
"Если вы используете «/usr/bin/env python» (или другие формы команды "
"«python», например «/usr/bin/python»), вам необходимо учитывать, что у ваших "
"пользователей может быть либо Python 2, либо Python 3. по умолчанию и "
"напишите свой код для работы в обеих версиях."

#: ../../library/zipapp.rst:247
msgid ""
"If you use an explicit version, for example \"/usr/bin/env python3\" your "
"application will not work for users who do not have that version.  (This may "
"be what you want if you have not made your code Python 2 compatible)."
msgstr ""
"Если вы используете явную версию, например «/usr/bin/env python3», ваше "
"приложение не будет работать для пользователей, у которых нет этой версии. "
"(Это может быть то, что вам нужно, если вы не сделали свой код совместимым с "
"Python 2)."

#: ../../library/zipapp.rst:250
msgid ""
"There is no way to say \"python X.Y or later\", so be careful of using an "
"exact version like \"/usr/bin/env python3.4\" as you will need to change "
"your shebang line for users of Python 3.5, for example."
msgstr ""
"Невозможно сказать «python XY или более поздняя версия», поэтому будьте "
"осторожны, используя точную версию, например «/usr/bin/env python3.4», так "
"как вам нужно будет изменить строку shebang, например, для пользователей "
"Python 3.5. ."

#: ../../library/zipapp.rst:254
msgid ""
"Typically, you should use an \"/usr/bin/env python2\" or \"/usr/bin/env "
"python3\", depending on whether your code is written for Python 2 or 3."
msgstr ""
"Обычно вам следует использовать «/usr/bin/env python2» или «/usr/bin/env "
"python3» в зависимости от того, написан ли ваш код для Python 2 или 3."

#: ../../library/zipapp.rst:259
msgid "Creating Standalone Applications with zipapp"
msgstr "Создание автономных приложений с помощью zipapp"

#: ../../library/zipapp.rst:261
msgid ""
"Using the :mod:`zipapp` module, it is possible to create self-contained "
"Python programs, which can be distributed to end users who only need to have "
"a suitable version of Python installed on their system.  The key to doing "
"this is to bundle all of the application's dependencies into the archive, "
"along with the application code."
msgstr ""
"Используя модуль :mod:`zipapp`, можно создавать автономные программы Python, "
"которые можно распространять среди конечных пользователей, которым "
"достаточно установить в своей системе подходящую версию Python. Ключом к "
"этому является объединение в архив всех зависимостей приложения вместе с "
"кодом приложения."

#: ../../library/zipapp.rst:267
msgid "The steps to create a standalone archive are as follows:"
msgstr "Шаги по созданию автономного архива следующие:"

#: ../../library/zipapp.rst:269
msgid ""
"Create your application in a directory as normal, so you have a ``myapp`` "
"directory containing a ``__main__.py`` file, and any supporting application "
"code."
msgstr ""
"Создайте приложение в обычном каталоге, чтобы у вас был каталог myapp, "
"содержащий файл __main__.py и весь вспомогательный код приложения."

#: ../../library/zipapp.rst:273
msgid ""
"Install all of your application's dependencies into the ``myapp`` directory, "
"using pip:"
msgstr ""
"Установите все зависимости вашего приложения в каталог myapp, используя pip:"

#: ../../library/zipapp.rst:276
msgid "$ python -m pip install -r requirements.txt --target myapp"
msgstr "$ python -m pip install -r requirements.txt --target myapp"

#: ../../library/zipapp.rst:280
msgid ""
"(this assumes you have your project requirements in a ``requirements.txt`` "
"file - if not, you can just list the dependencies manually on the pip "
"command line)."
msgstr ""
"(предполагается, что требования вашего проекта есть в файле ``requirements."
"txt`` - если нет, вы можете просто перечислить зависимости вручную в "
"командной строке pip)."

#: ../../library/zipapp.rst:284
msgid "Package the application using:"
msgstr "Упакуйте приложение, используя:"

#: ../../library/zipapp.rst:286
msgid "$ python -m zipapp -p \"interpreter\" myapp"
msgstr "$ python -m zipapp -p \"interpreter\" myapp"

#: ../../library/zipapp.rst:290
msgid ""
"This will produce a standalone executable, which can be run on any machine "
"with the appropriate interpreter available. See :ref:`zipapp-specifying-the-"
"interpreter` for details. It can be shipped to users as a single file."
msgstr ""
"В результате будет создан автономный исполняемый файл, который можно будет "
"запустить на любом компьютере с соответствующим доступным интерпретатором. "
"Подробности см. в разделе :ref:`zipapp-specifying-the-interpreter`. Его "
"можно отправить пользователям в виде одного файла."

#: ../../library/zipapp.rst:294
msgid ""
"On Unix, the ``myapp.pyz`` file is executable as it stands.  You can rename "
"the file to remove the ``.pyz`` extension if you prefer a \"plain\" command "
"name.  On Windows, the ``myapp.pyz[w]`` file is executable by virtue of the "
"fact that the Python interpreter registers the ``.pyz`` and ``.pyzw`` file "
"extensions when installed."
msgstr ""
"В Unix файл myapp.pyz является исполняемым в его нынешнем виде. Вы можете "
"переименовать файл, удалив расширение .pyz, если предпочитаете «простое» имя "
"команды. В Windows файл myapp.pyz[w]`` является исполняемым, поскольку "
"интерпретатор Python регистрирует расширения файлов ``.pyz`` и ``.pyzw`` при "
"установке."

#: ../../library/zipapp.rst:302
msgid "Caveats"
msgstr "Предостережения"

#: ../../library/zipapp.rst:304
msgid ""
"If your application depends on a package that includes a C extension, that "
"package cannot be run from a zip file (this is an OS limitation, as "
"executable code must be present in the filesystem for the OS loader to load "
"it). In this case, you can exclude that dependency from the zipfile, and "
"either require your users to have it installed, or ship it alongside your "
"zipfile and add code to your ``__main__.py`` to include the directory "
"containing the unzipped module in ``sys.path``. In this case, you will need "
"to make sure to ship appropriate binaries for your target architecture(s) "
"(and potentially pick the correct version to add to ``sys.path`` at runtime, "
"based on the user's machine)."
msgstr ""
"Если ваше приложение зависит от пакета, включающего расширение C, этот пакет "
"нельзя запустить из zip-файла (это ограничение ОС, поскольку в файловой "
"системе должен присутствовать исполняемый код, чтобы загрузчик ОС мог его "
"загрузить). В этом случае вы можете исключить эту зависимость из zip-файла и "
"либо потребовать, чтобы ваши пользователи установили ее, либо отправить ее "
"вместе с zip-файлом и добавить код в ваш ``__main__.py``, чтобы включить "
"каталог, содержащий разархивированный модуль, в ``sys.path``. В этом случае "
"вам нужно будет убедиться, что вы поставили соответствующие двоичные файлы "
"для вашей целевой архитектуры (и, возможно, выберите правильную версию для "
"добавления в ``sys.path`` во время выполнения, в зависимости от машины "
"пользователя)."

#: ../../library/zipapp.rst:316
msgid "The Python Zip Application Archive Format"
msgstr "Формат архива приложения Python Zip"

#: ../../library/zipapp.rst:318
msgid ""
"Python has been able to execute zip files which contain a ``__main__.py`` "
"file since version 2.6.  In order to be executed by Python, an application "
"archive simply has to be a standard zip file containing a ``__main__.py`` "
"file which will be run as the entry point for the application.  As usual for "
"any Python script, the parent of the script (in this case the zip file) will "
"be placed on :data:`sys.path` and thus further modules can be imported from "
"the zip file."
msgstr ""
"Начиная с версии 2.6, Python может выполнять zip-файлы, содержащие файл "
"``__main__.py``. Чтобы быть выполненным Python, архив приложения просто "
"должен представлять собой стандартный zip-файл, содержащий файл ``__main__."
"py``, который будет запускаться как точка входа для приложения. Как обычно "
"для любого сценария Python, родительский элемент сценария (в данном случае "
"zip-файл) будет помещен в :data:`sys.path` и, таким образом, из zip-файла "
"можно будет импортировать дополнительные модули."

#: ../../library/zipapp.rst:325
msgid ""
"The zip file format allows arbitrary data to be prepended to a zip file.  "
"The zip application format uses this ability to prepend a standard POSIX "
"\"shebang\" line to the file (``#!/path/to/interpreter``)."
msgstr ""
"Формат zip-файла позволяет добавлять к zip-файлу произвольные данные. Формат "
"приложения zip использует эту возможность для добавления к файлу стандартной "
"строки POSIX \"shebang\" (``#!/path/to/interpreter``)."

#: ../../library/zipapp.rst:329
msgid "Formally, the Python zip application format is therefore:"
msgstr "Формально формат zip-приложения Python выглядит следующим образом:"

#: ../../library/zipapp.rst:331
msgid ""
"An optional shebang line, containing the characters ``b'#!'`` followed by an "
"interpreter name, and then a newline (``b'\\n'``) character.  The "
"interpreter name can be anything acceptable to the OS \"shebang\" "
"processing, or the Python launcher on Windows.  The interpreter should be "
"encoded in UTF-8 on Windows, and in :func:`sys.getfilesystemencoding` on "
"POSIX."
msgstr ""
"Необязательная строка shebang, содержащая символы ``b'#!'``, за которыми "
"следует имя интерпретатора, а затем символ новой строки (``b'\\n'``). Имя "
"интерпретатора может быть любым, приемлемым для обработки «shebang» ОС или "
"средства запуска Python в Windows. Интерпретатор должен быть закодирован в "
"UTF-8 в Windows и в :func:`sys.getfilesystemencoding` в POSIX."

#: ../../library/zipapp.rst:336
msgid ""
"Standard zipfile data, as generated by the :mod:`zipfile` module.  The "
"zipfile content *must* include a file called ``__main__.py`` (which must be "
"in the \"root\" of the zipfile - i.e., it cannot be in a subdirectory).  The "
"zipfile data can be compressed or uncompressed."
msgstr ""
"Стандартные данные zip-файла, сгенерированные модулем :mod:`zipfile`. "
"Содержимое zip-файла *должно* включать файл с именем ``__main__.py`` "
"(который должен находиться в «корне» zip-файла, т.е. он не может находиться "
"в подкаталоге). Данные zip-файла могут быть сжатыми или несжатыми."

#: ../../library/zipapp.rst:341
msgid ""
"If an application archive has a shebang line, it may have the executable bit "
"set on POSIX systems, to allow it to be executed directly."
msgstr ""
"Если в архиве приложения есть строка shebang, в системах POSIX может быть "
"установлен бит исполняемого файла, чтобы разрешить его непосредственное "
"выполнение."

#: ../../library/zipapp.rst:344
msgid ""
"There is no requirement that the tools in this module are used to create "
"application archives - the module is a convenience, but archives in the "
"above format created by any means are acceptable to Python."
msgstr ""
"Не требуется, чтобы инструменты этого модуля использовались для создания "
"архивов приложений — модуль удобен, но архивы в указанном выше формате, "
"созданные любыми способами, приемлемы для Python."

#: ../../library/zipapp.rst:11
msgid "Executable Zip Files"
msgstr "Исполняемые ZIP-файлы"
