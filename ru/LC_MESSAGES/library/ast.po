# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:12+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- Абстрактные синтаксические деревья"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Исходный код:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Модуль :mod:`ast` помогает приложениям Python обрабатывать деревья "
"грамматики абстрактного синтаксиса Python. Сам абстрактный синтаксис может "
"меняться с каждым выпуском Python; этот модуль помогает программно узнать, "
"как выглядит текущая грамматика."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Абстрактное синтаксическое дерево можно создать, передав :data:`ast."
"PyCF_ONLY_AST` в качестве флага встроенной функции :func:`compile` или "
"используя вспомогательную функцию :func:`parse`, представленную в этом "
"модуле. Результатом будет дерево объектов, все классы которого наследуются "
"от :class:`ast.AST`. Абстрактное синтаксическое дерево можно скомпилировать "
"в объект кода Python с помощью встроенной функции :func:`compile`."

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "Абстрактная грамматика"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr ""
"Абстрактная грамматика в настоящее время определяется следующим образом:"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Классы узлов"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"Это основа всех классов узлов AST. Фактические классы узлов получены из "
"файла :file:`Parser/Python.asdl`, который воспроизведен :ref:`above "
"<abstract-grammar>`. Они определены в модуле C :mod:`!_ast` и "
"реэкспортируются в :mod:`ast`."

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Для каждого левого символа абстрактной грамматики определен один класс "
"(например, :class:`ast.stmt` или :class:`ast.expr`). Кроме того, для каждого "
"конструктора в правой части определен один класс; эти классы наследуются от "
"классов левых деревьев. Например, :class:`ast.BinOp` наследуется от :class:"
"`ast.expr`. Для производственных правил с альтернативами (также известными "
"как «суммы») левый класс является абстрактным: всегда создаются только "
"экземпляры определенных узлов конструктора."

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"Каждый конкретный класс имеет атрибут :attr:`_fields`, который задаёт имена "
"всех дочерних узлов."

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Каждый экземпляр конкретного класса имеет один атрибут для каждого дочернего "
"узла типа, определенного в грамматике. Например, экземпляры :class:`ast."
"BinOp` имеют атрибут :attr:`left` типа :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Если эти атрибуты помечены в грамматике как необязательные (с помощью "
"вопросительного знака), значение может быть «Нет». Если атрибуты могут иметь "
"ноль или более значений (отмечены звездочкой), значения представляются в "
"виде списков Python. Все возможные атрибуты должны присутствовать и иметь "
"допустимые значения при компиляции AST с помощью :func:`compile`."

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"Экземпляры подклассов :class:`ast.expr` и :class:`ast.stmt` имеют атрибуты :"
"attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` и :attr:"
"`end_col_offset` . :attr:`lineno` и :attr:`end_lineno` — это номера первой и "
"последней строк исходного текстового диапазона (с индексом 1, поэтому первая "
"строка является строкой 1), а :attr:`col_offset` и :attr:` end_col_offset` — "
"это соответствующие смещения байтов UTF-8 первого и последнего токенов, "
"сгенерировавших узел. Смещение UTF-8 записывается, поскольку синтаксический "
"анализатор внутренне использует UTF-8."

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Обратите внимание, что конечные позиции не требуются компилятору и поэтому "
"являются необязательными. Конечное смещение находится *после* последнего "
"символа, например, можно получить исходный сегмент узла однострочного "
"выражения, используя ``source_line[node.col_offset : node.end_col_offset]``."

#: ../../library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Конструктор класса :class:`ast.T` анализирует его аргументы следующим "
"образом:"

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Если есть позиционные аргументы, их должно быть столько, сколько элементов "
"в :attr:`T._fields`; они будут назначены как атрибуты этих имен."

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Если есть аргументы-ключевые слова, они будут устанавливать атрибуты с "
"одинаковыми именами в заданные значения."

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Например, чтобы создать и заполнить узел :class:`ast.UnaryOp`, вы можете "
"использовать ::"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr "или более компактный::"

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "Класс :class:`ast.Constant` теперь используется для всех констант."

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Простые индексы представлены их значениями, расширенные срезы представлены "
"кортежами."

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still available, "
"but they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""
"Старые классы :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, :"
"class:`!ast.NameConstant` и :class:`!ast.Ellipsis ` все еще доступны, но они "
"будут удалены в будущих выпусках Python. Между тем, их создание вернет "
"экземпляр другого класса."

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"Старые классы :class:`!ast.Index` и :class:`!ast.ExtSlice` по-прежнему "
"доступны, но они будут удалены в будущих выпусках Python. Между тем, их "
"создание вернет экземпляр другого класса."

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"Представленные здесь описания конкретных классов узлов изначально были "
"адаптированы из фантастического проекта Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ и всех его участников."

#: ../../library/ast.rst:153
msgid "Root nodes"
msgstr "Корневые узлы"

#: ../../library/ast.rst:157
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type generated "
"by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""
"Модуль Python, как и :ref:`file input <file-input>`. Тип узла, созданный :"
"func:`ast.parse` в режиме ``\"exec\"`` *mode* по умолчанию."

#: ../../library/ast.rst:160
msgid "*body* is a :class:`list` of the module's :ref:`ast-statements`."
msgstr ""

#: ../../library/ast.rst:162
msgid ""
"*type_ignores* is a :class:`list` of the module's type ignore comments; see :"
"func:`ast.parse` for more details."
msgstr ""

#: ../../library/ast.rst:179
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""
"Одно :ref:`входное выражение Python <expression-input>`. Тип узла, "
"создаваемый :func:`ast.parse`, когда *mode* равен ``\"eval\"``."

#: ../../library/ast.rst:182
msgid ""
"*body* is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""

#: ../../library/ast.rst:194
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`. "
"Node type generated by :func:`ast.parse` when *mode* is ``\"single\"``."
msgstr ""
"Один :ref:`interactive input <interactive>`, как в :ref:`tut-interac`. Тип "
"узла, создаваемый :func:`ast.parse`, когда *mode* равен ``\"single\"``."

#: ../../library/ast.rst:197
msgid "*body* is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""

#: ../../library/ast.rst:216
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""
"Представление комментариев типа старого стиля для функций, поскольку версии "
"Python до 3.5 не поддерживали аннотации :pep:`484`. Тип узла, создаваемый :"
"func:`ast.parse`, когда *mode* равен ``\"func_type\"``."

#: ../../library/ast.rst:220
msgid "Such type comments would look like this::"
msgstr "Комментарии такого типа будут выглядеть так::"

#: ../../library/ast.rst:226
msgid ""
"*argtypes* is a :class:`list` of :ref:`expression nodes <ast-expressions>`."
msgstr ""

#: ../../library/ast.rst:228
msgid "*returns* is a single :ref:`expression node <ast-expressions>`."
msgstr ""

#: ../../library/ast.rst:246
msgid "Literals"
msgstr "Литералы"

#: ../../library/ast.rst:250
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"Постоянное значение. Атрибут value литерала Constant содержит объект Python, "
"который он представляет. Представленные значения могут быть простыми типами, "
"такими как число, строка или None, а также неизменяемыми типами контейнеров "
"(кортежи и замороженные наборы), если все их элементы постоянны."

#: ../../library/ast.rst:264
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Узел, представляющий одно поле форматирования в f-строке. Если строка "
"содержит одно поле форматирования и больше ничего, узел можно изолировать, в "
"противном случае он появится в :class:`JoinedStr`."

#: ../../library/ast.rst:268
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``value`` — это любой узел выражения (например, литерал, переменная или "
"вызов функции)."

#: ../../library/ast.rst:270
msgid "``conversion`` is an integer:"
msgstr "``conversion`` - это целое число:"

#: ../../library/ast.rst:272
msgid "-1: no formatting"
msgstr "-1: без форматирования"

#: ../../library/ast.rst:273
msgid "115: ``!s`` string formatting"
msgstr "115: форматирование строки ``!s``"

#: ../../library/ast.rst:274
msgid "114: ``!r`` repr formatting"
msgstr "114: ``!r`` форматирование повтора"

#: ../../library/ast.rst:275
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` форматирование ascii"

#: ../../library/ast.rst:277
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` — это узел :class:`JoinedStr`, представляющий форматирование "
"значения, или ``None``, если формат не был указан. И ``conversion``, и "
"``format_spec`` могут быть установлены одновременно."

#: ../../library/ast.rst:284
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"F-строка, состоящая из серии узлов :class:`FormattedValue` и :class:"
"`Constant`."

#: ../../library/ast.rst:313
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"Список или кортеж. ``elts`` содержит список узлов, представляющих элементы. "
"``ctx`` равен :class:`Store`, если контейнер является целью назначения (т.е. "
"``(x,y)=something``), и :class:`Load` в противном случае."

#: ../../library/ast.rst:339
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr "Набор. ``elts`` содержит список узлов, представляющих элементы набора."

#: ../../library/ast.rst:354
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"Словарь. ``keys`` и ``values`` содержат списки узлов, представляющих ключи и "
"значения соответственно, в соответствующем порядке (то, что будет возвращено "
"при вызове :code:`dictionary.keys()` и :code:`dictionary. значения()`)."

#: ../../library/ast.rst:358
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"При распаковке словаря с использованием словарных литералов выражение, "
"которое нужно раскрыть, попадает в список ``values`` со значением ``None`` в "
"соответствующей позиции в ``keys``."

#: ../../library/ast.rst:376
msgid "Variables"
msgstr "Переменные"

#: ../../library/ast.rst:380
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Имя переменной. ``id`` содержит имя в виде строки, а ``ctx`` представляет "
"собой один из следующих типов."

#: ../../library/ast.rst:388
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"Ссылки на переменные можно использовать для загрузки значения переменной, "
"присвоения ей нового значения или ее удаления. Ссылкам на переменные дается "
"контекст, позволяющий различать эти случаи."

#: ../../library/ast.rst:421
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"Ссылка на переменную ``*var``. ``value`` содержит переменную, обычно это "
"узел :class:`Name`. Этот тип необходимо использовать при построении узла :"
"class:`Call` с ``*args``."

#: ../../library/ast.rst:446
msgid "Expressions"
msgstr "Выражения"

#: ../../library/ast.rst:450
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"Когда выражение, такое как вызов функции, появляется как инструкция, а "
"возвращаемое значение не используется и не сохраняется, оно помещается в "
"этот контейнер. ``value`` содержит один из других узлов в этом разделе: :"
"class:`Constant`, :class:`Name`, :class:`Lambda`, :class:`Yield` или :class: "
"Узел YieldFrom."

#: ../../library/ast.rst:469
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"Унарная операция. ``op`` — это оператор, а ``операн`` — любой узел выражения."

#: ../../library/ast.rst:478
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Токены унарного оператора. :class:`Not` — это ключевое слово ``not``, :class:"
"`Invert` — это оператор ``~``."

#: ../../library/ast.rst:492
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"Бинарная операция (например, сложение или деление). «op» — это оператор, а "
"«left» и «right» — любые узлы выражения."

#: ../../library/ast.rst:519
msgid "Binary operator tokens."
msgstr "Токены бинарных операторов."

#: ../../library/ast.rst:524
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"Логическая операция «или» или «и». ``op`` — это :class:`Or` или :class:"
"`And`. ``ценности`` — это задействованные ценности. Последовательные "
"операции с одним и тем же оператором, например «a, b или c», сворачиваются в "
"один узел с несколькими значениями."

#: ../../library/ast.rst:529
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Сюда не входит ``not``, который является :class:`UnaryOp`."

#: ../../library/ast.rst:545
msgid "Boolean operator tokens."
msgstr "Токены логических операторов."

#: ../../library/ast.rst:550
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"Сравнение двух или более значений. «left» — это первое значение в сравнении, "
"«ops» — список операторов, а «компараторы» — список значений после первого "
"элемента в сравнении."

#: ../../library/ast.rst:579
msgid "Comparison operator tokens."
msgstr "Токены операторов сравнения."

#: ../../library/ast.rst:584
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Вызов функции. ``func`` — это функция, которая часто является объектом :"
"class:`Name` или :class:`Attribute`. Из аргументов:"

#: ../../library/ast.rst:587
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` содержит список аргументов, передаваемых по позиции."

#: ../../library/ast.rst:588
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` содержит список объектов :class:`.keyword`, представляющих "
"аргументы, передаваемые по ключевому слову."

#: ../../library/ast.rst:591
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists."
msgstr ""
"При создании узла ``Call`` обязательны ``args`` и ``keywords``, но они могут "
"быть пустыми списками."

#: ../../library/ast.rst:615
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Ключевое слово-аргумент для вызова функции или определения класса. ``arg`` — "
"это необработанная строка имени параметра, ``value`` — это узел для передачи."

#: ../../library/ast.rst:621
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Такое выражение, как ``a if b else c``. Каждое поле содержит один узел, "
"поэтому в следующем примере все три являются узлами :class:`Name`."

#: ../../library/ast.rst:636
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Доступ к атрибутам, например ``d.keys``. ``value`` — это узел, обычно это :"
"class:`Name`. ``attr`` — это пустая строка, задающая имя атрибута, а "
"``ctx`` – это :class:`Load`, :class:`Store` или :class:`Del` в зависимости "
"от того, как действует атрибут. на."

#: ../../library/ast.rst:653
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Именованное выражение. Этот узел AST создается оператором выражений "
"присваивания (также известным как оператор моржа). В отличие от узла :class:"
"`Assign`, в котором первым аргументом может быть несколько узлов, в этом "
"случае и ``target``, и ``value`` должны быть отдельными узлами."

#: ../../library/ast.rst:668
msgid "Subscripting"
msgstr "Подписка"

#: ../../library/ast.rst:672
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Индекс, например ``l[1]``. ``value`` — это объект с индексом (обычно "
"последовательность или отображение). ``slice`` — это индекс, фрагмент или "
"ключ. Это может быть :class:`Tuple` и содержать :class:`Slice`. ``ctx`` — "
"это :class:`Load`, :class:`Store` или :class:`Del` в зависимости от "
"действия, выполняемого с индексом."

#: ../../library/ast.rst:696
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Обычная нарезка (в форме «нижний:верхний» или «нижний:верхний:ступень»). "
"Может встречаться только внутри поля *slice* :class:`Subscript`, либо "
"напрямую, либо как элемент :class:`Tuple`."

#: ../../library/ast.rst:713
msgid "Comprehensions"
msgstr "Comprehensions"

#: ../../library/ast.rst:720
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"Понимания списков и множеств, выражения-генераторы и словарные понимания. "
"``elt`` (или ``key`` и ``value``) — это один узел, представляющий часть, "
"которая будет оцениваться для каждого элемента."

#: ../../library/ast.rst:724
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``генераторы`` — это список узлов понимания."

#: ../../library/ast.rst:766
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"Одно предложение ``for`` в понимании. ``target`` — это ссылка, которую "
"следует использовать для каждого элемента — обычно это узел :class:`Name` "
"или :class:`Tuple`. ``iter`` — это объект для перебора. ``ifs`` — это список "
"тестовых выражений: каждое предложение ``for`` может иметь несколько ``ifs``."

#: ../../library/ast.rst:771
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` указывает, что понимание является асинхронным (используется "
"``async for`` вместо ``for``). Значение представляет собой целое число (0 "
"или 1)."

#: ../../library/ast.rst:840
msgid "Statements"
msgstr "Инструкции"

#: ../../library/ast.rst:844
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr "Задание. «targets» — это список узлов, а «value» — это один узел."

#: ../../library/ast.rst:846
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Несколько узлов в ``targets`` представляют собой присвоение каждому одного и "
"того же значения. Распаковка представлена ​​помещением :class:`Tuple` или :"
"class:`List` в ``targets``."

#: ../../library/ast.rst:852 ../../library/ast.rst:1139
#: ../../library/ast.rst:1343 ../../library/ast.rst:1764
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` — это необязательная строка с аннотацией типа в качестве "
"комментария."

#: ../../library/ast.rst:882
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""

#: ../../library/ast.rst:937
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Расширенное присваивание, например ``a += 1``. В следующем примере "
"``target`` — это узел :class:`Name` для ``x`` (с контекстом :class:`Store`), "
"``op`` — это :class:`Add`, а ``value`` — это :class:`Constant` со значением "
"1."

#: ../../library/ast.rst:942
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"Атрибут ``target`` не может относиться к классу :class:`Tuple` или :class:"
"`List`, в отличие от целей :class:`Assign`."

#: ../../library/ast.rst:959
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Заявление о повышении. ``exc`` — это вызываемый объект исключения, обычно "
"это :class:`Call` или :class:`Name`, или ``None`` для автономного ``raise``. "
"``cause`` является необязательной частью ``y`` в ``поднимите x из y``."

#: ../../library/ast.rst:976
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Утверждение. ``test`` содержит условие, например, узел :class:`Compare`. "
"``msg`` содержит сообщение об ошибке."

#: ../../library/ast.rst:992
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Представляет оператор del. ``targets`` — это список узлов, таких как узлы :"
"class:`Name`, :class:`Attribute` или :class:`Subscript`."

#: ../../library/ast.rst:1010
msgid "A ``pass`` statement."
msgstr "Заявление о пропуске."

#: ../../library/ast.rst:1021
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Другие операторы, применимые только внутри функций или циклов, описаны в "
"других разделах."

#: ../../library/ast.rst:1025
msgid "Imports"
msgstr "Imports"

#: ../../library/ast.rst:1029
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "Заявление об импорте. ``names`` — это список узлов :class:`alias`."

#: ../../library/ast.rst:1046
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Представляет ``from x import y``. ``module`` — это необработанная строка "
"имени from без каких-либо начальных точек или ``None`` для таких операторов, "
"как ``from . импортировать foo``. ``level`` — целое число, содержащее "
"уровень относительного импорта (0 означает абсолютный импорт)."

#: ../../library/ast.rst:1068
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Оба параметра представляют собой необработанные строки имен. ``asname`` "
"может быть ``None``, если будет использоваться обычное имя."

#: ../../library/ast.rst:1085
msgid "Control flow"
msgstr "Поток управления"

#: ../../library/ast.rst:1088
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Необязательные предложения, такие как else, сохраняются как пустой список, "
"если они отсутствуют."

#: ../../library/ast.rst:1093
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"Оператор «если». ``test`` содержит один узел, например узел :class:"
"`Compare`. ``body`` и ``orelse`` содержат список узлов."

#: ../../library/ast.rst:1096
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"Предложения ``elif`` не имеют специального представления в AST, а скорее "
"появляются как дополнительные узлы :class:`If` в разделе ``orelse`` "
"предыдущего."

#: ../../library/ast.rst:1131
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""

#: ../../library/ast.rst:1165
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"Цикл while. ``test`` содержит условие, например, узел :class:`Compare`."

#: ../../library/ast.rst:1192
msgid "The ``break`` and ``continue`` statements."
msgstr "Операторы ``break`` и ``continue``."

#: ../../library/ast.rst:1227
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``try`` блоки. Все атрибуты представляют собой список узлов для выполнения, "
"за исключением ``handlers``, который представляет собой список узлов :class:"
"`ExceptHandler`."

#: ../../library/ast.rst:1273
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes are "
"the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then ``except``."
msgstr ""
"Блоки ``try``, за которыми следуют предложения ``кроме*``. Атрибуты такие "
"же, как и для :class:`Try`, но узлы :class:`ExceptHandler` в ``handlers`` "
"интерпретируются как блоки ``кроме*``, а не как ``кроме``."

#: ../../library/ast.rst:1304
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"Единственное предложение «кроме». ``type`` — это тип исключения, которому он "
"будет соответствовать, обычно это узел :class:`Name` (или ``None`` для "
"универсального предложения ``кроме:``). ``name`` — это необработанная строка "
"для имени, в котором будет храниться исключение, или ``None``, если в "
"предложении нет ``as foo``. ``body`` — это список узлов."

#: ../../library/ast.rst:1338
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Блок ``with``. ``items`` — это список узлов :class:`withitem`, "
"представляющих менеджеры контекста, а ``body`` — это блок с отступом внутри "
"контекста."

#: ../../library/ast.rst:1348
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"Один контекстный менеджер в блоке with. ``context_expr`` — это менеджер "
"контекста, часто это узел :class:`Call`. ``optional_vars`` — это :class:"
"`Name`, :class:`Tuple` или :class:`List` для части ``as foo`` или ``None``, "
"если он не используется."

#: ../../library/ast.rst:1381
msgid "Pattern matching"
msgstr "Сопоставление с образцом"

#: ../../library/ast.rst:1386
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"Заявление о совпадении. ``subject`` содержит предмет совпадения (объект, "
"который сопоставляется с вариантами), а ``cases`` содержит итерацию узлов :"
"class:`match_case` с различными вариантами."

#: ../../library/ast.rst:1392
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Одиночный шаблон в операторе match. ``pattern`` содержит шаблон "
"соответствия, с которым будет сопоставляться предмет. Обратите внимание, что "
"узлы :class:`AST`, созданные для шаблонов, отличаются от узлов, созданных "
"для выражений, даже если они имеют один и тот же синтаксис."

#: ../../library/ast.rst:1397
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""
"Атрибут Guard содержит выражение, которое будет оцениваться, если шаблон "
"соответствует теме."

#: ../../library/ast.rst:1400
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` содержит список узлов, которые необходимо выполнить, если шаблон "
"соответствует и результат вычисления защитного выражения истинен."

#: ../../library/ast.rst:1443
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"Шаблон соответствия литерала или значения, который сравнивается на "
"равенство. ``value`` — это узел выражения. Узлы разрешенных значений "
"ограничены, как описано в документации по оператору сопоставления. Этот "
"шаблон успешен, если предмет соответствия равен вычисленному значению."

#: ../../library/ast.rst:1470
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Шаблон литерала соответствия, который сравнивается по идентичности. "
"``value`` — это синглтон для сравнения: ``None``, ``True`` или ``False``. "
"Этот шаблон успешен, если предметом сопоставления является заданная "
"константа."

#: ../../library/ast.rst:1495
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Шаблон последовательности совпадений. ``patterns`` содержит шаблоны, которые "
"нужно сопоставить с элементами субъекта, если субъектом является "
"последовательность. Соответствует последовательности переменной длины, если "
"один из подшаблонов является узлом MatchStar, в противном случае "
"соответствует последовательности фиксированной длины."

#: ../../library/ast.rst:1526
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Соответствует остальной части последовательности в шаблоне "
"последовательности соответствия переменной длины. Если ``name`` не равно "
"``None``, список, содержащий оставшиеся элементы последовательности, "
"привязывается к этому имени, если общий шаблон последовательности успешен."

#: ../../library/ast.rst:1566
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"Шаблон сопоставления совпадений. ``ключи`` — это последовательность узлов "
"выражения. ``шаблоны`` — это соответствующая последовательность узлов "
"шаблона. ``rest`` — это необязательное имя, которое можно указать для "
"захвата остальных элементов сопоставления. Разрешенные ключевые выражения "
"ограничены, как описано в документации по операторам сопоставления."

#: ../../library/ast.rst:1572
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Этот шаблон успешен, если субъект является сопоставлением, все вычисленные "
"ключевые выражения присутствуют в сопоставлении и значение, соответствующее "
"каждому ключу, соответствует соответствующему подшаблону. Если ``rest`` не "
"равен ``None``, словарь, содержащий оставшиеся элементы сопоставления, "
"привязывается к этому имени, если общий шаблон сопоставления успешен."

#: ../../library/ast.rst:1612
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Шаблон класса соответствия. ``cls`` — это выражение, задающее номинальный "
"класс, который необходимо сопоставить. ``шаблоны`` — это последовательность "
"узлов шаблона, которая сопоставляется с определенной классом "
"последовательностью атрибутов сопоставления с шаблоном. ``kwd_attrs`` — это "
"последовательность дополнительных атрибутов, которые необходимо сопоставить "
"(указанные как аргументы ключевых слов в шаблоне класса), ``kwd_patterns`` — "
"соответствующие шаблоны (заданные как значения ключевых слов в шаблоне "
"класса)."

#: ../../library/ast.rst:1619
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Этот шаблон успешен, если субъект является экземпляром назначенного класса, "
"все позиционные шаблоны соответствуют соответствующим атрибутам, "
"определенным классом, и все указанные атрибуты ключевого слова соответствуют "
"соответствующему шаблону."

#: ../../library/ast.rst:1623
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Примечание. Классы могут определять свойство, которое возвращает self, чтобы "
"сопоставить узел шаблона с сопоставляемым экземпляром. Некоторые встроенные "
"типы также сопоставляются таким образом, как описано в документации по "
"операторам сопоставления."

#: ../../library/ast.rst:1676
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"Соответствие «как шаблон», шаблон захвата или шаблон подстановочного знака. "
"``pattern`` содержит шаблон соответствия, с которым будет сопоставляться "
"предмет. Если шаблон имеет значение «Нет», узел представляет шаблон захвата "
"(т. е. чистое имя) и всегда будет успешным."

#: ../../library/ast.rst:1681
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"Атрибут ``name`` содержит имя, которое будет привязано, если шаблон окажется "
"успешным. Если ``name`` имеет значение ``None``, ``шаблон`` также должен "
"быть ``None``, а узел представляет шаблон подстановочного знака."

#: ../../library/ast.rst:1717
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"Соответствие «или-шаблон». Шаблон «или» по очереди сопоставляет каждый из "
"своих подшаблонов с предметом, пока один из них не добьется успеха. Тогда "
"шаблон «или» считается успешным. Если ни один из подшаблонов не удался, то "
"шаблон or терпит неудачу. Атрибут «patterns» содержит список узлов шаблона "
"соответствия, которые будут сопоставлены с предметом."

#: ../../library/ast.rst:1749
msgid "Function and class definitions"
msgstr "Определения функций и классов"

#: ../../library/ast.rst:1753
msgid "A function definition."
msgstr "Определение функции."

#: ../../library/ast.rst:1755
msgid "``name`` is a raw string of the function name."
msgstr "``name`` — это необработанная строка имени функции."

#: ../../library/ast.rst:1756
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` — это узел :class:`arguments`."

#: ../../library/ast.rst:1757
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` — это список узлов внутри функции."

#: ../../library/ast.rst:1758
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` — это список декораторов, которые будут применены, и он "
"сохраняется первым (т. е. первый в списке будет применен последним)."

#: ../../library/ast.rst:1760
msgid "``returns`` is the return annotation."
msgstr "``returns`` — это аннотация возврата."

#: ../../library/ast.rst:1769
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"«Лямбда» — это минимальное определение функции, которое можно использовать "
"внутри выражения. В отличие от :class:`FunctionDef`, ``body`` содержит один "
"узел."

#: ../../library/ast.rst:1793
msgid "The arguments for a function."
msgstr "Аргументы функции."

#: ../../library/ast.rst:1795
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` и ``kwonlyargs`` представляют собой списки узлов :"
"class:`arg`."

#: ../../library/ast.rst:1796
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` и ``kwarg`` — это одиночные узлы :class:`arg`, ссылающиеся на "
"параметры ``*args, **kwargs``."

#: ../../library/ast.rst:1798
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` — это список значений по умолчанию для аргументов, "
"содержащих только ключевые слова. Если один из них имеет значение «Нет», "
"требуется соответствующий аргумент."

#: ../../library/ast.rst:1800
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` — это список значений по умолчанию для аргументов, которые "
"можно передавать позиционно. Если значений по умолчанию меньше, они "
"соответствуют последним n аргументам."

#: ../../library/ast.rst:1807
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name; "
"``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""
"Один аргумент в списке. ``arg`` — это необработанная строка имени аргумента; "
"``annotation`` — это его аннотация, например узел :class:`Name`."

#: ../../library/ast.rst:1812
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` — необязательная строка с аннотацией типа в качестве "
"комментария."

#: ../../library/ast.rst:1856
msgid "A ``return`` statement."
msgstr "Заявление о возврате."

#: ../../library/ast.rst:1871
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""

#: ../../library/ast.rst:1896
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"``global`` and ``nonlocal`` statements. ``names`` это список необработанных "
"строк. "

#: ../../library/ast.rst:1923
msgid "A class definition."
msgstr "Определение класса."

#: ../../library/ast.rst:1925
msgid "``name`` is a raw string for the class name"
msgstr "``name`` — это необработанная строка для имени класса."

#: ../../library/ast.rst:1926
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``bases`` — это список узлов для явно указанных базовых классов."

#: ../../library/ast.rst:1927
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://peps.python.org/pep-3115/>`_."
msgstr ""

#: ../../library/ast.rst:1930
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr "``body`` — это список узлов, представляющих код в определении класса."

#: ../../library/ast.rst:1932
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` — это список узлов, например :class:`FunctionDef`."

#: ../../library/ast.rst:1961
msgid "Async and await"
msgstr "Асинхронность и ожидание"

#: ../../library/ast.rst:1965
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"Определение функции ``async def``. Имеет те же поля, что и :class:"
"`FunctionDef`."

#: ../../library/ast.rst:1971
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Выражение ``await``. ``value`` — это то, чего он ждет. Допустимо только в "
"теле :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2004
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Циклы ``async for`` и контекстные менеджеры ``async с``. Они имеют те же "
"поля, что и :class:`For` и :class:`With` соответственно. Допустимо только в "
"теле :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:2009
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"Когда строка анализируется с помощью :func:`ast.parse`, узлы операторов "
"(подклассы :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :"
"class: `ast.boolop` и :class:`ast.expr_context`) в возвращаемом дереве будут "
"одиночными. Изменения одного из них будут отражены во всех остальных "
"экземплярах того же значения (например, :class:`ast.Add`)."

#: ../../library/ast.rst:2017
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` Помощники"

#: ../../library/ast.rst:2019
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Помимо классов узлов, модуль :mod:`ast` определяет следующие служебные "
"функции и классы для обхода абстрактных синтаксических деревьев:"

#: ../../library/ast.rst:2024
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"Разберите источник в узел AST. Эквивалент ``compile(source, filename, mode, "
"ast.PyCF_ONLY_AST)``."

#: ../../library/ast.rst:2027
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""

#: ../../library/ast.rst:2037
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Кроме того, если ``mode`` имеет ``'func_type'``, синтаксис ввода изменяется, "
"чтобы соответствовать :pep:`484` \"комментариям типа сигнатуры\", например "
"``(str, int) -> List[ ул]``."

#: ../../library/ast.rst:2041
msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in a "
"\"best-effort\" attempt to parse using that Python version's grammar. For "
"example, setting ``feature_version=(3, 9)`` will attempt to disallow parsing "
"of :keyword:`match` statements. Currently ``major`` must equal to ``3``. The "
"lowest supported version is ``(3, 4)`` (and this may increase in future "
"Python versions); the highest is ``sys.version_info[0:2]``. \"Best-effort\" "
"attempt means there is no guarantee that the parse (or success of the parse) "
"is the same as when run on the Python version corresponding to "
"``feature_version``."
msgstr ""
"Установка ``feature_version`` в кортеж ``(основной, минорный)`` приведет к "
"\"максимальной\" попытке анализа с использованием грамматики этой версии "
"Python. Например, установка ``feature_version=(3, 9)`` попытается запретить "
"анализ операторов :keyword:`match`. В настоящее время ``major`` должен быть "
"равен ``3``. Самая низкая поддерживаемая версия — «(3, 4)» (и в будущих "
"версиях Python это значение может увеличиться); самый высокий — ``sys."
"version_info[0:2]``. Попытка «максимального усилия» означает, что нет "
"никакой гарантии, что анализ (или успех анализа) будет таким же, как при "
"запуске на версии Python, соответствующей ``feature_version``."

#: ../../library/ast.rst:2051
msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is raised."
msgstr ""
"Если источник содержит нулевой символ (``\\0``), возникает :exc:`ValueError`."

#: ../../library/ast.rst:2054
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Обратите внимание, что успешный анализ исходного кода в объект AST не "
"гарантирует, что предоставленный исходный код является допустимым кодом "
"Python, который может быть выполнен, поскольку этап компиляции может вызвать "
"дополнительные исключения :exc:`SyntaxError`. Например, исходный return 42 "
"генерирует действительный узел AST для оператора return, но его нельзя "
"скомпилировать отдельно (он должен находиться внутри функционального узла)."

#: ../../library/ast.rst:2061
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"В частности, :func:`ast.parse` не будет выполнять никаких проверок области "
"видимости, которые выполняются на этапе компиляции."

#: ../../library/ast.rst:2065
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Интерпретатор Python может привести к сбою при использовании достаточно "
"большой/сложной строки из-за ограничений глубины стека в компиляторе Python "
"AST."

#: ../../library/ast.rst:2069
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Добавлены ``type_comments``, ``mode='func_type'`` и ``feature_version``."

#: ../../library/ast.rst:2075
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Разберите объект :class:`ast.AST` и сгенерируйте строку с кодом, которая "
"создаст эквивалентный объект :class:`ast.AST` при обратном анализе с "
"помощью :func:`ast.parse`."

#: ../../library/ast.rst:2080
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"Созданная строка кода не обязательно будет равна исходному коду, который "
"сгенерировал объект :class:`ast.AST` (без каких-либо оптимизаций "
"компилятора, таких как константные кортежи/замороженные наборы)."

#: ../../library/ast.rst:2085
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Попытка разобрать очень сложное выражение приведет к ошибке :exc:"
"`RecursionError`."

#: ../../library/ast.rst:2093
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Оцените узел выражения или строку, содержащую только литерал Python или "
"отображение контейнера. Предоставленная строка или узел может состоять "
"только из следующих литеральных структур Python: строки, байты, числа, "
"кортежи, списки, словари, наборы, логические значения, ``Нет`` и "
"``Многоточие``."

#: ../../library/ast.rst:2098
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"Это можно использовать для оценки строк, содержащих значения Python, без "
"необходимости самостоятельно анализировать значения. Он не способен "
"оценивать произвольно сложные выражения, например, с использованием "
"операторов или индексации."

#: ../../library/ast.rst:2103
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Раньше эта функция была задокументирована как «безопасная» без указания "
"того, что это означает. Это вводило в заблуждение. Это специально "
"разработано для того, чтобы не выполнять код Python, в отличие от более "
"общего :func:`eval`. Здесь нет пространства имен, поиска имен или "
"возможности вызова. Но он не застрахован от атак: относительно небольшой "
"ввод может привести к исчерпанию памяти или к исчерпанию стека C, что "
"приведет к сбою процесса. Также существует вероятность отказа в обслуживании "
"из-за чрезмерного потребления ресурсов ЦП на некоторых входах. Поэтому не "
"рекомендуется вызывать его для ненадежных данных."

#: ../../library/ast.rst:2113
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"Интерпретатор Python может выйти из строя из-за ограничений глубины стека в "
"компиляторе AST Python."

#: ../../library/ast.rst:2116
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"Он может вызывать :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :"
"exc:`MemoryError` и :exc:`RecursionError` в зависимости от неправильного "
"ввода."

#: ../../library/ast.rst:2120
msgid "Now allows bytes and set literals."
msgstr "Теперь разрешены байты и заданные литералы."

#: ../../library/ast.rst:2123
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Теперь поддерживается создание пустых наборов с помощью ``'set()'``."

#: ../../library/ast.rst:2126
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "Для строкового ввода теперь удаляются ведущие пробелы и табуляции."

#: ../../library/ast.rst:2132
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Возвращает строку документации данного *узла* (который должен быть узлом :"
"class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef` или :class:"
"`Module`) или ``None` ` если у него нет строки документации. Если *clean* "
"истинно, очистите отступы строки документации с помощью :func:`inspect."
"cleandoc`."

#: ../../library/ast.rst:2138
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` теперь поддерживается."

#: ../../library/ast.rst:2144
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.end_lineno`, :"
"attr:`~ast.AST.col_offset`, or :attr:`~ast.AST.end_col_offset`) is missing, "
"return ``None``."
msgstr ""
"Получите сегмент исходного кода *источника*, который сгенерировал *узел*. "
"Если какая-либо информация о местоположении (:attr:`~ast.AST.lineno`, :attr:"
"`~ast.AST.end_lineno`, :attr:`~ast.AST.col_offset` или :attr:`~ast.AST ."
"end_col_offset`) отсутствует, верните ``None``."

#: ../../library/ast.rst:2148
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Если *padded* имеет значение True, первая строка многострочного оператора "
"будет дополнена пробелами, чтобы соответствовать исходному положению."

#: ../../library/ast.rst:2156
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for every "
"node that supports them.  This is rather tedious to fill in for generated "
"nodes, so this helper adds these attributes recursively where not already "
"set, by setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
"Когда вы компилируете дерево узлов с помощью :func:`compile`, компилятор "
"ожидает атрибуты :attr:`~ast.AST.lineno` и :attr:`~ast.AST.col_offset` для "
"каждого узла, который их поддерживает. Заполнять сгенерированные узлы "
"довольно утомительно, поэтому этот помощник рекурсивно добавляет эти "
"атрибуты там, где они еще не установлены, устанавливая для них значения "
"родительского узла. Он работает рекурсивно, начиная с *узла*."

#: ../../library/ast.rst:2165
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Увеличьте номер строки и номер конечной строки каждого узла в дереве, "
"начиная с *node*, на *n*. Это полезно для «перемещения кода» в другое место "
"файла."

#: ../../library/ast.rst:2172
msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, :attr:`~ast.AST.col_offset`, :"
"attr:`~ast.AST.end_lineno`, and :attr:`~ast.AST.end_col_offset`) from "
"*old_node* to *new_node* if possible, and return *new_node*."
msgstr ""
"Скопируйте исходное местоположение (:attr:`~ast.AST.lineno`, :attr:`~ast.AST."
"col_offset`, :attr:`~ast.AST.end_lineno` и :attr:`~ast.AST.AST. "
"end_col_offset`) от *old_node* до *new_node*, если это возможно, и вернуть "
"*new_node*."

#: ../../library/ast.rst:2179
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Выдайте кортеж ``(fieldname, value)`` для каждого поля в ``node._fields``, "
"которое присутствует на *node*."

#: ../../library/ast.rst:2185
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Выдать все прямые дочерние узлы *node*, то есть все поля, которые являются "
"узлами, и все элементы полей, которые являются списками узлов."

#: ../../library/ast.rst:2191
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Рекурсивно вывести все узлы-потомки в дереве, начиная с *node* (включая сам "
"*node*), в произвольном порядке. Это полезно, если вы хотите изменять узлы "
"только на месте и не заботитесь о контексте."

#: ../../library/ast.rst:2198
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Базовый класс посетителей узла, который обходит абстрактное синтаксическое "
"дерево и вызывает функцию посетителя для каждого найденного узла. Эта "
"функция может возвращать значение, которое пересылается методом :meth:"
"`visit`."

#: ../../library/ast.rst:2202
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Предполагается, что этот класс будет подклассом, при этом подкласс добавит "
"методы посетителя."

#: ../../library/ast.rst:2207
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Посетите узел. Реализация по умолчанию вызывает метод :samp:`self."
"visit_{classname}`, где *classname* — имя класса узла, или :meth:"
"`generic_visit`, если этот метод не существует."

#: ../../library/ast.rst:2213
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Этот посетитель вызывает :meth:`visit` для всех дочерних узлов узла."

#: ../../library/ast.rst:2215
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Обратите внимание, что дочерние узлы узлов, имеющих собственный метод "
"посетителя, не будут посещены, если посетитель не вызовет :meth:"
"`generic_visit` или не посетит их сам."

#: ../../library/ast.rst:2221
msgid "Handles all constant nodes."
msgstr "Обрабатывает все постоянные узлы."

#: ../../library/ast.rst:2223
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"Не используйте :class:`NodeVisitor`, если вы хотите применить изменения к "
"узлам во время обхода. Для этого существует специальный посетитель (:class:"
"`NodeTransformer`), который позволяет вносить изменения."

#: ../../library/ast.rst:2229
msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :meth:"
"`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated now and "
"will not be called in future Python versions.  Add the :meth:"
"`visit_Constant` method to handle all constant nodes."
msgstr ""
"Методы :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, :meth:`!"
"visit_NameConstant` и :meth:`!visit_Ellipsis` устарели и не будут вызываться "
"в будущем. Версии Python. Добавьте метод :meth:`visit_Constant` для "
"обработки всех постоянных узлов."

#: ../../library/ast.rst:2237
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"Подкласс :class:`NodeVisitor`, который обходит абстрактное синтаксическое "
"дерево и позволяет изменять узлы."

#: ../../library/ast.rst:2240
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` будет проходить AST и использовать возвращаемое "
"значение методов посетителя для замены или удаления старого узла. Если "
"возвращаемое значение метода посетителя равно None, узел будет удален из "
"своего местоположения, в противном случае он заменяется возвращаемым "
"значением. Возвращаемое значение может быть исходным узлом, и в этом случае "
"замена не происходит."

#: ../../library/ast.rst:2246
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Вот пример преобразователя, который перезаписывает все вхождения поиска "
"имени (``foo``) в ``data['foo']``::"

#: ../../library/ast.rst:2258
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`~ast."
"NodeVisitor.generic_visit` method for the node first."
msgstr ""
"Имейте в виду, что если узел, с которым вы работаете, имеет дочерние узлы, "
"вы должны либо преобразовать дочерние узлы самостоятельно, либо сначала "
"вызвать метод :meth:`~ast.NodeVisitor.generic_visit` для узла."

#: ../../library/ast.rst:2262
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Для узлов, которые были частью набора операторов (это относится ко всем "
"узлам операторов), посетитель также может вернуть список узлов, а не только "
"один узел."

#: ../../library/ast.rst:2266
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:`~ast."
"AST.lineno`), :func:`fix_missing_locations` should be called with the new "
"sub-tree to recalculate the location information::"
msgstr ""
"Если :class:`NodeTransformer` вводит новые узлы (которые не были частью "
"исходного дерева) без предоставления им информации о местоположении "
"(например, :attr:`~ast.AST.lineno`), следует вызвать :func:"
"`fix_missing_locations` с новым поддеревом для пересчета информации о "
"местоположении::"

#: ../../library/ast.rst:2274
msgid "Usually you use the transformer like this::"
msgstr "Обычно вы используете трансформатор следующим образом:"

#: ../../library/ast.rst:2281
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Вернуть отформатированный дамп дерева в *node*. В основном это полезно для "
"целей отладки. Если *annotate_fields* имеет значение true (по умолчанию), в "
"возвращаемой строке будут показаны имена и значения полей. Если "
"*annotate_fields* имеет значение false, результирующая строка будет более "
"компактной за счет исключения однозначных имен полей. Атрибуты, такие как "
"номера строк и смещения столбцов, по умолчанию не выгружаются. Если это "
"необходимо, для *include_attributes* можно установить значение true."

#: ../../library/ast.rst:2289
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Если *indent* является неотрицательным целым числом или строкой, то дерево "
"будет красиво напечатано с таким уровнем отступа. Уровень отступа 0, "
"отрицательный или ``\"\"`` будет вставлять только новые строки. ``Нет`` (по "
"умолчанию) выбирает однострочное представление. Использование положительного "
"целочисленного отступа приводит к отступу на такое количество пробелов на "
"уровень. Если *indent* — это строка (например, ``\"\\t\"``), эта строка "
"используется для отступа каждого уровня."

#: ../../library/ast.rst:2296
msgid "Added the *indent* option."
msgstr "Добавлен параметр *отступ*."

#: ../../library/ast.rst:2303
msgid "Compiler Flags"
msgstr "Флаги компилятора"

#: ../../library/ast.rst:2305
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Следующие флаги могут быть переданы в :func:`compile`, чтобы изменить эффект "
"компиляции программы:"

#: ../../library/ast.rst:2310
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Включает поддержку верхнего уровня ``await``, ``async for``, ``async with`` "
"и асинхронного понимания."

#: ../../library/ast.rst:2317
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Создает и возвращает абстрактное синтаксическое дерево вместо возврата "
"объекта скомпилированного кода."

#: ../../library/ast.rst:2322
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Включает поддержку комментариев типа стиля :pep:`484` и :pep:`526` (``# "
"type: <type>``, ``# type: ignore <stuff>``)."

#: ../../library/ast.rst:2331
msgid "Command-Line Usage"
msgstr "Использование командной строки"

#: ../../library/ast.rst:2335
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"Модуль :mod:`ast` можно запустить как скрипт из командной строки. Это так же "
"просто, как:"

#: ../../library/ast.rst:2342
msgid "The following options are accepted:"
msgstr "Принимаются следующие варианты:"

#: ../../library/ast.rst:2348
msgid "Show the help message and exit."
msgstr "Покажите справочное сообщение и выйдите."

#: ../../library/ast.rst:2353
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Укажите, какой код должен быть скомпилирован, например, аргумент *mode* в :"
"func:`parse`."

#: ../../library/ast.rst:2358
msgid "Don't parse type comments."
msgstr "Не анализируйте комментарии типа."

#: ../../library/ast.rst:2362
msgid "Include attributes such as line numbers and column offsets."
msgstr "Включите такие атрибуты, как номера строк и смещения столбцов."

#: ../../library/ast.rst:2367
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Отступы узлов в AST (количество пробелов)."

#: ../../library/ast.rst:2369
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Если указан :file:`infile`, его содержимое анализируется в AST и выгружается "
"на стандартный вывод. В противном случае содержимое считывается со "
"стандартного ввода."

#: ../../library/ast.rst:2375
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, внешний "
"ресурс документации, содержит подробные сведения о работе с Python AST."

#: ../../library/ast.rst:2378
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"аннотирует AST Python положениями токенов и текстом в исходном коде, который "
"их сгенерировал. Это полезно для инструментов, которые выполняют "
"преобразования исходного кода."

#: ../../library/ast.rst:2383
msgid ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:2387
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ анализирует код как конкретное "
"синтаксическое дерево, которое выглядит как дерево ast и сохраняет все "
"детали форматирования. Это полезно для создания приложений и линтеров "
"автоматического рефакторинга (codemod)."

#: ../../library/ast.rst:2392
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""

#: ../../library/ast.rst:59
msgid "? (question mark)"
msgstr "? (знак вопроса)"

#: ../../library/ast.rst:59 ../../library/ast.rst:60
msgid "in AST grammar"
msgstr "в грамматике АСТ"

#: ../../library/ast.rst:60
msgid "* (asterisk)"
msgstr "* (звёздочка)"
