# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/queue.rst:2
msgid ":mod:`queue` --- A synchronized queue class"
msgstr ""

#: ../../library/queue.rst:7
msgid "**Source code:** :source:`Lib/queue.py`"
msgstr "**Исходный код:** :source:`Lib/queue.py`"

#: ../../library/queue.rst:11
msgid ""
"The :mod:`queue` module implements multi-producer, multi-consumer queues. It "
"is especially useful in threaded programming when information must be "
"exchanged safely between multiple threads.  The :class:`Queue` class in this "
"module implements all the required locking semantics."
msgstr ""
"Модуль :mod:`queue` реализует очереди с несколькими производителями и "
"несколькими потребителями. Это особенно полезно в многопоточном "
"программировании, когда необходимо безопасно обмениваться информацией между "
"несколькими потоками. Класс :class:`Queue` в этом модуле реализует всю "
"необходимую семантику блокировки."

#: ../../library/queue.rst:16
msgid ""
"The module implements three types of queue, which differ only in the order "
"in which the entries are retrieved.  In a :abbr:`FIFO (first-in, first-out)` "
"queue, the first tasks added are the first retrieved.  In a :abbr:`LIFO "
"(last-in, first-out)` queue, the most recently added entry is the first "
"retrieved (operating like a stack).  With a priority queue, the entries are "
"kept sorted (using the :mod:`heapq` module) and the lowest valued entry is "
"retrieved first."
msgstr ""
"Модуль реализует три типа очередей, которые отличаются только порядком "
"получения записей. В очереди :abbr:`FIFO (первым вошел, первым обслужен)` "
"задачи, добавленные первыми, извлекаются первыми. В очереди :abbr:`LIFO "
"(последним вошел, первым обслужен)` самая последняя добавленная запись "
"является первой полученной (работает как стек). В очереди с приоритетом "
"записи сортируются (с использованием модуля :mod:`heapq`), и первой "
"извлекается запись с наименьшим значением."

#: ../../library/queue.rst:24
msgid ""
"Internally, those three types of queues use locks to temporarily block "
"competing threads; however, they are not designed to handle reentrancy "
"within a thread."
msgstr ""
"Внутри эти три типа очередей используют блокировки для временной блокировки "
"конкурирующих потоков; однако они не предназначены для обработки повторного "
"входа в поток."

#: ../../library/queue.rst:28
msgid ""
"In addition, the module implements a \"simple\" :abbr:`FIFO (first-in, first-"
"out)` queue type, :class:`SimpleQueue`, whose specific implementation "
"provides additional guarantees in exchange for the smaller functionality."
msgstr ""
"Кроме того, модуль реализует «простой» тип очереди :abbr:`FIFO (первым "
"вошел, первым обслужен)`, :class:`SimpleQueue`, конкретная реализация "
"которого обеспечивает дополнительные гарантии в обмен на меньшую "
"функциональность."

#: ../../library/queue.rst:33
msgid "The :mod:`queue` module defines the following classes and exceptions:"
msgstr "Модуль :mod:`queue` определяет следующие классы и исключения:"

#: ../../library/queue.rst:37
msgid ""
"Constructor for a :abbr:`FIFO (first-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор очереди :abbr:`FIFO (первым вошел, первым обслужен)`. *maxsize* "
"— целое число, устанавливающее верхний предел количества элементов, которые "
"можно поместить в очередь. Вставка будет заблокирована, как только будет "
"достигнут этот размер, пока элементы очереди не будут использованы. Если "
"*maxsize* меньше или равно нулю, размер очереди бесконечен."

#: ../../library/queue.rst:45
msgid ""
"Constructor for a :abbr:`LIFO (last-in, first-out)` queue.  *maxsize* is an "
"integer that sets the upperbound limit on the number of items that can be "
"placed in the queue.  Insertion will block once this size has been reached, "
"until queue items are consumed.  If *maxsize* is less than or equal to zero, "
"the queue size is infinite."
msgstr ""
"Конструктор очереди :abbr:`LIFO (последний вошел, первый обслужен). "
"*maxsize* — целое число, устанавливающее верхний предел количества "
"элементов, которые можно поместить в очередь. Вставка будет заблокирована, "
"как только будет достигнут этот размер, пока элементы очереди не будут "
"использованы. Если *maxsize* меньше или равно нулю, размер очереди "
"бесконечен."

#: ../../library/queue.rst:54
msgid ""
"Constructor for a priority queue.  *maxsize* is an integer that sets the "
"upperbound limit on the number of items that can be placed in the queue.  "
"Insertion will block once this size has been reached, until queue items are "
"consumed.  If *maxsize* is less than or equal to zero, the queue size is "
"infinite."
msgstr ""
"Конструктор приоритетной очереди. *maxsize* — целое число, устанавливающее "
"верхний предел количества элементов, которые можно поместить в очередь. "
"Вставка будет заблокирована, как только будет достигнут этот размер, пока "
"элементы очереди не будут использованы. Если *maxsize* меньше или равно "
"нулю, размер очереди бесконечен."

#: ../../library/queue.rst:59
msgid ""
"The lowest valued entries are retrieved first (the lowest valued entry is "
"the one that would be returned by ``min(entries)``).  A typical pattern for "
"entries is a tuple in the form: ``(priority_number, data)``."
msgstr ""
"Сначала извлекаются записи с наименьшим значением (запись с наименьшим "
"значением - это та, которая будет возвращена ``min(entries)``). Типичным "
"шаблоном записей является кортеж в форме: ``(priority_number, data)``."

#: ../../library/queue.rst:63
msgid ""
"If the *data* elements are not comparable, the data can be wrapped in a "
"class that ignores the data item and only compares the priority number::"
msgstr ""
"Если элементы *data* не сопоставимы, данные можно поместить в класс, который "
"игнорирует элемент данных и сравнивает только номер приоритета::"

#: ../../library/queue.rst:76
msgid ""
"Constructor for an unbounded :abbr:`FIFO (first-in, first-out)` queue. "
"Simple queues lack advanced functionality such as task tracking."
msgstr ""
"Конструктор для неограниченной очереди FIFO (первым вошел, первым обслужен). "
"Простым очередям не хватает расширенных функций, таких как отслеживание "
"задач."

#: ../../library/queue.rst:84
msgid ""
"Exception raised when non-blocking :meth:`~Queue.get` (or :meth:`~Queue."
"get_nowait`) is called on a :class:`Queue` object which is empty."
msgstr ""
"Исключение возникает, когда неблокирующий :meth:`~Queue.get` (или :meth:"
"`~Queue.get_nowait`) вызывается для пустого объекта :class:`Queue`."

#: ../../library/queue.rst:91
msgid ""
"Exception raised when non-blocking :meth:`~Queue.put` (or :meth:`~Queue."
"put_nowait`) is called on a :class:`Queue` object which is full."
msgstr ""
"Исключение возникает, когда неблокирующий :meth:`~Queue.put` (или :meth:"
"`~Queue.put_nowait`) вызывается для заполненного объекта :class:`Queue`."

#: ../../library/queue.rst:99
msgid "Queue Objects"
msgstr "Объекты очереди"

#: ../../library/queue.rst:101
msgid ""
"Queue objects (:class:`Queue`, :class:`LifoQueue`, or :class:"
"`PriorityQueue`) provide the public methods described below."
msgstr ""
"Объекты очередей (:class:`Queue`, :class:`LifoQueue` или :class:"
"`PriorityQueue`) предоставляют общедоступные методы, описанные ниже."

#: ../../library/queue.rst:107
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block, nor will qsize() < maxsize "
"guarantee that put() will not block."
msgstr ""
"Возвращает приблизительный размер очереди. Обратите внимание: qsize() > 0 не "
"гарантирует, что последующий get() не будет блокироваться, а qsize() < "
"maxsize не гарантирует, что put() не будет блокироваться."

#: ../../library/queue.rst:114
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``True`` it doesn't guarantee that a subsequent call to put() will "
"not block.  Similarly, if empty() returns ``False`` it doesn't guarantee "
"that a subsequent call to get() will not block."
msgstr ""
"Верните True, если очередь пуста, и False в противном случае. Если пустой() "
"возвращает True, это не гарантирует, что последующий вызов put() не "
"заблокируется. Аналогично, если пустой() возвращает False, это не "
"гарантирует, что последующий вызов get() не заблокируется."

#: ../../library/queue.rst:122
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  If full() "
"returns ``True`` it doesn't guarantee that a subsequent call to get() will "
"not block.  Similarly, if full() returns ``False`` it doesn't guarantee that "
"a subsequent call to put() will not block."
msgstr ""
"Верните True, если очередь заполнена, и False в противном случае. Если "
"функция full() возвращает True, это не гарантирует, что последующий вызов "
"get() не будет заблокирован. Аналогично, если full() возвращает False, это "
"не гарантирует, что последующий вызов put() не заблокируется."

#: ../../library/queue.rst:130
msgid ""
"Put *item* into the queue.  If optional args *block* is true and *timeout* "
"is ``None`` (the default), block if necessary until a free slot is "
"available.  If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Full` exception if no free slot was available "
"within that time. Otherwise (*block* is false), put an item on the queue if "
"a free slot is immediately available, else raise the :exc:`Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"Поместите *элемент* в очередь. Если необязательные аргументы *block* имеют "
"значение true, а *timeout* имеет значение None (по умолчанию), блокируйте "
"при необходимости до тех пор, пока не станет доступен свободный слот. Если "
"*timeout* является положительным числом, он блокирует не более *timeout* "
"секунд и вызывает исключение :exc:`Full`, если в течение этого времени не "
"было свободного слота. В противном случае (*block* имеет значение false) "
"поместите элемент в очередь, если свободный слот доступен немедленно, иначе "
"вызовите исключение :exc:`Full` (в этом случае *timeout* игнорируется)."

#: ../../library/queue.rst:141
msgid "Equivalent to ``put(item, block=False)``."
msgstr "Эквивалентно put(item,block=False)``."

#: ../../library/queue.rst:146 ../../library/queue.rst:258
msgid ""
"Remove and return an item from the queue.  If optional args *block* is true "
"and *timeout* is ``None`` (the default), block if necessary until an item is "
"available. If *timeout* is a positive number, it blocks at most *timeout* "
"seconds and raises the :exc:`Empty` exception if no item was available "
"within that time. Otherwise (*block* is false), return an item if one is "
"immediately available, else raise the :exc:`Empty` exception (*timeout* is "
"ignored in that case)."
msgstr ""
"Удалить и вернуть элемент из очереди. Если необязательные аргументы *block* "
"имеют значение true, а *timeout* имеет значение None (по умолчанию), "
"блокируйте при необходимости до тех пор, пока элемент не станет доступен. "
"Если *timeout* является положительным числом, он блокирует не более "
"*timeout* секунд и вызывает исключение :exc:`Empty`, если в течение этого "
"времени ни один элемент не был доступен. В противном случае (*block* имеет "
"значение false) верните элемент, если он доступен немедленно, иначе вызовите "
"исключение :exc:`Empty` (в этом случае *timeout* игнорируется)."

#: ../../library/queue.rst:153
msgid ""
"Prior to 3.0 on POSIX systems, and for all versions on Windows, if *block* "
"is true and *timeout* is ``None``, this operation goes into an "
"uninterruptible wait on an underlying lock.  This means that no exceptions "
"can occur, and in particular a SIGINT will not trigger a :exc:"
"`KeyboardInterrupt`."
msgstr ""
"До версии 3.0 в системах POSIX и для всех версий в Windows, если *block* "
"имеет значение true, а *timeout* имеет значение ``None``, эта операция "
"переходит в режим непрерывного ожидания базовой блокировки. Это означает, "
"что никаких исключений возникнуть не может, и, в частности, SIGINT не "
"вызовет :exc:`KeyboardInterrupt`."

#: ../../library/queue.rst:161 ../../library/queue.rst:268
msgid "Equivalent to ``get(False)``."
msgstr "Эквивалент ``get(False)``."

#: ../../library/queue.rst:163
msgid ""
"Two methods are offered to support tracking whether enqueued tasks have been "
"fully processed by daemon consumer threads."
msgstr ""
"Предлагаются два метода для отслеживания того, были ли поставленные в "
"очередь задачи полностью обработаны потоками-потребителями демона."

#: ../../library/queue.rst:169
msgid ""
"Indicate that a formerly enqueued task is complete.  Used by queue consumer "
"threads.  For each :meth:`get` used to fetch a task, a subsequent call to :"
"meth:`task_done` tells the queue that the processing on the task is complete."
msgstr ""
"Указывает, что ранее поставленная в очередь задача завершена. Используется "
"потоками-потребителями очереди. Для каждого :meth:`get`, используемого для "
"получения задачи, последующий вызов :meth:`task_done` сообщает очереди, что "
"обработка задачи завершена."

#: ../../library/queue.rst:173
msgid ""
"If a :meth:`join` is currently blocking, it will resume when all items have "
"been processed (meaning that a :meth:`task_done` call was received for every "
"item that had been :meth:`put` into the queue)."
msgstr ""
"Если :meth:`join` в данный момент блокируется, оно возобновится, когда все "
"элементы будут обработаны (это означает, что вызов :meth:`task_done` был "
"получен для каждого элемента, который был :meth:`помещен` в очередь) ."

#: ../../library/queue.rst:177
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Вызывает :exc:`ValueError`, если вызывается больше раз, чем было помещено в "
"очередь элементов."

#: ../../library/queue.rst:183
msgid "Blocks until all items in the queue have been gotten and processed."
msgstr ""
"Блокируется до тех пор, пока все элементы в очереди не будут получены и "
"обработаны."

#: ../../library/queue.rst:185
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue. The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`join` "
"unblocks."
msgstr ""
"Количество незавершенных задач увеличивается каждый раз, когда элемент "
"добавляется в очередь. Счетчик уменьшается всякий раз, когда потребительский "
"поток вызывает :meth:`task_done`, чтобы указать, что элемент был получен и "
"вся работа над ним завершена. Когда количество незавершенных задач падает до "
"нуля, :meth:`join` разблокируется."

#: ../../library/queue.rst:191
msgid "Example of how to wait for enqueued tasks to be completed::"
msgstr "Пример того, как дождаться завершения задач в очереди:"

#: ../../library/queue.rst:218
msgid "SimpleQueue Objects"
msgstr "Объекты SimpleQueue"

#: ../../library/queue.rst:220
msgid ""
":class:`SimpleQueue` objects provide the public methods described below."
msgstr ""
"Объекты :class:`SimpleQueue` предоставляют общедоступные методы, описанные "
"ниже."

#: ../../library/queue.rst:224
msgid ""
"Return the approximate size of the queue.  Note, qsize() > 0 doesn't "
"guarantee that a subsequent get() will not block."
msgstr ""
"Возвращает приблизительный размер очереди. Обратите внимание: qsize() > 0 не "
"гарантирует, что последующий вызов get() не заблокируется."

#: ../../library/queue.rst:230
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  If empty() "
"returns ``False`` it doesn't guarantee that a subsequent call to get() will "
"not block."
msgstr ""
"Верните True, если очередь пуста, и False в противном случае. Если пустой() "
"возвращает «False», это не гарантирует, что последующий вызов get() не будет "
"заблокирован."

#: ../../library/queue.rst:237
msgid ""
"Put *item* into the queue.  The method never blocks and always succeeds "
"(except for potential low-level errors such as failure to allocate memory). "
"The optional args *block* and *timeout* are ignored and only provided for "
"compatibility with :meth:`Queue.put`."
msgstr ""
"Поместите *элемент* в очередь. Этот метод никогда не блокируется и всегда "
"завершается успешно (за исключением потенциальных ошибок низкого уровня, "
"таких как неспособность выделить память). Необязательные аргументы *block* и "
"*timeout* игнорируются и предоставляются только для совместимости с :meth:"
"`Queue.put`."

#: ../../library/queue.rst:243
msgid ""
"This method has a C implementation which is reentrant.  That is, a ``put()`` "
"or ``get()`` call can be interrupted by another ``put()`` call in the same "
"thread without deadlocking or corrupting internal state inside the queue.  "
"This makes it appropriate for use in destructors such as ``__del__`` methods "
"or :mod:`weakref` callbacks."
msgstr ""
"Этот метод имеет реентерабельную реализацию на языке C. То есть вызов put() "
"или get() может быть прерван другим вызовом put() в том же потоке без "
"взаимоблокировки или повреждения внутреннего состояния внутри очереди. Это "
"делает его подходящим для использования в деструкторах, таких как методы "
"``__del__`` или обратные вызовы :mod:`weakref`."

#: ../../library/queue.rst:252
msgid ""
"Equivalent to ``put(item, block=False)``, provided for compatibility with :"
"meth:`Queue.put_nowait`."
msgstr ""
"Эквивалент ``put(item, block=False)``, предусмотрен для совместимости с :"
"meth:`Queue.put_nowait`."

#: ../../library/queue.rst:275
msgid "Class :class:`multiprocessing.Queue`"
msgstr "Класс :class:`multiprocessing.Queue`"

#: ../../library/queue.rst:274
msgid ""
"A queue class for use in a multi-processing (rather than multi-threading) "
"context."
msgstr ""
"Класс очереди для использования в контексте многопроцессорной обработки (а "
"не многопоточности)."

#: ../../library/queue.rst:277
msgid ""
":class:`collections.deque` is an alternative implementation of unbounded "
"queues with fast atomic :meth:`~collections.deque.append` and :meth:"
"`~collections.deque.popleft` operations that do not require locking and also "
"support indexing."
msgstr ""
":class:`collections.deque` — это альтернативная реализация неограниченных "
"очередей с быстрыми атомарными операциями :meth:`~collections.deque.append` "
"и :meth:`~collections.deque.popleft`, которые не требуют блокировки, а также "
"поддерживают индексация."
