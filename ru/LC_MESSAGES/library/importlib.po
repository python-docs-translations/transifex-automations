# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Kristina Mironova, 2021
# Daniil Kolesnikov, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Илья Панфилов, 2024
# Roustam Khamidoulline, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Roustam Khamidoulline, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- Реализация :keyword:`!import`"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Исходный код:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "Введение"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr "Пакет :mod:`importlib` имеет три цели."

#: ../../library/importlib.rst:22
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and "
"thus, by extension, the :func:`__import__` function) in Python source code. "
"This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier "
"to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"Один из них — обеспечить реализацию оператора :keyword:`import` (и, "
"следовательно, функции :func:`__import__`) в исходном коде Python. Это "
"обеспечивает реализацию :keyword:`!import`, которую можно переносить в любой "
"интерпретатор Python. Это также обеспечивает реализацию, которую легче "
"понять, чем реализацию на другом языке программирования, кроме Python."

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"Во-вторых, в этом пакете представлены компоненты для реализации :keyword:"
"`import`, что упрощает пользователям создание собственных объектов "
"(известных в общем как :term:`importer`) для участия в процессе импорта."

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr ""
"В-третьих, пакет содержит модули, предоставляющие дополнительные функции для "
"управления аспектами пакетов Python:"

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""
":mod:`importlib.metadata` предоставляет доступ к метаданным из сторонних "
"дистрибутивов."

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""
":mod:`importlib.resources` предоставляет процедуры для доступа к некодовым "
"«ресурсам» из пакетов Python."

#: ../../library/importlib.rst:43
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr "Ссылка на язык для оператора :keyword:`import`."

#: ../../library/importlib.rst:46
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`Спецификация пакетов <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"Оригинальная спецификация пакетов. Некоторая семантика изменилась с момента "
"написания этого документа (например, перенаправление на основе None в :data:"
"`sys.modules`)."

#: ../../library/importlib.rst:51
msgid "The :func:`.__import__` function"
msgstr "Функция :func:`.__import__`"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ""
"Оператор :keyword:`import` является синтаксическим сахаром для этой функции."

#: ../../library/importlib.rst:54
msgid ":ref:`sys-path-init`"
msgstr ":ref:`sys-path-init`"

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr "Инициализация :data:`sys.path`."

#: ../../library/importlib.rst:57
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "Импорт на платформах, не чувствительных к регистру"

#: ../../library/importlib.rst:60
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "Определение кодировки исходного кода Python"

#: ../../library/importlib.rst:63
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "Новые крючки импорта"

#: ../../library/importlib.rst:66
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Импорт: многострочный и абсолютный/относительный"

#: ../../library/importlib.rst:69
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "Явный относительный импорт основного модуля"

#: ../../library/importlib.rst:72
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "Неявные пакеты пространства имен"

#: ../../library/importlib.rst:75
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "Тип ModuleSpec для системы импорта"

#: ../../library/importlib.rst:78
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "Удаление файлов PYO"

#: ../../library/importlib.rst:81
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "Инициализация многофазного модуля расширения"

#: ../../library/importlib.rst:84
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "Детерминированные фото"

#: ../../library/importlib.rst:87
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Использование UTF-8 в качестве исходной кодировки по умолчанию"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "Каталоги репозитория PYC"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "Функции"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "Реализация встроенной функции :func:`__import__`."

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"Программный импорт модулей должен использовать :func:`import_module` вместо "
"этой функции."

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Импортируйте модуль. Аргумент *name* указывает, какой модуль импортировать в "
"абсолютном или относительном выражении (например, ``pkg.mod`` или ``.."
"mod``). Если имя указано в относительных терминах, то аргумент *package* "
"должен быть установлен в имя пакета, который будет действовать как привязка "
"для разрешения имени пакета (например, ``import_module('..mod', 'pkg ."
"subpkg')`` импортирует ``pkg.mod``)."

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"Функция :func:`import_module` действует как упрощающая оболочка вокруг :func:"
"`importlib.__import__`. Это означает, что вся семантика функции получена из :"
"func:`importlib.__import__`. Наиболее важное различие между этими двумя "
"функциями заключается в том, что :func:`import_module` возвращает указанный "
"пакет или модуль (например, ``pkg.mod``), а :func:`__import__` возвращает "
"пакет или модуль верхнего уровня (например, ``упаковка``)."

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Если вы динамически импортируете модуль, который был создан с момента начала "
"выполнения интерпретатора (например, после создания исходного файла Python), "
"вам может потребоваться вызвать :func:`invalidate_caches`, чтобы новый "
"модуль был обнаружен системой импорта."

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "Родительские пакеты импортируются автоматически."

#: ../../library/importlib.rst:132
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Сделайте недействительными внутренние кеши средств поиска, хранящиеся в :"
"data:`sys.meta_path`. Если средство поиска реализует invalidate_caches(), то "
"оно будет вызвано для аннулирования. Эту функцию следует вызывать, если "
"какие-либо модули создаются/устанавливаются во время работы вашей программы, "
"чтобы гарантировать, что все искатели заметят существование нового модуля."

#: ../../library/importlib.rst:140
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""
"Пакеты пространства имен, созданные/установленные в другом месте :data:`sys."
"path` после того, как то же пространство имен уже было импортировано, "
"учитываются."

#: ../../library/importlib.rst:146
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Перезагрузите ранее импортированный *модуль*. Аргумент должен быть объектом "
"модуля, поэтому он должен быть успешно импортирован ранее. Это полезно, если "
"вы отредактировали исходный файл модуля с помощью внешнего редактора и "
"хотите опробовать новую версию, не выходя из интерпретатора Python. "
"Возвращаемое значение — это объект модуля (который может быть другим, если "
"при повторном импорте в :data:`sys.modules` будет помещен другой объект)."

#: ../../library/importlib.rst:153
msgid "When :func:`reload` is executed:"
msgstr "Когда выполняется :func:`reload`:"

#: ../../library/importlib.rst:155
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"Код модуля Python перекомпилируется, и код уровня модуля повторно "
"выполняется, определяя новый набор объектов, которые привязаны к именам в "
"словаре модуля, путем повторного использования :term:`loader`, который "
"первоначально загрузил модуль. Функция init модулей расширения не вызывается "
"второй раз."

#: ../../library/importlib.rst:161
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Как и все другие объекты в Python, старые объекты восстанавливаются только "
"после того, как их счетчик ссылок упадет до нуля."

#: ../../library/importlib.rst:164
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Имена в пространстве имен модуля обновляются, чтобы указывать на любые новые "
"или измененные объекты."

#: ../../library/importlib.rst:167
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Другие ссылки на старые объекты (например, имена, внешние по отношению к "
"модулю) не переназначаются для ссылки на новые объекты и должны обновляться "
"в каждом пространстве имен, где они встречаются, если это желательно."

#: ../../library/importlib.rst:171
msgid "There are a number of other caveats:"
msgstr "Есть еще ряд предостережений:"

#: ../../library/importlib.rst:173
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Когда модуль перезагружается, его словарь (содержащий глобальные переменные "
"модуля) сохраняется. Переопределения имен переопределяют старые определения, "
"поэтому обычно это не проблема. Если новая версия модуля не определяет имя, "
"определенное в старой версии, старое определение остается. Эту функцию можно "
"использовать в интересах модуля, если он поддерживает глобальную таблицу или "
"кеш объектов --- с помощью оператора :keyword:`try` он может проверить "
"наличие таблицы и при желании пропустить ее инициализацию::"

#: ../../library/importlib.rst:182
msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"

#: ../../library/importlib.rst:187
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Обычно перезагружать встроенные или динамически загружаемые модули не очень "
"полезно. Перезагрузка :mod:`sys`, :mod:`__main__`, :mod:`builtins` и других "
"ключевых модулей не рекомендуется. Во многих случаях модули расширения не "
"предназначены для многократной инициализации и могут по каким-либо причинам "
"выйти из строя при перезагрузке."

#: ../../library/importlib.rst:193
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"Если модуль импортирует объекты из другого модуля, используя :keyword:"
"`from` ... :keyword:`import` ..., вызов :func:`reload` для другого модуля не "
"переопределяет объекты, импортированные из него --- Один из способов решения "
"этой проблемы — повторное выполнение оператора :keyword:`!from`, другой — "
"вместо этого использовать :keyword:`!import` и квалифицированные имена "
"(*module.name*)."

#: ../../library/importlib.rst:199
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Если модуль создает экземпляры класса, перезагрузка модуля, определяющего "
"класс, не влияет на определения методов экземпляров — они продолжают "
"использовать старое определение класса. То же самое справедливо и для "
"производных классов."

#: ../../library/importlib.rst:205
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` возникает, когда в перезагружаемом модуле "
"отсутствует :class:`~importlib.machinery.ModuleSpec`."

#: ../../library/importlib.rst:211
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ""
":mod:`importlib.abc` -- Абстрактные базовые классы, связанные с импортом"

#: ../../library/importlib.rst:216
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Исходный код:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:221
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
"Модуль :mod:`importlib.abc` содержит все основные абстрактные базовые "
"классы, используемые :keyword:`import`. Некоторые подклассы основных "
"абстрактных базовых классов также предоставляются для помощи в реализации "
"основных ABC."

#: ../../library/importlib.rst:225
msgid "ABC hierarchy::"
msgstr "Иерархия ABC::"

#: ../../library/importlib.rst:227
msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"

#: ../../library/importlib.rst:240
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "Абстрактный базовый класс, представляющий средство поиска метапутей."

#: ../../library/importlib.rst:244 ../../library/importlib.rst:280
msgid "No longer a subclass of :class:`!Finder`."
msgstr "Больше не является подклассом :class:`!Finder`."

#: ../../library/importlib.rst:249
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`~module.__path__` from the parent package. If a spec "
"cannot be found, ``None`` is returned. When passed in, ``target`` is a "
"module object that the finder may use to make a more educated guess about "
"what spec to return. :func:`importlib.util.spec_from_loader` may be useful "
"for implementing concrete ``MetaPathFinders``."
msgstr ""
"Абстрактный метод для поиска :term:`spec <module spec>` для указанного "
"модуля. Если это импорт верхнего уровня, *path* будет ``None``. В противном "
"случае это поиск подпакета или модуля, и *path* будет значением :attr:"
"`~module.__path__` из родительского пакета. Если спецификация не может быть "
"найдена, возвращается None. При передаче ``target`` представляет собой "
"объект модуля, который искатель может использовать, чтобы сделать более "
"обоснованное предположение о том, какую спецификацию вернуть. :func:"
"`importlib.util.spec_from_loader` может быть полезен для реализации "
"конкретных ``MetaPathFinders``."

#: ../../library/importlib.rst:263
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"Необязательный метод, который при вызове должен аннулировать любой "
"внутренний кеш, используемый искателем. Используется :func:`importlib."
"invalidate_caches` при аннулировании кешей всех средств поиска в :data:`sys."
"meta_path`."

#: ../../library/importlib.rst:267
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr "Возвращает None при вызове вместо :data:`NotImplemented`."

#: ../../library/importlib.rst:273
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
"Абстрактный базовый класс, представляющий :term:`поиск записей пути`. Хотя "
"он имеет некоторое сходство с :class:`MetaPathFinder`, ``PathEntryFinder`` "
"предназначен для использования только в подсистеме импорта на основе пути, "
"предоставляемой :class:`importlib.machinery.PathFinder`."

#: ../../library/importlib.rst:285
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"Абстрактный метод для поиска :term:`spec <module spec>` для указанного "
"модуля. Средство поиска будет искать модуль только в пределах записи пути, "
"которой он назначен. Если спецификация не может быть найдена, возвращается "
"None. При передаче ``target`` представляет собой объект модуля, который "
"искатель может использовать, чтобы сделать более обоснованное предположение "
"о том, какую спецификацию вернуть. :func:`importlib.util.spec_from_loader` "
"может быть полезен для реализации конкретных ``PathEntryFinders``."

#: ../../library/importlib.rst:297
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"Необязательный метод, который при вызове должен аннулировать любой "
"внутренний кеш, используемый искателем. Используется :meth:`importlib."
"machinery.PathFinder.invalidate_caches` при аннулировании кешей всех "
"кэшированных средств поиска."

#: ../../library/importlib.rst:305
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"Абстрактный базовый класс для :term:`loader`. См. :pep:`302` для точного "
"определения загрузчика."

#: ../../library/importlib.rst:308
msgid ""
"Loaders that wish to support resource reading should implement a :meth:"
"`get_resource_reader` method as specified by :class:`importlib.resources.abc."
"ResourceReader`."
msgstr ""
"Загрузчики, которые хотят поддерживать чтение ресурсов, должны реализовать "
"метод :meth:`get_resource_reader`, как указано в :class:`importlib.resources."
"abc.ResourceReader`."

#: ../../library/importlib.rst:312
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "Представлен дополнительный метод :meth:`get_resource_reader`."

#: ../../library/importlib.rst:317
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"Метод, возвращающий объект модуля, который будет использоваться при импорте "
"модуля. Этот метод может возвращать None, указывая, что должна быть "
"выполнена семантика создания модуля по умолчанию."

#: ../../library/importlib.rst:323
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr ""
"Этот метод больше не является необязательным, если определен :meth:"
"`exec_module`."

#: ../../library/importlib.rst:329
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, :meth:"
"`create_module` must be defined."
msgstr ""
"Абстрактный метод, который выполняет модуль в его собственном пространстве "
"имен при импорте или перезагрузке модуля. Модуль уже должен быть "
"инициализирован при вызове :meth:`exec_module`. Если этот метод существует, "
"необходимо определить :meth:`create_module`."

#: ../../library/importlib.rst:336
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` также должен быть определен."

#: ../../library/importlib.rst:341
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"Устаревший метод загрузки модуля. Если модуль не может быть загружен, "
"выдается :exc:`ImportError`, в противном случае возвращается загруженный "
"модуль."

#: ../../library/importlib.rst:345
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import.  If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone."
msgstr ""
"Если запрошенный модуль уже существует в :data:`sys.modules`, этот модуль "
"следует использовать и перезагрузить. В противном случае загрузчик должен "
"создать новый модуль и вставить его в :data:`sys.modules` до начала "
"загрузки, чтобы предотвратить рекурсию импорта. Если загрузчик вставил "
"модуль и загрузка не удалась, загрузчик должен удалить его из :data:`sys."
"modules`; модули, уже находящиеся в :data:`sys.modules` до того, как "
"загрузчик начал выполнение, следует оставить в покое."

#: ../../library/importlib.rst:354
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"Загрузчик должен установить для модуля несколько атрибутов (обратите "
"внимание, что некоторые из этих атрибутов могут измениться при перезагрузке "
"модуля):"

#: ../../library/importlib.rst:358
msgid ":attr:`module.__name__`"
msgstr ":attr:`module.__name__`"

#: ../../library/importlib.rst:359
msgid ":attr:`module.__file__`"
msgstr ":attr:`module.__file__`"

#: ../../library/importlib.rst:360
msgid ":attr:`module.__cached__` *(deprecated)*"
msgstr ":attr:`module.__cached__` *(устарело)*"

#: ../../library/importlib.rst:361
msgid ":attr:`module.__path__`"
msgstr ":attr:`module.__path__`"

#: ../../library/importlib.rst:362
msgid ":attr:`module.__package__` *(deprecated)*"
msgstr ":attr:`module.__package__` *(устарело)*"

#: ../../library/importlib.rst:363
msgid ":attr:`module.__loader__` *(deprecated)*"
msgstr ":attr:`module.__loader__` *(устарело)*"

#: ../../library/importlib.rst:365
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"Когда доступен :meth:`exec_module`, обеспечивается обратно совместимая "
"функциональность."

#: ../../library/importlib.rst:368
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`.  "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"Вызовите :exc:`ImportError` при вызове вместо :exc:`NotImplementedError`. "
"Функциональность предоставляется, когда доступен :meth:`exec_module`."

#: ../../library/importlib.rst:373
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of :meth:"
"`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"Рекомендуемый API для загрузки модуля — :meth:`exec_module` (и :meth:"
"`create_module`). Загрузчики должны реализовать его вместо :meth:"
"`load_module`. Механизм импорта берет на себя все остальные обязанности :"
"meth:`load_module` при реализации :meth:`exec_module`."

#: ../../library/importlib.rst:383 ../../library/importlib.rst:636
msgid "*Superseded by TraversableResources*"
msgstr "*Заменено TraversableResources*"

#: ../../library/importlib.rst:385
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"Абстрактный базовый класс для :term:`loader`, который реализует "
"дополнительный :pep:`302` протокол для загрузки произвольных ресурсов из "
"серверной части хранилища."

#: ../../library/importlib.rst:389
msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.resources.abc.TraversableResources`."
msgstr ""

#: ../../library/importlib.rst:396
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`~module."
"__file__` attribute or an item from a package's :attr:`~module.__path__`."
msgstr ""
"Абстрактный метод для возврата байтов данных, расположенных по адресу "
"*path*. Загрузчики, имеющие файловое хранилище, позволяющее хранить "
"произвольные данные, могут реализовать этот абстрактный метод, чтобы "
"предоставить прямой доступ к хранимым данным. :exc:`OSError` вызывается, "
"если *путь* не найден. Ожидается, что *path* будет создан с использованием "
"атрибута :attr:`~module.__file__` модуля или элемента из :attr:`~module."
"__path__` пакета."

#: ../../library/importlib.rst:405
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Вызывает :exc:`OSError` вместо :exc:`NotImplementedError`."

#: ../../library/importlib.rst:411
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Абстрактный базовый класс для :term:`loader`, который реализует "
"дополнительный протокол :pep:`302` для загрузчиков, проверяющих модули."

#: ../../library/importlib.rst:416
msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Возвращает объект кода для модуля или None, если у модуля нет объекта кода "
"(как, например, в случае встроенного модуля). Вызовите :exc:`ImportError`, "
"если загрузчик не может найти запрошенный модуль."

#: ../../library/importlib.rst:422
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Хотя у метода есть реализация по умолчанию, рекомендуется по возможности "
"переопределить ее для повышения производительности."

#: ../../library/importlib.rst:428
msgid "No longer abstract and a concrete implementation is provided."
msgstr "Больше не абстрактно, а конкретная реализация."

#: ../../library/importlib.rst:434
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"Абстрактный метод для возврата исходного кода модуля. Он возвращается в виде "
"текстовой строки с использованием :term:`универсальных символов новой "
"строки`, переводя все распознаваемые разделители строк в символы ``'\\n'``. "
"Возвращает None, если источник недоступен (например, встроенный модуль). "
"Вызывает :exc:`ImportError`, если загрузчик не может найти указанный модуль."

#: ../../library/importlib.rst:440 ../../library/importlib.rst:449
#: ../../library/importlib.rst:500
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Вызывает :exc:`ImportError` вместо :exc:`NotImplementedError`."

#: ../../library/importlib.rst:445
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"Необязательный метод для возврата истинного значения, если модуль является "
"пакетом, и ложного значения в противном случае. :exc:`ImportError` "
"возникает, если :term:`loader` не может найти модуль."

#: ../../library/importlib.rst:454
msgid "Create a code object from Python source."
msgstr "Создайте объект кода из исходного кода Python."

#: ../../library/importlib.rst:456
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"Аргумент *data* может быть любым, что поддерживает функция :func:`compile` "
"(например, строка или байты). Аргумент *path* должен быть «путем» к "
"источнику исходного кода, что может быть абстрактным понятием (например, "
"расположение в zip-файле)."

#: ../../library/importlib.rst:461
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"С последующим объектом кода его можно выполнить в модуле, запустив "
"``exec(code, Module.__dict__)``."

#: ../../library/importlib.rst:466
msgid "Made the method static."
msgstr "Сделал метод статическим."

#: ../../library/importlib.rst:471
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Реализация :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:477
msgid "Implementation of :meth:`Loader.load_module`."
msgstr "реализация :meth:`Loader.load_module`."

#: ../../library/importlib.rst:479
msgid "use :meth:`exec_module` instead."
msgstr "вместо этого используйте :meth:`exec_module`."

#: ../../library/importlib.rst:485
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Абстрактный базовый класс, который наследуется от :class:`InspectLoader`, "
"который при реализации помогает выполнять модуль как скрипт. ABC "
"представляет собой дополнительный протокол :pep:`302`."

#: ../../library/importlib.rst:492
msgid ""
"An abstract method that is to return the value of :attr:`~module.__file__` "
"for the specified module. If no path is available, :exc:`ImportError` is "
"raised."
msgstr ""
"Абстрактный метод, возвращающий значение :attr:`~module.__file__` для "
"указанного модуля. Если путь недоступен, возникает :exc:`ImportError`."

#: ../../library/importlib.rst:496
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Если исходный код доступен, то метод должен вернуть путь к исходному файлу "
"независимо от того, использовался ли байт-код для загрузки модуля."

#: ../../library/importlib.rst:506
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Абстрактный базовый класс, который наследуется от :class:`ResourceLoader` и :"
"class:`ExecutionLoader`, предоставляя конкретные реализации :meth:"
"`ResourceLoader.get_data` и :meth:`ExecutionLoader.get_filename`."

#: ../../library/importlib.rst:510
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"Аргумент *fullname* — это полностью разрешенное имя модуля, который должен "
"обрабатывать загрузчик. Аргумент *path* — это путь к файлу модуля."

#: ../../library/importlib.rst:517
msgid "The name of the module the loader can handle."
msgstr "Имя модуля, который может обрабатывать загрузчик."

#: ../../library/importlib.rst:521
msgid "Path to the file of the module."
msgstr "Путь к файлу модуля."

#: ../../library/importlib.rst:525
msgid "Calls super's ``load_module()``."
msgstr "Вызывает супер-модуль load_module()."

#: ../../library/importlib.rst:527
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Вместо этого используйте :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:533 ../../library/importlib.rst:1140
msgid "Returns :attr:`path`."
msgstr "Возвращает :attr:`path`."

#: ../../library/importlib.rst:538
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Считывает *path* как двоичный файл и возвращает из него байты."

#: ../../library/importlib.rst:543
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Абстрактный базовый класс для реализации загрузки исходного файла (и, "
"возможно, байт-кода). Класс наследует как :class:`ResourceLoader`, так и :"
"class:`ExecutionLoader`, что требует реализации:"

#: ../../library/importlib.rst:547
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:548
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:549
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Должен возвращать только путь к исходному файлу; Загрузка без исходного кода "
"не поддерживается."

#: ../../library/importlib.rst:552
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Абстрактные методы, определенные этим классом, предназначены для добавления "
"дополнительной поддержки файлов байт-кода. Если не реализовать эти "
"необязательные методы (или заставить их вызвать :exc:`NotImplementedError`), "
"загрузчик будет работать только с исходным кодом. Реализация методов "
"позволяет загрузчику работать с исходными *и* файлами байт-кода; он не "
"позволяет загружать *без исходного кода*, где предоставляется только байт-"
"код. Файлы байт-кода представляют собой оптимизацию для ускорения загрузки "
"за счет удаления этапа анализа компилятора Python, поэтому API, специфичный "
"для байт-кода, не предоставляется."

#: ../../library/importlib.rst:563
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Необязательный абстрактный метод, который возвращает :class:`dict`, "
"содержащий метаданные об указанном пути. Поддерживаемые ключи словаря:"

#: ../../library/importlib.rst:566
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (обязательный): целое число или число с плавающей запятой, "
"представляющее время модификации исходного кода;"

#: ../../library/importlib.rst:568
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'размер'`` (необязательно): размер исходного кода в байтах."

#: ../../library/importlib.rst:570
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Любые другие ключи в словаре игнорируются, чтобы обеспечить возможность "
"будущих расширений. Если путь не может быть обработан, возникает :exc:"
"`OSError`."

#: ../../library/importlib.rst:575 ../../library/importlib.rst:588
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Поднимите :exc:`OSError` вместо :exc:`NotImplementedError`."

#: ../../library/importlib.rst:580
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Необязательный абстрактный метод, который возвращает время изменения "
"указанного пути."

#: ../../library/importlib.rst:583
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Этот метод устарел в пользу :meth:`path_stats`. Вам не обязательно его "
"реализовывать, но он все равно доступен в целях совместимости. Поднимите :"
"exc:`OSError`, если путь не может быть обработан."

#: ../../library/importlib.rst:593
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Необязательный абстрактный метод, который записывает указанные байты в путь "
"к файлу. Все несуществующие промежуточные каталоги должны создаваться "
"автоматически."

#: ../../library/importlib.rst:597
msgid ""
"When writing to the path fails because the path is read-only (:const:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""
"Если запись по пути не удалась, поскольку путь доступен только для чтения (:"
"const:`errno.EACCES`/:exc:`PermissionError`), не распространяйте исключение."

#: ../../library/importlib.rst:601
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Больше не вызывает :exc:`NotImplementedError` при вызове."

#: ../../library/importlib.rst:606
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Конкретная реализация :meth:`InspectLoader.get_code`."

#: ../../library/importlib.rst:610
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Конкретная реализация :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:616
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Конкретная реализация :meth:`Loader.load_module`."

#: ../../library/importlib.rst:618
msgid "Use :meth:`exec_module` instead."
msgstr "Вместо этого используйте :meth:`exec_module`."

#: ../../library/importlib.rst:623
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Конкретная реализация :meth:`InspectLoader.get_source`."

#: ../../library/importlib.rst:627
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Конкретная реализация :meth:`InspectLoader.is_package`. Модуль определяется "
"как пакет, если его путь к файлу (как предоставлено :meth:`ExecutionLoader."
"get_filename`) представляет собой файл с именем ``__init__``, когда "
"расширение файла удалено **и** само имя модуля не заканчиваться на "
"``__init__``."

#: ../../library/importlib.rst:638
msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""
":term:`абстрактный базовый класс`, обеспечивающий возможность чтения "
"*ресурсов*."

#: ../../library/importlib.rst:641
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored e.g. in a zip "
"file versus on the file system."
msgstr ""
":term:`абстрактный базовый класс`, обеспечивающий возможность чтения "
"*ресурсов*."

#: ../../library/importlib.rst:649
msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"Для любого метода этого класса ожидается, что аргумент *resource* будет "
"объектом, похожим на путь, который концептуально представляет собой просто "
"имя файла. Это означает, что в аргумент *resource* не следует включать пути "
"к подкаталогам. Это связано с тем, что местоположение пакета, для которого "
"предназначено устройство чтения, действует как «каталог». Следовательно, "
"метафорой имен каталогов и файлов являются пакеты и ресурсы соответственно. "
"Именно поэтому ожидается, что экземпляры этого класса будут напрямую "
"соотноситься с конкретным пакетом (вместо того, чтобы потенциально "
"представлять несколько пакетов или модуля)."

#: ../../library/importlib.rst:660
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""
"Ожидается, что загрузчики, желающие поддерживать чтение ресурсов, "
"предоставят метод get_resource_reader(fullname), который возвращает объект, "
"реализующий этот интерфейс ABC. Если модуль, указанный полным именем, не "
"является пакетом, этот метод должен вернуть :const:`None`. Объект, "
"совместимый с этим ABC, должен быть возвращен только в том случае, если "
"указанный модуль является пакетом."

#: ../../library/importlib.rst:669 ../../library/importlib.rst:789
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr ""
"Вместо этого используйте :class:`importlib.resources.abc."
"TraversableResources`."

#: ../../library/importlib.rst:675
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Возвращает открытый :term:`файлоподобный объект` для двоичного чтения "
"*ресурса*."

#: ../../library/importlib.rst:678
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "Если ресурс не может быть найден, возникает :exc:`FileNotFoundError`."

#: ../../library/importlib.rst:684
msgid "Returns the file system path to the *resource*."
msgstr "Возвращает путь файловой системы к *ресурсу*."

#: ../../library/importlib.rst:686
msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"Если ресурс конкретно не существует в файловой системе, поднимите :exc:"
"`FileNotFoundError`."

#: ../../library/importlib.rst:692
msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Возвращает ``True``, если именованное *имя* считается ресурсом. :exc:"
"`FileNotFoundError` возникает, если *name* не существует."

#: ../../library/importlib.rst:698
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""
"Возвращает :term:`iterable` строк по содержимому пакета. Обратите внимание, "
"что не обязательно, чтобы все имена, возвращаемые итератором, были реальными "
"ресурсами, например, допустимо возвращать имена, для которых :meth:"
"`is_resource` будет ложным."

#: ../../library/importlib.rst:704
msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""
"Разрешить возврат имен, не являющихся ресурсами, необходимо для ситуаций, "
"когда способ хранения пакета и его ресурсов известен априори и имена, не "
"относящиеся к ресурсам, могут оказаться полезными. Например, разрешен "
"возврат имен подкаталогов, чтобы, когда известно, что пакет и ресурсы "
"хранятся в файловой системе, эти имена подкаталогов можно было использовать "
"напрямую."

#: ../../library/importlib.rst:712
msgid "The abstract method returns an iterable of no items."
msgstr "Абстрактный метод возвращает итерацию без элементов."

#: ../../library/importlib.rst:717
msgid ""
"An object with a subset of :class:`pathlib.Path` methods suitable for "
"traversing directories and opening files."
msgstr ""
"Объект с подмножеством методов :class:`pathlib.Path`, подходящих для "
"перемещения по каталогам и открытия файлов."

#: ../../library/importlib.rst:720
msgid ""
"For a representation of the object on the file-system, use :meth:`importlib."
"resources.as_file`."
msgstr ""
"Для представления объекта в файловой системе используйте :meth:`importlib."
"resources.as_file`."

#: ../../library/importlib.rst:725
msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr "Вместо этого используйте :class:`importlib.resources.abc.Traversable`."

#: ../../library/importlib.rst:730
msgid "Abstract. The base name of this object without any parent references."
msgstr ""
"Абстрактный. Базовое имя этого объекта без каких-либо родительских ссылок."

#: ../../library/importlib.rst:735
msgid "Yield ``Traversable`` objects in ``self``."
msgstr "Выдавать ``Traversable`` объекты в ``self``."

#: ../../library/importlib.rst:740
msgid "Return ``True`` if ``self`` is a directory."
msgstr "Верните True, если self — это каталог."

#: ../../library/importlib.rst:745
msgid "Return ``True`` if ``self`` is a file."
msgstr "Верните True, если self — это файл."

#: ../../library/importlib.rst:750
msgid "Return Traversable child in ``self``."
msgstr "Вернуть проходимого дочернего элемента в ``self``."

#: ../../library/importlib.rst:755
msgid "Return ``Traversable`` child in ``self``."
msgstr "Вернуть дочерний элемент «Traversable» в «self»."

#: ../../library/importlib.rst:760
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* может иметь значение «r» или «rb», чтобы открыть его в текстовом или "
"двоичном виде. Возвращает дескриптор, подходящий для чтения (аналогично :"
"attr:`pathlib.Path.open`)."

#: ../../library/importlib.rst:763
msgid ""
"When opening as text, accepts encoding parameters such as those accepted by :"
"class:`io.TextIOWrapper`."
msgstr ""
"При открытии в виде текста принимает параметры кодирования, подобные тем, "
"которые принимаются :class:`io.TextIOWrapper`."

#: ../../library/importlib.rst:768
msgid "Read contents of ``self`` as bytes."
msgstr "Считайте содержимое ``self`` в байтах."

#: ../../library/importlib.rst:772
msgid "Read contents of ``self`` as text."
msgstr "Прочитайте содержимое ``self`` как текст."

#: ../../library/importlib.rst:777
msgid ""
"An abstract base class for resource readers capable of serving the :meth:"
"`importlib.resources.files` interface. Subclasses :class:`importlib."
"resources.abc.ResourceReader` and provides concrete implementations of the :"
"class:`importlib.resources.abc.ResourceReader`'s abstract methods. "
"Therefore, any loader supplying :class:`importlib.abc.TraversableResources` "
"also supplies ResourceReader."
msgstr ""
"Абстрактный базовый класс для чтения ресурсов, способный обслуживать "
"интерфейс :meth:`importlib.resources.files`. Подклассы :class:`importlib."
"resources.abc.ResourceReader` и предоставляют конкретные реализации "
"абстрактных методов :class:`importlib.resources.abc.ResourceReader`. "
"Следовательно, любой загрузчик, предоставляющий :class:`importlib.abc."
"TraversableResources`, также предоставляет ResourceReader."

#: ../../library/importlib.rst:784
msgid ""
"Loaders that wish to support resource reading are expected to implement this "
"interface."
msgstr ""
"Ожидается, что загрузчики, желающие поддерживать чтение ресурсов, реализуют "
"этот интерфейс."

#: ../../library/importlib.rst:795
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the loaded "
"package."
msgstr ""
"Возвращает объект :class:`importlib.resources.abc.Traversable` для "
"загруженного пакета."

#: ../../library/importlib.rst:801
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- Импортеры и перехватчики пути"

#: ../../library/importlib.rst:806
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Исходный код:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:810
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Этот модуль содержит различные объекты, которые помогают :keyword:`import` "
"находить и загружать модули."

#: ../../library/importlib.rst:815
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"Список строк, представляющих распознанные суффиксы файлов для исходных "
"модулей."

#: ../../library/importlib.rst:822
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"Список строк, представляющих суффиксы файлов для неоптимизированных модулей "
"байт-кода."

#: ../../library/importlib.rst:827 ../../library/importlib.rst:837
msgid "Use :const:`BYTECODE_SUFFIXES` instead."
msgstr "Вместо этого используйте :const:`BYTECODE_SUFFIXES`."

#: ../../library/importlib.rst:832
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"Список строк, представляющих суффиксы файлов для оптимизированных модулей "
"байт-кода."

#: ../../library/importlib.rst:842
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"Список строк, представляющих распознанные суффиксы файлов для модулей байт-"
"кода (включая начальную точку)."

#: ../../library/importlib.rst:847
msgid "The value is no longer dependent on ``__debug__``."
msgstr "Значение больше не зависит от ``__debug__``."

#: ../../library/importlib.rst:852
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"Список строк, представляющих распознанные суффиксы файлов для модулей "
"расширения."

#: ../../library/importlib.rst:859
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"Возвращает объединенный список строк, представляющих все суффиксы файлов для "
"модулей, распознаваемых стандартным механизмом импорта. Это помощник для "
"кода, которому просто нужно знать, потенциально ли путь файловой системы "
"относится к модулю, без необходимости каких-либо подробностей о типе модуля "
"(например, :func:`inspect.getmodulename`)."

#: ../../library/importlib.rst:870
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
":term:`импортер` для встроенных модулей. Все известные встроенные модули "
"перечислены в :data:`sys.builtin_module_names`. Этот класс реализует ABC :"
"class:`importlib.abc.MetaPathFinder` и :class:`importlib.abc.InspectLoader`."

#: ../../library/importlib.rst:875 ../../library/importlib.rst:889
#: ../../library/importlib.rst:902 ../../library/importlib.rst:917
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"В этом классе определяются только методы класса, чтобы избежать "
"необходимости создания экземпляров."

#: ../../library/importlib.rst:878
msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"В составе :pep:`489` встроенный импортер теперь реализует :meth:`Loader."
"create_module` и :meth:`Loader.exec_module`"

#: ../../library/importlib.rst:885
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
":term:`импортер` для замороженных модулей. Этот класс реализует ABC :class:"
"`importlib.abc.MetaPathFinder` и :class:`importlib.abc.InspectLoader`."

#: ../../library/importlib.rst:892
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""
"Получены методы :meth:`~Loader.create_module` и :meth:`~Loader.exec_module`."

#: ../../library/importlib.rst:899
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` для модулей, объявленных в реестре Windows. Этот "
"класс реализует :class:`importlib.abc.MetaPathFinder` ABC."

#: ../../library/importlib.rst:907
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Вместо этого используйте конфигурацию :mod:`site`. Будущие версии Python "
"могут не включать этот механизм поиска по умолчанию."

#: ../../library/importlib.rst:914
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
":term:`Finder <finder>` для атрибутов :data:`sys.path` и пакета "
"``__path__``. Этот класс реализует :class:`importlib.abc.MetaPathFinder` ABC."

#: ../../library/importlib.rst:922
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"Метод класса, который пытается найти :term:`spec <module spec>` для модуля, "
"указанного *fullname* в :data:`sys.path` или, если определено, в *path*. Для "
"каждой искомой записи пути проверяется :data:`sys.path_importer_cache`. Если "
"найден неложный объект, то он используется в качестве :term:`поиска записи "
"пути` для поиска искомого модуля. Если запись не найдена в :data:`sys."
"path_importer_cache`, то :data:`sys.path_hooks` ищет поисковик для записи "
"пути и, если найден, сохраняется в :data:`sys.path_importer_cache` вместе с "
"с запросом о модуле. Если искатель не найден, то ``None`` сохраняется в кеше "
"и возвращается."

#: ../../library/importlib.rst:936
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"Если текущий рабочий каталог, представленный пустой строкой, больше не "
"действителен, то возвращается None, но никакое значение не кэшируется в :"
"data:`sys.path_importer_cache`."

#: ../../library/importlib.rst:943
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Вызывает :meth:`importlib.abc.PathEntryFinder.invalidate_caches` для всех "
"средств поиска, хранящихся в :data:`sys.path_importer_cache`, которые "
"определяют метод. В противном случае записи в :data:`sys."
"path_importer_cache`, для которых установлено значение ``None``, удаляются."

#: ../../library/importlib.rst:948
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr "Записи ``None`` в :data:`sys.path_importer_cache` удаляются."

#: ../../library/importlib.rst:951
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Вызывает объекты в :data:`sys.path_hooks` с текущим рабочим каталогом для "
"``''`` (т.е. пустая строка)."

#: ../../library/importlib.rst:958
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"Конкретная реализация :class:`importlib.abc.PathEntryFinder`, которая "
"кэширует результаты из файловой системы."

#: ../../library/importlib.rst:961
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr "Аргумент *path* — это каталог, в котором искатель отвечает за поиск."

#: ../../library/importlib.rst:964
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"Аргумент *loader_details* представляет собой переменное количество кортежей "
"из двух элементов, каждый из которых содержит загрузчик и последовательность "
"файловых суффиксов, распознаваемых загрузчиком. Ожидается, что загрузчики "
"будут вызываемыми объектами, которые принимают два аргумента: имя модуля и "
"путь к найденному файлу."

#: ../../library/importlib.rst:969
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"Средство поиска будет кэшировать содержимое каталога по мере необходимости, "
"выполняя статистические вызовы для каждого поиска модуля, чтобы убедиться, "
"что кеш не устарел. Поскольку устаревание кэша зависит от детализации "
"информации о состоянии файловой системы операционной системы, существует "
"потенциальное состояние гонки при поиске модуля, создании нового файла, а "
"затем поиске модуля, который представляет новый файл. Если операции "
"выполняются достаточно быстро, чтобы соответствовать степени детализации "
"вызовов статистики, поиск модуля завершится неудачно. Чтобы этого не "
"произошло, при динамическом создании модуля обязательно вызывайте :func:"
"`importlib.invalidate_caches`."

#: ../../library/importlib.rst:983
msgid "The path the finder will search in."
msgstr "Путь, по которому будет искать искатель."

#: ../../library/importlib.rst:987
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Попытайтесь найти спецификацию для обработки *fullname* в :attr:`path`."

#: ../../library/importlib.rst:993
msgid "Clear out the internal cache."
msgstr "Очистите внутренний кэш."

#: ../../library/importlib.rst:997
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"Метод класса, который возвращает замыкание для использования в :data:`sys."
"path_hooks`. Экземпляр :class:`FileFinder` возвращается замыканием с "
"использованием аргумента пути, заданного замыканию напрямую, и "
"*loader_details* косвенно."

#: ../../library/importlib.rst:1002
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"Если аргумент закрытия не является существующим каталогом, возникает :exc:"
"`ImportError`."

#: ../../library/importlib.rst:1008
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"Конкретная реализация :class:`importlib.abc.SourceLoader` путем создания "
"подкласса :class:`importlib.abc.FileLoader` и предоставления некоторых "
"конкретных реализаций других методов."

#: ../../library/importlib.rst:1016
msgid "The name of the module that this loader will handle."
msgstr "Имя модуля, который будет обрабатывать этот загрузчик."

#: ../../library/importlib.rst:1020
msgid "The path to the source file."
msgstr "Путь к исходному файлу."

#: ../../library/importlib.rst:1024
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Возвращайте ``True``, если :attr:`path` принадлежит пакету."

#: ../../library/importlib.rst:1028
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr "Конкретная реализация :meth:`importlib.abc.SourceLoader.path_stats`."

#: ../../library/importlib.rst:1032
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "Конкретная реализация :meth:`importlib.abc.SourceLoader.set_data`."

#: ../../library/importlib.rst:1036 ../../library/importlib.rst:1079
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Конкретная реализация :meth:`importlib.abc.Loader.load_module`, где указание "
"имени загружаемого модуля не является обязательным."

#: ../../library/importlib.rst:1041 ../../library/importlib.rst:1084
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Вместо этого используйте :meth:`importlib.abc.Loader.exec_module`."

#: ../../library/importlib.rst:1046
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"Конкретная реализация :class:`importlib.abc.FileLoader`, которая может "
"импортировать файлы байт-кода (т.е. файлы исходного кода не существуют)."

#: ../../library/importlib.rst:1049
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"Обратите внимание, что прямое использование файлов байт-кода (и, "
"следовательно, не файлов исходного кода) препятствует использованию ваших "
"модулей всеми реализациями Python или новыми версиями Python, которые меняют "
"формат байт-кода."

#: ../../library/importlib.rst:1058
msgid "The name of the module the loader will handle."
msgstr "Имя модуля, который будет обрабатывать загрузчик."

#: ../../library/importlib.rst:1062
msgid "The path to the bytecode file."
msgstr "Путь к файлу байт-кода."

#: ../../library/importlib.rst:1066
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Определяет, является ли модуль пакетом на основе :attr:`path`."

#: ../../library/importlib.rst:1070
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr "Возвращает объект кода для :attr:`name`, созданный из :attr:`path`."

#: ../../library/importlib.rst:1074
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Возвращает None, поскольку файлы байт-кода не имеют источника при "
"использовании этого загрузчика."

#: ../../library/importlib.rst:1089
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"Конкретная реализация :class:`importlib.abc.ExecutionLoader` для модулей "
"расширения."

#: ../../library/importlib.rst:1092
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"Аргумент *fullname* указывает имя модуля, который должен поддерживать "
"загрузчик. Аргумент *path* — это путь к файлу модуля расширения."

#: ../../library/importlib.rst:1095
msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see :pep:`489`), "
"even if it would otherwise import successfully."
msgstr ""
"Обратите внимание, что по умолчанию импорт модуля расширения завершится "
"неудачей в подинтерпретаторах, если он не реализует многофазную "
"инициализацию (см. :pep:`489`), даже если в противном случае импорт будет "
"успешным."

#: ../../library/importlib.rst:1101
msgid "Multi-phase init is now required for use in subinterpreters."
msgstr ""
"Многофазная инициализация теперь требуется для использования в "
"субинтерпретаторах."

#: ../../library/importlib.rst:1106 ../../library/importlib.rst:1292
msgid "Name of the module the loader supports."
msgstr "Имя модуля, который поддерживает загрузчик."

#: ../../library/importlib.rst:1110
msgid "Path to the extension module."
msgstr "Путь к модулю расширения."

#: ../../library/importlib.rst:1114
msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr ""
"Создает объект модуля из заданной спецификации в соответствии с :pep:`489`."

#: ../../library/importlib.rst:1121
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Инициализирует данный объект модуля в соответствии с :pep:`489`."

#: ../../library/importlib.rst:1127
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :const:`EXTENSION_SUFFIXES`."
msgstr ""

#: ../../library/importlib.rst:1132
msgid "Returns ``None`` as extension modules lack a code object."
msgstr ""
"Возвращает None, поскольку в модулях расширения отсутствует объект кода."

#: ../../library/importlib.rst:1136
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "Возвращает None, поскольку модули расширения не имеют исходного кода."

#: ../../library/importlib.rst:1147
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace packages::"
msgstr ""
"Конкретная реализация :class:`importlib.abc.InspectLoader` для пакетов "
"пространства имен. Это псевдоним частного класса, который публикуется только "
"для анализа атрибута ``__loader__`` в пакетах пространства имен::"

#: ../../library/importlib.rst:1152
msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"

#: ../../library/importlib.rst:1165
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`~module.__spec__` attribute.  Many "
"of these attributes are also available directly on a module: for example, "
"``module.__spec__.origin == module.__file__``.  Note, however, that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`~module.__file__` at runtime and this will not be "
"automatically reflected in the module's :attr:`__spec__.origin <ModuleSpec."
"origin>`, and vice versa."
msgstr ""
"Спецификация состояния модуля, связанного с системой импорта. Обычно это "
"указывается как атрибут :attr:`~module.__spec__` модуля. Многие из этих "
"атрибутов также доступны непосредственно в модуле: например, ``module."
"__spec__.origin == module.__file__``. Однако обратите внимание, что хотя "
"*значения* обычно эквивалентны, они могут различаться, поскольку между двумя "
"объектами нет синхронизации. Например, можно обновить :attr:`~module."
"__file__` модуля во время выполнения, и это не будет автоматически отражено "
"в :attr:`__spec__.origin <ModuleSpec.origin>` модуля, и наоборот."

#: ../../library/importlib.rst:1179
msgid ""
"The module's fully qualified name (see :attr:`module.__name__`). The :term:"
"`finder` should always set this attribute to a non-empty string."
msgstr ""
"Полное имя модуля (см. :attr:`module.__name__`). :term:`finder` всегда "
"должен устанавливать для этого атрибута непустую строку."

#: ../../library/importlib.rst:1184
msgid ""
"The :term:`loader` used to load the module (see :attr:`module.__loader__`). "
"The :term:`finder` should always set this attribute."
msgstr ""
":term:`loader`, используемый для загрузки модуля (см. :attr:`module."
"__loader__`). :term:`finder` всегда должен устанавливать этот атрибут."

#: ../../library/importlib.rst:1189
msgid ""
"The location the :term:`loader` should use to load the module (see :attr:"
"`module.__file__`). For example, for modules loaded from a ``.py`` file this "
"is the filename. The :term:`finder` should always set this attribute to a "
"meaningful value for the :term:`loader` to use.  In the uncommon case that "
"there is not one (like for namespace packages), it should be set to ``None``."
msgstr ""
"Местоположение, которое :term:`loader` должен использовать для загрузки "
"модуля (см. :attr:`module.__file__`). Например, для модулей, загруженных из "
"файла ``.py``, это имя файла. :term:`finder` всегда должен устанавливать для "
"этого атрибута значимое значение, чтобы :term:`loader` мог его использовать. "
"В редких случаях, когда его нет (например, для пакетов пространства имен), "
"для него должно быть установлено значение «Нет»."

#: ../../library/importlib.rst:1198
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations in "
"which a package's submodules will be found (see :attr:`module.__path__`). "
"Most of the time there will only be a single directory in this list."
msgstr ""
"(Возможно, пустая) :term:`последовательность` строк, перечисляющих "
"местоположения, в которых будут найдены подмодули пакета (см. :attr:`module."
"__path__`). В большинстве случаев в этом списке будет только один каталог."

#: ../../library/importlib.rst:1203
msgid ""
"The :term:`finder` should set this attribute to a sequence, even an empty "
"one, to indicate to the import system that the module is a package.  It "
"should be set to ``None`` for non-package modules.  It is set automatically "
"later to a special object for namespace packages."
msgstr ""
":term:`finder` должен установить этот атрибут в последовательность, даже "
"пустую, чтобы указать системе импорта, что модуль является пакетом. Для "
"непакетных модулей должно быть установлено значение «Нет». Позже он "
"автоматически устанавливается в специальный объект для пакетов пространства "
"имен."

#: ../../library/importlib.rst:1211
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""
":term:`finder` может установить этот атрибут для объекта, содержащего "
"дополнительные, специфичные для модуля данные, которые будут использоваться "
"при загрузке модуля. В противном случае следует установить значение «Нет»."

#: ../../library/importlib.rst:1217
msgid ""
"The filename of a compiled version of the module's code (see :attr:`module."
"__cached__`). The :term:`finder` should always set this attribute but it may "
"be ``None`` for modules that do not need compiled code stored."
msgstr ""
"Имя файла скомпилированной версии кода модуля (см. :attr:`module."
"__cached__`). :term:`finder` всегда должен устанавливать этот атрибут, но он "
"может быть ``None`` для модулей, которым не требуется сохранение "
"скомпилированного кода."

#: ../../library/importlib.rst:1224
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the "
"empty string for a top-level module). See :attr:`module.__package__`. If the "
"module is a package then this is the same as :attr:`name`."
msgstr ""
"(Только для чтения) Полное имя пакета, в котором находится модуль (или "
"пустая строка для модуля верхнего уровня). См. :attr:`module.__package__`. "
"Если модуль является пакетом, то это то же самое, что и :attr:`name`."

#: ../../library/importlib.rst:1231
msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`!origin` is interpreted "
"and how the module's :attr:`~module.__file__` is populated."
msgstr ""
"``True``, если :attr:`origin` спецификации относится к загружаемому "
"местоположению, ``False`` в противном случае. Это значение влияет на то, как "
"интерпретируется :attr:`!origin` и как заполняется :attr:`~module.__file__` "
"модуля."

#: ../../library/importlib.rst:1238
msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that is "
"able to load extension modules in Framework format."
msgstr ""
"Специализация :class:`importlib.machinery.ExtensionFileLoader`, которая "
"способна загружать модули расширения в формате Framework."

#: ../../library/importlib.rst:1241
msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS app "
"must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There can "
"be only a single binary per framework, and there can be no executable binary "
"material outside the Frameworks folder."
msgstr ""
"Для совместимости с iOS App Store *все* бинарные модули в приложении iOS "
"должны быть динамическими библиотеками, содержащимися в фреймворке с "
"соответствующими метаданными, хранящимися в папке ``Frameworks`` "
"упакованного приложения. Для каждой платформы может быть только один "
"двоичный файл, и за пределами папки Frameworks не может быть исполняемого "
"двоичного материала."

#: ../../library/importlib.rst:1247
msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this loader "
"is be registered against the ``.fwork`` file extension, with a ``.fwork`` "
"file acting as a placeholder in the original location of the binary on ``sys."
"path``. The ``.fwork`` file contains the path of the actual binary in the "
"``Frameworks`` folder, relative to the app bundle. To allow for resolving a "
"framework-packaged binary back to the original location, the framework is "
"expected to contain a ``.origin`` file that contains the location of the ``."
"fwork`` file, relative to the app bundle."
msgstr ""
"Чтобы удовлетворить этому требованию, при работе на iOS двоичные файлы "
"модулей расширения *не* упаковываются как файлы ``.so`` в ``sys.path``, а "
"как отдельные автономные платформы. Чтобы обнаружить эти платформы, этот "
"загрузчик должен быть зарегистрирован с расширением файла ``.fwork``, при "
"этом файл ``.fwork`` действует как заполнитель в исходном местоположении "
"двоичного файла в ``sys.path``. Файл ``.fwork`` содержит путь к фактическому "
"двоичному файлу в папке ``Frameworks`` относительно пакета приложения. Чтобы "
"разрешить преобразование двоичного файла, упакованного в платформу, обратно "
"в исходное местоположение, ожидается, что платформа будет содержать файл ``."
"origin``, который содержит местоположение файла ``.fwork`` относительно "
"пакета приложения."

#: ../../library/importlib.rst:1258
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"Например, рассмотрим случай импорта ``из foo.bar import _whiz``, где "
"``_whiz`` реализуется с помощью двоичного модуля ``sources/foo/bar/_whiz."
"abi3.so``, с `` `sources`` — это местоположение, зарегистрированное в ``sys."
"path`` относительно пакета приложения. Этот модуль *должен* распространяться "
"как ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (имя платформы "
"создается из полного пути импорта модуля) с ``Info.plist` `файл в каталоге "
"``.framework``, идентифицирующий двоичный файл как фреймворк. Модуль ``foo."
"bar._whiz`` будет представлен в исходном месте с помощью файла маркера "
"``sources/foo/bar/_whiz.abi3.fwork``, содержащего путь ``Frameworks/foo.bar."
"_whiz``. /foo.bar._whiz``. Фреймворк также будет содержать ``Frameworks/foo."
"bar._whiz.framework/foo.bar._whiz.origin``, содержащий путь к файлу ``."
"fwork``."

#: ../../library/importlib.rst:1272
msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module "
"will report as the location of the ``.fwork`` file. This allows code to use "
"the ``__file__`` of a  module as an anchor for file system traversal. "
"However, the spec origin will reference the location of the *actual* binary "
"in the ``.framework`` folder."
msgstr ""

#: ../../library/importlib.rst:1278
msgid ""
"The Xcode project building the app is responsible for converting any ``.so`` "
"files from wherever they exist in the ``PYTHONPATH`` into frameworks in the "
"``Frameworks`` folder (including stripping extensions from the module file, "
"the addition of framework metadata, and signing the resulting framework), "
"and creating the ``.fwork`` and ``.origin`` files. This will usually be done "
"with a build step in the Xcode project; see the iOS documentation for "
"details on how to construct this build step."
msgstr ""
"Проект Xcode, создающий приложение, отвечает за преобразование любых файлов "
"``.so``, где бы они ни находились в ``PYTHONPATH``, в фреймворки в папке "
"``Frameworks`` (включая удаление расширений из файла модуля, добавление "
"метаданных платформы и подписание полученной структуры), а также создание "
"файлов ``.fwork`` и ``.origin``. Обычно это делается на этапе сборки в "
"проекте Xcode; подробную информацию о том, как построить этот этап сборки, "
"см. в документации iOS."

#: ../../library/importlib.rst:1288
msgid "Availability"
msgstr "Доступность"

#: ../../library/importlib.rst:1296
msgid "Path to the ``.fwork`` file for the extension module."
msgstr "Путь к файлу ``.fwork`` для модуля расширения."

#: ../../library/importlib.rst:1300
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- Утилитный код для импортеров"

#: ../../library/importlib.rst:1306
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Исходный код:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1310
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""
"Этот модуль содержит различные объекты, которые помогают в создании :term:"
"`importer`."

#: ../../library/importlib.rst:1315
msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Байты, представляющие номер версии байт-кода. Если вам нужна помощь с "
"загрузкой/записью байт-кода, рассмотрите :class:`importlib.abc.SourceLoader`."

#: ../../library/importlib.rst:1322
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"Верните путь :pep:`3147`/:pep:`488` к скомпилированному побайтно файлу, "
"связанному с исходным *path*. Например, если *path* равен ``/foo/bar/baz."
"py``, возвращаемое значение будет ``/foo/bar/__pycache__/baz.cpython-32."
"pyc`` для Python 3.2. Строка ``cpython-32`` берется из текущего магического "
"тега (см. :func:`get_tag`; если :attr:`sys.implementation.cache_tag` не "
"определен, то :exc:`NotImplementedError` будет поднято)."

#: ../../library/importlib.rst:1329
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"Параметр *optimization* используется для указания уровня оптимизации файла "
"байт-кода. Пустая строка означает отсутствие оптимизации, поэтому ``/foo/bar/"
"baz.py`` с *оптимизацией* ``''`` приведет к пути байт-кода ``/foo/bar/"
"__pycache__/baz. cpython-32.pyc``. ``None`` приводит к использованию уровня "
"оптимизации интерпретатора. Используется строковое представление любого "
"другого значения, поэтому ``/foo/bar/baz.py`` с *оптимизацией* ``2`` "
"приведет к пути байт-кода ``/foo/bar/__pycache__/baz. cpython-32.opt-2."
"pyc``. Строковое представление *оптимизации* может быть только буквенно-"
"цифровым, иначе выдается :exc:`ValueError`."

#: ../../library/importlib.rst:1339
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"Параметр *debug_override* устарел и может использоваться для переопределения "
"системного значения ``__debug__``. Значение True эквивалентно установке "
"*оптимизации* пустой строки. Значение «False» аналогично установке для "
"*optimization* значения «1». Если оба параметра *debug_override* и "
"*optimization* не равны None, то возникает :exc:`TypeError`."

#: ../../library/importlib.rst:1347
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"Был добавлен параметр *optimization*, а параметр *debug_override* признан "
"устаревшим."

#: ../../library/importlib.rst:1351 ../../library/importlib.rst:1367
#: ../../library/importlib.rst:1456
msgid "Accepts a :term:`path-like object`."
msgstr "Принимает :term:`объект, похожий на путь`."

#: ../../library/importlib.rst:1357
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Учитывая *путь* к имени файла :pep:`3147`, верните соответствующий путь к "
"файлу исходного кода. Например, если *path* равен ``/foo/bar/__pycache__/baz."
"cpython-32.pyc``, возвращаемый путь будет ``/foo/bar/baz.py``. *path* не "
"обязательно должен существовать, однако, если он не соответствует формату :"
"pep:`3147` или :pep:`488`, выдается ошибка :exc:`ValueError`. Если :attr:"
"`sys.implementation.cache_tag` не определен, возникает :exc:"
"`NotImplementedError`."

#: ../../library/importlib.rst:1372
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"Декодируйте данные байты, представляющие исходный код, и верните их в виде "
"строки с универсальными символами новой строки (как того требует :meth:"
"`importlib.abc.InspectLoader.get_source`)."

#: ../../library/importlib.rst:1380
msgid "Resolve a relative module name to an absolute one."
msgstr "Преобразуйте относительное имя модуля в абсолютное."

#: ../../library/importlib.rst:1382
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"Если в **name** нет начальных точек, то просто возвращается **name**. Это "
"позволяет использовать, например, ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` без проверки необходимости аргумента **package**."

#: ../../library/importlib.rst:1387
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised if a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
":exc:`ImportError` возникает, если **name** — относительное имя модуля, а "
"**package** — ложное значение (например, ``None`` или пустая строка). :exc:"
"`ImportError` также возникает, если относительное имя выходит за рамки "
"содержащего его пакета (например, запрос ``..bacon`` из пакета ``spam``)."

#: ../../library/importlib.rst:1395
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"Чтобы улучшить согласованность с операторами импорта, вызовите :exc:"
"`ImportError` вместо :exc:`ValueError` для недопустимых относительных "
"попыток импорта."

#: ../../library/importlib.rst:1402
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""
"Найдите :term:`spec <module spec>` для модуля, при необходимости "
"относительно указанного имени **package**. Если модуль находится в :data:"
"`sys.modules`, то возвращается ``sys.modules[name].__spec__`` (если только "
"спецификация не будет ``None`` или не установлена, в этом случае :exc :"
"`ValueError` возникает). В противном случае выполняется поиск с "
"использованием :data:`sys.meta_path`. ``None`` возвращается, если "
"спецификация не найдена."

#: ../../library/importlib.rst:1409
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Если **имя** относится к подмодулю (содержит точку), родительский модуль "
"импортируется автоматически."

#: ../../library/importlib.rst:1412
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**имя** и **пакет** работают так же, как и для :func:`import_module`."

#: ../../library/importlib.rst:1416
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`~module.__path__` "
"attribute)."
msgstr ""
"Вызывает :exc:`ModuleNotFoundError` вместо :exc:`AttributeError`, если "
"**package** на самом деле не является пакетом (т. е. не имеет атрибута :attr:"
"`~module.__path__`)."

#: ../../library/importlib.rst:1423
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Создайте новый модуль на основе **spec** и :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

#: ../../library/importlib.rst:1426
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Если :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"не возвращает ``None``, то любые ранее существовавшие атрибуты не будут "
"сброшены. Кроме того, :exc:`AttributeError` не будет возникать, если он "
"срабатывает при доступе к **spec** или установке атрибута в модуле."

#: ../../library/importlib.rst:1431
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Эта функция предпочтительнее использования :class:`types.ModuleType` для "
"создания нового модуля, поскольку **spec** используется для установки как "
"можно большего количества атрибутов, контролируемых импортом, в модуле."

#: ../../library/importlib.rst:1439
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"Фабричная функция для создания экземпляра :class:`~importlib.machinery."
"ModuleSpec` на основе загрузчика. Параметры имеют то же значение, что и для "
"ModuleSpec. Функция использует доступные API-интерфейсы :term:`loader`, "
"такие как :meth:`InspectLoader.is_package`, для заполнения любой недостающей "
"информации в спецификации."

#: ../../library/importlib.rst:1449
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"Фабричная функция для создания экземпляра :class:`~importlib.machinery."
"ModuleSpec` на основе пути к файлу. Недостающая информация будет заполнена в "
"спецификации за счет использования API-интерфейсов загрузчика и "
"подразумевая, что модуль будет основан на файлах."

#: ../../library/importlib.rst:1461
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Верните хеш *source_bytes* в виде байтов. Файл ``.pyc``, основанный на хеше, "
"встраивает :func:`source_hash` содержимого соответствующего исходного файла "
"в свой заголовок."

#: ../../library/importlib.rst:1469
msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also fail "
"for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""
"Контекстный менеджер, который может временно пропустить проверку "
"совместимости модулей расширения. По умолчанию проверка включена и "
"завершится неудачно, если однофазный модуль инициализации импортируется в "
"субинтерпретатор. Он также не будет работать для модуля многофазной "
"инициализации, который явно не поддерживает GIL для каждого интерпретатора, "
"при импорте в интерпретатор с собственным GIL."

#: ../../library/importlib.rst:1476
msgid ""
"Note that this function is meant to accommodate an unusual case; one which "
"is likely to eventually go away.  There's is a pretty good chance this is "
"not what you were looking for."
msgstr ""
"Обратите внимание, что эта функция предназначена для необычных случаев; тот, "
"который, вероятно, в конечном итоге исчезнет. Вполне вероятно, что это не "
"то, что вы искали."

#: ../../library/importlib.rst:1480
msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr ""
"Вы можете получить тот же эффект, что и эта функция, реализовав базовый "
"интерфейс многофазной инициализации (:pep:`489`) и солгав о поддержке "
"нескольких интерпретаторов (или GIL для каждого интерпретатора)."

#: ../../library/importlib.rst:1485
msgid ""
"Using this function to disable the check can lead to unexpected behavior and "
"even crashes.  It should only be used during extension module development."
msgstr ""
"Использование этой функции для отключения проверки может привести к "
"неожиданному поведению и даже сбоям. Его следует использовать только во "
"время разработки модуля расширения."

#: ../../library/importlib.rst:1493
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"Класс, который откладывает выполнение загрузчика модуля до тех пор, пока "
"модуль не получит доступ к атрибуту."

#: ../../library/importlib.rst:1496
msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :data:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""
"Этот класс **только** работает с загрузчиками, которые определяют :meth:"
"`~importlib.abc.Loader.exec_module`, поскольку требуется контроль над тем, "
"какой тип модуля используется для модуля. По тем же причинам метод :meth:"
"`~importlib.abc.Loader.create_module` загрузчика должен возвращать ``None`` "
"или тип, для которого его атрибут ``__class__`` может быть изменен без "
"использования :term: `слоты <__slots__>`. Наконец, модули, которые заменяют "
"объект, помещенный в :data:`sys.modules`, не будут работать, поскольку не "
"существует способа безопасно заменить ссылки на модули во всем "
"интерпретаторе; :exc:`ValueError` возникает, если обнаружена такая замена."

#: ../../library/importlib.rst:1507
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"Для проектов, где время запуска имеет решающее значение, этот класс "
"позволяет потенциально минимизировать стоимость загрузки модуля, если он "
"никогда не используется. Для проектов, где время запуска не является "
"существенным, использование этого класса **крайне** не рекомендуется из-за "
"того, что сообщения об ошибках, создаваемые во время загрузки, откладываются "
"и, таким образом, происходят вне контекста."

#: ../../library/importlib.rst:1515
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Начал вызывать :meth:`~importlib.abc.Loader.create_module`, удалив "
"предупреждение совместимости для :class:`importlib.machinery."
"BuiltinImporter` и :class:`importlib.machinery.ExtensionFileLoader`."

#: ../../library/importlib.rst:1522
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"Метод класса, который возвращает вызываемый объект, создающий ленивый "
"загрузчик. Это предназначено для использования в ситуациях, когда загрузчик "
"передается по классу, а не по экземпляру. ::"

#: ../../library/importlib.rst:1527
msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"

#: ../../library/importlib.rst:1535
msgid "Examples"
msgstr "Примеры"

#: ../../library/importlib.rst:1538
msgid "Importing programmatically"
msgstr "Программный импорт"

#: ../../library/importlib.rst:1540
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"Чтобы программно импортировать модуль, используйте :func:`importlib."
"import_module`. ::"

#: ../../library/importlib.rst:1543
msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"

#: ../../library/importlib.rst:1549
msgid "Checking if a module can be imported"
msgstr "Проверка возможности импорта модуля"

#: ../../library/importlib.rst:1551
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"Если вам нужно выяснить, можно ли импортировать модуль без фактического "
"импорта, вам следует использовать :func:`importlib.util.find_spec`."

#: ../../library/importlib.rst:1554
msgid ""
"Note that if ``name`` is a submodule (contains a dot), :func:`importlib.util."
"find_spec` will import the parent module. ::"
msgstr ""
"Обратите внимание: если ``name`` является подмодулем (содержит точку), :func:"
"`importlib.util.find_spec` импортирует родительский модуль. ::"

#: ../../library/importlib.rst:1558
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"

#: ../../library/importlib.rst:1577
msgid "Importing a source file directly"
msgstr "Импорт исходного файла напрямую"

#: ../../library/importlib.rst:1579
msgid ""
"This recipe should be used with caution: it is an approximation of an import "
"statement where the file path is specified directly, rather than :data:`sys."
"path` being searched. Alternatives should first be considered first, such as "
"modifying :data:`sys.path` when a proper module is required, or using :func:"
"`runpy.run_path` when the global namespace resulting from running a Python "
"file is appropriate."
msgstr ""
"Этот рецепт следует использовать с осторожностью: это приближение к "
"оператору импорта, в котором путь к файлу указывается напрямую, а не "
"выполняется поиск по :data:`sys.path`. В первую очередь следует рассмотреть "
"альтернативы, такие как изменение :data:`sys.path`, когда требуется "
"соответствующий модуль, или использование :func:`runpy.run_path`, когда "
"подходящее глобальное пространство имен, полученное в результате запуска "
"файла Python, является подходящим."

#: ../../library/importlib.rst:1586
msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr ""
"Чтобы импортировать исходный файл Python непосредственно по пути, "
"используйте следующий рецепт:"

#: ../../library/importlib.rst:1588
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"

#: ../../library/importlib.rst:1610
msgid "Implementing lazy imports"
msgstr "Реализация отложенного импорта"

#: ../../library/importlib.rst:1612
msgid "The example below shows how to implement lazy imports::"
msgstr "В примере ниже показано, как реализовать отложенный импорт:"

#: ../../library/importlib.rst:1614
msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"

#: ../../library/importlib.rst:1633
msgid "Setting up an importer"
msgstr "Настройка импортера"

#: ../../library/importlib.rst:1635
msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :data:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :data:`sys.path_hooks` "
"which works with :data:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""
"Для глубокой настройки импорта обычно требуется реализовать :term:"
"`importer`. Это означает управление как :term:`finder`, так и :term:"
"`loader`. Для поиска есть два варианта на выбор в зависимости от ваших "
"потребностей: :term:`мета-поиск пути` или :term:`поиск записей пути`. Первое "
"— это то, что вы бы поместили в :data:`sys.meta_path`, а второе — это то, "
"что вы создаёте с помощью :term:`path входного хука` в :data:`sys."
"path_hooks`, который работает с :data:`sys. Записи .path` для потенциального "
"создания средства поиска. Этот пример покажет вам, как зарегистрировать ваши "
"собственные импортеры, чтобы импорт мог использовать их (для создания "
"импортера для себя прочитайте документацию для соответствующих классов, "
"определенных в этом пакете)::"

#: ../../library/importlib.rst:1646
msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms "
"of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms "
"of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"

#: ../../library/importlib.rst:1667
msgid "Approximating :func:`importlib.import_module`"
msgstr "Приближение :func:`importlib.import_module`"

#: ../../library/importlib.rst:1669
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"Сам импорт реализован в коде Python, что позволяет использовать большую "
"часть механизмов импорта через importlib. Следующее помогает "
"проиллюстрировать различные API, которые предоставляет importlib, "
"предоставляя приблизительную реализацию :func:`importlib.import_module`::"

#: ../../library/importlib.rst:1675
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"

#: ../../library/importlib.rst:425
msgid "universal newlines"
msgstr "универсальные переводы строк"

#: ../../library/importlib.rst:425
msgid "importlib.abc.InspectLoader.get_source method"
msgstr "importlib.abc.InspectLoader.get_source метод"
