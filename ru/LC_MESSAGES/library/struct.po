# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:49+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/struct.rst:2
msgid ":mod:`!struct` --- Interpret bytes as packed binary data"
msgstr ""
":mod:`!struct` --- Интерпретировать байты как упакованные двоичные данные"

#: ../../library/struct.rst:7
msgid "**Source code:** :source:`Lib/struct.py`"
msgstr "**Исходный код:** :source:`Lib/struct.py`"

#: ../../library/struct.rst:15
msgid ""
"This module converts between Python values and C structs represented as "
"Python :class:`bytes` objects.  Compact :ref:`format strings <struct-format-"
"strings>` describe the intended conversions to/from Python values. The "
"module's functions and objects can be used for two largely distinct "
"applications, data exchange with external sources (files or network "
"connections), or data transfer between the Python application and the C "
"layer."
msgstr ""
"Этот модуль преобразует значения Python в структуры C, представленные как "
"объекты Python :class:`bytes`. Компактные строки формата <struct-format-"
"strings>` описывают предполагаемые преобразования в/из значений Python. "
"Функции и объекты модуля могут использоваться для двух совершенно разных "
"приложений: обмена данными с внешними источниками (файлами или сетевыми "
"подключениями) или передачи данных между приложением Python и уровнем C."

#: ../../library/struct.rst:25
msgid ""
"When no prefix character is given, native mode is the default. It packs or "
"unpacks data based on the platform and compiler on which the Python "
"interpreter was built. The result of packing a given C struct includes pad "
"bytes which maintain proper alignment for the C types involved; similarly, "
"alignment is taken into account when unpacking.  In contrast, when "
"communicating data between external sources, the programmer is responsible "
"for defining byte ordering and padding between elements. See :ref:`struct-"
"alignment` for details."
msgstr ""
"Если префикс не указан, по умолчанию используется собственный режим. Он "
"упаковывает или распаковывает данные на основе платформы и компилятора, на "
"которых был построен интерпретатор Python. Результат упаковки данной "
"структуры C включает байты заполнения, которые поддерживают правильное "
"выравнивание для задействованных типов C; аналогично выравнивание "
"учитывается при распаковке. Напротив, при передаче данных между внешними "
"источниками программист отвечает за определение порядка байтов и заполнение "
"между элементами. Подробности смотрите в :ref:`struct-alignment`."

#: ../../library/struct.rst:35
msgid ""
"Several :mod:`struct` functions (and methods of :class:`Struct`) take a "
"*buffer* argument.  This refers to objects that implement the :ref:"
"`bufferobjects` and provide either a readable or read-writable buffer.  The "
"most common types used for that purpose are :class:`bytes` and :class:"
"`bytearray`, but many other types that can be viewed as an array of bytes "
"implement the buffer protocol, so that they can be read/filled without "
"additional copying from a :class:`bytes` object."
msgstr ""
"Некоторые функции :mod:`struct` (и методы :class:`Struct`) принимают "
"аргумент *buffer*. Это относится к объектам, которые реализуют :ref:"
"`bufferobjects` и предоставляют либо читаемый, либо читаемо-записываемый "
"буфер. Наиболее распространенными типами, используемыми для этой цели, "
"являются :class:`bytes` и :class:`bytearray`, но многие другие типы, которые "
"можно рассматривать как массив байтов, реализуют протокол буфера, поэтому их "
"можно читать/заполнять без дополнительное копирование из объекта :class:"
"`bytes`."

#: ../../library/struct.rst:44
msgid "Functions and Exceptions"
msgstr "Функции и исключения"

#: ../../library/struct.rst:46
msgid "The module defines the following exception and functions:"
msgstr "Модуль определяет следующие исключения и функции:"

#: ../../library/struct.rst:51
msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr ""
"Исключение возникало в различных случаях; Аргумент — это строка, "
"описывающая, что не так."

#: ../../library/struct.rst:57
msgid ""
"Return a bytes object containing the values *v1*, *v2*, ... packed according "
"to the format string *format*.  The arguments must match the values required "
"by the format exactly."
msgstr ""
"Возвращает объект байтов, содержащий значения *v1*, *v2*, ..., упакованный в "
"соответствии со строкой формата *format*. Аргументы должны точно "
"соответствовать значениям, требуемым форматом."

#: ../../library/struct.rst:64
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *format* and "
"write the packed bytes into the writable buffer *buffer* starting at "
"position *offset*.  Note that *offset* is a required argument."
msgstr ""
"Упакуйте значения *v1*, *v2*, ... в соответствии со строкой формата *format* "
"и запишите упакованные байты в записываемый буфер *buffer*, начиная с "
"позиции *offset*. Обратите внимание, что *offset* является обязательным "
"аргументом."

#: ../../library/struct.rst:71
msgid ""
"Unpack from the buffer *buffer* (presumably packed by ``pack(format, ...)``) "
"according to the format string *format*.  The result is a tuple even if it "
"contains exactly one item.  The buffer's size in bytes must match the size "
"required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Распакуйте из буфера *buffer* (предположительно упакованного с помощью "
"``pack(format, ...)``) в соответствии со строкой формата *format*. "
"Результатом является кортеж, даже если он содержит ровно один элемент. "
"Размер буфера в байтах должен соответствовать размеру, требуемому форматом, "
"как это отражено в :func:`calcsize`."

#: ../../library/struct.rst:79
msgid ""
"Unpack from *buffer* starting at position *offset*, according to the format "
"string *format*.  The result is a tuple even if it contains exactly one "
"item.  The buffer's size in bytes, starting at position *offset*, must be at "
"least the size required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Распакуйте из *buffer*, начиная с позиции *offset*, в соответствии со "
"строкой формата *format*. Результатом является кортеж, даже если он содержит "
"ровно один элемент. Размер буфера в байтах, начиная с позиции *offset*, "
"должен быть не меньше размера, требуемого форматом, как это отражено в :func:"
"`calcsize`."

#: ../../library/struct.rst:87
msgid ""
"Iteratively unpack from the buffer *buffer* according to the format string "
"*format*.  This function returns an iterator which will read equally sized "
"chunks from the buffer until all its contents have been consumed.  The "
"buffer's size in bytes must be a multiple of the size required by the "
"format, as reflected by :func:`calcsize`."
msgstr ""
"Итеративно распаковать из буфера *buffer* в соответствии со строкой формата "
"*format*. Эта функция возвращает итератор, который будет читать из буфера "
"куски одинакового размера до тех пор, пока все его содержимое не будет "
"использовано. Размер буфера в байтах должен быть кратным размеру, требуемому "
"форматом, что отражено в :func:`calcsize`."

#: ../../library/struct.rst:93
msgid "Each iteration yields a tuple as specified by the format string."
msgstr "Каждая итерация дает кортеж, указанный в строке формата."

#: ../../library/struct.rst:100
msgid ""
"Return the size of the struct (and hence of the bytes object produced by "
"``pack(format, ...)``) corresponding to the format string *format*."
msgstr ""
"Возвращает размер структуры (и, следовательно, объекта байтов, созданного с "
"помощью ``pack(format, ...)``), соответствующего строке формата *format*."

#: ../../library/struct.rst:107
msgid "Format Strings"
msgstr "Форматирование строк"

#: ../../library/struct.rst:109
msgid ""
"Format strings describe the data layout when packing and unpacking data.  "
"They are built up from :ref:`format characters<format-characters>`, which "
"specify the type of data being packed/unpacked.  In addition, special "
"characters control the :ref:`byte order, size and alignment<struct-"
"alignment>`. Each format string consists of an optional prefix character "
"which describes the overall properties of the data and one or more format "
"characters which describe the actual data values and padding."
msgstr ""
"Строки формата описывают расположение данных при упаковке и распаковке "
"данных. Они состоят из :ref:`formatcharacters<format-characters>`, которые "
"определяют тип упаковываемых/распаковываемых данных. Кроме того, специальные "
"символы управляют порядком байтов, размером и выравниванием<struct-"
"alignment>`. Каждая строка формата состоит из необязательного префиксного "
"символа, который описывает общие свойства данных, и одного или нескольких "
"символов формата, которые описывают фактические значения данных и заполнение."

#: ../../library/struct.rst:121
msgid "Byte Order, Size, and Alignment"
msgstr "Порядок байтов, размер и выравнивание"

#: ../../library/struct.rst:123
msgid ""
"By default, C types are represented in the machine's native format and byte "
"order, and properly aligned by skipping pad bytes if necessary (according to "
"the rules used by the C compiler). This behavior is chosen so that the bytes "
"of a packed struct correspond exactly to the memory layout of the "
"corresponding C struct. Whether to use native byte ordering and padding or "
"standard formats depends on the application."
msgstr ""
"По умолчанию типы C представлены в собственном формате машины и порядке "
"байтов и правильно выровнены путем пропуска дополнительных байтов, если это "
"необходимо (в соответствии с правилами, используемыми компилятором C). Такое "
"поведение выбрано таким образом, чтобы байты упакованной структуры точно "
"соответствовали расположению памяти соответствующей структуры C. "
"Использовать ли собственный порядок байтов и заполнение или стандартные "
"форматы, зависит от приложения."

#: ../../library/struct.rst:139
msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr ""
"Альтернативно, первый символ строки формата может использоваться для "
"указания порядка байтов, размера и выравнивания упакованных данных в "
"соответствии со следующей таблицей:"

#: ../../library/struct.rst:144
msgid "Character"
msgstr "Символ"

#: ../../library/struct.rst:144
msgid "Byte order"
msgstr "Порядок байтов"

#: ../../library/struct.rst:144
msgid "Size"
msgstr "Размер"

#: ../../library/struct.rst:144
msgid "Alignment"
msgstr "Выравнивание"

#: ../../library/struct.rst:146
msgid "``@``"
msgstr "``@``"

#: ../../library/struct.rst:146 ../../library/struct.rst:148
msgid "native"
msgstr "native"

#: ../../library/struct.rst:148
msgid "``=``"
msgstr "``=``"

#: ../../library/struct.rst:148 ../../library/struct.rst:150
#: ../../library/struct.rst:152 ../../library/struct.rst:154
msgid "standard"
msgstr "стандартный"

#: ../../library/struct.rst:148 ../../library/struct.rst:150
#: ../../library/struct.rst:152 ../../library/struct.rst:154
msgid "none"
msgstr "none"

#: ../../library/struct.rst:150
msgid "``<``"
msgstr "``<``"

#: ../../library/struct.rst:150
msgid "little-endian"
msgstr "little-endian"

#: ../../library/struct.rst:152
msgid "``>``"
msgstr "``>``"

#: ../../library/struct.rst:152
msgid "big-endian"
msgstr "big-endian"

#: ../../library/struct.rst:154
msgid "``!``"
msgstr "``!``"

#: ../../library/struct.rst:154
msgid "network (= big-endian)"
msgstr "сеть (= big-endian)"

#: ../../library/struct.rst:157
msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr "Если первый символ не является одним из этих, предполагается ``'@'``."

#: ../../library/struct.rst:161
msgid ""
"The number 1023 (``0x3ff`` in hexadecimal) has the following byte "
"representations:"
msgstr ""
"Число 1023 (шестнадцатеричное 0x3ff) имеет следующие байтовые представления:"

#: ../../library/struct.rst:163
msgid "``03 ff`` in big-endian (``>``)"
msgstr "``03 ff`` in big-endian (``>``)"

#: ../../library/struct.rst:164
msgid "``ff 03`` in little-endian (``<``)"
msgstr "``ff 03`` in little-endian (``<``)"

#: ../../library/struct.rst:166
msgid "Python example:"
msgstr "Пример Python:"

#: ../../library/struct.rst:174
msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Intel x86, AMD64 (x86-64), and Apple M1 are little-"
"endian; IBM z and many legacy architectures are big-endian. Use :data:`sys."
"byteorder` to check the endianness of your system."
msgstr ""
"Собственный порядок байтов — прямой или прямой, в зависимости от хост-"
"системы. Например, Intel x86, AMD64 (x86-64) и Apple M1 имеют прямой порядок "
"байтов; IBM z и многие устаревшие архитектуры имеют обратный порядок байтов. "
"Используйте :data:`sys.byteorder`, чтобы проверить порядок байтов вашей "
"системы."

#: ../../library/struct.rst:179
msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr ""
"Собственный размер и выравнивание определяются с использованием выражения "
"компилятора C sizeof. Это всегда сочетается с собственным порядком байтов."

#: ../../library/struct.rst:182
msgid ""
"Standard size depends only on the format character;  see the table in the :"
"ref:`format-characters` section."
msgstr ""
"Стандартный размер зависит только от символа формата; см. таблицу в разделе :"
"ref:`format-characters`."

#: ../../library/struct.rst:185
msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr ""
"Обратите внимание на разницу между ``'@'`` и ``'='``: оба используют "
"собственный порядок байтов, но размер и выравнивание последнего "
"стандартизированы."

#: ../../library/struct.rst:188
msgid ""
"The form ``'!'`` represents the network byte order which is always big-"
"endian as defined in `IETF RFC 1700 <IETF RFC 1700_>`_."
msgstr ""
"Форма ``'!'`` представляет сетевой порядок байтов, который всегда имеет "
"обратный порядок байтов, как определено в ``IETF RFC 1700 <IETF RFC 1700_>`_."

#: ../../library/struct.rst:191
msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""
"Невозможно указать несобственный порядок байтов (принудительная замена "
"байтов); используйте соответствующий выбор ``'<'`` или ``'>'``."

#: ../../library/struct.rst:194 ../../library/struct.rst:273
msgid "Notes:"
msgstr "Примечания:"

#: ../../library/struct.rst:196
msgid ""
"Padding is only automatically added between successive structure members. No "
"padding is added at the beginning or the end of the encoded struct."
msgstr ""
"Заполнение автоматически добавляется только между последовательными "
"элементами структуры. Никакие дополнения не добавляются в начале или конце "
"закодированной структуры."

#: ../../library/struct.rst:199
msgid ""
"No padding is added when using non-native size and alignment, e.g. with '<', "
"'>', '=', and '!'."
msgstr ""
"При использовании нестандартного размера и выравнивания, например, с '<', "
"'>', '=' и '!', заполнение не добавляется."

#: ../../library/struct.rst:202
msgid ""
"To align the end of a structure to the alignment requirement of a particular "
"type, end the format with the code for that type with a repeat count of "
"zero.  See :ref:`struct-examples`."
msgstr ""
"Чтобы привести конец структуры в соответствие с требованиями выравнивания "
"определенного типа, завершите формат кодом для этого типа с нулевым "
"счетчиком повторов. См. :ref:`struct-examples`."

#: ../../library/struct.rst:210
msgid "Format Characters"
msgstr "Форматирование символов"

#: ../../library/struct.rst:212
msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types.  The 'Standard size' "
"column refers to the size of the packed value in bytes when using standard "
"size; that is, when the format string starts with one of ``'<'``, ``'>'``, "
"``'!'`` or ``'='``.  When using native size, the size of the packed value is "
"platform-dependent."
msgstr ""
"Символы формата имеют следующее значение; преобразование между значениями C "
"и Python должно быть очевидным, учитывая их типы. Столбец «Стандартный "
"размер» относится к размеру упакованного значения в байтах при использовании "
"стандартного размера; то есть, когда строка формата начинается с одного из "
"``'<'``, ``'>'``, ``'!'`` или ``'='``. При использовании собственного "
"размера размер упакованного значения зависит от платформы."

#: ../../library/struct.rst:220
msgid "Format"
msgstr "Формат"

#: ../../library/struct.rst:220
msgid "C Type"
msgstr "Тип C"

#: ../../library/struct.rst:220
msgid "Python type"
msgstr "Тип Python"

#: ../../library/struct.rst:220
msgid "Standard size"
msgstr "Стандартный размер"

#: ../../library/struct.rst:220
msgid "Notes"
msgstr "Примечания"

#: ../../library/struct.rst:222
msgid "``x``"
msgstr "``x``"

#: ../../library/struct.rst:222
msgid "pad byte"
msgstr "байт заполнения"

#: ../../library/struct.rst:222
msgid "no value"
msgstr "нет значения"

#: ../../library/struct.rst:222
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/struct.rst:224
msgid "``c``"
msgstr "``c``"

#: ../../library/struct.rst:224
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../library/struct.rst:224
msgid "bytes of length 1"
msgstr "байты длиной 1"

#: ../../library/struct.rst:224 ../../library/struct.rst:226
#: ../../library/struct.rst:228 ../../library/struct.rst:230
msgid "1"
msgstr "1"

#: ../../library/struct.rst:226
msgid "``b``"
msgstr "``b``"

#: ../../library/struct.rst:226
msgid ":c:expr:`signed char`"
msgstr ":c:expr:`signed char`"

#: ../../library/struct.rst:226 ../../library/struct.rst:228
#: ../../library/struct.rst:232 ../../library/struct.rst:234
#: ../../library/struct.rst:236 ../../library/struct.rst:238
#: ../../library/struct.rst:240 ../../library/struct.rst:242
#: ../../library/struct.rst:244 ../../library/struct.rst:246
#: ../../library/struct.rst:249 ../../library/struct.rst:251
#: ../../library/struct.rst:263
msgid "integer"
msgstr "целое число"

#: ../../library/struct.rst:226
msgid "\\(1), \\(2)"
msgstr "\\(1), \\(2)"

#: ../../library/struct.rst:228
msgid "``B``"
msgstr "``B``"

#: ../../library/struct.rst:228
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../library/struct.rst:228 ../../library/struct.rst:232
#: ../../library/struct.rst:234 ../../library/struct.rst:236
#: ../../library/struct.rst:238 ../../library/struct.rst:240
#: ../../library/struct.rst:242 ../../library/struct.rst:244
#: ../../library/struct.rst:246
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/struct.rst:230
msgid "``?``"
msgstr "``?``"

#: ../../library/struct.rst:230
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../../library/struct.rst:230
msgid "bool"
msgstr "bool"

#: ../../library/struct.rst:230
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/struct.rst:232
msgid "``h``"
msgstr "``h``"

#: ../../library/struct.rst:232
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../library/struct.rst:232 ../../library/struct.rst:234
#: ../../library/struct.rst:253
msgid "2"
msgstr "2"

#: ../../library/struct.rst:234
msgid "``H``"
msgstr "``H``"

#: ../../library/struct.rst:234
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../library/struct.rst:236
msgid "``i``"
msgstr "``i``"

#: ../../library/struct.rst:236
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../library/struct.rst:236 ../../library/struct.rst:238
#: ../../library/struct.rst:240 ../../library/struct.rst:242
#: ../../library/struct.rst:255
msgid "4"
msgstr "4"

#: ../../library/struct.rst:238
msgid "``I``"
msgstr "``I``"

#: ../../library/struct.rst:238
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../library/struct.rst:240
msgid "``l``"
msgstr "``l``"

#: ../../library/struct.rst:240
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../library/struct.rst:242
msgid "``L``"
msgstr "``L``"

#: ../../library/struct.rst:242
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../library/struct.rst:244
msgid "``q``"
msgstr "``q``"

#: ../../library/struct.rst:244
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: ../../library/struct.rst:244 ../../library/struct.rst:246
#: ../../library/struct.rst:257
msgid "8"
msgstr "8"

#: ../../library/struct.rst:246
msgid "``Q``"
msgstr "``Q``"

#: ../../library/struct.rst:246
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: ../../library/struct.rst:249
msgid "``n``"
msgstr "``n``"

#: ../../library/struct.rst:249
msgid ":c:type:`ssize_t`"
msgstr ":c:type:`ssize_t`"

#: ../../library/struct.rst:249 ../../library/struct.rst:251
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/struct.rst:251
msgid "``N``"
msgstr "``N``"

#: ../../library/struct.rst:251
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../../library/struct.rst:253
msgid "``e``"
msgstr "``e``"

#: ../../library/struct.rst:253
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/struct.rst:253 ../../library/struct.rst:255
#: ../../library/struct.rst:257
msgid "float"
msgstr "float"

#: ../../library/struct.rst:253 ../../library/struct.rst:255
#: ../../library/struct.rst:257
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/struct.rst:255
msgid "``f``"
msgstr "``f``"

#: ../../library/struct.rst:255
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../library/struct.rst:257
msgid "``d``"
msgstr "``d``"

#: ../../library/struct.rst:257
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../library/struct.rst:259
msgid "``s``"
msgstr "``s``"

#: ../../library/struct.rst:259 ../../library/struct.rst:261
msgid ":c:expr:`char[]`"
msgstr ":c:expr:`char[]`"

#: ../../library/struct.rst:259 ../../library/struct.rst:261
msgid "bytes"
msgstr "байт"

#: ../../library/struct.rst:259
msgid "\\(9)"
msgstr "\\(9)"

#: ../../library/struct.rst:261
msgid "``p``"
msgstr "``p``"

#: ../../library/struct.rst:261
msgid "\\(8)"
msgstr "\\(8)"

#: ../../library/struct.rst:263
msgid "``P``"
msgstr "``P``"

#: ../../library/struct.rst:263
msgid ":c:expr:`void \\*`"
msgstr ":c:expr:`void \\*`"

#: ../../library/struct.rst:263
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/struct.rst:266
msgid "Added support for the ``'n'`` and ``'N'`` formats."
msgstr "Добавлена ​​поддержка форматов ``'n'`` и ``'N'``."

#: ../../library/struct.rst:269
msgid "Added support for the ``'e'`` format."
msgstr "Добавлена ​​поддержка формата ``'e'``."

#: ../../library/struct.rst:278
msgid ""
"The ``'?'`` conversion code corresponds to the :c:expr:`_Bool` type defined "
"by C standards since C99.  In standard mode, it is represented by one byte."
msgstr ""
"Код преобразования ``'?'`` соответствует типу :c:expr:`_Bool`, определенному "
"стандартами C, начиная с C99. В стандартном режиме он представлен одним "
"байтом."

#: ../../library/struct.rst:283
msgid ""
"When attempting to pack a non-integer using any of the integer conversion "
"codes, if the non-integer has a :meth:`~object.__index__` method then that "
"method is called to convert the argument to an integer before packing."
msgstr ""
"При попытке упаковать нецелое число с использованием любого из целочисленных "
"кодов преобразования, если нецелое число имеет метод :meth:`~object."
"__index__`, то этот метод вызывается для преобразования аргумента в целое "
"число перед упаковкой."

#: ../../library/struct.rst:287
msgid "Added use of the :meth:`~object.__index__` method for non-integers."
msgstr ""
"Добавлено использование метода :meth:`~object.__index__` для нецелых чисел."

#: ../../library/struct.rst:291
msgid ""
"The ``'n'`` and ``'N'`` conversion codes are only available for the native "
"size (selected as the default or with the ``'@'`` byte order character). For "
"the standard size, you can use whichever of the other integer formats fits "
"your application."
msgstr ""
"Коды преобразования ``'n'`` и ``'N'`` доступны только для собственного "
"размера (выбранного по умолчанию или с символом порядка байтов ``'@'``). Для "
"стандартного размера вы можете использовать любой другой целочисленный "
"формат, подходящий для вашего приложения."

#: ../../library/struct.rst:297
msgid ""
"For the ``'f'``, ``'d'`` and ``'e'`` conversion codes, the packed "
"representation uses the IEEE 754 binary32, binary64 or binary16 format (for "
"``'f'``, ``'d'`` or ``'e'`` respectively), regardless of the floating-point "
"format used by the platform."
msgstr ""
"Для кодов преобразования ``'f'``, ``'d'`` и ``'e'`` упакованное "
"представление использует формат IEEE 754binary32,binary64 илиbinary16 (для "
"``'f'`` , ``'d'`` или ``'e'`` соответственно), независимо от формата с "
"плавающей запятой, используемого платформой."

#: ../../library/struct.rst:303
msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""
"Символ формата ``'P'`` доступен только для собственного порядка байтов "
"(выбранного по умолчанию или с символом порядка байтов ``'@'``). Символ "
"порядка байтов ``'='`` выбирает использование прямого или обратного порядка "
"байтов в зависимости от хост-системы. Модуль struct не интерпретирует это "
"как собственный порядок, поэтому формат P недоступен."

#: ../../library/struct.rst:310
msgid ""
"The IEEE 754 binary16 \"half precision\" type was introduced in the 2008 "
"revision of the `IEEE 754 standard <ieee 754 standard_>`_. It has a sign "
"bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), "
"and can represent numbers between approximately ``6.1e-05`` and ``6.5e+04`` "
"at full precision. This type is not widely supported by C compilers: on a "
"typical machine, an unsigned short can be used for storage, but not for math "
"operations. See the Wikipedia page on the `half-precision floating-point "
"format <half precision format_>`_ for more information."
msgstr ""
"Двоичный16 тип IEEE 754 «половинной точности» был введен в версии 2008 года "
"`_ стандарта IEEE 754 <ieee 754 Standard_>`_. Он имеет знаковый бит, 5-"
"битную экспоненту и 11-битную точность (с явно сохраненными 10 битами) и "
"может представлять числа примерно между ``6.1e-05`` и ``6.5e+04`` с полной "
"точностью. . Этот тип не поддерживается широко компиляторами C: на типичной "
"машине беззнаковое сокращение может использоваться для хранения, но не для "
"математических операций. Дополнительную информацию см. на странице Википедии "
"«формат с плавающей запятой половинной точности <формат половинной "
"точности_>»."

#: ../../library/struct.rst:320
msgid "When packing, ``'x'`` inserts one NUL byte."
msgstr "При упаковке ``'x'`` вставляет один NUL-байт."

#: ../../library/struct.rst:323
msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a *fixed number of bytes*, given by the "
"count. The first byte stored is the length of the string, or 255, whichever "
"is smaller.  The bytes of the string follow.  If the string passed in to :"
"func:`pack` is too long (longer than the count minus 1), only the leading "
"``count-1`` bytes of the string are stored.  If the string is shorter than "
"``count-1``, it is padded with null bytes so that exactly count bytes in all "
"are used.  Note that for :func:`unpack`, the ``'p'`` format character "
"consumes ``count`` bytes, but that the string returned can never contain "
"more than 255 bytes."
msgstr ""
"Символ формата ``'p'`` кодирует \"строку Паскаля\", то есть короткую строку "
"переменной длины, хранящуюся в *фиксированном количестве байтов*, заданном "
"счетчиком. Первый сохраненный байт соответствует длине строки или 255, в "
"зависимости от того, что меньше. Далее следуют байты строки. Если строка, "
"переданная в :func:`pack`, слишком длинная (длиннее, чем count минус 1), "
"сохраняются только ведущие байты ``count-1`` строки. Если строка короче, чем "
"``count-1``, она дополняется нулевыми байтами, так что всего используется "
"ровно столько байтов. Обратите внимание, что для :func:`unpack` символ "
"формата ``'p'`` потребляет ``count`` байтов, но возвращаемая строка никогда "
"не может содержать более 255 байтов."

#: ../../library/struct.rst:335
msgid ""
"For the ``'s'`` format character, the count is interpreted as the length of "
"the bytes, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string mapping to or from a single "
"Python byte string, while ``'10c'`` means 10 separate one byte character "
"elements (e.g., ``cccccccccc``) mapping to or from ten different Python byte "
"objects. (See :ref:`struct-examples` for a concrete demonstration of the "
"difference.) If a count is not given, it defaults to 1.  For packing, the "
"string is truncated or padded with null bytes as appropriate to make it fit. "
"For unpacking, the resulting bytes object always has exactly the specified "
"number of bytes.  As a special case, ``'0s'`` means a single, empty string "
"(while ``'0c'`` means 0 characters)."
msgstr ""
"Для символа формата ``'s'`` счетчик интерпретируется как длина байтов, а не "
"как счетчик повторений, как для других символов формата; например, ``'10s'`` "
"означает одну 10-байтовую строку, сопоставленную с одной байтовой строкой "
"Python или из нее, а ``'10c'`` означает 10 отдельных однобайтовых символьных "
"элементов (например, ``cccccccccc`` ) сопоставление десяти различным "
"байтовым объектам Python или обратно. (См. :ref:`struct-examples` для "
"конкретной демонстрации разницы.) Если счетчик не указан, по умолчанию он "
"равен 1. Для упаковки строка усекается или дополняется нулевыми байтами, "
"чтобы она соответствовала размеру. При распаковке результирующий объект "
"байтов всегда содержит ровно указанное количество байтов. В частном случае "
"``'0s'`` означает одну пустую строку (в то время как ``'0c'`` означает 0 "
"символов)."

#: ../../library/struct.rst:348
msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""
"Символу формата может предшествовать целое число повторений. Например, "
"строка формата ``'4h'`` означает то же самое, что и ``'hhhh'``."

#: ../../library/struct.rst:351
msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr ""
"Пробелы между форматами игнорируются; однако счетчик и его формат не должны "
"содержать пробелов."

#: ../../library/struct.rst:354
msgid ""
"When packing a value ``x`` using one of the integer formats (``'b'``, "
"``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, "
"``'Q'``), if ``x`` is outside the valid range for that format then :exc:"
"`struct.error` is raised."
msgstr ""
"При упаковке значения ``x`` с использованием одного из целочисленных "
"форматов (``'b'``, ``'B'``, ``'h'``, ``'H'``, `` 'i'``, ``'I'``, ``'l'``, "
"``'L'``, ``'q'``, ``'Q'``), если `` x`` находится за пределами допустимого "
"диапазона для этого формата, тогда возникает :exc:`struct.error`."

#: ../../library/struct.rst:359
msgid ""
"Previously, some of the integer formats wrapped out-of-range values and "
"raised :exc:`DeprecationWarning` instead of :exc:`struct.error`."
msgstr ""
"Ранее некоторые целочисленные форматы переносили значения, выходящие за "
"пределы диапазона, и вызывали :exc:`DeprecationWarning` вместо :exc:`struct."
"error`."

#: ../../library/struct.rst:365
msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""
"Для символа формата ``'?'`` возвращаемое значение равно либо :const:`True`, "
"либо :const:`False`. При упаковке используется значение истинности объекта "
"аргумента. Будет упаковано либо 0, либо 1 в собственном или стандартном "
"логическом представлении, а любое ненулевое значение при распаковке будет "
"иметь значение «True»."

#: ../../library/struct.rst:375
msgid "Examples"
msgstr "Примеры"

#: ../../library/struct.rst:378
msgid ""
"Native byte order examples (designated by the ``'@'`` format prefix or lack "
"of any prefix character) may not match what the reader's machine produces as "
"that depends on the platform and compiler."
msgstr ""
"Примеры собственного порядка байтов (обозначаемые префиксом формата ``'@'`` "
"или отсутствием какого-либо префиксного символа) могут не соответствовать "
"тому, что выдает машина чтения, поскольку это зависит от платформы и "
"компилятора."

#: ../../library/struct.rst:383
msgid ""
"Pack and unpack integers of three different sizes, using big endian "
"ordering::"
msgstr ""
"Упаковывайте и распаковывайте целые числа трёх разных размеров, используя "
"обратный порядок байтов:"

#: ../../library/struct.rst:386
msgid ""
">>> from struct import *\n"
">>> pack(\">bhl\", 1, 2, 3)\n"
"b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('>bhl', b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('>bhl')\n"
"7"
msgstr ""
">>> from struct import *\n"
">>> pack(\">bhl\", 1, 2, 3)\n"
"b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('>bhl', b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('>bhl')\n"
"7"

#: ../../library/struct.rst:394
msgid "Attempt to pack an integer which is too large for the defined field::"
msgstr ""
"Попытка упаковать целое число, которое слишком велико для определенного "
"поля::"

#: ../../library/struct.rst:396
msgid ""
">>> pack(\">h\", 99999)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"struct.error: 'h' format requires -32768 <= number <= 32767"
msgstr ""
">>> пакет(\">h\", 99999) Traceback (последний вызов последний): Файл "
"«<stdin>», строка 1, в <модуле> struct.error: для формата 'h' требуется "
"-32768 <= число <= 32767"

#: ../../library/struct.rst:401
msgid ""
"Demonstrate the difference between ``'s'`` and ``'c'`` format characters::"
msgstr "Продемонстрируйте разницу между символами формата ``'s'`` и ``'c'``::"

#: ../../library/struct.rst:404
msgid ""
">>> pack(\"@ccc\", b'1', b'2', b'3')\n"
"b'123'\n"
">>> pack(\"@3s\", b'123')\n"
"b'123'"
msgstr ""
">>> pack(\"@ccc\", b'1', b'2', b'3')\n"
"b'123'\n"
">>> pack(\"@3s\", b'123')\n"
"b'123'"

#: ../../library/struct.rst:409
msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr ""
"Неупакованным полям можно дать имена, присвоив их переменным или обернув "
"результат в именованный кортеж:"

#: ../../library/struct.rst:412
msgid ""
">>> record = b'raymond   \\x32\\x12\\x08\\x01\\x08'\n"
">>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'name serialnum school gradelevel')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)"
msgstr ""
">>> record = b'raymond   \\x32\\x12\\x08\\x01\\x08'\n"
">>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'name serialnum school gradelevel')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)"

#: ../../library/struct.rst:420
msgid ""
"The ordering of format characters may have an impact on size in native mode "
"since padding is implicit. In standard mode, the user is responsible for "
"inserting any desired padding. Note in the first ``pack`` call below that "
"three NUL bytes were added after the packed ``'#'`` to align the following "
"integer on a four-byte boundary. In this example, the output was produced on "
"a little endian machine::"
msgstr ""
"Порядок символов формата может влиять на размер в основном режиме, поскольку "
"заполнение неявно. В стандартном режиме пользователь несет ответственность "
"за вставку любого желаемого заполнения. Обратите внимание, что в первом "
"вызове ``pack`` ниже, после упакованного ``'#'`` были добавлены три NUL-"
"байта, чтобы выровнять следующее целое число по границе четырех байтов. В "
"этом примере выходные данные были созданы на машине с прямым порядком байтов:"

#: ../../library/struct.rst:428
msgid ""
">>> pack('@ci', b'#', 0x12131415)\n"
"b'#\\x00\\x00\\x00\\x15\\x14\\x13\\x12'\n"
">>> pack('@ic', 0x12131415, b'#')\n"
"b'\\x15\\x14\\x13\\x12#'\n"
">>> calcsize('@ci')\n"
"8\n"
">>> calcsize('@ic')\n"
"5"
msgstr ""
">>> pack('@ci', b'#', 0x12131415)\n"
"b'#\\x00\\x00\\x00\\x15\\x14\\x13\\x12'\n"
">>> pack('@ic', 0x12131415, b'#')\n"
"b'\\x15\\x14\\x13\\x12#'\n"
">>> calcsize('@ci')\n"
"8\n"
">>> calcsize('@ic')\n"
"5"

#: ../../library/struct.rst:437
msgid ""
"The following format ``'llh0l'`` results in two pad bytes being added at the "
"end, assuming the platform's longs are aligned on 4-byte boundaries::"
msgstr ""
"Следующий формат ``'llh0l'`` приводит к добавлению в конце двух байтов "
"заполнения, предполагая, что длинные длины платформы выровнены по границам 4 "
"байтов:"

#: ../../library/struct.rst:440
msgid ""
">>> pack('@llh0l', 1, 2, 3)\n"
"b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x00'"
msgstr ""
">>> pack('@llh0l', 1, 2, 3)\n"
"b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x00'"

#: ../../library/struct.rst:446
msgid "Module :mod:`array`"
msgstr "Модуль :mod:`array`"

#: ../../library/struct.rst:447
msgid "Packed binary storage of homogeneous data."
msgstr "Упакованное двоичное хранилище однородных данных."

#: ../../library/struct.rst:449
msgid "Module :mod:`json`"
msgstr "Модуль :mod:`json`"

#: ../../library/struct.rst:450
msgid "JSON encoder and decoder."
msgstr "Кодер и декодер JSON."

#: ../../library/struct.rst:452
msgid "Module :mod:`pickle`"
msgstr "Модуль :mod:`pickle`"

#: ../../library/struct.rst:453
msgid "Python object serialization."
msgstr "Сериализация объектов Python."

#: ../../library/struct.rst:459
msgid "Applications"
msgstr "Приложения"

#: ../../library/struct.rst:461
msgid ""
"Two main applications for the :mod:`struct` module exist, data interchange "
"between Python and C code within an application or another application "
"compiled using the same compiler (:ref:`native formats<struct-native-"
"formats>`), and data interchange between applications using agreed upon data "
"layout (:ref:`standard formats<struct-standard-formats>`).  Generally "
"speaking, the format strings constructed for these two domains are distinct."
msgstr ""
"Существуют два основных приложения для модуля :mod:`struct`: обмен данными "
"между кодом Python и C внутри приложения или другого приложения, "
"скомпилированного с использованием одного и того же компилятора (:ref:"
"`native formats<struct-native-formats>`) и обмен данными между приложениями "
"с использованием согласованного формата данных (:ref:`standard "
"formats<struct-standard-formats>`). Вообще говоря, строки формата, созданные "
"для этих двух доменов, различны."

#: ../../library/struct.rst:472
msgid "Native Formats"
msgstr "Родные форматы"

#: ../../library/struct.rst:474
msgid ""
"When constructing format strings which mimic native layouts, the compiler "
"and machine architecture determine byte ordering and padding. In such cases, "
"the ``@`` format character should be used to specify native byte ordering "
"and data sizes.  Internal pad bytes are normally inserted automatically.  It "
"is possible that a zero-repeat format code will be needed at the end of a "
"format string to round up to the correct byte boundary for proper alignment "
"of consecutive chunks of data."
msgstr ""
"При создании строк формата, имитирующих собственные макеты, компилятор и "
"архитектура машины определяют порядок и заполнение байтов. В таких случаях "
"для указания собственного порядка байтов и размеров данных следует "
"использовать символ формата ``@``. Внутренние байты заполнения обычно "
"вставляются автоматически. Возможно, что код формата с нулевым повторением "
"потребуется в конце строки формата для округления до правильной границы "
"байта и правильного выравнивания последовательных фрагментов данных."

#: ../../library/struct.rst:482
msgid ""
"Consider these two simple examples (on a 64-bit, little-endian machine)::"
msgstr ""
"Рассмотрим эти два простых примера (на 64-битной машине с прямым порядком "
"байтов):"

#: ../../library/struct.rst:485
msgid ""
">>> calcsize('@lhl')\n"
"24\n"
">>> calcsize('@llh')\n"
"18"
msgstr ""
">>> calcsize('@lhl')\n"
"24\n"
">>> calcsize('@llh')\n"
"18"

#: ../../library/struct.rst:490
msgid ""
"Data is not padded to an 8-byte boundary at the end of the second format "
"string without the use of extra padding.  A zero-repeat format code solves "
"that problem::"
msgstr ""
"Данные не дополняются до 8-байтовой границы в конце второй строки формата "
"без использования дополнительного заполнения. Код формата с нулевым "
"повторением решает эту проблему:"

#: ../../library/struct.rst:494
msgid ""
">>> calcsize('@llh0l')\n"
"24"
msgstr ""
">>> calcsize('@llh0l')\n"
"24"

#: ../../library/struct.rst:497
msgid ""
"The ``'x'`` format code can be used to specify the repeat, but for native "
"formats it is better to use a zero-repeat format like ``'0l'``."
msgstr ""
"Код формата ``'x'`` может использоваться для указания повторения, но для "
"собственных форматов лучше использовать формат с нулевым повторением, "
"например ``'0l'``."

#: ../../library/struct.rst:500
msgid ""
"By default, native byte ordering and alignment is used, but it is better to "
"be explicit and use the ``'@'`` prefix character."
msgstr ""
"По умолчанию используется собственный порядок и выравнивание байтов, но "
"лучше указать явно и использовать префиксный символ ``'@'``."

#: ../../library/struct.rst:507
msgid "Standard Formats"
msgstr "Стандартные форматы"

#: ../../library/struct.rst:509
msgid ""
"When exchanging data beyond your process such as networking or storage, be "
"precise.  Specify the exact byte order, size, and alignment.  Do not assume "
"they match the native order of a particular machine. For example, network "
"byte order is big-endian, while many popular CPUs are little-endian.  By "
"defining this explicitly, the user need not care about the specifics of the "
"platform their code is running on. The first character should typically be "
"``<`` or ``>`` (or ``!``).  Padding is the responsibility of the "
"programmer.  The zero-repeat format character won't work.  Instead, the user "
"must explicitly add ``'x'`` pad bytes where needed.  Revisiting the examples "
"from the previous section, we have::"
msgstr ""
"При обмене данными, выходящим за рамки вашего процесса, например, сети или "
"хранилища, будьте точны. Укажите точный порядок байтов, размер и "
"выравнивание. Не думайте, что они соответствуют исходному порядку конкретной "
"машины. Например, порядок байтов в сети — обратный порядок байтов, тогда как "
"у многих популярных процессоров — прямой порядок байтов. Определив это явно, "
"пользователю не нужно беспокоиться о специфике платформы, на которой "
"работает его код. Первым символом обычно должен быть ``<`` или ``>`` (или ``!"
"``). Заполнение является обязанностью программиста. Символ формата с нулевым "
"повтором не будет работать. Вместо этого пользователь должен явно добавить x "
"байтов заполнения там, где это необходимо. Возвращаясь к примерам из "
"предыдущего раздела, мы имеем:"

#: ../../library/struct.rst:521
msgid ""
">>> calcsize('<qh6xq')\n"
"24\n"
">>> pack('<qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)\n"
"True\n"
">>> calcsize('@llh')\n"
"18\n"
">>> pack('@llh', 1, 2, 3) == pack('<qqh', 1, 2, 3)\n"
"True\n"
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"24\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"True"
msgstr ""
">>> calcsize('<qh6xq')\n"
"24\n"
">>> pack('<qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)\n"
"True\n"
">>> calcsize('@llh')\n"
"18\n"
">>> pack('@llh', 1, 2, 3) == pack('<qqh', 1, 2, 3)\n"
"True\n"
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"24\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"True"

#: ../../library/struct.rst:536
msgid ""
"The above results (executed on a 64-bit machine) aren't guaranteed to match "
"when executed on different machines.  For example, the examples below were "
"executed on a 32-bit machine::"
msgstr ""
"Приведенные выше результаты (выполненные на 64-разрядной машине) не "
"гарантируют совпадение при выполнении на разных машинах. Например, "
"приведенные ниже примеры были выполнены на 32-битной машине:"

#: ../../library/struct.rst:540
msgid ""
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"12\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"False"
msgstr ""
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"12\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"False"

#: ../../library/struct.rst:551
msgid "Classes"
msgstr "Классы"

#: ../../library/struct.rst:553
msgid "The :mod:`struct` module also defines the following type:"
msgstr "Модуль :mod:`struct` также определяет следующий тип:"

#: ../../library/struct.rst:558
msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a ``Struct`` object once and calling "
"its methods is more efficient than calling module-level functions with the "
"same format since the format string is only compiled once."
msgstr ""
"Возвращает новый объект Struct, который записывает и считывает двоичные "
"данные в соответствии со строкой формата *format*. Создание объекта Struct "
"один раз и вызов его методов более эффективно, чем вызов функций уровня "
"модуля с тем же форматом, поскольку строка формата компилируется только один "
"раз."

#: ../../library/struct.rst:565
msgid ""
"The compiled versions of the most recent format strings passed to the module-"
"level functions are cached, so programs that use only a few format strings "
"needn't worry about reusing a single :class:`Struct` instance."
msgstr ""
"Скомпилированные версии самых последних строк формата, переданных функциям "
"уровня модуля, кэшируются, поэтому программам, которые используют только "
"несколько строк формата, не нужно беспокоиться о повторном использовании "
"одного экземпляра :class:`Struct`."

#: ../../library/struct.rst:570
msgid "Compiled Struct objects support the following methods and attributes:"
msgstr ""
"Скомпилированные объекты Struct поддерживают следующие методы и атрибуты:"

#: ../../library/struct.rst:574
msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`size`.)"
msgstr ""
"Идентичен функции :func:`pack`, использует скомпилированный формат. "
"(``len(result)`` будет равен :attr:`size`.)"

#: ../../library/struct.rst:580
msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""
"Идентичен функции :func:`pack_into`, использует скомпилированный формат."

#: ../../library/struct.rst:585
msgid ""
"Identical to the :func:`unpack` function, using the compiled format. The "
"buffer's size in bytes must equal :attr:`size`."
msgstr ""
"Идентичен функции :func:`unpack`, использует скомпилированный формат. Размер "
"буфера в байтах должен быть равен :attr:`size`."

#: ../../library/struct.rst:591
msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"The buffer's size in bytes, starting at position *offset*, must be at least :"
"attr:`size`."
msgstr ""
"Идентичен функции :func:`unpack_from`, использует скомпилированный формат. "
"Размер буфера в байтах, начиная с позиции *offset*, должен быть не менее :"
"attr:`size`."

#: ../../library/struct.rst:598
msgid ""
"Identical to the :func:`iter_unpack` function, using the compiled format. "
"The buffer's size in bytes must be a multiple of :attr:`size`."
msgstr ""
"Идентичен функции :func:`iter_unpack`, использует скомпилированный формат. "
"Размер буфера в байтах должен быть кратен :attr:`size`."

#: ../../library/struct.rst:605
msgid "The format string used to construct this Struct object."
msgstr "Строка формата, используемая для создания этого объекта Struct."

#: ../../library/struct.rst:607
msgid "The format string type is now :class:`str` instead of :class:`bytes`."
msgstr "Тип строки формата теперь :class:`str` вместо :class:`bytes`."

#: ../../library/struct.rst:612
msgid ""
"The calculated size of the struct (and hence of the bytes object produced by "
"the :meth:`pack` method) corresponding to :attr:`format`."
msgstr ""
"Вычисленный размер структуры (и, следовательно, объекта байтов, созданного "
"методом :meth:`pack`), соответствующего :attr:`format`."

#: ../../library/struct.rst:9
msgid "C"
msgstr "C"

#: ../../library/struct.rst:9
msgid "structures"
msgstr "структуры"

#: ../../library/struct.rst:9
msgid "packing"
msgstr "упаковка"

#: ../../library/struct.rst:9
msgid "binary"
msgstr "бинарные"

#: ../../library/struct.rst:9
msgid "data"
msgstr "данные"

#: ../../library/struct.rst:132
msgid "@ (at)"
msgstr "@ (at)"

#: ../../library/struct.rst:132 ../../library/struct.rst:276
#: ../../library/struct.rst:363
msgid "in struct format strings"
msgstr "в строках формата структуры"

#: ../../library/struct.rst:132
msgid "= (equals)"
msgstr "= (равно)"

#: ../../library/struct.rst:132
msgid "< (less)"
msgstr "< (меньше)"

#: ../../library/struct.rst:132
msgid "> (greater)"
msgstr "> (больше)"

#: ../../library/struct.rst:132
msgid "! (exclamation)"
msgstr "! (восклицание)"

#: ../../library/struct.rst:276 ../../library/struct.rst:363
msgid "? (question mark)"
msgstr "? (знак вопроса)"
