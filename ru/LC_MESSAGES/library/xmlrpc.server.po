# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/xmlrpc.server.rst:2
msgid ":mod:`!xmlrpc.server` --- Basic XML-RPC servers"
msgstr ":mod:`!xmlrpc.server` --- Базовые серверы XML-RPC"

#: ../../library/xmlrpc.server.rst:10
msgid "**Source code:** :source:`Lib/xmlrpc/server.py`"
msgstr "**Исходный код:** :source:`Lib/xmlrpc/server.py`"

#: ../../library/xmlrpc.server.rst:14
msgid ""
"The :mod:`xmlrpc.server` module provides a basic server framework for XML-"
"RPC servers written in Python.  Servers can either be free standing, using :"
"class:`SimpleXMLRPCServer`, or embedded in a CGI environment, using :class:"
"`CGIXMLRPCRequestHandler`."
msgstr ""
"Модуль :mod:`xmlrpc.server` предоставляет базовую структуру для серверов XML-"
"RPC, написанную на Python. Серверы могут быть либо автономными, используя :"
"class:`SimpleXMLRPCServer`, либо встроенными в среду CGI, используя :class:"
"`CGIXMLRPCRequestHandler`."

#: ../../library/xmlrpc.server.rst:22
msgid ""
"The :mod:`xmlrpc.server` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""
"Модуль :mod:`xmlrpc.server` не защищен от вредоносно созданных данных. Если "
"вам нужно проанализировать ненадежные или неаутентифицированные данные, см. :"
"ref:`xml-vulnerabilities`."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Доступность"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Этот модуль не работает или недоступен на платформах WebAssembly «wasm32-"
"emscripten» и «wasm32-wasi». См. :ref:`wasm-availability` для получения "
"дополнительной информации."

#: ../../library/xmlrpc.server.rst:32
msgid ""
"Create a new server instance.  This class provides methods for registration "
"of functions that can be called by the XML-RPC protocol.  The "
"*requestHandler* parameter should be a factory for request handler "
"instances; it defaults to :class:`SimpleXMLRPCRequestHandler`.  The *addr* "
"and *requestHandler* parameters are passed to the :class:`socketserver."
"TCPServer` constructor.  If *logRequests* is true (the default), requests "
"will be logged; setting this parameter to false will turn off logging.   The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client` "
"and control the XML-RPC responses that will be returned from the server. The "
"*bind_and_activate* parameter controls whether :meth:`server_bind` and :meth:"
"`server_activate` are called immediately by the constructor; it defaults to "
"true. Setting it to false allows code to manipulate the "
"*allow_reuse_address* class variable before the address is bound. The "
"*use_builtin_types* parameter is passed to the :func:`~xmlrpc.client.loads` "
"function and controls which types are processed when date/times values or "
"binary data are received; it defaults to false."
msgstr ""
"Создайте новый экземпляр сервера. Этот класс предоставляет методы для "
"регистрации функций, которые могут вызываться по протоколу XML-RPC. Параметр "
"*requestHandler* должен быть фабрикой для экземпляров обработчика запросов; "
"по умолчанию это :class:`SimpleXMLRPCRequestHandler`. Параметры *addr* и "
"*requestHandler* передаются конструктору :class:`socketserver.TCPServer`. "
"Если *logRequests* имеет значение true (по умолчанию), запросы будут "
"регистрироваться; установка для этого параметра значения false отключит "
"ведение журнала. Параметры *allow_none* и *encoding* передаются в :mod:"
"`xmlrpc.client` и управляют ответами XML-RPC, которые будут возвращены с "
"сервера. Параметр *bind_and_activate* определяет, будут ли :meth:"
"`server_bind` и :meth:`server_activate` вызываться конструктором немедленно; "
"по умолчанию это правда. Установка значения false позволяет коду "
"манипулировать переменной класса *allow_reuse_address* до привязки адреса. "
"Параметр *use_builtin_types* передается в функцию :func:`~xmlrpc.client."
"loads` и контролирует, какие типы обрабатываются при получении значений даты/"
"времени или двоичных данных; по умолчанию оно имеет значение false."

#: ../../library/xmlrpc.server.rst:48 ../../library/xmlrpc.server.rst:62
#: ../../library/xmlrpc.server.rst:374
msgid "The *use_builtin_types* flag was added."
msgstr "Был добавлен флаг *use_builtin_types*."

#: ../../library/xmlrpc.server.rst:55
msgid ""
"Create a new instance to handle XML-RPC requests in a CGI environment.  The "
"*allow_none* and *encoding* parameters are passed on to :mod:`xmlrpc.client` "
"and control the XML-RPC responses that will be returned from the server. The "
"*use_builtin_types* parameter is passed to the :func:`~xmlrpc.client.loads` "
"function and controls which types are processed when date/times values or "
"binary data are received; it defaults to false."
msgstr ""
"Создайте новый экземпляр для обработки запросов XML-RPC в среде CGI. "
"Параметры *allow_none* и *encoding* передаются в :mod:`xmlrpc.client` и "
"управляют ответами XML-RPC, которые будут возвращены с сервера. Параметр "
"*use_builtin_types* передается в функцию :func:`~xmlrpc.client.loads` и "
"контролирует, какие типы обрабатываются при получении значений даты/времени "
"или двоичных данных; по умолчанию оно имеет значение false."

#: ../../library/xmlrpc.server.rst:68
msgid ""
"Create a new request handler instance.  This request handler supports "
"``POST`` requests and modifies logging so that the *logRequests* parameter "
"to the :class:`SimpleXMLRPCServer` constructor parameter is honored."
msgstr ""
"Создайте новый экземпляр обработчика запросов. Этот обработчик запросов "
"поддерживает запросы ``POST`` и изменяет журналирование, чтобы учитывался "
"параметр *logRequests* параметра конструктора :class:`SimpleXMLRPCServer`."

#: ../../library/xmlrpc.server.rst:76
msgid "SimpleXMLRPCServer Objects"
msgstr "Объекты SimpleXMLRPCServer"

#: ../../library/xmlrpc.server.rst:78
msgid ""
"The :class:`SimpleXMLRPCServer` class is based on :class:`socketserver."
"TCPServer` and provides a means of creating simple, stand alone XML-RPC "
"servers."
msgstr ""
"Класс :class:`SimpleXMLRPCServer` основан на :class:`socketserver.TCPServer` "
"и предоставляет средства создания простых, автономных серверов XML-RPC."

#: ../../library/xmlrpc.server.rst:85 ../../library/xmlrpc.server.rst:299
msgid ""
"Register a function that can respond to XML-RPC requests.  If *name* is "
"given, it will be the method name associated with *function*, otherwise :"
"attr:`function.__name__` will be used.  *name* is a string, and may contain "
"characters not legal in Python identifiers, including the period character."
msgstr ""
"Зарегистрируйте функцию, которая может отвечать на запросы XML-RPC. Если "
"указано *name*, это будет имя метода, связанное с *function*, в противном "
"случае будет использоваться :attr:`function.__name__`. *name* — это строка, "
"которая может содержать символы, недопустимые в идентификаторах Python, "
"включая символ точки."

#: ../../library/xmlrpc.server.rst:90 ../../library/xmlrpc.server.rst:304
msgid ""
"This method can also be used as a decorator.  When used as a decorator, "
"*name* can only be given as a keyword argument to register *function* under "
"*name*.  If no *name* is given, :attr:`function.__name__` will be used."
msgstr ""
"Этот метод также можно использовать в качестве декоратора. При использовании "
"в качестве декоратора *name* можно указывать только в качестве аргумента "
"ключевого слова для регистрации *функции* под *name*. Если *name* не "
"указано, будет использоваться :attr:`function.__name__`."

#: ../../library/xmlrpc.server.rst:94 ../../library/xmlrpc.server.rst:308
msgid ":meth:`register_function` can be used as a decorator."
msgstr ":meth:`register_function` можно использовать в качестве декоратора."

#: ../../library/xmlrpc.server.rst:100
msgid ""
"Register an object which is used to expose method names which have not been "
"registered using :meth:`register_function`.  If *instance* contains a :meth:"
"`_dispatch` method, it is called with the requested method name and the "
"parameters from the request.  Its API is ``def _dispatch(self, method, "
"params)`` (note that *params* does not represent a variable argument list).  "
"If it calls an underlying function to perform its task, that function is "
"called as ``func(*params)``, expanding the parameter list. The return value "
"from :meth:`_dispatch` is returned to the client as the result.  If "
"*instance* does not have a :meth:`_dispatch` method, it is searched for an "
"attribute matching the name of the requested method."
msgstr ""
"Зарегистрируйте объект, который используется для предоставления имен "
"методов, которые не были зарегистрированы, с помощью :meth:"
"`register_function`. Если *instance* содержит метод :meth:`_dispatch`, он "
"вызывается с запрошенным именем метода и параметрами из запроса. Его API — "
"``def _dispatch(self, Method, params)`` (обратите внимание, что *params* не "
"представляет собой список переменных аргументов). Если для выполнения своей "
"задачи он вызывает базовую функцию, эта функция называется "
"``func(*params)``, расширяя список параметров. Возвращаемое значение из :"
"meth:`_dispatch` возвращается клиенту в качестве результата. Если *instance* "
"не имеет метода :meth:`_dispatch`, он ищет атрибут, соответствующий имени "
"запрошенного метода."

#: ../../library/xmlrpc.server.rst:111
msgid ""
"If the optional *allow_dotted_names* argument is true and the instance does "
"not have a :meth:`_dispatch` method, then if the requested method name "
"contains periods, each component of the method name is searched for "
"individually, with the effect that a simple hierarchical search is "
"performed.  The value found from this search is then called with the "
"parameters from the request, and the return value is passed back to the "
"client."
msgstr ""
"Если необязательный аргумент *allow_dotted_names* имеет значение true и "
"экземпляр не имеет метода :meth:`_dispatch`, то если запрошенное имя метода "
"содержит точки, каждый компонент имени метода ищется индивидуально, в "
"результате чего простой осуществляется иерархический поиск. Затем значение, "
"найденное в результате этого поиска, вызывается с параметрами запроса, а "
"возвращаемое значение передается обратно клиенту."

#: ../../library/xmlrpc.server.rst:120
msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this option on a secure, closed network."
msgstr ""
"Включение опции *allow_dotted_names* позволяет злоумышленникам получить "
"доступ к глобальным переменным вашего модуля и может позволить "
"злоумышленникам выполнить произвольный код на вашем компьютере. Используйте "
"эту опцию только в защищенной закрытой сети."

#: ../../library/xmlrpc.server.rst:127
msgid ""
"Registers the XML-RPC introspection functions ``system.listMethods``, "
"``system.methodHelp`` and ``system.methodSignature``."
msgstr ""
"Регистрирует функции самоанализа XML-RPC ``system.listMethods``, ``system."
"methodHelp`` и ``system.methodSignature``."

#: ../../library/xmlrpc.server.rst:133
msgid "Registers the XML-RPC multicall function system.multicall."
msgstr "Регистрирует функцию множественного вызова XML-RPC system.multicall."

#: ../../library/xmlrpc.server.rst:138
msgid ""
"An attribute value that must be a tuple listing valid path portions of the "
"URL for receiving XML-RPC requests.  Requests posted to other paths will "
"result in a 404 \"no such page\" HTTP error.  If this tuple is empty, all "
"paths will be considered valid. The default value is ``('/', '/RPC2')``."
msgstr ""
"Значение атрибута, которое должно представлять собой кортеж, в котором "
"перечислены допустимые части пути URL-адреса для получения запросов XML-RPC. "
"Запросы, отправленные по другим путям, приведут к ошибке HTTP 404 «нет такой "
"страницы». Если этот кортеж пуст, все пути будут считаться действительными. "
"Значение по умолчанию — ``('/', '/RPC2')``."

#: ../../library/xmlrpc.server.rst:147
msgid "SimpleXMLRPCServer Example"
msgstr "Пример SimpleXMLRPCServer"

#: ../../library/xmlrpc.server.rst:148
msgid "Server code::"
msgstr "Код сервера::"

#: ../../library/xmlrpc.server.rst:150
msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"# Restrict to a particular path.\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"# Create server\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"    server.register_function(adder_function, 'add')\n"
"\n"
"    # Register an instance; all the methods of the instance are\n"
"    # published as XML-RPC methods (in this case, just 'mul').\n"
"    class MyFuncs:\n"
"        def mul(self, x, y):\n"
"            return x * y\n"
"\n"
"    server.register_instance(MyFuncs())\n"
"\n"
"    # Run the server's main loop\n"
"    server.serve_forever()"

#: ../../library/xmlrpc.server.rst:182
msgid ""
"The following client code will call the methods made available by the "
"preceding server::"
msgstr ""
"Следующий клиентский код вызовет методы, доступные на предыдущем сервере:"

#: ../../library/xmlrpc.server.rst:185
msgid ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"
msgstr ""
"import xmlrpc.client\n"
"\n"
"s = xmlrpc.client.ServerProxy('http://localhost:8000')\n"
"print(s.pow(2,3))  # Returns 2**3 = 8\n"
"print(s.add(2,3))  # Returns 5\n"
"print(s.mul(5,2))  # Returns 5*2 = 10\n"
"\n"
"# Print list of available methods\n"
"print(s.system.listMethods())"

#: ../../library/xmlrpc.server.rst:195
msgid ""
":meth:`register_function` can also be used as a decorator. The previous "
"server example can register functions in a decorator way::"
msgstr ""
":meth:`register_function` также можно использовать в качестве декоратора. "
"Предыдущий пример сервера может регистрировать функции с помощью декоратора:"

#: ../../library/xmlrpc.server.rst:198
msgid ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"
msgstr ""
"from xmlrpc.server import SimpleXMLRPCServer\n"
"from xmlrpc.server import SimpleXMLRPCRequestHandler\n"
"\n"
"class RequestHandler(SimpleXMLRPCRequestHandler):\n"
"    rpc_paths = ('/RPC2',)\n"
"\n"
"with SimpleXMLRPCServer(('localhost', 8000),\n"
"                        requestHandler=RequestHandler) as server:\n"
"    server.register_introspection_functions()\n"
"\n"
"    # Register pow() function; this will use the value of\n"
"    # pow.__name__ as the name, which is just 'pow'.\n"
"    server.register_function(pow)\n"
"\n"
"    # Register a function under a different name, using\n"
"    # register_function as a decorator. *name* can only be given\n"
"    # as a keyword argument.\n"
"    @server.register_function(name='add')\n"
"    def adder_function(x, y):\n"
"        return x + y\n"
"\n"
"    # Register a function under function.__name__.\n"
"    @server.register_function\n"
"    def mul(x, y):\n"
"        return x * y\n"
"\n"
"    server.serve_forever()"

#: ../../library/xmlrpc.server.rst:226
msgid ""
"The following example included in the :file:`Lib/xmlrpc/server.py` module "
"shows a server allowing dotted names and registering a multicall function."
msgstr ""
"Следующий пример, включенный в модуль :file:`Lib/xmlrpc/server.py`, "
"показывает сервер, допускающий использование точечных имен и регистрирующий "
"функцию множественного вызова."

#: ../../library/xmlrpc.server.rst:231
msgid ""
"Enabling the *allow_dotted_names* option allows intruders to access your "
"module's global variables and may allow intruders to execute arbitrary code "
"on your machine.  Only use this example only within a secure, closed network."
msgstr ""
"Включение опции *allow_dotted_names* позволяет злоумышленникам получить "
"доступ к глобальным переменным вашего модуля и может позволить "
"злоумышленникам выполнить произвольный код на вашем компьютере. Используйте "
"этот пример только в безопасной закрытой сети."

#: ../../library/xmlrpc.server.rst:237
msgid ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"
msgstr ""
"import datetime\n"
"\n"
"class ExampleService:\n"
"    def getData(self):\n"
"        return '42'\n"
"\n"
"    class currentTime:\n"
"        @staticmethod\n"
"        def getCurrentTime():\n"
"            return datetime.datetime.now()\n"
"\n"
"with SimpleXMLRPCServer((\"localhost\", 8000)) as server:\n"
"    server.register_function(pow)\n"
"    server.register_function(lambda x,y: x+y, 'add')\n"
"    server.register_instance(ExampleService(), allow_dotted_names=True)\n"
"    server.register_multicall_functions()\n"
"    print('Serving XML-RPC on localhost port 8000')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        print(\"\\nKeyboard interrupt received, exiting.\")\n"
"        sys.exit(0)"

#: ../../library/xmlrpc.server.rst:260
msgid "This ExampleService demo can be invoked from the command line::"
msgstr "Демо-версию SampleService можно вызвать из командной строки:"

#: ../../library/xmlrpc.server.rst:262
msgid "python -m xmlrpc.server"
msgstr "python -m xmlrpc.server"

#: ../../library/xmlrpc.server.rst:265
msgid ""
"The client that interacts with the above server is included in ``Lib/xmlrpc/"
"client.py``::"
msgstr ""
"Клиент, который взаимодействует с вышеуказанным сервером, включен в ``Lib/"
"xmlrpc/client.py``::"

#: ../../library/xmlrpc.server.rst:268
msgid ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"
msgstr ""
"server = ServerProxy(\"http://localhost:8000\")\n"
"\n"
"try:\n"
"    print(server.currentTime.getCurrentTime())\n"
"except Error as v:\n"
"    print(\"ERROR\", v)\n"
"\n"
"multi = MultiCall(server)\n"
"multi.getData()\n"
"multi.pow(2,9)\n"
"multi.add(1,2)\n"
"try:\n"
"    for response in multi():\n"
"        print(response)\n"
"except Error as v:\n"
"    print(\"ERROR\", v)"

#: ../../library/xmlrpc.server.rst:285
msgid ""
"This client which interacts with the demo XMLRPC server can be invoked as::"
msgstr ""
"Этот клиент, который взаимодействует с демонстрационным XMLRPC-сервером, "
"может быть вызван как:"

#: ../../library/xmlrpc.server.rst:287
msgid "python -m xmlrpc.client"
msgstr "python -m xmlrpc.client"

#: ../../library/xmlrpc.server.rst:291
msgid "CGIXMLRPCRequestHandler"
msgstr "CGIXMLRPCRequestHandler"

#: ../../library/xmlrpc.server.rst:293
msgid ""
"The :class:`CGIXMLRPCRequestHandler` class can be used to handle XML-RPC "
"requests sent to Python CGI scripts."
msgstr ""
"Класс :class:`CGIXMLRPCRequestHandler` может использоваться для обработки "
"запросов XML-RPC, отправленных в CGI-скрипты Python."

#: ../../library/xmlrpc.server.rst:314
msgid ""
"Register an object which is used to expose method names  which have not been "
"registered using :meth:`register_function`. If  instance contains a :meth:"
"`_dispatch` method, it is called with the  requested method name and the "
"parameters from the  request; the return value is returned to the client as "
"the result. If instance does not have a :meth:`_dispatch` method, it is "
"searched for an attribute matching the name of the requested method; if  the "
"requested method name contains periods, each  component of the method name "
"is searched for individually,  with the effect that a simple hierarchical "
"search is performed. The value found from this search is then called with "
"the  parameters from the request, and the return value is passed  back to "
"the client."
msgstr ""
"Зарегистрируйте объект, который используется для предоставления имен "
"методов, которые не были зарегистрированы, с помощью :meth:"
"`register_function`. Если экземпляр содержит метод :meth:`_dispatch`, он "
"вызывается с использованием запрошенного имени метода и параметров из "
"запроса; возвращаемое значение возвращается клиенту в качестве результата. "
"Если экземпляр не имеет метода :meth:`_dispatch`, он ищет атрибут, "
"соответствующий имени запрошенного метода; если запрошенное имя метода "
"содержит точки, каждый компонент имени метода ищется индивидуально, в "
"результате чего выполняется простой иерархический поиск. Затем значение, "
"найденное в результате этого поиска, вызывается с параметрами запроса, а "
"возвращаемое значение передается обратно клиенту."

#: ../../library/xmlrpc.server.rst:328
msgid ""
"Register the XML-RPC introspection functions  ``system.listMethods``, "
"``system.methodHelp`` and  ``system.methodSignature``."
msgstr ""
"Зарегистрируйте функции самоанализа XML-RPC ``system.listMethods``, ``system."
"methodHelp`` и ``system.methodSignature``."

#: ../../library/xmlrpc.server.rst:334
msgid "Register the XML-RPC multicall function ``system.multicall``."
msgstr "Зарегистрируйте функцию многовызова XML-RPC ``system.multicall``."

#: ../../library/xmlrpc.server.rst:339
msgid ""
"Handle an XML-RPC request. If *request_text* is given, it should be the POST "
"data provided by the HTTP server,  otherwise the contents of stdin will be "
"used."
msgstr ""
"Обработка запроса XML-RPC. Если указан *request_text*, это должны быть "
"данные POST, предоставленные HTTP-сервером, в противном случае будет "
"использоваться содержимое стандартного ввода."

#: ../../library/xmlrpc.server.rst:342
msgid "Example::"
msgstr "Пример::"

#: ../../library/xmlrpc.server.rst:344
msgid ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"
msgstr ""
"class MyFuncs:\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"\n"
"handler = CGIXMLRPCRequestHandler()\n"
"handler.register_function(pow)\n"
"handler.register_function(lambda x,y: x+y, 'add')\n"
"handler.register_introspection_functions()\n"
"handler.register_instance(MyFuncs())\n"
"handler.handle_request()"

#: ../../library/xmlrpc.server.rst:358
msgid "Documenting XMLRPC server"
msgstr "Документирование сервера XMLRPC"

#: ../../library/xmlrpc.server.rst:360
msgid ""
"These classes extend the above classes to serve HTML documentation in "
"response to HTTP GET requests.  Servers can either be free standing, using :"
"class:`DocXMLRPCServer`, or embedded in a CGI environment, using :class:"
"`DocCGIXMLRPCRequestHandler`."
msgstr ""
"Эти классы расширяют вышеуказанные классы для предоставления HTML-"
"документации в ответ на запросы HTTP GET. Серверы могут быть либо "
"автономными, используя :class:`DocXMLRPCServer`, либо встроенными в среду "
"CGI, используя :class:`DocCGIXMLRPCRequestHandler`."

#: ../../library/xmlrpc.server.rst:370
msgid ""
"Create a new server instance. All parameters have the same meaning as for :"
"class:`SimpleXMLRPCServer`; *requestHandler* defaults to :class:"
"`DocXMLRPCRequestHandler`."
msgstr ""
"Создайте новый экземпляр сервера. Все параметры имеют то же значение, что и "
"для :class:`SimpleXMLRPCServer`; *requestHandler* по умолчанию имеет "
"значение :class:`DocXMLRPCRequestHandler`."

#: ../../library/xmlrpc.server.rst:380
msgid "Create a new instance to handle XML-RPC requests in a CGI environment."
msgstr "Создайте новый экземпляр для обработки запросов XML-RPC в среде CGI."

#: ../../library/xmlrpc.server.rst:385
msgid ""
"Create a new request handler instance. This request handler supports XML-RPC "
"POST requests, documentation GET requests, and modifies logging so that the "
"*logRequests* parameter to the :class:`DocXMLRPCServer` constructor "
"parameter is honored."
msgstr ""
"Создайте новый экземпляр обработчика запросов. Этот обработчик запросов "
"поддерживает POST-запросы XML-RPC, GET-запросы документации и изменяет "
"ведение журнала, чтобы учитывался параметр *logRequests* в параметре "
"конструктора :class:`DocXMLRPCServer`."

#: ../../library/xmlrpc.server.rst:394
msgid "DocXMLRPCServer Objects"
msgstr "Объекты DocXMLRPCServer"

#: ../../library/xmlrpc.server.rst:396
msgid ""
"The :class:`DocXMLRPCServer` class is derived from :class:"
"`SimpleXMLRPCServer` and provides a means of creating self-documenting, "
"stand alone XML-RPC servers. HTTP POST requests are handled as XML-RPC "
"method calls. HTTP GET requests are handled by generating pydoc-style HTML "
"documentation. This allows a server to provide its own web-based "
"documentation."
msgstr ""
"Класс :class:`DocXMLRPCServer` является производным от :class:"
"`SimpleXMLRPCServer` и предоставляет средства создания самодокументируемых "
"автономных серверов XML-RPC. Запросы HTTP POST обрабатываются как вызовы "
"методов XML-RPC. Запросы HTTP GET обрабатываются путем создания HTML-"
"документации в стиле pydoc. Это позволяет серверу предоставлять собственную "
"веб-документацию."

#: ../../library/xmlrpc.server.rst:405 ../../library/xmlrpc.server.rst:433
msgid ""
"Set the title used in the generated HTML documentation. This title will be "
"used inside the HTML \"title\" element."
msgstr ""
"Установите заголовок, используемый в сгенерированной HTML-документации. Этот "
"заголовок будет использоваться внутри HTML-элемента title."

#: ../../library/xmlrpc.server.rst:411 ../../library/xmlrpc.server.rst:439
msgid ""
"Set the name used in the generated HTML documentation. This name will appear "
"at the top of the generated documentation inside a \"h1\" element."
msgstr ""
"Задайте имя, используемое в сгенерированной HTML-документации. Это имя "
"появится вверху созданной документации внутри элемента «h1»."

#: ../../library/xmlrpc.server.rst:417 ../../library/xmlrpc.server.rst:445
msgid ""
"Set the description used in the generated HTML documentation. This "
"description will appear as a paragraph, below the server name, in the "
"documentation."
msgstr ""
"Установите описание, используемое в сгенерированной HTML-документации. Это "
"описание появится в документации в виде абзаца под именем сервера."

#: ../../library/xmlrpc.server.rst:422
msgid "DocCGIXMLRPCRequestHandler"
msgstr "DocCGIXMLRPCRequestHandler"

#: ../../library/xmlrpc.server.rst:424
msgid ""
"The :class:`DocCGIXMLRPCRequestHandler` class is derived from :class:"
"`CGIXMLRPCRequestHandler` and provides a means of creating self-documenting, "
"XML-RPC CGI scripts. HTTP POST requests are handled as XML-RPC method calls. "
"HTTP GET requests are handled by generating pydoc-style HTML documentation. "
"This allows a server to provide its own web-based documentation."
msgstr ""
"Класс :class:`DocCGIXMLRPCRequestHandler` является производным от :class:"
"`CGIXMLRPCRequestHandler` и предоставляет средства создания "
"самодокументируемых XML-RPC CGI-скриптов. Запросы HTTP POST обрабатываются "
"как вызовы методов XML-RPC. Запросы HTTP GET обрабатываются путем создания "
"HTML-документации в стиле pydoc. Это позволяет серверу предоставлять "
"собственную веб-документацию."
