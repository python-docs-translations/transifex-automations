# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/chunk.rst:2
msgid ":mod:`chunk` --- Read IFF chunked data"
msgstr ":mod:`chunk` --- Чтение фрагментированных данных IFF"

#: ../../library/chunk.rst:11
msgid "**Source code:** :source:`Lib/chunk.py`"
msgstr "**Исходный код:** :source:`Lib/chunk.py`"

#: ../../library/chunk.rst:20
msgid ""
"The :mod:`chunk` module is deprecated (see :pep:`PEP 594 <594#chunk>` for "
"details)."
msgstr ""
"Модуль :mod:`chunk` устарел (подробности см. в :pep:`PEP 594 <594#chunk>`)."

#: ../../library/chunk.rst:26
msgid ""
"This module provides an interface for reading files that use EA IFF 85 "
"chunks. [#]_  This format is used in at least the Audio Interchange File "
"Format (AIFF/AIFF-C) and the Real Media File Format (RMFF).  The WAVE audio "
"file format is closely related and can also be read using this module."
msgstr ""
"Этот модуль предоставляет интерфейс для чтения файлов, использующих "
"фрагменты EA IFF 85. [#]_ Этот формат используется, по крайней мере, в "
"формате файла аудиообмена (AIFF/AIFF-C) и формате реального мультимедийного "
"файла (RMFF). Формат аудиофайлов WAVE тесно связан с ним, и его также можно "
"прочитать с помощью этого модуля."

#: ../../library/chunk.rst:31
msgid "A chunk has the following structure:"
msgstr "Блок имеет следующую структуру:"

#: ../../library/chunk.rst:34
msgid "Offset"
msgstr "Смещение"

#: ../../library/chunk.rst:34
msgid "Length"
msgstr "Длина"

#: ../../library/chunk.rst:34
msgid "Contents"
msgstr " Содержание"

#: ../../library/chunk.rst:36
msgid "0"
msgstr "0"

#: ../../library/chunk.rst:36 ../../library/chunk.rst:38
msgid "4"
msgstr "4"

#: ../../library/chunk.rst:36
msgid "Chunk ID"
msgstr "Идентификатор блока"

#: ../../library/chunk.rst:38
msgid "Size of chunk in big-endian byte order, not including the header"
msgstr ""
"Размер фрагмента в порядке байтов с обратным порядком байтов, не включая "
"заголовок"

#: ../../library/chunk.rst:42
msgid "8"
msgstr "8"

#: ../../library/chunk.rst:42
msgid "*n*"
msgstr "*n*"

#: ../../library/chunk.rst:42
msgid "Data bytes, where *n* is the size given in the preceding field"
msgstr "Байты данных, где *n* — размер, указанный в предыдущем поле."

#: ../../library/chunk.rst:46
msgid "8 + *n*"
msgstr "8 + *n*"

#: ../../library/chunk.rst:46
msgid "0 or 1"
msgstr "0 или 1"

#: ../../library/chunk.rst:46
msgid "Pad byte needed if *n* is odd and chunk alignment is used"
msgstr ""
"Байт заполнения необходим, если *n* нечетно и используется выравнивание "
"фрагментов."

#: ../../library/chunk.rst:50
msgid "The ID is a 4-byte string which identifies the type of chunk."
msgstr ""
"Идентификатор представляет собой 4-байтовую строку, которая идентифицирует "
"тип фрагмента."

#: ../../library/chunk.rst:52
msgid ""
"The size field (a 32-bit value, encoded using big-endian byte order) gives "
"the size of the chunk data, not including the 8-byte header."
msgstr ""
"Поле размера (32-битное значение, закодированное с использованием обратного "
"порядка байтов) дает размер данных фрагмента, не включая 8-байтовый "
"заголовок."

#: ../../library/chunk.rst:55
msgid ""
"Usually an IFF-type file consists of one or more chunks.  The proposed usage "
"of the :class:`Chunk` class defined here is to instantiate an instance at "
"the start of each chunk and read from the instance until it reaches the end, "
"after which a new instance can be instantiated. At the end of the file, "
"creating a new instance will fail with an :exc:`EOFError` exception."
msgstr ""
"Обычно файл типа IFF состоит из одного или нескольких фрагментов. "
"Предлагаемое использование определенного здесь класса :class:`Chunk` "
"заключается в создании экземпляра в начале каждого фрагмента и чтении из "
"экземпляра до тех пор, пока он не достигнет конца, после чего может быть "
"создан новый экземпляр. В конце файла создание нового экземпляра завершится "
"ошибкой с исключением :exc:`EOFError`."

#: ../../library/chunk.rst:64
msgid ""
"Class which represents a chunk.  The *file* argument is expected to be a "
"file-like object.  An instance of this class is specifically allowed.  The "
"only method that is needed is :meth:`~io.IOBase.read`.  If the methods :meth:"
"`~io.IOBase.seek` and :meth:`~io.IOBase.tell` are present and don't raise an "
"exception, they are also used. If these methods are present and raise an "
"exception, they are expected to not have altered the object.  If the "
"optional argument *align* is true, chunks are assumed to be aligned on 2-"
"byte boundaries.  If *align* is false, no alignment is assumed.  The default "
"value is true.  If the optional argument *bigendian* is false, the chunk "
"size is assumed to be in little-endian order. This is needed for WAVE audio "
"files. The default value is true.  If the optional argument *inclheader* is "
"true, the size given in the chunk header includes the size of the header.  "
"The default value is false."
msgstr ""
"Класс, представляющий фрагмент. Ожидается, что аргумент *file* будет "
"файловым объектом. Экземпляр этого класса специально разрешен. Единственный "
"необходимый метод — это :meth:`~io.IOBase.read`. Если методы :meth:`~io."
"IOBase.seek` и :meth:`~io.IOBase.tell` присутствуют и не вызывают "
"исключения, они также используются. Если эти методы присутствуют и вызывают "
"исключение, ожидается, что они не изменили объект. Если необязательный "
"аргумент *align* имеет значение true, предполагается, что фрагменты "
"выровнены по 2-байтовым границам. Если *align* имеет значение false, "
"выравнивание не предполагается. Значение по умолчанию — true. Если "
"необязательный аргумент *bigendian* имеет значение false, предполагается, "
"что размер фрагмента имеет прямой порядок байтов. Это необходимо для "
"аудиофайлов WAVE. Значение по умолчанию — true. Если необязательный аргумент "
"*inclheader* имеет значение true, размер, указанный в заголовке фрагмента, "
"включает размер заголовка. Значение по умолчанию — ложь."

#: ../../library/chunk.rst:78
msgid "A :class:`Chunk` object supports the following methods:"
msgstr "Объект :class:`Chunk` поддерживает следующие методы:"

#: ../../library/chunk.rst:83
msgid ""
"Returns the name (ID) of the chunk.  This is the first 4 bytes of the chunk."
msgstr "Возвращает имя (ID) чанка. Это первые 4 байта фрагмента."

#: ../../library/chunk.rst:89
msgid "Returns the size of the chunk."
msgstr "Возвращает размер чанка."

#: ../../library/chunk.rst:94
msgid ""
"Close and skip to the end of the chunk.  This does not close the underlying "
"file."
msgstr "Закройте и перейдите к концу фрагмента. Это не закрывает базовый файл."

#: ../../library/chunk.rst:97
msgid ""
"The remaining methods will raise :exc:`OSError` if called after the :meth:"
"`close` method has been called.  Before Python 3.3, they used to raise :exc:"
"`IOError`, now an alias of :exc:`OSError`."
msgstr ""
"Остальные методы вызовут :exc:`OSError`, если они будут вызваны после вызова "
"метода :meth:`close`. До Python 3.3 они вызывали :exc:`IOError`, теперь это "
"псевдоним :exc:`OSError`."

#: ../../library/chunk.rst:104
msgid "Returns ``False``."
msgstr "Возвращает ``Ложь``."

#: ../../library/chunk.rst:109
msgid ""
"Set the chunk's current position.  The *whence* argument is optional and "
"defaults to ``0`` (absolute file positioning); other values are ``1`` (seek "
"relative to the current position) and ``2`` (seek relative to the file's "
"end).  There is no return value. If the underlying file does not allow seek, "
"only forward seeks are allowed."
msgstr ""
"Установите текущую позицию фрагмента. Аргумент *wherece* является "
"необязательным и по умолчанию имеет значение «0» (абсолютное "
"позиционирование файла); другие значения — ``1`` (поиск относительно текущей "
"позиции) и ``2`` (поиск относительно конца файла). Возвращаемого значения "
"нет. Если базовый файл не поддерживает поиск, разрешен только прямой поиск."

#: ../../library/chunk.rst:118
msgid "Return the current position into the chunk."
msgstr "Вернуть текущую позицию в чанк."

#: ../../library/chunk.rst:123
msgid ""
"Read at most *size* bytes from the chunk (less if the read hits the end of "
"the chunk before obtaining *size* bytes).  If the *size* argument is "
"negative or omitted, read all data until the end of the chunk.  An empty "
"bytes object is returned when the end of the chunk is encountered "
"immediately."
msgstr ""
"Считайте не более *size* байт из фрагмента (меньше, если чтение достигает "
"конца фрагмента до получения *size* байт). Если аргумент *size* "
"отрицательный или опущен, считываются все данные до конца фрагмента. Объект "
"пустых байтов возвращается, когда немедленно обнаруживается конец фрагмента."

#: ../../library/chunk.rst:132
msgid ""
"Skip to the end of the chunk.  All further calls to :meth:`read` for the "
"chunk will return ``b''``.  If you are not interested in the contents of the "
"chunk, this method should be called so that the file points to the start of "
"the next chunk."
msgstr ""
"Перейдите к концу фрагмента. Все дальнейшие вызовы :meth:`read` для "
"фрагмента вернут ``b''``. Если вас не интересует содержимое чанка, этот "
"метод следует вызвать так, чтобы файл указывал на начало следующего чанка."

#: ../../library/chunk.rst:139
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/chunk.rst:140
msgid ""
"\"EA IFF 85\" Standard for Interchange Format Files, Jerry Morrison, "
"Electronic Arts, January 1985."
msgstr ""
"Стандарт «EA IFF 85» для файлов формата обмена, Джерри Моррисон, Electronic "
"Arts, январь 1985 г."
