# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 16:02+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/email.headerregistry.rst:2
msgid ":mod:`email.headerregistry`: Custom Header Objects"
msgstr ":mod:`email.headerregistry`: Объекты пользовательских заголовков"

#: ../../library/email.headerregistry.rst:10
msgid "**Source code:** :source:`Lib/email/headerregistry.py`"
msgstr "**Исходный код:** :source:`Lib/email/headerregistry.py`"

#: ../../library/email.headerregistry.rst:14
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.headerregistry.rst:16
msgid ""
"Headers are represented by customized subclasses of :class:`str`.  The "
"particular class used to represent a given header is determined by the :attr:"
"`~email.policy.EmailPolicy.header_factory` of the :mod:`~email.policy` in "
"effect when the headers are created.  This section documents the particular "
"``header_factory`` implemented by the email package for handling :RFC:`5322` "
"compliant email messages, which not only provides customized header objects "
"for various header types, but also provides an extension mechanism for "
"applications to add their own custom header types."
msgstr ""
"Заголовки представлены настраиваемыми подклассами :class:`str`. Конкретный "
"класс, используемый для представления данного заголовка, определяется :attr:"
"`~email.policy.EmailPolicy.header_factory` :mod:`~email.policy`, действующим "
"при создании заголовков. В этом разделе описывается конкретная "
"``header_factory``, реализованная в пакете электронной почты для обработки "
"сообщений электронной почты, соответствующих :RFC:`5322`, которая не только "
"предоставляет настраиваемые объекты заголовков для различных типов "
"заголовков, но также предоставляет механизм расширения, позволяющий "
"приложениям добавлять свои собственные типы заголовков."

#: ../../library/email.headerregistry.rst:25
msgid ""
"When using any of the policy objects derived from :data:`~email.policy."
"EmailPolicy`, all headers are produced by :class:`.HeaderRegistry` and have :"
"class:`.BaseHeader` as their last base class.  Each header class has an "
"additional base class that is determined by the type of the header.  For "
"example, many headers have the class :class:`.UnstructuredHeader` as their "
"other base class.  The specialized second class for a header is determined "
"by the name of the header, using a lookup table stored in the :class:`."
"HeaderRegistry`.  All of this is managed transparently for the typical "
"application program, but interfaces are provided for modifying the default "
"behavior for use by more complex applications."
msgstr ""
"При использовании любого из объектов политики, производных от :data:`~email."
"policy.EmailPolicy`, все заголовки создаются :class:`.HeaderRegistry` и "
"имеют :class:`.BaseHeader` в качестве последнего базового класса. Каждый "
"класс заголовка имеет дополнительный базовый класс, который определяется "
"типом заголовка. Например, многие заголовки имеют класс :class:`."
"UnstructuredHeader` в качестве другого базового класса. Специализированный "
"второй класс заголовка определяется именем заголовка с использованием "
"таблицы поиска, хранящейся в :class:`.HeaderRegistry`. Все это прозрачно "
"управляется для типичной прикладной программы, но предусмотрены интерфейсы "
"для изменения поведения по умолчанию для использования более сложными "
"приложениями."

#: ../../library/email.headerregistry.rst:36
msgid ""
"The sections below first document the header base classes and their "
"attributes, followed by the API for modifying the behavior of :class:`."
"HeaderRegistry`, and finally the support classes used to represent the data "
"parsed from structured headers."
msgstr ""
"В разделах ниже сначала описаны базовые классы заголовков и их атрибуты, "
"затем API для изменения поведения :class:`.HeaderRegistry` и, наконец, "
"вспомогательные классы, используемые для представления данных, анализируемых "
"из структурированных заголовков."

#: ../../library/email.headerregistry.rst:44
msgid ""
"*name* and *value* are passed to ``BaseHeader`` from the :attr:`~email."
"policy.EmailPolicy.header_factory` call.  The string value of any header "
"object is the *value* fully decoded to unicode."
msgstr ""
"*name* и *value* передаются в BaseHeader из вызова :attr:`~email.policy."
"EmailPolicy.header_factory`. Строковое значение любого объекта заголовка — "
"это *значение*, полностью декодированное в Юникод."

#: ../../library/email.headerregistry.rst:48
msgid "This base class defines the following read-only properties:"
msgstr ""
"Этот базовый класс определяет следующие свойства, доступные только для "
"чтения:"

#: ../../library/email.headerregistry.rst:53
msgid ""
"The name of the header (the portion of the field before the ':').  This is "
"exactly the value passed in the :attr:`~email.policy.EmailPolicy."
"header_factory` call for *name*; that is, case is preserved."
msgstr ""
"Имя заголовка (часть поля перед «:»). Это именно то значение, которое "
"передается в вызове :attr:`~email.policy.EmailPolicy.header_factory` для "
"*name*; то есть регистр сохраняется."

#: ../../library/email.headerregistry.rst:61
msgid ""
"A tuple of :exc:`~email.errors.HeaderDefect` instances reporting any RFC "
"compliance problems found during parsing.  The email package tries to be "
"complete about detecting compliance issues.  See the :mod:`~email.errors` "
"module for a discussion of the types of defects that may be reported."
msgstr ""
"Кортеж экземпляров :exc:`~email.errors.HeaderDefect`, сообщающих о любых "
"проблемах с соответствием RFC, обнаруженных во время анализа. Пакет "
"электронной почты пытается обеспечить полное обнаружение проблем с "
"соблюдением требований. См. модуль :mod:`~email.errors` для обсуждения типов "
"дефектов, о которых можно сообщить."

#: ../../library/email.headerregistry.rst:69
msgid ""
"The maximum number of headers of this type that can have the same ``name``.  "
"A value of ``None`` means unlimited.  The ``BaseHeader`` value for this "
"attribute is ``None``; it is expected that specialized header classes will "
"override this value as needed."
msgstr ""
"Максимальное количество заголовков этого типа, которые могут иметь одно и то "
"же имя. Значение «Нет» означает неограниченное количество. Значением "
"BaseHeader для этого атрибута является None; ожидается, что "
"специализированные классы заголовков будут переопределять это значение по "
"мере необходимости."

#: ../../library/email.headerregistry.rst:74
msgid ""
"``BaseHeader`` also provides the following method, which is called by the "
"email library code and should not in general be called by application "
"programs:"
msgstr ""
"``BaseHeader`` также предоставляет следующий метод, который вызывается кодом "
"библиотеки электронной почты и обычно не должен вызываться прикладными "
"программами:"

#: ../../library/email.headerregistry.rst:80
msgid ""
"Return a string containing :attr:`~email.policy.Policy.linesep` characters "
"as required to correctly fold the header according to *policy*.  A :attr:"
"`~email.policy.Policy.cte_type` of ``8bit`` will be treated as if it were "
"``7bit``, since headers may not contain arbitrary binary data.  If :attr:"
"`~email.policy.EmailPolicy.utf8` is ``False``, non-ASCII data will be :rfc:"
"`2047` encoded."
msgstr ""
"Возвращает строку, содержащую символы :attr:`~email.policy.Policy.linesep`, "
"необходимые для правильного свертывания заголовка в соответствии с "
"*policy*. :attr:`~email.policy.Policy.cte_type` ``8bit`` будет "
"обрабатываться так, как если бы он был ``7bit``, поскольку заголовки не "
"могут содержать произвольные двоичные данные. Если :attr:`~email.policy."
"EmailPolicy.utf8` имеет значение ``False``, данные, отличные от ASCII, будут "
"закодированы :rfc:`2047`."

#: ../../library/email.headerregistry.rst:88
msgid ""
"``BaseHeader`` by itself cannot be used to create a header object.  It "
"defines a protocol that each specialized header cooperates with in order to "
"produce the header object.  Specifically, ``BaseHeader`` requires that the "
"specialized class provide a :func:`classmethod` named ``parse``.  This "
"method is called as follows::"
msgstr ""
"``BaseHeader`` сам по себе не может использоваться для создания объекта "
"заголовка. Он определяет протокол, с которым взаимодействует каждый "
"специализированный заголовок для создания объекта заголовка. В частности, "
"BaseHeader требует, чтобы специализированный класс предоставлял метод класса "
"с именем parse. Этот метод вызывается следующим образом:"

#: ../../library/email.headerregistry.rst:96
msgid ""
"``kwds`` is a dictionary containing one pre-initialized key, ``defects``. "
"``defects`` is an empty list.  The parse method should append any detected "
"defects to this list.  On return, the ``kwds`` dictionary *must* contain "
"values for at least the keys ``decoded`` and ``defects``.  ``decoded`` "
"should be the string value for the header (that is, the header value fully "
"decoded to unicode).  The parse method should assume that *string* may "
"contain content-transfer-encoded parts, but should correctly handle all "
"valid unicode characters as well so that it can parse un-encoded header "
"values."
msgstr ""
"``kwds`` — это словарь, содержащий один предварительно инициализированный "
"ключ ``defects``. ``дефекты`` — пустой список. Метод анализа должен "
"добавлять в этот список все обнаруженные дефекты. При возврате словарь "
"``kwds`` *должен* содержать значения как минимум для ключей ``decoded`` и "
"``defects``. ``decoded`` должно быть строковым значением заголовка (то есть "
"значение заголовка, полностью декодированное в Юникод). Метод анализа должен "
"предполагать, что *string* может содержать части, закодированные при "
"передаче контента, но также должен правильно обрабатывать все допустимые "
"символы Юникода, чтобы он мог анализировать незакодированные значения "
"заголовка."

#: ../../library/email.headerregistry.rst:105
msgid ""
"``BaseHeader``'s ``__new__`` then creates the header instance, and calls its "
"``init`` method.  The specialized class only needs to provide an ``init`` "
"method if it wishes to set additional attributes beyond those provided by "
"``BaseHeader`` itself.  Such an ``init`` method should look like this::"
msgstr ""
"Затем ``__new__`` BaseHeader создает экземпляр заголовка и вызывает его "
"метод ``init``. Специализированный класс должен предоставить метод init "
"только в том случае, если он хочет установить дополнительные атрибуты помимо "
"тех, которые предоставляются самим BaseHeader. Такой метод ``init`` должен "
"выглядеть следующим образом:"

#: ../../library/email.headerregistry.rst:114
msgid ""
"That is, anything extra that the specialized class puts in to the ``kwds`` "
"dictionary should be removed and handled, and the remaining contents of "
"``kw`` (and ``args``) passed to the ``BaseHeader`` ``init`` method."
msgstr ""
"То есть все лишнее, что специализированный класс помещает в словарь "
"``kwds``, должно быть удалено и обработано, а оставшееся содержимое ``kw`` "
"(и ``args``) должно быть передано в ``BaseHeader`. ```init`` метод."

#: ../../library/email.headerregistry.rst:121
msgid ""
"An \"unstructured\" header is the default type of header in :rfc:`5322`. Any "
"header that does not have a specified syntax is treated as unstructured.  "
"The classic example of an unstructured header is the :mailheader:`Subject` "
"header."
msgstr ""
"«Неструктурированный» заголовок — это тип заголовка по умолчанию в :rfc:"
"`5322`. Любой заголовок, не имеющий определенного синтаксиса, считается "
"неструктурированным. Классическим примером неструктурированного заголовка "
"является заголовок :mailheader:`Subject`."

#: ../../library/email.headerregistry.rst:126
msgid ""
"In :rfc:`5322`, an unstructured header is a run of arbitrary text in the "
"ASCII character set.  :rfc:`2047`, however, has an :rfc:`5322` compatible "
"mechanism for encoding non-ASCII text as ASCII characters within a header "
"value.  When a *value* containing encoded words is passed to the "
"constructor, the ``UnstructuredHeader`` parser converts such encoded words "
"into unicode, following the :rfc:`2047` rules for unstructured text.  The "
"parser uses heuristics to attempt to decode certain non-compliant encoded "
"words.  Defects are registered in such cases, as well as defects for issues "
"such as invalid characters within the encoded words or the non-encoded text."
msgstr ""
"В :rfc:`5322` неструктурированный заголовок представляет собой произвольный "
"текст в наборе символов ASCII. Однако :rfc:`2047` имеет механизм, "
"совместимый с :rfc:`5322`, для кодирования текста, отличного от ASCII, как "
"символов ASCII внутри значения заголовка. Когда конструктору передается "
"*значение*, содержащее закодированные слова, анализатор UnstructuredHeader "
"преобразует такие закодированные слова в Юникод, следуя правилам :rfc:`2047` "
"для неструктурированного текста. Анализатор использует эвристику, чтобы "
"попытаться декодировать определенные несовместимые закодированные слова. В "
"таких случаях регистрируются дефекты, а также дефекты, связанные с такими "
"проблемами, как недопустимые символы в закодированных словах или "
"незакодированном тексте."

#: ../../library/email.headerregistry.rst:136
msgid "This header type provides no additional attributes."
msgstr "Этот тип заголовка не предоставляет дополнительных атрибутов."

#: ../../library/email.headerregistry.rst:141
msgid ""
":rfc:`5322` specifies a very specific format for dates within email headers. "
"The ``DateHeader`` parser recognizes that date format, as well as "
"recognizing a number of variant forms that are sometimes found \"in the "
"wild\"."
msgstr ""
":rfc:`5322` определяет очень специфический формат дат в заголовках "
"электронных писем. Анализатор DateHeader распознает этот формат даты, а "
"также распознает ряд вариантов форм, которые иногда встречаются «в дикой "
"природе»."

#: ../../library/email.headerregistry.rst:146
#: ../../library/email.headerregistry.rst:188
msgid "This header type provides the following additional attributes:"
msgstr "Этот тип заголовка предоставляет следующие дополнительные атрибуты:"

#: ../../library/email.headerregistry.rst:150
msgid ""
"If the header value can be recognized as a valid date of one form or "
"another, this attribute will contain a :class:`~datetime.datetime` instance "
"representing that date.  If the timezone of the input date is specified as "
"``-0000`` (indicating it is in UTC but contains no information about the "
"source timezone), then :attr:`.datetime` will be a naive :class:`~datetime."
"datetime`.  If a specific timezone offset is found (including ``+0000``), "
"then :attr:`.datetime` will contain an aware ``datetime`` that uses :class:"
"`datetime.timezone` to record the timezone offset."
msgstr ""
"Если значение заголовка можно распознать как допустимую дату той или иной "
"формы, этот атрибут будет содержать экземпляр :class:`~datetime.datetime`, "
"представляющий эту дату. Если часовой пояс входной даты указан как ``-0000`` "
"(указывает, что он находится в формате UTC, но не содержит информации об "
"исходном часовом поясе), то :attr:`.datetime` будет наивным :class:"
"`~datetime .датавремя`. Если обнаружено определенное смещение часового пояса "
"(включая ``+0000``), то :attr:`.datetime` будет содержать известное "
"``datetime``, которое использует :class:`datetime.timezone` для записи "
"смещения часового пояса."

#: ../../library/email.headerregistry.rst:160
msgid ""
"The ``decoded`` value of the header is determined by formatting the "
"``datetime`` according to the :rfc:`5322` rules; that is, it is set to::"
msgstr ""
"Декодированное значение заголовка определяется форматированием даты и "
"времени в соответствии с правилами :rfc:`5322`; то есть установлено::"

#: ../../library/email.headerregistry.rst:165
msgid ""
"When creating a ``DateHeader``, *value* may be :class:`~datetime.datetime` "
"instance.  This means, for example, that the following code is valid and "
"does what one would expect::"
msgstr ""
"При создании DateHeader *value* может быть экземпляром :class:`~datetime."
"datetime`. Это означает, например, что следующий код действителен и делает "
"то, что и следовало ожидать:"

#: ../../library/email.headerregistry.rst:171
msgid ""
"Because this is a naive ``datetime`` it will be interpreted as a UTC "
"timestamp, and the resulting value will have a timezone of ``-0000``.  Much "
"more useful is to use the :func:`~email.utils.localtime` function from the :"
"mod:`~email.utils` module::"
msgstr ""
"Поскольку это простое ``datetime``, оно будет интерпретироваться как "
"временная метка UTC, а полученное значение будет иметь часовой пояс "
"``-0000``. Гораздо полезнее использовать функцию :func:`~email.utils."
"localtime` из модуля :mod:`~email.utils`::"

#: ../../library/email.headerregistry.rst:178
msgid ""
"This example sets the date header to the current time and date using the "
"current timezone offset."
msgstr ""
"В этом примере в заголовке даты задается текущее время и дата с "
"использованием текущего смещения часового пояса."

#: ../../library/email.headerregistry.rst:184
msgid ""
"Address headers are one of the most complex structured header types. The "
"``AddressHeader`` class provides a generic interface to any address header."
msgstr ""
"Заголовки адресов — один из наиболее сложных структурированных типов "
"заголовков. Класс AddressHeader предоставляет общий интерфейс для любого "
"заголовка адреса."

#: ../../library/email.headerregistry.rst:193
msgid ""
"A tuple of :class:`.Group` objects encoding the addresses and groups found "
"in the header value.  Addresses that are not part of a group are represented "
"in this list as single-address ``Groups`` whose :attr:`~.Group.display_name` "
"is ``None``."
msgstr ""
"Кортеж объектов :class:`.Group`, кодирующий адреса и группы, найденные в "
"значении заголовка. Адреса, не являющиеся частью группы, представлены в этом "
"списке как одноадресные ``Группы``, у которых :attr:`~.Group.display_name` "
"имеет значение ``None``."

#: ../../library/email.headerregistry.rst:201
msgid ""
"A tuple of :class:`.Address` objects encoding all of the individual "
"addresses from the header value.  If the header value contains any groups, "
"the individual addresses from the group are included in the list at the "
"point where the group occurs in the value (that is, the list of addresses is "
"\"flattened\" into a one dimensional list)."
msgstr ""
"Кортеж объектов :class:`.Address`, кодирующий все отдельные адреса из "
"значения заголовка. Если значение заголовка содержит какие-либо группы, "
"отдельные адреса из группы включаются в список в той точке, где группа "
"встречается в значении (то есть список адресов «сглаживается» в одномерный "
"список)."

#: ../../library/email.headerregistry.rst:207
msgid ""
"The ``decoded`` value of the header will have all encoded words decoded to "
"unicode.  :class:`~encodings.idna` encoded domain names are also decoded to "
"unicode.  The ``decoded`` value is set by :attr:`~str.join`\\ ing the :class:"
"`str` value of the elements of the ``groups`` attribute with ``', '``."
msgstr ""

#: ../../library/email.headerregistry.rst:213
msgid ""
"A list of :class:`.Address` and :class:`.Group` objects in any combination "
"may be used to set the value of an address header.  ``Group`` objects whose "
"``display_name`` is ``None`` will be interpreted as single addresses, which "
"allows an address list to be copied with groups intact by using the list "
"obtained from the ``groups`` attribute of the source header."
msgstr ""
"Список объектов :class:`.Address` и :class:`.Group` в любой комбинации может "
"использоваться для установки значения заголовка адреса. Объекты ``Group``, "
"``display_name`` которых имеют значение ``None``, будут интерпретироваться "
"как отдельные адреса, что позволяет копировать список адресов с "
"неповрежденными группами, используя список, полученный из атрибута "
"``groups`` исходный заголовок."

#: ../../library/email.headerregistry.rst:222
msgid ""
"A subclass of :class:`.AddressHeader` that adds one additional attribute:"
msgstr ""
"Подкласс :class:`.AddressHeader`, который добавляет один дополнительный "
"атрибут:"

#: ../../library/email.headerregistry.rst:228
msgid ""
"The single address encoded by the header value.  If the header value "
"actually contains more than one address (which would be a violation of the "
"RFC under the default :mod:`~email.policy`), accessing this attribute will "
"result in a :exc:`ValueError`."
msgstr ""
"Одиночный адрес, закодированный значением заголовка. Если значение заголовка "
"на самом деле содержит более одного адреса (что было бы нарушением RFC по "
"умолчанию :mod:`~email.policy`), доступ к этому атрибуту приведет к :exc:"
"`ValueError`."

#: ../../library/email.headerregistry.rst:234
msgid ""
"Many of the above classes also have a ``Unique`` variant (for example, "
"``UniqueUnstructuredHeader``).  The only difference is that in the "
"``Unique`` variant, :attr:`~.BaseHeader.max_count` is set to 1."
msgstr ""
"Многие из вышеперечисленных классов также имеют вариант «Unique» (например, "
"«UniqueUnstructuredHeader»). Единственное отличие состоит в том, что в "
"варианте Unique для :attr:`~.BaseHeader.max_count` установлено значение 1."

#: ../../library/email.headerregistry.rst:241
msgid ""
"There is really only one valid value for the :mailheader:`MIME-Version` "
"header, and that is ``1.0``.  For future proofing, this header class "
"supports other valid version numbers.  If a version number has a valid value "
"per :rfc:`2045`, then the header object will have non-``None`` values for "
"the following attributes:"
msgstr ""
"На самом деле существует только одно допустимое значение для заголовка :"
"mailheader:`MIME-Version`, и это ``1.0``. Для будущей проверки этот класс "
"заголовка поддерживает другие допустимые номера версий. Если номер версии "
"имеет допустимое значение для :rfc:`2045`, то объект заголовка будет иметь "
"значения, отличные от ``None``, для следующих атрибутов:"

#: ../../library/email.headerregistry.rst:249
msgid ""
"The version number as a string, with any whitespace and/or comments removed."
msgstr "Номер версии в виде строки с удаленными пробелами и/или комментариями."

#: ../../library/email.headerregistry.rst:254
msgid "The major version number as an integer"
msgstr "Основной номер версии в качестве целого числа"

#: ../../library/email.headerregistry.rst:258
msgid "The minor version number as an integer"
msgstr "Младший номер версии в качестве целого числа"

#: ../../library/email.headerregistry.rst:263
msgid ""
"MIME headers all start with the prefix 'Content-'.  Each specific header has "
"a certain value, described under the class for that header.  Some can also "
"take a list of supplemental parameters, which have a common format. This "
"class serves as a base for all the MIME headers that take parameters."
msgstr ""
"Все заголовки MIME начинаются с префикса «Content-». Каждый конкретный "
"заголовок имеет определенное значение, описанное в классе этого заголовка. "
"Некоторые также могут принимать список дополнительных параметров, имеющих "
"общий формат. Этот класс служит основой для всех заголовков MIME, "
"принимающих параметры."

#: ../../library/email.headerregistry.rst:270
msgid "A dictionary mapping parameter names to parameter values."
msgstr "Словарь, сопоставляющий имена параметров со значениями параметров."

#: ../../library/email.headerregistry.rst:275
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the :mailheader:"
"`Content-Type` header."
msgstr ""
"Класс :class:`ParameterizedMIMEHeader`, который обрабатывает заголовок :"
"mailheader:`Content-Type`."

#: ../../library/email.headerregistry.rst:280
msgid "The content type string, in the form ``maintype/subtype``."
msgstr "Строка типа контента в форме «основной тип/подтип»."

#: ../../library/email.headerregistry.rst:289
msgid ""
"A :class:`ParameterizedMIMEHeader` class that handles the :mailheader:"
"`Content-Disposition` header."
msgstr ""
"Класс :class:`ParameterizedMIMEHeader`, который обрабатывает заголовок :"
"mailheader:`Content-Disposition`."

#: ../../library/email.headerregistry.rst:294
msgid "``inline`` and ``attachment`` are the only valid values in common use."
msgstr ""
"``inline`` и ``attachment`` — единственные общеупотребительные допустимые "
"значения."

#: ../../library/email.headerregistry.rst:299
msgid "Handles the :mailheader:`Content-Transfer-Encoding` header."
msgstr "Обрабатывает заголовок :mailheader:`Content-Transfer-Encoding`."

#: ../../library/email.headerregistry.rst:303
msgid ""
"Valid values are ``7bit``, ``8bit``, ``base64``, and ``quoted-printable``.  "
"See :rfc:`2045` for more information."
msgstr ""
"Допустимые значения: 7bit, 8bit, base64 иquoted-printable. См. :rfc:`2045` "
"для получения дополнительной информации."

#: ../../library/email.headerregistry.rst:312
msgid ""
"This is the factory used by :class:`~email.policy.EmailPolicy` by default. "
"``HeaderRegistry`` builds the class used to create a header instance "
"dynamically, using *base_class* and a specialized class retrieved from a "
"registry that it holds.  When a given header name does not appear in the "
"registry, the class specified by *default_class* is used as the specialized "
"class.  When *use_default_map* is ``True`` (the default), the standard "
"mapping of header names to classes is copied in to the registry during "
"initialization.  *base_class* is always the last class in the generated "
"class's ``__bases__`` list."
msgstr ""

#: ../../library/email.headerregistry.rst:322
msgid "The default mappings are:"
msgstr "По умолчанию используются следующие сопоставления:"

#: ../../library/email.headerregistry.rst:0
msgid "subject"
msgstr "предмет"

#: ../../library/email.headerregistry.rst:324
msgid "UniqueUnstructuredHeader"
msgstr "UniqueUnstructuredHeader"

#: ../../library/email.headerregistry.rst:0
msgid "date"
msgstr "дата"

#: ../../library/email.headerregistry.rst:325
#: ../../library/email.headerregistry.rst:327
msgid "UniqueDateHeader"
msgstr "UniqueDateHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-date"
msgstr "дата повторной отправки"

#: ../../library/email.headerregistry.rst:326
msgid "DateHeader"
msgstr "DateHeader"

#: ../../library/email.headerregistry.rst:0
msgid "orig-date"
msgstr "первоначальная дата"

#: ../../library/email.headerregistry.rst:0
msgid "sender"
msgstr "отправитель"

#: ../../library/email.headerregistry.rst:328
msgid "UniqueSingleAddressHeader"
msgstr "UniqueSingleAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-sender"
msgstr "отправитель повторного сообщения"

#: ../../library/email.headerregistry.rst:329
msgid "SingleAddressHeader"
msgstr "SingleAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "to"
msgstr "к"

#: ../../library/email.headerregistry.rst:330
#: ../../library/email.headerregistry.rst:332
#: ../../library/email.headerregistry.rst:334
#: ../../library/email.headerregistry.rst:336
#: ../../library/email.headerregistry.rst:338
msgid "UniqueAddressHeader"
msgstr "UniqueAddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "resent-to"
msgstr "повторно отправить"

#: ../../library/email.headerregistry.rst:331
#: ../../library/email.headerregistry.rst:333
#: ../../library/email.headerregistry.rst:335
#: ../../library/email.headerregistry.rst:337
msgid "AddressHeader"
msgstr "AddressHeader"

#: ../../library/email.headerregistry.rst:0
msgid "cc"
msgstr "cc"

#: ../../library/email.headerregistry.rst:0
msgid "resent-cc"
msgstr "resent-cc"

#: ../../library/email.headerregistry.rst:0
msgid "bcc"
msgstr "bcc"

#: ../../library/email.headerregistry.rst:0
msgid "resent-bcc"
msgstr "resent-bcc"

#: ../../library/email.headerregistry.rst:0
msgid "from"
msgstr "от"

#: ../../library/email.headerregistry.rst:0
msgid "resent-from"
msgstr "resent-from"

#: ../../library/email.headerregistry.rst:0
msgid "reply-to"
msgstr "ответ на"

#: ../../library/email.headerregistry.rst:0
msgid "mime-version"
msgstr "mime-версия"

#: ../../library/email.headerregistry.rst:339
msgid "MIMEVersionHeader"
msgstr "MIMEVersionHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-type"
msgstr "тип содержимого"

#: ../../library/email.headerregistry.rst:340
msgid "ContentTypeHeader"
msgstr "ContentTypeHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-disposition"
msgstr "содержание-расположение"

#: ../../library/email.headerregistry.rst:341
msgid "ContentDispositionHeader"
msgstr "ContentDispositionHeader"

#: ../../library/email.headerregistry.rst:0
msgid "content-transfer-encoding"
msgstr "передача контента кодирование"

#: ../../library/email.headerregistry.rst:342
msgid "ContentTransferEncodingHeader"
msgstr "ContentTransferEncodingHeader"

#: ../../library/email.headerregistry.rst:0
msgid "message-id"
msgstr "идентификатор сообщения"

#: ../../library/email.headerregistry.rst:343
msgid "MessageIDHeader"
msgstr "MessageIDHeader"

#: ../../library/email.headerregistry.rst:345
msgid "``HeaderRegistry`` has the following methods:"
msgstr "``HeaderRegistry`` имеет следующие методы:"

#: ../../library/email.headerregistry.rst:350
msgid ""
"*name* is the name of the header to be mapped.  It will be converted to "
"lower case in the registry.  *cls* is the specialized class to be used, "
"along with *base_class*, to create the class used to instantiate headers "
"that match *name*."
msgstr ""
"*name* — имя заголовка, который необходимо сопоставить. В реестре он будет "
"преобразован в нижний регистр. *cls* — это специализированный класс, который "
"будет использоваться вместе с *base_class* для создания класса, "
"используемого для создания экземпляров заголовков, соответствующих *name*."

#: ../../library/email.headerregistry.rst:358
msgid "Construct and return a class to handle creating a *name* header."
msgstr "Создайте и верните класс для обработки создания заголовка *name*."

#: ../../library/email.headerregistry.rst:363
msgid ""
"Retrieves the specialized header associated with *name* from the registry "
"(using *default_class* if *name* does not appear in the registry) and "
"composes it with *base_class* to produce a class, calls the constructed "
"class's constructor, passing it the same argument list, and finally returns "
"the class instance created thereby."
msgstr ""
"Извлекает специализированный заголовок, связанный с *name*, из реестра "
"(используя *default_class*, если *name* не отображается в реестре) и "
"объединяет его с *base_class* для создания класса, вызывает конструктор "
"созданного класса, передавая ему то же самое список аргументов и, наконец, "
"возвращает созданный таким образом экземпляр класса."

#: ../../library/email.headerregistry.rst:370
msgid ""
"The following classes are the classes used to represent data parsed from "
"structured headers and can, in general, be used by an application program to "
"construct structured values to assign to specific headers."
msgstr ""
"Следующие классы представляют собой классы, используемые для представления "
"данных, анализируемых из структурированных заголовков, и, как правило, могут "
"использоваться прикладной программой для создания структурированных значений "
"для присвоения определенным заголовкам."

#: ../../library/email.headerregistry.rst:377
msgid ""
"The class used to represent an email address.  The general form of an "
"address is::"
msgstr ""
"Класс, используемый для представления адреса электронной почты. Общая форма "
"адреса:"

#: ../../library/email.headerregistry.rst:382
msgid "or::"
msgstr "или::"

#: ../../library/email.headerregistry.rst:386
msgid ""
"where each part must conform to specific syntax rules spelled out in :rfc:"
"`5322`."
msgstr ""
"где каждая часть должна соответствовать определенным синтаксическим "
"правилам, изложенным в :rfc:`5322`."

#: ../../library/email.headerregistry.rst:389
msgid ""
"As a convenience *addr_spec* can be specified instead of *username* and "
"*domain*, in which case *username* and *domain* will be parsed from the "
"*addr_spec*.  An *addr_spec* must be a properly RFC quoted string; if it is "
"not ``Address`` will raise an error.  Unicode characters are allowed and "
"will be property encoded when serialized.  However, per the RFCs, unicode is "
"*not* allowed in the username portion of the address."
msgstr ""
"Для удобства вместо *username* и *domain* можно указать *addr_spec*, в этом "
"случае *username* и *domain* будут анализироваться из *addr_spec*. "
"*addr_spec* должен быть строкой, заключенной в кавычки RFC; если это не "
"«Адрес», возникнет ошибка. Символы Юникода разрешены и будут закодированы "
"свойством при сериализации. Однако, согласно RFC, юникод *не* разрешен в "
"части адреса, посвященной имени пользователя."

#: ../../library/email.headerregistry.rst:398
msgid ""
"The display name portion of the address, if any, with all quoting removed.  "
"If the address does not have a display name, this attribute will be an empty "
"string."
msgstr ""
"Отображаемая часть адреса, если таковая имеется, без кавычек. Если у адреса "
"нет отображаемого имени, этот атрибут будет пустой строкой."

#: ../../library/email.headerregistry.rst:404
msgid "The ``username`` portion of the address, with all quoting removed."
msgstr "Часть адреса ``имя пользователя``, все кавычки удалены."

#: ../../library/email.headerregistry.rst:408
msgid "The ``domain`` portion of the address."
msgstr "``domain`` часть адреса."

#: ../../library/email.headerregistry.rst:412
msgid ""
"The ``username@domain`` portion of the address, correctly quoted for use as "
"a bare address (the second form shown above).  This attribute is not mutable."
msgstr ""
"Часть адреса ``username@domain``, правильно заключенная в кавычки для "
"использования в качестве простого адреса (вторая форма показана выше). Этот "
"атрибут не является изменяемым."

#: ../../library/email.headerregistry.rst:418
msgid ""
"The ``str`` value of the object is the address quoted according to :rfc:"
"`5322` rules, but with no Content Transfer Encoding of any non-ASCII "
"characters."
msgstr ""
"Значение ``str`` объекта — это адрес, указанный в соответствии с правилами :"
"rfc:`5322`, но без кодирования передачи контента для любых символов, "
"отличных от ASCII."

#: ../../library/email.headerregistry.rst:422
msgid ""
"To support SMTP (:rfc:`5321`), ``Address`` handles one special case: if "
"``username`` and ``domain`` are both the empty string (or ``None``), then "
"the string value of the ``Address`` is ``<>``."
msgstr ""
"Для поддержки SMTP (:rfc:`5321`) ``Address`` обрабатывает один особый "
"случай: если ``username`` и ``domain`` оба являются пустой строкой (или "
"``None``), то Строковое значение ``Адрес`` равно ``<>``."

#: ../../library/email.headerregistry.rst:429
msgid ""
"The class used to represent an address group.  The general form of an "
"address group is::"
msgstr ""
"Класс, используемый для представления группы адресов. Общая форма адресной "
"группы:"

#: ../../library/email.headerregistry.rst:434
msgid ""
"As a convenience for processing lists of addresses that consist of a mixture "
"of groups and single addresses, a ``Group`` may also be used to represent "
"single addresses that are not part of a group by setting *display_name* to "
"``None`` and providing a list of the single address as *addresses*."
msgstr ""
"Для удобства обработки списков адресов, состоящих из группы и отдельных "
"адресов, можно также использовать группу для представления отдельных "
"адресов, не входящих в группу, установив для *display_name* значение «Нет». "
"` и предоставление списка отдельных адресов в виде *адресов*."

#: ../../library/email.headerregistry.rst:441
msgid ""
"The ``display_name`` of the group.  If it is ``None`` and there is exactly "
"one ``Address`` in ``addresses``, then the ``Group`` represents a single "
"address that is not in a group."
msgstr ""
"``display_name`` группы. Если это «Нет» и в «адресах» есть ровно один "
"«Адрес», то «Группа» представляет собой одиночный адрес, которого нет в "
"группе."

#: ../../library/email.headerregistry.rst:447
msgid ""
"A possibly empty tuple of :class:`.Address` objects representing the "
"addresses in the group."
msgstr ""
"Возможно, пустой кортеж объектов :class:`.Address`, представляющих адреса в "
"группе."

#: ../../library/email.headerregistry.rst:452
msgid ""
"The ``str`` value of a ``Group`` is formatted according to :rfc:`5322`, but "
"with no Content Transfer Encoding of any non-ASCII characters.  If "
"``display_name`` is none and there is a single ``Address`` in the "
"``addresses`` list, the ``str`` value will be the same as the ``str`` of "
"that single ``Address``."
msgstr ""
"Значение ``str`` для ``Group`` форматируется в соответствии с :rfc:`5322`, "
"но без кодирования передачи контента для каких-либо символов, отличных от "
"ASCII. Если ``display_name`` отсутствует и в списке ``адресов`` есть один "
"``Адрес``, значение ``str`` будет таким же, как ``str`` этого единственного "
"`` Адрес``."

#: ../../library/email.headerregistry.rst:460
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/email.headerregistry.rst:461
msgid ""
"Originally added in 3.3 as a :term:`provisional module <provisional package>`"
msgstr ""
"Первоначально добавлен в версии 3.3 как :term:`previsional Module "
"<provisional package>`"
