# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/logging.config.rst:2
msgid ":mod:`!logging.config` --- Logging configuration"
msgstr ":mod:`!logging.config` --- Конфигурация журналирования"

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**Исходный код:** :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ":mod:`!logging.config` --- Конфигурация журналирования"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Basic Tutorial <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Logging Cookbook <logging-cookbook>`"

#: ../../library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "В этом разделе описывается API для настройки модуля журналирования."

#: ../../library/logging.config.rst:28
msgid "Configuration functions"
msgstr "Функции настройки"

#: ../../library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"Следующие функции настраивают модуль журналирования. Они расположены в "
"модуле :mod:`logging.config`. Их использование не является обязательным — вы "
"можете настроить модуль журналирования, используя эти функции или выполнив "
"вызовы основного API (определенного в самом :mod:`logging`) и определив "
"обработчики, которые объявлены либо в :mod:`logging`, либо в :mod:`logging` "
"или :mod:`logging.handlers`."

#: ../../library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"Берет конфигурацию журналирования из словаря. Содержимое этого словаря "
"описано в :ref:`logging-config-dictschema` ниже."

#: ../../library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"Если во время конфигурации обнаружена ошибка, эта функция вызовет :exc:"
"`ValueError`, :exc:`TypeError`, :exc:`AttributeError` или :exc:`ImportError` "
"с подходящим описательным сообщением. Ниже приводится (возможно, неполный) "
"список условий, при которых возникает ошибка:"

#: ../../library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr ""
"``Уровень``, который не является строкой или является строкой, не "
"соответствующей фактическому уровню ведения журнала."

#: ../../library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "Значение ``распространения``, которое не является логическим."

#: ../../library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "Идентификатор, у которого нет соответствующего пункта назначения."

#: ../../library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr ""
"Во время добавочного вызова обнаружен несуществующий идентификатор "
"обработчика."

#: ../../library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "Недопустимое имя регистратора."

#: ../../library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "Неспособность разрешить внутренний или внешний объект."

#: ../../library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"Анализ выполняется классом :class:`DictConfigurator`, конструктору которого "
"передается словарь, используемый для конфигурации, и он имеет метод :meth:"
"`configure`. Модуль :mod:`logging.config` имеет вызываемый атрибут :attr:"
"`dictConfigClass`, для которого изначально установлено значение :class:"
"`DictConfigurator`. Вы можете заменить значение :attr:`dictConfigClass` на "
"подходящую собственную реализацию."

#: ../../library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` вызывает :attr:`dictConfigClass`, передавая указанный "
"словарь, а затем вызывает метод :meth:`configure` для возвращаемого объекта, "
"чтобы привести конфигурацию в действие::"

#: ../../library/logging.config.rst:68
msgid ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"
msgstr ""
"def dictConfig(config):\n"
"    dictConfigClass(config).configure()"

#: ../../library/logging.config.rst:71
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""
"Например, подкласс :class:`DictConfigurator` может вызывать "
"``DictConfigurator.__init__()`` в своем собственном :meth:`__init__`, а "
"затем устанавливать собственные префиксы, которые можно будет использовать в "
"последующих :meth:`configure. ` позвони. :attr:`dictConfigClass` будет "
"привязан к этому новому подклассу, а затем :func:`dictConfig` может быть "
"вызван точно так же, как в ненастроенном состоянии по умолчанию."

#: ../../library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"Считывает конфигурацию журнала из файла формата :mod:`configparser`\\. "
"Формат файла должен быть таким, как описано в :ref:`logging-config-"
"fileformat`. Эту функцию можно вызывать из приложения несколько раз, что "
"позволяет конечному пользователю выбирать из различных заранее "
"подготовленных конфигураций (если разработчик предоставляет механизм "
"представления вариантов выбора и загрузки выбранной конфигурации)."

#: ../../library/logging.config.rst:90
msgid ""
"It will raise :exc:`FileNotFoundError` if the file doesn't exist and :exc:"
"`RuntimeError` if the file is invalid or empty."
msgstr ""
"Он выдаст :exc:`FileNotFoundError`, если файл не существует, и :exc:"
"`RuntimeError`, если файл недействителен или пуст."

#: ../../library/logging.config.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../../library/logging.config.rst:94
msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a :class:`!RawConfigParser`-derived "
"instance is passed, it is used as is. Otherwise, a :class:`~configparser."
"ConfigParser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"Имя файла, файлоподобный объект или экземпляр, производный от :class:"
"`~configparser.RawConfigParser`. Если передается экземпляр, производный от :"
"class:`!RawConfigParser`, он используется как есть. В противном случае "
"создается экземпляр :class:`~configparser.ConfigParser`, и конфигурация "
"считывается им из объекта, переданного в ``fname``. Если у него есть метод :"
"meth:`readline`, предполагается, что он представляет собой файлоподобный "
"объект и читается с помощью :meth:`~configparser.ConfigParser.read_file`; в "
"противном случае предполагается, что это имя файла и передается в :meth:"
"`~configparser.ConfigParser.read`."

#: ../../library/logging.config.rst:106
msgid ""
"Defaults to be passed to the :class:`!ConfigParser` can be specified in this "
"argument."
msgstr ""
"В этом аргументе можно указать значения по умолчанию, которые будут переданы "
"в :class:`!ConfigParser`."

#: ../../library/logging.config.rst:109
msgid ""
"If specified as ``False``, loggers which exist when this call is made are "
"left enabled. The default is ``True`` because this enables old behaviour in "
"a backward-compatible way. This behaviour is to disable any existing non-"
"root loggers unless they or their ancestors are explicitly named in the "
"logging configuration."
msgstr ""
"Если указано значение «False», средства ведения журнала, существующие на "
"момент выполнения этого вызова, остаются включенными. По умолчанию "
"установлено значение True, поскольку это позволяет использовать старое "
"поведение с обратной совместимостью. Такое поведение предназначено для "
"отключения всех существующих средств ведения журнала без полномочий root, "
"если они или их предки явно не указаны в конфигурации ведения журнала."

#: ../../library/logging.config.rst:118
msgid "The encoding used to open file when *fname* is filename."
msgstr ""
"Кодировка, используемая для открытия файла, если *fname* — это имя файла."

#: ../../library/logging.config.rst:120
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ""
"Экземпляр подкласса :class:`~configparser.RawConfigParser` теперь "
"принимается как значение для ``fname``. Это облегчает:"

#: ../../library/logging.config.rst:124
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr ""
"Использование файла конфигурации, в котором конфигурация журнала является "
"лишь частью общей конфигурации приложения."

#: ../../library/logging.config.rst:126
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"Использование конфигурации, считанной из файла, а затем измененной "
"использующим приложением (например, на основе параметров командной строки "
"или других аспектов среды выполнения) перед передачей в ``fileConfig``."

#: ../../library/logging.config.rst:130
msgid "Added the *encoding* parameter."
msgstr "Добавлен параметр *encoding*."

#: ../../library/logging.config.rst:133
msgid ""
"An exception will be thrown if the provided file doesn't exist or is invalid "
"or empty."
msgstr ""
"Исключение будет выдано, если предоставленный файл не существует, является "
"недействительным или пустым."

#: ../../library/logging.config.rst:139
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"Запускает сервер сокетов на указанном порту и прослушивает новые "
"конфигурации. Если порт не указан, используется значение по умолчанию :const:"
"`DEFAULT_LOGGING_CONFIG_PORT`. Конфигурации журналирования будут отправлены "
"в виде файла, подходящего для обработки с помощью :func:`dictConfig` или :"
"func:`fileConfig`. Возвращает экземпляр :class:`~threading.Thread`, в "
"котором вы можете вызвать :meth:`~threading.Thread.start` для запуска "
"сервера и который вы можете :meth:`~threading.Thread.join` при "
"необходимости . Чтобы остановить сервер, вызовите :func:`stopListening`."

#: ../../library/logging.config.rst:148
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"Аргумент ``verify``, если он указан, должен быть вызываемым объектом, "
"который должен проверять, являются ли байты, полученные через сокет, "
"действительными и должны ли они быть обработаны. Это можно сделать путем "
"шифрования и/или подписи того, что отправляется через сокет, так, чтобы "
"вызываемая функция verify могла выполнять проверку и/или расшифровку "
"подписи. Вызываемая функция verify вызывается с одним аргументом — байтами, "
"полученными через сокет — и должна возвращать байты, подлежащие обработке, "
"или «None», чтобы указать, что байты должны быть отброшены. Возвращаемые "
"байты могут быть такими же, как переданные байты (например, когда "
"выполняется только проверка), или они могут быть совершенно разными "
"(возможно, если выполнялась расшифровка)."

#: ../../library/logging.config.rst:159
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"Чтобы отправить конфигурацию в сокет, прочитайте файл конфигурации и "
"отправьте его в сокет в виде последовательности байтов, которой предшествует "
"строка длиной четыре байта, упакованная в двоичном формате с использованием "
"``struct.pack('>L', n)` `."

#: ../../library/logging.config.rst:167
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"Поскольку части конфигурации передаются через :func:`eval`, использование "
"этой функции может подвергнуть пользователей риску безопасности. Хотя "
"функция привязывается только к сокету на ``localhost`` и поэтому не "
"принимает соединения от удаленных компьютеров, существуют сценарии, в "
"которых ненадежный код может быть запущен под учетной записью процесса, "
"который вызывает :func:`listen`. В частности, если процесс, вызывающий :func:"
"`listen`, выполняется на многопользовательской машине, где пользователи не "
"могут доверять друг другу, тогда злонамеренный пользователь может запустить "
"по существу произвольный код в процессе пользователя-жертвы, просто "
"подключившись к системе жертвы: func:`listen` и отправка конфигурации, "
"которая запускает любой код, который злоумышленник хочет выполнить в "
"процессе жертвы. Это особенно легко сделать, если используется порт по "
"умолчанию, но несложно, даже если используется другой порт. Чтобы избежать "
"такого риска, используйте аргумент ``verify`` для :func:`listen`, чтобы "
"предотвратить применение нераспознанных конфигураций."

#: ../../library/logging.config.rst:183
msgid "The ``verify`` argument was added."
msgstr "Был добавлен аргумент ``verify``."

#: ../../library/logging.config.rst:188
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"Если вы хотите отправить прослушивателю конфигурации, которые не отключают "
"существующие средства ведения журнала, вам нужно будет использовать формат "
"JSON для конфигурации, который будет использовать :func:`dictConfig` для "
"конфигурации. Этот метод позволяет вам указать ``disable_existing_loggers`` "
"как ``False`` в отправляемой вами конфигурации."

#: ../../library/logging.config.rst:197
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"Останавливает прослушивающий сервер, созданный вызовом :func:`listen`. "
"Обычно это вызывается перед вызовом :meth:`join` для возвращаемого значения "
"из :func:`listen`."

#: ../../library/logging.config.rst:203
msgid "Security considerations"
msgstr "Соображения безопасности"

#: ../../library/logging.config.rst:205
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""
"Функциональность конфигурации ведения журнала пытается обеспечить удобство, "
"и частично это достигается за счет возможности конвертировать текст в файлах "
"конфигурации в объекты Python, используемые в конфигурации ведения журнала — "
"например, как описано в :ref:`logging-config-dict-userdef `. Однако те же "
"механизмы (импорт вызываемых объектов из пользовательских модулей и вызов их "
"с параметрами из конфигурации) можно использовать для вызова любого кода, "
"который вам нравится, и по этой причине к файлам конфигурации из ненадежных "
"источников следует относиться с *крайней осторожностью* и прежде чем "
"загружать их, убедитесь, что ничего плохого не произойдет, если вы их "
"загрузите."

#: ../../library/logging.config.rst:219
msgid "Configuration dictionary schema"
msgstr "Схема словаря конфигурации"

#: ../../library/logging.config.rst:221
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"Описание конфигурации журналирования требует перечисления различных "
"объектов, которые необходимо создать, и связей между ними; например, вы "
"можете создать обработчик с именем «консоль», а затем сказать, что "
"регистратор с именем «запуск» будет отправлять свои сообщения обработчику "
"«консоль». Эти объекты не ограничиваются объектами, предоставляемыми "
"модулем :mod:`logging`, поскольку вы можете написать свой собственный класс "
"форматирования или обработчика. Параметры этих классов также могут включать "
"внешние объекты, такие как ``sys.stderr``. Синтаксис описания этих объектов "
"и соединений определен в разделе :ref:`logging-config-dict-connections` ниже."

#: ../../library/logging.config.rst:233
msgid "Dictionary Schema Details"
msgstr "Подробные сведения о схеме словаря"

#: ../../library/logging.config.rst:235
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr ""
"Словарь, передаваемый в :func:`dictConfig`, должен содержать следующие ключи:"

#: ../../library/logging.config.rst:238
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr ""
"*версия* — для установки целочисленного значения, представляющего версию "
"схемы. Единственное допустимое значение на данный момент — 1, но наличие "
"этого ключа позволяет схеме развиваться, сохраняя при этом обратную "
"совместимость."

#: ../../library/logging.config.rst:243
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"Все остальные клавиши являются необязательными, но если они присутствуют, "
"они будут интерпретироваться, как описано ниже. Во всех приведенных ниже "
"случаях, когда упоминается «настройка dict», он будет проверен на наличие "
"специального ключа ``'()'``, чтобы определить, требуется ли пользовательское "
"создание экземпляра. Если да, то для создания экземпляра используется "
"механизм, описанный в разделе :ref:`logging-config-dict-userdef` ниже; в "
"противном случае контекст используется для определения того, что создавать."

#: ../../library/logging.config.rst:252
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* — соответствующим значением будет словарь, в котором каждый "
"ключ является идентификатором форматтера, а каждое значение — это словарь, "
"описывающий, как настроить соответствующий экземпляр :class:`~logging."
"Formatter`."

#: ../../library/logging.config.rst:256
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr ""
"В конфигурационном словаре выполняется поиск следующих дополнительных "
"ключей, которые соответствуют аргументам, переданным для создания объекта :"
"class:`~logging.Formatter`:"

#: ../../library/logging.config.rst:260
msgid "``format``"
msgstr "``format``"

#: ../../library/logging.config.rst:261
msgid "``datefmt``"
msgstr "``datefmt``"

#: ../../library/logging.config.rst:262
msgid "``style``"
msgstr "``style``"

#: ../../library/logging.config.rst:263
msgid "``validate`` (since version >=3.8)"
msgstr "``validate`` (начиная с версии >=3.8)"

#: ../../library/logging.config.rst:264
msgid "``defaults`` (since version >=3.12)"
msgstr "``defaults`` (since version >=3.12)"

#: ../../library/logging.config.rst:266
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for :"
"class:`~logging.Formatter`, thus this key is most useful for instantiating a "
"customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"Необязательный ключ ``class`` указывает имя класса форматтера (в виде модуля "
"и имени класса, разделенных точками). Аргументы создания экземпляра такие "
"же, как и для :class:`~logging.Formatter`, поэтому этот ключ наиболее "
"полезен для создания экземпляра настроенного подкласса :class:`~logging."
"Formatter`. Например, альтернативный класс может представлять обратные "
"трассировки исключений в расширенном или сжатом формате. Если вашему "
"форматтеру требуются другие или дополнительные ключи конфигурации, вам "
"следует использовать :ref:`logging-config-dict-userdef`."

#: ../../library/logging.config.rst:275
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* — соответствующее значение будет словарем, в котором каждый ключ "
"является идентификатором фильтра, а каждое значение — это словарем, "
"описывающим, как настроить соответствующий экземпляр фильтра."

#: ../../library/logging.config.rst:279
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"В конфигурационном словаре выполняется поиск ключа ``name`` (по умолчанию "
"пустая строка), который используется для создания экземпляра :class:`logging."
"Filter`."

#: ../../library/logging.config.rst:283
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* — соответствующее значение будет словарем, в котором каждый ключ "
"является идентификатором обработчика, а каждое значение — это словарем, "
"описывающим, как настроить соответствующий экземпляр обработчика."

#: ../../library/logging.config.rst:287 ../../library/logging.config.rst:332
msgid "The configuring dict is searched for the following keys:"
msgstr "В конфигурационном словаре ищутся следующие ключи:"

#: ../../library/logging.config.rst:289
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."

#: ../../library/logging.config.rst:292
msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (optional).  The level of the handler."

#: ../../library/logging.config.rst:294
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``formatter`` (optional).  The id of the formatter for this handler."

#: ../../library/logging.config.rst:297
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr ""
"``filters`` (optional).  A list of ids of the filters for this handler."

#: ../../library/logging.config.rst:300 ../../library/logging.config.rst:341
msgid "``filters`` can take filter instances in addition to ids."
msgstr "``filters`` can take filter instances in addition to ids."

#: ../../library/logging.config.rst:303
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr ""
"Все *другие* ключи передаются в качестве аргументов ключевого слова "
"конструктору обработчика. Например, учитывая фрагмент:"

#: ../../library/logging.config.rst:306
msgid ""
"handlers:\n"
"  console:\n"
"    class : logging.StreamHandler\n"
"    formatter: brief\n"
"    level   : INFO\n"
"    filters: [allow_foo]\n"
"    stream  : ext://sys.stdout\n"
"  file:\n"
"    class : logging.handlers.RotatingFileHandler\n"
"    formatter: precise\n"
"    filename: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"
msgstr ""
"handlers:\n"
"  console:\n"
"    class : logging.StreamHandler\n"
"    formatter: brief\n"
"    level   : INFO\n"
"    filters: [allow_foo]\n"
"    stream  : ext://sys.stdout\n"
"  file:\n"
"    class : logging.handlers.RotatingFileHandler\n"
"    formatter: precise\n"
"    filename: logconfig.log\n"
"    maxBytes: 1024\n"
"    backupCount: 3"

#: ../../library/logging.config.rst:322
msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"обработчик с идентификатором ``console`` создается как :class:`logging."
"StreamHandler`, используя ``sys.stdout`` в качестве базового потока. "
"Обработчик с идентификатором ``file`` создается как :class:`logging.handlers."
"RotatingFileHandler` с ключевыми аргументами ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."

#: ../../library/logging.config.rst:328
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* — соответствующим значением будет словарь, в котором каждый ключ — "
"это имя регистратора, а каждое значение — это словарь, описывающий, как "
"настроить соответствующий экземпляр Logger."

#: ../../library/logging.config.rst:334
msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (optional).  The level of the logger."

#: ../../library/logging.config.rst:336
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``propagate`` (optional).  The propagation setting of the logger."

#: ../../library/logging.config.rst:338
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr "``filters`` (optional).  A list of ids of the filters for this logger."

#: ../../library/logging.config.rst:344
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."

#: ../../library/logging.config.rst:347
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr ""
"Указанные регистраторы будут настроены в соответствии с указанным уровнем, "
"распространением, фильтрами и обработчиками."

#: ../../library/logging.config.rst:350
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* — это будет конфигурация корневого логгера. Обработка конфигурации "
"будет такой же, как и для любого регистратора, за исключением того, что "
"настройка распространения не будет применима."

#: ../../library/logging.config.rst:354
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*incremental* — следует ли интерпретировать конфигурацию как дополнительную "
"по отношению к существующей конфигурации. По умолчанию это значение равно "
"«False», что означает, что указанная конфигурация заменяет существующую "
"конфигурацию той же семантикой, которая используется существующим API :func:"
"`fileConfig`."

#: ../../library/logging.config.rst:360
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"Если указанное значение равно True, конфигурация обрабатывается, как описано "
"в разделе :ref:`logging-config-dict-incremental`."

#: ../../library/logging.config.rst:363
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* — следует ли отключить какие-либо существующие "
"средства ведения журнала без полномочий root. Этот параметр отражает "
"одноименный параметр в :func:`fileConfig`. Если он отсутствует, этот "
"параметр по умолчанию имеет значение True. Это значение игнорируется, если "
"*incremental* имеет значение True."

#: ../../library/logging.config.rst:371
msgid "Incremental Configuration"
msgstr "Инкрементная конфигурация"

#: ../../library/logging.config.rst:373
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr ""
"Трудно обеспечить полную гибкость для инкрементной конфигурации. Например, "
"поскольку такие объекты, как фильтры и средства форматирования, являются "
"анонимными, после настройки конфигурации невозможно ссылаться на такие "
"анонимные объекты при дополнении конфигурации."

#: ../../library/logging.config.rst:379
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"Более того, нет убедительных оснований для произвольного изменения графа "
"объектов регистраторов, обработчиков, фильтров и форматировщиков во время "
"выполнения после настройки конфигурации; многословием регистраторов и "
"обработчиков можно управлять, просто устанавливая уровни (и, в случае "
"регистраторов, флаги распространения). Произвольное изменение графа объекта "
"безопасным способом проблематично в многопоточной среде; хотя это и не "
"невозможно, преимущества не стоят тех сложностей, которые они добавляют к "
"реализации."

#: ../../library/logging.config.rst:388
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"Таким образом, когда ``инкрементальный`` ключ конфигурации dict присутствует "
"и имеет значение ``True``, система будет полностью игнорировать любые записи "
"``форматеров`` и ``фильтров`` и обрабатывать только ``уровень `` настройки в "
"записях ``handlers``, а также настройки``level`` и ``propagate`` в записях "
"``loggers`` и ``root``."

#: ../../library/logging.config.rst:394
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"Использование значения в конфигурационном диктофоне позволяет отправлять "
"конфигурации по сети в виде маринованных диктовок прослушивателю сокета. "
"Таким образом, степень детализации журнала долго работающего приложения "
"может быть изменена с течением времени без необходимости останавливать и "
"перезапускать приложение."

#: ../../library/logging.config.rst:402
msgid "Object connections"
msgstr "Соединения с объектами"

#: ../../library/logging.config.rst:404
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"Схема описывает набор объектов журналирования — регистраторов, обработчиков, "
"форматировщиков, фильтров — которые связаны друг с другом в графе объектов. "
"Таким образом, схема должна представлять связи между объектами. Например, "
"предположим, что после настройки определенный регистратор присоединил к нему "
"определенный обработчик. Для целей этого обсуждения мы можем сказать, что "
"регистратор представляет собой источник, а обработчик — пункт назначения "
"соединения между ними. Конечно, в сконфигурированных объектах это "
"представлено регистратором, содержащим ссылку на обработчик. В словаре "
"конфигурации это делается путем присвоения каждому целевому объекту "
"идентификатора, который однозначно идентифицирует его, а затем использования "
"идентификатора в конфигурации исходного объекта, чтобы указать, что "
"существует соединение между источником и целевым объектом с этим "
"идентификатором."

#: ../../library/logging.config.rst:418
msgid "So, for example, consider the following YAML snippet:"
msgstr "Так, например, рассмотрим следующий фрагмент YAML:"

#: ../../library/logging.config.rst:420
msgid ""
"formatters:\n"
"  brief:\n"
"    # configuration for formatter with id 'brief' goes here\n"
"  precise:\n"
"    # configuration for formatter with id 'precise' goes here\n"
"handlers:\n"
"  h1: #This is an id\n"
"   # configuration of handler with id 'h1' goes here\n"
"   formatter: brief\n"
"  h2: #This is another id\n"
"   # configuration of handler with id 'h2' goes here\n"
"   formatter: precise\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # other configuration for logger 'foo.bar.baz'\n"
"    handlers: [h1, h2]"
msgstr ""
"formatters:\n"
"  brief:\n"
"    # configuration for formatter with id 'brief' goes here\n"
"  precise:\n"
"    # configuration for formatter with id 'precise' goes here\n"
"handlers:\n"
"  h1: #This is an id\n"
"   # configuration of handler with id 'h1' goes here\n"
"   formatter: brief\n"
"  h2: #This is another id\n"
"   # configuration of handler with id 'h2' goes here\n"
"   formatter: precise\n"
"loggers:\n"
"  foo.bar.baz:\n"
"    # other configuration for logger 'foo.bar.baz'\n"
"    handlers: [h1, h2]"

#: ../../library/logging.config.rst:439
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr ""
"(Примечание: здесь используется YAML, потому что он немного более "
"удобочитаем, чем эквивалентная исходная форма словаря Python.)"

#: ../../library/logging.config.rst:442
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"Идентификаторы регистраторов — это имена регистраторов, которые будут "
"использоваться программно для получения ссылки на эти регистраторы, например "
"``foo.bar.baz``. Идентификаторы форматтеров и фильтров могут быть любыми "
"строковыми значениями (например, «краткий», «точный» выше), и они являются "
"временными, поскольку имеют смысл только для обработки словаря конфигурации "
"и используются для определения связей между объектами. и не сохраняются "
"нигде после завершения вызова конфигурации."

#: ../../library/logging.config.rst:450
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"Приведенный выше фрагмент указывает, что к регистратору с именем ``foo.bar."
"baz`` должны быть прикреплены два обработчика, которые описываются "
"идентификаторами обработчиков ``h1`` и ``h2``. Форматировщик для ``h1`` "
"описан идентификатором ``brief``, а форматтер для ``h2`` описан "
"идентификатором ``precision``."

#: ../../library/logging.config.rst:460
msgid "User-defined objects"
msgstr "Пользовательские объекты"

#: ../../library/logging.config.rst:462
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"Схема поддерживает определяемые пользователем объекты для обработчиков, "
"фильтров и средств форматирования. (Системы ведения журнала не обязательно "
"должны иметь разные типы для разных экземпляров, поэтому в этой схеме "
"конфигурации нет поддержки определяемых пользователем классов средств "
"ведения журнала.)"

#: ../../library/logging.config.rst:467
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"Настраиваемые объекты описываются словарями, в которых подробно описана их "
"конфигурация. В некоторых местах система журналирования сможет определить из "
"контекста, как должен быть создан экземпляр объекта, но когда должен быть "
"создан экземпляр определяемого пользователем объекта, система не будет "
"знать, как это сделать. Чтобы обеспечить полную гибкость при создании "
"экземпляров определяемых пользователем объектов, пользователю необходимо "
"предоставить «фабрику» — вызываемый объект, который вызывается со словарем "
"конфигурации и возвращает экземпляр объекта. Об этом сигнализирует "
"абсолютный путь импорта к фабрике, доступный под специальным ключом "
"``'()'``. Вот конкретный пример:"

#: ../../library/logging.config.rst:479
msgid ""
"formatters:\n"
"  brief:\n"
"    format: '%(message)s'\n"
"  default:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      answer: 42"
msgstr ""
"formatters:\n"
"  brief:\n"
"    format: '%(message)s'\n"
"  default:\n"
"    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'\n"
"    datefmt: '%Y-%m-%d %H:%M:%S'\n"
"  custom:\n"
"      (): my.package.customFormatterFactory\n"
"      bar: baz\n"
"      spam: 99.9\n"
"      answer: 42"

#: ../../library/logging.config.rst:493
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"Приведенный выше фрагмент YAML определяет три средства форматирования. "
"Первый, с идентификатором ``brief``, представляет собой стандартный "
"экземпляр :class:`logging.Formatter` с указанной строкой формата. Второй, с "
"идентификатором ``default``, имеет более длинный формат, а также явно "
"определяет формат времени и приведет к созданию :class:`logging.Formatter`, "
"инициализированного этими двумя строками формата. Показанные в исходной "
"форме Python средства форматирования ``brief`` и ``default`` имеют "
"подсловари конфигурации:"

#: ../../library/logging.config.rst:501
msgid ""
"{\n"
"  'format' : '%(message)s'\n"
"}"
msgstr ""
"{\n"
"  'format' : '%(message)s'\n"
"}"

#: ../../library/logging.config.rst:505
msgid "and::"
msgstr "и::"

#: ../../library/logging.config.rst:507
msgid ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"
msgstr ""
"{\n"
"  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',\n"
"  'datefmt' : '%Y-%m-%d %H:%M:%S'\n"
"}"

#: ../../library/logging.config.rst:512
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"соответственно, и поскольку эти словари не содержат специального ключа "
"``'()'``, создание экземпляра выводится из контекста: в результате создаются "
"стандартные экземпляры :class:`logging.Formatter``. Подсловарь конфигурации "
"для третьего форматтера с идентификатором «custom»:"

#: ../../library/logging.config.rst:518
msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42\n"
"}"
msgstr ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42\n"
"}"

#: ../../library/logging.config.rst:525
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"и он содержит специальный ключ ``'()'``, что означает, что требуется "
"создание определяемого пользователем экземпляра. В этом случае будет "
"использоваться указанный фабричный вызываемый объект. Если это реальный "
"вызываемый объект, он будет использоваться напрямую. В противном случае, "
"если вы укажете строку (как в примере), фактический вызываемый объект будет "
"найден с использованием обычных механизмов импорта. Вызываемый объект будет "
"вызываться с **оставшимися** элементами в подсловаре конфигурации в качестве "
"аргументов ключевого слова. В приведенном выше примере предполагается, что "
"форматтер с идентификатором «custom» возвращается вызовом::"

#: ../../library/logging.config.rst:535
msgid "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"
msgstr "my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)"

#: ../../library/logging.config.rst:537
msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the "
"configuration machinery, but passed to the callable as-is."
msgstr ""
"Значения таких ключей, как ``bar``, ``spam`` и ``ответ`` в приведенном выше "
"примере не должны быть словарями конфигурации или ссылками, такими как "
"``cfg://foo`` или ``ext: //bar``, потому что они не будут обрабатываться "
"механизмом настройки, а будут переданы вызываемому объекту как есть."

#: ../../library/logging.config.rst:542
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"Ключ ``'()'`` использовался в качестве специального ключа, поскольку он не "
"является допустимым именем параметра ключевого слова и поэтому не будет "
"конфликтовать с именами аргументов ключевого слова, используемых в вызове. "
"``'()'`` также служит мнемоническим знаком того, что соответствующее "
"значение является вызываемым."

#: ../../library/logging.config.rst:547
msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr ""
"Член ``filters`` в ``handlers`` и ``loggers`` может принимать экземпляры "
"фильтров в дополнение к идентификаторам."

#: ../../library/logging.config.rst:551
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is a "
"mapping of attribute names to values. If found, the specified attributes "
"will be set on the user-defined object before it is returned. Thus, with the "
"following configuration::"
msgstr ""
"Вы также можете указать специальный ключ ``'.'``, значение которого является "
"словарем, представляющим собой сопоставление имен атрибутов со значениями. "
"Если они найдены, указанные атрибуты будут установлены для пользовательского "
"объекта перед его возвратом. Таким образом, при следующей конфигурации:"

#: ../../library/logging.config.rst:556
msgid ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"
msgstr ""
"{\n"
"  '()' : 'my.package.customFormatterFactory',\n"
"  'bar' : 'baz',\n"
"  'spam' : 99.9,\n"
"  'answer' : 42,\n"
"  '.' {\n"
"    'foo': 'bar',\n"
"    'baz': 'bozz'\n"
"  }\n"
"}"

#: ../../library/logging.config.rst:567
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr ""
"возвращаемый форматтер будет иметь атрибут ``foo``, установленный в "
"``'bar'``, а атрибут ``baz`` установлен в ``'bozz'``."

#: ../../library/logging.config.rst:570
msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above example "
"should not be configuration dictionaries or references such as ``cfg://foo`` "
"or ``ext://bar``, because they will not be processed by the configuration "
"machinery, but set as attribute values as-is."
msgstr ""
"Значения таких атрибутов, как ``foo`` и ``baz`` в приведенном выше примере, "
"не должны быть словарями конфигурации или ссылками, такими как ``cfg://foo`` "
"или ``ext://bar``, поскольку они не будут обрабатываться механизмом "
"настройки, а будут установлены как значения атрибутов как есть."

#: ../../library/logging.config.rst:579
msgid "Handler configuration order"
msgstr "Порядок настройки обработчика"

#: ../../library/logging.config.rst:581
msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working copy "
"of) the ``handlers`` dictionary in the schema. If you use a construct such "
"as ``cfg://handlers.foo``, then initially ``handlers['foo']`` points to the "
"configuration dictionary for the handler named ``foo``, and later (once that "
"handler has been configured) it points to the configured handler instance. "
"Thus, ``cfg://handlers.foo`` could resolve to either a dictionary or a "
"handler instance. In general, it is wise to name handlers in a way such that "
"dependent handlers are configured _after_ any handlers they depend on; that "
"allows something like ``cfg://handlers.foo`` to be used in configuring a "
"handler that depends on handler ``foo``. If that dependent handler were "
"named ``bar``, problems would result, because the configuration of ``bar`` "
"would be attempted before that of ``foo``, and ``foo`` would not yet have "
"been configured. However, if the dependent handler were named ``foobar``, it "
"would be configured after ``foo``, with the result that ``cfg://handlers."
"foo`` would resolve to configured handler ``foo``, and not its configuration "
"dictionary."
msgstr ""
"Обработчики настраиваются в алфавитном порядке своих ключей, и настроенный "
"обработчик заменяет словарь конфигурации (рабочую копию) словаря "
"``handlers`` в схеме. Если вы используете такую ​​конструкцию, как ``cfg://"
"handlers.foo``, то первоначально ``handlers['foo']`` указывает на словарь "
"конфигурации для обработчика с именем ``foo``, а позже (однажды этот "
"обработчик настроен) он указывает на настроенный экземпляр обработчика. "
"Таким образом, ``cfg://handlers.foo`` может быть преобразован либо в "
"словарь, либо в экземпляр обработчика. В общем, разумно называть обработчики "
"таким образом, чтобы зависимые обработчики настраивались _после_ любых "
"обработчиков, от которых они зависят; это позволяет использовать что-то "
"вроде ``cfg://handlers.foo`` при настройке обработчика, который зависит от "
"обработчика ``foo``. Если бы этот зависимый обработчик был назван ``bar``, "
"возникли бы проблемы, поскольку попытка настройки ``bar`` была предпринята "
"раньше, чем ``foo``, а ``foo`` еще не был настроен. Однако, если бы "
"зависимый обработчик назывался ``foobar``, он был бы настроен после ``foo``, "
"в результате чего ``cfg://handlers.foo`` будет преобразован в настроенный "
"обработчик ``foo``. , а не его словарь конфигурации."

#: ../../library/logging.config.rst:602
msgid "Access to external objects"
msgstr "Доступ к внешним объектам"

#: ../../library/logging.config.rst:604
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"Бывают случаи, когда конфигурация должна ссылаться на внешние по отношению к "
"конфигурации объекты, например ``sys.stderr``. Если словарь конфигурации "
"создан с использованием кода Python, это просто, но возникает проблема, "
"когда конфигурация предоставляется через текстовый файл (например, JSON, "
"YAML). В текстовом файле не существует стандартного способа отличить ``sys."
"stderr`` от буквальной строки ``'sys.stderr'``. Чтобы облегчить это "
"различие, система конфигурации ищет определенные специальные префиксы в "
"строковых значениях и обрабатывает их особым образом. Например, если "
"литеральная строка ext://sys.stderr указана в качестве значения в "
"конфигурации, то ext:// будет удален, а оставшаяся часть значения будет "
"обработана. используя обычные механизмы импорта."

#: ../../library/logging.config.rst:617
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"Обработка таких префиксов осуществляется аналогично обработке протоколов: "
"существует общий механизм поиска префиксов, соответствующих регулярному "
"выражению ``^(?P<prefix>[az]+)://(?P< suffix>.*)$``, при этом, если "
"``префикс`` распознан, ``суффикс`` обрабатывается в зависимости от префикса, "
"и результат обработки заменяет строковое значение. Если префикс не "
"распознан, строковое значение останется как есть."

#: ../../library/logging.config.rst:629
msgid "Access to internal objects"
msgstr "Доступ к внутренним объектам"

#: ../../library/logging.config.rst:631
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"Помимо внешних объектов иногда возникает необходимость обратиться к объектам "
"в конфигурации. Это будет сделано неявно системой конфигурации для вещей, о "
"которых она знает. Например, строковое значение ``'DEBUG'`` для ``level`` в "
"средстве ведения журнала или обработчике будет автоматически преобразовано в "
"значение ``logging.DEBUG``, а ``handlers``, `` Записи filter и formatter "
"принимают идентификатор объекта и преобразуются в соответствующий целевой "
"объект."

#: ../../library/logging.config.rst:639
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"Однако для пользовательских объектов, которые неизвестны модулю :mod:"
"`logging`, необходим более общий механизм. Например, рассмотрим :class:"
"`logging.handlers.MemoryHandler`, который принимает аргумент ``target``, "
"который является еще одним обработчиком, которому можно делегировать. "
"Поскольку система уже знает об этом классе, то в конфигурации заданная "
"«цель» просто должна быть идентификатором объекта соответствующего целевого "
"обработчика, и система разрешит обработчик на основе идентификатора. Однако "
"если пользователь определяет my.package.MyHandler, который имеет "
"альтернативный обработчик, система конфигурации не будет знать, что "
"альтернативный обработчик относится к обработчику. Чтобы удовлетворить эту "
"потребность, универсальная система разрешения позволяет пользователю указать:"

#: ../../library/logging.config.rst:651
msgid ""
"handlers:\n"
"  file:\n"
"    # configuration of file handler goes here\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"
msgstr ""
"handlers:\n"
"  file:\n"
"    # configuration of file handler goes here\n"
"\n"
"  custom:\n"
"    (): my.package.MyHandler\n"
"    alternate: cfg://handlers.file"

#: ../../library/logging.config.rst:661
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"Литеральная строка ``'cfg://handlers.file'`` будет разрешена аналогично "
"строкам с префиксом ``ext://``, но при этом будет учитываться сама "
"конфигурация, а не пространство имен импорта. Этот механизм позволяет доступ "
"по точке или по индексу, аналогично тому, как это предусмотрено в ``str."
"format``. Таким образом, учитывая следующий фрагмент:"

#: ../../library/logging.config.rst:667
msgid ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."
msgstr ""
"handlers:\n"
"  email:\n"
"    class: logging.handlers.SMTPHandler\n"
"    mailhost: localhost\n"
"    fromaddr: my_app@domain.tld\n"
"    toaddrs:\n"
"      - support_team@domain.tld\n"
"      - dev_team@domain.tld\n"
"    subject: Houston, we have a problem."

#: ../../library/logging.config.rst:679
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string ``'cfg://handlers.email."
"toaddrs[0]'`` would resolve to the value ``'support_team@domain.tld'``. The "
"``subject`` value could be accessed using either ``'cfg://handlers.email."
"subject'`` or, equivalently, ``'cfg://handlers.email[subject]'``.  The "
"latter form only needs to be used if the key contains spaces or non-"
"alphanumeric characters.  If an index value consists only of decimal digits, "
"access will be attempted using the corresponding integer value, falling back "
"to the string value if needed."
msgstr ""
"в конфигурации строка ``'cfg://handlers'`` будет разрешаться в словарь с "
"ключом ``handlers``, строка ``'cfg://handlers.email`` будет разрешаться в "
"словарь с ключом ``handlers``. ключ ``email`` в ``handlers`` и так далее. "
"Строка ``'cfg://handlers.email.toaddrs[1]`` будет преобразована в "
"``'dev_team@domain.tld'``, а строка ``'cfg://handlers.email.toaddrs[0 ]'`` "
"будет преобразовано в значение ``'support_team@domain.tld'``. Доступ к "
"значению ``subject`` можно получить, используя ``'cfg://handlers.email."
"subject'`` или, что то же самое, ``'cfg://handlers.email[subject]'``. "
"Последнюю форму необходимо использовать только в том случае, если ключ "
"содержит пробелы или небуквенно-цифровые символы. Если значение индекса "
"состоит только из десятичных цифр, будет предпринята попытка доступа с "
"использованием соответствующего целочисленного значения, при необходимости "
"возвращаясь к строковому значению."

#: ../../library/logging.config.rst:693
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"Учитывая строку ``cfg://handlers.myhandler.mykey.123``, она будет "
"преобразована в ``config_dict['handlers']['myhandler']['mykey']['123']``. "
"Если строка указана как ``cfg://handlers.myhandler.mykey[123]``, система "
"попытается получить значение из ``config_dict['handlers']['myhandler']"
"['mykey'] [123]`` и вернуться к ``config_dict['handlers']['myhandler']"
"['mykey']['123']``, если это не удастся."

#: ../../library/logging.config.rst:705
msgid "Import resolution and custom importers"
msgstr "Разрешение импорта и пользовательские импортеры"

#: ../../library/logging.config.rst:707
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"Разрешение импорта по умолчанию использует встроенную функцию :func:"
"`__import__` для импорта. Возможно, вы захотите заменить это своим "
"собственным механизмом импорта: если да, то вы можете заменить атрибут :attr:"
"`importer` класса :class:`DictConfigurator` или его суперкласса, класса :"
"class:`BaseConfigurator`. Однако вам следует быть осторожным из-за способа "
"доступа к функциям из классов через дескрипторы. Если вы используете "
"вызываемую функцию Python для импорта и хотите определить ее на уровне "
"класса, а не на уровне экземпляра, вам необходимо обернуть ее с помощью :"
"func:`staticmethod`. Например::"

#: ../../library/logging.config.rst:717
msgid ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"
msgstr ""
"from importlib import import_module\n"
"from logging.config import BaseConfigurator\n"
"\n"
"BaseConfigurator.importer = staticmethod(import_module)"

#: ../../library/logging.config.rst:722
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr ""
"Вам не нужно использовать :func:`staticmethod`, если вы устанавливаете "
"вызываемый объект импорта в *экземпляре* конфигуратора."

#: ../../library/logging.config.rst:728
msgid "Configuring QueueHandler and QueueListener"
msgstr "Настройка QueueHandler и QueueListener"

#: ../../library/logging.config.rst:730
msgid ""
"If you want to configure a :class:`~logging.handlers.QueueHandler`, noting "
"that this is normally used in conjunction with a :class:`~logging.handlers."
"QueueListener`, you can configure both together. After the configuration, "
"the ``QueueListener`` instance will be available as the :attr:`~logging."
"handlers.QueueHandler.listener` attribute of the created handler, and that "
"in turn will be available to you using :func:`~logging.getHandlerByName` and "
"passing the name you have used for the ``QueueHandler`` in your "
"configuration. The dictionary schema for configuring the pair is shown in "
"the example YAML snippet below."
msgstr ""
"Если вы хотите настроить :class:`~logging.handlers.QueueHandler`, учитывая, "
"что он обычно используется вместе с :class:`~logging.handlers."
"QueueListener`, вы можете настроить оба вместе. После настройки экземпляр "
"QueueListener будет доступен как атрибут :attr:`~logging.handlers."
"QueueHandler.listener` созданного обработчика, а он, в свою очередь, будет "
"доступен вам с помощью :func:`~ logging.getHandlerByName` и передав имя, "
"которое вы использовали для QueueHandler`` в вашей конфигурации. Схема "
"словаря для настройки пары показана в примере фрагмента YAML ниже."

#: ../../library/logging.config.rst:739
msgid ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."
msgstr ""
"handlers:\n"
"  qhand:\n"
"    class: logging.handlers.QueueHandler\n"
"    queue: my.module.queue_factory\n"
"    listener: my.package.CustomListener\n"
"    handlers:\n"
"      - hand_name_1\n"
"      - hand_name_2\n"
"      ..."

#: ../../library/logging.config.rst:751
msgid "The ``queue`` and ``listener`` keys are optional."
msgstr "Ключи ``queue`` и ``listener`` являются необязательными."

#: ../../library/logging.config.rst:753
msgid ""
"If the ``queue`` key is present, the corresponding value can be one of the "
"following:"
msgstr ""
"Если присутствует ключ очереди, соответствующее значение может быть одним из "
"следующих:"

#: ../../library/logging.config.rst:755
msgid ""
"An object implementing the :meth:`Queue.put_nowait <queue.Queue.put_nowait>` "
"and :meth:`Queue.get <queue.Queue.get>` public API. For instance, this may "
"be an actual instance of :class:`queue.Queue` or a subclass thereof, or a "
"proxy obtained by :meth:`multiprocessing.managers.SyncManager.Queue`."
msgstr ""
"Объект, реализующий общедоступный API :meth:`Queue.put_nowait <queue.Queue."
"put_nowait>` и :meth:`Queue.get <queue.Queue.get>`. Например, это может быть "
"реальный экземпляр :class:`queue.Queue` или его подкласса, или прокси, "
"полученный :meth:`multiprocessing.managers.SyncManager.Queue`."

#: ../../library/logging.config.rst:760
msgid ""
"This is of course only possible if you are constructing or modifying the "
"configuration dictionary in code."
msgstr ""
"Конечно, это возможно только в том случае, если вы создаете или изменяете "
"словарь конфигурации в коде."

#: ../../library/logging.config.rst:763
msgid ""
"A string that resolves to a callable which, when called with no arguments, "
"returns the queue instance to use. That callable could be a :class:`queue."
"Queue` subclass or a function which returns a suitable queue instance, such "
"as ``my.module.queue_factory()``."
msgstr ""
"Строка, которая преобразуется в вызываемый объект, который при вызове без "
"аргументов возвращает экземпляр очереди для использования. Этот вызываемый "
"объект может быть подклассом :class:`queue.Queue` или функцией, которая "
"возвращает подходящий экземпляр очереди, например ``my.module."
"queue_factory()``."

#: ../../library/logging.config.rst:768
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a :class:`queue.Queue` instance."
msgstr ""
"Дикт с ключом ``'()'``, который создается обычным способом, как описано в :"
"ref:`logging-config-dict-userdef`. Результатом этой конструкции должен быть "
"экземпляр :class:`queue.Queue`."

#: ../../library/logging.config.rst:772
msgid ""
"If the  ``queue`` key is absent, a standard unbounded :class:`queue.Queue` "
"instance is created and used."
msgstr ""
"Если ключ ``queue`` отсутствует, создается и используется стандартный "
"неограниченный экземпляр :class:`queue.Queue`."

#: ../../library/logging.config.rst:775
msgid ""
"If the ``listener`` key is present, the corresponding value can be one of "
"the following:"
msgstr ""
"Если присутствует ключ ``listener``, соответствующее значение может быть "
"одним из следующих:"

#: ../../library/logging.config.rst:777
msgid ""
"A subclass of :class:`logging.handlers.QueueListener`. This is of course "
"only possible if you are constructing or modifying the configuration "
"dictionary in code."
msgstr ""
"Подкласс :class:`logging.handlers.QueueListener`. Конечно, это возможно "
"только в том случае, если вы создаете или изменяете словарь конфигурации в "
"коде."

#: ../../library/logging.config.rst:781
msgid ""
"A string which resolves to a class which is a subclass of ``QueueListener``, "
"such as ``'my.package.CustomListener'``."
msgstr ""
"Строка, которая разрешается в класс, который является подклассом "
"QueueListener, например my.package.CustomListener."

#: ../../library/logging.config.rst:784
msgid ""
"A dict with a ``'()'`` key which is constructed in the usual way as "
"discussed in :ref:`logging-config-dict-userdef`. The result of this "
"construction should be a callable with the same signature as the "
"``QueueListener`` initializer."
msgstr ""
"Дикт с ключом ``'()'``, который создается обычным способом, как описано в :"
"ref:`logging-config-dict-userdef`. Результатом этой конструкции должен быть "
"вызываемый объект с той же сигнатурой, что и инициализатор QueueListener."

#: ../../library/logging.config.rst:788
msgid ""
"If the ``listener`` key is absent, :class:`logging.handlers.QueueListener` "
"is used."
msgstr ""
"Если ключ ``listener`` отсутствует, используется :class:`logging.handlers."
"QueueListener`."

#: ../../library/logging.config.rst:790
msgid ""
"The values under the ``handlers`` key are the names of other handlers in the "
"configuration (not shown in the above snippet) which will be passed to the "
"queue listener."
msgstr ""
"Значения под ключом handlers — это имена других обработчиков в конфигурации "
"(не показаны в приведенном выше фрагменте), которые будут переданы "
"прослушивателю очереди."

#: ../../library/logging.config.rst:794
msgid ""
"Any custom queue handler and listener classes will need to be defined with "
"the same initialization signatures as :class:`~logging.handlers."
"QueueHandler` and :class:`~logging.handlers.QueueListener`."
msgstr ""
"Любые пользовательские классы обработчиков и прослушивателей очереди должны "
"быть определены с теми же сигнатурами инициализации, что и :class:`~logging."
"handlers.QueueHandler` и :class:`~logging.handlers.QueueListener`."

#: ../../library/logging.config.rst:803
msgid "Configuration file format"
msgstr "Формат файла конфигурации"

#: ../../library/logging.config.rst:805
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
"Формат файла конфигурации, понимаемый :func:`fileConfig`, основан на "
"функциональности :mod:`configparser`. Файл должен содержать разделы под "
"названием ``[loggers]``, ``[handlers]`` и ``[formatters]``, которые "
"идентифицируют по имени сущности каждого типа, определенные в файле. Для "
"каждого такого объекта существует отдельный раздел, в котором указывается, "
"как этот объект настроен. Таким образом, для регистратора с именем ``log01`` "
"в разделе ``[loggers]`` соответствующие детали конфигурации хранятся в "
"разделе ``[logger_log01]``. Аналогично, конфигурация обработчика с именем "
"«hand01» в разделе «[handlers]» будет храниться в разделе с именем "
"«[handler_hand01]», а форматировщика с именем «form01» в разделе « "
"Конфигурация раздела [formatters]`` будет указана в разделе под названием "
"``[formatter_form01]``. Конфигурация корневого регистратора должна быть "
"указана в разделе ``[logger_root]``."

#: ../../library/logging.config.rst:820
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
"API :func:`fileConfig` старше API :func:`dictConfig` и не предоставляет "
"функций, охватывающих определенные аспекты ведения журналов. Например, вы не "
"можете настроить объекты :class:`~logging.Filter`, которые обеспечивают "
"фильтрацию сообщений за пределами простых целочисленных уровней, используя :"
"func:`fileConfig`. Если вам нужно иметь экземпляры :class:`~logging.Filter` "
"в вашей конфигурации ведения журнала, вам нужно будет использовать :func:"
"`dictConfig`. Обратите внимание, что будущие улучшения функциональности "
"конфигурации будут добавлены в :func:`dictConfig`, поэтому стоит рассмотреть "
"возможность перехода на этот новый API, когда это будет удобно."

#: ../../library/logging.config.rst:830
msgid "Examples of these sections in the file are given below."
msgstr "Примеры этих разделов в файле приведены ниже."

#: ../../library/logging.config.rst:832
msgid ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"
msgstr ""
"[loggers]\n"
"keys=root,log02,log03,log04,log05,log06,log07\n"
"\n"
"[handlers]\n"
"keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09\n"
"\n"
"[formatters]\n"
"keys=form01,form02,form03,form04,form05,form06,form07,form08,form09"

#: ../../library/logging.config.rst:843
msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr ""
"Корневой регистратор должен указать уровень и список обработчиков. Ниже "
"приведен пример раздела корневого регистратора."

#: ../../library/logging.config.rst:846
msgid ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"
msgstr ""
"[logger_root]\n"
"level=NOTSET\n"
"handlers=hand01"

#: ../../library/logging.config.rst:852
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :ref:`evaluated <func-eval>` in the context "
"of the ``logging`` package's namespace."
msgstr ""
"Запись ``level`` может быть одной из ``DEBUG, INFO, WARNING, ERROR, "
"CRITICAL`` или ``NOTSET``. Только для корневого регистратора ``NOTSET`` "
"означает, что все сообщения будут регистрироваться. Значения уровня :ref:"
"`оцениваются <func-eval>` в контексте пространства имен пакета ``logging``."

#: ../../library/logging.config.rst:857
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"Запись ``handlers`` представляет собой список имен обработчиков, разделенных "
"запятыми, который должен появиться в разделе ``[handlers]``. Эти имена "
"должны появиться в разделе ``[handlers]`` и иметь соответствующие разделы в "
"файле конфигурации."

#: ../../library/logging.config.rst:862
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr ""
"Для регистраторов, отличных от корневого, требуется некоторая дополнительная "
"информация. Это иллюстрируется следующим примером."

#: ../../library/logging.config.rst:865
msgid ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"
msgstr ""
"[logger_parser]\n"
"level=DEBUG\n"
"handlers=hand01\n"
"propagate=1\n"
"qualname=compiler.parser"

#: ../../library/logging.config.rst:873
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"Записи ``level`` и ``handlers`` интерпретируются как для корневого "
"регистратора, за исключением того, что если уровень некорневого регистратора "
"указан как ``NOTSET``, система консультируется с регистраторами более "
"высокого уровня в иерархии, чтобы определить эффективный уровень логгера. "
"Для записи ``propagate`` установлено значение 1, чтобы указать, что "
"сообщения должны распространяться обработчикам выше по иерархии регистратора "
"из этого регистратора, или 0, чтобы указать, что сообщения **не** "
"распространяются обработчикам выше по иерархии. Запись ``qualname`` "
"представляет собой иерархическое имя канала регистратора, то есть имя, "
"используемое приложением для получения регистратора."

#: ../../library/logging.config.rst:882
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr ""
"Ниже приведены примеры разделов, определяющих конфигурацию обработчика."

#: ../../library/logging.config.rst:884
msgid ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"
msgstr ""
"[handler_hand01]\n"
"class=StreamHandler\n"
"level=NOTSET\n"
"formatter=form01\n"
"args=(sys.stdout,)"

#: ../../library/logging.config.rst:892
msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"Запись ``class`` указывает класс обработчика (как определено :func:`eval` в "
"пространстве имен пакета ``logging``). «Уровень» интерпретируется как для "
"регистраторов, а «NOTSET» означает «регистрировать все»."

#: ../../library/logging.config.rst:896
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"Запись ``formatter`` указывает имя ключа форматтера для этого обработчика. "
"Если это поле пусто, используется форматтер по умолчанию (``logging."
"_defaultFormatter``). Если указано имя, оно должно появиться в разделе "
"``[formatters]`` и иметь соответствующий раздел в файле конфигурации."

#: ../../library/logging.config.rst:901
msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""
"Запись ``args``, когда :ref:`оценивается <func-eval>` в контексте "
"пространства имен пакета ``logging``, представляет собой список аргументов "
"конструктора для класса-обработчика. Обратитесь к конструкторам "
"соответствующих обработчиков или к примерам ниже, чтобы увидеть, как "
"создаются типичные записи. Если не указано, по умолчанию используется ``()``."

#: ../../library/logging.config.rst:907
msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument dict "
"to the constructor for the handler class. If not provided, it defaults to "
"``{}``."
msgstr ""
"Запись ``args``, когда :ref:`оценивается <func-eval>` в контексте "
"пространства имен пакета ``logging``, представляет собой список аргументов "
"конструктора для класса-обработчика. Обратитесь к конструкторам "
"соответствующих обработчиков или к примерам ниже, чтобы увидеть, как "
"создаются типичные записи. Если не указано, по умолчанию используется ``()``."

#: ../../library/logging.config.rst:911
msgid ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler."
"LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger "
"Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"
msgstr ""
"[handler_hand02]\n"
"class=FileHandler\n"
"level=DEBUG\n"
"formatter=form02\n"
"args=('python.log', 'w')\n"
"\n"
"[handler_hand03]\n"
"class=handlers.SocketHandler\n"
"level=INFO\n"
"formatter=form03\n"
"args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"\n"
"[handler_hand04]\n"
"class=handlers.DatagramHandler\n"
"level=WARN\n"
"formatter=form04\n"
"args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)\n"
"\n"
"[handler_hand05]\n"
"class=handlers.SysLogHandler\n"
"level=ERROR\n"
"formatter=form05\n"
"args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler."
"LOG_USER)\n"
"\n"
"[handler_hand06]\n"
"class=handlers.NTEventLogHandler\n"
"level=CRITICAL\n"
"formatter=form06\n"
"args=('Python Application', '', 'Application')\n"
"\n"
"[handler_hand07]\n"
"class=handlers.SMTPHandler\n"
"level=WARN\n"
"formatter=form07\n"
"args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger "
"Subject')\n"
"kwargs={'timeout': 10.0}\n"
"\n"
"[handler_hand08]\n"
"class=handlers.MemoryHandler\n"
"level=NOTSET\n"
"formatter=form08\n"
"target=\n"
"args=(10, ERROR)\n"
"\n"
"[handler_hand09]\n"
"class=handlers.HTTPHandler\n"
"level=NOTSET\n"
"formatter=form09\n"
"args=('localhost:9022', '/log', 'GET')\n"
"kwargs={'secure': True}"

#: ../../library/logging.config.rst:964
msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr "Разделы, определяющие конфигурацию форматтера, имеют следующий вид."

#: ../../library/logging.config.rst:966
msgid ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"
msgstr ""
"[formatter_form01]\n"
"format=F1 %(asctime)s %(levelname)s %(message)s %(customfield)s\n"
"datefmt=\n"
"style=%\n"
"validate=True\n"
"defaults={'customfield': 'defaultvalue'}\n"
"class=logging.Formatter"

#: ../../library/logging.config.rst:976
msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
"Аргументы для конфигурации форматтера такие же, как ключи в схеме словаря :"
"ref:`раздел форматтеров <logging-config-dictschema-formatters>`."

#: ../../library/logging.config.rst:980
msgid ""
"The ``defaults`` entry, when :ref:`evaluated <func-eval>` in the context of "
"the ``logging`` package's namespace, is a dictionary of default values for "
"custom formatting fields. If not provided, it defaults to ``None``."
msgstr ""
"Запись ``defaults``, когда :ref:`оценивается <func-eval>` в контексте "
"пространства имен пакета ``logging``, представляет собой словарь значений по "
"умолчанию для пользовательских полей форматирования. Если он не указан, по "
"умолчанию используется значение «Нет»."

#: ../../library/logging.config.rst:987
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
"Из-за использования :func:`eval`, как описано выше, существуют потенциальные "
"риски безопасности, возникающие в результате использования :func:`listen` "
"для отправки и получения конфигураций через сокеты. Риски ограничиваются "
"случаями, когда несколько пользователей без взаимного доверия запускают код "
"на одном компьютере; дополнительную информацию смотрите в документации :func:"
"`listen`."

#: ../../library/logging.config.rst:995
msgid "Module :mod:`logging`"
msgstr "Модуль :mod:`logging`"

#: ../../library/logging.config.rst:996
msgid "API reference for the logging module."
msgstr "Ссылка на API для модуля ведения журнала."

#: ../../library/logging.config.rst:998
msgid "Module :mod:`logging.handlers`"
msgstr "Модуль :mod:`logging.handlers`"

#: ../../library/logging.config.rst:999
msgid "Useful handlers included with the logging module."
msgstr "Полезные обработчики, включенные в модуль журналирования."
