# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmitriy Q, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/multiprocessing.shared_memory.rst:2
msgid ""
":mod:`multiprocessing.shared_memory` --- Shared memory for direct access "
"across processes"
msgstr ""

#: ../../library/multiprocessing.shared_memory.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/shared_memory.py`"
msgstr "**Исходный код:** :source:`Lib/multiprocessing/shared_memory.py`"

#: ../../library/multiprocessing.shared_memory.rst:18
msgid ""
"This module provides a class, :class:`SharedMemory`, for the allocation and "
"management of shared memory to be accessed by one or more processes on a "
"multicore or symmetric multiprocessor (SMP) machine.  To assist with the "
"life-cycle management of shared memory especially across distinct processes, "
"a :class:`~multiprocessing.managers.BaseManager` subclass, :class:"
"`~multiprocessing.managers.SharedMemoryManager`, is also provided in the :"
"mod:`multiprocessing.managers` module."
msgstr ""
"Этот модуль предоставляет класс :class:`SharedMemory` для выделения и "
"управления общей памятью, к которой могут получить доступ один или несколько "
"процессов на многоядерной или симметричной многопроцессорной (SMP) машине. "
"Чтобы помочь в управлении жизненным циклом общей памяти, особенно в "
"отдельных процессах, в :mod: также предоставляется подкласс :class:"
"`~multiprocessing.managers.BaseManager`, :class:`~multiprocessing.managers."
"SharedMemoryManager`, :class:`~multiprocessing.managers."
"SharedMemoryManager`. Модуль `multiprocessing.managers`."

#: ../../library/multiprocessing.shared_memory.rst:26
msgid ""
"In this module, shared memory refers to \"POSIX style\" shared memory blocks "
"(though is not necessarily implemented explicitly as such) and does not "
"refer to \"distributed shared memory\".  This style of shared memory permits "
"distinct processes to potentially read and write to a common (or shared) "
"region of volatile memory.  Processes are conventionally limited to only "
"have access to their own process memory space but shared memory permits the "
"sharing of data between processes, avoiding the need to instead send "
"messages between processes containing that data.  Sharing data directly via "
"memory can provide significant performance benefits compared to sharing data "
"via disk or socket or other communications requiring the serialization/"
"deserialization and copying of data."
msgstr ""
"В этом модуле общая память относится к блокам общей памяти в стиле POSIX "
"(хотя не обязательно реализуется явно как таковая) и не относится к "
"«распределенной общей памяти». Этот стиль общей памяти позволяет различным "
"процессам потенциально читать и записывать в общую (или разделяемую) область "
"энергозависимой памяти. Процессы традиционно ограничены доступом только к "
"своему собственному пространству памяти процесса, но общая память позволяет "
"совместно использовать данные между процессами, избегая необходимости вместо "
"этого отправлять сообщения между процессами, содержащими эти данные. "
"Совместное использование данных непосредственно через память может "
"обеспечить значительный выигрыш в производительности по сравнению с "
"совместным использованием данных через диск или сокет или другие средства "
"связи, требующие сериализации/десериализации и копирования данных."

#: ../../library/multiprocessing.shared_memory.rst:41
msgid ""
"Create an instance of the :class:`!SharedMemory` class for either creating a "
"new shared memory block or attaching to an existing shared memory block.  "
"Each shared memory block is assigned a unique name. In this way, one process "
"can create a shared memory block with a particular name and a different "
"process can attach to that same shared memory block using that same name."
msgstr ""
"Создайте экземпляр класса :class:`!SharedMemory` для создания нового блока "
"общей памяти или присоединения к существующему блоку общей памяти. Каждому "
"блоку общей памяти присваивается уникальное имя. Таким образом, один процесс "
"может создать блок общей памяти с определенным именем, а другой процесс "
"может подключиться к этому же блоку общей памяти, используя то же имя."

#: ../../library/multiprocessing.shared_memory.rst:48
msgid ""
"As a resource for sharing data across processes, shared memory blocks may "
"outlive the original process that created them.  When one process no longer "
"needs access to a shared memory block that might still be needed by other "
"processes, the :meth:`close` method should be called. When a shared memory "
"block is no longer needed by any process, the :meth:`unlink` method should "
"be called to ensure proper cleanup."
msgstr ""
"В качестве ресурса для совместного использования данных между процессами "
"блоки общей памяти могут пережить исходный процесс, который их создал. Когда "
"одному процессу больше не нужен доступ к блоку общей памяти, который все еще "
"может понадобиться другим процессам, следует вызвать метод :meth:`close`. "
"Когда блок общей памяти больше не нужен какому-либо процессу, следует "
"вызвать метод :meth:`unlink`, чтобы обеспечить правильную очистку."

#: ../../library/multiprocessing.shared_memory.rst:0
msgid "Parameters"
msgstr "Параметры"

#: ../../library/multiprocessing.shared_memory.rst:55
msgid ""
"The unique name for the requested shared memory, specified as a string. When "
"creating a new shared memory block, if ``None`` (the default) is supplied "
"for the name, a novel name will be generated."
msgstr ""
"Уникальное имя запрошенной общей памяти в виде строки. Если при создании "
"нового блока общей памяти для имени указано «Нет» (по умолчанию), будет "
"сгенерировано новое имя."

#: ../../library/multiprocessing.shared_memory.rst:61
msgid ""
"Control whether a new shared memory block is created (``True``) or an "
"existing shared memory block is attached (``False``)."
msgstr ""
"Контролируйте, создается ли новый блок общей памяти («True») или "
"присоединяется существующий блок общей памяти («False»)."

#: ../../library/multiprocessing.shared_memory.rst:65
msgid ""
"The requested number of bytes when creating a new shared memory block. "
"Because some platforms choose to allocate chunks of memory based upon that "
"platform's memory page size, the exact size of the shared memory block may "
"be larger or equal to the size requested. When attaching to an existing "
"shared memory block, the *size* parameter is ignored."
msgstr ""
"Запрошенное количество байтов при создании нового блока общей памяти. "
"Поскольку некоторые платформы предпочитают выделять фрагменты памяти в "
"зависимости от размера страницы памяти этой платформы, точный размер блока "
"общей памяти может быть больше или равен запрошенному размеру. При "
"присоединении к существующему блоку общей памяти параметр *size* "
"игнорируется."

#: ../../library/multiprocessing.shared_memory.rst:75
msgid ""
"Close access to the shared memory from this instance.  In order to ensure "
"proper cleanup of resources, all instances should call :meth:`close` once "
"the instance is no longer needed.  Note that calling :meth:`!close` does not "
"cause the shared memory block itself to be destroyed."
msgstr ""
"Закройте доступ к общей памяти из этого экземпляра. Чтобы обеспечить "
"правильную очистку ресурсов, все экземпляры должны вызывать :meth:`close`, "
"как только экземпляр больше не нужен. Обратите внимание, что вызов :meth:`!"
"close` не приводит к уничтожению самого блока общей памяти."

#: ../../library/multiprocessing.shared_memory.rst:83
msgid ""
"Request that the underlying shared memory block be destroyed.  In order to "
"ensure proper cleanup of resources, :meth:`unlink` should be called once "
"(and only once) across all processes which have need for the shared memory "
"block.  After requesting its destruction, a shared memory block may or may "
"not be immediately destroyed and this behavior may differ across platforms.  "
"Attempts to access data inside the shared memory block after :meth:`!unlink` "
"has been called may result in memory access errors.  Note: the last process "
"relinquishing its hold on a shared memory block may call :meth:`!unlink` "
"and :meth:`close` in either order."
msgstr ""
"Запросить уничтожение основного блока общей памяти. Чтобы обеспечить "
"правильную очистку ресурсов, :meth:`unlink` следует вызывать один раз (и "
"только один раз) для всех процессов, которым необходим блок общей памяти. "
"После запроса на уничтожение блок общей памяти может быть уничтожен, а может "
"и не быть немедленно уничтожен, и это поведение может различаться на разных "
"платформах. Попытки доступа к данным внутри блока общей памяти после вызова :"
"meth:`!unlink` могут привести к ошибкам доступа к памяти. Примечание: "
"последний процесс, освобождающий блок общей памяти, может вызвать :meth:`!"
"unlink` и :meth:`close` в любом порядке."

#: ../../library/multiprocessing.shared_memory.rst:96
msgid "A memoryview of contents of the shared memory block."
msgstr "Просмотр содержимого блока общей памяти."

#: ../../library/multiprocessing.shared_memory.rst:100
msgid "Read-only access to the unique name of the shared memory block."
msgstr "Доступ только для чтения к уникальному имени общего блока памяти."

#: ../../library/multiprocessing.shared_memory.rst:104
msgid "Read-only access to size in bytes of the shared memory block."
msgstr "Доступ только для чтения к размеру блока общей памяти в байтах."

#: ../../library/multiprocessing.shared_memory.rst:107
msgid ""
"The following example demonstrates low-level use of :class:`SharedMemory` "
"instances::"
msgstr ""
"Следующий пример демонстрирует низкоуровневое использование экземпляров :"
"class:`SharedMemory`::"

#: ../../library/multiprocessing.shared_memory.rst:133
msgid ""
"The following example demonstrates a practical use of the :class:"
"`SharedMemory` class with `NumPy arrays <https://numpy.org/>`_, accessing "
"the same :class:`!numpy.ndarray` from two distinct Python shells:"
msgstr ""
"В следующем примере показано практическое использование класса :class:"
"`SharedMemory` с `массивами NumPy <https://numpy.org/>`_, доступ к одному и "
"тому же :class:`!numpy.ndarray` из двух разных оболочек Python. :"

#: ../../library/multiprocessing.shared_memory.rst:187
msgid ""
"A subclass of :class:`multiprocessing.managers.BaseManager` which can be "
"used for the management of shared memory blocks across processes."
msgstr ""
"Подкласс :class:`multiprocessing.managers.BaseManager`, который можно "
"использовать для управления блоками общей памяти между процессами."

#: ../../library/multiprocessing.shared_memory.rst:190
msgid ""
"A call to :meth:`~multiprocessing.managers.BaseManager.start` on a :class:`!"
"SharedMemoryManager` instance causes a new process to be started. This new "
"process's sole purpose is to manage the life cycle of all shared memory "
"blocks created through it.  To trigger the release of all shared memory "
"blocks managed by that process, call :meth:`~multiprocessing.managers."
"BaseManager.shutdown` on the instance. This triggers a :meth:"
"`~multiprocessing.shared_memory.SharedMemory.unlink` call on all of the :"
"class:`SharedMemory` objects managed by that process and then stops the "
"process itself.  By creating :class:`!SharedMemory` instances through a :"
"class:`!SharedMemoryManager`, we avoid the need to manually track and "
"trigger the freeing of shared memory resources."
msgstr ""
"Вызов :meth:`~multiprocessing.managers.BaseManager.start` в экземпляре :"
"class:`!SharedMemoryManager` вызывает запуск нового процесса. Единственная "
"цель этого нового процесса — управлять жизненным циклом всех блоков общей "
"памяти, созданных с его помощью. Чтобы вызвать освобождение всех блоков "
"общей памяти, управляемых этим процессом, вызовите :meth:`~multiprocessing."
"managers.BaseManager.shutdown` на экземпляре. Это запускает вызов :meth:"
"`~multiprocessing.shared_memory.SharedMemory.unlink` для всех объектов :"
"class:`SharedMemory`, управляемых этим процессом, а затем останавливает сам "
"процесс. Создавая экземпляры :class:`!SharedMemory` с помощью :class:`!"
"SharedMemoryManager`, мы избегаем необходимости вручную отслеживать и "
"запускать освобождение ресурсов общей памяти."

#: ../../library/multiprocessing.shared_memory.rst:202
msgid ""
"This class provides methods for creating and returning :class:`SharedMemory` "
"instances and for creating a list-like object (:class:`ShareableList`) "
"backed by shared memory."
msgstr ""
"Этот класс предоставляет методы для создания и возврата экземпляров :class:"
"`SharedMemory` и для создания объекта, подобного списку (:class:"
"`ShareableList`), поддерживаемого общей памятью."

#: ../../library/multiprocessing.shared_memory.rst:206
msgid ""
"Refer to :class:`~multiprocessing.managers.BaseManager` for a description of "
"the inherited *address* and *authkey* optional input arguments and how they "
"may be used to connect to an existing :class:`!SharedMemoryManager` service "
"from other processes."
msgstr ""
"Обратитесь к :class:`~multiprocessing.managers.BaseManager` для описания "
"унаследованных необязательных входных аргументов *address* и *authkey* и "
"того, как их можно использовать для подключения к существующей службе :class:"
"`!SharedMemoryManager` из других процессы."

#: ../../library/multiprocessing.shared_memory.rst:213
msgid ""
"Create and return a new :class:`SharedMemory` object with the specified "
"*size* in bytes."
msgstr ""
"Создайте и верните новый объект :class:`SharedMemory` с указанным *размером* "
"в байтах."

#: ../../library/multiprocessing.shared_memory.rst:218
msgid ""
"Create and return a new :class:`ShareableList` object, initialized by the "
"values from the input *sequence*."
msgstr ""
"Создайте и верните новый объект :class:`ShareableList`, инициализированный "
"значениями из входной *последовательности*."

#: ../../library/multiprocessing.shared_memory.rst:222
msgid ""
"The following example demonstrates the basic mechanisms of a :class:"
"`~multiprocessing.managers.SharedMemoryManager`:"
msgstr ""
"Следующий пример демонстрирует основные механизмы :class:`~multiprocessing."
"managers.SharedMemoryManager`:"

#: ../../library/multiprocessing.shared_memory.rst:240
msgid ""
"The following example depicts a potentially more convenient pattern for "
"using :class:`~multiprocessing.managers.SharedMemoryManager` objects via "
"the :keyword:`with` statement to ensure that all shared memory blocks are "
"released after they are no longer needed:"
msgstr ""
"В следующем примере показан потенциально более удобный шаблон использования "
"объектов :class:`~multiprocessing.managers.SharedMemoryManager` через "
"оператор :keyword:`with`, чтобы гарантировать, что все блоки общей памяти "
"будут освобождены после того, как они больше не нужны:"

#: ../../library/multiprocessing.shared_memory.rst:259
msgid ""
"When using a :class:`~multiprocessing.managers.SharedMemoryManager` in a :"
"keyword:`with` statement, the shared memory blocks created using that "
"manager are all released when the :keyword:`!with` statement's code block "
"finishes execution."
msgstr ""
"При использовании :class:`~multiprocessing.managers.SharedMemoryManager` в "
"операторе :keyword:`with` все блоки общей памяти, созданные с помощью этого "
"менеджера, освобождаются, когда блок кода оператора :keyword:`!with` "
"завершает выполнение."

#: ../../library/multiprocessing.shared_memory.rst:267
msgid ""
"Provide a mutable list-like object where all values stored within are stored "
"in a shared memory block. This constrains storable values to the following "
"built-in data types:"
msgstr ""
"Предоставьте изменяемый объект, похожий на список, где все значения, "
"хранящиеся внутри, хранятся в блоке общей памяти. Это ограничивает "
"сохраняемые значения следующими встроенными типами данных:"

#: ../../library/multiprocessing.shared_memory.rst:271
msgid ":class:`int` (signed 64-bit)"
msgstr ":class:`int` (64-битный со знаком)"

#: ../../library/multiprocessing.shared_memory.rst:272
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/multiprocessing.shared_memory.rst:273
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../library/multiprocessing.shared_memory.rst:274
msgid ":class:`str` (less than 10M bytes each when encoded as UTF-8)"
msgstr ":class:`str` (менее 10 Мбайт каждый в кодировке UTF-8)"

#: ../../library/multiprocessing.shared_memory.rst:275
msgid ":class:`bytes` (less than 10M bytes each)"
msgstr ":class:`bytes` (менее 10 М байт каждый)"

#: ../../library/multiprocessing.shared_memory.rst:276
msgid "``None``"
msgstr "``None``"

#: ../../library/multiprocessing.shared_memory.rst:278
msgid ""
"It also notably differs from the built-in :class:`list` type in that these "
"lists can not change their overall length (i.e. no :meth:`!append`, :meth:`!"
"insert`, etc.) and do not support the dynamic creation of new :class:`!"
"ShareableList` instances via slicing."
msgstr ""
"Он также заметно отличается от встроенного типа :class:`list` тем, что эти "
"списки не могут изменять свою общую длину (т.е. нет :meth:`!append`, :meth:`!"
"insert` и т. д.) и не поддерживать динамическое создание новых экземпляров :"
"class:`!ShareableList` посредством нарезки."

#: ../../library/multiprocessing.shared_memory.rst:284
msgid ""
"*sequence* is used in populating a new :class:`!ShareableList` full of "
"values. Set to ``None`` to instead attach to an already existing :class:`!"
"ShareableList` by its unique shared memory name."
msgstr ""
"*sequence* используется для заполнения нового :class:`!ShareableList`, "
"полного значений. Установите значение None, чтобы вместо этого присоединить "
"его к уже существующему :class:`!ShareableList` по его уникальному имени "
"общей памяти."

#: ../../library/multiprocessing.shared_memory.rst:288
msgid ""
"*name* is the unique name for the requested shared memory, as described in "
"the definition for :class:`SharedMemory`.  When attaching to an existing :"
"class:`!ShareableList`, specify its shared memory block's unique name while "
"leaving *sequence* set to ``None``."
msgstr ""
"*name* — это уникальное имя запрошенной общей памяти, как описано в "
"определении :class:`SharedMemory`. При присоединении к существующему :class:"
"`!ShareableList` укажите уникальное имя его блока общей памяти, оставив для "
"*sequence* значение ``None``."

#: ../../library/multiprocessing.shared_memory.rst:295
msgid ""
"A known issue exists for :class:`bytes` and :class:`str` values. If they end "
"with ``\\x00`` nul bytes or characters, those may be *silently stripped* "
"when fetching them by index from the :class:`!ShareableList`. This ``."
"rstrip(b'\\x00')`` behavior is considered a bug and may go away in the "
"future. See :gh:`106939`."
msgstr ""
"Известная проблема существует для значений :class:`bytes` и :class:`str`. "
"Если они заканчиваются нулевыми байтами или символами ``\\x00``, они могут "
"быть *тихо удалены* при извлечении их по индексу из :class:`!ShareableList`. "
"Такое поведение ``.rstrip(b'\\x00')`` считается ошибкой и может исчезнуть в "
"будущем. См. :gh:`106939`."

#: ../../library/multiprocessing.shared_memory.rst:301
msgid ""
"For applications where rstripping of trailing nulls is a problem, work "
"around it by always unconditionally appending an extra non-0 byte to the end "
"of such values when storing and unconditionally removing it when fetching:"
msgstr ""
"Для приложений, где удаление конечных нулей является проблемой, обойдите ее, "
"всегда безоговорочно добавляя дополнительный байт, отличный от 0, в конец "
"таких значений при сохранении и безоговорочно удаляя его при выборке:"

#: ../../library/multiprocessing.shared_memory.rst:324
msgid "Return the number of occurrences of *value*."
msgstr "Возвращает количество вхождений *значения*."

#: ../../library/multiprocessing.shared_memory.rst:328
msgid ""
"Return first index position of *value*. Raise :exc:`ValueError` if *value* "
"is not present."
msgstr ""
"Вернуть первую позицию индекса *значения*. Поднимите :exc:`ValueError`, если "
"*value* отсутствует."

#: ../../library/multiprocessing.shared_memory.rst:333
msgid ""
"Read-only attribute containing the :mod:`struct` packing format used by all "
"currently stored values."
msgstr ""
"Атрибут только для чтения, содержащий формат упаковки :mod:`struct`, "
"используемый всеми сохраненными в данный момент значениями."

#: ../../library/multiprocessing.shared_memory.rst:338
msgid "The :class:`SharedMemory` instance where the values are stored."
msgstr "Экземпляр :class:`SharedMemory`, в котором хранятся значения."

#: ../../library/multiprocessing.shared_memory.rst:341
msgid ""
"The following example demonstrates basic use of a :class:`ShareableList` "
"instance:"
msgstr ""
"Следующий пример демонстрирует базовое использование экземпляра :class:"
"`ShareableList`:"

#: ../../library/multiprocessing.shared_memory.rst:374
msgid ""
"The following example depicts how one, two, or many processes may access the "
"same :class:`ShareableList` by supplying the name of the shared memory block "
"behind it:"
msgstr ""
"В следующем примере показано, как один, два или несколько процессов могут "
"получить доступ к одному и тому же :class:`ShareableList`, указав имя блока "
"общей памяти, стоящего за ним:"

#: ../../library/multiprocessing.shared_memory.rst:389
msgid ""
"The following examples demonstrates that :class:`ShareableList` (and "
"underlying :class:`SharedMemory`) objects can be pickled and unpickled if "
"needed. Note, that it will still be the same shared object. This happens, "
"because the deserialized object has the same unique name and is just "
"attached to an existing object with the same name (if the object is still "
"alive):"
msgstr ""
"Следующие примеры демонстрируют, что объекты :class:`ShareableList` (и "
"лежащие в их основе :class:`SharedMemory`) объекты могут быть пикированы и "
"расконсервированы при необходимости. Обратите внимание, что это все равно "
"будет тот же общий объект. Это происходит потому, что десериализованный "
"объект имеет то же уникальное имя и просто прикреплен к существующему "
"объекту с тем же именем (если объект еще жив):"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Shared Memory"
msgstr "Общая память"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "POSIX Shared Memory"
msgstr "Общая память POSIX"

#: ../../library/multiprocessing.shared_memory.rst:11
msgid "Named Shared Memory"
msgstr "Именованная общая память"
