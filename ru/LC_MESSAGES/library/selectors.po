# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/selectors.rst:2
msgid ":mod:`!selectors` --- High-level I/O multiplexing"
msgstr ":mod:`!selectors` --- Мультиплексирование ввода-вывода высокого уровня"

#: ../../library/selectors.rst:9
msgid "**Source code:** :source:`Lib/selectors.py`"
msgstr "**Исходный код:** :source:`Lib/selectors.py`"

#: ../../library/selectors.rst:14
msgid "Introduction"
msgstr "Введение"

#: ../../library/selectors.rst:16
msgid ""
"This module allows high-level and efficient I/O multiplexing, built upon "
"the :mod:`select` module primitives. Users are encouraged to use this module "
"instead, unless they want precise control over the OS-level primitives used."
msgstr ""
"Этот модуль обеспечивает высокоуровневое и эффективное мультиплексирование "
"ввода-вывода, основанное на примитивах модуля :mod:`select`. Вместо этого "
"пользователям рекомендуется использовать этот модуль, если только им не "
"нужен точный контроль над используемыми примитивами уровня ОС."

#: ../../library/selectors.rst:20
msgid ""
"It defines a :class:`BaseSelector` abstract base class, along with several "
"concrete implementations (:class:`KqueueSelector`, :class:"
"`EpollSelector`...), that can be used to wait for I/O readiness notification "
"on multiple file objects. In the following, \"file object\" refers to any "
"object with a :meth:`~io.IOBase.fileno` method, or a raw file descriptor. "
"See :term:`file object`."
msgstr ""
"Он определяет абстрактный базовый класс :class:`BaseSelector`, а также "
"несколько конкретных реализаций (:class:`KqueueSelector`, :class:"
"`EpollSelector`...), которые можно использовать для ожидания уведомления о "
"готовности ввода-вывода. несколько файловых объектов. Далее «файловый "
"объект» относится к любому объекту с методом :meth:`~io.IOBase.fileno` или к "
"необработанному файловому дескриптору. См. :term:`файловый объект`."

#: ../../library/selectors.rst:26
msgid ""
":class:`DefaultSelector` is an alias to the most efficient implementation "
"available on the current platform: this should be the default choice for "
"most users."
msgstr ""
":class:`DefaultSelector` — это псевдоним наиболее эффективной реализации, "
"доступной на текущей платформе: это должен быть выбор по умолчанию для "
"большинства пользователей."

#: ../../library/selectors.rst:31
msgid ""
"The type of file objects supported depends on the platform: on Windows, "
"sockets are supported, but not pipes, whereas on Unix, both are supported "
"(some other types may be supported as well, such as fifos or special file "
"devices)."
msgstr ""
"Тип поддерживаемых файловых объектов зависит от платформы: в Windows "
"поддерживаются сокеты, но не каналы, тогда как в Unix поддерживаются оба "
"(также могут поддерживаться некоторые другие типы, такие как fifo или "
"специальные файловые устройства)."

#: ../../library/selectors.rst:38
msgid ":mod:`select`"
msgstr ":mod:`select`"

#: ../../library/selectors.rst:39
msgid "Low-level I/O multiplexing module."
msgstr "Модуль низкоуровневого мультиплексирования ввода-вывода."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Доступность"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Этот модуль не работает или недоступен на платформах WebAssembly «wasm32-"
"emscripten» и «wasm32-wasi». См. :ref:`wasm-availability` для получения "
"дополнительной информации."

#: ../../library/selectors.rst:44
msgid "Classes"
msgstr "Классы"

#: ../../library/selectors.rst:46
msgid "Classes hierarchy::"
msgstr "Иерархия классов::"

#: ../../library/selectors.rst:48
msgid ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"
msgstr ""
"BaseSelector\n"
"+-- SelectSelector\n"
"+-- PollSelector\n"
"+-- EpollSelector\n"
"+-- DevpollSelector\n"
"+-- KqueueSelector"

#: ../../library/selectors.rst:56
msgid ""
"In the following, *events* is a bitwise mask indicating which I/O events "
"should be waited for on a given file object. It can be a combination of the "
"modules constants below:"
msgstr ""
"Далее *events* — это побитовая маска, указывающая, какие события ввода-"
"вывода следует ожидать для данного файлового объекта. Это может быть "
"комбинация констант модулей ниже:"

#: ../../library/selectors.rst:61
msgid "Constant"
msgstr "Константа"

#: ../../library/selectors.rst:61
msgid "Meaning"
msgstr "Значение"

#: ../../library/selectors.rst:63
msgid "Available for read"
msgstr "Доступно для чтения"

#: ../../library/selectors.rst:65
msgid "Available for write"
msgstr "Доступен для записи"

#: ../../library/selectors.rst:71
msgid ""
"A :class:`SelectorKey` is a :class:`~collections.namedtuple` used to "
"associate a file object to its underlying file descriptor, selected event "
"mask and attached data. It is returned by several :class:`BaseSelector` "
"methods."
msgstr ""
":class:`SelectorKey` — это :class:`~collections.namedtuple`, используемый "
"для связывания файлового объекта с его базовым файловым дескриптором, маской "
"выбранного события и присоединенными данными. Его возвращают несколько "
"методов BaseSelector."

#: ../../library/selectors.rst:78
msgid "File object registered."
msgstr "Зарегистрированный файловый объект."

#: ../../library/selectors.rst:82
msgid "Underlying file descriptor."
msgstr "Базовый файловый дескриптор."

#: ../../library/selectors.rst:86
msgid "Events that must be waited for on this file object."
msgstr "События, которых необходимо ожидать в этом файловом объекте."

#: ../../library/selectors.rst:90
msgid ""
"Optional opaque data associated to this file object: for example, this could "
"be used to store a per-client session ID."
msgstr ""
"Необязательные непрозрачные данные, связанные с этим файловым объектом: "
"например, их можно использовать для хранения идентификатора сеанса каждого "
"клиента."

#: ../../library/selectors.rst:96
msgid ""
"A :class:`BaseSelector` is used to wait for I/O event readiness on multiple "
"file objects. It supports file stream registration, unregistration, and a "
"method to wait for I/O events on those streams, with an optional timeout. "
"It's an abstract base class, so cannot be instantiated. Use :class:"
"`DefaultSelector` instead, or one of :class:`SelectSelector`, :class:"
"`KqueueSelector` etc. if you want to specifically use an implementation, and "
"your platform supports it. :class:`BaseSelector` and its concrete "
"implementations support the :term:`context manager` protocol."
msgstr ""
":class:`BaseSelector` используется для ожидания готовности события ввода-"
"вывода для нескольких файловых объектов. Он поддерживает регистрацию "
"файловых потоков, отмену регистрации и метод ожидания событий ввода-вывода в "
"этих потоках с дополнительным тайм-аутом. Это абстрактный базовый класс, "
"поэтому его экземпляр не может быть создан. Вместо этого используйте :class:"
"`DefaultSelector` или один из :class:`SelectSelector`, :class:"
"`KqueueSelector` и т. д., если вы хотите конкретно использовать реализацию и "
"ваша платформа ее поддерживает. :class:`BaseSelector` и его конкретные "
"реализации поддерживают протокол :term:`context Manager`."

#: ../../library/selectors.rst:109
msgid "Register a file object for selection, monitoring it for I/O events."
msgstr ""
"Зарегистрируйте файловый объект для выбора, отслеживая его на предмет "
"событий ввода-вывода."

#: ../../library/selectors.rst:111
msgid ""
"*fileobj* is the file object to monitor.  It may either be an integer file "
"descriptor or an object with a ``fileno()`` method. *events* is a bitwise "
"mask of events to monitor. *data* is an opaque object."
msgstr ""
"*fileobj* — файловый объект для мониторинга. Это может быть либо "
"целочисленный дескриптор файла, либо объект с методом fileno(). *events* — "
"это побитовая маска событий, которые нужно отслеживать. *data* — "
"непрозрачный объект."

#: ../../library/selectors.rst:116
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is already registered."
msgstr ""
"Это возвращает новый экземпляр :class:`SelectorKey` или вызывает :exc:"
"`ValueError` в случае недопустимой маски события или дескриптора файла, или :"
"exc:`KeyError`, если файловый объект уже зарегистрирован."

#: ../../library/selectors.rst:123
msgid ""
"Unregister a file object from selection, removing it from monitoring. A file "
"object shall be unregistered prior to being closed."
msgstr ""
"Отменить регистрацию файлового объекта из выделения, сняв его с мониторинга. "
"Перед закрытием файловый объект должен быть отменен регистрации."

#: ../../library/selectors.rst:126
msgid "*fileobj* must be a file object previously registered."
msgstr "*fileobj* должен быть ранее зарегистрированным файловым объектом."

#: ../../library/selectors.rst:128
msgid ""
"This returns the associated :class:`SelectorKey` instance, or raises a :exc:"
"`KeyError` if *fileobj* is not registered.  It will raise :exc:`ValueError` "
"if *fileobj* is invalid (e.g. it has no ``fileno()`` method or its "
"``fileno()`` method has an invalid return value)."
msgstr ""
"Это возвращает связанный экземпляр :class:`SelectorKey` или вызывает :exc:"
"`KeyError`, если *fileobj* не зарегистрирован. Он выдаст :exc:`ValueError`, "
"если *fileobj* недействителен (например, у него нет метода ``fileno()`` или "
"его метод ``fileno()`` имеет недопустимое возвращаемое значение)."

#: ../../library/selectors.rst:135
msgid "Change a registered file object's monitored events or attached data."
msgstr ""
"Измените отслеживаемые события или прикрепленные данные зарегистрированного "
"файлового объекта."

#: ../../library/selectors.rst:137
msgid ""
"This is equivalent to ``BaseSelector.unregister(fileobj)`` followed by "
"``BaseSelector.register(fileobj, events, data)``, except that it can be "
"implemented more efficiently."
msgstr ""
"Это эквивалентно ``BaseSelector.unregister(fileobj)``, за которым следует "
"``BaseSelector.register(fileobj, event, data)``, за исключением того, что "
"его можно реализовать более эффективно."

#: ../../library/selectors.rst:141
msgid ""
"This returns a new :class:`SelectorKey` instance, or raises a :exc:"
"`ValueError` in case of invalid event mask or file descriptor, or :exc:"
"`KeyError` if the file object is not registered."
msgstr ""
"Это возвращает новый экземпляр :class:`SelectorKey` или вызывает :exc:"
"`ValueError` в случае недопустимой маски события или дескриптора файла, или :"
"exc:`KeyError`, если файловый объект не зарегистрирован."

#: ../../library/selectors.rst:148
msgid ""
"Wait until some registered file objects become ready, or the timeout expires."
msgstr ""
"Подождите, пока некоторые зарегистрированные файловые объекты не станут "
"готовы или пока не истечет время ожидания."

#: ../../library/selectors.rst:151
msgid ""
"If ``timeout > 0``, this specifies the maximum wait time, in seconds. If "
"``timeout <= 0``, the call won't block, and will report the currently ready "
"file objects. If *timeout* is ``None``, the call will block until a "
"monitored file object becomes ready."
msgstr ""
"Если ``timeout > 0``, это определяет максимальное время ожидания в секундах. "
"Если ``timeout <= 0``, вызов не будет блокироваться и сообщит о готовых в "
"данный момент файловых объектах. Если *timeout* имеет значение «None», вызов "
"будет блокироваться до тех пор, пока отслеживаемый файловый объект не станет "
"готовым."

#: ../../library/selectors.rst:157
msgid ""
"This returns a list of ``(key, events)`` tuples, one for each ready file "
"object."
msgstr ""
"Это возвращает список кортежей ``(ключ, события)``, по одному для каждого "
"готового файлового объекта."

#: ../../library/selectors.rst:160
msgid ""
"*key* is the :class:`SelectorKey` instance corresponding to a ready file "
"object. *events* is a bitmask of events ready on this file object."
msgstr ""
"*key* — это экземпляр :class:`SelectorKey`, соответствующий готовому "
"файловому объекту. *events* — это битовая маска событий, готовых для этого "
"файлового объекта."

#: ../../library/selectors.rst:165
msgid ""
"This method can return before any file object becomes ready or the timeout "
"has elapsed if the current process receives a signal: in this case, an empty "
"list will be returned."
msgstr ""
"Этот метод может вернуться до того, как какой-либо файловый объект станет "
"готов или истечет время ожидания, если текущий процесс получит сигнал: в "
"этом случае будет возвращен пустой список."

#: ../../library/selectors.rst:169
msgid ""
"The selector is now retried with a recomputed timeout when interrupted by a "
"signal if the signal handler did not raise an exception (see :pep:`475` for "
"the rationale), instead of returning an empty list of events before the "
"timeout."
msgstr ""
"Селектор теперь повторяется с перевычисленным таймаутом, когда он "
"прерывается сигналом, если обработчик сигнала не вызвал исключение "
"(обоснование см. в :pep:`475`), вместо возврата пустого списка событий до "
"таймаута."

#: ../../library/selectors.rst:177
msgid "Close the selector."
msgstr "Закройте селектор."

#: ../../library/selectors.rst:179
msgid ""
"This must be called to make sure that any underlying resource is freed. The "
"selector shall not be used once it has been closed."
msgstr ""
"Это необходимо вызвать, чтобы убедиться, что любой базовый ресурс "
"освобожден. Селектор нельзя использовать после его закрытия."

#: ../../library/selectors.rst:184
msgid "Return the key associated with a registered file object."
msgstr "Верните ключ, связанный с зарегистрированным файловым объектом."

#: ../../library/selectors.rst:186
msgid ""
"This returns the :class:`SelectorKey` instance associated to this file "
"object, or raises :exc:`KeyError` if the file object is not registered."
msgstr ""
"Это возвращает экземпляр :class:`SelectorKey`, связанный с этим файловым "
"объектом, или вызывает :exc:`KeyError`, если файловый объект не "
"зарегистрирован."

#: ../../library/selectors.rst:192
msgid "Return a mapping of file objects to selector keys."
msgstr "Вернуть сопоставление файловых объектов с клавишами выбора."

#: ../../library/selectors.rst:194
msgid ""
"This returns a :class:`~collections.abc.Mapping` instance mapping registered "
"file objects to their associated :class:`SelectorKey` instance."
msgstr ""
"Это возвращает экземпляр :class:`~collections.abc.Mapping`, сопоставляющий "
"зарегистрированные файловые объекты со связанным с ними экземпляром :class:"
"`SelectorKey`."

#: ../../library/selectors.rst:201
msgid ""
"The default selector class, using the most efficient implementation "
"available on the current platform. This should be the default choice for "
"most users."
msgstr ""
"Класс селектора по умолчанию, использующий наиболее эффективную реализацию, "
"доступную на текущей платформе. Это должен быть выбор по умолчанию для "
"большинства пользователей."

#: ../../library/selectors.rst:208
msgid ":func:`select.select`-based selector."
msgstr "Селектор на основе :func:`select.select`."

#: ../../library/selectors.rst:213
msgid ":func:`select.poll`-based selector."
msgstr "Селектор на основе :func:`select.poll`"

#: ../../library/selectors.rst:218
msgid ":func:`select.epoll`-based selector."
msgstr "Селектор на основе :func:`select.epoll`"

#: ../../library/selectors.rst:222
msgid ""
"This returns the file descriptor used by the underlying :func:`select.epoll` "
"object."
msgstr ""
"Это возвращает дескриптор файла, используемый базовым объектом :func:`select."
"epoll`."

#: ../../library/selectors.rst:227
msgid ":func:`select.devpoll`-based selector."
msgstr "Селектор на основе :func:`select.devpoll`"

#: ../../library/selectors.rst:231
msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"devpoll` object."
msgstr ""
"Это возвращает дескриптор файла, используемый базовым объектом :func:`select."
"devpoll`."

#: ../../library/selectors.rst:238
msgid ":func:`select.kqueue`-based selector."
msgstr "Селектор на основе "

#: ../../library/selectors.rst:242
msgid ""
"This returns the file descriptor used by the underlying :func:`select."
"kqueue` object."
msgstr ""
"Это возвращает дескриптор файла, используемый базовым объектом :func:`select."
"kqueue`."

#: ../../library/selectors.rst:247
msgid "Examples"
msgstr "Примеры"

#: ../../library/selectors.rst:249
msgid "Here is a simple echo server implementation::"
msgstr "Вот простая реализация эхо-сервера::"

#: ../../library/selectors.rst:251
msgid ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
msgstr ""
"import selectors\n"
"import socket\n"
"\n"
"sel = selectors.DefaultSelector()\n"
"\n"
"def accept(sock, mask):\n"
"    conn, addr = sock.accept()  # Should be ready\n"
"    print('accepted', conn, 'from', addr)\n"
"    conn.setblocking(False)\n"
"    sel.register(conn, selectors.EVENT_READ, read)\n"
"\n"
"def read(conn, mask):\n"
"    data = conn.recv(1000)  # Should be ready\n"
"    if data:\n"
"        print('echoing', repr(data), 'to', conn)\n"
"        conn.send(data)  # Hope it won't block\n"
"    else:\n"
"        print('closing', conn)\n"
"        sel.unregister(conn)\n"
"        conn.close()\n"
"\n"
"sock = socket.socket()\n"
"sock.bind(('localhost', 1234))\n"
"sock.listen(100)\n"
"sock.setblocking(False)\n"
"sel.register(sock, selectors.EVENT_READ, accept)\n"
"\n"
"while True:\n"
"    events = sel.select()\n"
"    for key, mask in events:\n"
"        callback = key.data\n"
"        callback(key.fileobj, mask)"
