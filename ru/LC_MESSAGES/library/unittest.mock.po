# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/unittest.mock.rst:3
msgid ":mod:`unittest.mock` --- mock object library"
msgstr ""

#: ../../library/unittest.mock.rst:13
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**Исходный код:** :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:17
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` — это библиотека для тестирования на Python. Это "
"позволяет вам заменять части тестируемой системы макетными объектами и "
"делать утверждения о том, как они использовались."

#: ../../library/unittest.mock.rst:21
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` предоставляет базовый класс :class:`Mock`, устраняющий "
"необходимость создания множества заглушек в вашем наборе тестов. После "
"выполнения действия вы можете делать утверждения о том, какие методы/"
"атрибуты были использованы и с какими аргументами они были вызваны. Вы также "
"можете указать возвращаемые значения и установить необходимые атрибуты "
"обычным способом."

#: ../../library/unittest.mock.rst:27
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"Кроме того, макет предоставляет декоратор :func:`patch`, который "
"обрабатывает исправления атрибутов уровня модуля и класса в рамках теста, а "
"также :const:`sentinel` для создания уникальных объектов. См. `краткое "
"руководство`_ для некоторых примеров использования :class:`Mock`, :class:"
"`MagicMock` и :func:`patch`."

#: ../../library/unittest.mock.rst:33
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock предназначен для использования с :mod:`unittest` и основан на шаблоне "
"«действие -> утверждение» вместо «запись -> воспроизведение», используемом "
"многими фреймворками для создания макетов."

#: ../../library/unittest.mock.rst:37
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as `mock on PyPI <https://pypi.org/project/mock>`_."
msgstr ""

#: ../../library/unittest.mock.rst:42
msgid "Quick Guide"
msgstr "Краткое руководство"

#: ../../library/unittest.mock.rst:60
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
"Объекты :class:`Mock` и :class:`MagicMock` создают все атрибуты и методы по "
"мере доступа к ним и сохраняют сведения о том, как они использовались. Вы "
"можете настроить их, чтобы указать возвращаемые значения или ограничить "
"доступные атрибуты, а затем сделать утверждения о том, как они "
"использовались:"

#: ../../library/unittest.mock.rst:72
msgid ""
":attr:`side_effect` allows you to perform side effects, including raising an "
"exception when a mock is called:"
msgstr ""
":attr:`side_effect` позволяет вам выполнять побочные эффекты, включая "
"создание исключения при вызове макета:"

#: ../../library/unittest.mock.rst:92
msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"У Mock есть много других способов настроить его и контролировать его "
"поведение. Например, аргумент *spec* настраивает макет на получение "
"спецификации из другого объекта. Попытка получить доступ к атрибутам или "
"методам макета, которых нет в спецификации, завершится неудачно с ошибкой :"
"exc:`AttributeError`."

#: ../../library/unittest.mock.rst:97
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
"Декоратор/менеджер контекста :func:`patch` позволяет легко имитировать "
"классы или объекты в тестируемом модуле. Указанный вами объект будет заменен "
"макетом (или другим объектом) во время теста и восстановлен по завершении "
"теста:"

#: ../../library/unittest.mock.rst:116
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"Когда вы вкладываете декораторы патчей, макеты передаются декорируемой "
"функции в том же порядке, в котором они были применены (обычный порядок "
"*Python*, в котором применяются декораторы). Это означает, что снизу вверх, "
"поэтому в приведенном выше примере сначала передается макет для ``module."
"ClassName1``."

#: ../../library/unittest.mock.rst:121
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"При использовании :func:`patch` важно исправлять объекты в пространстве "
"имен, в котором они просматриваются. Обычно это просто, но для краткого "
"руководства прочтите :ref:`where to patch <where-to-patch>`."

#: ../../library/unittest.mock.rst:125
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr ""
"Помимо декоратора :func:`patch` можно использовать в качестве менеджера "
"контекста в операторе with:"

#: ../../library/unittest.mock.rst:135
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Существует также :func:`patch.dict` для установки значений в словаре только "
"во время проверки и восстановления словаря в исходное состояние после "
"завершения теста:"

#: ../../library/unittest.mock.rst:146
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"Mock поддерживает издевательство над Python :ref:`магическими методами "
"<magic-methods>`. Самый простой способ использовать магические методы — "
"использовать класс :class:`MagicMock`. Это позволяет вам делать такие вещи, "
"как:"

#: ../../library/unittest.mock.rst:156
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"Mock позволяет вам назначать функции (или другие экземпляры Mock) магическим "
"методам, и они будут вызываться соответствующим образом. Класс :class:"
"`MagicMock` — это просто вариант Mock, в котором заранее созданы все "
"магические методы (ну, во всяком случае, все полезные)."

#: ../../library/unittest.mock.rst:161
msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr ""
"Ниже приведен пример использования магических методов с обычным классом Mock:"

#: ../../library/unittest.mock.rst:169
msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"Чтобы убедиться, что фиктивные объекты в ваших тестах имеют тот же API, что "
"и объекты, которые они заменяют, вы можете использовать :ref:`auto-speccing "
"<auto-speccing>`. Автоспецификацию можно выполнить с помощью аргумента "
"*autospec* команды patch или функции :func:`create_autospec`. Автоматическая "
"спецификация создает макеты объектов, которые имеют те же атрибуты и методы, "
"что и объекты, которые они заменяют, а любые функции и методы (включая "
"конструкторы) имеют ту же сигнатуру вызова, что и реальный объект."

#: ../../library/unittest.mock.rst:177
msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr ""
"Это гарантирует, что ваши макеты потерпят неудачу так же, как и ваш "
"производственный код, если они используются неправильно:"

#: ../../library/unittest.mock.rst:193
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` также можно использовать в классах, где он копирует "
"подпись метода ``__init__``, и на вызываемых объектах, где он копирует "
"подпись метода ``__call__``."

#: ../../library/unittest.mock.rst:200
msgid "The Mock Class"
msgstr "Мок-класс"

#: ../../library/unittest.mock.rst:211
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` — это гибкий макетный объект, предназначенный для замены "
"использования заглушек и тестовых двойников в вашем коде. Моки можно "
"вызывать и создавать атрибуты как новые макеты при доступе к ним. [#]_ . "
"Доступ к одному и тому же атрибуту всегда будет возвращать один и тот же "
"макет. Моки записывают, как вы их используете, позволяя вам делать "
"утверждения о том, что ваш код с ними сделал."

#: ../../library/unittest.mock.rst:217
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` — это подкласс :class:`Mock` со всеми заранее созданными "
"и готовыми к использованию магическими методами. Существуют также "
"невызываемые варианты, полезные при создании макетов объектов, которые не "
"могут быть вызваны: :class:`NonCallableMock` и :class:`NonCallableMagicMock`"

#: ../../library/unittest.mock.rst:222
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
"Декораторы :func:`patch` позволяют легко временно заменить классы в "
"конкретном модуле объектом :class:`Mock`. По умолчанию :func:`patch` создаст "
"для вас :class:`MagicMock`. Вы можете указать альтернативный класс :class:"
"`Mock`, используя аргумент *new_callable* для :func:`patch`."

#: ../../library/unittest.mock.rst:230
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"Создайте новый объект :class:`Mock`. :class:`Mock` принимает несколько "
"дополнительных аргументов, определяющих поведение объекта Mock:"

#: ../../library/unittest.mock.rst:233
msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*спец*: это может быть либо список строк, либо существующий объект (класс "
"или экземпляр), который действует как спецификация для макетного объекта. "
"Если вы передаете объект, то список строк формируется путем вызова dir для "
"объекта (исключая неподдерживаемые магические атрибуты и методы). Доступ к "
"любому атрибуту, не указанному в этом списке, вызовет ошибку :exc:"
"`AttributeError`."

#: ../../library/unittest.mock.rst:239
msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~instance."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""

#: ../../library/unittest.mock.rst:243
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*: более строгий вариант *spec*. Если он используется, попытка "
"*установить* или получить атрибут макета, которого нет в объекте, переданном "
"как *spec_set*, приведет к возникновению ошибки :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:247
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*: функция, вызываемая при каждом вызове Mock. См. атрибут :attr:"
"`~Mock.side_effect`. Полезно для создания исключений или динамического "
"изменения возвращаемых значений. Функция вызывается с теми же аргументами, "
"что и макет, и если она не возвращает :data:`DEFAULT`, в качестве "
"возвращаемого значения используется возвращаемое значение этой функции."

#: ../../library/unittest.mock.rst:253
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr ""
"Альтернативно *side_effect* может быть классом или экземпляром исключения. В "
"этом случае исключение будет вызвано при вызове макета."

#: ../../library/unittest.mock.rst:256
msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr ""
"Если *side_effect* является итерируемым, то каждый вызов макета будет "
"возвращать следующее значение из итерируемого объекта."

#: ../../library/unittest.mock.rst:259
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "*side_effect* можно удалить, установив для него значение None."

#: ../../library/unittest.mock.rst:261
msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*: значение, возвращаемое при вызове макета. По умолчанию это "
"новый Mock (созданный при первом доступе). См. атрибут :attr:`return_value`."

#: ../../library/unittest.mock.rst:265
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*unsafe*: по умолчанию доступ к любому атрибуту, имя которого начинается с "
"*assert*, *assret*, *asert*, *aseert* или *assrt*, вызовет ошибку :exc:"
"`AttributeError`. Передача unsafe=True позволит получить доступ к этим "
"атрибутам."

#: ../../library/unittest.mock.rst:272
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*wraps*: элемент для обертывания фиктивного объекта. Если *wraps* не имеет "
"значения None, то вызов Mock передаст вызов обернутому объекту (возвращая "
"реальный результат). Доступ к атрибуту в макете вернет объект Mock, который "
"обертывает соответствующий атрибут обернутого объекта (поэтому попытка "
"доступа к несуществующему атрибуту вызовет ошибку :exc:`AttributeError`)."

#: ../../library/unittest.mock.rst:279
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr ""
"Если в макете явно установлено *return_value*, вызовы не передаются в "
"обернутый объект, а вместо этого возвращается *return_value*."

#: ../../library/unittest.mock.rst:282
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr ""
"*имя*: если у макета есть имя, оно будет использоваться при его "
"воспроизведении. Это может быть полезно для отладки. Имя распространяется на "
"детские насмешки."

#: ../../library/unittest.mock.rst:286
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"Mocks также можно вызывать с произвольными аргументами ключевого слова. Они "
"будут использоваться для установки атрибутов макета после его создания. "
"Подробности смотрите в методе :meth:`configure_mock`."

#: ../../library/unittest.mock.rst:292
msgid "Assert that the mock was called at least once."
msgstr "Утвердите, что макет был вызван хотя бы один раз."

#: ../../library/unittest.mock.rst:303
msgid "Assert that the mock was called exactly once."
msgstr "Утвердите, что макет был вызван ровно один раз."

#: ../../library/unittest.mock.rst:321
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr ""
"Этот метод представляет собой удобный способ подтвердить, что последний "
"вызов был выполнен определенным образом:"

#: ../../library/unittest.mock.rst:331
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr ""
"Утвердите, что макет был вызван ровно один раз и этот вызов был с указанными "
"аргументами."

#: ../../library/unittest.mock.rst:346
msgid "assert the mock has been called with the specified arguments."
msgstr "утверждайте, что макет был вызван с указанными аргументами."

#: ../../library/unittest.mock.rst:348
msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""
"Утверждение проходит, если макет *когда-либо* вызывался, в отличие от :meth:"
"`assert_called_with` и :meth:`assert_called_once_with`, которые проходят "
"только в том случае, если вызов является самым последним, и в случае :meth:"
"`assert_known_once_with` это также должен быть единственный звонок."

#: ../../library/unittest.mock.rst:361
msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr ""
"утверждать, что макет был вызван с указанными вызовами. Список :attr:"
"`mock_calls` проверяется на наличие вызовов."

#: ../../library/unittest.mock.rst:364
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr ""
"Если *any_order* имеет значение false, вызовы должны быть последовательными. "
"До или после указанных вызовов могут быть дополнительные вызовы."

#: ../../library/unittest.mock.rst:368
msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr ""
"Если *any_order* имеет значение true, то вызовы могут быть в любом порядке, "
"но все они должны появляться в :attr:`mock_calls`."

#: ../../library/unittest.mock.rst:383
msgid "Assert the mock was never called."
msgstr ""
"Если *any_order* имеет значение true, то вызовы могут быть в любом порядке, "
"но все они должны появляться в :attr:`mock_calls`."

#: ../../library/unittest.mock.rst:398
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "Метод reset_mock сбрасывает все атрибуты вызова фиктивного объекта:"

#: ../../library/unittest.mock.rst:408
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr ""
"В функцию reset_mock добавлены два аргумента, состоящие только из ключевых "
"слов."

#: ../../library/unittest.mock.rst:411
msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object. Note that :meth:`reset_mock` *doesn't* clear the return "
"value, :attr:`side_effect` or any child attributes you have set using normal "
"assignment by default. In case you want to reset *return_value* or :attr:"
"`side_effect`, then pass the corresponding parameter as ``True``. Child "
"mocks and the return value mock (if any) are reset as well."
msgstr ""

#: ../../library/unittest.mock.rst:419
msgid "*return_value*, and :attr:`side_effect` are keyword-only arguments."
msgstr ""

#: ../../library/unittest.mock.rst:425
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr ""
"Добавьте спецификацию в макет. *spec* может быть либо объектом, либо списком "
"строк. Только атрибуты *spec* могут быть извлечены как атрибуты из макета."

#: ../../library/unittest.mock.rst:429
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr ""
"Если *spec_set* имеет значение true, то можно установить только атрибуты "
"спецификации."

#: ../../library/unittest.mock.rst:434
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"Прикрепите макет в качестве атрибута этого объекта, заменив его имя и "
"родителя. Вызовы прикрепленного макета будут записаны в атрибутах :attr:"
"`method_calls` и :attr:`mock_calls` этого."

#: ../../library/unittest.mock.rst:441
msgid "Set attributes on the mock through keyword arguments."
msgstr "Установите атрибуты макета с помощью аргументов ключевого слова."

#: ../../library/unittest.mock.rst:443
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr ""
"Атрибуты, возвращаемые значения и побочные эффекты могут быть установлены в "
"дочерних макетах с использованием стандартной записи через точку и "
"распаковки словаря при вызове метода:"

#: ../../library/unittest.mock.rst:457
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "Того же самого можно добиться при вызове конструктора для макетов:"

#: ../../library/unittest.mock.rst:470
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ""
":meth:`configure_mock` существует для того, чтобы упростить настройку после "
"создания макета."

#: ../../library/unittest.mock.rst:476
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
"Объекты :class:`Mock` ограничивают результаты ``dir(some_mock)`` полезными "
"результатами. Для макетов со спецификацией *spec* сюда входят все "
"разрешенные атрибуты макета."

#: ../../library/unittest.mock.rst:480
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr ""
"См. :data:`FILTER_DIR`, чтобы узнать, что делает эта фильтрация и как ее "
"отключить."

#: ../../library/unittest.mock.rst:486
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"Создайте дочерние макеты для атрибутов и возвращаемого значения. По "
"умолчанию дочерние макеты будут того же типа, что и родительские. Подклассы "
"Mock могут захотеть переопределить это, чтобы настроить способ создания "
"дочерних макетов."

#: ../../library/unittest.mock.rst:491
msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr ""
"Для невызываемых макетов будет использоваться вызываемый вариант (а не любой "
"пользовательский подкласс)."

#: ../../library/unittest.mock.rst:497
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "Логическое значение, указывающее, был ли вызван фиктивный объект:"

#: ../../library/unittest.mock.rst:508
msgid "An integer telling you how many times the mock object has been called:"
msgstr "Целое число, сообщающее, сколько раз вызывался фиктивный объект:"

#: ../../library/unittest.mock.rst:520
msgid "Set this to configure the value returned by calling the mock:"
msgstr ""
"Установите это, чтобы настроить значение, возвращаемое при вызове макета:"

#: ../../library/unittest.mock.rst:527
msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr ""
"Возвращаемое значение по умолчанию — это фиктивный объект, и вы можете "
"настроить его обычным способом:"

#: ../../library/unittest.mock.rst:536
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` также можно установить в конструкторе:"

#: ../../library/unittest.mock.rst:547
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"Это может быть либо функция, вызываемая при вызове макета, либо итерация, "
"либо вызываемое исключение (класс или экземпляр)."

#: ../../library/unittest.mock.rst:550
msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"Если вы передадите функцию, она будет вызвана с теми же аргументами, что и "
"макет, и если функция не вернет синглтон :data:`DEFAULT`, вызов макета затем "
"вернет все, что возвращает функция. Если функция возвращает :data:`DEFAULT`, "
"то макет вернет своё нормальное значение (из :attr:`return_value`)."

#: ../../library/unittest.mock.rst:556
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"Если вы передаете итерируемый объект, он используется для получения "
"итератора, который должен возвращать значение при каждом вызове. Это "
"значение может быть либо экземпляром исключения, которое должно быть "
"вызвано, либо значением, которое должно быть возвращено из вызова макета "
"(обработка :data:`DEFAULT` идентична случаю функции)."

#: ../../library/unittest.mock.rst:561
msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr ""
"Пример макета, вызывающего исключение (для проверки обработки исключений "
"API):"

#: ../../library/unittest.mock.rst:571
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr ""
"Использование :attr:`side_effect` для возврата последовательности значений:"

#: ../../library/unittest.mock.rst:578
msgid "Using a callable:"
msgstr "Использование вызываемого объекта:"

#: ../../library/unittest.mock.rst:588
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ""
":attr:`side_effect` можно установить в конструкторе. Вот пример, который "
"добавляет единицу к значению, с которым вызывается макет, и возвращает его:"

#: ../../library/unittest.mock.rst:598
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "Установка :attr:`side_effect` в ``None`` очищает его:"

#: ../../library/unittest.mock.rst:612
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""
"Это либо None (если макет не вызывался), либо аргументы, с которыми макет "
"вызывался в последний раз. Это будет кортеж: первый член, к которому также "
"можно получить доступ через свойство args, — это любые упорядоченные "
"аргументы, с которыми был вызван макет (или пустой кортеж), а второй член, "
"который может также доступен через свойство kwargs, любые аргументы "
"ключевого слова (или пустой словарь)."

#: ../../library/unittest.mock.rst:645
msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args` вместе с членами списков :attr:`call_args_list`, :attr:"
"`method_calls` и :attr:`mock_calls` являются объектами :data:`call`. Это "
"кортежи, поэтому их можно распаковать, чтобы получить отдельные аргументы и "
"сделать более сложные утверждения. См. :ref:`вызовы как кортежи <calls-as-"
"tuples>`."

#: ../../library/unittest.mock.rst:651
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "Добавлены свойства args и kwargs."

#: ../../library/unittest.mock.rst:657
msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"Это список всех последовательных вызовов макетного объекта (поэтому длина "
"списка равна количеству раз, когда он вызывался). До того, как были сделаны "
"какие-либо вызовы, это пустой список. Объект :data:`call` можно использовать "
"для удобного создания списков вызовов для сравнения с :attr:`call_args_list`."

#: ../../library/unittest.mock.rst:673
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Членами :attr:`call_args_list` являются объекты :data:`call`. Их можно "
"распаковать как кортежи, чтобы получить отдельные аргументы. См. :ref:"
"`вызовы как кортежи <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:680
msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr ""
"Помимо отслеживания вызовов самих себя, макеты также отслеживают вызовы "
"методов и атрибутов, а также *их* методов и атрибутов:"

#: ../../library/unittest.mock.rst:691
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Членами :attr:`method_calls` являются объекты :data:`call`. Их можно "
"распаковать как кортежи, чтобы получить отдельные аргументы. См. :ref:"
"`вызовы как кортежи <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:698
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls` записывает *все* вызовы макетного объекта, его методов, "
"магических методов *и* возвращаемых значений."

#: ../../library/unittest.mock.rst:716
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Членами :attr:`mock_calls` являются объекты :data:`call`. Их можно "
"распаковать как кортежи, чтобы получить отдельные аргументы. См. :ref:"
"`вызовы как кортежи <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:722
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ""
"Способ записи :attr:`mock_calls` означает, что при выполнении вложенных "
"вызовов параметры вызовов предков не записываются и поэтому всегда будут "
"сравниваться равными:"

#: ../../library/unittest.mock.rst:736
msgid ""
"Normally the :attr:`__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`spec`, ``__class__`` returns the spec class "
"instead. This allows mock objects to pass :func:`isinstance` tests for the "
"object they are replacing / masquerading as:"
msgstr ""
"Обычно атрибут :attr:`__class__` объекта возвращает его тип. Для макетного "
"объекта со спецификацией :attr:```__class__`` вместо этого возвращает класс "
"спецификации. Это позволяет макетным объектам проходить тесты :func:"
"`isinstance` для объекта, который они заменяют/маскируют под:"

#: ../../library/unittest.mock.rst:745
msgid ""
":attr:`__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`__class__` можно назначить, это позволяет макету пройти проверку :"
"func:`isinstance`, не заставляя вас использовать спецификацию:"

#: ../../library/unittest.mock.rst:755
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"Невызываемая версия :class:`Mock`. Параметры конструктора имеют то же "
"значение, что и :class:`Mock`, за исключением *return_value* и "
"*side_effect*, которые не имеют значения для невызываемого макета."

#: ../../library/unittest.mock.rst:759
msgid ""
"Mock objects that use a class or an instance as a :attr:`spec` or :attr:"
"`spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"Мок-объекты, использующие класс или экземпляр в качестве :attr:`spec` или :"
"attr:`spec_set`, могут проходить тесты :func:`isinstance`:"

#: ../../library/unittest.mock.rst:769
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
"Классы :class:`Mock` поддерживают имитацию магических методов. См. :ref:"
"`magic методы <magic-methods>` для получения полной информации."

#: ../../library/unittest.mock.rst:772
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"Мок-классы и декораторы :func:`patch` принимают произвольные ключевые слова "
"для настройки. Для декораторов :func:`patch` ключевые слова передаются "
"конструктору создаваемого макета. Аргументы ключевого слова предназначены "
"для настройки атрибутов макета:"

#: ../../library/unittest.mock.rst:783
msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"Возвращаемое значение и побочный эффект дочерних макетов можно задать таким "
"же образом, используя точечную запись. Поскольку вы не можете использовать "
"имена с точками непосредственно в вызове, вам придется создать словарь и "
"распаковать его с помощью ``**``:"

#: ../../library/unittest.mock.rst:798
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"Вызываемый макет, созданный с помощью *spec* (или *spec_set*), будет "
"анализировать сигнатуру объекта спецификации при сопоставлении вызовов с "
"макетом. Следовательно, он может соответствовать фактическим аргументам "
"вызова независимо от того, были ли они переданы позиционно или по имени::"

#: ../../library/unittest.mock.rst:811
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"Это относится к :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_known_once_with`, :meth:`~Mock.assert_has_calls` и :meth:`~Mock."
"assert_any_call`. При использовании :ref:`auto-speccing` оно также будет "
"применяться к вызовам методов фиктивного объекта."

#: ../../library/unittest.mock.rst:816
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr ""
"Добавлен самоанализ сигнатур для заданных и автоматически заданных макетов "
"объектов."

#: ../../library/unittest.mock.rst:822
msgid ""
"A mock intended to be used as a :class:`property`, or other :term:"
"`descriptor`, on a class. :class:`PropertyMock` provides :meth:`~object."
"__get__` and :meth:`~object.__set__` methods so you can specify a return "
"value when it is fetched."
msgstr ""
"Макет, предназначенный для использования в качестве свойства :class:`или "
"другого :term:`дескриптора` в классе. :class:`PropertyMock` предоставляет "
"методы :meth:`~object.__get__` и :meth:`~object.__set__`, чтобы вы могли "
"указать возвращаемое значение при его получении."

#: ../../library/unittest.mock.rst:827
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"Получение экземпляра :class:`PropertyMock` из объекта вызывает макет без "
"аргументов. Установка этого параметра вызывает макет с установленным "
"значением. ::"

#: ../../library/unittest.mock.rst:848
msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr ""
"Из-за способа хранения фиктивных атрибутов вы не можете напрямую прикрепить :"
"class:`PropertyMock` к фиктивному объекту. Вместо этого вы можете прикрепить "
"его к объекту фиктивного типа::"

#: ../../library/unittest.mock.rst:862
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""
"Асинхронная версия :class:`MagicMock`. Объект :class:`AsyncMock` будет вести "
"себя так, что объект распознается как асинхронная функция, а результат "
"вызова является ожидаемым."

#: ../../library/unittest.mock.rst:872
msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"Результатом ``mock()`` является асинхронная функция, которая будет иметь "
"результат ``side_effect`` или ``return_value`` после ее ожидания:"

#: ../../library/unittest.mock.rst:875
msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr ""
"если ``side_effect`` является функцией, асинхронная функция вернет результат "
"этой функции,"

#: ../../library/unittest.mock.rst:877
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr ""
"если ``side_effect`` является исключением, асинхронная функция вызовет "
"исключение,"

#: ../../library/unittest.mock.rst:879
msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"если ``side_effect`` является итерируемым, асинхронная функция вернет "
"следующее значение итерируемого объекта, однако, если последовательность "
"результатов исчерпана, ``StopAsyncIteration`` вызывается немедленно,"

#: ../../library/unittest.mock.rst:882
msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""
"если ``side_effect`` не определен, функция async вернет значение, "
"определенное ``return_value``, следовательно, по умолчанию функция async "
"возвращает новый объект :class:`AsyncMock``."

#: ../../library/unittest.mock.rst:887
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""
"Установка *spec* :class:`Mock` или :class:`MagicMock` для асинхронной "
"функции приведет к возврату объекта сопрограммы после вызова."

#: ../../library/unittest.mock.rst:899
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""
"Установка *spec* :class:`Mock`, :class:`MagicMock` или :class:`AsyncMock` "
"для класса с асинхронными и синхронными функциями автоматически обнаружит "
"синхронные функции и установит их как :class:` MagicMock` (если родительским "
"макетом является :class:`AsyncMock` или :class:`MagicMock`) или :class:"
"`Mock` (если родительским макетом является :class:`Mock`). Все асинхронные "
"функции будут :class:`AsyncMock`."

#: ../../library/unittest.mock.rst:927
msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr ""
"Утвердите, что макет ожидался хотя бы один раз. Обратите внимание, что это "
"отдельно от вызываемого объекта, необходимо использовать ключевое слово "
"await:"

#: ../../library/unittest.mock.rst:946
msgid "Assert that the mock was awaited exactly once."
msgstr "Утвердите, что макет ожидался ровно один раз."

#: ../../library/unittest.mock.rst:962
msgid "Assert that the last await was with the specified arguments."
msgstr "Утвердите, что последнее ожидание было с указанными аргументами."

#: ../../library/unittest.mock.rst:979
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr ""
"Утвердите, что макет ожидался ровно один раз и с указанными аргументами."

#: ../../library/unittest.mock.rst:996
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "Утвердите, что макет когда-либо ожидался с указанными аргументами."

#: ../../library/unittest.mock.rst:1012
msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr ""
"Утвердите, что макет ожидался с указанными вызовами. Список :attr:"
"`await_args_list` проверяется на наличие ожиданий."

#: ../../library/unittest.mock.rst:1015
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr ""
"Если *any_order* имеет значение false, то ожидания должны быть "
"последовательными. До или после указанного ожидания могут быть "
"дополнительные вызовы."

#: ../../library/unittest.mock.rst:1019
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr ""
"Если *any_order* имеет значение true, то ожидания могут быть в любом "
"порядке, но все они должны присутствовать в :attr:`await_args_list`."

#: ../../library/unittest.mock.rst:1039
msgid "Assert that the mock was never awaited."
msgstr "Утверждайте, что макета никогда не ждали."

#: ../../library/unittest.mock.rst:1046
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"См. :func:`Mock.reset_mock`. Также устанавливает для :attr:`await_count` "
"значение 0, для :attr:`await_args` значение None и очищает :attr:"
"`await_args_list`."

#: ../../library/unittest.mock.rst:1051
msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr "Целое число, отслеживающее, сколько раз ожидался фиктивный объект."

#: ../../library/unittest.mock.rst:1066
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr ""
"Это либо «Нет» (если макет не ожидался), либо аргументы, с которыми макет "
"ожидался в последний раз. Функционирует так же, как :attr:`Mock.call_args`."

#: ../../library/unittest.mock.rst:1084
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr ""
"Это список всех ожиданий, выполненных в последовательности для фиктивного "
"объекта (поэтому длина списка равна количеству раз, когда он ожидался). До "
"того, как были сделаны какие-либо ожидания, это пустой список."

#: ../../library/unittest.mock.rst:1103
msgid "Calling"
msgstr "Вызов"

#: ../../library/unittest.mock.rst:1105
msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"Мок-объекты являются вызываемыми. Вызов вернет значение, установленное в "
"качестве атрибута :attr:`~Mock.return_value`. Возвращаемое значение по "
"умолчанию — новый Mock-объект; он создается при первом доступе к "
"возвращаемому значению (либо явно, либо путем вызова Mock), но он "
"сохраняется и каждый раз возвращается одно и то же."

#: ../../library/unittest.mock.rst:1111
msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"Вызовы объекта будут записаны в таких атрибутах, как :attr:`~Mock.call_args` "
"и :attr:`~Mock.call_args_list`."

#: ../../library/unittest.mock.rst:1114
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`side_effect` raises an exception the call is "
"still recorded."
msgstr ""
"Если :attr:`~Mock.side_effect` установлен, то он будет вызываться после "
"записи вызова, поэтому, если :attr:`side_effect` вызывает исключение, вызов "
"все равно записывается."

#: ../../library/unittest.mock.rst:1118
msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"Самый простой способ заставить макет вызывать исключение при вызове — это "
"сделать :attr:`~Mock.side_effect` классом или экземпляром исключения:"

#: ../../library/unittest.mock.rst:1136
msgid ""
"If :attr:`side_effect` is a function then whatever that function returns is "
"what calls to the mock return. The :attr:`side_effect` function is called "
"with the same arguments as the mock. This allows you to vary the return "
"value of the call dynamically, based on the input:"
msgstr ""
"Если :attr:`side_effect` — это функция, то все, что возвращает эта функция, "
"является тем, что вызывает фиктивный возврат. Функция :attr:`side_effect` "
"вызывается с теми же аргументами, что и макет. Это позволяет вам динамически "
"изменять возвращаемое значение вызова в зависимости от входных данных:"

#: ../../library/unittest.mock.rst:1152
msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`mock.return_value` from inside :attr:`side_effect`, or return :"
"data:`DEFAULT`:"
msgstr ""
"Если вы хотите, чтобы макет по-прежнему возвращал возвращаемое значение по "
"умолчанию (новый макет) или любое установленное возвращаемое значение, есть "
"два способа сделать это. Либо верните :attr:`mock.return_value` изнутри :"
"attr:`side_effect`, либо верните :data:`DEFAULT`:"

#: ../../library/unittest.mock.rst:1171
msgid ""
"To remove a :attr:`side_effect`, and return to the default behaviour, set "
"the :attr:`side_effect` to ``None``:"
msgstr ""
"Чтобы удалить :attr:`side_effect` и вернуться к поведению по умолчанию, "
"установите для :attr:`side_effect` значение ``None``:"

#: ../../library/unittest.mock.rst:1185
msgid ""
"The :attr:`side_effect` can also be any iterable object. Repeated calls to "
"the mock will return values from the iterable (until the iterable is "
"exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`side_effect` также может быть любым итерируемым объектом. Повторные "
"вызовы макета будут возвращать значения из итерации (пока итерация не будет "
"исчерпана и не будет вызвано :exc:`StopIteration`):"

#: ../../library/unittest.mock.rst:1201
msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr ""
"Если какие-либо члены итерируемого объекта являются исключениями, они будут "
"вызваны, а не возвращены::"

#: ../../library/unittest.mock.rst:1219
msgid "Deleting Attributes"
msgstr "Удаление атрибутов"

#: ../../library/unittest.mock.rst:1221
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr ""
"Мок-объекты создают атрибуты по требованию. Это позволяет им притворяться "
"объектами любого типа."

#: ../../library/unittest.mock.rst:1224
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`spec` for a mock, but that isn't always "
"convenient."
msgstr ""
"Мок-объекты создают атрибуты по требованию. Это позволяет им притворяться "
"объектами любого типа."

#: ../../library/unittest.mock.rst:1228
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"Вы «блокируете» атрибуты, удаляя их. После удаления доступ к атрибуту "
"вызовет ошибку :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:1245
msgid "Mock names and the name attribute"
msgstr "Фокальные имена и атрибут имени"

#: ../../library/unittest.mock.rst:1247
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"Поскольку «имя» является аргументом конструктора :class:`Mock`, если вы "
"хотите, чтобы ваш макетный объект имел атрибут «имя», вы не можете просто "
"передать его во время создания. Есть две альтернативы. Один из вариантов — "
"использовать :meth:`~Mock.configure_mock`::"

#: ../../library/unittest.mock.rst:1257
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr ""
"Более простой вариант — просто установить атрибут «name» после создания "
"макета:"

#: ../../library/unittest.mock.rst:1264
msgid "Attaching Mocks as Attributes"
msgstr "Прикрепление макетов в качестве атрибутов"

#: ../../library/unittest.mock.rst:1266
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"Когда вы присоединяете макет как атрибут другого макета (или как "
"возвращаемое значение), он становится «дочерним» объектом этого макета. "
"Вызовы дочернего элемента записываются в атрибутах :attr:`~Mock."
"method_calls` и :attr:`~Mock.mock_calls` родителя. Это полезно для настройки "
"дочерних макетов и последующего прикрепления их к родительскому элементу или "
"для прикрепления макетов к родительскому элементу, который записывает все "
"вызовы дочерних элементов и позволяет вам делать утверждения о порядке "
"вызовов между макетами:"

#: ../../library/unittest.mock.rst:1284
msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"Исключением является случай, когда у макета есть имя. Это позволяет вам "
"предотвратить «воспитание», если по какой-то причине вы не хотите, чтобы это "
"произошло."

#: ../../library/unittest.mock.rst:1295
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
"Мокам, созданным для вас с помощью :func:`patch`, автоматически "
"присваиваются имена. Чтобы прикрепить макеты, имеющие имена, к родителю, вы "
"используете метод :meth:`~Mock.attach_mock`::"

#: ../../library/unittest.mock.rst:1313
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"Единственным исключением являются магические методы и атрибуты (те, которые "
"имеют двойное подчеркивание в начале и в конце). Mock не создает их, а "
"вместо этого вызывает :exc:`AttributeError`. Это связано с тем, что "
"интерпретатор часто неявно запрашивает эти методы и *очень* запутывается, "
"пытаясь получить новый Mock-объект, когда он ожидает магический метод. Если "
"вам нужна поддержка магических методов, см. :ref:`magic методы <magic-"
"methods>`."

#: ../../library/unittest.mock.rst:1322
msgid "The patchers"
msgstr "The patchers"

#: ../../library/unittest.mock.rst:1324
msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"Декораторы патчей используются для исправления объектов только в рамках "
"функции, которую они декорируют. Они автоматически выполняют удаление "
"исправлений за вас, даже если возникают исключения. Все эти функции также "
"можно использовать с операторами или в качестве декораторов классов."

#: ../../library/unittest.mock.rst:1331
msgid "patch"
msgstr "patch"

#: ../../library/unittest.mock.rst:1335
msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr ""
"Ключевым моментом является внесение исправлений в правильное пространство "
"имен. См. раздел `где пропатчить`_."

#: ../../library/unittest.mock.rst:1339
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` действует как декоратор функции, декоратор класса или менеджер "
"контекста. Внутри тела функции или оператора with *target* добавляется *new* "
"объект. Когда оператор function/with завершает работу, исправление "
"отменяется."

#: ../../library/unittest.mock.rst:1344
msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"Если *new* опущено, то цель заменяется на :class:`AsyncMock`, если "
"исправленный объект является асинхронной функцией, или :class:`MagicMock` в "
"противном случае. Если :func:`patch` используется в качестве декоратора и "
"*new* опущено, созданный макет передается в качестве дополнительного "
"аргумента декорируемой функции. Если :func:`patch` используется в качестве "
"менеджера контекста, созданный макет возвращается менеджером контекста."

#: ../../library/unittest.mock.rst:1352
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* должна быть строкой в ​​формате ``'package.module.ClassName'``. "
"*Цель* импортируется, а указанный объект заменяется *новым* объектом, "
"поэтому *цель* должна быть доступна для импорта из среды, из которой вы "
"вызываете :func:`patch`. Цель импортируется при выполнении декорированной "
"функции, а не во время декорирования."

#: ../../library/unittest.mock.rst:1358
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr ""
"Аргументы ключевых слов *spec* и *spec_set* передаются в :class:`MagicMock`, "
"если патч создает его для вас."

#: ../../library/unittest.mock.rst:1361
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"Кроме того, вы можете передать ``spec=True`` или ``spec_set=True``, что "
"приведет к тому, что patch передаст издеваемый объект как объект spec/"
"spec_set."

#: ../../library/unittest.mock.rst:1364
msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""
"*new_callable* позволяет вам указать другой класс или вызываемый объект, "
"который будет вызываться для создания *нового* объекта. По умолчанию :class:"
"`AsyncMock` используется для асинхронных функций, а :class:`MagicMock` — для "
"остальных."

#: ../../library/unittest.mock.rst:1368
msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"Более мощная форма *spec* — *autospec*. Если вы установите "
"``autospec=True``, то макет будет создан со спецификацией заменяемого "
"объекта. Все атрибуты макета также будут иметь спецификацию соответствующего "
"атрибута заменяемого объекта. Аргументы имитируемых методов и функций будут "
"проверены, и они вызовут ошибку :exc:`TypeError`, если они вызваны с "
"неправильной сигнатурой. Для макетов, заменяющих класс, их возвращаемое "
"значение («экземпляр») будет иметь ту же спецификацию, что и класс. См. "
"функцию :func:`create_autospec` и :ref:`auto-speccing`."

#: ../../library/unittest.mock.rst:1378
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"Вместо autospec=True вы можете передать autospec=some_object, чтобы "
"использовать в качестве спецификации произвольный объект вместо заменяемого."

#: ../../library/unittest.mock.rst:1381
msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"По умолчанию :func:`patch` не сможет заменить несуществующие атрибуты. Если "
"вы передадите ``create=True``, а атрибут не существует, patch создаст "
"атрибут для вас при вызове исправленной функции и удалит его снова после "
"выхода из исправленной функции. Это полезно для написания тестов для "
"атрибутов, которые ваш производственный код создает во время выполнения. По "
"умолчанию он отключен, поскольку может быть опасным. Включив его, вы можете "
"писать проходящие тесты для API, которых на самом деле не существует!"

#: ../../library/unittest.mock.rst:1391
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr ""
"Если вы исправляете встроенные функции в модуле, вам не нужно передавать "
"create=True, он будет добавлен по умолчанию."

#: ../../library/unittest.mock.rst:1395
msgid ""
"Patch can be used as a :class:`TestCase` class decorator. It works by "
"decorating each test method in the class. This reduces the boilerplate code "
"when your test methods share a common patchings set. :func:`patch` finds "
"tests by looking for method names that start with ``patch.TEST_PREFIX``. By "
"default this is ``'test'``, which matches the way :mod:`unittest` finds "
"tests. You can specify an alternative prefix by setting ``patch."
"TEST_PREFIX``."
msgstr ""
"Patch можно использовать как декоратор класса :class:`TestCase`. Он работает "
"путем украшения каждого тестового метода в классе. Это уменьшает количество "
"шаблонного кода, когда ваши методы тестирования используют общий набор "
"исправлений. :func:`patch` находит тесты, ища имена методов, начинающиеся с "
"``patch.TEST_PREFIX``. По умолчанию это ``'test'``, который соответствует "
"тому, как :mod:`unittest` находит тесты. Вы можете указать альтернативный "
"префикс, установив ``patch.TEST_PREFIX``."

#: ../../library/unittest.mock.rst:1402
msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"Patch можно использовать в качестве менеджера контекста с помощью оператора "
"with. Здесь исправление применяется к блоку с отступом после оператора with. "
"Если вы используете «as», то исправленный объект будет привязан к имени "
"после «as»; очень полезно, если :func:`patch` создает для вас фиктивный "
"объект."

#: ../../library/unittest.mock.rst:1407
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` принимает произвольные аргументы ключевого слова. Они будут "
"переданы в :class:`AsyncMock`, если исправленный объект является "
"асинхронным, в :class:`MagicMock` в противном случае или в *new_callable*, "
"если указано."

#: ../../library/unittest.mock.rst:1411
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``, ``patch.multiple(...)`` и ``patch.object(...)`` "
"доступны для альтернативных вариантов использования."

#: ../../library/unittest.mock.rst:1414
msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ""
":func:`patch` в качестве декоратора функции, создающий для вас макет и "
"передающий его декорируемой функции::"

#: ../../library/unittest.mock.rst:1424
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"Исправление класса заменяет класс на *экземпляр* :class:`MagicMock`. Если "
"экземпляр класса создается в тестируемом коде, то будет использоваться :attr:"
"`~Mock.return_value` макета."

#: ../../library/unittest.mock.rst:1428
msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"Если экземпляр класса создается несколько раз, вы можете использовать :attr:"
"`~Mock.side_effect`, чтобы каждый раз возвращать новый макет. В качестве "
"альтернативы вы можете установить для *return_value* любое желаемое значение."

#: ../../library/unittest.mock.rst:1432
msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`return_value`. For example::"
msgstr ""
"Чтобы настроить возвращаемые значения для методов *экземпляров* "
"исправленного класса, вы должны сделать это в :attr:`return_value`. "
"Например::"

#: ../../library/unittest.mock.rst:1446
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"Если вы используете *spec* или *spec_set* и :func:`patch` заменяет *class*, "
"то возвращаемое значение созданного макета будет иметь ту же спецификацию. ::"

#: ../../library/unittest.mock.rst:1456
msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"Аргумент *new_callable* полезен, если вы хотите использовать класс, "
"альтернативный классу по умолчанию :class:`MagicMock` для созданного макета. "
"Например, если вы хотите использовать :class:`NonCallableMock`::"

#: ../../library/unittest.mock.rst:1469
msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr ""
"Другим вариантом использования может быть замена объекта экземпляром :class:"
"`io.StringIO`::"

#: ../../library/unittest.mock.rst:1482
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"Когда :func:`patch` создает для вас макет, обычно первое, что вам нужно "
"сделать, — это настроить макет. Некоторые из этих настроек можно выполнить "
"при вызове patch. Любые произвольные ключевые слова, которые вы передаете в "
"вызов, будут использоваться для установки атрибутов созданного макета::"

#: ../../library/unittest.mock.rst:1494
msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"Помимо атрибутов созданных макетов, таких как :attr:`~Mock.return_value` и :"
"attr:`~Mock.side_effect`, также можно настроить дочерние макеты. Они "
"синтаксически недопустимы для прямой передачи в качестве аргументов "
"ключевого слова, но словарь с ними в качестве ключей все равно можно "
"расширить до вызова :func:`patch`, используя ``**``::"

#: ../../library/unittest.mock.rst:1510
msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr ""
"По умолчанию попытка исправить несуществующую функцию в модуле (или метод "
"или атрибут в классе) завершится неудачно с ошибкой :exc:`AttributeError`::"

#: ../../library/unittest.mock.rst:1522
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr ""
"но добавление ``create=True`` в вызов :func:`patch` заставит предыдущий "
"пример работать так, как ожидалось::"

#: ../../library/unittest.mock.rst:1533
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ""
":func:`patch` теперь возвращает :class:`AsyncMock`, если целью является "
"асинхронная функция."

#: ../../library/unittest.mock.rst:1537
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1541
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr ""
"исправьте именованный элемент (*атрибут*) на объекте (*цель*) с помощью "
"фиктивного объекта."

#: ../../library/unittest.mock.rst:1544
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` может использоваться как декоратор, декоратор класса "
"или менеджер контекста. Аргументы *new*, *spec*, *create*, *spec_set*, "
"*autospec* и *new_callable* имеют то же значение, что и для :func:`patch`. "
"Подобно :func:`patch`, :func:`patch.object` принимает произвольные аргументы "
"ключевого слова для настройки создаваемого им фиктивного объекта."

#: ../../library/unittest.mock.rst:1550
msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"При использовании в качестве декоратора класса :func:`patch.object` "
"использует ``patch.TEST_PREFIX`` для выбора методов для переноса."

#: ../../library/unittest.mock.rst:1553
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"Вы можете вызвать :func:`patch.object` с тремя или двумя аргументами. Форма "
"с тремя аргументами принимает объект, который нужно исправить, имя атрибута "
"и объект, которым атрибут заменяется."

#: ../../library/unittest.mock.rst:1557
msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr ""
"При вызове с формой с двумя аргументами вы опускаете заменяющий объект, и "
"для вас создается макет, который передается в качестве дополнительного "
"аргумента декорированной функции:"

#: ../../library/unittest.mock.rst:1568
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"*spec*, *create* и другие аргументы :func:`patch.object` имеют то же "
"значение, что и для :func:`patch`."

#: ../../library/unittest.mock.rst:1573
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1577
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test."
msgstr ""
"Исправьте словарь или словареподобный объект и восстановите словарь в "
"исходное состояние после теста."

#: ../../library/unittest.mock.rst:1580
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr ""
"*in_dict* может быть словарем или контейнером, подобным отображению. Если "
"это сопоставление, то оно должно как минимум поддерживать получение, "
"установку и удаление элементов, а также перебор ключей."

#: ../../library/unittest.mock.rst:1584
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr ""
"*in_dict* также может быть строкой, определяющей имя словаря, которое затем "
"будет получено путем его импорта."

#: ../../library/unittest.mock.rst:1587
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* может быть словарем значений, которые можно установить в словаре. "
"*значения* также могут быть итерацией пар ``(ключ, значение)``."

#: ../../library/unittest.mock.rst:1590
msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr ""
"Если *clear* имеет значение true, словарь будет очищен перед установкой "
"новых значений."

#: ../../library/unittest.mock.rst:1593
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ""
":func:`patch.dict` также может быть вызван с произвольными ключевыми "
"аргументами для установки значений в словаре."

#: ../../library/unittest.mock.rst:1598
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ""
":func:`patch.dict` теперь возвращает исправленный словарь при использовании "
"в качестве менеджера контекста."

#: ../../library/unittest.mock.rst:1601
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ""
":func:`patch.dict` можно использовать как менеджер контекста, декоратор или "
"декоратор класса:"

#: ../../library/unittest.mock.rst:1611
msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""
"При использовании в качестве декоратора класса :func:`patch.dict` учитывает "
"``patch.TEST_PREFIX`` (по умолчанию ``'test'``) для выбора методов для "
"переноса:"

#: ../../library/unittest.mock.rst:1622
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"Если вы хотите использовать другой префикс для своего теста, вы можете "
"сообщить патчерам о другом префиксе, установив ``patch.TEST_PREFIX``. Для "
"получения более подробной информации о том, как изменить значение, см. :ref:"
"`test-prefix`."

#: ../../library/unittest.mock.rst:1626
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ""
":func:`patch.dict` можно использовать для добавления элементов в словарь или "
"просто позволить тесту изменить словарь и гарантировать, что словарь будет "
"восстановлен после завершения теста."

#: ../../library/unittest.mock.rst:1647
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr ""
"Ключевые слова можно использовать в вызове :func:`patch.dict` для установки "
"значений в словаре:"

#: ../../library/unittest.mock.rst:1657
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` and either :meth:`~container."
"__iter__` or :meth:`~object.__contains__`."
msgstr ""
":func:`patch.dict` можно использовать со словарными объектами, которые на "
"самом деле словарями не являются. Как минимум, они должны поддерживать "
"получение, установку, удаление элементов, а также итерацию или проверку "
"членства. Это соответствует магическим методам :meth:`~object.__getitem__`, :"
"meth:`~object.__setitem__`, :meth:`~object.__delitem__` и либо :meth:"
"`~container.__iter__`, либо :meth: `~object.__contains__`."

#: ../../library/unittest.mock.rst:1687
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1691
msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr ""
"Выполните несколько исправлений за один вызов. Он принимает объект для "
"исправления (либо в виде объекта, либо в виде строки для извлечения объекта "
"путем импорта) и аргументы ключевого слова для исправлений::"

#: ../../library/unittest.mock.rst:1698
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
"Используйте :data:`DEFAULT` в качестве значения, если вы хотите, чтобы :func:"
"`patch.multiple` создавал для вас макеты. В этом случае созданные макеты "
"передаются в декорированную функцию по ключевому слову, а словарь "
"возвращается, когда :func:`patch.multiple` используется в качестве "
"контекстного менеджера."

#: ../../library/unittest.mock.rst:1703
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` может использоваться как декоратор, декоратор класса "
"или менеджер контекста. Аргументы *spec*, *spec_set*, *create*, *autospec* и "
"*new_callable* имеют то же значение, что и для :func:`patch`. Эти аргументы "
"будут применяться ко *всем* патчам, созданным :func:`patch.multiple`."

#: ../../library/unittest.mock.rst:1708
msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"При использовании в качестве декоратора класса :func:`patch.multiple` "
"использует ``patch.TEST_PREFIX`` для выбора методов для переноса."

#: ../../library/unittest.mock.rst:1711
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"Если вы хотите, чтобы :func:`patch.multiple` создавал для вас макеты, вы "
"можете использовать :data:`DEFAULT` в качестве значения. Если вы "
"используете :func:`patch.multiple` в качестве декоратора, то созданные "
"макеты передаются в декорированную функцию по ключевому слову. ::"

#: ../../library/unittest.mock.rst:1725
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` может быть вложен в другие декораторы ``patch``, но "
"аргументы, передаваемые по ключевому слову, *после* любого из стандартных "
"аргументов, созданных :func:`patch`::"

#: ../../library/unittest.mock.rst:1737
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
"Если :func:`patch.multiple` используется в качестве менеджера контекста, "
"значение, возвращаемое менеджером контекста, представляет собой словарь, в "
"котором созданные макеты кодируются по имени::"

#: ../../library/unittest.mock.rst:1751
msgid "patch methods: start and stop"
msgstr "методы исправления: запуск и остановка"

#: ../../library/unittest.mock.rst:1753
msgid ""
"All the patchers have :meth:`start` and :meth:`stop` methods. These make it "
"simpler to do patching in ``setUp`` methods or where you want to do multiple "
"patches without nesting decorators or with statements."
msgstr ""
"Все патчеры имеют методы :meth:`start` и :meth:`stop`. Это упрощает внесение "
"исправлений в методах ``setUp`` или там, где вы хотите выполнить несколько "
"исправлений без вложенных декораторов или с помощью операторов."

#: ../../library/unittest.mock.rst:1757
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`start` to put the patch in place and :meth:`stop` to undo "
"it."
msgstr ""
"Чтобы использовать их, вызовите :func:`patch`, :func:`patch.object` или :"
"func:`patch.dict` как обычно и сохраните ссылку на возвращенный объект "
"``patcher``. Затем вы можете вызвать :meth:`start`, чтобы установить патч, "
"и :meth:`stop`, чтобы отменить его."

#: ../../library/unittest.mock.rst:1761
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ""
"Если вы используете :func:`patch` для создания макета, он будет возвращен "
"вызовом ``patcher.start``. ::"

#: ../../library/unittest.mock.rst:1775
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`TestCase`::"
msgstr ""
"Типичным примером использования этого может быть выполнение нескольких "
"исправлений в методе ``setUp`` :class:`TestCase`::"

#: ../../library/unittest.mock.rst:1797
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Если вы используете этот метод, вы должны убедиться, что исправление "
"«отменено», вызвав ``stop``. Это может быть сложнее, чем вы думаете, потому "
"что если в setUp возникает исключение, то tearDown не вызывается. :meth:"
"`unittest.TestCase.addCleanup` делает это проще::"

#: ../../library/unittest.mock.rst:1812
msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr ""
"В качестве дополнительного бонуса вам больше не нужно хранить ссылку на "
"объект «patcher»."

#: ../../library/unittest.mock.rst:1815
msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr ""
"Также возможно остановить все запущенные патчи с помощью :func:`patch."
"stopall`."

#: ../../library/unittest.mock.rst:1820
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr ""
"Остановите все активные патчи. Останавливает только патчи, запущенные с "
"помощью ``start``."

#: ../../library/unittest.mock.rst:1826
msgid "patch builtins"
msgstr "патчить встроенные функции"

#: ../../library/unittest.mock.rst:1827
msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr ""
"Вы можете исправить любые встроенные функции внутри модуля. Следующий пример "
"исправляет встроенную :func:`ord`::"

#: ../../library/unittest.mock.rst:1842
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1844
msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"Все патчеры можно использовать в качестве декораторов классов. При таком "
"использовании они оборачивают каждый тестовый метод класса. Патчеры "
"распознают методы, начинающиеся с «test», как тестовые. Точно так же :class:"
"`unittest.TestLoader` по умолчанию находит тестовые методы."

#: ../../library/unittest.mock.rst:1849
msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"Возможно, вы захотите использовать для своих тестов другой префикс. Вы "
"можете сообщить патчерам другой префикс, установив ``patch.TEST_PREFIX``::"

#: ../../library/unittest.mock.rst:1872
msgid "Nesting Patch Decorators"
msgstr "Вложенные декораторы патчей"

#: ../../library/unittest.mock.rst:1874
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr ""
"Если вы хотите выполнить несколько патчей, вы можете просто сложить "
"декораторы."

#: ../../library/unittest.mock.rst:1877
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr ""
"Вы можете объединить несколько декораторов патчей, используя этот шаблон:"

#: ../../library/unittest.mock.rst:1893
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"Обратите внимание, что декораторы применяются снизу вверх. Это стандартный "
"способ применения декораторов в Python. Порядок созданных макетов, "
"передаваемых в вашу тестовую функцию, соответствует этому порядку."

#: ../../library/unittest.mock.rst:1901
msgid "Where to patch"
msgstr "Где патчить"

#: ../../library/unittest.mock.rst:1903
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` работает путем (временного) изменения объекта, на который "
"указывает *имя*, на другой. Может быть много имен, указывающих на любой "
"отдельный объект, поэтому для того, чтобы исправление работало, вы должны "
"убедиться, что вы исправили имя, используемое тестируемой системой."

#: ../../library/unittest.mock.rst:1908
msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr ""
"Основной принцип заключается в том, что вы исправляете место, где "
"*просматривается* объект, и это не обязательно то же самое место, где он "
"определен. Несколько примеров помогут прояснить это."

#: ../../library/unittest.mock.rst:1912
msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr ""
"Представьте, что у нас есть проект, который мы хотим протестировать, со "
"следующей структурой:"

#: ../../library/unittest.mock.rst:1921
msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do then it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"Теперь мы хотим протестировать ``some_function``, но мы хотим смоделировать "
"``SomeClass``, используя :func:`patch`. Проблема в том, что когда мы "
"импортируем модуль b, что нам придется сделать, он импортирует ``SomeClass`` "
"из модуля a. Если мы используем :func:`patch` для макетирования ``a."
"SomeClass``, то это не окажет никакого влияния на наш тест; модуль b уже "
"имеет ссылку на *реальный* ``SomeClass``, и похоже, что наши исправления не "
"оказали никакого эффекта."

#: ../../library/unittest.mock.rst:1928
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"Ключевым моментом является исправление ``SomeClass`` там, где он "
"используется (или где его ищут). В этом случае some_function на самом деле "
"будет искать SomeClass в модуле b, куда мы его импортировали. Патч должен "
"выглядеть так:"

#: ../../library/unittest.mock.rst:1934
msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"Однако рассмотрим альтернативный сценарий, где вместо ``из импорта "
"SomeClass`` модуль b ``импортирует a``, а ``some_function`` использует ``a."
"SomeClass``. Обе эти формы импорта распространены. В этом случае класс, "
"который мы хотим исправить, ищется в модуле, и поэтому вместо этого нам "
"нужно исправить ``a.SomeClass``::"

#: ../../library/unittest.mock.rst:1943
msgid "Patching Descriptors and Proxy Objects"
msgstr "Исправление дескрипторов и прокси-объектов"

#: ../../library/unittest.mock.rst:1945
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"И patch_, и patch.object_ корректно исправляют и восстанавливают "
"дескрипторы: методы класса, статические методы и свойства. Вам следует "
"исправлять их в *классе*, а не в экземпляре. Они также работают с "
"*некоторыми* объектами, которые имеют доступ к атрибутам прокси, например, с "
"объектом настроек django <https://web.archive.org/web/20200603181648/http://"
"www.voidspace.org.uk/python/weblog/ Arch_d7_2010_12_04.shtml#e1198>`_."

#: ../../library/unittest.mock.rst:1953
msgid "MagicMock and magic method support"
msgstr "Поддержка MagicMock и магических методов."

#: ../../library/unittest.mock.rst:1958
msgid "Mocking Magic Methods"
msgstr "Mocking Magic Methods"

#: ../../library/unittest.mock.rst:1960
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as :"
"term:`\"magic methods\" <magic method>`. This allows mock objects to replace "
"containers or other objects that implement Python protocols."
msgstr ""
":class:`Mock` поддерживает имитацию методов протокола Python, также "
"известных как :term:`\"магические методы\" <магический метод>`. Это "
"позволяет макетным объектам заменять контейнеры или другие объекты, "
"реализующие протоколы Python."

#: ../../library/unittest.mock.rst:1964
msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"Потому что магические методы ищутся иначе, чем обычные методы. [#]_ , эта "
"поддержка была специально реализована. Это означает, что поддерживаются "
"только определенные магические методы. Список поддерживаемых включает "
"*почти* все из них. Если вам что-то не хватает, пожалуйста, сообщите нам об "
"этом."

#: ../../library/unittest.mock.rst:1969
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr ""
"Вы имитируете магические методы, устанавливая интересующий вас метод в "
"функцию или фиктивный экземпляр. Если вы используете функцию, то она "
"*должна* принимать ``self`` в качестве первого аргумента. [#]_ ."

#: ../../library/unittest.mock.rst:1992
msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr ""
"Одним из вариантов использования этого является имитация объектов, "
"используемых в качестве менеджеров контекста в операторе :keyword:`with`:"

#: ../../library/unittest.mock.rst:2004
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"Вызовы магических методов не отображаются в :attr:`~Mock.method_calls`, но "
"они записываются в :attr:`~Mock.mock_calls`."

#: ../../library/unittest.mock.rst:2009
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr ""
"Если вы используете аргумент ключевого слова *spec* для создания макета, то "
"попытка установить магический метод, которого нет в спецификации, приведет к "
"возникновению ошибки :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:2012
msgid "The full list of supported magic methods is:"
msgstr "Полный список поддерживаемых магических методов:"

#: ../../library/unittest.mock.rst:2014
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"

#: ../../library/unittest.mock.rst:2015
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__`` and ``__subclasses__``"

#: ../../library/unittest.mock.rst:2016
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"

#: ../../library/unittest.mock.rst:2017
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"Сравнения: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` и "
"``__ne__``"

#: ../../library/unittest.mock.rst:2019
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"контейнер методы: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` и "
"``__missing__``"

#: ../../library/unittest.mock.rst:2022
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr ""
"контекстный менеджер: ``__enter__``, ``__exit__``, ``__aenter__`` и "
"``__aexit__``"

#: ../../library/unittest.mock.rst:2023
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "Унарные числовые методы: ``__neg__``, ``__pos__`` и ``__invert__``"

#: ../../library/unittest.mock.rst:2024
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"Числовые методы (включая правосторонние и локальные варианты): ``__add__``, "
"``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, ``__floordiv__``, "
"``__mod__``, ``__divmod__``, ``__lshift__``, ``__rshift__``, ``__and__``, "
"``__xor__``, ``__or__`` и ``__pow__``"

#: ../../library/unittest.mock.rst:2028
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr ""
"Методы числового преобразования: ``__complex__``, ``__int__``, ``__float__`` "
"и ``__index__``"

#: ../../library/unittest.mock.rst:2030
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "Методы дескриптора: ``__get__``, ``__set__`` и ``__delete__``"

#: ../../library/unittest.mock.rst:2031
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"Маринование: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` и ``__setstate__``"

#: ../../library/unittest.mock.rst:2033
msgid "File system path representation: ``__fspath__``"
msgstr "Представление пути файловой системы: ``__fspath__``"

#: ../../library/unittest.mock.rst:2034
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "Асинхронные методы итерации: ``__aiter__`` и ``__anext__``"

#: ../../library/unittest.mock.rst:2036
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "Добавлена ​​поддержка :func:`os.PathLike.__fspath__`."

#: ../../library/unittest.mock.rst:2039
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"Добавлена ​​поддержка ``__aenter__``, ``__aexit__``, ``__aiter__`` и "
"``__anext__``."

#: ../../library/unittest.mock.rst:2043
msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"Следующие методы существуют, но *не* поддерживаются, поскольку они либо "
"используются макетом, не могут быть установлены динамически или могут "
"вызывать проблемы:"

#: ../../library/unittest.mock.rst:2046
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"

#: ../../library/unittest.mock.rst:2047
msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"

#: ../../library/unittest.mock.rst:2052
msgid "Magic Mock"
msgstr "Волшебный макет"

#: ../../library/unittest.mock.rst:2054
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"Существует два варианта MagicMock: :class:`MagicMock` и :class:"
"`NonCallableMagicMock`."

#: ../../library/unittest.mock.rst:2059
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the :term:`magic methods <magic method>`. You can use ``MagicMock`` "
"without having to configure the magic methods yourself."
msgstr ""
"``MagicMock`` является подклассом :class:`Mock` с реализациями по умолчанию "
"большинства :term:`magic методов <magic Method>`. Вы можете использовать "
"MagicMock без необходимости самостоятельно настраивать магические методы."

#: ../../library/unittest.mock.rst:2063
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "Параметры конструктора имеют то же значение, что и для :class:`Mock`."

#: ../../library/unittest.mock.rst:2065
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr ""
"Если вы используете аргументы *spec* или *spec_set*, будут созданы *только* "
"магические методы, существующие в спецификации."

#: ../../library/unittest.mock.rst:2071
msgid "A non-callable version of :class:`MagicMock`."
msgstr "Невызываемая версия :class:`MagicMock`."

#: ../../library/unittest.mock.rst:2073
msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"Параметры конструктора имеют то же значение, что и для :class:`MagicMock`, "
"за исключением *return_value* и *side_effect*, которые не имеют значения для "
"невызываемого макета."

#: ../../library/unittest.mock.rst:2077
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr ""
"Магические методы настраиваются с помощью объектов :class:`MagicMock`, "
"поэтому вы можете настроить их и использовать обычным способом:"

#: ../../library/unittest.mock.rst:2087
msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"По умолчанию многие методы протокола должны возвращать объекты определенного "
"типа. Эти методы предварительно настроены с возвращаемым значением по "
"умолчанию, поэтому их можно использовать без необходимости делать что-либо, "
"если возвращаемое значение вас не интересует. Вы по-прежнему можете "
"*установить* возвращаемое значение вручную, если хотите изменить значение по "
"умолчанию."

#: ../../library/unittest.mock.rst:2093
msgid "Methods and their defaults:"
msgstr "Методы и их значения по умолчанию:"

#: ../../library/unittest.mock.rst:2095
msgid "``__lt__``: :data:`NotImplemented`"
msgstr "``__lt__``: :data:`NotImplemented`"

#: ../../library/unittest.mock.rst:2096
msgid "``__gt__``: :data:`!NotImplemented`"
msgstr "``__gt__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2097
msgid "``__le__``: :data:`!NotImplemented`"
msgstr "``__le__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2098
msgid "``__ge__``: :data:`!NotImplemented`"
msgstr "``__ge__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2099
msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

#: ../../library/unittest.mock.rst:2100
msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

#: ../../library/unittest.mock.rst:2101
msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

#: ../../library/unittest.mock.rst:2102
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

#: ../../library/unittest.mock.rst:2103
msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

#: ../../library/unittest.mock.rst:2104
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

#: ../../library/unittest.mock.rst:2105
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``: ``1j``"

#: ../../library/unittest.mock.rst:2106
msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1.0``"

#: ../../library/unittest.mock.rst:2107
msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``True``"

#: ../../library/unittest.mock.rst:2108
msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

#: ../../library/unittest.mock.rst:2109
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: хеш по умолчанию для макета"

#: ../../library/unittest.mock.rst:2110
msgid "``__str__``: default str for the mock"
msgstr "``__str__``: строка по умолчанию для макета"

#: ../../library/unittest.mock.rst:2111
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: размер по умолчанию для макета"

#: ../../library/unittest.mock.rst:2113
msgid "For example:"
msgstr "Например:"

#: ../../library/unittest.mock.rst:2125
msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""
"Два метода равенства, :meth:`!__eq__` и :meth:`!__ne__`, являются "
"особенными. Они выполняют сравнение на равенство по умолчанию, используя "
"атрибут :attr:`~Mock.side_effect`, если вы не измените их возвращаемое "
"значение, чтобы оно возвращало что-то другое::"

#: ../../library/unittest.mock.rst:2139
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ""
"Возвращаемое значение :meth:`MagicMock.__iter__` может быть любым "
"итерируемым объектом и не обязательно должно быть итератором:"

#: ../../library/unittest.mock.rst:2149
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr ""
"Если возвращаемое значение *является* итератором, то однократная итерация по "
"нему будет использовать его, а последующие итерации приведут к пустому "
"списку:"

#: ../../library/unittest.mock.rst:2158
msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr ""
"В ``MagicMock`` настроены все поддерживаемые магические методы, за "
"исключением некоторых непонятных и устаревших. Вы все равно можете настроить "
"их, если хотите."

#: ../../library/unittest.mock.rst:2161
msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr ""
"Волшебные методы, которые поддерживаются, но не настраиваются по умолчанию в "
"MagicMock:"

#: ../../library/unittest.mock.rst:2163
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2164
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2165
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2166
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__`` и ``__delete__``"

#: ../../library/unittest.mock.rst:2167
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__`` и ``__missing__``"

#: ../../library/unittest.mock.rst:2168
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` и ``__setstate__``"

#: ../../library/unittest.mock.rst:2170
msgid "``__getformat__``"
msgstr "``__getformat__``"

#: ../../library/unittest.mock.rst:2174
msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"Волшебные методы *следует* искать в классе, а не в экземпляре. Различные "
"версии Python по-разному применяют это правило. Поддерживаемые методы "
"протокола должны работать со всеми поддерживаемыми версиями Python."

#: ../../library/unittest.mock.rst:2178
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr ""
"Функция в основном привязана к классу, но каждый экземпляр Mock изолирован "
"от других."

#: ../../library/unittest.mock.rst:2183
msgid "Helpers"
msgstr "Помощники"

#: ../../library/unittest.mock.rst:2186
msgid "sentinel"
msgstr "дозорный"

#: ../../library/unittest.mock.rst:2190
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr ""
"Объект Sentinel предоставляет удобный способ предоставления уникальных "
"объектов для ваших тестов."

#: ../../library/unittest.mock.rst:2193
msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr ""
"Атрибуты создаются по требованию, когда вы обращаетесь к ним по имени. "
"Доступ к одному и тому же атрибуту всегда будет возвращать один и тот же "
"объект. Возвращенные объекты имеют разумное представление, поэтому сообщения "
"об ошибках теста можно прочитать."

#: ../../library/unittest.mock.rst:2197
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"Атрибуты ``sentinel`` теперь сохраняют свою идентичность, когда они :mod:"
"`копируются <copy>` или :mod:`маринуются <pickle>`."

#: ../../library/unittest.mock.rst:2201
msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"Иногда при тестировании вам необходимо проверить, что конкретный объект "
"передается в качестве аргумента другому методу или возвращается. Для "
"проверки этого может быть обычным создание именованных сторожевых объектов. :"
"data:`sentinel` предоставляет удобный способ создания и проверки подлинности "
"подобных объектов."

#: ../../library/unittest.mock.rst:2206
msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr ""
"В этом примере мы обрабатываем ``method``, чтобы вернуть ``sentinel."
"some_object``:"

#: ../../library/unittest.mock.rst:2218
msgid "DEFAULT"
msgstr "DEFAULT"

#: ../../library/unittest.mock.rst:2223
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
"Объект :data:`DEFAULT` — это заранее созданный дозорный (на самом деле "
"``sentinel.DEFAULT``). Его можно использовать функциями :attr:`~Mock."
"side_effect`, чтобы указать, что следует использовать обычное возвращаемое "
"значение."

#: ../../library/unittest.mock.rst:2229
msgid "call"
msgstr "call"

#: ../../library/unittest.mock.rst:2233
msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` — вспомогательный объект для создания более простых "
"утверждений, для сравнения с :attr:`~Mock.call_args`, :attr:`~Mock."
"call_args_list`, :attr:`~Mock.mock_calls` и :attr :`~Mock.method_calls`. :"
"func:`call` также можно использовать с :meth:`~Mock.assert_has_calls`."

#: ../../library/unittest.mock.rst:2246
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr ""
"Для объекта вызова, который представляет несколько вызовов, :meth:"
"`call_list` возвращает список всех промежуточных вызовов, а также финальный "
"вызов."

#: ../../library/unittest.mock.rst:2250
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` особенно полезен для создания утверждений о \"связанных "
"вызовах\". Связанный вызов — это несколько вызовов в одной строке кода. Это "
"приводит к появлению нескольких записей в :attr:`~Mock.mock_calls` для "
"макета. Создание последовательности вызовов вручную может быть утомительным."

#: ../../library/unittest.mock.rst:2255
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ""
":meth:`~call.call_list` может создать последовательность вызовов из одного и "
"того же связанного вызова:"

#: ../../library/unittest.mock.rst:2272
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"Объект ``call`` представляет собой кортеж из (позиционных аргументов, "
"аргументов ключевого слова) или (имя, позиционных аргументов, аргументов "
"ключевого слова) в зависимости от того, как он был создан. Когда вы создаете "
"их самостоятельно, это не представляет особого интереса, но объекты "
"``call``, находящиеся в :attr:`Mock.call_args`, :attr:`Mock.call_args_list` "
"и :attr:`Mock.mock_calls` Атрибуты можно проанализировать, чтобы получить "
"отдельные аргументы, которые они содержат."

#: ../../library/unittest.mock.rst:2279
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
"Объекты ``call`` в :attr:`Mock.call_args` и :attr:`Mock.call_args_list` "
"представляют собой два кортежа (позиционные аргументы, ключевые слова args), "
"тогда как объекты ``call`` в :attr:` Mock.mock_calls`, а также те, которые "
"вы создаете самостоятельно, представляют собой три кортежа (имя, позиционные "
"аргументы, аргументы ключевого слова)."

#: ../../library/unittest.mock.rst:2284
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"Вы можете использовать их «кортежность», чтобы извлечь отдельные аргументы "
"для более сложного самоанализа и утверждений. Позиционные аргументы "
"представляют собой кортеж (пустой кортеж, если позиционных аргументов нет), "
"а аргументы ключевого слова представляют собой словарь:"

#: ../../library/unittest.mock.rst:2317
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2321
msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr ""
"Создайте макет объекта, используя другой объект в качестве спецификации. "
"Атрибуты макета будут использовать соответствующий атрибут объекта *spec* в "
"качестве своей спецификации."

#: ../../library/unittest.mock.rst:2325
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr ""
"Аргументы имитируемых функций или методов будут проверены, чтобы убедиться, "
"что они вызываются с правильной сигнатурой."

#: ../../library/unittest.mock.rst:2328
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"Если *spec_set* имеет значение ``True``, то попытка установить атрибуты, "
"которых нет в объекте спецификации, приведет к возникновению ошибки :exc:"
"`AttributeError`."

#: ../../library/unittest.mock.rst:2331
msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"Если класс используется в качестве спецификации, то возвращаемое значение "
"макета (экземпляр класса) будет иметь ту же спецификацию. Вы можете "
"использовать класс в качестве спецификации объекта экземпляра, передав "
"``instance=True``. Возвращенный макет будет доступен для вызова только в том "
"случае, если можно вызвать экземпляры макета."

#: ../../library/unittest.mock.rst:2336
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ""
":func:`create_autospec` также принимает произвольные аргументы ключевого "
"слова, которые передаются конструктору созданного макета."

#: ../../library/unittest.mock.rst:2339
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"См. :ref:`auto-speccing` для примеров того, как использовать автоматическую "
"спецификацию с :func:`create_autospec` и аргументом *autospec* для :func:"
"`patch`."

#: ../../library/unittest.mock.rst:2345
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ""
":func:`create_autospec` теперь возвращает :class:`AsyncMock`, если целью "
"является асинхронная функция."

#: ../../library/unittest.mock.rst:2350
msgid "ANY"
msgstr "ANY"

#: ../../library/unittest.mock.rst:2354
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"Иногда вам может потребоваться сделать утверждения о *некоторых* аргументах "
"в вызове макета, но вы либо не заботитесь о некоторых аргументах, либо "
"хотите вытащить их по отдельности из :attr:`~Mock.call_args` и сделать более "
"сложным. утверждения о них."

#: ../../library/unittest.mock.rst:2359
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"Чтобы игнорировать определенные аргументы, вы можете передать объекты, "
"которые при сравнении равны *всем*. Вызовы :meth:`~Mock.assert_called_with` "
"и :meth:`~Mock.assert_known_once_with` будут успешными независимо от того, "
"что было передано."

#: ../../library/unittest.mock.rst:2368
msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ""
":data:`ANY` также можно использовать в сравнении со списками вызовов, "
"например :attr:`~Mock.mock_calls`:"

#: ../../library/unittest.mock.rst:2378
msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can also "
"be used in test assertions::"
msgstr ""
":data:`ANY` не ограничивается сравнением с объектами вызова и поэтому может "
"также использоваться в тестовых утверждениях::"

#: ../../library/unittest.mock.rst:2389
msgid "FILTER_DIR"
msgstr "FILTER_DIR"

#: ../../library/unittest.mock.rst:2393
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` — это переменная уровня модуля, которая управляет тем, "
"как макетные объекты реагируют на :func:`dir`. По умолчанию установлено "
"значение True, при котором используется фильтрация, описанная ниже, для "
"отображения только полезных элементов. Если вам не нравится эта фильтрация "
"или вам нужно отключить ее в диагностических целях, установите ``mock."
"FILTER_DIR = False``."

#: ../../library/unittest.mock.rst:2399
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"При включенной фильтрации ``dir(some_mock)`` показывает только полезные "
"атрибуты и включает любые динамически созданные атрибуты, которые обычно не "
"отображаются. Если макет был создан с использованием *spec* (или, конечно, "
"*autospec*), то отображаются все атрибуты оригинала, даже если к ним еще не "
"обращались:"

#: ../../library/unittest.mock.rst:2426
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"Многие из не очень полезных (приватных для :class:`Mock`, а не для того, над "
"чем высмеивают) атрибутов подчеркивания и двойного подчеркивания с префиксом "
"были отфильтрованы из результата вызова :func:`dir` в :class:` Мок`. Если "
"вам не нравится такое поведение, вы можете отключить его, установив "
"переключатель уровня модуля :data:`FILTER_DIR`:"

#: ../../library/unittest.mock.rst:2447
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :const:`mock.FILTER_DIR`."
msgstr ""
"В качестве альтернативы вы можете просто использовать ``vars(my_mock)`` "
"(члены экземпляра) и ``dir(type(my_mock))`` (члены типа), чтобы обойти "
"фильтрацию независимо от :const:`mock.FILTER_DIR`."

#: ../../library/unittest.mock.rst:2453
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2457
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
"Вспомогательная функция для создания макета вместо использования :func:"
"`open`. Это работает для :func:`open`, вызываемого напрямую или "
"используемого в качестве менеджера контекста."

#: ../../library/unittest.mock.rst:2460
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"Аргумент *mock* — это фиктивный объект для настройки. Если «Нет» (по "
"умолчанию), то для вас будет создан :class:`MagicMock`, а API ограничен "
"методами или атрибутами, доступными в стандартных дескрипторах файлов."

#: ../../library/unittest.mock.rst:2464
msgid ""
"*read_data* is a string for the :meth:`~io.IOBase.read`, :meth:`~io.IOBase."
"readline`, and :meth:`~io.IOBase.readlines` methods of the file handle to "
"return.  Calls to those methods will take data from *read_data* until it is "
"depleted.  The mock of these methods is pretty simplistic: every time the "
"*mock* is called, the *read_data* is rewound to the start.  If you need more "
"control over the data that you are feeding to the tested code you will need "
"to customize this mock for yourself.  When that is insufficient, one of the "
"in-memory filesystem packages on `PyPI <https://pypi.org>`_ can offer a "
"realistic filesystem for testing."
msgstr ""
"*read_data* — это строка для методов :meth:`~io.IOBase.read`, :meth:`~io."
"IOBase.readline` и :meth:`~io.IOBase.readlines` дескриптора файла. "
"возвращаться. Вызовы этих методов будут брать данные из *read_data*, пока "
"они не будут исчерпаны. Имитация этих методов довольно упрощена: каждый раз, "
"когда вызывается *mock*, *read_data* перематывается на начало. Если вам "
"нужен больший контроль над данными, которые вы передаете в тестируемый код, "
"вам нужно будет настроить этот макет под себя. Если этого недостаточно, один "
"из пакетов файловой системы в памяти PyPI <https://pypi.org>_ может "
"предложить реалистичную файловую систему для тестирования."

#: ../../library/unittest.mock.rst:2474
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.IOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
"Добавлена ​​поддержка :meth:`~io.IOBase.readline` и :meth:`~io.IOBase."
"readlines`. Макет :meth:`~io.IOBase.read` изменен на использование "
"*read_data* вместо того, чтобы возвращать его при каждом вызове."

#: ../../library/unittest.mock.rst:2479
msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data* теперь сбрасывается при каждом вызове *mock*."

#: ../../library/unittest.mock.rst:2482
msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration (such "
"as in for loops) correctly consumes *read_data*."
msgstr ""
"В реализацию добавлен :meth:`~container.__iter__`, чтобы итерация (например, "
"в циклах for) правильно использовала *read_data*."

#: ../../library/unittest.mock.rst:2486
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr ""
"Использование :func:`open` в качестве менеджера контекста — отличный способ "
"обеспечить правильное закрытие дескрипторов файлов, и это становится обычным "
"явлением:"

#: ../../library/unittest.mock.rst:2492
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:`~object."
"__enter__` and :meth:`~object.__exit__` called)."
msgstr ""
"Проблема в том, что даже если вы имитируете вызов :func:`open`, это "
"*возвращенный объект*, который используется в качестве контекстного "
"менеджера (и имеет :meth:`~object.__enter__` и :meth:`~ вызывается object."
"__exit__`)."

#: ../../library/unittest.mock.rst:2496
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ""
"Имитация менеджеров контекста с помощью :class:`MagicMock` достаточно "
"распространена и достаточно сложна, поэтому вспомогательная функция может "
"оказаться полезной. ::"

#: ../../library/unittest.mock.rst:2513
msgid "And for reading files::"
msgstr "И для чтения файлов::"

#: ../../library/unittest.mock.rst:2526
msgid "Autospeccing"
msgstr "Автоматическая настройка"

#: ../../library/unittest.mock.rst:2528
msgid ""
"Autospeccing is based on the existing :attr:`spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"Автоспецификация основана на существующей функции макета :attr:`spec`. Он "
"ограничивает API-интерфейсы макетов API исходного объекта (спецификации), но "
"он рекурсивен (реализуется лениво), так что атрибуты макетов имеют только "
"тот же API, что и атрибуты спецификации. Кроме того, имитируемые функции/"
"методы имеют ту же сигнатуру вызова, что и исходные, поэтому они вызывают "
"ошибку :exc:`TypeError`, если они вызваны неправильно."

#: ../../library/unittest.mock.rst:2535
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr ""
"Прежде чем я объясню, как работает автоопределение, расскажу, почему оно "
"необходимо."

#: ../../library/unittest.mock.rst:2537
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from "
"two flaws when used to mock out objects from a system under test. One of "
"these flaws is specific to the :class:`Mock` api and the other is a more "
"general problem with using mock objects."
msgstr ""

#: ../../library/unittest.mock.rst:2542
msgid ""
"First the problem specific to :class:`Mock`. :class:`Mock` has two assert "
"methods that are extremely handy: :meth:`~Mock.assert_called_with` and :meth:"
"`~Mock.assert_called_once_with`."
msgstr ""

#: ../../library/unittest.mock.rst:2555
msgid ""
"Because mocks auto-create attributes on demand, and allow you to call them "
"with arbitrary arguments, if you misspell one of these assert methods then "
"your assertion is gone:"
msgstr ""

#: ../../library/unittest.mock.rst:2565
msgid "Your tests can pass silently and incorrectly because of the typo."
msgstr ""

#: ../../library/unittest.mock.rst:2567
msgid ""
"The second issue is more general to mocking. If you refactor some of your "
"code, rename members and so on, any tests for code that is still using the "
"*old api* but uses mocks instead of the real objects will still pass. This "
"means your tests can all pass even though your code is broken."
msgstr ""

#: ../../library/unittest.mock.rst:2572
msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"Обратите внимание, что это еще одна причина, по которой вам нужны "
"интеграционные тесты, а также модульные тесты. Тестировать все по "
"отдельности — это прекрасно, но если вы не проверяете, как ваши устройства "
"«соединены вместе», остается много места для ошибок, которые могли быть "
"обнаружены тестами."

#: ../../library/unittest.mock.rst:2577
msgid ""
":mod:`mock` already provides a feature to help with this, called speccing. "
"If you use a class or instance as the :attr:`spec` for a mock then you can "
"only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`mock` уже предоставляет функцию, которая поможет в этом, называемую "
"спецификацией. Если вы используете класс или экземпляр в качестве :attr:"
"`spec` для макета, вы можете получить доступ только к атрибутам макета, "
"которые существуют в реальном классе:"

#: ../../library/unittest.mock.rst:2588
msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr ""
"Спецификация применима только к самому макету, поэтому у нас все еще есть та "
"же проблема с любыми методами макета:"

#: ../../library/unittest.mock.rst:2597
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"Автоопределение решает эту проблему. Вы можете либо передать "
"``autospec=True`` в :func:`patch` / :func:`patch.object`, либо использовать "
"функцию :func:`create_autospec` для создания макета со спецификацией. Если "
"вы используете аргумент ``autospec=True`` для :func:`patch`, то заменяемый "
"объект будет использоваться как объект спецификации. Поскольку спецификация "
"выполняется «лениво» (спецификация создается при доступе к атрибутам "
"макета), вы можете использовать ее с очень сложными или глубоко вложенными "
"объектами (например, с модулями, которые импортируют модули, которые "
"импортируют модули) без большого снижения производительности."

#: ../../library/unittest.mock.rst:2606
msgid "Here's an example of it in use::"
msgstr "Вот пример его использования::"

#: ../../library/unittest.mock.rst:2616
msgid ""
"You can see that :class:`request.Request` has a spec. :class:`request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
"Вы можете видеть, что :class:`request.Request` имеет спецификацию. :class:"
"`request.Request` принимает в конструкторе два аргумента (один из которых "
"*self*). Вот что произойдет, если мы попытаемся вызвать его неправильно:"

#: ../../library/unittest.mock.rst:2625
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr ""
"Спецификация также применима к созданным классам (т.е. возвращаемому "
"значению указанных макетов)::"

#: ../../library/unittest.mock.rst:2632
msgid ""
":class:`Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
"Объекты :class:`Request` не подлежат вызову, поэтому возвращаемое значение "
"создания экземпляра нашего макета :class:`request.Request` является "
"невызываемым макетом. При наличии спецификации любые опечатки в наших "
"утверждениях вызовут правильную ошибку::"

#: ../../library/unittest.mock.rst:2644
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"Во многих случаях вы сможете просто добавить autospec=True к существующим "
"вызовам :func:`patch` и затем быть защищены от ошибок из-за опечаток и "
"изменений API."

#: ../../library/unittest.mock.rst:2648
msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"Помимо использования *autospec* через :func:`patch`, существует :func:"
"`create_autospec` для непосредственного создания автоспецифицированных "
"макетов:"

#: ../../library/unittest.mock.rst:2656
msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"Однако здесь есть оговорки и ограничения, поэтому это не поведение по "
"умолчанию. Чтобы узнать, какие атрибуты доступны в объекте спецификации, "
"autospec должен проанализировать (получить доступ к атрибутам) спецификацию. "
"Когда вы перемещаетесь по атрибутам в макете, под капотом происходит "
"соответствующий обход исходного объекта. Если какой-либо из ваших указанных "
"объектов имеет свойства или дескрипторы, которые могут инициировать "
"выполнение кода, возможно, вы не сможете использовать автоспецификацию. С "
"другой стороны, гораздо лучше проектировать объекты так, чтобы самоанализ "
"был безопасен. [#]_ ."

#: ../../library/unittest.mock.rst:2665
msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`~object.__init__` method and not to exist on the class "
"at all. *autospec* can't know about any dynamically created attributes and "
"restricts the api to visible attributes. ::"
msgstr ""
"Более серьезная проблема заключается в том, что атрибуты экземпляра обычно "
"создаются в методе :meth:`~object.__init__` и вообще не существуют в классе. "
"*autospec* не может знать ни о каких динамически создаваемых атрибутах и ​​"
"ограничивает API видимыми атрибутами. ::"

#: ../../library/unittest.mock.rst:2682
msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"Есть несколько различных способов решения этой проблемы. Самый простой, но "
"не обязательно наименее раздражающий способ — просто установить необходимые "
"атрибуты макета после создания. Тот факт, что *autospec* не позволяет вам "
"получать атрибуты, которых нет в спецификации, не мешает вам их "
"устанавливать::"

#: ../../library/unittest.mock.rst:2693
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"Существует более агрессивная версия *spec* и *autospec*, которая *не* "
"предотвращает установку несуществующих атрибутов. Это полезно, если вы "
"хотите, чтобы ваш код также *устанавливал* действительные атрибуты, но, "
"очевидно, это предотвращает этот конкретный сценарий:"

#: ../../library/unittest.mock.rst:2706
msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`~object.__init__`. "
"Note that if you are only setting default attributes in :meth:`!__init__` "
"then providing them via class attributes (shared between instances of "
"course) is faster too. e.g."
msgstr ""
"Вероятно, лучший способ решить проблему — добавить атрибуты класса в "
"качестве значений по умолчанию для членов экземпляра, инициализированных в :"
"meth:`~object.__init__`. Обратите внимание: если вы устанавливаете только "
"атрибуты по умолчанию в :meth:`!__init__`, то предоставление их через "
"атрибуты класса (конечно, общие для всех экземпляров) также происходит "
"быстрее. например"

#: ../../library/unittest.mock.rst:2717
msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"Это поднимает еще одну проблему. Относительно распространено предоставление "
"значения по умолчанию «Нет» для членов, которые позже станут объектами "
"другого типа. ``None`` был бы бесполезен в качестве спецификации, потому что "
"он не позволял бы вам получить доступ к *любым* атрибутам или методам. "
"Поскольку ``None`` *никогда* не будет полезен в качестве спецификации и, "
"вероятно, указывает на элемент, который обычно имеет какой-то другой тип, "
"autospec не использует спецификацию для членов, для которых установлено "
"значение ``None``. Это будут просто обычные моки (ну — MagicMocks):"

#: ../../library/unittest.mock.rst:2732
msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"Если вам не нравится изменение ваших производственных классов для добавления "
"значений по умолчанию, есть больше вариантов. Один из них — просто "
"использовать экземпляр в качестве спецификации, а не класса. Другой вариант "
"— создать подкласс производственного класса и добавить в него значения по "
"умолчанию, не затрагивая производственный класс. Оба из них требуют "
"использования альтернативного объекта в качестве спецификации. К счастью, :"
"func:`patch` поддерживает это - вы можете просто передать альтернативный "
"объект в качестве аргумента *autospec*::"

#: ../../library/unittest.mock.rst:2753
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"Это применимо только к классам или уже созданным объектам. Вызов фиктивного "
"класса для создания фиктивного экземпляра *не* создает реальный экземпляр. "
"Выполняется только поиск атрибутов вместе с вызовами :func:`dir`."

#: ../../library/unittest.mock.rst:2758
msgid "Sealing mocks"
msgstr "Уплотнительные макеты"

#: ../../library/unittest.mock.rst:2767
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr ""
"Seal отключит автоматическое создание макетов при доступе к атрибуту "
"запечатываемого макета или к любому из его атрибутов, которые уже являются "
"макетами рекурсивно."

#: ../../library/unittest.mock.rst:2770
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""
"Если атрибуту присвоен фиктивный экземпляр с именем или спецификацией, он не "
"будет учитываться в цепочке запечатывания. Это позволяет предотвратить "
"фиксацию пломбой части макета объекта. ::"

#: ../../library/unittest.mock.rst:2786
msgid ""
"Order of precedence of :attr:`side_effect`, :attr:`return_value` and *wraps*"
msgstr "Порядок приоритета :attr:`side_effect`, :attr:`return_value` и *wraps*"

#: ../../library/unittest.mock.rst:2788
msgid "The order of their precedence is:"
msgstr "Порядок их старшинства следующий:"

#: ../../library/unittest.mock.rst:2790
msgid ":attr:`~Mock.side_effect`"
msgstr ":attr:`~Mock.side_effect`"

#: ../../library/unittest.mock.rst:2791
msgid ":attr:`~Mock.return_value`"
msgstr ":attr:`~Mock.return_value`"

#: ../../library/unittest.mock.rst:2792
msgid "*wraps*"
msgstr "*wraps*"

#: ../../library/unittest.mock.rst:2794
msgid ""
"If all three are set, mock will return the value from :attr:`~Mock."
"side_effect`, ignoring :attr:`~Mock.return_value` and the wrapped object "
"altogether. If any two are set, the one with the higher precedence will "
"return the value. Regardless of the order of which was set first, the order "
"of precedence remains unchanged."
msgstr ""
"Если все три установлены, макет вернет значение из :attr:`~Mock."
"side_effect`, полностью игнорируя :attr:`~Mock.return_value` и обернутый "
"объект. Если установлены любые два, значение будет возвращено значение с "
"более высоким приоритетом. Независимо от того, какой порядок был установлен "
"первым, порядок приоритета остается неизменным."

#: ../../library/unittest.mock.rst:2812
msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be checked "
"between :attr:`~Mock.return_value` and the wrapped object, ignoring :attr:"
"`~Mock.side_effect`."
msgstr ""
"Поскольку ``None`` является значением по умолчанию для :attr:`~Mock."
"side_effect`, если вы переназначите его значение обратно на ``None``, "
"порядок приоритета будет проверен между :attr:`~Mock.return_value ` и "
"обернутый объект, игнорируя :attr:`~Mock.side_effect`."

#: ../../library/unittest.mock.rst:2821
msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is :data:`DEFAULT`, "
"it is ignored and the order of precedence moves to the successor to obtain "
"the value to return."
msgstr ""
"Если значение, возвращаемое :attr:`~Mock.side_effect`, равно :data:"
"`DEFAULT`, оно игнорируется, и порядок приоритета перемещается к преемнику, "
"чтобы получить возвращаемое значение."

#: ../../library/unittest.mock.rst:2830
msgid ""
"When :class:`Mock` wraps an object, the default value of :attr:`~Mock."
"return_value` will be :data:`DEFAULT`."
msgstr ""
"Когда :class:`Mock` оборачивает объект, значением по умолчанию :attr:`~Mock."
"return_value` будет :data:`DEFAULT`."

#: ../../library/unittest.mock.rst:2839
msgid ""
"The order of precedence will ignore this value and it will move to the last "
"successor which is the wrapped object."
msgstr ""
"Порядок приоритета будет игнорировать это значение и переместится к "
"последнему преемнику, который является обернутым объектом."

#: ../../library/unittest.mock.rst:2842
msgid ""
"As the real call is being made to the wrapped object, creating an instance "
"of this mock will return the real instance of the class. The positional "
"arguments, if any, required by the wrapped object must be passed."
msgstr ""
"Поскольку реальный вызов выполняется к обернутому объекту, создание "
"экземпляра этого макета вернет реальный экземпляр класса. Должны быть "
"переданы позиционные аргументы, если таковые имеются, необходимые для "
"обернутого объекта."

#: ../../library/unittest.mock.rst:2860
msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr ""
"Но если вы присвоите ему None, это не будет проигнорировано, поскольку это "
"явное присвоение. Таким образом, порядок приоритета не будет перенесен на "
"обернутый объект."

#: ../../library/unittest.mock.rst:2868
msgid ""
"Even if you set all three at once when initializing the mock, the order of "
"precedence remains the same:"
msgstr ""
"Даже если вы установите все три одновременно при инициализации макета, "
"порядок приоритета останется прежним:"

#: ../../library/unittest.mock.rst:2885
msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will not "
"cause a value to be obtained from the successors. Instead, ``StopIteration`` "
"exception is raised."
msgstr ""
"Если :attr:`~Mock.side_effect` исчерпан, порядок приоритета не приведет к "
"получению значения от наследников. Вместо этого возникает исключение "
"StopIteration."
