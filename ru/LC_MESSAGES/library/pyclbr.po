# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:18+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/pyclbr.rst:2
msgid ":mod:`pyclbr` --- Python module browser support"
msgstr ""

#: ../../library/pyclbr.rst:9
msgid "**Source code:** :source:`Lib/pyclbr.py`"
msgstr "**Исходный код:** :source:`Lib/pyclbr.py`"

#: ../../library/pyclbr.rst:13
msgid ""
"The :mod:`pyclbr` module provides limited information about the functions, "
"classes, and methods defined in a Python-coded module.  The information is "
"sufficient to implement a module browser.  The information is extracted from "
"the Python source code rather than by importing the module, so this module "
"is safe to use with untrusted code. This restriction makes it impossible to "
"use this module with modules not implemented in Python, including all "
"standard and optional extension modules."
msgstr ""
"Модуль :mod:`pyclbr` предоставляет ограниченную информацию о функциях, "
"классах и методах, определенных в модуле, написанном на Python. Информации "
"достаточно для реализации модуля браузера. Информация извлекается из "
"исходного кода Python, а не путем импорта модуля, поэтому этот модуль можно "
"безопасно использовать с ненадежным кодом. Это ограничение делает "
"невозможным использование этого модуля с модулями, не реализованными в "
"Python, включая все стандартные и дополнительные модули расширения."

#: ../../library/pyclbr.rst:25
msgid ""
"Return a dictionary mapping module-level class names to class descriptors.  "
"If possible, descriptors for imported base classes are included.  Parameter "
"*module* is a string with the name of the module to read; it may be the name "
"of a module within a package.  If given, *path* is a sequence of directory "
"paths prepended to ``sys.path``, which is used to locate the module source "
"code."
msgstr ""
"Возвращает имена классов уровня модуля словаря, сопоставляющие дескрипторы "
"классов. Если возможно, включаются дескрипторы импортированных базовых "
"классов. Параметр *module* — это строка с именем считываемого модуля; это "
"может быть имя модуля внутри пакета. Если задано, *path* представляет собой "
"последовательность путей к каталогам, добавленную к ``sys.path``, которая "
"используется для поиска исходного кода модуля."

#: ../../library/pyclbr.rst:32
msgid ""
"This function is the original interface and is only kept for back "
"compatibility.  It returns a filtered version of the following."
msgstr ""
"Эта функция является исходным интерфейсом и сохранена только для обратной "
"совместимости. Он возвращает отфильтрованную версию следующего."

#: ../../library/pyclbr.rst:38
msgid ""
"Return a dictionary-based tree containing a function or class descriptors "
"for each function and class defined in the module with a ``def`` or "
"``class`` statement.  The returned dictionary maps module-level function and "
"class names to their descriptors.  Nested objects are entered into the "
"children dictionary of their parent.  As with readmodule, *module* names the "
"module to be read and *path* is prepended to sys.path.  If the module being "
"read is a package, the returned dictionary has a key ``'__path__'`` whose "
"value is a list containing the package search path."
msgstr ""
"Возвращает дерево на основе словаря, содержащее дескрипторы функций или "
"классов для каждой функции и класса, определенных в модуле, с помощью "
"оператора def или class. Возвращенный словарь сопоставляет функции уровня "
"модуля и имена классов с их дескрипторами. Вложенные объекты вводятся в "
"дочерний словарь своего родителя. Как и в случае с readmodule, *module* "
"называет модуль, который нужно прочитать, а *path* добавляется к sys.path. "
"Если считываемый модуль является пакетом, возвращаемый словарь имеет ключ "
"``'__path__'``, значением которого является список, содержащий путь поиска "
"пакета."

#: ../../library/pyclbr.rst:48
msgid ""
"Descriptors for nested definitions.  They are accessed through the new "
"children attribute.  Each has a new parent attribute."
msgstr ""
"Дескрипторы для вложенных определений. Доступ к ним осуществляется через "
"новый атрибут Children. У каждого есть новый родительский атрибут."

#: ../../library/pyclbr.rst:52
msgid ""
"The descriptors returned by these functions are instances of Function and "
"Class classes.  Users are not expected to create instances of these classes."
msgstr ""
"Дескрипторы, возвращаемые этими функциями, являются экземплярами классов "
"Function и Class. От пользователей не ожидается создания экземпляров этих "
"классов."

#: ../../library/pyclbr.rst:60
msgid "Function Objects"
msgstr "Функциональные объекты"

#: ../../library/pyclbr.rst:64
msgid ""
"Class :class:`!Function` instances describe functions defined by def "
"statements.  They have the following attributes:"
msgstr ""
"Экземпляры класса :class:`!Function` описывают функции, определенные "
"операторами def. Они имеют следующие атрибуты:"

#: ../../library/pyclbr.rst:70
msgid "Name of the file in which the function is defined."
msgstr "Имя файла, в котором определена функция."

#: ../../library/pyclbr.rst:75
msgid "The name of the module defining the function described."
msgstr "Имя модуля, определяющего описываемую функцию."

#: ../../library/pyclbr.rst:80
msgid "The name of the function."
msgstr "Имя функции."

#: ../../library/pyclbr.rst:85 ../../library/pyclbr.rst:140
msgid "The line number in the file where the definition starts."
msgstr "Номер строки в файле, с которой начинается определение."

#: ../../library/pyclbr.rst:90
msgid "For top-level functions, ``None``.  For nested functions, the parent."
msgstr ""
"Для функций верхнего уровня — None. Для вложенных функций родительский."

#: ../../library/pyclbr.rst:97
msgid ""
"A :class:`dictionary <dict>` mapping names to descriptors for nested "
"functions and classes."
msgstr ""
":class:`dictionary <dict>` сопоставляет имена с дескрипторами вложенных "
"функций и классов."

#: ../../library/pyclbr.rst:105
msgid ""
"``True`` for functions that are defined with the :keyword:`async <async "
"def>` prefix, ``False`` otherwise."
msgstr ""
"``True`` для функций, которые определены с префиксом :keyword:`async <async "
"def>`, ``False`` в противном случае."

#: ../../library/pyclbr.rst:114
msgid "Class Objects"
msgstr "Классы"

#: ../../library/pyclbr.rst:118
msgid ""
"Class :class:`!Class` instances describe classes defined by class "
"statements.  They have the same attributes as :class:`Functions <Function>` "
"and two more."
msgstr ""
"Экземпляры класса :class:`!Class` описывают классы, определенные операторами "
"класса. Они имеют те же атрибуты, что и :class:`Functions <Function>` и еще "
"два."

#: ../../library/pyclbr.rst:125
msgid "Name of the file in which the class is defined."
msgstr "Имя файла, в котором определен класс."

#: ../../library/pyclbr.rst:130
msgid "The name of the module defining the class described."
msgstr "Имя модуля, определяющего описываемый класс."

#: ../../library/pyclbr.rst:135
msgid "The name of the class."
msgstr "Имя класса."

#: ../../library/pyclbr.rst:145
msgid "For top-level classes, None.  For nested classes, the parent."
msgstr ""

#: ../../library/pyclbr.rst:152
msgid ""
"A dictionary mapping names to descriptors for nested functions and classes."
msgstr ""
"Словарь, сопоставляющий имена с дескрипторами вложенных функций и классов."

#: ../../library/pyclbr.rst:160
msgid ""
"A list of :class:`!Class` objects which describe the immediate base classes "
"of the class being described.  Classes which are named as superclasses but "
"which are not discoverable by :func:`readmodule_ex` are listed as a string "
"with the class name instead of as :class:`!Class` objects."
msgstr ""
"Список объектов :class:`!Class`, которые описывают непосредственные базовые "
"классы описываемого класса. Классы, которые называются суперклассами, но не "
"могут быть обнаружены с помощью :func:`readmodule_ex`, перечислены в виде "
"строки с именем класса, а не как объекты :class:`!Class`."

#: ../../library/pyclbr.rst:169
msgid ""
"A :class:`dictionary <dict>` mapping method names to line numbers. This can "
"be derived from the newer :attr:`children` dictionary, but remains for back-"
"compatibility."
msgstr ""
":class:`dictionary <dict>` отображает имена методов на номера строк. Его "
"можно получить из более нового словаря :attr:`children`, но он остается для "
"обратной совместимости."
