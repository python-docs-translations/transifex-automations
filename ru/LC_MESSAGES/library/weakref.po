# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:49+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/weakref.rst:4
msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- Слабые ссылки"

#: ../../library/weakref.rst:14
msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**Исходный код:** :source:`Lib/weakref.py`"

#: ../../library/weakref.rst:18
msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ""
"Модуль :mod:`weakref` позволяет программисту Python создавать :dfn:`слабые "
"ссылки` на объекты."

#: ../../library/weakref.rst:24
msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr ""
"Далее термин :dfn:`referent` означает объект, на который ссылается слабая "
"ссылка."

#: ../../library/weakref.rst:27
msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, :term:"
"`garbage collection` is free to destroy the referent and reuse its memory "
"for something else.  However, until the object is actually destroyed the "
"weak reference may return the object even if there are no strong references "
"to it."
msgstr ""
"Слабой ссылки на объект недостаточно, чтобы сохранить объект в живых: когда "
"единственные оставшиеся ссылки на референт являются слабыми ссылками, :term:"
"`сборка мусора` может уничтожить референт и повторно использовать его память "
"для чего-то другого. Однако до тех пор, пока объект не будет фактически "
"уничтожен, слабая ссылка может возвращать объект, даже если на него нет "
"сильных ссылок."

#: ../../library/weakref.rst:33
msgid ""
"A primary use for weak references is to implement caches or mappings holding "
"large objects, where it's desired that a large object not be kept alive "
"solely because it appears in a cache or mapping."
msgstr ""
"Основное использование слабых ссылок заключается в реализации кэшей или "
"отображений, содержащих большие объекты, где желательно, чтобы большой "
"объект не оставался активным только потому, что он появляется в кэше или "
"сопоставлении."

#: ../../library/weakref.rst:37
msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The :"
"class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied "
"by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a :"
"class:`WeakValueDictionary`, then when the last remaining references to that "
"image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"Например, если у вас есть несколько больших объектов двоичного изображения, "
"вы можете захотеть связать имя с каждым. Если вы использовали словарь Python "
"для сопоставления имен с изображениями или изображений с именами, объекты "
"изображений оставались бы живыми только потому, что они появлялись в "
"словарях как значения или ключи. Классы :class:`WeakKeyDictionary` и :class:"
"`WeakValueDictionary`, предоставляемые модулем :mod:`weakref`, являются "
"альтернативой, использующей слабые ссылки для создания отображений, которые "
"не поддерживают активность объектов только потому, что они появляются в "
"объектах сопоставления. . Если, например, объект изображения является "
"значением в :class:`WeakValueDictionary`, то, когда последние оставшиеся "
"ссылки на этот объект изображения являются слабыми ссылками, содержащимися в "
"слабых сопоставлениях, сборщик мусора может вернуть объект и соответствующие "
"ему записи. в слабых отображениях просто удаляются."

#: ../../library/weakref.rst:50
msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  :class:`WeakSet` implements the :"
"class:`set` interface, but keeps weak references to its elements, just like "
"a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary` и :class:`WeakValueDictionary` используют слабые "
"ссылки в своей реализации, настраивая функции обратного вызова для слабых "
"ссылок, которые уведомляют слабые словари, когда ключ или значение были "
"возвращены сборщиком мусора. :class:`WeakSet` реализует интерфейс :class:"
"`set`, но сохраняет слабые ссылки на его элементы, как это делает :class:"
"`WeakKeyDictionary`."

#: ../../library/weakref.rst:57
msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is simpler "
"to use than setting up a callback function on a raw weak reference, since "
"the module automatically ensures that the finalizer remains alive until the "
"object is collected."
msgstr ""
":class:`finalize` предоставляет простой способ регистрации функции очистки, "
"которая будет вызываться при сборке мусора. Это проще в использовании, чем "
"настройка функции обратного вызова для необработанной слабой ссылки, "
"поскольку модуль автоматически гарантирует, что финализатор остается "
"активным до тех пор, пока объект не будет собран."

#: ../../library/weakref.rst:63
msgid ""
"Most programs should find that using one of these weak container types or :"
"class:`finalize` is all they need -- it's not usually necessary to create "
"your own weak references directly.  The low-level machinery is exposed by "
"the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"Большинство программ обнаружит, что использование одного из этих слабых "
"типов контейнеров или :class:`finalize` — это все, что им нужно; обычно нет "
"необходимости напрямую создавать свои собственные слабые ссылки. Механизмы "
"низкого уровня доступны с помощью модуля :mod:`weakref` для удобства "
"расширенного использования."

#: ../../library/weakref.rst:68
msgid ""
"Not all objects can be weakly referenced. Objects which support weak "
"references include class instances, functions written in Python (but not in "
"C), instance methods, sets, frozensets, some :term:`file objects <file "
"object>`, :term:`generators <generator>`, type objects, sockets, arrays, "
"deques, regular expression pattern objects, and code objects."
msgstr ""
"Не на все объекты можно слабо ссылаться. Объекты, поддерживающие слабые "
"ссылки, включают экземпляры классов, функции, написанные на Python (но не на "
"C), методы экземпляра, наборы, замороженные наборы, некоторые :term:`file "
"object <file object>`, :term:`generators <generator>`, объекты типов, "
"сокеты, массивы, деки, объекты шаблонов регулярных выражений и объекты кода."

#: ../../library/weakref.rst:74
msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "Добавлена ​​поддержка объектов thread.lock, threading.Lock и кода."

#: ../../library/weakref.rst:77
msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr ""
"Некоторые встроенные типы, такие как :class:`list` и :class:`dict`, не "
"поддерживают слабые ссылки напрямую, но могут добавить поддержку посредством "
"создания подклассов:"

#: ../../library/weakref.rst:80
msgid ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # this object is weak referenceable"
msgstr ""
"class Dict(dict):\n"
"    pass\n"
"\n"
"obj = Dict(red=1, green=2, blue=3)   # this object is weak referenceable"

#: ../../library/weakref.rst:87
msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not support "
"weak references even when subclassed."
msgstr ""
"Другие встроенные типы, такие как :class:`tuple` и :class:`int`, не "
"поддерживают слабые ссылки, даже если они являются подклассами."

#: ../../library/weakref.rst:90
msgid ""
"Extension types can easily be made to support weak references; see :ref:"
"`weakref-support`."
msgstr ""
"Типы расширений можно легко создать для поддержки слабых ссылок; см. :ref:"
"`weakref-support`."

#: ../../library/weakref.rst:93
msgid ""
"When ``__slots__`` are defined for a given type, weak reference support is "
"disabled unless a ``'__weakref__'`` string is also present in the sequence "
"of strings in the ``__slots__`` declaration. See :ref:`__slots__ "
"documentation <slots>` for details."
msgstr ""
"Когда для данного типа определены ``__slots__``, поддержка слабых ссылок "
"отключается, если только строка ``'__weakref__'`` также не присутствует в "
"последовательности строк в объявлении ``__slots__``. Подробности смотрите в :"
"ref:`__slots__ документации <slots>`."

#: ../../library/weakref.rst:100
msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause :const:"
"`None` to be returned.  If *callback* is provided and not :const:`None`, and "
"the returned weakref object is still alive, the callback will be called when "
"the object is about to be finalized; the weak reference object will be "
"passed as the only parameter to the callback; the referent will no longer be "
"available."
msgstr ""
"Верните слабую ссылку на *object*. Исходный объект можно получить, вызвав "
"ссылочный объект, если референт еще жив; если референт больше не существует, "
"вызов ссылочного объекта приведет к возврату :const:`None`. Если указан "
"*callback*, а не :const:`None`, и возвращенный объект слабой ссылки все еще "
"активен, обратный вызов будет вызван, когда объект вот-вот будет "
"финализирован; объект слабой ссылки будет передан в качестве единственного "
"параметра обратного вызова; референт больше не будет доступен."

#: ../../library/weakref.rst:108
msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the "
"most recently registered callback to the oldest registered callback."
msgstr ""
"Для одного и того же объекта допускается создание множества слабых ссылок. "
"Обратные вызовы, зарегистрированные для каждой слабой ссылки, будут "
"вызываться от самого последнего зарегистрированного обратного вызова до "
"самого старого зарегистрированного обратного вызова."

#: ../../library/weakref.rst:112
msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`~object.__del__` method."
msgstr ""
"Исключения, вызванные обратным вызовом, будут отмечены в стандартном выводе "
"ошибок, но не могут быть распространены; они обрабатываются точно так же, "
"как исключения, возникающие из метода :meth:`~object.__del__` объекта."

#: ../../library/weakref.rst:116
msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will "
"maintain their hash value even after the *object* was deleted.  If :func:"
"`hash` is called the first time only after the *object* was deleted, the "
"call will raise :exc:`TypeError`."
msgstr ""
"Слабые ссылки являются :term:`хешируемыми`, если *объект* хэшируемый. Они "
"сохранят свое хеш-значение даже после удаления *объекта*. Если :func:`hash` "
"вызывается в первый раз только после удаления *объекта*, вызов вызовет :exc:"
"`TypeError`."

#: ../../library/weakref.rst:121
msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"Слабые ссылки поддерживают проверку на равенство, но не на порядок. Если "
"референты все еще живы, две ссылки имеют те же отношения равенства, что и их "
"референты (независимо от *обратного вызова*). Если любой из референтов был "
"удален, ссылки равны, только если ссылочные объекты являются одним и тем же "
"объектом."

#: ../../library/weakref.rst:126
msgid "This is a subclassable type rather than a factory function."
msgstr "Это подклассифицированный тип, а не фабричная функция."

#: ../../library/weakref.rst:130
msgid ""
"This read-only attribute returns the callback currently associated to the "
"weakref.  If there is no callback or if the referent of the weakref is no "
"longer alive then this attribute will have value ``None``."
msgstr ""
"Этот атрибут только для чтения возвращает обратный вызов, связанный в данный "
"момент со слабой ссылкой. Если обратного вызова нет или референт слабой "
"ссылки больше не активен, тогда этот атрибут будет иметь значение None."

#: ../../library/weakref.rst:134
msgid "Added the :attr:`__callback__` attribute."
msgstr "Добавлен атрибут :attr:`__callback__`."

#: ../../library/weakref.rst:140
msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevents their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the :func:"
"`ref` function."
msgstr ""
"Верните прокси объекту *object*, который использует слабую ссылку. Это "
"поддерживает использование прокси в большинстве контекстов вместо "
"необходимости явного разыменования, используемого со слабыми ссылочными "
"объектами. Возвращенный объект будет иметь тип ProxyType или "
"CallableProxyType, в зависимости от того, является ли *object* вызываемым. "
"Прокси-объекты не являются :term:`хешируемыми` независимо от референта; это "
"позволяет избежать ряда проблем, связанных с их принципиально изменчивой "
"природой, и предотвращает их использование в качестве ключей словаря. "
"*callback* аналогичен одноименному параметру функции :func:`ref`."

#: ../../library/weakref.rst:149
msgid ""
"Accessing an attribute of the proxy object after the referent is garbage "
"collected raises :exc:`ReferenceError`."
msgstr ""
"Доступ к атрибуту прокси-объекта после того, как референт был очищен от "
"мусора, вызывает ошибку :exc:`ReferenceError`."

#: ../../library/weakref.rst:152
msgid ""
"Extended the operator support on proxy objects to include the matrix "
"multiplication operators ``@`` and ``@=``."
msgstr ""
"Расширена поддержка операторов прокси-объектов за счет включения операторов "
"матричного умножения ``@`` и ``@=``."

#: ../../library/weakref.rst:159
msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr "Возвращает количество слабых ссылок и прокси, ссылающихся на *объект*."

#: ../../library/weakref.rst:164
msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr ""
"Возвращает список всех слабых ссылок и прокси-объектов, которые ссылаются на "
"*object*."

#: ../../library/weakref.rst:169
msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts "
"of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"Класс сопоставления, который слабо ссылается на ключи. Записи в словаре "
"будут отброшены, если на ключ больше не будет сильной ссылки. Это можно "
"использовать для связывания дополнительных данных с объектом, принадлежащим "
"другим частям приложения, без добавления атрибутов к этим объектам. Это "
"может быть особенно полезно для объектов, которые переопределяют доступ к "
"атрибутам."

#: ../../library/weakref.rst:175
msgid ""
"Note that when a key with equal value to an existing key (but not equal "
"identity) is inserted into the dictionary, it replaces the value but does "
"not replace the existing key. Due to this, when the reference to the "
"original key is deleted, it also deletes the entry in the dictionary::"
msgstr ""
"Обратите внимание: когда в словарь вставляется ключ со значением, равным "
"существующему ключу (но не с равным идентификатором), он заменяет значение, "
"но не заменяет существующий ключ. Благодаря этому при удалении ссылки на "
"исходный ключ удаляется и запись в словаре::"

#: ../../library/weakref.rst:180
msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> d[k2] = 2   # d = {k1: 2}\n"
">>> del k1      # d = {}"

#: ../../library/weakref.rst:188
msgid "A workaround would be to remove the key prior to reassignment::"
msgstr "Обходным решением было бы удалить ключ перед переназначением::"

#: ../../library/weakref.rst:190
msgid ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"
msgstr ""
">>> class T(str): pass\n"
"...\n"
">>> k1, k2 = T(), T()\n"
">>> d = weakref.WeakKeyDictionary()\n"
">>> d[k1] = 1   # d = {k1: 1}\n"
">>> del d[k1]\n"
">>> d[k2] = 2   # d = {k2: 2}\n"
">>> del k1      # d = {k2: 2}"

#: ../../library/weakref.rst:199 ../../library/weakref.rst:220
msgid ""
"Added support for ``|`` and ``|=`` operators, as specified in :pep:`584`."
msgstr ""
"Добавлена ​​поддержка операторов ``|`` и ``|=``, как указано в :pep:`584`."

#: ../../library/weakref.rst:202
msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes "
"the internal references directly.  The references are not guaranteed to be "
"\"live\" at the time they are used, so the result of calling the references "
"needs to be checked before being used.  This can be used to avoid creating "
"references that will cause the garbage collector to keep the keys around "
"longer than needed."
msgstr ""
"Объекты :class:`WeakKeyDictionary` имеют дополнительный метод, который "
"напрямую предоставляет внутренние ссылки. Не гарантируется, что ссылки будут "
"«живыми» в момент их использования, поэтому перед использованием необходимо "
"проверить результат вызова ссылок. Это можно использовать, чтобы избежать "
"создания ссылок, из-за которых сборщик мусора будет хранить ключи дольше, "
"чем необходимо."

#: ../../library/weakref.rst:212
msgid "Return an iterable of the weak references to the keys."
msgstr "Верните итерацию слабых ссылок на ключи."

#: ../../library/weakref.rst:217
msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will "
"be discarded when no strong reference to the value exists any more."
msgstr ""
"Класс сопоставления, слабо ссылающийся на значения. Записи в словаре будут "
"отброшены, если сильная ссылка на значение больше не существует."

#: ../../library/weakref.rst:223
msgid ""
":class:`WeakValueDictionary` objects have an additional method that has the "
"same issues as the :meth:`WeakKeyDictionary.keyrefs` method."
msgstr ""
"Объекты :class:`WeakValueDictionary` имеют дополнительный метод, имеющий те "
"же проблемы, что и метод :meth:`WeakKeyDictionary.keyrefs`."

#: ../../library/weakref.rst:229
msgid "Return an iterable of the weak references to the values."
msgstr "Возвращает итерацию слабых ссылок на значения."

#: ../../library/weakref.rst:234
msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr ""
"Установите класс, который хранит слабые ссылки на свои элементы. Элемент "
"будет отброшен, если на него больше не существует сильной ссылки."

#: ../../library/weakref.rst:240
msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a bound "
"method (i.e., a method defined on a class and looked up on an instance). "
"Since a bound method is ephemeral, a standard weak reference cannot keep "
"hold of it.  :class:`WeakMethod` has special code to recreate the bound "
"method until either the object or the original function dies::"
msgstr ""
"Пользовательский подкласс :class:`ref`, который имитирует слабую ссылку на "
"связанный метод (т. е. метод, определенный в классе и просматриваемый в "
"экземпляре). Поскольку связанный метод эфемерен, стандартная слабая ссылка "
"не может его удержать. :class:`WeakMethod` имеет специальный код для "
"воссоздания привязанного метода до тех пор, пока объект или исходная функция "
"не умрут::"

#: ../../library/weakref.rst:246
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         print(\"method called!\")\n"
"...\n"
">>> c = C()\n"
">>> r = weakref.ref(c.method)\n"
">>> r()\n"
">>> r = weakref.WeakMethod(c.method)\n"
">>> r()\n"
"<bound method C.method of <__main__.C object at 0x7fc859830220>>\n"
">>> r()()\n"
"method called!\n"
">>> del c\n"
">>> gc.collect()\n"
"0\n"
">>> r()\n"
">>>"

#: ../../library/weakref.rst:264
msgid ""
"*callback* is the same as the parameter of the same name to the :func:`ref` "
"function."
msgstr "*callback* аналогичен одноименному параметру функции :func:`ref`."

#: ../../library/weakref.rst:270
msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly simplifying "
"lifecycle management."
msgstr ""
"Возвращает вызываемый объект финализатора, который будет вызываться при "
"сборке мусора *obj*. В отличие от обычной слабой ссылки, финализатор всегда "
"будет работать до тех пор, пока не будет собран ссылочный объект, что "
"значительно упрощает управление жизненным циклом."

#: ../../library/weakref.rst:275
msgid ""
"A finalizer is considered *alive* until it is called (either explicitly or "
"at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, whereas "
"calling a dead finalizer returns :const:`None`."
msgstr ""
"Финализатор считается *живым* до тех пор, пока он не будет вызван (явно или "
"при сборке мусора), а после этого он *мертв*. Вызов действующего "
"финализатора возвращает результат вычисления func(*arg, **kwargs)``, тогда "
"как вызов мертвого финализатора возвращает :const:`None`."

#: ../../library/weakref.rst:280
msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will be "
"shown on the standard error output, but cannot be propagated.  They are "
"handled in the same way as exceptions raised from an object's :meth:`~object."
"__del__` method or a weak reference's callback."
msgstr ""
"Исключения, вызванные обратными вызовами финализатора во время сборки "
"мусора, будут отображаться в стандартном выводе ошибок, но не могут быть "
"распространены. Они обрабатываются так же, как исключения, возникающие из "
"метода :meth:`~object.__del__` объекта или обратного вызова слабой ссылки."

#: ../../library/weakref.rst:286
msgid ""
"When the program exits, each remaining live finalizer is called unless its :"
"attr:`atexit` attribute has been set to false.  They are called in reverse "
"order of creation."
msgstr ""
"При выходе из программы вызывается каждый оставшийся активный финализатор, "
"если только его атрибут :attr:`atexit` не установлен в значение false. Они "
"вызываются в порядке, обратном созданию."

#: ../../library/weakref.rst:290
msgid ""
"A finalizer will never invoke its callback during the later part of the :"
"term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr ""
"Финализатор никогда не будет вызывать свой обратный вызов во время поздней "
"части завершения работы интерпретатора, когда глобальные переменные модуля "
"могут быть заменены на :const:`None`."

#: ../../library/weakref.rst:296
msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"Если *self* жив, то пометьте его как мертвый и верните результат вызова "
"``func(*args, **kwargs)``. Если *self* мертв, верните :const:`None`."

#: ../../library/weakref.rst:302
msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, func, "
"args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"Если *self* жив, отметьте его как мертвый и верните кортеж ``(obj, func, "
"args, kwargs)``. Если *self* мертв, верните :const:`None`."

#: ../../library/weakref.rst:308
msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  If "
"*self* is dead then return :const:`None`."
msgstr ""
"Если *self* жив, верните кортеж ``(obj, func, args, kwargs)``. Если *self* "
"мертв, верните :const:`None`."

#: ../../library/weakref.rst:313
msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr ""
"Свойство, которое истинно, если финализатор активен, и ложно в противном "
"случае."

#: ../../library/weakref.rst:317
msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` is "
"true.  They are called in reverse order of creation."
msgstr ""
"Доступное для записи логическое свойство, которое по умолчанию имеет "
"значение true. Когда программа завершает работу, она вызывает все оставшиеся "
"активные финализаторы, для которых :attr:`.atexit` имеет значение true. Они "
"вызываются в порядке, обратном созданию."

#: ../../library/weakref.rst:324
msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any "
"references to *obj*, either directly or indirectly, since otherwise *obj* "
"will never be garbage collected.  In particular, *func* should not be a "
"bound method of *obj*."
msgstr ""
"Важно гарантировать, что *func*, *args* и *kwargs* не содержат никаких "
"ссылок на *obj*, ни прямо, ни косвенно, поскольку в противном случае *obj* "
"никогда не будет подвергнут сборке мусора. В частности, *func* не должен "
"быть связанным методом *obj*."

#: ../../library/weakref.rst:334
msgid "The type object for weak references objects."
msgstr "Тип объекта для объектов слабых ссылок."

#: ../../library/weakref.rst:339
msgid "The type object for proxies of objects which are not callable."
msgstr "Тип объекта для прокси объектов, которые не могут быть вызваны."

#: ../../library/weakref.rst:344
msgid "The type object for proxies of callable objects."
msgstr "Тип объекта для прокси вызываемых объектов."

#: ../../library/weakref.rst:349
msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr ""
"Последовательность, содержащая все объекты типов для прокси. Это может "
"упростить проверку того, является ли объект прокси, не прибегая к именованию "
"обоих типов прокси."

#: ../../library/weakref.rst:356
msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - Слабые ссылки"

#: ../../library/weakref.rst:357
msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr ""
"Предложение и обоснование этой функции, включая ссылки на более ранние "
"реализации и информацию о подобных функциях на других языках."

#: ../../library/weakref.rst:364
msgid "Weak Reference Objects"
msgstr "Слабые эталонные объекты"

#: ../../library/weakref.rst:366
msgid ""
"Weak reference objects have no methods and no attributes besides :attr:`ref."
"__callback__`. A weak reference object allows the referent to be obtained, "
"if it still exists, by calling it:"
msgstr ""
"Слабые ссылочные объекты не имеют методов и атрибутов, кроме :attr:`ref."
"__callback__`. Слабый ссылочный объект позволяет получить референт, если он "
"все еще существует, вызвав его:"

#: ../../library/weakref.rst:380
msgid ""
"If the referent no longer exists, calling the reference object returns :"
"const:`None`:"
msgstr ""
"Если референт больше не существует, вызов ссылочного объекта возвращает :"
"const:`None`:"

#: ../../library/weakref.rst:387
msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"Проверка работоспособности объекта слабой ссылки должна выполняться с "
"использованием выражения ``ref() is not None``. Обычно код приложения, "
"которому необходимо использовать ссылочный объект, должен следовать "
"следующему шаблону:"

#: ../../library/weakref.rst:391
msgid ""
"# r is a weak reference object\n"
"o = r()\n"
"if o is None:\n"
"    # referent has been garbage collected\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"
msgstr ""
"# r is a weak reference object\n"
"o = r()\n"
"if o is None:\n"
"    # referent has been garbage collected\n"
"    print(\"Object has been deallocated; can't frobnicate.\")\n"
"else:\n"
"    print(\"Object is still live!\")\n"
"    o.do_something_useful()"

#: ../../library/weakref.rst:400
msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"Использование отдельного теста на «живучесть» создает условия гонки в "
"многопоточных приложениях; другой поток может привести к тому, что слабая "
"ссылка станет недействительной до того, как слабая ссылка будет вызвана; "
"показанная выше идиома безопасна как для многопоточных, так и для "
"однопоточных приложений."

#: ../../library/weakref.rst:405
msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the :class:"
"`WeakValueDictionary` to reduce the memory overhead for each entry in the "
"mapping.  This may be most useful to associate additional information with a "
"reference, but could also be used to insert additional processing on calls "
"to retrieve the referent."
msgstr ""
"Специализированные версии объектов :class:`ref` могут быть созданы "
"посредством создания подклассов. Это используется в реализации :class:"
"`WeakValueDictionary` для уменьшения накладных расходов памяти для каждой "
"записи в сопоставлении. Это может быть наиболее полезно для связывания "
"дополнительной информации со ссылкой, но также может использоваться для "
"вставки дополнительной обработки вызовов для получения референта."

#: ../../library/weakref.rst:411
msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr ""
"В этом примере показано, как подкласс :class:`ref` можно использовать для "
"хранения дополнительной информации об объекте и влияния на значение, "
"возвращаемое при обращении к референту::"

#: ../../library/weakref.rst:415
msgid ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"Return a pair containing the referent and the number of\n"
"        times the reference has been called.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"
msgstr ""
"import weakref\n"
"\n"
"class ExtendedRef(weakref.ref):\n"
"    def __init__(self, ob, callback=None, /, **annotations):\n"
"        super().__init__(ob, callback)\n"
"        self.__counter = 0\n"
"        for k, v in annotations.items():\n"
"            setattr(self, k, v)\n"
"\n"
"    def __call__(self):\n"
"        \"\"\"Return a pair containing the referent and the number of\n"
"        times the reference has been called.\n"
"        \"\"\"\n"
"        ob = super().__call__()\n"
"        if ob is not None:\n"
"            self.__counter += 1\n"
"            ob = (ob, self.__counter)\n"
"        return ob"

#: ../../library/weakref.rst:438
msgid "Example"
msgstr "Пример"

#: ../../library/weakref.rst:440
msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in "
"other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"Этот простой пример показывает, как приложение может использовать "
"идентификаторы объектов для извлечения объектов, которые оно видело раньше. "
"Идентификаторы объектов затем можно использовать в других структурах данных, "
"не заставляя объекты оставаться активными, но объекты все равно можно "
"получить по идентификатору, если они это сделают."

#: ../../library/weakref.rst:449
msgid ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"
msgstr ""
"import weakref\n"
"\n"
"_id2obj_dict = weakref.WeakValueDictionary()\n"
"\n"
"def remember(obj):\n"
"    oid = id(obj)\n"
"    _id2obj_dict[oid] = obj\n"
"    return oid\n"
"\n"
"def id2obj(oid):\n"
"    return _id2obj_dict[oid]"

#: ../../library/weakref.rst:465
msgid "Finalizer Objects"
msgstr "финализатор Объекты"

#: ../../library/weakref.rst:467
msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to "
"register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr ""
"Основное преимущество использования :class:`finalize` заключается в том, что "
"он упрощает регистрацию обратного вызова без необходимости сохранения "
"возвращаемого объекта финализатора. Например"

#: ../../library/weakref.rst:481
msgid ""
"The finalizer can be called directly as well.  However the finalizer will "
"invoke the callback at most once."
msgstr ""
"Финализатор также можно вызвать напрямую. Однако финализатор вызовет "
"обратный вызов не более одного раза."

#: ../../library/weakref.rst:497
msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method.  "
"This kills the finalizer and returns the arguments passed to the constructor "
"when it was created."
msgstr ""
"Вы можете отменить регистрацию финализатора, используя его метод :meth:"
"`~finalize.detach`. Это убивает финализатор и возвращает аргументы, "
"переданные конструктору при его создании."

#: ../../library/weakref.rst:511
msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, a "
"finalizer will be called when the program exits if it is still alive.  For "
"instance"
msgstr ""
"Если вы не установите для атрибута :attr:`~finalize.atexit` значение :const:"
"`False`, финализатор будет вызываться при выходе из программы, если она еще "
"жива. Например"

#: ../../library/weakref.rst:515
msgid ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"
msgstr ""
">>> obj = Object()\n"
">>> weakref.finalize(obj, print, \"obj dead or exiting\")\n"
"<finalize object at ...; for 'Object' at ...>\n"
">>> exit()\n"
"obj dead or exiting"

#: ../../library/weakref.rst:526
msgid "Comparing finalizers with :meth:`~object.__del__` methods"
msgstr "Сравнение финализаторов с методами :meth:`~object.__del__`"

#: ../../library/weakref.rst:528
msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when the "
"first of the following events occurs:"
msgstr ""
"Предположим, мы хотим создать класс, экземпляры которого представляют "
"временные каталоги. Каталоги должны быть удалены вместе с их содержимым при "
"возникновении первого из следующих событий:"

#: ../../library/weakref.rst:532
msgid "the object is garbage collected,"
msgstr "объект убран сборщиком мусора,"

#: ../../library/weakref.rst:533
msgid "the object's :meth:`!remove` method is called, or"
msgstr "вызывается метод :meth:`!remove` объекта, или"

#: ../../library/weakref.rst:534
msgid "the program exits."
msgstr "программа завершает работу."

#: ../../library/weakref.rst:536
msgid ""
"We might try to implement the class using a :meth:`~object.__del__` method "
"as follows::"
msgstr ""
"Мы могли бы попытаться реализовать класс, используя метод :meth:`~object."
"__del__` следующим образом:"

#: ../../library/weakref.rst:539
msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"\n"
"    def remove(self):\n"
"        if self.name is not None:\n"
"            shutil.rmtree(self.name)\n"
"            self.name = None\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return self.name is None\n"
"\n"
"    def __del__(self):\n"
"        self.remove()"

#: ../../library/weakref.rst:555
msgid ""
"Starting with Python 3.4, :meth:`~object.__del__` methods no longer prevent "
"reference cycles from being garbage collected, and module globals are no "
"longer forced to :const:`None` during :term:`interpreter shutdown`. So this "
"code should work without any issues on CPython."
msgstr ""
"Начиная с Python 3.4, методы :meth:`~object.__del__` больше не предотвращают "
"сбор мусора ссылочных циклов, а глобальные переменные модуля больше не "
"принудительно :const:`None` во время :term:`interpreter Shutdown`. Таким "
"образом, этот код должен работать без проблем на CPython."

#: ../../library/weakref.rst:560
msgid ""
"However, handling of :meth:`~object.__del__` methods is notoriously "
"implementation specific, since it depends on internal details of the "
"interpreter's garbage collector implementation."
msgstr ""
"Однако обработка методов :meth:`~object.__del__`, как известно, зависит от "
"конкретной реализации, поскольку она зависит от внутренних деталей "
"реализации сборщика мусора интерпретатора."

#: ../../library/weakref.rst:564
msgid ""
"A more robust alternative can be to define a finalizer which only references "
"the specific functions and objects that it needs, rather than having access "
"to the full state of the object::"
msgstr ""
"Более надежной альтернативой может быть определение финализатора, который "
"ссылается только на конкретные функции и объекты, которые ему нужны, вместо "
"того, чтобы иметь доступ к полному состоянию объекта:"

#: ../../library/weakref.rst:568
msgid ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"
msgstr ""
"class TempDir:\n"
"    def __init__(self):\n"
"        self.name = tempfile.mkdtemp()\n"
"        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n"
"\n"
"    def remove(self):\n"
"        self._finalizer()\n"
"\n"
"    @property\n"
"    def removed(self):\n"
"        return not self._finalizer.alive"

#: ../../library/weakref.rst:580
msgid ""
"Defined like this, our finalizer only receives a reference to the details it "
"needs to clean up the directory appropriately. If the object never gets "
"garbage collected the finalizer will still be called at exit."
msgstr ""
"При таком определении наш финализатор получает только ссылку на детали, "
"необходимые для соответствующей очистки каталога. Если объект никогда не "
"собирает мусор, финализатор все равно будет вызываться при выходе."

#: ../../library/weakref.rst:584
msgid ""
"The other advantage of weakref based finalizers is that they can be used to "
"register finalizers for classes where the definition is controlled by a "
"third party, such as running code when a module is unloaded::"
msgstr ""
"Другое преимущество финализаторов на основе слабых ссылок заключается в том, "
"что их можно использовать для регистрации финализаторов для классов, "
"определение которых контролируется третьей стороной, например, для запуска "
"кода при выгрузке модуля:"

#: ../../library/weakref.rst:588
msgid ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # implicit reference to the module globals from the function body\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"
msgstr ""
"import weakref, sys\n"
"def unloading_module():\n"
"    # implicit reference to the module globals from the function body\n"
"weakref.finalize(sys.modules[__name__], unloading_module)"

#: ../../library/weakref.rst:596
msgid ""
"If you create a finalizer object in a daemonic thread just as the program "
"exits then there is the possibility that the finalizer does not get called "
"at exit.  However, in a daemonic thread :func:`atexit.register`, ``try: ... "
"finally: ...`` and ``with: ...`` do not guarantee that cleanup occurs either."
msgstr ""
"Если вы создаете объект финализатора в демоническом потоке сразу после "
"выхода из программы, существует вероятность того, что финализатор не будет "
"вызван при выходе. Однако в демоническом потоке :func:`atexit.register` "
"``try: ...finally: ...`` и ``with: ...`` также не гарантируют, что очистка "
"произойдет."
