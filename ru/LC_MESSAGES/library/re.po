# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/re.rst:2
msgid ":mod:`!re` --- Regular expression operations"
msgstr ":mod:`!re` --- Операции с регулярными выражениями"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re/`"
msgstr "**Исходный код:** :source:`Lib/re/`"

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Этот модуль предоставляет операции сопоставления регулярных выражений, "
"аналогичные тем, которые есть в Perl."

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a bytes pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"Как шаблоны, так и строки для поиска могут быть строками Юникода (:class:"
"`str`), а также 8-битными строками (:class:`bytes`). Однако строки Юникода и "
"8-битные строки нельзя смешивать: то есть нельзя сопоставить строку Юникода "
"с шаблоном байтов или наоборот; аналогично, при запросе замены строка замены "
"должна быть того же типа, что и шаблон, и строка поиска."

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`SyntaxWarning` and in the "
"future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"Регулярные выражения используют символ обратной косой черты (``'\\'``) для "
"обозначения специальных форм или для разрешения использования специальных "
"символов без обращения к их особому значению. Это противоречит использованию "
"Python того же символа для той же цели в строковых литералах; например, "
"чтобы сопоставить буквальную обратную косую черту, возможно, придется "
"написать ``'\\\\\\\\'`` в качестве строки шаблона, поскольку регулярное "
"выражение должно быть ``\\\\``, а каждая обратная косая черта должна быть "
"выражена как ``\\\\\\``, а каждая обратная косая черта должна быть выражена "
"как ``'\\\\\\\\'`` в качестве строки шаблона `\\\\`` внутри обычного "
"строкового литерала Python. Также обратите внимание, что любые недопустимые "
"escape-последовательности при использовании Python обратной косой черты в "
"строковых литералах теперь генерируют :exc:`SyntaxWarning`, а в будущем это "
"станет :exc:`SyntaxError`. Такое поведение произойдет, даже если это "
"допустимая escape-последовательность для регулярного выражения."

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"Решение состоит в том, чтобы использовать необработанную строковую нотацию "
"Python для шаблонов регулярных выражений; обратные косые черты не "
"обрабатываются каким-либо особым образом в строковом литерале с префиксом "
"``'r'``. Таким образом, ``r\"\\n\"`` представляет собой двухсимвольную "
"строку, содержащую ``'\\'`` и ``'n'``, а ``\"\\n\"`` представляет собой "
"односимвольную строку, содержащую новая строка. Обычно шаблоны выражаются в "
"коде Python с использованием этой необработанной строковой нотации."

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Важно отметить, что большинство операций с регулярными выражениями доступны "
"в виде функций и методов уровня модуля в :ref:`скомпилированных регулярных "
"выражениях <re-objects>`. Функции представляют собой ярлыки, которые не "
"требуют предварительной компиляции объекта регулярного выражения, но "
"пропускают некоторые параметры тонкой настройки."

#: ../../library/re.rst:51
msgid ""
"The third-party :pypi:`regex` module, which has an API compatible with the "
"standard library :mod:`re` module, but offers additional functionality and a "
"more thorough Unicode support."
msgstr ""
"Сторонний модуль :pypi:`regex`, имеющий API, совместимый со стандартным "
"модулем библиотеки :mod:`re`, но предлагающий дополнительную "
"функциональность и более полную поддержку Unicode."

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "Синтаксис регулярных выражений"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Регулярное выражение (или RE) определяет набор соответствующих ему строк; "
"Функции в этом модуле позволяют вам проверить, соответствует ли определенная "
"строка заданному регулярному выражению (или соответствует ли данное "
"регулярное выражение определенной строке, что сводится к одному и тому же)."

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"Регулярные выражения можно объединять для формирования новых регулярных "
"выражений; если *A* и *B* являются регулярными выражениями, то *AB* также "
"является регулярным выражением. В общем, если строка *p* соответствует *A*, "
"а другая строка *q* соответствует *B*, строка *pq* будет соответствовать AB. "
"Это справедливо, если только *A* или *B* не содержат операций с низким "
"приоритетом; граничные условия между *A* и *B*; или иметь пронумерованные "
"ссылки на группы. Таким образом, сложные выражения можно легко создать из "
"более простых примитивных выражений, подобных описанным здесь. Подробную "
"информацию о теории и реализации регулярных выражений можно найти в книге "
"Фридла. [Frie09]_ или почти любой учебник по построению компиляторов."

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Ниже приводится краткое объяснение формата регулярных выражений. Для "
"получения дополнительной информации и более наглядного представления "
"обратитесь к :ref:`regex-howto`."

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Регулярные выражения могут содержать как специальные, так и обычные символы. "
"Большинство обычных символов, таких как ``'A'``, ``'a'`` или ``'0'``, "
"являются простейшими регулярными выражениями; они просто соответствуют самим "
"себе. Вы можете объединять обычные символы, чтобы ``last`` соответствовал "
"строке ``'last'``. (В оставшейся части этого раздела мы будем писать RE в "
"``этом специальном стиле``, обычно без кавычек, а сопоставляемые строки "
"заключать ``'в одинарные кавычки'``.)"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Некоторые символы, такие как ``'|'`` или ``'('``, являются специальными. "
"Специальные символы либо обозначают классы обычных символов, либо влияют на "
"интерпретацию регулярных выражений вокруг них."

#: ../../library/re.rst:90
msgid ""
"Repetition operators or quantifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) "
"cannot be directly nested. This avoids ambiguity with the non-greedy "
"modifier suffix ``?``, and with other modifiers in other implementations. To "
"apply a second repetition to an inner repetition, parentheses may be used. "
"For example, the expression ``(?:a{6})*`` matches any multiple of six "
"``'a'`` characters."
msgstr ""
"Операторы повторения или квантификаторы (``*``, ``+``, ``?``, ``{m,n}`` и "
"т. д.) не могут быть вложены напрямую. Это позволяет избежать "
"двусмысленности с нежадным суффиксом модификатора ``?`` и с другими "
"модификаторами в других реализациях. Чтобы применить второе повторение к "
"внутреннему повторению, можно использовать круглые скобки. Например, "
"выражение ``(?:a{6})*`` соответствует любому числу символов, кратному шести "
"``'a'``."

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "Специальные символы:"

#: ../../library/re.rst:101 ../../library/re.rst:1643
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline.  ``(?s:.)`` matches any character regardless of flags."
msgstr ""
"(Точка.) В режиме по умолчанию соответствует любому символу, кроме символа "
"новой строки. Если указан флаг :const:`DOTALL`, он соответствует любому "
"символу, включая символ новой строки. ``(?s:.)`` соответствует любому "
"символу независимо от флагов."

#: ../../library/re.rst:108
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Вставка.) Соответствует началу строки, а в режиме :const:`MULTILINE` также "
"соответствует сразу после каждой новой строки."

#: ../../library/re.rst:114
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Соответствует концу строки или непосредственно перед новой строкой в ​​конце "
"строки, а в режиме :const:`MULTILINE` также соответствует перед новой "
"строкой. ``foo`` соответствует как \"foo\", так и \"foobar\", тогда как "
"регулярное выражение ``foo$`` соответствует только \"foo\". Более интересно, "
"поиск ``foo.$`` в ``'foo1\\nfoo2\\n'`` обычно соответствует 'foo2', но "
"'foo1' в режиме :const:`MULTILINE`; поиск одного ``$`` в ``'foo\\n'`` найдет "
"два (пустых) совпадения: одно непосредственно перед новой строкой и одно в "
"конце строки."

#: ../../library/re.rst:125
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Заставляет результирующий RE соответствовать 0 или более повторениям "
"предыдущего RE, насколько это возможно. ``ab*`` будет соответствовать \"a\", "
"\"ab\" или \"a\", за которыми следует любое количество букв \"b\"."

#: ../../library/re.rst:132
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Заставляет результирующий RE соответствовать одному или нескольким "
"повторениям предыдущего RE. ``ab+`` будет соответствовать \"a\", за которым "
"следует любое ненулевое количество \"b\"; он не будет соответствовать просто "
"«a»."

#: ../../library/re.rst:139
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Заставляет результирующий RE соответствовать 0 или 1 повторению предыдущего "
"RE. ``ab?`` будет соответствовать либо \"a\", либо \"ab\"."

#: ../../library/re.rst:148
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` quantifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the quantifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""
"Кванторы ``'*'``, ``'+'`` и ``'?'`` являются :dfn:`greedy`; они "
"соответствуют как можно большему количеству текста. Иногда такое поведение "
"нежелательно; если RE ``<.*>`` сопоставляется с ``'<a> b <c>'``, он будет "
"соответствовать всей строке, а не только ``'<a>'``. Добавление ``?`` после "
"квантора заставляет его выполнять сопоставление в :dfn:`нежадном` или :dfn:"
"`минимальном` режиме; будет совпадать как можно *немногие* символы. "
"Использование RE ``<.*?>`` будет соответствовать только ``'<a>'``."

#: ../../library/re.rst:162
msgid "``*+``, ``++``, ``?+``"
msgstr "``*+``, ``++``, ``?+``"

#: ../../library/re.rst:163
msgid ""
"Like the ``'*'``, ``'+'``, and ``'?'`` quantifiers, those where ``'+'`` is "
"appended also match as many times as possible. However, unlike the true "
"greedy quantifiers, these do not allow back-tracking when the expression "
"following it fails to match. These are known as :dfn:`possessive` "
"quantifiers. For example, ``a*a`` will match ``'aaaa'`` because the ``a*`` "
"will match all 4 ``'a'``\\ s, but, when the final ``'a'`` is encountered, "
"the expression is backtracked so that in the end the ``a*`` ends up matching "
"3 ``'a'``\\ s total, and the fourth ``'a'`` is matched by the final ``'a'``. "
"However, when ``a*+a`` is used to match ``'aaaa'``, the ``a*+`` will match "
"all 4 ``'a'``, but when the final ``'a'`` fails to find any more characters "
"to match, the expression cannot be backtracked and will thus fail to match. "
"``x*+``, ``x++`` and ``x?+`` are equivalent to ``(?>x*)``, ``(?>x+)`` and "
"``(?>x?)`` correspondingly."
msgstr ""
"Подобно квантификаторам ``'*'``, ``'+'`` и ``'?'``, те, к которым добавлен "
"``'+'``, также совпадают столько раз, сколько возможно. Однако, в отличие от "
"настоящих жадных квантификаторов, они не позволяют выполнять обратный поиск, "
"если следующее за ним выражение не соответствует. Они известны как кванторы :"
"dfn:`притяжательные`. Например, ``a*a`` будет соответствовать ``'aaaa'``, "
"потому что ``a*`` будет соответствовать всем 4 ``'a'``\\ s, но когда "
"последний ``'a встречается '``, выражение возвращается так, что в конце "
"концов ``a*`` соответствует 3 ``'a'``\\ s, а четвертому ``'a'`` "
"соответствует последнее ``'а'``. Однако, когда ``a*+a`` используется для "
"соответствия ``'aaaa'``, ``a*+`` будет соответствовать всем 4 ``'a'``, но "
"когда последний ``' a'`` не может найти больше символов для соответствия, "
"выражение не может быть возвращено и, следовательно, не будет "
"соответствовать. ``x*+``, ``x++`` и ``x?+`` эквивалентны ``(?>x*)``, ``(?"
">x+)`` и ``(?> x?)`` соответственно."

#: ../../library/re.rst:184
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:185
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Указывает, что должно быть сопоставлено ровно *m* копий предыдущего RE; "
"меньшее количество совпадений приводит к тому, что весь RE не будет "
"совпадать. Например, ``a{6}`` будет соответствовать ровно шести символам "
"``'a'``, а не пяти."

#: ../../library/re.rst:189
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:190
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Заставляет результирующий RE соответствовать от *m* до *n* повторений "
"предыдущего RE, пытаясь сопоставить как можно больше повторений. Например, "
"``a{3,5}`` будет соответствовать от 3 до 5 символов ``'a'``. Пропуск *m* "
"задает нижнюю границу, равную нулю, а пропуск *n* задает бесконечную верхнюю "
"границу. Например, ``a{4,}b`` будет соответствовать ``'aaaab'`` или тысяче "
"символов ``'a'``, за которыми следует ``'b'``, но не ``' аааб'``. Запятую "
"нельзя опускать, иначе модификатор можно спутать с ранее описанной формой."

#: ../../library/re.rst:198
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:199
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous quantifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""
"Заставляет результирующий RE соответствовать от *m* до *n* повторений "
"предыдущего RE, пытаясь сопоставить как можно *несколько* повторений. Это "
"нежадная версия предыдущего квантора. Например, в строке из 6 символов "
"``'aaaaaa'`` ``a{3,5}`` будет соответствовать 5 символам ``'a'``, а ``a{3,5}?"
"` ` будет соответствовать только 3 символам."

#: ../../library/re.rst:205
msgid "``{m,n}+``"
msgstr "``{m,n}+``"

#: ../../library/re.rst:206
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible *without* "
"establishing any backtracking points. This is the possessive version of the "
"quantifier above. For example, on the 6-character string ``'aaaaaa'``, "
"``a{3,5}+aa`` attempt to match 5 ``'a'`` characters, then, requiring 2 more "
"``'a'``\\ s, will need more characters than available and thus fail, while "
"``a{3,5}aa`` will match with ``a{3,5}`` capturing 5, then 4 ``'a'``\\ s by "
"backtracking and then the final 2 ``'a'``\\ s are matched by the final "
"``aa`` in the pattern. ``x{m,n}+`` is equivalent to ``(?>x{m,n})``."
msgstr ""
"Заставляет результирующий RE соответствовать от *m* до *n* повторений "
"предыдущего RE, пытаясь сопоставить как можно больше повторений *без* "
"установления каких-либо точек возврата. Это притяжательная версия "
"приведенного выше квантора. Например, в строке из 6 символов ``'aaaaaa'`` "
"``a{3,5}+aa`` попытается сопоставить 5 символов ``'a'``, затем потребуется "
"еще 2 ``' a'``\\ s, потребуется больше символов, чем доступно, и, "
"следовательно, произойдет сбой, в то время как ``a{3,5}aa`` будет "
"соответствовать ``a{3,5}``, захватывая 5, а затем 4 ``' a'``\\ s путем "
"возврата, а затем последние 2 ``'a'``\\ s сопоставляются с последним ``aa`` "
"в шаблоне. ``x{m,n}+`` эквивалентно ``(?>x{m,n})``."

#: ../../library/re.rst:222
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:223
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Либо экранирует специальные символы (что позволяет сопоставлять такие "
"символы, как ``'*'``, ``'?'`` и т. д.), либо сигнализирует специальную "
"последовательность; специальные последовательности обсуждаются ниже."

#: ../../library/re.rst:227
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Если вы не используете необработанную строку для выражения шаблона, помните, "
"что Python также использует обратную косую черту в качестве escape-"
"последовательности в строковых литералах; если escape-последовательность не "
"распознается синтаксическим анализатором Python, в результирующую строку "
"включаются обратная косая черта и последующий символ. Однако, если Python "
"распознает полученную последовательность, обратную косую черту следует "
"повторить дважды. Это сложно и трудно понять, поэтому настоятельно "
"рекомендуется использовать необработанные строки для всех выражений, кроме "
"самых простых."

#: ../../library/re.rst:238
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:239
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Используется для обозначения набора символов. В наборе:"

#: ../../library/re.rst:241
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Символы могут быть указаны индивидуально, например, ``[amk]`` будет "
"соответствовать ``'a'``, ``'m'`` или ``'k'``."

#: ../../library/re.rst:246
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Диапазоны символов можно указать, задав два символа и разделив их знаком "
"``'-'``, например ``[az]`` будет соответствовать любой строчной букве ASCII, "
"``[0-5][0-9] ]`` будет соответствовать всем двузначным числам от ``00`` до "
"``59``, а ``[0-9A-Fa-f]`` будет соответствовать любой шестнадцатеричной "
"цифре. Если ``-`` экранирован (например, ``[a\\-z]``) или если он помещен в "
"качестве первого или последнего символа (например, ``[-a]`` или ``[a-]`` ), "
"он будет соответствовать буквальному ``'-'``."

#: ../../library/re.rst:253
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"Специальные символы теряют свое особое значение внутри наборов. Например, "
"``[(+*)]`` будет соответствовать любому из литеральных символов ``'('``, "
"``'+'``, ``'*'`` или ``')' ``."

#: ../../library/re.rst:259
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depend on the "
"flags_ used."
msgstr ""
"Классы символов, такие как ``\\w`` или ``\\S`` (определенные ниже), также "
"принимаются внутри набора, хотя символы, которым они соответствуют, зависят "
"от используемых flags_."

#: ../../library/re.rst:264
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Символы, не входящие в диапазон, могут быть сопоставлены путем :dfn:"
"`дополнения` набора. Если первый символ набора — ``'^'``, все символы, *не* "
"входящие в набор, будут сопоставлены. Например, ``[^5]`` будет "
"соответствовать любому символу, кроме ``'5'``, а ``[^^]`` будет "
"соответствовать любому символу, кроме ``'^'``. ``^`` не имеет особого "
"значения, если это не первый символ в наборе."

#: ../../library/re.rst:271
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will match a right bracket, as well as left bracket, braces, "
"and parentheses."
msgstr ""
"Чтобы сопоставить литерал ``']'`` внутри набора, поставьте перед ним "
"обратную косую черту или поместите его в начало набора. Например, ``[()[\\]"
"{}]`` и ``[]()[{}]`` будут соответствовать правой скобке, а также левой "
"скобке, фигурным и круглым скобкам."

#: ../../library/re.rst:281
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"В будущем может быть добавлена ​​поддержка вложенных наборов и операций над "
"множествами, как в «Техническом стандарте Unicode #18». Это приведет к "
"изменению синтаксиса, поэтому для облегчения этого изменения в настоящее "
"время в неоднозначных случаях будет вызываться :exc:`FutureWarning`. Сюда "
"входят наборы, начинающиеся с литерала ``'['`` или содержащие литеральные "
"последовательности символов ``'--'``, ``'&&'``, ``'~~'`` и ``'| |'``. Чтобы "
"избежать предупреждения, экранируйте их обратной косой чертой."

#: ../../library/re.rst:291
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` возникает, если набор символов содержит конструкции, "
"которые семантически изменятся в будущем."

#: ../../library/re.rst:297
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:298
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, где *A* и *B* могут быть произвольными RE, создает регулярное "
"выражение, которое будет соответствовать либо *A*, либо *B*. Таким образом, "
"произвольное количество RE можно разделить с помощью ``'|'``. Это также "
"можно использовать внутри групп (см. ниже). При сканировании целевой строки "
"RE, разделенные ``'|'``, проверяются слева направо. Когда один шаблон "
"полностью совпадает, эта ветвь принимается. Это означает, что как только *A* "
"совпадет, *B* не будет проверяться дальше, даже если это приведет к более "
"длинному общему совпадению. Другими словами, оператор ``'|'`` никогда не "
"бывает жадным. Чтобы сопоставить литерал ``'|'``, используйте ``\\|`` или "
"заключите его в класс символов, как в ``[|]``."

#: ../../library/re.rst:311
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:312
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Соответствует любому регулярному выражению, находящемуся внутри круглых "
"скобок, и указывает начало и конец группы; содержимое группы может быть "
"получено после выполнения сопоставления и может быть сопоставлено позже в "
"строке с помощью специальной последовательности ``\\number``, описанной "
"ниже. Чтобы сопоставить литералы ``'('`` или ``')'``, используйте ``\\(`` "
"или ``\\)`` или заключите их в класс символов: ``[(]`` , ``[)]``."

#: ../../library/re.rst:320
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:321
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Это обозначение расширения (``'?'`` после ``' (в противном случае '`` не "
"имеет смысла). Первый символ после ``'?'`` определяет значение и дальнейший "
"синтаксис Конструкция is. Расширения обычно не создают новую группу; "
"единственное исключение из этого правила — ``(?P<name>...)``. ​​Ниже приведены "
"поддерживаемые в настоящее время расширения."

#: ../../library/re.rst:327
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:328
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) The group matches the empty string; the letters "
"set the corresponding flags for the entire regular expression:"
msgstr ""
"(Одна или несколько букв из набора ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``s'``, `` 'u'``, ``'x'``.) Группа соответствует пустой строке; буквы "
"устанавливают соответствующие флаги для всего регулярного выражения:"

#: ../../library/re.rst:333 ../../library/re.rst:365
msgid ":const:`re.A` (ASCII-only matching)"
msgstr ":const:`re.A` (соответствие только ASCII)"

#: ../../library/re.rst:334 ../../library/re.rst:366
msgid ":const:`re.I` (ignore case)"
msgstr ":const:`re.I` (игнорировать регистр)"

#: ../../library/re.rst:335 ../../library/re.rst:367
msgid ":const:`re.L` (locale dependent)"
msgstr ":const:`re.L` (зависит от локали)"

#: ../../library/re.rst:336 ../../library/re.rst:368
msgid ":const:`re.M` (multi-line)"
msgstr ":const:`re.M` (многострочный)"

#: ../../library/re.rst:337 ../../library/re.rst:369
msgid ":const:`re.S` (dot matches all)"
msgstr ":const:`re.S` (точка соответствует всем)"

#: ../../library/re.rst:338 ../../library/re.rst:370
msgid ":const:`re.U` (Unicode matching)"
msgstr ":const:`re.U` (соответствие Юникода)"

#: ../../library/re.rst:339 ../../library/re.rst:371
msgid ":const:`re.X` (verbose)"
msgstr ":const:`re.X` (многословный)"

#: ../../library/re.rst:341
msgid ""
"(The flags are described in :ref:`contents-of-module-re`.) This is useful if "
"you wish to include the flags as part of the regular expression, instead of "
"passing a *flag* argument to the :func:`re.compile` function. Flags should "
"be used first in the expression string."
msgstr ""
"(Флаги описаны в :ref:`contents-of-module-re`.) Это полезно, если вы хотите "
"включить флаги как часть регулярного выражения вместо передачи аргумента "
"*flag* в :func: функция `re.compile`. Флаги следует использовать первыми в "
"строке выражения."

#: ../../library/re.rst:347
msgid "This construction can only be used at the start of the expression."
msgstr "Эту конструкцию можно использовать только в начале выражения."

#: ../../library/re.rst:352
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:353
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Незахватывающая версия обычных круглых скобок. Соответствует любому "
"регулярному выражению, находящемуся внутри круглых скобок, но подстроку, "
"соответствующую группе, *нельзя* получить после выполнения сопоставления или "
"использовать в шаблоне позже."

#: ../../library/re.rst:358
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:359
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags for the part of the expression:"
msgstr ""
"(Ноль или более букв из набора ``'a'``, ``'i'``, ``'L'``, ``'m'``, ``s'``, "
"`` 'u'``, ``'x'``, за которым необязательно следует ``'-'``, за которым "
"следует одна или несколько букв из ``'i'``, ``'m'``, `` 's'``, ``'x'``.) "
"Буквы устанавливают или снимают соответствующие флаги для части выражения:"

#: ../../library/re.rst:373
msgid "(The flags are described in :ref:`contents-of-module-re`.)"
msgstr "(Флаги описаны в :ref:`contents-of-module-re`.)"

#: ../../library/re.rst:375
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"bytes patterns ``(?L:...)`` switches to locale dependent matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"Буквы ``'a'``, ``'L'`` и ``'u'`` являются взаимоисключающими при "
"использовании в качестве встроенных флагов, поэтому их нельзя комбинировать "
"или следовать за ``'-'`` . Вместо этого, когда один из них появляется во "
"встроенной группе, он переопределяет режим сопоставления во включающей "
"группе. В шаблонах Юникода ``(?a:...)`` переключается на соответствие только "
"ASCII, а ``(?u:...)`` переключается на соответствие Юникода (по умолчанию). "
"В байтовых шаблонах ``(?L:...)`` переключается на соответствие, зависящее от "
"локали, а ``(?a:...)`` переключается на соответствие только ASCII (по "
"умолчанию). Это переопределение действует только для узкой встроенной "
"группы, а исходный режим сопоставления восстанавливается за пределами группы."

#: ../../library/re.rst:387
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "Буквы ``'a'``, ``'L'`` и ``'u'`` также могут использоваться в группе."

#: ../../library/re.rst:390
msgid "``(?>...)``"
msgstr "``(?>...)``"

#: ../../library/re.rst:391
msgid ""
"Attempts to match ``...`` as if it was a separate regular expression, and if "
"successful, continues to match the rest of the pattern following it. If the "
"subsequent pattern fails to match, the stack can only be unwound to a point "
"*before* the ``(?>...)`` because once exited, the expression, known as an :"
"dfn:`atomic group`, has thrown away all stack points within itself. Thus, "
"``(?>.*).`` would never match anything because first the ``.*`` would match "
"all characters possible, then, having nothing left to match, the final ``.`` "
"would fail to match. Since there are no stack points saved in the Atomic "
"Group, and there is no stack point before it, the entire expression would "
"thus fail to match."
msgstr ""
"Пытается сопоставить ``...``, как если бы это было отдельное регулярное "
"выражение, и в случае успеха продолжает сопоставлять остальную часть "
"следующего за ним шаблона. Если последующий шаблон не соответствует, стек "
"можно развернуть только до точки *перед* ``(?>...)``, потому что после "
"выхода выражение, известное как :dfn:`атомарная группа`, выбросил все очки "
"стека внутри себя. Таким образом, ``(?>.*).`` никогда не будет "
"соответствовать ничему, потому что сначала ``.*`` будет соответствовать всем "
"возможным символам, а затем, когда не останется ничего для сопоставления, "
"последний ``.`` не сможет соответствовать. соответствовать. Поскольку в "
"атомарной группе нет сохраненных точек стека, и перед ней нет точки стека, "
"все выражение не будет соответствовать."

#: ../../library/re.rst:407
msgid "``(?P<name>...)``"
msgstr "``(?P<name>...)``"

#: ../../library/re.rst:408
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and in :class:`bytes` patterns they can only contain "
"bytes in the ASCII range.  Each group name must be defined only once within "
"a regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Аналогично обычным круглым скобкам, но подстрока, соответствующая группе, "
"доступна через символическое имя группы *name*. Имена групп должны быть "
"допустимыми идентификаторами Python, а в шаблонах :class:`bytes` они могут "
"содержать только байты в диапазоне ASCII. Каждое имя группы должно быть "
"определено только один раз в регулярном выражении. Символическая группа "
"также является пронумерованной группой, как если бы группа не имела имени."

#: ../../library/re.rst:415
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"На именованные группы можно ссылаться в трех контекстах. Если шаблон ``(?"
"P<quote>['\"]).*?(?P=quote)`` (т.е. соответствует строке, заключенной в "
"одинарные или двойные кавычки):"

#: ../../library/re.rst:420
msgid "Context of reference to group \"quote\""
msgstr "Контекст обращения к группе «цитата»"

#: ../../library/re.rst:420
msgid "Ways to reference it"
msgstr "Способы ссылки на него"

#: ../../library/re.rst:422
msgid "in the same pattern itself"
msgstr "по той же схеме"

#: ../../library/re.rst:422
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (как показано)"

#: ../../library/re.rst:423 ../../library/re.rst:430
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:425
msgid "when processing match object *m*"
msgstr "при обработке объекта соответствия *m*"

#: ../../library/re.rst:425
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:426
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (и т.д.)"

#: ../../library/re.rst:428
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "в строке, передаваемой в аргумент *repl* функции ``re.sub()``"

#: ../../library/re.rst:428
msgid "``\\g<quote>``"
msgstr "``\\g<quote>``"

#: ../../library/re.rst:429
msgid "``\\g<1>``"
msgstr "``\\g<1>``"

#: ../../library/re.rst:433
msgid ""
"In :class:`bytes` patterns, group *name* can only contain bytes in the ASCII "
"range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"В шаблонах :class:`bytes` группа *name* может содержать только байты в "
"диапазоне ASCII (``b'\\x00'``-``b'\\x7f'``."

#: ../../library/re.rst:439
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:440
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Обратная ссылка на именованную группу; он соответствует любому тексту, "
"который был найден в предыдущей группе с именем *name*."

#: ../../library/re.rst:445
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:446
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "Комментарий; содержимое скобок просто игнорируется."

#: ../../library/re.rst:450
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:451
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Соответствует, если ``...`` соответствует следующему, но не использует какую-"
"либо строку. Это называется :dfn:`упреждающим утверждением`. Например, "
"``Isaac (?=Asimov)`` будет соответствовать ``'Isaac '``, только если за ним "
"следует ``'Asimov'``."

#: ../../library/re.rst:457
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:458
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Соответствует, если ``...`` не соответствует следующему. Это :dfn:"
"`утверждение отрицательного прогнозирования`. Например, ``Isaac (?!Asimov)`` "
"будет соответствовать ``'Isaac '``, только если за ним *не* следует "
"``'Asimov'``."

#: ../../library/re.rst:464
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:465
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Соответствует, если текущей позиции в строке предшествует совпадение с ``..."
"``, которое заканчивается в текущей позиции. Это называется :dfn:`позитивным "
"утверждением ретроспективного просмотра`. ``(?<=abc)def`` найдет совпадение "
"в ``'abcdef'``, поскольку просмотр назад скопирует 3 символа и проверит, "
"соответствует ли содержащийся шаблон. Содержащийся шаблон должен "
"соответствовать только строкам некоторой фиксированной длины. Это означает, "
"что ``abc`` или ``a|b`` разрешены, но ``a*`` и ``a{3,4}`` недопустимы. . "
"Обратите внимание, что шаблоны, начинающиеся с положительных утверждений "
"просмотра назад, не будут соответствовать началу искомой строки; вы, скорее "
"всего, захотите использовать функцию :func:`search` вместо функции :func:"
"`match`:"

#: ../../library/re.rst:480
msgid "This example looks for a word following a hyphen:"
msgstr "В этом примере выполняется поиск слова, следующего за дефисом:"

#: ../../library/re.rst:486
msgid "Added support for group references of fixed length."
msgstr "Добавлена ​​поддержка групповых ссылок фиксированной длины."

#: ../../library/re.rst:491
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:492
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Соответствует, если текущей позиции в строке не предшествует совпадение с "
"``...``. Это называется :dfn:`утверждением отрицательного просмотра`. "
"Подобно утверждениям положительного просмотра назад, содержащийся шаблон "
"должен соответствовать только строкам некоторой фиксированной длины. "
"Шаблоны, начинающиеся с отрицательных утверждений просмотра назад, могут "
"совпадать в начале искомой строки."

#: ../../library/re.rst:501
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:502
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Попытается сопоставить с ``yes-pattern``, если группа с данным *id* или "
"*name* существует, и с ``no-pattern``, если нет. ``no-pattern`` не является "
"обязательным и может быть опущен. Например, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` — это плохой шаблон соответствия электронной почты, который будет "
"соответствовать ``' <user@host.com>'``, а также ``'user@host.com'``, но не с "
"``'<user@host.com'`` и ``'user@host.com> '``."

#: ../../library/re.rst:509
msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` patterns, group "
"*name* can only contain bytes in the ASCII range (``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"Группа *id* может содержать только цифры ASCII. В шаблонах :class:`bytes` "
"группа *name* может содержать только байты в диапазоне ASCII (``b'\\x00'``-"
"``b'\\x7f'``."

#: ../../library/re.rst:517
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"Специальные последовательности состоят из ``'\\'`` и символа из списка ниже. "
"Если обычный символ не является цифрой ASCII или буквой ASCII, то "
"результирующий RE будет соответствовать второму символу. Например, ``\\$`` "
"соответствует символу ``'$'``."

#: ../../library/re.rst:524
msgid "``\\number``"
msgstr "``\\number``"

#: ../../library/re.rst:525
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Соответствует содержимому группы с тем же номером. Группы нумеруются начиная "
"с 1. Например, ``(.+) \\1`` соответствует ``'the'`` или ``'55 55'``, но не "
"``'thethe'`` (примечание пробел после группы). Эту специальную "
"последовательность можно использовать только для сопоставления с одной из "
"первых 99 групп. Если первая цифра *number* равна 0 или *number* состоит из "
"3 восьмеричных цифр, оно будет интерпретироваться не как совпадение группы, "
"а как символ с восьмеричным значением *number*. Внутри ``'['`` и ``']'`` "
"класса символов все числовые escape-символы обрабатываются как символы."

#: ../../library/re.rst:536
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:537
msgid "Matches only at the start of the string."
msgstr "Соответствует только началу строки."

#: ../../library/re.rst:541
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:542
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters. Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning or end of the string. This "
"means that ``r'\\bat\\b'`` matches ``'at'``, ``'at.'``, ``'(at)'``, and "
"``'as at ay'`` but not ``'attempt'`` or ``'atlas'``."
msgstr ""
"Соответствует пустой строке, но только в начале или конце слова. Слово "
"определяется как последовательность словных символов. Обратите внимание, что "
"формально ``\\b`` определяется как граница между символами ``\\w`` и ``\\W`` "
"(или наоборот) или между ``\\w`` и началом или конец строки. Это означает, "
"что ``r'\\bat\\b'`` соответствует ``'at'``, ``'at.'``, ``'(at)'`` и ``'as at "
"ay' `` но не ``'попытка'`` или ``атлас'``."

#: ../../library/re.rst:550
msgid ""
"The default word characters in Unicode (str) patterns are Unicode "
"alphanumerics and the underscore, but this can be changed by using the :py:"
"const:`~re.ASCII` flag. Word boundaries are determined by the current locale "
"if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"Символами слов по умолчанию в шаблонах Юникода (str) являются буквенно-"
"цифровые символы Юникода и знак подчеркивания, но это можно изменить с "
"помощью флага :py:const:`~re.ASCII`. Границы слов определяются текущей "
"локалью, если используется флаг :py:const:`~re.LOCALE`."

#: ../../library/re.rst:558
msgid ""
"Inside a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"Внутри диапазона символов ``\\b`` представляет собой символ возврата на "
"задний план для совместимости со строковыми литералами Python."

#: ../../library/re.rst:563
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:564
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word. This means that ``r'at\\B'`` matches ``'athens'``, ``'atom'``, "
"``'attorney'``, but not ``'at'``, ``'at.'``, or ``'at!'``. ``\\B`` is the "
"opposite of ``\\b``, so word characters in Unicode (str) patterns are "
"Unicode alphanumerics or the underscore, although this can be changed by "
"using the :py:const:`~re.ASCII` flag. Word boundaries are determined by the "
"current locale if the :py:const:`~re.LOCALE` flag is used."
msgstr ""
"Соответствует пустой строке, но только если она *не* находится в начале или "
"конце слова. Это означает, что ``r'at\\B'`` соответствует ``'athens'``, "
"``'atom'``, ``'attorney'``, но не ``'at'``, `` 'at.'`` или ``'at!'``. "
"``\\B`` является противоположностью ``\\b``, поэтому символы слов в шаблонах "
"Юникода (str) представляют собой буквенно-цифровые символы Юникода или знак "
"подчеркивания, хотя это можно изменить с помощью :py:const:`~re. Флаг ASCII. "
"Границы слов определяются текущей локалью, если используется флаг :py:const:"
"`~re.LOCALE`."

#: ../../library/re.rst:577
msgid ""
"Note that ``\\B`` does not match an empty string, which differs from RE "
"implementations in other programming languages such as Perl. This behavior "
"is kept for compatibility reasons."
msgstr ""
"Обратите внимание, что ``\\B`` не соответствует пустой строке, что "
"отличается от реализаций RE в других языках программирования, таких как "
"Perl. Такое поведение сохраняется по соображениям совместимости."

#: ../../library/re.rst:583
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:584 ../../library/re.rst:608 ../../library/re.rst:630
msgid "For Unicode (str) patterns:"
msgstr "Для шаблонов Unicode (str):"

#: ../../library/re.rst:585
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category `[Nd]`__). This includes ``[0-9]``, and also many other "
"digit characters."
msgstr ""
"Соответствует любой десятичной цифре Юникода (то есть любому символу из "
"категории символов Юникода `[Nd]`__). Сюда входят ``[0-9]``, а также многие "
"другие цифровые символы."

#: ../../library/re.rst:589
msgid "Matches ``[0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr "Соответствует ``[0-9]``, если используется флаг :py:const:`~re.ASCII`."

#: ../../library/re.rst:593 ../../library/re.rst:615 ../../library/re.rst:638
msgid "For 8-bit (bytes) patterns:"
msgstr "Для 8-битных (байтовых) шаблонов:"

#: ../../library/re.rst:594
msgid ""
"Matches any decimal digit in the ASCII character set; this is equivalent to "
"``[0-9]``."
msgstr ""
"Соответствует любой десятичной цифре в наборе символов ASCII; это "
"эквивалентно ``[0-9]``."

#: ../../library/re.rst:599
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:600
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``."
msgstr ""
"Соответствует любому символу, кроме десятичной цифры. Это противоположность "
"``\\d``."

#: ../../library/re.rst:603
msgid "Matches ``[^0-9]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Соответствует ``[^0-9]``, если используется флаг :py:const:`~re.ASCII`."

#: ../../library/re.rst:607
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:609
msgid ""
"Matches Unicode whitespace characters (as defined by :py:meth:`str."
"isspace`). This includes ``[ \\t\\n\\r\\f\\v]``, and also many other "
"characters, for example the non-breaking spaces mandated by typography rules "
"in many languages."
msgstr ""
"Соответствует пробельным символам Юникода (как определено в :py:meth:`str."
"isspace`). Сюда входят ``[ \\t\\n\\r\\f\\v]``, а также многие другие "
"символы, например неразрывные пробелы, предусмотренные правилами типографики "
"во многих языках."

#: ../../library/re.rst:613
msgid ""
"Matches ``[ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Соответствует ``[ \\t\\n\\r\\f\\v]``, если используется флаг :py:const:`~re."
"ASCII`."

#: ../../library/re.rst:616
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Соответствует символам, которые считаются пробелами в наборе символов ASCII; "
"это эквивалентно ``[ \\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:621
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:622
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``."
msgstr ""
"Соответствует любому символу, не являющемуся пробелом. Это противоположность "
"``\\s``."

#: ../../library/re.rst:625
msgid ""
"Matches ``[^ \\t\\n\\r\\f\\v]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Соответствует ``[^ \\t\\n\\r\\f\\v]``, если используется флаг :py:const:`~re."
"ASCII`."

#: ../../library/re.rst:629
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:631
msgid ""
"Matches Unicode word characters; this includes all Unicode alphanumeric "
"characters (as defined by :py:meth:`str.isalnum`), as well as the underscore "
"(``_``)."
msgstr ""
"Соответствует символам слов Юникода; сюда входят все буквенно-цифровые "
"символы Юникода (как определено в :py:meth:`str.isalnum`), а также "
"подчеркивание (``_``)."

#: ../../library/re.rst:636
msgid "Matches ``[a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Соответствует ``[a-zA-Z0-9_]``, если используется флаг :py:const:`~re.ASCII`."

#: ../../library/re.rst:639
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``. If the :py:const:`~re.LOCALE` flag is "
"used, matches characters considered alphanumeric in the current locale and "
"the underscore."
msgstr ""
"Соответствует символам, которые считаются буквенно-цифровыми в наборе "
"символов ASCII; это эквивалентно ``[a-zA-Z0-9_]``. Если используется флаг :"
"py:const:`~re.LOCALE`, он соответствует символам, считающимся буквенно-"
"цифровыми в текущей локали, и знаку подчеркивания."

#: ../../library/re.rst:646
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:647
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. By default, matches non-underscore (``_``) characters for which :py:"
"meth:`str.isalnum` returns ``False``."
msgstr ""
"Соответствует любому символу, который не является символом слова. Это "
"противоположность ``\\w``. По умолчанию соответствует символам без "
"подчеркивания (``_``), для которых :py:meth:`str.isalnum` возвращает "
"``False``."

#: ../../library/re.rst:652
msgid "Matches ``[^a-zA-Z0-9_]`` if the :py:const:`~re.ASCII` flag is used."
msgstr ""
"Соответствует ``[^a-zA-Z0-9_]``, если используется флаг :py:const:`~re."
"ASCII`."

#: ../../library/re.rst:654
msgid ""
"If the :py:const:`~re.LOCALE` flag is used, matches characters which are "
"neither alphanumeric in the current locale nor the underscore."
msgstr ""
"Если используется флаг :py:const:`~re.LOCALE`, он соответствует символам, "
"которые не являются ни буквенно-цифровыми в текущей локали, ни "
"подчеркиванием."

#: ../../library/re.rst:660
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:661
msgid "Matches only at the end of the string."
msgstr "Соответствует только концу строки."

#: ../../library/re.rst:677
msgid ""
"Most of the :ref:`escape sequences <escape-sequences>` supported by Python "
"string literals are also accepted by the regular expression parser::"
msgstr ""
"Большинство :ref:`escape-последовательностей <escape-sequences>`, "
"поддерживаемых строковыми литералами Python, также принимаются анализатором "
"регулярных выражений::"

#: ../../library/re.rst:680
msgid ""
"\\a      \\b      \\f      \\n\n"
"\\N      \\r      \\t      \\u\n"
"\\U      \\v      \\x      \\\\"
msgstr ""
"\\a      \\b      \\f      \\n\n"
"\\N      \\r      \\t      \\u\n"
"\\U      \\v      \\x      \\\\"

#: ../../library/re.rst:684
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Обратите внимание, что ``\\b`` используется для обозначения границ слов и "
"означает «возврат» только внутри классов символов.)"

#: ../../library/re.rst:687
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes "
"of ASCII letters are reserved for future use and treated as errors."
msgstr ""
"escape-последовательности ``'\\u'``, ``'\\U'`` и ``'\\N'`` распознаются "
"только в шаблонах Unicode (str). В шаблонах байтов это ошибки. Неизвестные "
"escape-символы ASCII-букв зарезервированы для использования в будущем и "
"рассматриваются как ошибки."

#: ../../library/re.rst:693
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Восьмеричные побеги включены в ограниченном виде. Если первая цифра равна 0 "
"или имеется три восьмеричные цифры, это считается восьмеричным escape. В "
"противном случае это групповая ссылка. Что касается строковых литералов, "
"восьмеричные escape-символы всегда имеют длину не более трех цифр."

#: ../../library/re.rst:698
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Были добавлены escape-последовательности ``'\\u'`` и ``'\\U'``."

#: ../../library/re.rst:701
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Неизвестные escape-символы, состоящие из ``'\\'`` и буквы ASCII, теперь "
"являются ошибками."

#: ../../library/re.rst:704
msgid ""
"The :samp:`'\\\\N\\\\{{name}\\\\}'` escape sequence has been added. As in "
"string literals, it expands to the named Unicode character (e.g. ``'\\N{EM "
"DASH}'``)."
msgstr ""
"Добавлена ​​escape-последовательность :samp:`'\\N\\\\{{name}\\\\}'`. Как и в "
"случае строковых литералов, он расширяется до именованного символа Юникода "
"(например, ``'\\N{EM DASH}'``)."

#: ../../library/re.rst:712
msgid "Module Contents"
msgstr "Содержимое модуля"

#: ../../library/re.rst:714
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"Модуль определяет несколько функций, констант и исключений. Некоторые "
"функции представляют собой упрощенные версии полнофункциональных методов для "
"скомпилированных регулярных выражений. Большинство нетривиальных приложений "
"всегда используют скомпилированную форму."

#: ../../library/re.rst:721
msgid "Flags"
msgstr "Флаги"

#: ../../library/re.rst:723
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Константы флагов теперь являются экземплярами :class:`RegexFlag`, который "
"является подклассом :class:`enum.IntFlag`."

#: ../../library/re.rst:730
msgid ""
"An :class:`enum.IntFlag` class containing the regex options listed below."
msgstr ""
"Класс :class:`enum.IntFlag`, содержащий параметры регулярного выражения, "
"перечисленные ниже."

#: ../../library/re.rst:732
msgid "- added to ``__all__``"
msgstr "- добавлено в ``__all__``"

#: ../../library/re.rst:737
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode (str) patterns, and is ignored for bytes "
"patterns."
msgstr ""
"Создайте ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` и "
"``\\S`` выполняет сопоставление только ASCII вместо полного сопоставления "
"Unicode. Это имеет смысл только для шаблонов Unicode (str) и игнорируется "
"для шаблонов байтов."

#: ../../library/re.rst:741
msgid "Corresponds to the inline flag ``(?a)``."
msgstr "Соответствует встроенному флагу ``(?a)``."

#: ../../library/re.rst:745
msgid ""
"The :py:const:`~re.U` flag still exists for backward compatibility, but is "
"redundant in Python 3 since matches are Unicode by default for ``str`` "
"patterns, and Unicode matching isn't allowed for bytes patterns. :py:const:"
"`~re.UNICODE` and the inline flag ``(?u)`` are similarly redundant."
msgstr ""
"Флаг :py:const:`~re.U` по-прежнему существует для обратной совместимости, но "
"он является избыточным в Python 3, поскольку по умолчанию для шаблонов "
"``str`` соответствует Unicode, а для шаблонов байтов соответствие Unicode не "
"разрешено. :py:const:`~re.UNICODE` и встроенный флаг ``(?u)`` также "
"избыточны."

#: ../../library/re.rst:754
msgid "Display debug information about compiled expression."
msgstr "Отображение отладочной информации о скомпилированном выражении."

#: ../../library/re.rst:756
msgid "No corresponding inline flag."
msgstr "Нет соответствующего встроенного флага."

#: ../../library/re.rst:762
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also  "
"match lowercase letters. Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :py:const:`~re.ASCII` flag is used to disable "
"non-ASCII matches. The current locale does not change the effect of this "
"flag unless the :py:const:`~re.LOCALE` flag is also used."
msgstr ""
"Выполнить сопоставление без учета регистра; выражения типа ``[AZ]`` также "
"будут соответствовать строчным буквам. Полное соответствие Юникода "
"(например, сопоставление ``Ü`` ``ü``) также работает, если только не "
"используется флаг :py:const:`~re.ASCII` для отключения совпадений, отличных "
"от ASCII. Текущая локаль не меняет эффект этого флага, если также не "
"используется флаг :py:const:`~re.LOCALE`."

#: ../../library/re.rst:770
msgid "Corresponds to the inline flag ``(?i)``."
msgstr "Соответствует встроенному флагу ``(?i)``."

#: ../../library/re.rst:772
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :py:const:`~re.ASCII` flag is used, only letters 'a' to 'z' and 'A' to "
"'Z' are matched."
msgstr ""
"Обратите внимание, что когда шаблоны Unicode ``[az]`` или ``[AZ]`` "
"используются в сочетании с флагом :const:`IGNORECASE`, они будут "
"соответствовать 52 буквам ASCII и 4 дополнительным буквам, отличным от "
"ASCII: 'İ' (U+0130, латинская заглавная буква I с точкой вверху), "
"'ı' (U+0131, латинская строчная буква без точки i), 'ſ' (U+017F, длинная "
"латинская строчная буква s) и 'K' (U+212A, знак Кельвина). Если используется "
"флаг :py:const:`~re.ASCII`, сопоставляются только буквы от «a» до «z» и от "
"«A» до «Z»."

#: ../../library/re.rst:783
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale. This flag can be used only with bytes "
"patterns."
msgstr ""
"Сделать ``\\w``, ``\\W``, ``\\b``, ``\\B`` и соответствие без учета регистра "
"в зависимости от текущей локали. Этот флаг можно использовать только с "
"шаблонами байтов."

#: ../../library/re.rst:787
msgid "Corresponds to the inline flag ``(?L)``."
msgstr "Corresponds to the inline flag ``(?L)``."

#: ../../library/re.rst:791
msgid ""
"This flag is discouraged; consider Unicode matching instead. The locale "
"mechanism is very unreliable as it only handles one \"culture\" at a time "
"and only works with 8-bit locales. Unicode matching is enabled by default "
"for Unicode (str) patterns and it is able to handle different locales and "
"languages."
msgstr ""
"Этот флаг не рекомендуется; вместо этого рассмотрите сопоставление Unicode. "
"Механизм локалей очень ненадежен, поскольку он обрабатывает только одну "
"«культуру» за раз и работает только с 8-битными локалями. Сопоставление "
"Юникода включено по умолчанию для шаблонов Юникода (str) и может "
"обрабатывать различные локали и языки."

#: ../../library/re.rst:798
msgid ""
":py:const:`~re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :py:const:`~re.ASCII`."
msgstr ""
":py:const:`~re.LOCALE` может использоваться только с байтовыми шаблонами и "
"несовместим с :py:const:`~re.ASCII`."

#: ../../library/re.rst:802
msgid ""
"Compiled regular expression objects with the :py:const:`~re.LOCALE` flag no "
"longer depend on the locale at compile time. Only the locale at matching "
"time affects the result of matching."
msgstr ""
"Скомпилированные объекты регулярных выражений с флагом :py:const:`~re."
"LOCALE` больше не зависят от локали во время компиляции. На результат "
"сопоставления влияет только локаль во время сопоставления."

#: ../../library/re.rst:811
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string."
msgstr ""
"Если он указан, символ шаблона ``'^'`` совпадает в начале строки и в начале "
"каждой строки (сразу после каждой новой строки); и символ шаблона ``'$'`` "
"совпадает в конце строки и в конце каждой строки (непосредственно перед "
"каждой новой строкой). По умолчанию ``'^'`` соответствует только началу "
"строки, а ``'$'`` только в конце строки и непосредственно перед символом "
"новой строки (если таковой имеется) в конце строки."

#: ../../library/re.rst:818
msgid "Corresponds to the inline flag ``(?m)``."
msgstr "Соответствует встроенному флагу ``(?m)``."

#: ../../library/re.rst:822
msgid ""
"Indicates no flag being applied, the value is ``0``.  This flag may be used "
"as a default value for a function keyword argument or as a base value that "
"will be conditionally ORed with other flags.  Example of use as a default "
"value::"
msgstr ""
"Указывает, что флаг не применяется, значение равно «0». Этот флаг можно "
"использовать в качестве значения по умолчанию для аргумента ключевого слова "
"функции или в качестве базового значения, которое будет объединяться по "
"условному оператору ИЛИ с другими флагами. Пример использования в качестве "
"значения по умолчанию::"

#: ../../library/re.rst:827
msgid ""
"def myfunc(text, flag=re.NOFLAG):\n"
"    return re.match(text, flag)"
msgstr ""
"def myfunc(text, flag=re.NOFLAG):\n"
"    return re.match(text, flag)"

#: ../../library/re.rst:835
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""
"Сделайте так, чтобы специальный символ ``'.'`` соответствовал любому "
"символу, включая новую строку; без этого флага ``'.'`` будет соответствовать "
"всему, *кроме* новой строки."

#: ../../library/re.rst:838
msgid "Corresponds to the inline flag ``(?s)``."
msgstr "Соответствует встроенному флагу ``(?s)``."

#: ../../library/re.rst:844
msgid ""
"In Python 3, Unicode characters are matched by default for ``str`` patterns. "
"This flag is therefore redundant with **no effect** and is only kept for "
"backward compatibility."
msgstr ""
"В Python 3 символы Юникода по умолчанию сопоставляются с шаблонами ``str``. "
"Поэтому этот флаг является избыточным и **не влияет** и сохраняется только "
"для обратной совместимости."

#: ../../library/re.rst:849
msgid ""
"See :py:const:`~re.ASCII` to restrict matching to ASCII characters instead."
msgstr ""
"См. :py:const:`~re.ASCII`, чтобы вместо этого ограничить соответствие "
"символами ASCII."

#: ../../library/re.rst:856
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""
"Этот флаг позволяет вам писать регулярные выражения, которые выглядят лучше "
"и более читабельны, позволяя визуально разделять логические разделы шаблона "
"и добавлять комментарии. Пробелы внутри шаблона игнорируются, за исключением "
"случаев, когда они находятся в классе символов, или когда им предшествует "
"неэкранированная обратная косая черта, или внутри токенов, таких как ``*?``, "
"``(?:`` или ``(?P<... >`` Например, ``(? :`` и ``* ?`` не допускаются. Если "
"строка содержит символ ``#``, который не принадлежит классу символов и "
"которому не предшествует неэкранированная обратная косая черта. , все "
"символы начиная с самого левого, например ``#``, до конца строки "
"игнорируются."

#: ../../library/re.rst:866
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Это означает, что два следующих объекта регулярных выражений, "
"соответствующие десятичному числу, функционально равны:"

#: ../../library/re.rst:869
msgid ""
"a = re.compile(r\"\"\"\\d +  # the integral part\n"
"                   \\.    # the decimal point\n"
"                   \\d *  # some fractional digits\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"
msgstr ""
"a = re.compile(r\"\"\"\\d +  # the integral part\n"
"                   \\.    # the decimal point\n"
"                   \\d *  # some fractional digits\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"

#: ../../library/re.rst:874
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Соответствует встроенному флагу ``(?x)``."

#: ../../library/re.rst:878
msgid "Functions"
msgstr "Функции"

#: ../../library/re.rst:882
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"Скомпилируйте шаблон регулярного выражения в :ref:`объект регулярного "
"выражения <re-objects>`, который можно использовать для сопоставления с "
"помощью его :func:`~Pattern.match`, :func:`~Pattern.search` и других методы, "
"описанные ниже."

#: ../../library/re.rst:887 ../../library/re.rst:919 ../../library/re.rst:937
#: ../../library/re.rst:948 ../../library/re.rst:994 ../../library/re.rst:1023
#: ../../library/re.rst:1038 ../../library/re.rst:1097
#: ../../library/re.rst:1136
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the `flags`_ variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"Поведение выражения можно изменить, указав значение *flags*. Значениями "
"могут быть любые переменные `flags`_, объединенные с помощью побитового ИЛИ "
"(оператор ``|``)."

#: ../../library/re.rst:891
msgid "The sequence ::"
msgstr "Последовательность ::"

#: ../../library/re.rst:893
msgid ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"
msgstr ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"

#: ../../library/re.rst:896
msgid "is equivalent to ::"
msgstr "эквивалентно::"

#: ../../library/re.rst:898
msgid "result = re.match(pattern, string)"
msgstr "result = re.match(pattern, string)"

#: ../../library/re.rst:900
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"но использование :func:`re.compile` и сохранение полученного объекта "
"регулярного выражения для повторного использования более эффективно, когда "
"выражение будет использоваться несколько раз в одной программе."

#: ../../library/re.rst:906
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"Скомпилированные версии самых последних шаблонов, передаваемые в :func:`re."
"compile`, и функции сопоставления на уровне модуля кэшируются, поэтому "
"программам, которые используют только несколько регулярных выражений "
"одновременно, не нужно беспокоиться о компиляции регулярных выражений."

#: ../../library/re.rst:914
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :class:"
"`~re.Match`. Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"Просканируйте *строку* в поисках первого места, где регулярное выражение "
"*шаблон* создает совпадение, и верните соответствующий :class:`~re.Match`. "
"Верните None, если ни одна позиция в строке не соответствует шаблону; "
"обратите внимание, что это отличается от поиска совпадения нулевой длины в "
"какой-то точке строки."

#: ../../library/re.rst:926
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`~re.Match`.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"Если ноль или более символов в начале *строки* соответствуют регулярному "
"выражению *шаблон*, верните соответствующий :class:`~re.Match`. Верните "
"None, если строка не соответствует шаблону; обратите внимание, что это "
"отличается от совпадения нулевой длины."

#: ../../library/re.rst:931
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Обратите внимание, что даже в режиме :const:`MULTILINE` :func:`re.match` "
"будет соответствовать только началу строки, а не началу каждой строки."

#: ../../library/re.rst:934
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Если вы хотите найти совпадение в любом месте *строки*, используйте вместо "
"этого :func:`search` (см. также :ref:`search-vs-match`)."

#: ../../library/re.rst:944
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""
"Если вся *строка* соответствует *шаблону* регулярного выражения, верните "
"соответствующий :class:`~re.Match`. Верните None, если строка не "
"соответствует шаблону; обратите внимание, что это отличается от совпадения "
"нулевой длины."

#: ../../library/re.rst:957
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Разделить *строку* по вхождениям *шаблона*. Если в *шаблоне* используются "
"захватывающие круглые скобки, то текст всех групп в шаблоне также "
"возвращается как часть результирующего списка. Если *maxsplit* не равно "
"нулю, происходит не более *maxsplit* разбиений, а остаток строки "
"возвращается как последний элемент списка. ::"

#: ../../library/re.rst:963
msgid ""
">>> re.split(r'\\W+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'(\\W+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'\\W+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"
msgstr ""
">>> re.split(r'\\W+', 'Words, words, words.')\n"
"['Words', 'words', 'words', '']\n"
">>> re.split(r'(\\W+)', 'Words, words, words.')\n"
"['Words', ', ', 'words', ', ', 'words', '.', '']\n"
">>> re.split(r'\\W+', 'Words, words, words.', 1)\n"
"['Words', 'words, words.']\n"
">>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)\n"
"['0', '3', '9']"

#: ../../library/re.rst:972
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Если в разделителе есть группы захвата и они совпадают в начале строки, "
"результат начнется с пустой строки. То же самое справедливо и для конца "
"строки::"

#: ../../library/re.rst:976
msgid ""
">>> re.split(r'(\\W+)', '...words, words...')\n"
"['', '...', 'words', ', ', 'words', '...', '']"
msgstr ""
">>> re.split(r'(\\W+)', '...words, words...')\n"
"['', '...', 'words', ', ', 'words', '...', '']"

#: ../../library/re.rst:979
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"Таким образом, компоненты разделителя всегда находятся в одних и тех же "
"относительных индексах в списке результатов."

#: ../../library/re.rst:982
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""
"Пустые совпадения с шаблоном разделяют строку только в том случае, если они "
"не являются соседними с предыдущим пустым совпадением."

#: ../../library/re.rst:985
msgid ""
">>> re.split(r'\\b', 'Words, words, words.')\n"
"['', 'Words', ', ', 'words', ', ', 'words', '.']\n"
">>> re.split(r'\\W*', '...words...')\n"
"['', '', 'w', 'o', 'r', 'd', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...words...')\n"
"['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', "
"'']"
msgstr ""
">>> re.split(r'\\b', 'Words, words, words.')\n"
"['', 'Words', ', ', 'words', ', ', 'words', '.']\n"
">>> re.split(r'\\W*', '...words...')\n"
"['', '', 'w', 'o', 'r', 'd', 's', '', '']\n"
">>> re.split(r'(\\W*)', '...words...')\n"
"['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', "
"'']"

#: ../../library/re.rst:998 ../../library/re.rst:1101 ../../library/re.rst:1130
msgid "Added the optional flags argument."
msgstr "Добавлен необязательный аргумент флагов."

#: ../../library/re.rst:1001
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""
"Добавлена ​​поддержка разделения по шаблону, который может соответствовать "
"пустой строке."

#: ../../library/re.rst:1007
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"Возвращает все непересекающиеся совпадения *pattern* в *string* в виде "
"списка строк или кортежей. *Строка* сканируется слева направо, и совпадения "
"возвращаются в найденном порядке. Пустые совпадения включаются в результат."

#: ../../library/re.rst:1011
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"Результат зависит от количества групп захвата в шаблоне. Если групп нет, "
"верните список строк, соответствующих всему шаблону. Если существует ровно "
"одна группа, верните список строк, соответствующих этой группе. Если "
"присутствует несколько групп, верните список кортежей строк, соответствующих "
"группам. Незахватывающие группы не влияют на форму результата."

#: ../../library/re.rst:1027 ../../library/re.rst:1042
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""
"Непустые совпадения теперь могут начинаться сразу после предыдущего пустого "
"совпадения."

#: ../../library/re.rst:1033
msgid ""
"Return an :term:`iterator` yielding :class:`~re.Match` objects over all non-"
"overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result."
msgstr ""
"Возвращает :term:`iterator`, возвращающий :class:`~re.Match` объекты по всем "
"непересекающимся совпадениям для *pattern* RE в *string*. *Строка* "
"сканируется слева направо, и совпадения возвращаются в найденном порядке. "
"Пустые совпадения включаются в результат."

#: ../../library/re.rst:1048
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"Возвращает строку, полученную путем замены крайних левых непересекающихся "
"вхождений *pattern* в *string* заменой *repl*. Если шаблон не найден, "
"*строка* возвращается без изменений. *repl* может быть строкой или функцией; "
"если это строка, любые символы обратной косой черты в ней обрабатываются. То "
"есть ``\\n`` преобразуется в один символ новой строки, ``\\r`` преобразуется "
"в возврат каретки и так далее. Неизвестные escape-символы ASCII-букв "
"зарезервированы для использования в будущем и рассматриваются как ошибки. "
"Другие неизвестные escape-последовательности, такие как ``\\&``, остаются в "
"покое. Обратные ссылки, такие как ``\\6``, заменяются подстрокой, "
"соответствующей группе 6 в шаблоне. Например::"

#: ../../library/re.rst:1059
msgid ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"...        r'static PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'static PyObject*\\npy_myfunc(void)\\n{'"
msgstr ""
">>> re.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n"
"...        r'static PyObject*\\npy_\\1(void)\\n{',\n"
"...        'def myfunc():')\n"
"'static PyObject*\\npy_myfunc(void)\\n{'"

#: ../../library/re.rst:1064
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :class:`~re.Match` argument, and "
"returns the replacement string.  For example::"
msgstr ""
"Если *repl* — функция, она вызывается для каждого непересекающегося "
"вхождения *pattern*. Функция принимает один аргумент :class:`~re.Match` и "
"возвращает строку замены. Например::"

#: ../../library/re.rst:1068
msgid ""
">>> def dashrepl(matchobj):\n"
"...     if matchobj.group(0) == '-': return ' '\n"
"...     else: return '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')\n"
"'pro--gram files'\n"
">>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re."
"IGNORECASE)\n"
"'Baked Beans & Spam'"
msgstr ""
">>> def dashrepl(matchobj):\n"
"...     if matchobj.group(0) == '-': return ' '\n"
"...     else: return '-'\n"
"...\n"
">>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')\n"
"'pro--gram files'\n"
">>> re.sub(r'\\sAND\\s', ' & ', 'Baked Beans And Spam', flags=re."
"IGNORECASE)\n"
"'Baked Beans & Spam'"

#: ../../library/re.rst:1077
msgid "The pattern may be a string or a :class:`~re.Pattern`."
msgstr "Шаблон может быть строкой или :class:`~re.Pattern`."

#: ../../library/re.rst:1079
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"Необязательный аргумент *count* — это максимальное количество вхождений "
"шаблона, которые необходимо заменить; *count* должно быть неотрицательным "
"целым числом. Если он опущен или равен нулю, все вхождения будут заменены. "
"Пустые совпадения шаблона заменяются только в том случае, если они не "
"являются соседними с предыдущим пустым совпадением, поэтому ``sub('x*', '-', "
"'abxd')`` возвращает ``'-ab--d-'`` ."

#: ../../library/re.rst:1087
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"В аргументах строкового типа *repl*, в дополнение к escape-символам и "
"обратным ссылкам, описанным выше, ``\\g<name>`` будет использовать "
"подстроку, соответствующую группе с именем ``name``, как определено в `` (?"
"P<имя>...)`` синтаксис. ``\\g<number>`` использует соответствующий номер "
"группы; Таким образом, ``\\g<2>`` эквивалентен ``\\2``, но не является "
"двусмысленным при замене, такой как ``\\g<2>0``. ``\\20`` будет "
"интерпретироваться как ссылка на группу 20, а не как ссылка на группу 2, за "
"которой следует буквальный символ ``'0'``. Обратная ссылка ``\\g<0>`` "
"заменяет всю подстроку, соответствующую RE."

#: ../../library/re.rst:1104 ../../library/re.rst:1133
#: ../../library/re.rst:1381
msgid "Unmatched groups are replaced with an empty string."
msgstr "Несовпадающие группы заменяются пустой строкой."

#: ../../library/re.rst:1107
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Неизвестные escape-символы в *шаблоне*, состоящем из ``'\\'`` и буквы ASCII, "
"теперь являются ошибками."

#: ../../library/re.rst:1111
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr ""
"Неизвестные escape-последовательности в *repl*, состоящие из ``'\\'`` и "
"буквы ASCII, теперь являются ошибками."

#: ../../library/re.rst:1115
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""
"Пустые совпадения шаблона заменяются, если они соседствуют с предыдущим "
"непустым совпадением."

#: ../../library/re.rst:1119
msgid ""
"Group *id* can only contain ASCII digits. In :class:`bytes` replacement "
"strings, group *name* can only contain bytes in the ASCII range "
"(``b'\\x00'``-``b'\\x7f'``)."
msgstr ""
"Группа *id* может содержать только цифры ASCII. В строках замены :class:"
"`bytes` группа *name* может содержать только байты в диапазоне ASCII "
"(``b'\\x00'``-``b'\\x7f'``."

#: ../../library/re.rst:1127
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Выполните ту же операцию, что и :func:`sub`, но верните кортеж "
"``(new_string, number_of_subs_made)``."

#: ../../library/re.rst:1143
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"Экранируйте специальные символы в *шаблоне*. Это полезно, если вы хотите "
"сопоставить произвольную литеральную строку, которая может содержать "
"метасимволы регулярного выражения. Например::"

#: ../../library/re.rst:1147
msgid ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:"
"\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+\n"
"\n"
">>> operators = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"
msgstr ""
">>> print(re.escape('https://www.python.org'))\n"
"https://www\\.python\\.org\n"
"\n"
">>> legal_chars = string.ascii_lowercase + string.digits + \"!#$%&'*+-.^_`|~:"
"\"\n"
">>> print('[%s]+' % re.escape(legal_chars))\n"
"[abcdefghijklmnopqrstuvwxyz0123456789!\\#\\$%\\&'\\*\\+\\-\\.\\^_`\\|\\~:]+\n"
"\n"
">>> operators = ['+', '-', '*', '/', '**']\n"
">>> print('|'.join(map(re.escape, sorted(operators, reverse=True))))\n"
"/|\\-|\\+|\\*\\*|\\*"

#: ../../library/re.rst:1158
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"Эту функцию нельзя использовать для строки замены в :func:`sub` и :func:"
"`subn`, экранировать следует только обратную косую черту. Например::"

#: ../../library/re.rst:1161
msgid ""
">>> digits_re = r'\\d+'\n"
">>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ errors, \\d+ warnings"
msgstr ""
">>> digits_re = r'\\d+'\n"
">>> sample = '/usr/sbin/sendmail - 0 errors, 12 warnings'\n"
">>> print(re.sub(digits_re, digits_re.replace('\\\\', r'\\\\'), sample))\n"
"/usr/sbin/sendmail - \\d+ errors, \\d+ warnings"

#: ../../library/re.rst:1166
msgid "The ``'_'`` character is no longer escaped."
msgstr "Символ ``'_'`` больше не экранируется."

#: ../../library/re.rst:1169
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"Экранируются только символы, которые могут иметь особое значение в "
"регулярном выражении. В результате ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, "
"``','``, ``'/'` `, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, и "
"``\"`\"`` больше не экранируются."

#: ../../library/re.rst:1178
msgid "Clear the regular expression cache."
msgstr "Очистите кеш регулярных выражений."

#: ../../library/re.rst:1182
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/re.rst:1186
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""
"Исключение возникает, когда строка, переданная одной из функций, не является "
"допустимым регулярным выражением (например, она может содержать "
"несовпадающие круглые скобки) или когда во время компиляции или "
"сопоставления возникает какая-либо другая ошибка. Если строка не содержит "
"совпадений с шаблоном, это никогда не является ошибкой. Экземпляр ошибки "
"имеет следующие дополнительные атрибуты:"

#: ../../library/re.rst:1194
msgid "The unformatted error message."
msgstr "Неформатированное сообщение об ошибке."

#: ../../library/re.rst:1198
msgid "The regular expression pattern."
msgstr "Шаблон регулярного выражения."

#: ../../library/re.rst:1202
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "Индекс в *pattern*, где компиляция не удалась (может быть ``None``)."

#: ../../library/re.rst:1206
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "Строка, соответствующая *pos* (может быть ``None``)."

#: ../../library/re.rst:1210
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "Столбец, соответствующий *pos* (может быть ``None``)."

#: ../../library/re.rst:1212
msgid "Added additional attributes."
msgstr "Добавлены дополнительные атрибуты."

#: ../../library/re.rst:1218
msgid "Regular Expression Objects"
msgstr "Объекты регулярных выражений"

#: ../../library/re.rst:1222
msgid "Compiled regular expression object returned by :func:`re.compile`."
msgstr ""
"Скомпилированный объект регулярного выражения, возвращаемый :func:`re."
"compile`."

#: ../../library/re.rst:1224
msgid ""
":py:class:`re.Pattern` supports ``[]`` to indicate a Unicode (str) or bytes "
"pattern. See :ref:`types-genericalias`."
msgstr ""
":py:class:`re.Pattern` поддерживает ``[]`` для указания шаблона Unicode "
"(str) или байтов. См. :ref:`types-genericalias`."

#: ../../library/re.rst:1230
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :class:`~re.Match`. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr ""
"Просканируйте *строку* в поисках первого места, где это регулярное выражение "
"создает совпадение, и верните соответствующий :class:`~re.Match`. Верните "
"None, если ни одна позиция в строке не соответствует шаблону; обратите "
"внимание, что это отличается от поиска совпадения нулевой длины в какой-то "
"точке строки."

#: ../../library/re.rst:1235
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"Необязательный второй параметр *pos* задает индекс в строке, с которой "
"должен начаться поиск; по умолчанию он равен ``0``. Это не полностью "
"эквивалентно разрезанию строки; символ шаблона ``'^'`` соответствует "
"реальному началу строки и позициям сразу после новой строки, но не "
"обязательно по индексу, с которого должен начаться поиск."

#: ../../library/re.rst:1241
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"Необязательный параметр *endpos* ограничивает глубину поиска строки; это "
"будет так, как будто строка состоит из символов *endpos*, поэтому для поиска "
"соответствия будут искаться только символы от *pos* до ``endpos - 1``. Если "
"*endpos* меньше, чем *pos*, совпадение не будет найдено; в противном случае, "
"если *rx* является скомпилированным объектом регулярного выражения, ``rx."
"search(string, 0, 50)`` эквивалентен ``rx.search(string[:50], 0)``. ::"

#: ../../library/re.rst:1248
msgid ""
">>> pattern = re.compile(\"d\")\n"
">>> pattern.search(\"dog\")     # Match at index 0\n"
"<re.Match object; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1)  # No match; search doesn't include the \"d\""
msgstr ""
">>> pattern = re.compile(\"d\")\n"
">>> pattern.search(\"dog\")     # Match at index 0\n"
"<re.Match object; span=(0, 1), match='d'>\n"
">>> pattern.search(\"dog\", 1)  # No match; search doesn't include the \"d\""

#: ../../library/re.rst:1256
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :class:`~re.Match`. Return ``None`` if "
"the string does not match the pattern; note that this is different from a "
"zero-length match."
msgstr ""
"Если ноль или более символов в *начале* *строки* соответствуют этому "
"регулярному выражению, верните соответствующий :class:`~re.Match`. Верните "
"None, если строка не соответствует шаблону; обратите внимание, что это "
"отличается от совпадения нулевой длины."

#: ../../library/re.rst:1261 ../../library/re.rst:1279
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""
"Необязательные параметры *pos* и *endpos* имеют то же значение, что и для "
"метода :meth:`~Pattern.search`. ::"

#: ../../library/re.rst:1264
msgid ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of "
"\"dog\".\n"
">>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of "
"\"dog\".\n"
"<re.Match object; span=(1, 2), match='o'>"
msgstr ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of "
"\"dog\".\n"
">>> pattern.match(\"dog\", 1)   # Match as \"o\" is the 2nd character of "
"\"dog\".\n"
"<re.Match object; span=(1, 2), match='o'>"

#: ../../library/re.rst:1269
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Если вы хотите найти совпадение в любом месте *string*, используйте вместо "
"этого :meth:`~Pattern.search` (см. также :ref:`search-vs-match`)."

#: ../../library/re.rst:1275
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :class:`~re.Match`.  Return ``None`` if the string does not "
"match the pattern; note that this is different from a zero-length match."
msgstr ""
"Если вся *строка* соответствует этому регулярному выражению, верните "
"соответствующий :class:`~re.Match`. Верните None, если строка не "
"соответствует шаблону; обратите внимание, что это отличается от совпадения "
"нулевой длины."

#: ../../library/re.rst:1282
msgid ""
">>> pattern = re.compile(\"o[gh]\")\n"
">>> pattern.fullmatch(\"dog\")      # No match as \"o\" is not at the start "
"of \"dog\".\n"
">>> pattern.fullmatch(\"ogre\")     # No match as not the full string "
"matches.\n"
">>> pattern.fullmatch(\"doggie\", 1, 3)   # Matches within given limits.\n"
"<re.Match object; span=(1, 3), match='og'>"
msgstr ""
">>> шаблон = re.compile(\"o[gh]\") \n"
">>> Pattern.fullmatch(\"dog\") # Нет совпадений, так как \"o\" не находится "
"в начале слова \"dog\". \n"
">>> шаблон.fullmatch(\"ogre\") # Нет совпадений, поскольку не совпадает вся "
"строка. \n"
">>> шаблон.fullmatch(\"собачка\", 1, 3) # Соответствует в заданных пределах. "
"<re.Match объект; span=(1, 3), match='og'>"

#: ../../library/re.rst:1293
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "Идентичен функции :func:`split`, использует скомпилированный шаблон."

#: ../../library/re.rst:1298
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Аналогично функции :func:`findall`, использует скомпилированный шаблон, но "
"также принимает дополнительные параметры *pos* и *endpos*, которые "
"ограничивают область поиска, как для :meth:`search`."

#: ../../library/re.rst:1305
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Аналогично функции :func:`finditer`, использует скомпилированный шаблон, но "
"также принимает дополнительные параметры *pos* и *endpos*, которые "
"ограничивают область поиска, как для :meth:`search`."

#: ../../library/re.rst:1312
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "Идентичен функции :func:`sub`, использует скомпилированный шаблон."

#: ../../library/re.rst:1317
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "Идентичен функции :func:`subn`, использует скомпилированный шаблон."

#: ../../library/re.rst:1322
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :py:const:`~re.UNICODE` if the pattern is a Unicode string."
msgstr ""
"Флаги соответствия регулярных выражений. Это комбинация флагов, заданных "
"для :func:`.compile`, любых встроенных флагов ``(?...)`` в шаблоне и неявных "
"флагов, таких как :py:const:`~re.UNICODE` если шаблон представляет собой "
"строку Юникода."

#: ../../library/re.rst:1329
msgid "The number of capturing groups in the pattern."
msgstr "Количество групп захвата в шаблоне."

#: ../../library/re.rst:1334
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"Словарь, сопоставляющий любые символические имена групп, определенные ``(?"
"P<id>)`` с номерами групп. Словарь пуст, если в шаблоне не использовались "
"символические группы."

#: ../../library/re.rst:1341
msgid "The pattern string from which the pattern object was compiled."
msgstr "Строка шаблона, из которой был скомпилирован объект шаблона."

#: ../../library/re.rst:1344
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"Добавлена ​​поддержка :func:`copy.copy` и :func:`copy.deepcopy`. "
"Скомпилированные объекты регулярных выражений считаются атомарными."

#: ../../library/re.rst:1352
msgid "Match Objects"
msgstr "Сопоставить объекты"

#: ../../library/re.rst:1354
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"Объекты совпадений всегда имеют логическое значение ``True``. Поскольку :"
"meth:`~Pattern.match` и :meth:`~Pattern.search` возвращают ``None``, если "
"совпадений нет, вы можете проверить, было ли совпадение, с помощью простого "
"оператора ``if``: :"

#: ../../library/re.rst:1359
msgid ""
"match = re.search(pattern, string)\n"
"if match:\n"
"    process(match)"
msgstr ""
"match = re.search(pattern, string)\n"
"if match:\n"
"    process(match)"

#: ../../library/re.rst:1365
msgid "Match object returned by successful ``match``\\ es and ``search``\\ es."
msgstr ""
"Объект соответствия, возвращаемый успешными запросами ``match``\\ и "
"``search``\\ es."

#: ../../library/re.rst:1367
msgid ""
":py:class:`re.Match` supports ``[]`` to indicate a Unicode (str) or bytes "
"match. See :ref:`types-genericalias`."
msgstr ""
":py:class:`re.Match` поддерживает ``[]`` для указания соответствия Юникода "
"(str) или байтов. См. :ref:`types-genericalias`."

#: ../../library/re.rst:1373
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group. The "
"backreference ``\\g<0>`` will be replaced by the entire match."
msgstr ""
"Верните строку, полученную путем замены обратной косой черты в строке "
"шаблона *template*, как это делается с помощью метода :meth:`~Pattern.sub`. "
"Экранирующие символы, такие как ``\\n``, преобразуются в соответствующие "
"символы, а также числовые обратные ссылки (``\\1``, ``\\2``) и именованные "
"обратные ссылки (``\\g<1>``, `` \\g<name>``) заменяются содержимым "
"соответствующей группы. Обратная ссылка ``\\g<0>`` будет заменена полным "
"совпадением."

#: ../../library/re.rst:1386
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"Возвращает одну или несколько подгрупп соответствия. Если имеется один "
"аргумент, результатом будет одна строка; если имеется несколько аргументов, "
"результатом является кортеж с одним элементом на каждый аргумент. Без "
"аргументов *group1* по умолчанию равно нулю (возвращается все совпадение). "
"Если аргумент *groupN* равен нулю, соответствующее возвращаемое значение — "
"это вся соответствующая строка; если оно находится в инклюзивном диапазоне "
"[1..99], это строка, соответствующая соответствующей группе в скобках. Если "
"номер группы отрицательный или превышает количество групп, определенных в "
"шаблоне, возникает исключение :exc:`IndexError`. Если группа содержится в "
"части шаблона, которая не совпала, соответствующий результат — «Нет». Если "
"группа содержится в части шаблона, которая совпала несколько раз, "
"возвращается последнее совпадение. ::"

#: ../../library/re.rst:1398
msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m.group(0)       # The entire match\n"
"'Isaac Newton'\n"
">>> m.group(1)       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m.group(2)       # The second parenthesized subgroup.\n"
"'Newton'\n"
">>> m.group(1, 2)    # Multiple arguments give us a tuple.\n"
"('Isaac', 'Newton')"
msgstr ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m.group(0)       # The entire match\n"
"'Isaac Newton'\n"
">>> m.group(1)       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m.group(2)       # The second parenthesized subgroup.\n"
"'Newton'\n"
">>> m.group(1, 2)    # Multiple arguments give us a tuple.\n"
"('Isaac', 'Newton')"

#: ../../library/re.rst:1408
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"Если регулярное выражение использует синтаксис ``(?P<name>...)``, аргументы "
"*groupN* также могут быть строками, идентифицирующими группы по их имени. "
"Если строковый аргумент не используется в качестве имени группы в шаблоне, "
"возникает исключение :exc:`IndexError`."

#: ../../library/re.rst:1413
msgid "A moderately complicated example::"
msgstr "Умеренно сложный пример:"

#: ../../library/re.rst:1415
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.group('first_name')\n"
"'Malcolm'\n"
">>> m.group('last_name')\n"
"'Reynolds'"
msgstr ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.group('first_name')\n"
"'Malcolm'\n"
">>> m.group('last_name')\n"
"'Reynolds'"

#: ../../library/re.rst:1421
msgid "Named groups can also be referred to by their index::"
msgstr "На именованные группы также можно ссылаться по их индексу::"

#: ../../library/re.rst:1423
msgid ""
">>> m.group(1)\n"
"'Malcolm'\n"
">>> m.group(2)\n"
"'Reynolds'"
msgstr ""
">>> m.group(1)\n"
"'Malcolm'\n"
">>> m.group(2)\n"
"'Reynolds'"

#: ../../library/re.rst:1428
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"Если группа совпадает несколько раз, доступно только последнее совпадение:"

#: ../../library/re.rst:1430
msgid ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Matches 3 times.\n"
">>> m.group(1)                        # Returns only the last match.\n"
"'c3'"
msgstr ""
">>> m = re.match(r\"(..)+\", \"a1b2c3\")  # Matches 3 times.\n"
">>> m.group(1)                        # Returns only the last match.\n"
"'c3'"

#: ../../library/re.rst:1437
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"Это идентично ``m.group(g)``. Это упрощает доступ к отдельной группе из "
"матча:"

#: ../../library/re.rst:1440
msgid ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m[0]       # The entire match\n"
"'Isaac Newton'\n"
">>> m[1]       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m[2]       # The second parenthesized subgroup.\n"
"'Newton'"
msgstr ""
">>> m = re.match(r\"(\\w+) (\\w+)\", \"Isaac Newton, physicist\")\n"
">>> m[0]       # The entire match\n"
"'Isaac Newton'\n"
">>> m[1]       # The first parenthesized subgroup.\n"
"'Isaac'\n"
">>> m[2]       # The second parenthesized subgroup.\n"
"'Newton'"

#: ../../library/re.rst:1448
msgid "Named groups are supported as well::"
msgstr "Также поддерживаются именованные группы:"

#: ../../library/re.rst:1450
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Isaac "
"Newton\")\n"
">>> m['first_name']\n"
"'Isaac'\n"
">>> m['last_name']\n"
"'Newton'"
msgstr ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Isaac "
"Newton\")\n"
">>> m['first_name']\n"
"'Isaac'\n"
">>> m['last_name']\n"
"'Newton'"

#: ../../library/re.rst:1461
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Возвращает кортеж, содержащий все подгруппы соответствия, от 1 до любого "
"количества групп, содержащихся в шаблоне. Аргумент *default* используется "
"для групп, не участвовавших в сопоставлении; по умолчанию установлено "
"значение «Нет»."

#: ../../library/re.rst:1465 ../../library/re.rst:1690
msgid "For example::"
msgstr "Например::"

#: ../../library/re.rst:1467
msgid ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n"
">>> m.groups()\n"
"('24', '1632')"
msgstr ""
">>> m = re.match(r\"(\\d+)\\.(\\d+)\", \"24.1632\")\n"
">>> m.groups()\n"
"('24', '1632')"

#: ../../library/re.rst:1471
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"Если мы сделаем десятичный знак и все, что после него, необязательным, не "
"все группы смогут участвовать в сопоставлении. По умолчанию для этих групп "
"будет установлено значение «Нет», если не указан аргумент *default*::"

#: ../../library/re.rst:1475
msgid ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups()      # Second group defaults to None.\n"
"('24', None)\n"
">>> m.groups('0')   # Now, the second group defaults to '0'.\n"
"('24', '0')"
msgstr ""
">>> m = re.match(r\"(\\d+)\\.?(\\d+)?\", \"24\")\n"
">>> m.groups()      # Second group defaults to None.\n"
"('24', None)\n"
">>> m.groups('0')   # Now, the second group defaults to '0'.\n"
"('24', '0')"

#: ../../library/re.rst:1484
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"Возвращает словарь, содержащий все *именованные* подгруппы соответствия, "
"ключом которых является имя подгруппы. Аргумент *default* используется для "
"групп, не участвовавших в сопоставлении; по умолчанию установлено значение "
"«Нет». Например::"

#: ../../library/re.rst:1488
msgid ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.groupdict()\n"
"{'first_name': 'Malcolm', 'last_name': 'Reynolds'}"
msgstr ""
">>> m = re.match(r\"(?P<first_name>\\w+) (?P<last_name>\\w+)\", \"Malcolm "
"Reynolds\")\n"
">>> m.groupdict()\n"
"{'first_name': 'Malcolm', 'last_name': 'Reynolds'}"

#: ../../library/re.rst:1496
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Возвращает индексы начала и конца подстроки, соответствующей *group*; "
"*group* по умолчанию равно нулю (имеется в виду вся совпавшая подстрока). "
"Верните ``-1``, если *group* существует, но не участвовала в совпадении. Для "
"объекта соответствия *m* и группы *g*, которая внесла свой вклад в "
"совпадение, подстрока, совпадающая с группой *g* (эквивалентна ``m."
"group(g)``), равна ::"

#: ../../library/re.rst:1502
msgid "m.string[m.start(g):m.end(g)]"
msgstr "m.string[m.start(g):m.end(g)]"

#: ../../library/re.rst:1504
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Обратите внимание, что ``m.start(group)`` будет равно ``m.end(group)``, если "
"*group* соответствует нулевой строке. Например, после ``m = re."
"search('b(c?)', 'cba')``, ``m.start(0)`` равен 1, ``m.end(0)`` равно 2, ``m."
"start(1)`` и ``m.end(1)`` оба равны 2, а ``m.start(2)`` вызывает исключение :"
"exc:`IndexError`."

#: ../../library/re.rst:1509
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "Пример удаления *remove_this* из адресов электронной почты::"

#: ../../library/re.rst:1511
msgid ""
">>> email = \"tony@tiremove_thisger.net\"\n"
">>> m = re.search(\"remove_this\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"
msgstr ""
">>> email = \"tony@tiremove_thisger.net\"\n"
">>> m = re.search(\"remove_this\", email)\n"
">>> email[:m.start()] + email[m.end():]\n"
"'tony@tiger.net'"

#: ../../library/re.rst:1519
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"Для совпадения *m* верните кортеж из двух ``(m.start(group), m."
"end(group))``. Обратите внимание: если *group* не участвовала в совпадении, "
"это ``(-1, -1)``. *group* по умолчанию равно нулю, все совпадение."

#: ../../library/re.rst:1526
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"Значение *pos*, которое было передано методу :meth:`~Pattern.search` или :"
"meth:`~Pattern.match` объекта :ref:`regex <re-objects>`. Это индекс строки, "
"с которой механизм RE начал поиск совпадения."

#: ../../library/re.rst:1533
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
"Значение *endpos*, которое было передано методу :meth:`~Pattern.search` или :"
"meth:`~Pattern.match` объекта :ref:`regex <re-objects>`. Это индекс строки, "
"за пределы которого механизм RE не выходит."

#: ../../library/re.rst:1540
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"Целочисленный индекс последней совпадающей группы захвата или «Нет», если ни "
"одна группа не была сопоставлена ​​вообще. Например, выражения ``(a)b``, ``((a)"
"(b))`` и ``((ab))`` будут иметь ``lastindex == 1``, ​​если они применяются к "
"строку ``'ab'``, а выражение ``(a)(b)`` будет иметь ``lastindex == 2``, если "
"оно применяется к той же строке."

#: ../../library/re.rst:1549
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"Имя последней совпадающей группы захвата или «Нет», если у группы не было "
"имени или если ни одна группа не была сопоставлена ​​вообще."

#: ../../library/re.rst:1555
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
":ref:`Объект регулярного выражения <re-objects>`, чей метод :meth:`~Pattern."
"match` или :meth:`~Pattern.search` создал этот экземпляр совпадения."

#: ../../library/re.rst:1561
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
"Строка передается в :meth:`~Pattern.match` или :meth:`~Pattern.search`."

#: ../../library/re.rst:1564
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
"Добавлена ​​поддержка :func:`copy.copy` и :func:`copy.deepcopy`. Объекты "
"совпадений считаются атомарными."

#: ../../library/re.rst:1572
msgid "Regular Expression Examples"
msgstr "Примеры регулярных выражений"

#: ../../library/re.rst:1576
msgid "Checking for a Pair"
msgstr "Проверка пары"

#: ../../library/re.rst:1578
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"В этом примере мы будем использовать следующую вспомогательную функцию для "
"более изящного отображения объектов соответствия:"

#: ../../library/re.rst:1581
msgid ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"
msgstr ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"

#: ../../library/re.rst:1586
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Предположим, вы пишете покерную программу, в которой рука игрока "
"представлена ​​в виде строки из 5 символов, где каждый символ представляет "
"карту: «a» — туз, «k» — король, «q» — дама, «j» — валет, «t» означает 10, а "
"от «2» до «9» представляет карту с этим значением."

#: ../../library/re.rst:1591
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"Чтобы проверить, является ли данная строка допустимой рукой, можно сделать "
"следующее:"

#: ../../library/re.rst:1593
msgid ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Valid.\n"
"\"<Match: 'akt5q', groups=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Invalid.\n"
">>> displaymatch(valid.match(\"akt\"))    # Invalid.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Valid.\n"
"\"<Match: '727ak', groups=()>\""
msgstr ""
">>> valid = re.compile(r\"^[a2-9tjqk]{5}$\")\n"
">>> displaymatch(valid.match(\"akt5q\"))  # Valid.\n"
"\"<Match: 'akt5q', groups=()>\"\n"
">>> displaymatch(valid.match(\"akt5e\"))  # Invalid.\n"
">>> displaymatch(valid.match(\"akt\"))    # Invalid.\n"
">>> displaymatch(valid.match(\"727ak\"))  # Valid.\n"
"\"<Match: '727ak', groups=()>\""

#: ../../library/re.rst:1601
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Последняя рука, «727ak», содержала пару или две карты одного достоинства. "
"Чтобы сопоставить это с регулярным выражением, можно использовать обратные "
"ссылки как таковые:"

#: ../../library/re.rst:1604
msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(pair.match(\"717ak\"))     # Pair of 7s.\n"
"\"<Match: '717', groups=('7',)>\"\n"
">>> displaymatch(pair.match(\"718ak\"))     # No pairs.\n"
">>> displaymatch(pair.match(\"354aa\"))     # Pair of aces.\n"
"\"<Match: '354aa', groups=('a',)>\""
msgstr ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> displaymatch(pair.match(\"717ak\"))     # Pair of 7s.\n"
"\"<Match: '717', groups=('7',)>\"\n"
">>> displaymatch(pair.match(\"718ak\"))     # No pairs.\n"
">>> displaymatch(pair.match(\"354aa\"))     # Pair of aces.\n"
"\"<Match: '354aa', groups=('a',)>\""

#: ../../library/re.rst:1611
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"Чтобы узнать, из какой карты состоит пара, можно использовать метод :meth:"
"`~Match.group` объекта match следующим образом:"

#: ../../library/re.rst:1614
msgid ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Error because re.match() returns None, which doesn't have a group() "
"method:\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"
msgstr ""
">>> pair = re.compile(r\".*(.).*\\1\")\n"
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Error because re.match() returns None, which doesn't have a group() "
"method:\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"

#: ../../library/re.rst:1630
msgid "Simulating scanf()"
msgstr "Имитация scanf()"

#: ../../library/re.rst:1634
msgid ""
"Python does not currently have an equivalent to :c:func:`!scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`!scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`!scanf` format tokens and regular "
"expressions."
msgstr ""
"Python в настоящее время не имеет эквивалента :c:func:`!scanf`. Регулярные "
"выражения, как правило, более мощны, но и более многословны, чем строки "
"формата :c:func:`!scanf`. В таблице ниже представлены некоторые более или "
"менее эквивалентные сопоставления между токенами формата :c:func:`!scanf` и "
"регулярными выражениями."

#: ../../library/re.rst:1641
msgid ":c:func:`!scanf` Token"
msgstr ":c:func:`!scanf` Token"

#: ../../library/re.rst:1641
msgid "Regular Expression"
msgstr "Регулярное выражение"

#: ../../library/re.rst:1643
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1645
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1645
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1647
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1647
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1649
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1649
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1651
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1651
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1653
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1653
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1655
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1655
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1657
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1657
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1659
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1659
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1662
msgid "To extract the filename and numbers from a string like ::"
msgstr "Чтобы извлечь имя файла и номера из строки типа:::"

#: ../../library/re.rst:1664
msgid "/usr/sbin/sendmail - 0 errors, 4 warnings"
msgstr "/usr/sbin/sendmail - 0 errors, 4 warnings"

#: ../../library/re.rst:1666
msgid "you would use a :c:func:`!scanf` format like ::"
msgstr "вы бы использовали формат :c:func:`!scanf`, например:::"

#: ../../library/re.rst:1668
msgid "%s - %d errors, %d warnings"
msgstr "%s - %d errors, %d warnings"

#: ../../library/re.rst:1670
msgid "The equivalent regular expression would be ::"
msgstr "Эквивалентным регулярным выражением будет:::"

#: ../../library/re.rst:1672
msgid "(\\S+) - (\\d+) errors, (\\d+) warnings"
msgstr "(\\S+) - (\\d+) ошибки, (\\d+) предупреждения"

#: ../../library/re.rst:1678
msgid "search() vs. match()"
msgstr "search() vs. match()"

#: ../../library/re.rst:1682
msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr ""
"Python предлагает различные примитивные операции, основанные на регулярных "
"выражениях:"

#: ../../library/re.rst:1684
msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr ":func:`re.match` проверяет совпадение только в начале строки"

#: ../../library/re.rst:1685
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ""
":func:`re.search` проверяет совпадение в любом месте строки (это то, что "
"Perl делает по умолчанию)"

#: ../../library/re.rst:1687
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ":func:`re.fullmatch` проверяет совпадение всей строки"

#: ../../library/re.rst:1692
msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"c\", \"abcdef\")   # Match\n"
"<re.Match object; span=(2, 3), match='c'>\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Match\n"
"<re.Match object; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # No match"
msgstr ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"c\", \"abcdef\")   # Match\n"
"<re.Match object; span=(2, 3), match='c'>\n"
">>> re.fullmatch(\"p.*n\", \"python\") # Match\n"
"<re.Match object; span=(0, 6), match='python'>\n"
">>> re.fullmatch(\"r.*n\", \"python\") # No match"

#: ../../library/re.rst:1699
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Регулярные выражения, начинающиеся с ``'^'``, можно использовать с :func:"
"`search` для ограничения совпадения в начале строки::"

#: ../../library/re.rst:1702
msgid ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"^c\", \"abcdef\")  # No match\n"
">>> re.search(\"^a\", \"abcdef\")  # Match\n"
"<re.Match object; span=(0, 1), match='a'>"
msgstr ""
">>> re.match(\"c\", \"abcdef\")    # No match\n"
">>> re.search(\"^c\", \"abcdef\")  # No match\n"
">>> re.search(\"^a\", \"abcdef\")  # Match\n"
"<re.Match object; span=(0, 1), match='a'>"

#: ../../library/re.rst:1707
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Однако обратите внимание, что в режиме :const:`MULTILINE` :func:`match` "
"соответствует только началу строки, тогда как использование :func:`search` с "
"регулярным выражением, начинающимся с ``'^'``, будет соответствовать в "
"начало каждой строки. ::"

#: ../../library/re.rst:1711
msgid ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE)  # No match\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE)  # Match\n"
"<re.Match object; span=(4, 5), match='X'>"
msgstr ""
">>> re.match(\"X\", \"A\\nB\\nX\", re.MULTILINE)  # No match\n"
">>> re.search(\"^X\", \"A\\nB\\nX\", re.MULTILINE)  # Match\n"
"<re.Match object; span=(4, 5), match='X'>"

#: ../../library/re.rst:1717
msgid "Making a Phonebook"
msgstr "Создание телефонной книги"

#: ../../library/re.rst:1719
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` разбивает строку на список, ограниченный переданным шаблоном. "
"Этот метод бесценен для преобразования текстовых данных в структуры данных, "
"которые можно легко читать и изменять с помощью Python, как показано в "
"следующем примере создания телефонной книги."

#: ../../library/re.rst:1724
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"Во-первых, вот входные данные. Обычно это может быть получено из файла, "
"здесь мы используем синтаксис строки в тройных кавычках."

#: ../../library/re.rst:1727
msgid ""
">>> text = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""
msgstr ""
">>> text = \"\"\"Ross McFluff: 834.345.1254 155 Elm Street\n"
"...\n"
"... Ronald Heathmore: 892.345.3428 436 Finley Avenue\n"
"... Frank Burger: 925.541.7625 662 South Dogwood Way\n"
"...\n"
"...\n"
"... Heather Albrecht: 548.326.4584 919 Park Place\"\"\""

#: ../../library/re.rst:1737
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Записи разделяются одной или несколькими символами новой строки. Теперь мы "
"преобразуем строку в список, где каждая непустая строка имеет собственную "
"запись:"

#: ../../library/re.rst:1740
msgid ""
">>> entries = re.split(\"\\n+\", text)\n"
">>> entries\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"
msgstr ""
">>> entries = re.split(\"\\n+\", text)\n"
">>> entries\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"

#: ../../library/re.rst:1750
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Наконец, разделите каждую запись на список с именем, фамилией, номером "
"телефона и адресом. Мы используем параметр maxsplit функции :func:split, "
"потому что в адресе есть пробелы, наш шаблон разделения:"

#: ../../library/re.rst:1754
msgid ""
">>> [re.split(\":? \", entry, 3) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"
msgstr ""
">>> [re.split(\":? \", entry, 3) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"

#: ../../library/re.rst:1763
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"Шаблон ``:?`` соответствует двоеточию после фамилии, поэтому он не "
"встречается в списке результатов. Используя maxsplit, равный 4, мы могли бы "
"отделить номер дома от названия улицы:"

#: ../../library/re.rst:1767
msgid ""
">>> [re.split(\":? \", entry, 4) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"
msgstr ""
">>> [re.split(\":? \", entry, 4) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"

#: ../../library/re.rst:1778
msgid "Text Munging"
msgstr "Разрушение текста"

#: ../../library/re.rst:1780
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` заменяет каждое вхождение шаблона строкой или результатом "
"функции. В этом примере показано использование :func:`sub` с функцией "
"«объединения» текста или рандомизации порядка всех символов в каждом слове "
"предложения, за исключением первого и последнего символов::"

#: ../../library/re.rst:1785
msgid ""
">>> def repl(m):\n"
"...     inner_word = list(m.group(2))\n"
"...     random.shuffle(inner_word)\n"
"...     return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Abdolmalek, please report your absences promptly.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"
msgstr ""
">>> def repl(m):\n"
"...     inner_word = list(m.group(2))\n"
"...     random.shuffle(inner_word)\n"
"...     return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
"...\n"
">>> text = \"Professor Abdolmalek, please report your absences promptly.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"

#: ../../library/re.rst:1798
msgid "Finding all Adverbs"
msgstr "Поиск всех наречий"

#: ../../library/re.rst:1800
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` соответствует *всем* вхождениям шаблона, а не только "
"первому, как это делает :func:`search`. Например, если автор хочет найти все "
"наречия в каком-то тексте, он может использовать :func:`findall` следующим "
"образом:"

#: ../../library/re.rst:1805
msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> re.findall(r\"\\w+ly\\b\", text)\n"
"['carefully', 'quickly']"
msgstr ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> re.findall(r\"\\w+ly\\b\", text)\n"
"['carefully', 'quickly']"

#: ../../library/re.rst:1811
msgid "Finding all Adverbs and their Positions"
msgstr "Нахождение всех наречий и их позиций"

#: ../../library/re.rst:1813
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :class:`~re.Match` "
"objects instead of strings.  Continuing with the previous example, if a "
"writer wanted to find all of the adverbs *and their positions* in some text, "
"they would use :func:`finditer` in the following manner::"
msgstr ""
"Если вам нужна дополнительная информация обо всех совпадениях шаблона, а не "
"о совпавшем тексте, полезно использовать :func:`finditer`, поскольку он "
"предоставляет объекты :class:`~re.Match` вместо строк. Продолжая предыдущий "
"пример, если бы автор хотел найти все наречия *и их позиции* в каком-то "
"тексте, он бы использовал :func:`finditer` следующим образом:"

#: ../../library/re.rst:1819
msgid ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> for m in re.finditer(r\"\\w+ly\\b\", text):\n"
"...     print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"07-16: carefully\n"
"40-47: quickly"
msgstr ""
">>> text = \"He was carefully disguised but captured quickly by police.\"\n"
">>> for m in re.finditer(r\"\\w+ly\\b\", text):\n"
"...     print('%02d-%02d: %s' % (m.start(), m.end(), m.group(0)))\n"
"07-16: carefully\n"
"40-47: quickly"

#: ../../library/re.rst:1827
msgid "Raw String Notation"
msgstr "Обозначение необработанной строки"

#: ../../library/re.rst:1829
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Необработанная строковая нотация (``r\"text\"``) сохраняет работоспособность "
"регулярных выражений. Без него к каждой обратной косой черте (``'\\'``) в "
"регулярном выражении нужно было бы добавлять еще один префикс, чтобы "
"избежать ее. Например, две следующие строки кода функционально идентичны:"

#: ../../library/re.rst:1834
msgid ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>"
msgstr ""
">>> re.match(r\"\\W(.)\\1\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>\n"
">>> re.match(\"\\\\W(.)\\\\1\\\\W\", \" ff \")\n"
"<re.Match object; span=(0, 4), match=' ff '>"

#: ../../library/re.rst:1839
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"Если кто-то хочет сопоставить буквальную обратную косую черту, ее необходимо "
"экранировать в регулярном выражении. При записи необработанных строк это "
"означает ``r\"\\\\\"``. Без нотации необработанной строки необходимо "
"использовать ``\"\\\\\\\\\"``, делая следующие строки кода функционально "
"идентичными:"

#: ../../library/re.rst:1844
msgid ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>"
msgstr ""
">>> re.match(r\"\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>\n"
">>> re.match(\"\\\\\\\\\", r\"\\\\\")\n"
"<re.Match object; span=(0, 1), match='\\\\'>"

#: ../../library/re.rst:1851
msgid "Writing a Tokenizer"
msgstr "Написание токенизатора"

#: ../../library/re.rst:1853
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`Токенизатор или сканер <https://en.wikipedia.org/wiki/Lexical_anasis>`_ "
"анализирует строку для классификации групп символов. Это полезный первый шаг "
"в написании компилятора или интерпретатора."

#: ../../library/re.rst:1857
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"Текстовые категории задаются с помощью регулярных выражений. Техника состоит "
"в том, чтобы объединить их в одно главное регулярное выражение и перебрать "
"последовательные совпадения:"

#: ../../library/re.rst:1861
msgid ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Integer or decimal number\n"
"        ('ASSIGN',   r':='),           # Assignment operator\n"
"        ('END',      r';'),            # Statement terminator\n"
"        ('ID',       r'[A-Za-z]+'),    # Identifiers\n"
"        ('OP',       r'[+\\-*/]'),      # Arithmetic operators\n"
"        ('NEWLINE',  r'\\n'),           # Line endings\n"
"        ('SKIP',     r'[ \\t]+'),       # Skip over spaces and tabs\n"
"        ('MISMATCH', r'.'),            # Any other character\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line {line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"
msgstr ""
"from typing import NamedTuple\n"
"import re\n"
"\n"
"class Token(NamedTuple):\n"
"    type: str\n"
"    value: str\n"
"    line: int\n"
"    column: int\n"
"\n"
"def tokenize(code):\n"
"    keywords = {'IF', 'THEN', 'ENDIF', 'FOR', 'NEXT', 'GOSUB', 'RETURN'}\n"
"    token_specification = [\n"
"        ('NUMBER',   r'\\d+(\\.\\d*)?'),  # Integer or decimal number\n"
"        ('ASSIGN',   r':='),           # Assignment operator\n"
"        ('END',      r';'),            # Statement terminator\n"
"        ('ID',       r'[A-Za-z]+'),    # Identifiers\n"
"        ('OP',       r'[+\\-*/]'),      # Arithmetic operators\n"
"        ('NEWLINE',  r'\\n'),           # Line endings\n"
"        ('SKIP',     r'[ \\t]+'),       # Skip over spaces and tabs\n"
"        ('MISMATCH', r'.'),            # Any other character\n"
"    ]\n"
"    tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in "
"token_specification)\n"
"    line_num = 1\n"
"    line_start = 0\n"
"    for mo in re.finditer(tok_regex, code):\n"
"        kind = mo.lastgroup\n"
"        value = mo.group()\n"
"        column = mo.start() - line_start\n"
"        if kind == 'NUMBER':\n"
"            value = float(value) if '.' in value else int(value)\n"
"        elif kind == 'ID' and value in keywords:\n"
"            kind = value\n"
"        elif kind == 'NEWLINE':\n"
"            line_start = mo.end()\n"
"            line_num += 1\n"
"            continue\n"
"        elif kind == 'SKIP':\n"
"            continue\n"
"        elif kind == 'MISMATCH':\n"
"            raise RuntimeError(f'{value!r} unexpected on line {line_num}')\n"
"        yield Token(kind, value, line_num, column)\n"
"\n"
"statements = '''\n"
"    IF quantity THEN\n"
"        total := total + price * quantity;\n"
"        tax := price * 0.05;\n"
"    ENDIF;\n"
"'''\n"
"\n"
"for token in tokenize(statements):\n"
"    print(token)"

#: ../../library/re.rst:1913
msgid "The tokenizer produces the following output::"
msgstr "Токенизатор выдает следующий результат:"

#: ../../library/re.rst:1915
msgid ""
"Token(type='IF', value='IF', line=2, column=4)\n"
"Token(type='ID', value='quantity', line=2, column=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(type='ID', value='total', line=3, column=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(type='ID', value='total', line=3, column=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(type='ID', value='price', line=3, column=25)\n"
"Token(type='OP', value='*', line=3, column=31)\n"
"Token(type='ID', value='quantity', line=3, column=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', line=4, column=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(type='ID', value='price', line=4, column=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(type='NUMBER', value=0.05, line=4, column=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(type='END', value=';', line=5, column=9)"
msgstr ""
"Token(type='IF', value='IF', line=2, column=4)\n"
"Token(type='ID', value='quantity', line=2, column=7)\n"
"Token(type='THEN', value='THEN', line=2, column=16)\n"
"Token(type='ID', value='total', line=3, column=8)\n"
"Token(type='ASSIGN', value=':=', line=3, column=14)\n"
"Token(type='ID', value='total', line=3, column=17)\n"
"Token(type='OP', value='+', line=3, column=23)\n"
"Token(type='ID', value='price', line=3, column=25)\n"
"Token(type='OP', value='*', line=3, column=31)\n"
"Token(type='ID', value='quantity', line=3, column=33)\n"
"Token(type='END', value=';', line=3, column=41)\n"
"Token(type='ID', value='tax', line=4, column=8)\n"
"Token(type='ASSIGN', value=':=', line=4, column=12)\n"
"Token(type='ID', value='price', line=4, column=15)\n"
"Token(type='OP', value='*', line=4, column=21)\n"
"Token(type='NUMBER', value=0.05, line=4, column=23)\n"
"Token(type='END', value=';', line=4, column=27)\n"
"Token(type='ENDIF', value='ENDIF', line=5, column=4)\n"
"Token(type='END', value=';', line=5, column=9)"

#: ../../library/re.rst:1936
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Фридл, Джеффри. Освоение регулярных выражений. 3-е изд., O'Reilly Media, "
"2009. Третье издание книги больше не рассматривает Python вообще, но в "
"первом издании очень подробно описано написание хороших шаблонов регулярных "
"выражений."

#: ../../library/re.rst:99
msgid ". (dot)"
msgstr ". (точка)"

#: ../../library/re.rst:99 ../../library/re.rst:106 ../../library/re.rst:112
#: ../../library/re.rst:123 ../../library/re.rst:130 ../../library/re.rst:137
#: ../../library/re.rst:143 ../../library/re.rst:157 ../../library/re.rst:181
#: ../../library/re.rst:220 ../../library/re.rst:235 ../../library/re.rst:244
#: ../../library/re.rst:257 ../../library/re.rst:262 ../../library/re.rst:295
#: ../../library/re.rst:308 ../../library/re.rst:318 ../../library/re.rst:350
#: ../../library/re.rst:405 ../../library/re.rst:437 ../../library/re.rst:443
#: ../../library/re.rst:448 ../../library/re.rst:455 ../../library/re.rst:462
#: ../../library/re.rst:489 ../../library/re.rst:499 ../../library/re.rst:522
#: ../../library/re.rst:534 ../../library/re.rst:539 ../../library/re.rst:561
#: ../../library/re.rst:581 ../../library/re.rst:597 ../../library/re.rst:605
#: ../../library/re.rst:619 ../../library/re.rst:627 ../../library/re.rst:644
#: ../../library/re.rst:658 ../../library/re.rst:663 ../../library/re.rst:854
#: ../../library/re.rst:1085
msgid "in regular expressions"
msgstr "в регулярных выражениях"

#: ../../library/re.rst:106 ../../library/re.rst:262
msgid "^ (caret)"
msgstr "^ (caret)"

#: ../../library/re.rst:112
msgid "$ (dollar)"
msgstr "$ (доллар)"

#: ../../library/re.rst:123
msgid "* (asterisk)"
msgstr "* (звёздочка)"

#: ../../library/re.rst:130
msgid "+ (plus)"
msgstr "+ (плюс)"

#: ../../library/re.rst:137
msgid "? (question mark)"
msgstr "? (знак вопроса)"

#: ../../library/re.rst:143
msgid "*?"
msgstr "*?"

#: ../../library/re.rst:143
msgid "+?"
msgstr "+?"

#: ../../library/re.rst:143
msgid "??"
msgstr "??"

#: ../../library/re.rst:157
msgid "*+"
msgstr "*+"

#: ../../library/re.rst:157
msgid "++"
msgstr "++"

#: ../../library/re.rst:157
msgid "?+"
msgstr "?+"

#: ../../library/re.rst:181
msgid "{} (curly brackets)"
msgstr "{} (фигурные скобки)"

#: ../../library/re.rst:220 ../../library/re.rst:257 ../../library/re.rst:522
msgid "\\ (backslash)"
msgstr "\\ (обратная косая черта)"

#: ../../library/re.rst:235
msgid "[] (square brackets)"
msgstr "[] (квадратные скобки)"

#: ../../library/re.rst:244
msgid "- (minus)"
msgstr "- (минус)"

#: ../../library/re.rst:295
msgid "| (vertical bar)"
msgstr "| (вертикальная полоса)"

#: ../../library/re.rst:308
msgid "() (parentheses)"
msgstr "() (parentheses)"

#: ../../library/re.rst:318
msgid "(?"
msgstr "(?"

#: ../../library/re.rst:350
msgid "(?:"
msgstr "(?:"

#: ../../library/re.rst:405
msgid "(?P<"
msgstr "(?P<"

#: ../../library/re.rst:437
msgid "(?P="
msgstr "(?P="

#: ../../library/re.rst:443
msgid "(?#"
msgstr "(?#"

#: ../../library/re.rst:448
msgid "(?="
msgstr "(?="

#: ../../library/re.rst:455
msgid "(?!"
msgstr "(?!"

#: ../../library/re.rst:462
msgid "(?<="
msgstr "(?<="

#: ../../library/re.rst:489
msgid "(?<!"
msgstr "(?<!"

#: ../../library/re.rst:499
msgid "(?("
msgstr "(?("

#: ../../library/re.rst:534
msgid "\\A"
msgstr "\\A"

#: ../../library/re.rst:539 ../../library/re.rst:663
msgid "\\b"
msgstr "\\b"

#: ../../library/re.rst:561
msgid "\\B"
msgstr "\\B"

#: ../../library/re.rst:581
msgid "\\d"
msgstr "\\d"

#: ../../library/re.rst:597
msgid "\\D"
msgstr "\\D"

#: ../../library/re.rst:605
msgid "\\s"
msgstr "\\s"

#: ../../library/re.rst:619
msgid "\\S"
msgstr "\\S"

#: ../../library/re.rst:627
msgid "\\w"
msgstr "\\w"

#: ../../library/re.rst:644
msgid "\\W"
msgstr "\\W"

#: ../../library/re.rst:658
msgid "\\Z"
msgstr "\\Z"

#: ../../library/re.rst:663
msgid "\\a"
msgstr "\\a"

#: ../../library/re.rst:663
msgid "\\f"
msgstr "\\f"

#: ../../library/re.rst:663
msgid "\\n"
msgstr "\\n"

#: ../../library/re.rst:663
msgid "\\r"
msgstr "\\r"

#: ../../library/re.rst:663
msgid "\\t"
msgstr "\\t"

#: ../../library/re.rst:663
msgid "\\u"
msgstr "\\u"

#: ../../library/re.rst:663
msgid "\\U"
msgstr "\\U"

#: ../../library/re.rst:663
msgid "\\v"
msgstr "\\v"

#: ../../library/re.rst:663
msgid "\\x"
msgstr "\\x"

#: ../../library/re.rst:663
msgid "\\\\"
msgstr "\\\\"

#: ../../library/re.rst:854
msgid "# (hash)"
msgstr "# (hash)"

#: ../../library/re.rst:1085
msgid "\\g"
msgstr "\\g"

#: ../../library/re.rst:1632
msgid "scanf (C function)"
msgstr "scanf (C function)"
