# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Отладчик Python"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**Исходный код:** :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
"Модуль :mod:`pdb` определяет интерактивный отладчик исходного кода программ "
"Python. Он поддерживает установку (условных) точек останова и пошаговое "
"выполнение на уровне строки исходного кода, проверку кадров стека, листинг "
"исходного кода и оценку произвольного кода Python в контексте любого кадра "
"стека. Он также поддерживает посмертную отладку и может вызываться под "
"управлением программы."

#: ../../library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the class :class:"
"`Pdb`. This is currently undocumented but easily understood by reading the "
"source.  The extension interface uses the modules :mod:`bdb` and :mod:`cmd`."
msgstr ""
"Отладчик является расширяемым — фактически он определен как класс :class:"
"`Pdb`. В настоящее время это недокументировано, но легко понять, прочитав "
"исходный код. Интерфейс расширения использует модули :mod:`bdb` и :mod:`cmd`."

#: ../../library/pdb.rst:34
msgid "Module :mod:`faulthandler`"
msgstr "Модуль :mod:`faulthandler`"

#: ../../library/pdb.rst:33
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr ""
"Используется для явного сброса обратных трассировок Python, при ошибке, "
"после тайм-аута или по сигналу пользователя."

#: ../../library/pdb.rst:36
msgid "Module :mod:`traceback`"
msgstr "Модуль :mod:`traceback`"

#: ../../library/pdb.rst:37
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr ""
"Стандартный интерфейс для извлечения, форматирования и печати трассировок "
"стека программ Python."

#: ../../library/pdb.rst:39
msgid ""
"The debugger's prompt is ``(Pdb)``. Typical usage to run a program under "
"control of the debugger is::"
msgstr ""

#: ../../library/pdb.rst:53
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"Заполнение табуляции через модуль :mod:`readline` доступно для команд и "
"аргументов команды, например, текущие глобальные и локальные имена "
"предлагаются в качестве аргументов команды ``p``."

#: ../../library/pdb.rst:58
msgid ""
":file:`pdb.py` can also be invoked as a script to debug other scripts.  For "
"example::"
msgstr ""

#: ../../library/pdb.rst:63
msgid ""
"When invoked as a script, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""

#: ../../library/pdb.rst:69
msgid ""
":file:`pdb.py` now accepts a ``-c`` option that executes commands as if "
"given in a :file:`.pdbrc` file, see :ref:`debugger-commands`."
msgstr ""

#: ../../library/pdb.rst:73
msgid ""
":file:`pdb.py` now accepts a ``-m`` option that execute modules similar to "
"the way ``python -m`` does. As with a script, the debugger will pause "
"execution just before the first line of the module."
msgstr ""

#: ../../library/pdb.rst:79
msgid "The typical usage to break into the debugger is to insert::"
msgstr "Типичное использование для взлома отладчика — это вставка::"

#: ../../library/pdb.rst:83
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"в том месте, где вы хотите взломать отладчик, а затем запустить программу. "
"Затем вы можете выполнить код, следующий за этим оператором, и продолжить "
"работу без отладчика, используя команду :pdbcmd:`continue`."

#: ../../library/pdb.rst:87
msgid ""
"The built-in :func:`breakpoint()`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""

#: ../../library/pdb.rst:91
msgid "The typical usage to inspect a crashed program is::"
msgstr "Типичное использование для проверки аварийной программы:"

#: ../../library/pdb.rst:109
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr ""
"Модуль определяет следующие функции; каждый входит в отладчик немного по-"
"своему:"

#: ../../library/pdb.rst:114
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-in :func:"
"`exec` or :func:`eval` functions.)"
msgstr ""
"Выполните *оператор* (заданный в виде строки или объекта кода) под "
"управлением отладчика. Приглашение отладчика появляется перед выполнением "
"любого кода; вы можете установить точки останова и ввести :pdbcmd:"
"`continue`, или вы можете пошагово выполнить оператор, используя :pdbcmd:"
"`step` или :pdbcmd:`next` (все эти команды описаны ниже). Необязательные "
"аргументы *globals* и *locals* указывают среду, в которой выполняется код; "
"по умолчанию используется словарь модуля :mod:`__main__`. (См. объяснение "
"встроенных функций :func:`exec` или :func:`eval`.)"

#: ../../library/pdb.rst:126
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"*expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"Оцените *выражение* (заданное в виде строки или объекта кода) под "
"управлением отладчика. Когда :func:`runeval` возвращается, она возвращает "
"значение *выражения*. В остальном эта функция аналогична :func:`run`."

#: ../../library/pdb.rst:133
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"Вызовите *функцию* (объект функции или метода, а не строку) с заданными "
"аргументами. Когда :func:`runcall` возвращается, она возвращает всё, что "
"вернул вызов функции. Приглашение отладчика появляется сразу после ввода "
"функции."

#: ../../library/pdb.rst:141
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins."
msgstr ""
"Войдите в отладчик в кадре стека вызовов. Это полезно для жесткого "
"кодирования точки останова в заданной точке программы, даже если код иначе "
"не отлаживается (например, когда утверждение не выполняется). Если задано, "
"*header* выводится на консоль непосредственно перед началом отладки."

#: ../../library/pdb.rst:146
msgid "The keyword-only argument *header*."
msgstr "Аргумент, содержащий только ключевые слова *header*."

#: ../../library/pdb.rst:152
msgid ""
"Enter post-mortem debugging of the given *traceback* object.  If no "
"*traceback* is given, it uses the one of the exception that is currently "
"being handled (an exception must be being handled if the default is to be "
"used)."
msgstr ""
"Введите посмертную отладку данного объекта *traceback*. Если *traceback* не "
"указан, используется то исключение, которое обрабатывается в данный момент "
"(исключение должно обрабатываться, если используется значение по умолчанию)."

#: ../../library/pdb.rst:160
msgid ""
"Enter post-mortem debugging of the traceback found in :data:`sys."
"last_traceback`."
msgstr ""
"Введите посмертную отладку обратной трассировки, найденной в :data:`sys."
"last_traceback`."

#: ../../library/pdb.rst:164
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"Функции ``run*`` и :func:`set_trace` являются псевдонимами для создания "
"экземпляра класса :class:`Pdb` и вызова одноименного метода. Если вы хотите "
"получить доступ к дополнительным функциям, вам придется сделать это "
"самостоятельно:"

#: ../../library/pdb.rst:171
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` — это класс отладчика."

#: ../../library/pdb.rst:173
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"Аргументы *completekey*, *stdin* и *stdout* передаются базовому классу :"
"class:`cmd.Cmd`; смотри описание там."

#: ../../library/pdb.rst:176
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr ""
"Аргумент *skip*, если он задан, должен быть итерацией шаблонов имен модулей "
"в стиле glob. Отладчик не будет входить в кадры, созданные в модуле, "
"соответствующем одному из этих шаблонов. [1]_"

#: ../../library/pdb.rst:180
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give a :pdbcmd:"
"`continue` command. This allows you to break into the debugger again by "
"pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT handler, "
"set *nosigint* to true."
msgstr ""
"По умолчанию Pdb устанавливает обработчик сигнала SIGINT (который "
"отправляется, когда пользователь нажимает :kbd:`Ctrl-C` на консоли), когда "
"вы даете команду :pdbcmd:`continue`. Это позволит вам снова войти в "
"отладчик, нажав :kbd:`Ctrl-C`. Если вы хотите, чтобы Pdb не касался "
"обработчика SIGINT, установите для *nosigint* значение true."

#: ../../library/pdb.rst:185
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load ."
"pdbrc files from the filesystem."
msgstr ""
"Аргумент *readrc* по умолчанию имеет значение true и определяет, будет ли "
"Pdb загружать файлы .pdbrc из файловой системы."

#: ../../library/pdb.rst:188
msgid "Example call to enable tracing with *skip*::"
msgstr "Пример вызова для включения трассировки с помощью *skip*::"

#: ../../library/pdb.rst:192
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr "Вызывает событие аудита <auditing>``pdb.Pdb`` без аргументов."

#: ../../library/pdb.rst:194
msgid "The *skip* argument."
msgstr ""

#: ../../library/pdb.rst:197
msgid ""
"The *nosigint* argument.  Previously, a SIGINT handler was never set by Pdb."
msgstr ""

#: ../../library/pdb.rst:201
msgid "The *readrc* argument."
msgstr "Аргумент *readrc*."

#: ../../library/pdb.rst:209
msgid "See the documentation for the functions explained above."
msgstr "См. документацию по функциям, описанным выше."

#: ../../library/pdb.rst:215
msgid "Debugger Commands"
msgstr "Команды отладчика"

#: ../../library/pdb.rst:217
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"Ниже перечислены команды, распознаваемые отладчиком. Большинство команд "
"можно сократить до одной или двух букв, как указано; например, ``h(elp)`` "
"означает, что для ввода команды справки можно использовать либо ``h``, либо "
"``help`` (но не ``he`` или ``help``, ни ``H `` или ``Помощь`` или ``HELP``). "
"Аргументы команд должны быть разделены пробелами (пробелами или "
"табуляциями). Необязательные аргументы заключаются в квадратные скобки "
"(``[]``) в синтаксисе команды; квадратные скобки печатать нельзя. "
"Альтернативы в синтаксисе команды разделяются вертикальной чертой (``|``)."

#: ../../library/pdb.rst:226
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"Ввод пустой строки повторяет последнюю введенную команду. Исключение: если "
"последней командой была команда :pdbcmd:`list`, будут перечислены следующие "
"11 строк."

#: ../../library/pdb.rst:229
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"Команды, которые не распознает отладчик, считаются операторами Python и "
"выполняются в контексте отлаживаемой программы. Операторы Python также могут "
"иметь префикс восклицательного знака (``!``). Это мощный способ проверки "
"отлаживаемой программы; можно даже изменить переменную или вызвать функцию. "
"Когда в таком операторе возникает исключение, имя исключения выводится, но "
"состояние отладчика не изменяется."

#: ../../library/pdb.rst:237
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"Отладчик поддерживает :ref:`aliases <debugger-aliases>`. Псевдонимы могут "
"иметь параметры, которые обеспечивают определенный уровень адаптации к "
"исследуемому контексту."

#: ../../library/pdb.rst:241
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"Несколько команд можно ввести в одной строке, разделив их ``;;``. (Один ``;"
"`` не используется, поскольку он является разделителем нескольких команд в "
"строке, передаваемой синтаксическому анализатору Python.) Для разделения "
"команд не применяется никакой интеллект; ввод разбивается по первой паре ``;;"
"``, даже если она находится в середине строки в кавычках. Обходным решением "
"для строк с двойными точками с запятой является использование неявной "
"конкатенации строк ``';'';'`` или ``\";\"\";\"``."

#: ../../library/pdb.rst:252
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read in and executed as if it had been typed at the "
"debugger prompt.  This is particularly useful for aliases.  If both files "
"exist, the one in the home directory is read first and aliases defined there "
"can be overridden by the local file."
msgstr ""

#: ../../library/pdb.rst:258
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as :"
"pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` теперь может содержать команды, продолжающие отладку, "
"например :pdbcmd:`continue` или :pdbcmd:`next`. Раньше эти команды не имели "
"никакого эффекта."

#: ../../library/pdb.rst:266
msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"Без аргументов вывести список доступных команд. Используя *команду* в "
"качестве аргумента, выведите справку по этой команде. ``help pdb`` "
"отображает полную документацию (строку документации модуля :mod:`pdb`). "
"Поскольку аргумент *command* должен быть идентификатором, для получения "
"справки по команде ``!`` необходимо ввести ``help exec``."

#: ../../library/pdb.rst:274
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"indicates the current frame, which determines the context of most commands."
msgstr ""

#: ../../library/pdb.rst:279
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"Переместить текущий уровень *count* кадров (один по умолчанию) вниз в "
"трассировке стека (к более новому кадру)."

#: ../../library/pdb.rst:284
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"Переместить текущий уровень *count* кадров (один по умолчанию) вверх в "
"трассировке стека (к более старому кадру)."

#: ../../library/pdb.rst:289
msgid ""
"With a *lineno* argument, set a break there in the current file.  With a "
"*function* argument, set a break at the first executable statement within "
"that function.  The line number may be prefixed with a filename and a colon, "
"to specify a breakpoint in another file (probably one that hasn't been "
"loaded yet).  The file is searched on :data:`sys.path`.  Note that each "
"breakpoint is assigned a number to which all the other breakpoint commands "
"refer."
msgstr ""
"С аргументом *lineno* установите разрыв в текущем файле. С помощью аргумента "
"*function* установите разрыв на первом исполняемом операторе внутри этой "
"функции. Перед номером строки может стоять имя файла и двоеточие, чтобы "
"указать точку останова в другом файле (возможно, еще не загруженном). Поиск "
"файла осуществляется по адресу :data:`sys.path`. Обратите внимание, что "
"каждой точке останова присвоен номер, к которому относятся все остальные "
"команды точки останова."

#: ../../library/pdb.rst:296
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr ""
"Если присутствует второй аргумент, это выражение, которое должно иметь "
"значение true, прежде чем будет соблюдена точка останова."

#: ../../library/pdb.rst:299
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"Без аргумента перечислите все прерывания, включая для каждой точки останова, "
"количество попаданий в эту точку останова, текущий счетчик игнорирования и "
"связанное с ним условие, если таковое имеется."

#: ../../library/pdb.rst:305
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"Временная точка останова, которая автоматически удаляется при первом "
"нажатии. Аргументы те же, что и для :pdbcmd:`break`."

#: ../../library/pdb.rst:310
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"С аргументом *filename:lineno* очистите все точки останова в этой строке. С "
"помощью списка номеров точек останова, разделенных пробелами, очистите эти "
"точки останова. Без споров удалите все разрывы (но сначала запросите "
"подтверждение)."

#: ../../library/pdb.rst:316
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"Отключите точки останова, заданные в виде списка номеров точек останова, "
"разделенных пробелами. Отключение точки останова означает, что она не может "
"привести к остановке выполнения программы, но в отличие от очистки точки "
"останова она остается в списке точек останова и может быть (повторно) "
"включена."

#: ../../library/pdb.rst:323
msgid "Enable the breakpoints specified."
msgstr "Включите указанные точки останова."

#: ../../library/pdb.rst:327
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the "
"ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"Установите счетчик игнорирования для данного номера точки останова. Если "
"*count* опущено, счетчик игнорирования устанавливается равным 0. Точка "
"останова становится активной, когда счетчик игнорирования равен нулю. Если "
"значение не равно нулю, *count* уменьшается каждый раз при достижении точки "
"останова, при этом точка останова не отключается, а любое связанное с ней "
"условие оценивается как истинное."

#: ../../library/pdb.rst:335
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"Установите новое *условие* для точки останова, выражение, которое должно "
"иметь значение true, прежде чем точка останова будет соблюдена. Если "
"*условие* отсутствует, любое существующее условие удаляется; т.е. точка "
"останова становится безусловной."

#: ../../library/pdb.rst:341
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"Укажите список команд для точки останова с номером *bpnumber*. Сами команды "
"появляются в следующих строках. Введите строку, содержащую только ``end``, "
"чтобы завершить выполнение команд. Пример::"

#: ../../library/pdb.rst:350
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"Чтобы удалить все команды из точки останова, введите ``commands`` и сразу же "
"добавьте ``end``; то есть не давать никаких команд."

#: ../../library/pdb.rst:353
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr ""
"Без аргумента *bpnumber* ``команды`` относятся к последней установленной "
"точке останова."

#: ../../library/pdb.rst:355
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"Вы можете использовать команды точки останова, чтобы снова запустить "
"программу. Просто используйте команду :pdbcmd:`continue`, или :pdbcmd:"
"`step`, или любую другую команду, которая возобновляет выполнение."

#: ../../library/pdb.rst:359
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, :"
"pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, :pdbcmd:"
"`quit` and their abbreviations) terminates the command list (as if that "
"command was immediately followed by end). This is because any time you "
"resume execution (even with a simple next or step), you may encounter "
"another breakpoint—which could have its own command list, leading to "
"ambiguities about which list to execute."
msgstr ""
"Указание любой команды, возобновляющей выполнение (в настоящее время :pdbcmd:"
"`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:"
"`jump`, :pdbcmd:`quit` и их сокращения) завершает список команд (как будто "
"за этой командой сразу следует конец). Это связано с тем, что каждый раз, "
"когда вы возобновляете выполнение (даже с помощью простого следующего шага "
"или шага), вы можете столкнуться с другой точкой останова, которая может "
"иметь свой собственный список команд, что приводит к неопределенности "
"относительно того, какой список выполнять."

#: ../../library/pdb.rst:368
msgid ""
"If you use the ``silent`` command in the command list, the usual message "
"about stopping at a breakpoint is not printed.  This may be desirable for "
"breakpoints that are to print a specific message and then continue.  If none "
"of the other commands print anything, you see no sign that the breakpoint "
"was reached."
msgstr ""
"Если вы используете команду ``silent`` в списке команд, обычное сообщение об "
"остановке в точке останова не выводится. Это может быть желательно для точек "
"останова, которые должны вывести определенное сообщение и затем продолжить. "
"Если ни одна из других команд ничего не выводит, вы не увидите никаких "
"признаков достижения точки останова."

#: ../../library/pdb.rst:375
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"Выполнить текущую строку, остановиться при первом возможном случае (либо в "
"вызываемой функции, либо на следующей строке текущей функции)."

#: ../../library/pdb.rst:380
msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"Продолжайте выполнение до тех пор, пока не будет достигнута следующая строка "
"в текущей функции или она не вернется. (Разница между :pdbcmd:`next` и :"
"pdbcmd:`step` заключается в том, что :pdbcmd:`step` останавливается внутри "
"вызываемой функции, тогда как :pdbcmd:`next` выполняет вызванные функции на "
"(почти) полной скорости, только останавливаясь на следующей строке текущей "
"функции.)"

#: ../../library/pdb.rst:388
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr ""
"Без аргумента продолжить выполнение до тех пор, пока не будет достигнута "
"строка с номером, превышающим текущий."

#: ../../library/pdb.rst:391
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""
"С помощью *lineno* продолжайте выполнение до тех пор, пока не будет "
"достигнута строка с номером, большим или равным *lineno*. В обоих случаях "
"также остановитесь, когда вернется текущий кадр."

#: ../../library/pdb.rst:395
msgid "Allow giving an explicit line number."
msgstr "Разрешить явно указывать номер строки."

#: ../../library/pdb.rst:400
msgid "Continue execution until the current function returns."
msgstr "Продолжайте выполнение до тех пор, пока текущая функция не вернется."

#: ../../library/pdb.rst:404
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr ""
"Продолжайте выполнение, останавливайтесь только при обнаружении точки "
"останова."

#: ../../library/pdb.rst:408
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"Установите следующую строку, которая будет выполнена. Доступно только в "
"самом нижнем кадре. Это позволяет вам вернуться назад и снова выполнить код "
"или перейти вперед, чтобы пропустить код, который вы не хотите запускать."

#: ../../library/pdb.rst:412
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of a :"
"keyword:`finally` clause."
msgstr ""
"Следует отметить, что не все переходы разрешены - например, невозможно "
"перейти в середину цикла :keyword:`for` или выйти из предложения :keyword:"
"`finally`."

#: ../../library/pdb.rst:418
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"Вывести исходный код текущего файла. Без аргументов перечислите 11 строк "
"вокруг текущей строки или продолжите предыдущий листинг. С аргументом ``.`` "
"перечислите 11 строк вокруг текущей строки. С одним аргументом перечислите "
"11 строк вокруг этой строки. С двумя аргументами перечислите заданный "
"диапазон; если второй аргумент меньше первого, он интерпретируется как "
"счетчик."

#: ../../library/pdb.rst:424
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"Текущая строка в текущем кадре обозначается ``->``. Если исключение "
"отлаживается, строка, в которой исключение было первоначально вызвано или "
"распространено, обозначается ``>>``, если она отличается от текущей строки."

#: ../../library/pdb.rst:429
msgid "The ``>>`` marker."
msgstr ""

#: ../../library/pdb.rst:434
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"Перечислите весь исходный код для текущей функции или фрейма. Интересные "
"строки отмечены как :pdbcmd:`list`."

#: ../../library/pdb.rst:441
msgid "Print the argument list of the current function."
msgstr ""

#: ../../library/pdb.rst:445
msgid "Evaluate *expression* in the current context and print its value."
msgstr "Оцените *выражение* в текущем контексте и выведите его значение."

#: ../../library/pdb.rst:449
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"``print()`` также можно использовать, но это не команда отладчика — она "
"выполняет функцию Python :func:`print`."

#: ../../library/pdb.rst:455
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""
"Аналогично команде :pdbcmd:`p`, за исключением того, что значение "
"*expression* красиво печатается с использованием модуля :mod:`pprint`."

#: ../../library/pdb.rst:460
msgid "Print the type of *expression*."
msgstr "Выведите тип *выражения*."

#: ../../library/pdb.rst:464
msgid "Try to get source code of *expression* and display it."
msgstr "Попробуйте получить исходный код *выражения* и отобразить его."

#: ../../library/pdb.rst:470
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr ""
"Отображать значение *выражения*, если оно изменилось, каждый раз, когда "
"выполнение останавливается в текущем кадре."

#: ../../library/pdb.rst:473
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr ""
"Без *выражения* выводит список всех выражений отображения для текущего кадра."

#: ../../library/pdb.rst:479
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr ""
"Больше не отображать *выражение* в текущем кадре. Без *выражения* очистить "
"все выражения отображения для текущего кадра."

#: ../../library/pdb.rst:486
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) whose global "
"namespace contains all the (global and local) names found in the current "
"scope."
msgstr ""
"Запустите интерактивный интерпретатор (используя модуль :mod:`code`), "
"глобальное пространство имен которого содержит все имена (глобальные и "
"локальные), найденные в текущей области."

#: ../../library/pdb.rst:496
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, and so on, while ``%*`` is replaced by all the parameters. "
"If *command* is omitted, the current alias for *name* is shown. If no "
"arguments are given, all aliases are listed."
msgstr ""
"Создайте псевдоним с именем *имя*, который выполняет *команду*. *Команду* "
"нельзя заключать в кавычки. Заменяемые параметры могут обозначаться ``%1``, "
"``%2`` и т. д., а ``%*`` заменяется всеми параметрами. Если *команда* "
"опущена, отображается текущий псевдоним для *имя*. Если аргументы не "
"указаны, отображаются все псевдонимы."

#: ../../library/pdb.rst:502
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"Псевдонимы могут быть вложенными и содержать все, что можно правильно ввести "
"в командной строке pdb. Обратите внимание, что внутренние команды pdb "
"*могут* быть переопределены псевдонимами. Такая команда затем скрывается до "
"тех пор, пока псевдоним не будет удален. Псевдоним рекурсивно применяется к "
"первому слову командной строки; все остальные слова в строке остаются в "
"покое."

#: ../../library/pdb.rst:508
msgid ""
"As an example, here are two useful aliases (especially when placed in the :"
"file:`.pdbrc` file)::"
msgstr ""
"В качестве примера приведем два полезных псевдонима (особенно если они "
"помещены в файл :file:`.pdbrc`)::"

#: ../../library/pdb.rst:518
msgid "Delete the specified alias *name*."
msgstr "Удалить указанный псевдоним *имя*."

#: ../../library/pdb.rst:522
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command.  To set a global variable, you can "
"prefix the assignment command with a :keyword:`global` statement on the same "
"line, e.g.::"
msgstr ""

#: ../../library/pdb.rst:534
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are preserved. :pdbcmd:"
"`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"Перезапустите отлаженную программу Python. Если указан *args*, он "
"разделяется с помощью :mod:`shlex`, и результат используется как новый :data:"
"`sys.argv`. История, точки останова, действия и параметры отладчика "
"сохраняются. :pdbcmd:`restart` — это псевдоним для :pdbcmd:`run`."

#: ../../library/pdb.rst:541
msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "Выйдите из отладчика. Выполнение программы прерывается."

#: ../../library/pdb.rst:545
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr ""
"Введите рекурсивный отладчик, который выполняет *код* (который представляет "
"собой произвольное выражение или оператор, который должен быть выполнен в "
"текущей среде)."

#: ../../library/pdb.rst:551
msgid "Print the return value for the last return of a function."
msgstr ""

#: ../../library/pdb.rst:554
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/pdb.rst:555
msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr ""
"Будет ли кадр считаться происходящим из определенного модуля, определяется "
"``__name__`` в глобальных переменных кадра."
