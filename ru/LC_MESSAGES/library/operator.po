# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 18:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/operator.rst:2
msgid ":mod:`operator` --- Standard operators as functions"
msgstr ""

#: ../../library/operator.rst:9
msgid "**Source code:** :source:`Lib/operator.py`"
msgstr "**Исходный код:** :source:`Lib/operator.py`"

#: ../../library/operator.rst:18
msgid ""
"The :mod:`operator` module exports a set of efficient functions "
"corresponding to the intrinsic operators of Python.  For example, ``operator."
"add(x, y)`` is equivalent to the expression ``x+y``. Many function names are "
"those used for special methods, without the double underscores.  For "
"backward compatibility, many of these have a variant with the double "
"underscores kept. The variants without the double underscores are preferred "
"for clarity."
msgstr ""
"Модуль :mod:`operator` экспортирует набор эффективных функций, "
"соответствующих встроенным операторам Python. Например, ``operator.add(x, "
"y)`` эквивалентен выражению ``x+y``. Многие имена функций используются для "
"специальных методов без двойного подчеркивания. Для обратной совместимости у "
"многих из них есть вариант с сохранением двойного подчеркивания. Для ясности "
"предпочтительны варианты без двойного подчеркивания."

#: ../../library/operator.rst:25
msgid ""
"The functions fall into categories that perform object comparisons, logical "
"operations, mathematical operations and sequence operations."
msgstr ""
"Функции делятся на категории, которые выполняют сравнение объектов, "
"логические операции, математические операции и операции с "
"последовательностями."

#: ../../library/operator.rst:28
msgid ""
"The object comparison functions are useful for all objects, and are named "
"after the rich comparison operators they support:"
msgstr ""
"Функции сравнения объектов полезны для всех объектов и названы в честь "
"поддерживаемых ими расширенных операторов сравнения:"

#: ../../library/operator.rst:45
msgid ""
"Perform \"rich comparisons\" between *a* and *b*. Specifically, ``lt(a, b)`` "
"is equivalent to ``a < b``, ``le(a, b)`` is equivalent to ``a <= b``, "
"``eq(a, b)`` is equivalent to ``a == b``, ``ne(a, b)`` is equivalent to ``a !"
"= b``, ``gt(a, b)`` is equivalent to ``a > b`` and ``ge(a, b)`` is "
"equivalent to ``a >= b``.  Note that these functions can return any value, "
"which may or may not be interpretable as a Boolean value.  See :ref:"
"`comparisons` for more information about rich comparisons."
msgstr ""
"Выполните «богатое сравнение» между *a* и *b*. В частности, ``lt(a, b)`` "
"эквивалентно ``a < b``, ``le(a, b)`` эквивалентно ``a <= b``, ``eq(a , b)`` "
"эквивалентно ``a == b``, ``ne(a, b)`` эквивалентно ``a != b``, ``gt(a, b)`` "
"эквивалентно ``a > b``, а ``ge(a, b)`` эквивалентно ``a >= b``. Обратите "
"внимание, что эти функции могут возвращать любое значение, которое может "
"интерпретироваться или не интерпретироваться как логическое значение. См. :"
"ref:`comparisons` для получения дополнительной информации о расширенных "
"сравнениях."

#: ../../library/operator.rst:54
msgid ""
"The logical operations are also generally applicable to all objects, and "
"support truth tests, identity tests, and boolean operations:"
msgstr ""
"Логические операции также обычно применимы ко всем объектам и поддерживают "
"проверки истинности, проверки идентичности и логические операции:"

#: ../../library/operator.rst:61
msgid ""
"Return the outcome of :keyword:`not` *obj*.  (Note that there is no :meth:"
"`__not__` method for object instances; only the interpreter core defines "
"this operation.  The result is affected by the :meth:`__bool__` and :meth:"
"`__len__` methods.)"
msgstr ""

#: ../../library/operator.rst:69
msgid ""
"Return :const:`True` if *obj* is true, and :const:`False` otherwise.  This "
"is equivalent to using the :class:`bool` constructor."
msgstr ""
"Верните :const:`True`, если *obj* истинно, и :const:`False` в противном "
"случае. Это эквивалентно использованию конструктора :class:`bool`."

#: ../../library/operator.rst:75
msgid "Return ``a is b``.  Tests object identity."
msgstr "Верните ``a равно b``. Проверяет идентичность объекта."

#: ../../library/operator.rst:80
msgid "Return ``a is not b``.  Tests object identity."
msgstr "Верните ``a не b``. Проверяет идентичность объекта."

#: ../../library/operator.rst:83
msgid "The mathematical and bitwise operations are the most numerous:"
msgstr "Математические и побитовые операции наиболее многочисленны:"

#: ../../library/operator.rst:89
msgid "Return the absolute value of *obj*."
msgstr "Верните абсолютное значение *obj*."

#: ../../library/operator.rst:95
msgid "Return ``a + b``, for *a* and *b* numbers."
msgstr "Возвращает ``a + b`` для чисел *a* и *b*."

#: ../../library/operator.rst:101
msgid "Return the bitwise and of *a* and *b*."
msgstr "Возвращает побитовое значение *a* и *b*."

#: ../../library/operator.rst:107
msgid "Return ``a // b``."
msgstr "Верните ``a // b``."

#: ../../library/operator.rst:113
msgid "Return *a* converted to an integer.  Equivalent to ``a.__index__()``."
msgstr ""
"Возвращает *a*, преобразованное в целое число. Эквивалент ``a.__index__()``."

#: ../../library/operator.rst:121
msgid ""
"Return the bitwise inverse of the number *obj*.  This is equivalent to "
"``~obj``."
msgstr "Возвращает побитовое обратное число *obj*. Это эквивалентно ``~obj``."

#: ../../library/operator.rst:127
msgid "Return *a* shifted left by *b*."
msgstr "Верните *a*, сдвинутую влево на *b*."

#: ../../library/operator.rst:133
msgid "Return ``a % b``."
msgstr "Верните ``a % b``."

#: ../../library/operator.rst:139
msgid "Return ``a * b``, for *a* and *b* numbers."
msgstr "Возвращает ``a * b`` для чисел *a* и *b*."

#: ../../library/operator.rst:145
msgid "Return ``a @ b``."
msgstr "Верните ``a @ b``."

#: ../../library/operator.rst:153
msgid "Return *obj* negated (``-obj``)."
msgstr "Возврат *obj* отрицательный (``-obj``)."

#: ../../library/operator.rst:159
msgid "Return the bitwise or of *a* and *b*."
msgstr "Возвращает побитовое ИЛИ из *a* и *b*."

#: ../../library/operator.rst:165
msgid "Return *obj* positive (``+obj``)."
msgstr "Верните *obj* положительное значение (``+obj``)."

#: ../../library/operator.rst:171
msgid "Return ``a ** b``, for *a* and *b* numbers."
msgstr "Возвращает ``a ** b`` для чисел *a* и *b*."

#: ../../library/operator.rst:177
msgid "Return *a* shifted right by *b*."
msgstr "Верните *a*, сдвинутую вправо на *b*."

#: ../../library/operator.rst:183
msgid "Return ``a - b``."
msgstr "Верните ``a - b``."

#: ../../library/operator.rst:189
msgid ""
"Return ``a / b`` where 2/3 is .66 rather than 0.  This is also known as "
"\"true\" division."
msgstr ""
"Верните ``a / b``, где 2/3 равно 0,66, а не 0. Это также известно как "
"«истинное» деление."

#: ../../library/operator.rst:196
msgid "Return the bitwise exclusive or of *a* and *b*."
msgstr "Возвращает побитовое исключающее или из *a* и *b*."

#: ../../library/operator.rst:199
msgid ""
"Operations which work with sequences (some of them with mappings too) "
"include:"
msgstr ""
"Операции, которые работают с последовательностями (некоторые из них также с "
"сопоставлениями), включают:"

#: ../../library/operator.rst:204
msgid "Return ``a + b`` for *a* and *b* sequences."
msgstr "Возвращает ``a + b`` для последовательностей *a* и *b*."

#: ../../library/operator.rst:210
msgid "Return the outcome of the test ``b in a``. Note the reversed operands."
msgstr ""
"Верните результат теста ``b в a``. Обратите внимание на перевернутые "
"операнды."

#: ../../library/operator.rst:215
msgid "Return the number of occurrences of *b* in *a*."
msgstr "Возвращает количество вхождений *b* в *a*."

#: ../../library/operator.rst:221
msgid "Remove the value of *a* at index *b*."
msgstr "Удалите значение *a* по индексу *b*."

#: ../../library/operator.rst:227
msgid "Return the value of *a* at index *b*."
msgstr "Верните значение *a* по индексу *b*."

#: ../../library/operator.rst:232
msgid "Return the index of the first of occurrence of *b* in *a*."
msgstr "Возвращает индекс первого вхождения *b* в *a*."

#: ../../library/operator.rst:238
msgid "Set the value of *a* at index *b* to *c*."
msgstr "Установите значение *a* по индексу *b* на *c*."

#: ../../library/operator.rst:243
msgid ""
"Return an estimated length for the object *o*. First try to return its "
"actual length, then an estimate using :meth:`object.__length_hint__`, and "
"finally return the default value."
msgstr ""

#: ../../library/operator.rst:249
msgid ""
"The :mod:`operator` module also defines tools for generalized attribute and "
"item lookups.  These are useful for making fast field extractors as "
"arguments for :func:`map`, :func:`sorted`, :meth:`itertools.groupby`, or "
"other functions that expect a function argument."
msgstr ""
"Модуль :mod:`operator` также определяет инструменты для обобщенного поиска "
"атрибутов и элементов. Они полезны для создания быстрых экстракторов полей в "
"качестве аргументов для :func:`map`, :func:`sorted`, :meth:`itertools."
"groupby` или других функций, которые ожидают аргумент функции."

#: ../../library/operator.rst:258
msgid ""
"Return a callable object that fetches *attr* from its operand. If more than "
"one attribute is requested, returns a tuple of attributes. The attribute "
"names can also contain dots. For example:"
msgstr ""
"Возвращает вызываемый объект, который извлекает *attr* из своего операнда. "
"Если запрошено более одного атрибута, возвращается кортеж атрибутов. Имена "
"атрибутов также могут содержать точки. Например:"

#: ../../library/operator.rst:262
msgid "After ``f = attrgetter('name')``, the call ``f(b)`` returns ``b.name``."
msgstr "После ``f = attrgetter('name')`` вызов ``f(b)`` возвращает ``b.name``."

#: ../../library/operator.rst:264
msgid ""
"After ``f = attrgetter('name', 'date')``, the call ``f(b)`` returns ``(b."
"name, b.date)``."
msgstr ""
"После ``f = attrgetter('name', 'date')`` вызов ``f(b)`` возвращает ``(b."
"name, b.date)``."

#: ../../library/operator.rst:267
msgid ""
"After ``f = attrgetter('name.first', 'name.last')``, the call ``f(b)`` "
"returns ``(b.name.first, b.name.last)``."
msgstr ""
"После ``f = attrgetter('name.first', 'name.last')`` вызов ``f(b)`` "
"возвращает ``(b.name.first, b.name.last)`` ."

#: ../../library/operator.rst:270 ../../library/operator.rst:302
#: ../../library/operator.rst:350
msgid "Equivalent to::"
msgstr "Эквивалентно::"

#: ../../library/operator.rst:293
msgid ""
"Return a callable object that fetches *item* from its operand using the "
"operand's :meth:`__getitem__` method.  If multiple items are specified, "
"returns a tuple of lookup values.  For example:"
msgstr ""

#: ../../library/operator.rst:297
msgid "After ``f = itemgetter(2)``, the call ``f(r)`` returns ``r[2]``."
msgstr "После ``f = itemgetter(2)`` вызов ``f(r)`` возвращает ``r[2]``."

#: ../../library/operator.rst:299
msgid ""
"After ``g = itemgetter(2, 5, 3)``, the call ``g(r)`` returns ``(r[2], r[5], "
"r[3])``."
msgstr ""
"После ``g = itemgetter(2, 5, 3)`` вызов ``g(r)`` возвращает ``(r[2], r[5], "
"r[3])``."

#: ../../library/operator.rst:314
msgid ""
"The items can be any type accepted by the operand's :meth:`__getitem__` "
"method.  Dictionaries accept any hashable value.  Lists, tuples, and strings "
"accept an index or a slice:"
msgstr ""

#: ../../library/operator.rst:328
msgid ""
"Example of using :func:`itemgetter` to retrieve specific fields from a tuple "
"record:"
msgstr ""
"Пример использования :func:`itemgetter` для получения определенных полей из "
"записи кортежа:"

#: ../../library/operator.rst:341
msgid ""
"Return a callable object that calls the method *name* on its operand.  If "
"additional arguments and/or keyword arguments are given, they will be given "
"to the method as well.  For example:"
msgstr ""
"Возвращает вызываемый объект, который вызывает метод *name* для своего "
"операнда. Если указаны дополнительные аргументы и/или аргументы ключевого "
"слова, они также будут переданы методу. Например:"

#: ../../library/operator.rst:345
msgid ""
"After ``f = methodcaller('name')``, the call ``f(b)`` returns ``b.name()``."
msgstr ""
"После ``f = методcaller('name')`` вызов ``f(b)`` возвращает ``b.name()``."

#: ../../library/operator.rst:347
msgid ""
"After ``f = methodcaller('name', 'foo', bar=1)``, the call ``f(b)`` returns "
"``b.name('foo', bar=1)``."
msgstr ""
"После ``f = методcaller('name', 'foo', bar=1)`` вызов ``f(b)`` возвращает "
"``b.name('foo', bar=1)``."

#: ../../library/operator.rst:361
msgid "Mapping Operators to Functions"
msgstr "Сопоставление операторов функциям"

#: ../../library/operator.rst:363
msgid ""
"This table shows how abstract operations correspond to operator symbols in "
"the Python syntax and the functions in the :mod:`operator` module."
msgstr ""
"В этой таблице показано, как абстрактные операции соответствуют символам "
"операторов в синтаксисе Python и функциям в модуле :mod:`operator`."

#: ../../library/operator.rst:367
msgid "Operation"
msgstr "Операция"

#: ../../library/operator.rst:367
msgid "Syntax"
msgstr "Синтаксис"

#: ../../library/operator.rst:367
msgid "Function"
msgstr "Функция"

#: ../../library/operator.rst:369
msgid "Addition"
msgstr "Дополнение"

#: ../../library/operator.rst:369
msgid "``a + b``"
msgstr "``a + b``"

#: ../../library/operator.rst:369
msgid "``add(a, b)``"
msgstr "``add(a, b)``"

#: ../../library/operator.rst:371
msgid "Concatenation"
msgstr "Конкатенация"

#: ../../library/operator.rst:371
msgid "``seq1 + seq2``"
msgstr "``seq1 + seq2``"

#: ../../library/operator.rst:371
msgid "``concat(seq1, seq2)``"
msgstr "``concat(seq1, seq2)``"

#: ../../library/operator.rst:373
msgid "Containment Test"
msgstr "Испытание на герметичность"

#: ../../library/operator.rst:373
msgid "``obj in seq``"
msgstr "``obj in seq``"

#: ../../library/operator.rst:373
msgid "``contains(seq, obj)``"
msgstr "``contains(seq, obj)``"

#: ../../library/operator.rst:375 ../../library/operator.rst:377
msgid "Division"
msgstr "Деление"

#: ../../library/operator.rst:375
msgid "``a / b``"
msgstr "``a / b``"

#: ../../library/operator.rst:375
msgid "``truediv(a, b)``"
msgstr "``truediv(a, b)``"

#: ../../library/operator.rst:377
msgid "``a // b``"
msgstr "``a // b``"

#: ../../library/operator.rst:377
msgid "``floordiv(a, b)``"
msgstr "``floordiv(a, b)``"

#: ../../library/operator.rst:379
msgid "Bitwise And"
msgstr "Побитовое и"

#: ../../library/operator.rst:379
msgid "``a & b``"
msgstr "``a & b``"

#: ../../library/operator.rst:379
msgid "``and_(a, b)``"
msgstr "``and_(a, b)``"

#: ../../library/operator.rst:381
msgid "Bitwise Exclusive Or"
msgstr "Побитовое исключающее Или"

#: ../../library/operator.rst:381
msgid "``a ^ b``"
msgstr "``a ^ b``"

#: ../../library/operator.rst:381
msgid "``xor(a, b)``"
msgstr "``xor(a, b)``"

#: ../../library/operator.rst:383
msgid "Bitwise Inversion"
msgstr "Побитовая инверсия"

#: ../../library/operator.rst:383
msgid "``~ a``"
msgstr "``~ a``"

#: ../../library/operator.rst:383
msgid "``invert(a)``"
msgstr "``invert(a)``"

#: ../../library/operator.rst:385
msgid "Bitwise Or"
msgstr "Побитовое или"

#: ../../library/operator.rst:385
msgid "``a | b``"
msgstr "``a | b``"

#: ../../library/operator.rst:385
msgid "``or_(a, b)``"
msgstr "``or_(a, b)``"

#: ../../library/operator.rst:387
msgid "Exponentiation"
msgstr "Возведение в степень"

#: ../../library/operator.rst:387
msgid "``a ** b``"
msgstr "``a ** b``"

#: ../../library/operator.rst:387
msgid "``pow(a, b)``"
msgstr "``pow(a, b)``"

#: ../../library/operator.rst:389 ../../library/operator.rst:391
msgid "Identity"
msgstr "Идентичность"

#: ../../library/operator.rst:389
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/operator.rst:389
msgid "``is_(a, b)``"
msgstr "``is_(a, b)``"

#: ../../library/operator.rst:391
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/operator.rst:391
msgid "``is_not(a, b)``"
msgstr "``is_not(a, b)``"

#: ../../library/operator.rst:393
msgid "Indexed Assignment"
msgstr "Индексированное назначение"

#: ../../library/operator.rst:393
msgid "``obj[k] = v``"
msgstr "``obj[k] = v``"

#: ../../library/operator.rst:393
msgid "``setitem(obj, k, v)``"
msgstr "``setitem(obj, k, v)``"

#: ../../library/operator.rst:395
msgid "Indexed Deletion"
msgstr "Индексированное удаление"

#: ../../library/operator.rst:395
msgid "``del obj[k]``"
msgstr "``del obj[k]``"

#: ../../library/operator.rst:395
msgid "``delitem(obj, k)``"
msgstr "``delitem(obj, k)``"

#: ../../library/operator.rst:397
msgid "Indexing"
msgstr "Индексация"

#: ../../library/operator.rst:397
msgid "``obj[k]``"
msgstr "``obj[k]``"

#: ../../library/operator.rst:397
msgid "``getitem(obj, k)``"
msgstr "``getitem(obj, k)``"

#: ../../library/operator.rst:399
msgid "Left Shift"
msgstr "Сдвиг влево"

#: ../../library/operator.rst:399
msgid "``a << b``"
msgstr "``a << b``"

#: ../../library/operator.rst:399
msgid "``lshift(a, b)``"
msgstr "``lshift(a, b)``"

#: ../../library/operator.rst:401
msgid "Modulo"
msgstr "Модуль"

#: ../../library/operator.rst:401
msgid "``a % b``"
msgstr "``a % b``"

#: ../../library/operator.rst:401
msgid "``mod(a, b)``"
msgstr "``mod(a, b)``"

#: ../../library/operator.rst:403
msgid "Multiplication"
msgstr "Умножение"

#: ../../library/operator.rst:403
msgid "``a * b``"
msgstr "``a * b``"

#: ../../library/operator.rst:403
msgid "``mul(a, b)``"
msgstr "``mul(a, b)``"

#: ../../library/operator.rst:405
msgid "Matrix Multiplication"
msgstr "Умножение матриц"

#: ../../library/operator.rst:405
msgid "``a @ b``"
msgstr "``a @ b``"

#: ../../library/operator.rst:405
msgid "``matmul(a, b)``"
msgstr "``matmul(a, b)``"

#: ../../library/operator.rst:407
msgid "Negation (Arithmetic)"
msgstr "Отрицание (арифметика)"

#: ../../library/operator.rst:407
msgid "``- a``"
msgstr "``- a``"

#: ../../library/operator.rst:407
msgid "``neg(a)``"
msgstr "``neg(a)``"

#: ../../library/operator.rst:409
msgid "Negation (Logical)"
msgstr "Отрицание (логическое)"

#: ../../library/operator.rst:409
msgid "``not a``"
msgstr "``not a``"

#: ../../library/operator.rst:409
msgid "``not_(a)``"
msgstr "``not_(a)``"

#: ../../library/operator.rst:411
msgid "Positive"
msgstr "Положительный"

#: ../../library/operator.rst:411
msgid "``+ a``"
msgstr "``+ a``"

#: ../../library/operator.rst:411
msgid "``pos(a)``"
msgstr "``pos(a)``"

#: ../../library/operator.rst:413
msgid "Right Shift"
msgstr "Сдвиг вправо"

#: ../../library/operator.rst:413
msgid "``a >> b``"
msgstr "``a >> b``"

#: ../../library/operator.rst:413
msgid "``rshift(a, b)``"
msgstr "``rshift(a, b)``"

#: ../../library/operator.rst:415
msgid "Slice Assignment"
msgstr "Назначение среза"

#: ../../library/operator.rst:415
msgid "``seq[i:j] = values``"
msgstr "``seq[i:j] = values``"

#: ../../library/operator.rst:415
msgid "``setitem(seq, slice(i, j), values)``"
msgstr "``setitem(seq, slice(i, j), values)``"

#: ../../library/operator.rst:417
msgid "Slice Deletion"
msgstr "Удаление фрагмента"

#: ../../library/operator.rst:417
msgid "``del seq[i:j]``"
msgstr "``del seq[i:j]``"

#: ../../library/operator.rst:417
msgid "``delitem(seq, slice(i, j))``"
msgstr "``delitem(seq, slice(i, j))``"

#: ../../library/operator.rst:419
msgid "Slicing"
msgstr "Разделение"

#: ../../library/operator.rst:419
msgid "``seq[i:j]``"
msgstr "``seq[i:j]``"

#: ../../library/operator.rst:419
msgid "``getitem(seq, slice(i, j))``"
msgstr "``getitem(seq, slice(i, j))``"

#: ../../library/operator.rst:421
msgid "String Formatting"
msgstr "Форматирование строк"

#: ../../library/operator.rst:421
msgid "``s % obj``"
msgstr "``s % obj``"

#: ../../library/operator.rst:421
msgid "``mod(s, obj)``"
msgstr "``mod(s, obj)``"

#: ../../library/operator.rst:423
msgid "Subtraction"
msgstr "Вычитание"

#: ../../library/operator.rst:423
msgid "``a - b``"
msgstr "``a - b``"

#: ../../library/operator.rst:423
msgid "``sub(a, b)``"
msgstr "``sub(a, b)``"

#: ../../library/operator.rst:425
msgid "Truth Test"
msgstr "Проверка на истинность"

#: ../../library/operator.rst:425
msgid "``obj``"
msgstr "``obj``"

#: ../../library/operator.rst:425
msgid "``truth(obj)``"
msgstr "``truth(obj)``"

#: ../../library/operator.rst:427 ../../library/operator.rst:429
#: ../../library/operator.rst:435 ../../library/operator.rst:437
msgid "Ordering"
msgstr "Сортировка"

#: ../../library/operator.rst:427
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/operator.rst:427
msgid "``lt(a, b)``"
msgstr "``lt(a, b)``"

#: ../../library/operator.rst:429
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/operator.rst:429
msgid "``le(a, b)``"
msgstr "``le(a, b)``"

#: ../../library/operator.rst:431
msgid "Equality"
msgstr "Равенство"

#: ../../library/operator.rst:431
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/operator.rst:431
msgid "``eq(a, b)``"
msgstr "``eq(a, b)``"

#: ../../library/operator.rst:433
msgid "Difference"
msgstr "Разница"

#: ../../library/operator.rst:433
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/operator.rst:433
msgid "``ne(a, b)``"
msgstr "``ne(a, b)``"

#: ../../library/operator.rst:435
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/operator.rst:435
msgid "``ge(a, b)``"
msgstr "``ge(a, b)``"

#: ../../library/operator.rst:437
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/operator.rst:437
msgid "``gt(a, b)``"
msgstr "``gt(a, b)``"

#: ../../library/operator.rst:441
msgid "In-place Operators"
msgstr "Операторы на месте"

#: ../../library/operator.rst:443
msgid ""
"Many operations have an \"in-place\" version.  Listed below are functions "
"providing a more primitive access to in-place operators than the usual "
"syntax does; for example, the :term:`statement` ``x += y`` is equivalent to "
"``x = operator.iadd(x, y)``.  Another way to put it is to say that ``z = "
"operator.iadd(x, y)`` is equivalent to the compound statement ``z = x; z += "
"y``."
msgstr ""
"Многие операции имеют версию «на месте». Ниже перечислены функции, "
"обеспечивающие более примитивный доступ к операторам на месте, чем обычный "
"синтаксис; например, оператор :term:`statement` ``x += y`` эквивалентен ``x "
"= оператор.iadd(x, y)``. Другой способ выразить это - сказать, что ``z = "
"оператор.iadd(x, y)`` эквивалентен составному оператору ``z = x; г += у``."

#: ../../library/operator.rst:450
msgid ""
"In those examples, note that when an in-place method is called, the "
"computation and assignment are performed in two separate steps.  The in-"
"place functions listed below only do the first step, calling the in-place "
"method.  The second step, assignment, is not handled."
msgstr ""
"Обратите внимание, что в этих примерах при вызове метода на месте вычисление "
"и присвоение выполняются в два отдельных этапа. Перечисленные ниже функции "
"на месте выполняют только первый шаг, вызывая метод на месте. Второй шаг, "
"присвоение, не обрабатывается."

#: ../../library/operator.rst:455
msgid ""
"For immutable targets such as strings, numbers, and tuples, the updated "
"value is computed, but not assigned back to the input variable:"
msgstr ""
"Для неизменяемых целевых объектов, таких как строки, числа и кортежи, "
"обновленное значение вычисляется, но не присваивается обратно входной "
"переменной:"

#: ../../library/operator.rst:464
msgid ""
"For mutable targets such as lists and dictionaries, the in-place method will "
"perform the update, so no subsequent assignment is necessary:"
msgstr ""
"Для изменяемых целей, таких как списки и словари, метод in-place выполнит "
"обновление, поэтому последующее присвоение не требуется:"

#: ../../library/operator.rst:476
msgid "``a = iadd(a, b)`` is equivalent to ``a += b``."
msgstr "``a = iadd(a, b)`` эквивалентна ``a += b``."

#: ../../library/operator.rst:482
msgid "``a = iand(a, b)`` is equivalent to ``a &= b``."
msgstr "``a = iand(a, b)`` эквивалентна ``a &= b``."

#: ../../library/operator.rst:488
msgid ""
"``a = iconcat(a, b)`` is equivalent to ``a += b`` for *a* and *b* sequences."
msgstr ""
"``a = iconcat(a, b)`` эквивалентно ``a += b`` для последовательностей *a* и "
"*b*."

#: ../../library/operator.rst:494
msgid "``a = ifloordiv(a, b)`` is equivalent to ``a //= b``."
msgstr "``a = ifloordiv(a, b)`` эквивалентна ``a //= b``."

#: ../../library/operator.rst:500
msgid "``a = ilshift(a, b)`` is equivalent to ``a <<= b``."
msgstr "``a = ilshift(a, b)`` эквивалентна ``a <<= b``."

#: ../../library/operator.rst:506
msgid "``a = imod(a, b)`` is equivalent to ``a %= b``."
msgstr "``a = imod(a, b)`` эквивалентна ``a %= b``."

#: ../../library/operator.rst:512
msgid "``a = imul(a, b)`` is equivalent to ``a *= b``."
msgstr "``a = imul(a, b)`` эквивалентна ``a *= b``."

#: ../../library/operator.rst:518
msgid "``a = imatmul(a, b)`` is equivalent to ``a @= b``."
msgstr "``a = imatmul(a, b)`` is equivalent to ``a @= b``."

#: ../../library/operator.rst:526
msgid "``a = ior(a, b)`` is equivalent to ``a |= b``."
msgstr "``a = ior(a, b)`` is equivalent to ``a |= b``."

#: ../../library/operator.rst:532
msgid "``a = ipow(a, b)`` is equivalent to ``a **= b``."
msgstr "``a = ipow(a, b)`` is equivalent to ``a **= b``."

#: ../../library/operator.rst:538
msgid "``a = irshift(a, b)`` is equivalent to ``a >>= b``."
msgstr "``a = irshift(a, b)`` is equivalent to ``a >>= b``."

#: ../../library/operator.rst:544
msgid "``a = isub(a, b)`` is equivalent to ``a -= b``."
msgstr "``a = isub(a, b)`` is equivalent to ``a -= b``."

#: ../../library/operator.rst:550
msgid "``a = itruediv(a, b)`` is equivalent to ``a /= b``."
msgstr "``a = itruediv(a, b)`` эквивалентна ``a /= b``."

#: ../../library/operator.rst:556
msgid "``a = ixor(a, b)`` is equivalent to ``a ^= b``."
msgstr "``a = ixor(a, b)`` эквивалентна ``a ^= b``."
