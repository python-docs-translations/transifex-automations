# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:13+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/configparser.rst:2
msgid ":mod:`configparser` --- Configuration file parser"
msgstr ""

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Исходный код:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Этот модуль предоставляет класс :class:`ConfigParser`, который реализует "
"базовый язык конфигурации, обеспечивающий структуру, аналогичную той, что "
"находится в INI-файлах Microsoft Windows. Вы можете использовать это для "
"написания программ на Python, которые конечные пользователи могут легко "
"настроить."

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Эта библиотека *не* интерпретирует и не записывает префиксы типов значений, "
"используемые в расширенной версии синтаксиса INI реестра Windows."

#: ../../library/configparser.rst:38
msgid "Module :mod:`tomllib`"
msgstr "Модуль :mod:`tomllib`"

#: ../../library/configparser.rst:37
msgid ""
"TOML is a well-specified format for application configuration files. It is "
"specifically designed to be an improved version of INI."
msgstr ""
"TOML — это четко определенный формат файлов конфигурации приложения. Он "
"специально разработан как улучшенная версия INI."

#: ../../library/configparser.rst:42
msgid "Module :mod:`shlex`"
msgstr "Модуль :mod:`shlex`"

#: ../../library/configparser.rst:41
msgid ""
"Support for creating Unix shell-like mini-languages which can also be used "
"for application configuration files."
msgstr ""
"Поддержка создания мини-языков, подобных оболочке Unix, которые также можно "
"использовать для файлов конфигурации приложений."

#: ../../library/configparser.rst:45
msgid "Module :mod:`json`"
msgstr "Модуль :mod:`json`"

#: ../../library/configparser.rst:45
msgid ""
"The ``json`` module implements a subset of JavaScript syntax which is "
"sometimes used for configuration, but does not support comments."
msgstr ""
"Модуль json реализует подмножество синтаксиса JavaScript, который иногда "
"используется для настройки, но не поддерживает комментарии."

#: ../../library/configparser.rst:60
msgid "Quick Start"
msgstr "Быстрый старт"

#: ../../library/configparser.rst:62
msgid "Let's take a very basic configuration file that looks like this:"
msgstr ""
"Давайте возьмем очень простой файл конфигурации, который выглядит следующим "
"образом:"

#: ../../library/configparser.rst:79
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"Структура файлов INI описана `в следующем разделе <#supported-ini-file-"
"structure>`_. По сути файл состоит из разделов, каждый из которых содержит "
"ключи со значениями. Классы :mod:`configparser` могут читать и записывать "
"такие файлы. Начнем с программного создания вышеуказанного файла "
"конфигурации."

#: ../../library/configparser.rst:103
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Как видите, мы можем относиться к анализатору конфигурации во многом как к "
"словарю. Есть различия, `описанные позже <#mapping-protocol-access>`_, но "
"поведение очень близко к тому, что вы ожидаете от словаря."

#: ../../library/configparser.rst:107
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Теперь, когда мы создали и сохранили файл конфигурации, давайте прочитаем "
"его и изучим содержащиеся в нем данные."

#: ../../library/configparser.rst:142
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Как мы видим выше, API довольно прост. Единственная магия связана с разделом "
"DEFAULT, который предоставляет значения по умолчанию для всех остальных "
"разделов. [1]_ . Также обратите внимание, что ключи в разделах не "
"чувствительны к регистру и хранятся в нижнем регистре. [1]_ ."

#: ../../library/configparser.rst:147
msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained."
msgstr ""

#: ../../library/configparser.rst:168
msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr ""
"Такое поведение эквивалентно вызову :meth:`ConfigParser.read` с несколькими "
"файлами, передаваемыми в параметр *filenames*."

#: ../../library/configparser.rst:173
msgid "Supported Datatypes"
msgstr "Поддерживаемые типы данных"

#: ../../library/configparser.rst:175
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Анализаторы конфигурации не угадывают типы данных значений в файлах "
"конфигурации, всегда сохраняя их внутри в виде строк. Это означает, что если "
"вам нужны другие типы данных, вам следует преобразовать их самостоятельно:"

#: ../../library/configparser.rst:186
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Поскольку эта задача настолько распространена, анализаторы конфигурации "
"предоставляют ряд удобных методов получения для обработки целых чисел, чисел "
"с плавающей запятой и логических значений. Последний вариант наиболее "
"интересен, поскольку простая передача значения в ``bool()`` не принесет "
"никакой пользы, поскольку ``bool('False')`` по-прежнему имеет ``True``. Вот "
"почему анализаторы конфигурации также предоставляют :meth:`~ConfigParser."
"getboolean`. Этот метод нечувствителен к регистру и распознает логические "
"значения из ``'да'``/``'нет'``, ``'вкл'``/``'выкл'``, ``'истина'`` /"
"``'false'`` и ``'1'``/``'0'`` [1]_ . Например:"

#: ../../library/configparser.rst:203
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Помимо :meth:`~ConfigParser.getboolean`, анализаторы конфигурации также "
"предоставляют эквивалентные методы :meth:`~ConfigParser.getint` и :meth:"
"`~ConfigParser.getfloat`. Вы можете зарегистрировать свои собственные "
"конвертеры и настроить имеющиеся. [1]_"

#: ../../library/configparser.rst:209
msgid "Fallback Values"
msgstr "Резервные значения"

#: ../../library/configparser.rst:211
msgid ""
"As with a dictionary, you can use a section's :meth:`~ConfigParser.get` "
"method to provide fallback values:"
msgstr ""
"Как и в случае со словарем, вы можете использовать метод раздела :meth:"
"`~ConfigParser.get` для предоставления резервных значений:"

#: ../../library/configparser.rst:224
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Обратите внимание, что значения по умолчанию имеют приоритет над резервными "
"значениями. Например, в нашем примере ключ CompressionLevel был указан "
"только в разделе DEFAULT. Если мы попытаемся получить его из раздела "
"topsecret.server.example, мы всегда получим значение по умолчанию, даже если "
"укажем запасной вариант:"

#: ../../library/configparser.rst:235
msgid ""
"One more thing to be aware of is that the parser-level :meth:`~ConfigParser."
"get` method provides a custom, more complex interface, maintained for "
"backwards compatibility.  When using this method, a fallback value can be "
"provided via the ``fallback`` keyword-only argument:"
msgstr ""
"Еще одна вещь, о которой следует знать, это то, что метод :meth:"
"`~ConfigParser.get` уровня парсера предоставляет собственный, более сложный "
"интерфейс, поддерживаемый для обратной совместимости. При использовании "
"этого метода резервное значение может быть предоставлено через аргумент, "
"содержащий только ключевое слово ``fallback``:"

#: ../../library/configparser.rst:246
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"Тот же аргумент ``fallback`` можно использовать с методами :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` и :meth:"
"`~ConfigParser.getboolean`, например:"

#: ../../library/configparser.rst:262
msgid "Supported INI File Structure"
msgstr "Поддерживаемая файловая структура INI"

#: ../../library/configparser.rst:264
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"Файл конфигурации состоит из разделов, каждый из которых начинается с "
"заголовка ``[section]``, за которым следуют записи ключ/значение, "
"разделенные определенной строкой (``=`` или ``:`` по умолчанию. [1]_ ). По "
"умолчанию имена разделов чувствительны к регистру, но ключи — нет. [1]_ . "
"Ведущие и конечные пробелы удаляются из ключей и значений. Значения могут "
"быть опущены, если синтаксический анализатор настроен на это. [1]_ , и в "
"этом случае разделитель ключ/значение также может быть опущен. Значения "
"также могут занимать несколько строк, если они имеют более глубокий отступ, "
"чем первая строка значения. В зависимости от режима анализатора пустые "
"строки могут рассматриваться как части многострочных значений или "
"игнорироваться."

#: ../../library/configparser.rst:274
msgid ""
"By default, a valid section name can be any string that does not contain '\\"
"\\n'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"По умолчанию допустимым именем раздела может быть любая строка, не "
"содержащая '\\\\n'. Чтобы изменить это, см. :attr:`ConfigParser.SECTCRE`."

#: ../../library/configparser.rst:277
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Файлы конфигурации могут включать комментарии, которым предшествуют "
"определенные символы (``#`` и ``;`` по умолчанию. [1]_ ). Комментарии могут "
"появляться отдельно в пустой строке, возможно, с отступом. [1]_"

#: ../../library/configparser.rst:281 ../../library/configparser.rst:344
msgid "For example:"
msgstr "Например:"

#: ../../library/configparser.rst:329
msgid "Interpolation of values"
msgstr "Интерполяция значений"

#: ../../library/configparser.rst:331
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"Помимо основной функциональности, :class:`ConfigParser` поддерживает "
"интерполяцию. Это означает, что значения могут быть предварительно "
"обработаны перед их возвратом из вызовов get()."

#: ../../library/configparser.rst:339
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"Реализация по умолчанию, используемая :class:`ConfigParser`. Это позволяет "
"значениям содержать строки формата, которые ссылаются на другие значения в "
"том же разделе или значения в специальном разделе по умолчанию. [1]_ . "
"Дополнительные значения по умолчанию могут быть предоставлены при "
"инициализации."

#: ../../library/configparser.rst:357
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"В приведенном выше примере :class:`ConfigParser` с *interpolation*, "
"установленным в ``BasicInterpolation()``, разрешит `` %(man_dir)с `` на "
"значение ``home_dir`` (в данном случае ``/Users``). `` %(my_dir)с `` по сути "
"будет разрешено как ``/Users/lumberjack``. Все интерполяции выполняются по "
"требованию, поэтому ключи, используемые в цепочке ссылок, не нужно указывать "
"в каком-либо определенном порядке в файле конфигурации."

#: ../../library/configparser.rst:364
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Если для ``интерполяции`` установлено значение ``Нет``, синтаксический "
"анализатор просто вернет `` %(my_dir)с /Pictures`` как значение "
"``my_pictures`` и `` %(man_dir)с /lumberjack`` как значение ``my_dir``."

#: ../../library/configparser.rst:372
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Альтернативный обработчик интерполяции, реализующий более продвинутый "
"синтаксис, используемый, например, в zc.buildout. Расширенная интерполяция "
"использует ``${section:option}`` для обозначения значения из стороннего "
"раздела. Интерполяция может охватывать несколько уровней. Для удобства, если "
"часть ``section:`` опущена, интерполяция по умолчанию будет использоваться "
"для текущего раздела (и, возможно, значений по умолчанию из специального "
"раздела)."

#: ../../library/configparser.rst:379
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Например, указанная выше конфигурация с базовой интерполяцией будет "
"выглядеть так с расширенной интерполяцией:"

#: ../../library/configparser.rst:393
msgid "Values from other sections can be fetched as well:"
msgstr "Также можно получить значения из других разделов:"

#: ../../library/configparser.rst:415
msgid "Mapping Protocol Access"
msgstr "Доступ к протоколу сопоставления"

#: ../../library/configparser.rst:419
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"Доступ к протоколу сопоставления — это общее название функциональности, "
"которая позволяет использовать пользовательские объекты, как если бы они "
"были словарями. В случае :mod:`configparser` реализация интерфейса "
"сопоставления использует нотацию ``parser['section']['option']``."

#: ../../library/configparser.rst:424
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']``, в частности, возвращает прокси для данных раздела в "
"анализаторе. Это означает, что значения не копируются, а берутся из "
"исходного парсера по требованию. Еще более важно то, что когда значения "
"изменяются в прокси-сервере раздела, они фактически изменяются в исходном "
"парсере."

#: ../../library/configparser.rst:430
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
"Объекты :mod:`configparser` ведут себя как можно ближе к реальным словарям. "
"Интерфейс сопоставления завершен и соответствует ABC :class:`~collections."
"abc.MutableMapping`. Однако есть несколько отличий, которые следует "
"учитывать:"

#: ../../library/configparser.rst:435
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"По умолчанию все ключи в разделах доступны без учета регистра. [1]_ . "
"Например, ``for option in parser[\"section\"]`` дает только имена опций, "
"заданные ``optionxform``. Это означает, что клавиши в нижнем регистре по "
"умолчанию. В то же время для раздела, содержащего ключ «a», оба выражения "
"возвращают «True»::"

#: ../../library/configparser.rst:443
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Все разделы также включают значения DEFAULTSECT, что означает, что ``."
"clear()`` в разделе не может оставить раздел визуально пустым. Это связано с "
"тем, что значения по умолчанию нельзя удалить из раздела (потому что "
"технически их там нет). Если они переопределены в разделе, удаление приведет "
"к тому, что значение по умолчанию снова станет видимым. Попытка удалить "
"значение по умолчанию вызывает ошибку :exc:`KeyError`."

#: ../../library/configparser.rst:450
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` нельзя удалить из парсера:"

#: ../../library/configparser.rst:452
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "при попытке удалить возникает :exc:`ValueError`,"

#: ../../library/configparser.rst:454
msgid "``parser.clear()`` leaves it intact,"
msgstr "``pars.clear()`` оставляет его нетронутым,"

#: ../../library/configparser.rst:456
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` никогда не возвращает его."

#: ../../library/configparser.rst:458
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - второй аргумент **не** является "
"резервным значением. Однако обратите внимание, что методы get() на уровне "
"раздела совместимы как с протоколом сопоставления, так и с классическим API "
"configparser."

#: ../../library/configparser.rst:462
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` совместим с протоколом сопоставления (возвращает список "
"пар *section_name*, *section_proxy*, включая DEFAULTSECT). Однако этот метод "
"также можно вызвать с аргументами: ``parser.items(section, raw, vars)``. "
"Последний вызов возвращает список пар *option*, *value* для указанного "
"``section`` со всеми расширенными интерполяциями (если не указан "
"``raw=True``)."

#: ../../library/configparser.rst:469
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"Протокол сопоставления реализован поверх существующего устаревшего API, "
"поэтому подклассы, переопределяющие исходный интерфейс, по-прежнему должны "
"иметь сопоставления, работающие должным образом."

#: ../../library/configparser.rst:475
msgid "Customizing Parser Behaviour"
msgstr "Настройка поведения анализатора"

#: ../../library/configparser.rst:477
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Вариантов формата INI почти столько же, сколько приложений, его "
"использующих. :mod:`configparser` имеет большое значение для обеспечения "
"поддержки самого большого разумного набора доступных стилей INI. "
"Функциональность по умолчанию в основном продиктована историческим прошлым, "
"и весьма вероятно, что вы захотите настроить некоторые функции."

#: ../../library/configparser.rst:483
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`!__init__` options:"
msgstr ""
"Самый распространенный способ изменить способ работы конкретного анализатора "
"конфигурации — использовать параметры :meth:`!__init__`:"

#: ../../library/configparser.rst:486
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, значение по умолчанию: ``None``"

#: ../../library/configparser.rst:488
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Эта опция принимает словарь пар ключ-значение, который изначально будет "
"помещен в раздел DEFAULT. Это обеспечивает элегантный способ поддержки "
"кратких файлов конфигурации, в которых не указаны значения, совпадающие с "
"документированными значениями по умолчанию."

#: ../../library/configparser.rst:493
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`~ConfigParser.read_dict` before you read the actual file."
msgstr ""
"Подсказка: если вы хотите указать значения по умолчанию для определенного "
"раздела, используйте :meth:`~ConfigParser.read_dict` перед чтением "
"фактического файла."

#: ../../library/configparser.rst:496
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, значение по умолчанию: :class:`dict`"

#: ../../library/configparser.rst:498
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Этот параметр оказывает существенное влияние на поведение протокола "
"сопоставления и на то, как будут выглядеть записанные файлы конфигурации. В "
"стандартном словаре каждый раздел сохраняется в том порядке, в котором они "
"были добавлены в анализатор. То же самое касается опций внутри разделов."

#: ../../library/configparser.rst:503
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Альтернативный тип словаря можно использовать, например, для сортировки "
"разделов и опций при обратной записи."

#: ../../library/configparser.rst:506
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Обратите внимание: существуют способы добавить набор пар ключ-значение за "
"одну операцию. Когда вы используете в этих операциях обычный словарь, "
"порядок ключей будет упорядочен. Например:"

#: ../../library/configparser.rst:528
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, значение по умолчанию: ``False``"

#: ../../library/configparser.rst:530
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Известно, что некоторые файлы конфигурации содержат настройки без значений, "
"но в остальном они соответствуют синтаксису, поддерживаемому :mod:"
"`configparser`. Параметр *allow_no_value* конструктора можно использовать "
"для указания того, что такие значения должны быть приняты:"

#: ../../library/configparser.rst:565
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*разделители*, значение по умолчанию: ``('=', ':')``"

#: ../../library/configparser.rst:567
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Разделители — это подстроки, которые отделяют ключи от значений внутри "
"раздела. Первое появление разделительной подстроки в строке считается "
"разделителем. Это означает, что значения (но не ключи) могут содержать "
"разделители."

#: ../../library/configparser.rst:571
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"См. также аргумент *space_around_delimiters* для :meth:`ConfigParser.write`."

#: ../../library/configparser.rst:574
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, значение по умолчанию: ``('#', ';')``"

#: ../../library/configparser.rst:576
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, значение по умолчанию: ``None``"

#: ../../library/configparser.rst:578
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Префиксы комментариев — это строки, обозначающие начало допустимого "
"комментария в файле конфигурации. *comment_prefixes* используются только в "
"пустых строках (необязательно с отступом), тогда как "
"*inline_comment_prefixes* можно использовать после каждого допустимого "
"значения (например, названий разделов, опций и пустых строк). По умолчанию "
"встроенные комментарии отключены, а ``'#'`` и ``';'`` используются в "
"качестве префиксов для комментариев всей строки."

#: ../../library/configparser.rst:585
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"В предыдущих версиях :mod:`configparser` поведение соответствовало "
"``comment_prefixes=('#',';')`` и ``inline_comment_prefixes=(';',)``."

#: ../../library/configparser.rst:589
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Обратите внимание, что анализаторы конфигурации не поддерживают "
"экранирование префиксов комментариев, поэтому использование "
"*inline_comment_prefixes* может помешать пользователям указывать значения "
"параметров с помощью символов, используемых в качестве префиксов "
"комментариев. В случае сомнений не устанавливайте *inline_comment_prefixes*. "
"В любых обстоятельствах единственный способ сохранить символы префикса "
"комментария в начале строки в многострочных значениях — это интерполировать "
"префикс, например::"

#: ../../library/configparser.rst:635
msgid "*strict*, default value: ``True``"
msgstr "*strict*, значение по умолчанию: ``True``"

#: ../../library/configparser.rst:637
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`~ConfigParser."
"read_file`, :meth:`~ConfigParser.read_string` or :meth:`~ConfigParser."
"read_dict`).  It is recommended to use strict parsers in new applications."
msgstr ""
"Если установлено значение «True», анализатор не допустит дублирования "
"разделов или параметров при чтении из одного источника (с использованием :"
"meth:`~ConfigParser.read_file`, :meth:`~ConfigParser.read_string` или :meth :"
"`~ConfigParser.read_dict`). В новых приложениях рекомендуется использовать "
"строгие парсеры."

#: ../../library/configparser.rst:642
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"В предыдущих версиях поведение :mod:`configparser` соответствовало "
"``strict=False``."

#: ../../library/configparser.rst:646
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, значение по умолчанию: ``True``"

#: ../../library/configparser.rst:648
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"В анализаторах конфигурации значения могут занимать несколько строк, если их "
"отступ больше, чем у ключа, который их содержит. По умолчанию анализаторы "
"также позволяют пустым строкам быть частью значений. В то же время клавиши "
"могут иметь произвольный отступ для улучшения читаемости. Как следствие, "
"когда файлы конфигурации становятся большими и сложными, пользователь может "
"легко потерять структуру файла. Возьмем, к примеру:"

#: ../../library/configparser.rst:663
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Пользователю может быть особенно проблематично увидеть, использует ли он "
"пропорциональный шрифт для редактирования файла. Вот почему, если вашему "
"приложению не нужны значения с пустыми строками, вам следует запретить их "
"использование. Это приведет к тому, что пустые строки будут каждый раз "
"разделять ключи. В приведенном выше примере будет создано два ключа: ``key`` "
"и ``this``."

#: ../../library/configparser.rst:669
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, значение по умолчанию: ``configparser.DEFAULTSECT`` (то "
"есть: ``\"DEFAULT\"``)"

#: ../../library/configparser.rst:672
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"Соглашение о разрешении специального раздела значений по умолчанию для "
"других разделов или целей интерполяции является мощной концепцией этой "
"библиотеки, позволяющей пользователям создавать сложные декларативные "
"конфигурации. Этот раздел обычно называется ``DEFAULT'`, но его можно "
"настроить так, чтобы он указывал на любое другое допустимое имя раздела. "
"Некоторые типичные значения включают: ``\"general\"`` или ``\"common\"``. "
"Предоставленное имя используется для распознавания разделов по умолчанию при "
"чтении из любого источника и при записи конфигурации обратно в файл. Его "
"текущее значение можно получить с помощью атрибута parser_instance."
"default_section и можно изменить во время выполнения (т. е. для "
"преобразования файлов из одного формата в другой)."

#: ../../library/configparser.rst:683
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr ""
"*интерполяция*, значение по умолчанию: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:685
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"Поведение интерполяции можно настроить, предоставив собственный обработчик "
"через аргумент *interpolation*. ``None`` можно использовать для полного "
"отключения интерполяции, ``ExtendedInterpolation()`` предоставляет более "
"продвинутый вариант, вдохновленный ``zc.buildout``. Подробнее об этом "
"читайте в `специальном разделе документации <#interpolation-of-values>`_. :"
"class:`RawConfigParser` имеет значение по умолчанию ``None``."

#: ../../library/configparser.rst:692
msgid "*converters*, default value: not set"
msgstr "*converters*, значение по умолчанию: не установлено"

#: ../../library/configparser.rst:694
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`!getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"Анализаторы конфигурации предоставляют методы получения значений опций, "
"которые выполняют преобразование типов. По умолчанию реализованы :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` и :meth:"
"`~ConfigParser.getboolean`. Если желательны другие методы получения, "
"пользователи могут определить их в подклассе или передать словарь, где "
"каждый ключ является именем преобразователя, а каждое значение является "
"вызываемым объектом, реализующим указанное преобразование. Например, "
"передача ``{'decimal': decimal.Decimal}`` добавит :meth:`!getdecimal` как к "
"объекту синтаксического анализатора, так и ко всем прокси разделов. Другими "
"словами, можно будет написать как ``parser_instance.getdecimal('section', "
"'key', Fallback=0)``, так и ``parser_instance['section'].getdecimal('key', "
"0)` `."

#: ../../library/configparser.rst:705
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Если преобразователю необходимо получить доступ к состоянию анализатора, его "
"можно реализовать как метод в подклассе анализатора конфигурации. Если имя "
"этого метода начинается с ``get``, он будет доступен на всех прокси-серверах "
"раздела в совместимой с dict формой (см. пример ``getdecimal()`` выше)."

#: ../../library/configparser.rst:710
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Более продвинутая настройка может быть достигнута путем переопределения "
"значений по умолчанию этих атрибутов синтаксического анализатора. Значения "
"по умолчанию определены в классах, поэтому они могут быть переопределены "
"подклассами или присвоением атрибутов."

#: ../../library/configparser.rst:716
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""
"По умолчанию при использовании :meth:`~ConfigParser.getboolean` анализаторы "
"конфигурации учитывают следующие значения ``True``: ``'1'``, ``'yes'``, "
"``'true'``, ``'on'`` и следующие значения ``False``: ``'0'``, ``'no'``, "
"``'false'``, ``'off'``. Вы можете переопределить это, указав собственный "
"словарь строк и их логических результатов. Например:"

#: ../../library/configparser.rst:734
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""
"Другие типичные логические пары включают ``accept``/``reject`` или "
"``enabled``/``disabled``."

#: ../../library/configparser.rst:740
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""
"Этот метод преобразует имена опций при каждой операции чтения, получения или "
"установки. По умолчанию имя преобразуется в нижний регистр. Это также "
"означает, что при записи файла конфигурации все ключи будут в нижнем "
"регистре. Переопределите этот метод, если он не подходит. Например:"

#: ../../library/configparser.rst:770
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"Функция optionxform преобразует имена опций в каноническую форму. Это должна "
"быть идемпотентная функция: если имя уже находится в канонической форме, оно "
"должно быть возвращено без изменений."

#: ../../library/configparser.rst:777
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""
"Скомпилированное регулярное выражение, используемое для анализа заголовков "
"разделов. По умолчанию имя ``[section]`` соответствует имени "
"``\"section\"``. Пробелы считаются частью имени раздела, поэтому "
"``[ larch ]`` будет читаться как раздел с именем ``\" larch \"``. "
"Переопределите этот атрибут, если он не подходит. Например:"

#: ../../library/configparser.rst:805
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""
"Хотя объекты ConfigParser также используют атрибут OPTCRE для распознавания "
"строк параметров, не рекомендуется переопределять его, поскольку это будет "
"мешать параметрам конструктора *allow_no_value* и *delimiters*."

#: ../../library/configparser.rst:811
msgid "Legacy API Examples"
msgstr "Примеры устаревших API"

#: ../../library/configparser.rst:813
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""
"В основном из-за проблем обратной совместимости, :mod:`configparser` также "
"предоставляет устаревший API с явными методами ``get``/``set``. Хотя "
"существуют допустимые варианты использования методов, описанных ниже, доступ "
"к протоколу сопоставления предпочтителен для новых проектов. Устаревший API "
"порой более продвинутый, низкоуровневый и совершенно нелогичный."

#: ../../library/configparser.rst:819
msgid "An example of writing to a configuration file::"
msgstr "Пример записи в файл конфигурации::"

#: ../../library/configparser.rst:842
msgid "An example of reading the configuration file again::"
msgstr "Пример повторного чтения файла конфигурации:"

#: ../../library/configparser.rst:860
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "Чтобы получить интерполяцию, используйте :class:`ConfigParser`::"

#: ../../library/configparser.rst:893
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Значения по умолчанию доступны в обоих типах ConfigParsers. Они используются "
"при интерполяции, если используемый параметр не определен где-либо еще. ::"

#: ../../library/configparser.rst:911
msgid "ConfigParser Objects"
msgstr "Объекты ConfigParser"

#: ../../library/configparser.rst:915
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"Основной парсер конфигурации. Когда задано значение *defaults*, оно "
"инициализируется в словаре встроенных значений по умолчанию. Если указан "
"*dict_type*, он будет использоваться для создания объектов словаря для "
"списка разделов, для параметров внутри раздела и для значений по умолчанию."

#: ../../library/configparser.rst:920
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"Если указаны *разделители*, они используются как набор подстрок, которые "
"отделяют ключи от значений. Если указан *comment_prefixes*, он будет "
"использоваться как набор подстрок, которые ставят комментарии в пустых "
"строках. Комментарии могут быть с отступом. Если указан "
"*inline_comment_prefixes*, он будет использоваться как набор подстрок, "
"которые ставят комментарии перед комментариями в непустых строках."

#: ../../library/configparser.rst:926
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"Когда *strict* имеет значение True (по умолчанию), синтаксический анализатор "
"не допускает дублирования разделов или опций при чтении из одного источника "
"(файла, строки или словаря), вызывая :exc:`DuplateSectionError` или : exc:"
"`DuplateOptionError`. Когда *empty_lines_in_values* имеет значение "
"«False» (по умолчанию: «True»), каждая пустая строка отмечает конец опции. В "
"противном случае внутренние пустые строки многострочного параметра "
"сохраняются как часть значения. Когда *allow_no_value* имеет значение True "
"(по умолчанию: False), принимаются параметры без значений; для них "
"сохраняется значение None, и они сериализуются без конечного разделителя."

#: ../../library/configparser.rst:936
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"at runtime using the ``default_section`` instance attribute. This won't re-"
"evaluate an already parsed config file, but will be used when writing parsed "
"settings to a new config file."
msgstr ""
"Если указан *default_section*, он определяет имя специального раздела, "
"содержащего значения по умолчанию для других разделов и целей интерполяции "
"(обычно называемый ``\"DEFAULT\"``). Это значение можно получить и изменить "
"во время выполнения, используя атрибут экземпляра ``default_section``. Это "
"не приведет к повторной оценке уже проанализированного файла конфигурации, "
"но будет использоваться при записи проанализированных настроек в новый файл "
"конфигурации."

#: ../../library/configparser.rst:943
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""
"Поведение интерполяции можно настроить, предоставив собственный обработчик "
"через аргумент *interpolation*. ``None`` можно использовать для полного "
"отключения интерполяции, ``ExtendedInterpolation()`` предоставляет более "
"продвинутый вариант, вдохновленный ``zc.buildout``. Подробнее об этом "
"читайте в `специальном разделе документации <#interpolation-of-values>`_."

#: ../../library/configparser.rst:949
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Все имена опций, используемые при интерполяции, будут передаваться через "
"метод :meth:`optionxform`, как и любая другая ссылка на имя опции. Например, "
"при использовании реализации :meth:`optionxform` по умолчанию (которая "
"преобразует имена опций в нижний регистр), значения ``foo %(бар)с `` и ``фу "
"%(БАР)с `` эквивалентны."

#: ../../library/configparser.rst:955
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`!get*()` method on the parser "
"object and section proxies."
msgstr ""

#: ../../library/configparser.rst:961
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "По умолчанию *dict_type* — :class:`collections.OrderedDict`."

#: ../../library/configparser.rst:964
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"Были добавлены *allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* и *interpolation*."

#: ../../library/configparser.rst:969
msgid "The *converters* argument was added."
msgstr "Был добавлен аргумент *converters*."

#: ../../library/configparser.rst:972
msgid ""
"The *defaults* argument is read with :meth:`read_dict()`, providing "
"consistent behavior across the parser: non-string keys and values are "
"implicitly converted to strings."
msgstr ""

#: ../../library/configparser.rst:977 ../../library/configparser.rst:1262
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"По умолчанию *dict_type* — :class:`dict`, поскольку теперь он сохраняет "
"порядок вставки."

#: ../../library/configparser.rst:983
msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""
"Возвращает словарь, содержащий значения по умолчанию для всего экземпляра."

#: ../../library/configparser.rst:988
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Вернуть список доступных разделов; *раздел по умолчанию* не включен в список."

#: ../../library/configparser.rst:994
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Добавьте в экземпляр раздел с именем *section*. Если раздел с данным именем "
"уже существует, возникает :exc:`DuplateSectionError`. Если передается имя "
"раздела *default*, возникает :exc:`ValueError`. Имя раздела должно быть "
"строкой; в противном случае возникает :exc:`TypeError`."

#: ../../library/configparser.rst:999
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "Имена нестроковых разделов вызывают :exc:`TypeError`."

#: ../../library/configparser.rst:1005
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Указывает, присутствует ли указанный *раздел* в конфигурации. *Раздел по "
"умолчанию* не подтверждается."

#: ../../library/configparser.rst:1011
msgid "Return a list of options available in the specified *section*."
msgstr "Возвращает список опций, доступных в указанном *разделе*."

#: ../../library/configparser.rst:1016
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Если данный *раздел* существует и содержит данную *опцию*, верните :const:"
"`True`; в противном случае верните :const:`False`. Если указанный *раздел* "
"имеет значение :const:`None` или пустую строку, предполагается DEFAULT."

#: ../../library/configparser.rst:1023
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Попытка прочитать и проанализировать итерацию имен файлов, вернув список "
"имен файлов, которые были успешно проанализированы."

#: ../../library/configparser.rst:1026
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Если *filenames* представляет собой строку, объект :class:`bytes` или :term:"
"`path-like object`, он рассматривается как одно имя файла. Если файл, "
"указанный в *filenames*, не может быть открыт, этот файл будет "
"проигнорирован. Это сделано так, что вы можете указать итерацию "
"потенциальных местоположений файлов конфигурации (например, текущий каталог, "
"домашний каталог пользователя и какой-либо общесистемный каталог), и все "
"существующие файлы конфигурации в итерации будут прочитаны."

#: ../../library/configparser.rst:1035
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Если ни один из указанных файлов не существует, экземпляр :class:"
"`ConfigParser` будет содержать пустой набор данных. Приложение, которому "
"требуется загрузка начальных значений из файла, должно загрузить требуемый "
"файл или файлы с помощью :meth:`read_file` перед вызовом :meth:`read` для "
"любых необязательных файлов::"

#: ../../library/configparser.rst:1048
msgid ""
"Added the *encoding* parameter. Previously, all files were read using the "
"default encoding for :func:`open`."
msgstr ""
"Добавлен параметр *encoding*. Раньше все файлы читались с использованием "
"кодировки по умолчанию для :func:`open`."

#: ../../library/configparser.rst:1052
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "Параметр *filenames* принимает объект, похожий на путь."

#: ../../library/configparser.rst:1055
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "Параметр *filenames* принимает объект :class:`bytes`."

#: ../../library/configparser.rst:1061
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Считайте и проанализируйте данные конфигурации из *f*, которые должны быть "
"итеративными, возвращающими строки Unicode (например, файлы, открытые в "
"текстовом режиме)."

#: ../../library/configparser.rst:1064
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`!name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"Необязательный аргумент *source* указывает имя читаемого файла. Если он не "
"указан и *f* имеет атрибут :attr:`!name`, который используется для *source*; "
"значение по умолчанию — ``'<???>'``."

#: ../../library/configparser.rst:1068
msgid "Replaces :meth:`!readfp`."
msgstr "Заменяет :meth:`!readfp`."

#: ../../library/configparser.rst:1073
msgid "Parse configuration data from a string."
msgstr "Анализ данных конфигурации из строки."

#: ../../library/configparser.rst:1075
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"Необязательный аргумент *source* указывает контекстно-зависимое имя "
"передаваемой строки. Если не указано, используется ``'<string>'``. Обычно "
"это должен быть путь к файловой системе или URL-адрес."

#: ../../library/configparser.rst:1084
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Загрузите конфигурацию из любого объекта, который предоставляет метод "
"item(), похожий на dict. Ключи — это названия разделов, значения — словари с "
"ключами и значениями, которые должны присутствовать в разделе. Если "
"используемый тип словаря сохраняет порядок, разделы и их ключи будут "
"добавлены по порядку. Значения автоматически преобразуются в строки."

#: ../../library/configparser.rst:1090
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"Необязательный аргумент *source* указывает контекстно-зависимое имя "
"переданного словаря. Если не указано, используется ``<dict>``."

#: ../../library/configparser.rst:1093
msgid "This method can be used to copy state between parsers."
msgstr ""
"Этот метод можно использовать для копирования состояния между парсерами."

#: ../../library/configparser.rst:1100
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Получите значение *option* для именованного *section*. Если указан *vars*, "
"это должен быть словарь. *опция* ищется в *vars* (если есть), *section* и в "
"*DEFAULTSECT* в указанном порядке. Если ключ не найден и указан *fallback*, "
"он используется как резервное значение. ``None`` может быть предоставлено "
"как *резервное* значение."

#: ../../library/configparser.rst:1106
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Все интерполяции ``'%'`` расширяются в возвращаемых значениях, если только "
"аргумент *raw* не имеет значения true. Значения ключей интерполяции ищутся "
"так же, как и этот параметр."

#: ../../library/configparser.rst:1110
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Аргументы *raw*, *vars* и *fallback* являются ключевыми словами только для "
"защиты пользователей от попыток использовать третий аргумент в качестве "
"запасного *fallback* (особенно при использовании протокола сопоставления)."

#: ../../library/configparser.rst:1118
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Удобный метод, который приводит *опцию* в указанном *разделе* к целому "
"числу. См. :meth:`get` для объяснения *raw*, *vars* и *fallback*."

#: ../../library/configparser.rst:1125
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""

#: ../../library/configparser.rst:1132
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Удобный метод, который приводит *option* в указанном *section* к логическому "
"значению. Обратите внимание, что допустимыми значениями для этой опции "
"являются ``'1'``, ``'yes'``, ``'true'`` и ``'on'``, что приводит к тому, что "
"этот метод возвращает `` True``, ``'0'``, ``'no'``, ``'false'`` и ``'off'`, "
"которые заставляют его возвращать ``False``. Эти строковые значения "
"проверяются без учета регистра. Любое другое значение приведет к повышению :"
"exc:`ValueError`. См. :meth:`get` для объяснения *raw*, *vars* и *fallback*."

#: ../../library/configparser.rst:1145
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Если *section* не указан, верните список пар *section_name*, "
"*section_proxy*, включая DEFAULTSECT."

#: ../../library/configparser.rst:1148
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"В противном случае верните список пар *имя*, *значение* для параметров в "
"данном *разделе*. Необязательные аргументы имеют то же значение, что и для "
"метода :meth:`get`."

#: ../../library/configparser.rst:1152
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Элементы, присутствующие в *vars*, больше не отображаются в результатах. "
"Предыдущее поведение смешивало фактические параметры синтаксического анализа "
"с переменными, предоставленными для интерполяции."

#: ../../library/configparser.rst:1160
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Если данный раздел существует, установите для данной опции указанное "
"значение; в противном случае поднимите :exc:`NoSectionError`. *опция* и "
"*значение* должны быть строками; в противном случае возникает :exc:"
"`TypeError`."

#: ../../library/configparser.rst:1167
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Запишите представление конфигурации в указанный :term:`файловый объект`, "
"который должен быть открыт в текстовом режиме (принимающий строки). Это "
"представление может быть проанализировано будущим вызовом :meth:`read`. Если "
"*space_around_delimiters* имеет значение true, разделители между ключами и "
"значениями заключаются в пробелы."

#: ../../library/configparser.rst:1175
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Комментарии в исходном файле конфигурации не сохраняются при обратной записи "
"конфигурации. То, что считается комментарием, зависит от заданных значений "
"*comment_prefix* и *inline_comment_prefix*."

#: ../../library/configparser.rst:1183
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Удалить указанную *опцию* из указанного *раздела*. Если раздел не "
"существует, поднимите :exc:`NoSectionError`. Если опция, которую нужно "
"удалить, существовала, верните :const:`True`; в противном случае верните :"
"const:`False`."

#: ../../library/configparser.rst:1191
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Удалите указанный *раздел* из конфигурации. Если раздел действительно "
"существовал, верните ``True``. В противном случае верните ``False``."

#: ../../library/configparser.rst:1197
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Преобразует имя опции *option*, найденное во входном файле или переданное "
"клиентским кодом, в форму, которая должна использоваться во внутренних "
"структурах. Реализация по умолчанию возвращает версию *option* в нижнем "
"регистре; подклассы могут переопределить это, или клиентский код может "
"установить атрибут с этим именем в экземплярах, чтобы повлиять на это "
"поведение."

#: ../../library/configparser.rst:1203
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"Вам не нужно создавать подкласс синтаксического анализатора, чтобы "
"использовать этот метод, вы также можете установить его в экземпляре в "
"функцию, которая принимает строковый аргумент и возвращает строку. Например, "
"установка значения ``str`` сделает имена опций чувствительными к регистру::"

#: ../../library/configparser.rst:1211
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Обратите внимание, что при чтении файлов конфигурации пробелы вокруг имен "
"опций удаляются перед вызовом :meth:`optionxform`."

#: ../../library/configparser.rst:1217
msgid "Use :meth:`read_file` instead."
msgstr ""

#: ../../library/configparser.rst:1220
msgid ""
":meth:`readfp` now iterates on *fp* instead of calling ``fp.readline()``."
msgstr ""

#: ../../library/configparser.rst:1223
msgid ""
"For existing code calling :meth:`readfp` with arguments which don't support "
"iteration, the following generator may be used as a wrapper around the file-"
"like object::"
msgstr ""

#: ../../library/configparser.rst:1233
msgid ""
"Instead of ``parser.readfp(fp)`` use ``parser."
"read_file(readline_generator(fp))``."
msgstr ""

#: ../../library/configparser.rst:1239
msgid ""
"The maximum depth for recursive interpolation for :meth:`~configparser."
"ConfigParser.get` when the *raw* parameter is false.  This is relevant only "
"when the default *interpolation* is used."
msgstr ""
"Максимальная глубина рекурсивной интерполяции для :meth:`~configparser."
"ConfigParser.get`, когда параметр *raw* имеет значение false. Это актуально "
"только при использовании *интерполяции* по умолчанию."

#: ../../library/configparser.rst:1247
msgid "RawConfigParser Objects"
msgstr "Объекты RawConfigParser"

#: ../../library/configparser.rst:1257
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""
"Устаревший вариант :class:`ConfigParser`. По умолчанию в нем отключена "
"интерполяция, и он позволяет использовать нестроковые имена разделов, имена "
"опций и значения с помощью небезопасных методов ``add_section`` и ``set``, а "
"также устаревшую обработку аргументов ключевого слова ``defaults=``. ."

#: ../../library/configparser.rst:1267
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Вместо этого рассмотрите возможность использования :class:`ConfigParser`, "
"который проверяет типы значений, которые будут храниться внутри. Если вам не "
"нужна интерполяция, вы можете использовать "
"``ConfigParser(interpolation=None)``."

#: ../../library/configparser.rst:1274
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""
"Добавьте в экземпляр раздел с именем *section*. Если раздел с данным именем "
"уже существует, возникает :exc:`DuplateSectionError`. Если передается имя "
"раздела *default*, возникает :exc:`ValueError`."

#: ../../library/configparser.rst:1278
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"Тип *раздела* не отмечен, что позволяет пользователям создавать разделы с "
"нестроковыми именами. Такое поведение не поддерживается и может вызвать "
"внутренние ошибки."

#: ../../library/configparser.rst:1284
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Если данный раздел существует, установите для данной опции указанное "
"значение; в противном случае поднимите :exc:`NoSectionError`. Хотя можно "
"использовать :class:`RawConfigParser` (или :class:`ConfigParser` с "
"параметрами *raw*, установленными в true) для *внутреннего* хранения "
"нестроковых значений, полная функциональность (включая интерполяцию и вывод "
"в файлы) может быть достигнуто только с использованием строковых значений."

#: ../../library/configparser.rst:1291
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Этот метод позволяет пользователям внутренне присваивать ключам нестроковые "
"значения. Такое поведение не поддерживается и приведет к ошибкам при попытке "
"записи в файл или получения его в режиме, отличном от необработанных. "
"**Используйте API протокола сопоставления**, который не позволяет выполнять "
"такие назначения."

#: ../../library/configparser.rst:1298
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/configparser.rst:1302
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Базовый класс для всех остальных исключений :mod:`configparser`."

#: ../../library/configparser.rst:1307
msgid "Exception raised when a specified section is not found."
msgstr "Исключение возникает, когда указанный раздел не найден."

#: ../../library/configparser.rst:1312
msgid ""
"Exception raised if :meth:`~ConfigParser.add_section` is called with the "
"name of a section that is already present or in strict parsers when a "
"section if found more than once in a single input file, string or dictionary."
msgstr ""
"Исключение возникает, если :meth:`~ConfigParser.add_section` вызывается с "
"именем уже существующего раздела или в строгих синтаксических анализаторах, "
"когда раздел найден более одного раза в одном входном файле, строке или "
"словаре."

#: ../../library/configparser.rst:1316
msgid ""
"Added the optional *source* and *lineno* attributes and parameters to :meth:"
"`!__init__`."
msgstr ""
"В :meth:`!__init__` добавлены необязательные атрибуты и параметры *source* и "
"*lineno*."

#: ../../library/configparser.rst:1323
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Исключение возникает строгими анализаторами, если одна опция появляется "
"дважды во время чтения из одного файла, строки или словаря. Это позволяет "
"выявить орфографические ошибки и ошибки, связанные с чувствительностью к "
"регистру, например, словарь может иметь два ключа, представляющих один и тот "
"же ключ конфигурации без учета регистра."

#: ../../library/configparser.rst:1331
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Исключение возникает, когда указанный параметр не найден в указанном разделе."

#: ../../library/configparser.rst:1337
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Базовый класс для исключений, возникающих при возникновении проблем при "
"интерполяции строк."

#: ../../library/configparser.rst:1343
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Исключение возникает, когда интерполяцию строк невозможно завершить, "
"поскольку количество итераций превышает :const:`MAX_INTERPOLATION_DEPTH`. "
"Подкласс :exc:`InterpolationError`."

#: ../../library/configparser.rst:1350
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Исключение возникает, когда параметр, на который ссылается значение, не "
"существует. Подкласс :exc:`InterpolationError`."

#: ../../library/configparser.rst:1356
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Исключение возникает, когда исходный текст, в который производятся замены, "
"не соответствует требуемому синтаксису. Подкласс :exc:`InterpolationError`."

#: ../../library/configparser.rst:1362
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Исключение возникает при попытке анализа файла, не имеющего заголовков "
"разделов."

#: ../../library/configparser.rst:1368
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "ошибок при попытке анализа файл"

#: ../../library/configparser.rst:1370
msgid ""
"The ``filename`` attribute and :meth:`!__init__` argument were renamed to "
"``source`` for consistency."
msgstr ""

#: ../../library/configparser.rst:1376
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/configparser.rst:1377
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""
"Анализаторы конфигурации допускают глубокую настройку. Если вы "
"заинтересованы в изменении поведения, описанного в сноске, обратитесь к "
"разделу «Настройка поведения анализатора»."

#: ../../library/configparser.rst:16
msgid ".ini"
msgstr ".ini"

#: ../../library/configparser.rst:16
msgid "file"
msgstr "файл"

#: ../../library/configparser.rst:16
msgid "configuration"
msgstr "конфигурация"

#: ../../library/configparser.rst:16
msgid "ini file"
msgstr "ini-файл"

#: ../../library/configparser.rst:16
msgid "Windows ini file"
msgstr "ini-файлы Windows"

#: ../../library/configparser.rst:335
msgid "% (percent)"
msgstr "% (процент)"

#: ../../library/configparser.rst:335 ../../library/configparser.rst:368
msgid "interpolation in configuration files"
msgstr "интерполяция в файлах конфигурации"

#: ../../library/configparser.rst:368
msgid "$ (dollar)"
msgstr "$ (доллар)"
