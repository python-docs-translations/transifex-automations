# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Jon Britva, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:19+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/socket.rst:2
msgid ":mod:`socket` --- Low-level networking interface"
msgstr ""

#: ../../library/socket.rst:7
msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**Исходный код:** :source:`Lib/socket.py`"

#: ../../library/socket.rst:11
msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"Этот модуль обеспечивает доступ к *сокетному* интерфейсу BSD. Он доступен на "
"всех современных системах Unix, Windows, MacOS и, возможно, на "
"дополнительных платформах."

#: ../../library/socket.rst:16
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"Некоторое поведение может зависеть от платформы, поскольку выполняются "
"вызовы API-интерфейсов сокетов операционной системы."

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Этот модуль не работает или недоступен на платформах WebAssembly «wasm32-"
"emscripten» и «wasm32-wasi». См. :ref:`wasm-availability` для получения "
"дополнительной информации."

#: ../../library/socket.rst:24
msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`~socket.socket` function returns a :dfn:`socket object` whose "
"methods implement the various socket system calls.  Parameter types are "
"somewhat higher-level than in the C interface: as with :meth:`read` and :"
"meth:`write` operations on Python files, buffer allocation on receive "
"operations is automatic, and buffer length is implicit on send operations."
msgstr ""
"Интерфейс Python представляет собой прямую транслитерацию системного вызова "
"Unix и библиотечного интерфейса для сокетов в объектно-ориентированном стиле "
"Python: функция :func:`~socket.socket` возвращает объект :dfn:`socket`, "
"методы которого реализуют различные сокеты. системные вызовы. Типы "
"параметров являются несколько более высокоуровневыми, чем в интерфейсе C: "
"как и в случае с операциями :meth:`read` и :meth:`write` в файлах Python, "
"выделение буфера при операциях приема происходит автоматически, а длина "
"буфера неявно задается при операциях отправки."

#: ../../library/socket.rst:36
msgid "Module :mod:`socketserver`"
msgstr "Модуль :mod:`socketserver`"

#: ../../library/socket.rst:36
msgid "Classes that simplify writing network servers."
msgstr "Классы, упрощающие написание сетевых серверов."

#: ../../library/socket.rst:38
msgid "Module :mod:`ssl`"
msgstr "Модуль :mod:`ssl`"

#: ../../library/socket.rst:39
msgid "A TLS/SSL wrapper for socket objects."
msgstr "Оболочка TLS/SSL для объектов сокетов."

#: ../../library/socket.rst:43
msgid "Socket families"
msgstr "Семейства сокетов"

#: ../../library/socket.rst:45
msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"В зависимости от системы и вариантов сборки этот модуль поддерживает "
"различные семейства сокетов."

#: ../../library/socket.rst:48
msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"Формат адреса, требуемый для конкретного объекта сокета, автоматически "
"выбирается на основе семейства адресов, указанного при создании объекта "
"сокета. Адреса сокетов представлены следующим образом:"

#: ../../library/socket.rst:52
msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"Адрес сокета :const:`AF_UNIX`, привязанного к узлу файловой системы, "
"представлен в виде строки с использованием кодировки файловой системы и "
"обработчика ошибок ``'surrogateescape'`` (см. :pep:`383`). Адрес в "
"абстрактном пространстве имен Linux возвращается как :term:`bytes-like "
"object` с начальным нулевым байтом; обратите внимание, что сокеты в этом "
"пространстве имен могут взаимодействовать с обычными сокетами файловой "
"системы, поэтому программам, предназначенным для работы в Linux, возможно, "
"придется иметь дело с обоими типами адресов. Строковый или байтовый объект "
"можно использовать для любого типа адреса при передаче его в качестве "
"аргумента."

#: ../../library/socket.rst:62
msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"Ранее предполагалось, что пути сокетов :const:`AF_UNIX` используют кодировку "
"UTF-8."

#: ../../library/socket.rst:66 ../../library/socket.rst:1049
#: ../../library/socket.rst:1091 ../../library/socket.rst:1851
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Доступный для записи :term:`байтовый объект` теперь принимается."

#: ../../library/socket.rst:71
msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"Пара ``(хост, порт)`` используется для семейства адресов :const:`AF_INET`, "
"где *host* — это строка, представляющая либо имя хоста в нотации интернет-"
"домена, например ``'daring.cwi.nl'` ` или IPv4-адрес, например "
"``'100.50.200.5'``, а *port* — целое число."

#: ../../library/socket.rst:76
msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"Для адресов IPv4 вместо адреса хоста принимаются две специальные формы: "
"``''`` представляет собой :const:`INADDR_ANY`, который используется для "
"привязки ко всем интерфейсам, и строку ``'<broadcast>'`` представляет :const:"
"`INADDR_BROADCAST`. Такое поведение несовместимо с IPv6, поэтому вам следует "
"избегать его, если вы собираетесь поддерживать IPv6 в своих программах "
"Python."

#: ../../library/socket.rst:83
msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"Для семейства адресов :const:`AF_INET6` используется четырёхкортеж ``(host, "
"port,flowinfo,scope_id)``, где *flowinfo* и *scope_id* представляют "
"``sin6_flowinfo`` и ``sin6_scope_id` ` члены в :const:`struct sockaddr_in6` "
"в C. Для методов модуля :mod:`socket` *flowinfo* и *scope_id* можно опустить "
"только для обратной совместимости. Однако обратите внимание, что отсутствие "
"*scope_id* может вызвать проблемы при управлении IPv6-адресами с "
"ограниченной областью действия."

#: ../../library/socket.rst:90
msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"Для адресов многоадресной рассылки (со значащим *scope_id*) *адрес* не может "
"содержать `` %s «cope_id» (или «идентификатор зоны»). Эта информация "
"является лишней и ее можно безопасно опустить (рекомендуется)."

#: ../../library/socket.rst:95
msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` сокеты представлены парами ``(pid, groups)``."

#: ../../library/socket.rst:97
msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"Поддержка TIPC только в Linux доступна с использованием семейства адресов :"
"const:`AF_TIPC`. TIPC — это открытый сетевой протокол, не основанный на IP, "
"предназначенный для использования в кластерных компьютерных средах. Адреса "
"представлены кортежем, а поля зависят от типа адреса. Общая форма кортежа: "
"``(addr_type, v1, v2, v3 [,scope])``, где:"

#: ../../library/socket.rst:103
msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."

#: ../../library/socket.rst:105
msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* является одним из :const:`TIPC_ZONE_SCOPE`, :const:"
"`TIPC_CLUSTER_SCOPE` и :const:`TIPC_NODE_SCOPE`."

#: ../../library/socket.rst:107
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"Если *addr_type* равен :const:`TIPC_ADDR_NAME`, то *v1* — это тип сервера, "
"*v2* — идентификатор порта, а *v3* должно быть равно 0."

#: ../../library/socket.rst:110
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"Если *addr_type* имеет значение :const:`TIPC_ADDR_NAMESEQ`, то *v1* — это "
"тип сервера, *v2* — нижний номер порта, а *v3* — верхний номер порта."

#: ../../library/socket.rst:113
msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"Если *addr_type* равен :const:`TIPC_ADDR_ID`, то *v1* — это узел, *v2* — это "
"ссылка, а *v3* должно быть установлено в 0."

#: ../../library/socket.rst:116
msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"Кортеж ``(interface, )`` используется для семейства адресов :const:`AF_CAN`, "
"где *interface* — это строка, представляющая имя сетевого интерфейса, "
"например ``'can0'``. Имя сетевого интерфейса ``''`` может использоваться для "
"получения пакетов от всех сетевых интерфейсов этого семейства."

#: ../../library/socket.rst:121
msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
"Для протокола :const:`CAN_ISOTP` требуется кортеж ``(interface, rx_addr, "
"tx_addr)``, где оба дополнительных параметра представляют собой длинное "
"целое число без знака, представляющее CAN-идентификатор (стандартный или "
"расширенный)."

#: ../../library/socket.rst:124
msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
":const:`Протокол CAN_J1939` требует кортежа ``(interface, name, pgn, "
"addr)``, где дополнительными параметрами являются 64-битное целое число без "
"знака, представляющее имя ЭБУ, 32-битное целое число без знака, "
"представляющее номер группы параметров (PGN). ) и 8-битное целое число, "
"представляющее адрес."

#: ../../library/socket.rst:129
msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""
"Строка или кортеж ``(id, unit)`` используется для протокола :const:"
"`SYSPROTO_CONTROL` семейства :const:`PF_SYSTEM`. Эта строка представляет "
"собой имя элемента управления ядра с использованием динамически назначаемого "
"идентификатора. Кортеж можно использовать, если известны идентификатор и "
"номер устройства управления ядром или если используется зарегистрированный "
"идентификатор."

#: ../../library/socket.rst:137
msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ""
":const:`AF_BLUETOOTH` поддерживает следующие протоколы и форматы адресов:"

#: ../../library/socket.rst:140
msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` принимает ``(bdaddr, psm)``, где ``bdaddr`` — это "
"адрес Bluetooth в виде строки, а ``psm`` — целое число."

#: ../../library/socket.rst:143
msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` принимает ``(bdaddr, канал)``, где ``bdaddr`` — это "
"адрес Bluetooth в виде строки, а ``канал`` — целое число."

#: ../../library/socket.rst:146
msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` принимает ``(device_id,)``, где ``device_id`` — это "
"целое число или строка с адресом Bluetooth интерфейса. (Это зависит от вашей "
"ОС; NetBSD и DragonFlyBSD ожидают адрес Bluetooth, а все остальное ожидает "
"целое число.)"

#: ../../library/socket.rst:151
msgid "NetBSD and DragonFlyBSD support added."
msgstr "Добавлена ​​поддержка NetBSD и DragonFlyBSD."

#: ../../library/socket.rst:154
msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` принимает ``bdaddr``, где ``bdaddr`` — это объект :"
"class:`bytes`, содержащий адрес Bluetooth в строковом формате. (например, "
"``b'12:23:34:45:56:67'``) Этот протокол не поддерживается FreeBSD."

#: ../../library/socket.rst:159
msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` — это основанный на сокетах интерфейс для шифрования ядра, "
"предназначенный только для Linux. Сокет алгоритма настраивается с помощью "
"кортежа из двух-четырех элементов ``(type, name [, feat [, Mask]])``, где:"

#: ../../library/socket.rst:163
msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* — это тип алгоритма в виде строки, например, ``aad``, ``hash``, "
"``skcipher`` или ``rng``."

#: ../../library/socket.rst:166
msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*name* — это имя алгоритма и режим работы в виде строки, например "
"``sha256``, ``hmac(sha256)``, ``cbc(aes)`` или ``drbg_nopr_ctr_aes256``."

#: ../../library/socket.rst:169
msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* и *mask* — 32-битные целые числа без знака."

#: ../../library/socket.rst:171 ../../library/socket.rst:525
#: ../../library/socket.rst:1773
msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.6.38."

#: ../../library/socket.rst:173
msgid "Some algorithm types require more recent Kernels."
msgstr "Для некоторых типов алгоритмов требуются более свежие ядра."

#: ../../library/socket.rst:177
msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` обеспечивает связь между виртуальными машинами и их "
"хостами. Сокеты представлены в виде кортежа «(CID, порт)», где идентификатор "
"контекста или CID и порт являются целыми числами."

#: ../../library/socket.rst:181 ../../library/socket.rst:598
msgid ":ref:`Availability <availability>`: Linux >= 3.9"
msgstr ":ref:`Доступность <доступность>`: Linux >= 3.9"

#: ../../library/socket.rst:183
msgid "See :manpage:`vsock(7)`"
msgstr "См. :manpage:`vsock(7)`"

#: ../../library/socket.rst:187
msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"addresses are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` — это низкоуровневый интерфейс непосредственно с сетевыми "
"устройствами. Адреса представлены кортежем ``(ifname, proto[, pkttype[, "
"hatype[, addr]]])``, где:"

#: ../../library/socket.rst:191
msgid "*ifname* - String specifying the device name."
msgstr "*ifname* — строка, определяющая имя устройства."

#: ../../library/socket.rst:192
msgid "*proto* - An integer specifying the Ethernet protocol number."
msgstr ""

#: ../../library/socket.rst:193
msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* — необязательное целое число, определяющее тип пакета:"

#: ../../library/socket.rst:195
msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr "``PACKET_HOST`` (по умолчанию) — пакет, адресованный локальному хосту."

#: ../../library/socket.rst:196
msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` — широковещательный пакет физического уровня."

#: ../../library/socket.rst:197
msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr ""
"``PACKET_MULTICAST`` — пакет отправлен на адрес многоадресной рассылки "
"физического уровня."

#: ../../library/socket.rst:198
msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` — пакет на другой хост, который был перехвачен "
"драйвером устройства в неразборчивом режиме."

#: ../../library/socket.rst:200
msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""
"``PACKET_OUTGOING`` — пакет, исходящий от локального хоста, который "
"возвращается обратно в пакетный сокет."

#: ../../library/socket.rst:202
msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr ""
"*hatype* — необязательное целое число, определяющее тип аппаратного адреса "
"ARP."

#: ../../library/socket.rst:203
msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""
"*addr* — дополнительный байтовый объект, определяющий физический адрес "
"оборудования, интерпретация которого зависит от устройства."

#: ../../library/socket.rst:206 ../../library/socket.rst:486
msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.2."

#: ../../library/socket.rst:208
msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` — это интерфейс на основе сокетов, предназначенный "
"только для Linux, для связи со службами, работающими на сопроцессорах "
"платформ Qualcomm. Семейство адресов представлено в виде кортежа ``(node, "
"port)``, где *node* и *port* являются неотрицательными целыми числами."

#: ../../library/socket.rst:213 ../../library/socket.rst:574
msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ""
":ref:`Наличие\n"
"`: Linux >= 4.7."

#: ../../library/socket.rst:217
msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` — это вариант UDP, который позволяет вам указать, "
"какая часть пакета покрывается контрольной суммой. Он добавляет два "
"параметра сокета, которые вы можете изменить. ``self."
"setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, length)`` изменит, какая "
"часть исходящих пакетов покрывается контрольной суммой, а ``self."
"setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` отфильтрует "
"пакеты, которые покрывают слишком малую часть их данные. В обоих случаях "
"длина должна находиться в диапазоне (8, 2**16, 8)``."

#: ../../library/socket.rst:226
msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"Такой сокет должен быть создан с помощью ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` для IPv4 или ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` для IPv6."

#: ../../library/socket.rst:230
msgid ":ref:`Availability <availability>`: Linux >= 2.6.20, FreeBSD >= 10.1"
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.6.20, FreeBSD >= 10.1"

#: ../../library/socket.rst:234
msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"Если вы используете имя хоста в части *host* адреса сокета IPv4/v6, "
"программа может демонстрировать недетерминированное поведение, поскольку "
"Python использует первый адрес, возвращенный в результате разрешения DNS. "
"Адрес сокета будет преобразован в фактический адрес IPv4/v6 по-разному, в "
"зависимости от результатов разрешения DNS и/или конфигурации хоста. Для "
"детерминированного поведения используйте числовой адрес в части *host*."

#: ../../library/socket.rst:241
msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"Все ошибки вызывают исключения. Могут быть вызваны обычные исключения для "
"недопустимых типов аргументов и условий нехватки памяти. Ошибки, связанные с "
"семантикой сокета или адреса, вызывают :exc:`OSError` или один из его "
"подклассов."

#: ../../library/socket.rst:246
msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"Неблокирующий режим поддерживается через :meth:`~socket.setblocking`. "
"Обобщение этого на основе таймаутов поддерживается через :meth:`~socket."
"settimeout`."

#: ../../library/socket.rst:252
msgid "Module contents"
msgstr "Содержимое модуля"

#: ../../library/socket.rst:254
msgid "The module :mod:`socket` exports the following elements."
msgstr "Модуль :mod:`socket` экспортирует следующие элементы."

#: ../../library/socket.rst:258
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/socket.rst:262
msgid "A deprecated alias of :exc:`OSError`."
msgstr "Устаревший псевдоним :exc:`OSError`."

#: ../../library/socket.rst:264
msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr "После :pep:`3151` этому классу был присвоен псевдоним :exc:`OSError`."

#: ../../library/socket.rst:270
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
"Подкласс :exc:`OSError`, это исключение вызывается для ошибок, связанных с "
"адресом, то есть для функций, которые используют *h_errno* в POSIX C API, "
"включая :func:`gethostbyname_ex` и :func:`gethostbyaddr`. Сопутствующее "
"значение — это пара (h_errno, string)», представляющая ошибку, возвращаемую "
"вызовом библиотеки. *h_errno* — это числовое значение, а *string* "
"представляет собой описание *h_errno*, возвращаемое функцией C :c:func:"
"`hstrerror`."

#: ../../library/socket.rst:278 ../../library/socket.rst:291
#: ../../library/socket.rst:304
msgid "This class was made a subclass of :exc:`OSError`."
msgstr "Этот класс стал подклассом :exc:`OSError`."

#: ../../library/socket.rst:283
msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`!EAI_\\*` constants defined in this module."
msgstr ""
"Подкласс :exc:`OSError`, это исключение вызывается для ошибок, связанных с "
"адресом, :func:`getaddrinfo` и :func:`getnameinfo`. Сопутствующее значение "
"представляет собой пару ``(error, string)``, представляющую ошибку, "
"возвращаемую вызовом библиотеки. *строка* представляет описание *ошибки*, "
"возвращаемое функцией C :c:func:`gai_strerror`. Числовое значение *error* "
"будет соответствовать одной из констант :const:`!EAI_\\*`, определенных в "
"этом модуле."

#: ../../library/socket.rst:296
msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr "Устаревший псевдоним :exc:`TimeoutError`."

#: ../../library/socket.rst:298
msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
"Подкласс :exc:`OSError`, это исключение возникает, когда тайм-аут происходит "
"в сокете, для которого тайм-ауты были включены посредством предварительного "
"вызова :meth:`~socket.settimeout` (или неявно через :func:`~socket ."
"setdefaulttimeout`). Сопутствующее значение представляет собой строку, "
"значение которой в настоящее время всегда истекло."

#: ../../library/socket.rst:307
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Этот класс стал псевдонимом :exc:`TimeoutError`."

#: ../../library/socket.rst:312
msgid "Constants"
msgstr "Константы"

#: ../../library/socket.rst:314
msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"Константы AF_* и SOCK_* теперь представляют собой коллекции :class:"
"`AddressFamily` и :class:`SocketKind` :class:`.IntEnum`."

#: ../../library/socket.rst:323
msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`~socket.socket`.  If the :const:`AF_UNIX` constant "
"is not defined then this protocol is unsupported.  More constants may be "
"available depending on the system."
msgstr ""
"Эти константы представляют семейства адресов (и протоколов), используемые в "
"качестве первого аргумента :func:`~socket.socket`. Если константа :const:"
"`AF_UNIX` не определена, этот протокол не поддерживается. В зависимости от "
"системы могут быть доступны дополнительные константы."

#: ../../library/socket.rst:330
msgid ""
":const:`AF_UNSPEC` means that :func:`getaddrinfo` should return socket "
"addresses for any address family (either IPv4, IPv6, or any other) that can "
"be used."
msgstr ""
":const:`AF_UNSPEC` означает, что :func:`getaddrinfo` должен возвращать "
"адреса сокетов для любого семейства адресов (IPv4, IPv6 или любого другого), "
"которое можно использовать."

#: ../../library/socket.rst:340
msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`~socket.socket`.  More constants may be available depending on the "
"system. (Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be "
"generally useful.)"
msgstr ""
"Эти константы представляют типы сокетов, используемые в качестве второго "
"аргумента :func:`~socket.socket`. В зависимости от системы могут быть "
"доступны дополнительные константы. (Только :const:`SOCK_STREAM` и :const:"
"`SOCK_DGRAM` кажутся обычно полезными.)"

#: ../../library/socket.rst:348
msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"Эти две константы, если они определены, могут быть объединены с типами "
"сокетов и позволяют устанавливать некоторые флаги атомарно (таким образом "
"избегая возможных состояний гонки и необходимости отдельных вызовов)."

#: ../../library/socket.rst:354
msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""
"`Безопасная обработка файловых дескрипторов <https://udrepper.livejournal."
"com/20407.html>`_ для более подробного объяснения."

#: ../../library/socket.rst:357
msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.6.27."

#: ../../library/socket.rst:378
msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`~socket.setsockopt` and :meth:"
"`~socket.getsockopt` methods of socket objects.  In most cases, only those "
"symbols that are defined in the Unix header files are defined; for a few "
"symbols, default values are provided."
msgstr ""
"Многие константы этих форм, описанные в документации Unix по сокетам и/или "
"протоколу IP, также определены в модуле сокета. Обычно они используются в "
"аргументах методов :meth:`~socket.setsockopt` и :meth:`~socket.getsockopt` "
"объектов сокетов. В большинстве случаев определяются только те символы, "
"которые определены в файлах заголовков Unix; для некоторых символов указаны "
"значения по умолчанию."

#: ../../library/socket.rst:385
msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"Добавлены ``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION``."

#: ../../library/socket.rst:389
msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"В Windows появляются ``TCP_FASTOPEN``, ``TCP_KEEPCNT``, если их поддерживает "
"среда выполнения Windows."

#: ../../library/socket.rst:393
msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT`` был добавлен."

#: ../../library/socket.rst:396
msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"В Windows ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` появляются, если Windows "
"поддерживает их во время выполнения."

#: ../../library/socket.rst:399
msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"Добавлен ``IP_RECVTOS``. Добавлен TCP_KEEPALIVE. В MacOS эту константу можно "
"использовать так же, как TCP_KEEPIDLE в Linux."

#: ../../library/socket.rst:404
msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""
"Добавлен ``TCP_CONNECTION_INFO``. В MacOS эту константу можно использовать "
"так же, как TCP_INFO в Linux и BSD."

#: ../../library/socket.rst:413 ../../library/socket.rst:483
#: ../../library/socket.rst:494
msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Многие константы этих форм, описанные в документации Linux, также определены "
"в модуле сокета."

#: ../../library/socket.rst:416
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.6.25, NetBSD >= 8."

#: ../../library/socket.rst:420
msgid "NetBSD support was added."
msgstr "Добавлена ​​поддержка NetBSD."

#: ../../library/socket.rst:426
msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM в семействе протоколов CAN является протоколом диспетчера "
"широковещания (BCM). Константы менеджера вещания, описанные в документации "
"Linux, также определены в модуле сокета."

#: ../../library/socket.rst:430 ../../library/socket.rst:465
msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.6.25."

#: ../../library/socket.rst:433
msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr "Флаг :data:`CAN_BCM_CAN_FD_FRAME` доступен только в Linux >= 4.8."

#: ../../library/socket.rst:439
msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"Включает поддержку CAN FD в разъеме CAN_RAW. По умолчанию это отключено. Это "
"позволяет вашему приложению отправлять кадры CAN и CAN FD; однако при чтении "
"из сокета вы должны принимать кадры CAN и CAN FD."

#: ../../library/socket.rst:443 ../../library/socket.rst:454
msgid "This constant is documented in the Linux documentation."
msgstr "Эта константа описана в документации Linux."

#: ../../library/socket.rst:445
msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`Доступность <доступность>`: Linux >= 3.6."

#: ../../library/socket.rst:451
msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"Объединяет примененные фильтры CAN таким образом, что в пространство "
"пользователя передаются только кадры CAN, соответствующие всем заданным "
"фильтрам CAN."

#: ../../library/socket.rst:456
msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`Доступность <доступность>`: Linux >= 4.1."

#: ../../library/socket.rst:462
msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP в семействе протоколов CAN — это протокол ISO-TP (ISO 15765-2). "
"Константы ISO-TP, описанные в документации Linux."

#: ../../library/socket.rst:471
msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939, в семействе протоколов CAN, представляет собой протокол SAE "
"J1939. Константы J1939, описанные в документации Linux."

#: ../../library/socket.rst:474
msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`Доступность <доступность>`: Linux >= 5.4."

#: ../../library/socket.rst:497
msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`Доступность <доступность>`: Linux >= 2.6.30."

#: ../../library/socket.rst:507
msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Константы для Windows WSAIoctl(). Константы используются в качестве "
"аргументов метода :meth:`~socket.socket.ioctl` объектов сокета."

#: ../../library/socket.rst:510 ../../library/socket.rst:1464
msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "Был добавлен ``SIO_LOOPBACK_FAST_PATH``."

#: ../../library/socket.rst:516
msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"Константы, связанные с TIPC, соответствующие константам, экспортированным "
"через API сокетов C. Дополнительную информацию см. в документации TIPC."

#: ../../library/socket.rst:523
msgid "Constants for Linux Kernel cryptography."
msgstr "Константы для криптографии ядра Linux."

#: ../../library/socket.rst:535
msgid "Constants for Linux host/guest communication."
msgstr "Константы для связи между хостом и гостем Linux."

#: ../../library/socket.rst:537
msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`Доступность <доступность>`: Linux >= 4.8."

#: ../../library/socket.rst:543
msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ":ref:`Доступность <доступность>`: BSD, macOS."

#: ../../library/socket.rst:549
msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr ""
"Эта константа содержит логическое значение, которое указывает, "
"поддерживается ли IPv6 на этой платформе."

#: ../../library/socket.rst:555
msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"Это строковые константы, содержащие адреса Bluetooth со специальным "
"значением. Например, :const:`BDADDR_ANY` можно использовать для указания "
"любого адреса при указании сокета привязки с помощью :const:`BTPROTO_RFCOMM`."

#: ../../library/socket.rst:564
msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"Для использования с :const:`BTPROTO_HCI`. :const:`HCI_FILTER` недоступен для "
"NetBSD или DragonFlyBSD. :const:`HCI_TIME_STAMP` и :const:`HCI_DATA_DIR` "
"недоступны для FreeBSD, NetBSD или DragonFlyBSD."

#: ../../library/socket.rst:571
msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""
"Константа для протокола маршрутизатора Qualcomm IPC, используемая для связи "
"с удаленными процессорами, предоставляющими услуги."

#: ../../library/socket.rst:580
msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""
"LOCAL_CREDS и LOCAL_CREDS_PERSISTENT могут использоваться с сокетами "
"SOCK_DGRAM, SOCK_STREAM, что эквивалентно Linux/DragonFlyBSD SO_PASSCRED, в "
"то время как LOCAL_CREDS отправляет учетные данные при первом чтении, "
"LOCAL_CREDS_PERSISTENT отправляет при каждом чтении, затем для последнего "
"необходимо использовать SCM_CREDS2 для типа сообщения."

#: ../../library/socket.rst:589
msgid ":ref:`Availability <availability>`: FreeBSD."
msgstr ":ref:`Availability <availability>`: FreeBSD."

#: ../../library/socket.rst:593
msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr ""
"Константа для оптимизации локальности ЦП, которая будет использоваться "
"вместе с :data:`SO_REUSEPORT`."

#: ../../library/socket.rst:601
msgid "Functions"
msgstr "Функции"

#: ../../library/socket.rst:604
msgid "Creating sockets"
msgstr "Создание сокетов"

#: ../../library/socket.rst:606
msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "Все следующие функции создают :ref:`объекты сокетов <socket-objects>`."

#: ../../library/socket.rst:611
msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"Создайте новый сокет, используя заданное семейство адресов, тип сокета и "
"номер протокола. Семейство адресов должно быть :const:`AF_INET` (по "
"умолчанию), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:"
"`AF_PACKET` или :const:`AF_RDS. `. Тип сокета должен быть :const:"
"`SOCK_STREAM` (по умолчанию), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` или, "
"возможно, одной из других констант ``SOCK_``. Номер протокола обычно равен "
"нулю и может быть опущен, или в случае, когда семейство адресов :const:"
"`AF_CAN`, протокол должен быть одним из :const:`CAN_RAW`, :const:`CAN_BCM`, :"
"const:`CAN_ISOTP` ` или :const:`CAN_J1939`."

#: ../../library/socket.rst:621
msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""

#: ../../library/socket.rst:630 ../../library/socket.rst:776
#: ../../library/socket.rst:1283 ../../library/socket.rst:1377
msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "Вновь созданный сокет является :ref:`ненаследуемым <fd_inheritance>`."

#: ../../library/socket.rst:643
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"Вызывает событие аудита <auditing>` ``socket.__new__`` с аргументами "
"``self``, ``family``, ``type``, ``protocol``."

#: ../../library/socket.rst:634
msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "Добавлено семейство AF_CAN. Добавлено семейство AF_RDS."

#: ../../library/socket.rst:638
msgid "The CAN_BCM protocol was added."
msgstr "Был добавлен протокол CAN_BCM."

#: ../../library/socket.rst:641 ../../library/socket.rst:778
msgid "The returned socket is now non-inheritable."
msgstr "Возвращенный сокет теперь не наследуется."

#: ../../library/socket.rst:644
msgid "The CAN_ISOTP protocol was added."
msgstr "Был добавлен протокол CAN_ISOTP."

#: ../../library/socket.rst:647
msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""
"Когда битовые флаги :const:`SOCK_NONBLOCK` или :const:`SOCK_CLOEXEC` "
"применяются к *type*, они очищаются, и :attr:`socket.type` не будет их "
"отражать. Они по-прежнему передаются базовому системному вызову Socket(). "
"Поэтому,"

#: ../../library/socket.rst:659
msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"по-прежнему создаст неблокирующий сокет в ОС, поддерживающих SOCK_NONBLOCK, "
"но для sock.type будет установлено значение socket.SOCK_STREAM."

#: ../../library/socket.rst:663
msgid "The CAN_J1939 protocol was added."
msgstr "Добавлен протокол CAN_J1939."

#: ../../library/socket.rst:666
msgid "The IPPROTO_MPTCP protocol was added."
msgstr "Добавлен протокол IPPROTO_MPTCP."

#: ../../library/socket.rst:671
msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`~socket.socket` function above. The default "
"family is :const:`AF_UNIX` if defined on the platform; otherwise, the "
"default is :const:`AF_INET`."
msgstr ""
"Создайте пару связанных объектов сокета, используя заданное семейство "
"адресов, тип сокета и номер протокола. Семейство адресов, тип сокета и номер "
"протокола такие же, как для функции :func:`~socket.socket` выше. Семейством "
"по умолчанию является :const:`AF_UNIX`, если оно определено на платформе; в "
"противном случае значением по умолчанию является :const:`AF_INET`."

#: ../../library/socket.rst:676
msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr ""
"Вновь созданные сокеты являются :ref:`ненаследуемыми <fd_inheritance>`."

#: ../../library/socket.rst:678
msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"Возвращенные объекты сокетов теперь поддерживают весь API сокетов, а не его "
"подмножество."

#: ../../library/socket.rst:682
msgid "The returned sockets are now non-inheritable."
msgstr "Возвращенные сокеты теперь не наследуются."

#: ../../library/socket.rst:685
msgid "Windows support added."
msgstr "Добавлена поддержка Windows."

#: ../../library/socket.rst:691
msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"Подключитесь к службе TCP, прослушивающей Интернет *адрес* (двухкортежный "
"``(хост, порт)``) и верните объект сокета. Это функция более высокого "
"уровня, чем :meth:`socket.connect`: если *host* — нечисловое имя хоста, она "
"попытается разрешить его как для :data:`AF_INET`, так и для :data:"
"`AF_INET6`, а затем попытайтесь подключиться ко всем возможным адресам по "
"очереди, пока соединение не будет успешным. Это упрощает создание клиентов, "
"совместимых как с IPv4, так и с IPv6."

#: ../../library/socket.rst:699
msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"Передача необязательного параметра *timeout* установит тайм-аут экземпляра "
"сокета перед попыткой подключения. Если *timeout* не указан, используется "
"глобальная настройка таймаута по умолчанию, возвращаемая :func:"
"`getdefaulttimeout`."

#: ../../library/socket.rst:704
msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"Если указано, *source_address* должен быть двухкортежным ``(host, port)``, "
"чтобы сокет мог привязаться к нему в качестве исходного адреса перед "
"подключением. Если хост или порт равны '' или 0 соответственно, будет "
"использоваться поведение ОС по умолчанию."

#: ../../library/socket.rst:708
msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""
"Если соединение не может быть создано, возникает исключение. По умолчанию "
"это исключение из последнего адреса в списке. Если *all_errors* имеет "
"значение True, это :exc:`ExceptionGroup`, содержащий ошибки всех попыток."

#: ../../library/socket.rst:713
msgid "*source_address* was added."
msgstr "Был добавлен *адрес_источника*."

#: ../../library/socket.rst:716
msgid "*all_errors* was added."
msgstr "Добавлено *all_errors*."

#: ../../library/socket.rst:722
msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and return the socket object."
msgstr ""

#: ../../library/socket.rst:725
msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; if not specified , a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""
"*семейство* должно быть либо :data:`AF_INET`, либо :data:`AF_INET6`. "
"*backlog* — размер очереди, передаваемой в :meth:`socket.listen`; если не "
"указано, выбирается разумное значение по умолчанию. *reuse_port* определяет, "
"устанавливать ли опцию сокета :data:`SO_REUSEPORT`."

#: ../../library/socket.rst:730
msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""
"Если *dualstack_ipv6* имеет значение true и платформа поддерживает его, "
"сокет сможет принимать соединения как IPv4, так и IPv6, в противном случае "
"будет выдано :exc:`ValueError`. Предполагается, что большинство платформ "
"POSIX и Windows поддерживают эту функцию. Когда эта функция включена, адрес, "
"возвращаемый :meth:`socket.getpeername` при возникновении IPv4-соединения, "
"будет адресом IPv6, представленным как IPv6-адрес, сопоставленный с IPv4. "
"Если *dualstack_ipv6* имеет значение false, эта функция будет явно отключена "
"на платформах, которые включают ее по умолчанию (например, Linux). Этот "
"параметр можно использовать вместе с :func:`has_dualstack_ipv6`:"

#: ../../library/socket.rst:752
msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"На платформах POSIX опция сокета :data:`SO_REUSEADDR` установлена ​​для "
"немедленного повторного использования предыдущих сокетов, которые были "
"привязаны к тому же *адресу* и оставались в состоянии TIME_WAIT."

#: ../../library/socket.rst:760
msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"Верните True, если платформа поддерживает создание TCP-сокета, который может "
"обрабатывать соединения как IPv4, так и IPv6."

#: ../../library/socket.rst:767
msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`~io.IOBase.fileno` method) and build a socket object from "
"the result.  Address family, socket type and protocol number are as for the :"
"func:`~socket.socket` function above. The file descriptor should refer to a "
"socket, but this is not checked --- subsequent operations on the object may "
"fail if the file descriptor is invalid. This function is rarely needed, but "
"can be used to get or set socket options on a socket passed to a program as "
"standard input or output (such as a server started by the Unix inet "
"daemon).  The socket is assumed to be in blocking mode."
msgstr ""
"Дублируйте дескриптор файла *fd* (целое число, возвращаемое методом :meth:"
"`~io.IOBase.fileno` файлового объекта) и создайте объект сокета из "
"результата. Семейство адресов, тип сокета и номер протокола такие же, как "
"для функции :func:`~socket.socket` выше. Дескриптор файла должен ссылаться "
"на сокет, но это не проверяется — последующие операции с объектом могут "
"завершиться неудачно, если дескриптор файла недействителен. Эта функция "
"требуется редко, но ее можно использовать для получения или установки "
"параметров сокета для сокета, передаваемого программе в качестве "
"стандартного ввода или вывода (например, сервер, запускаемый демоном inet "
"Unix). Предполагается, что сокет находится в блокирующем режиме."

#: ../../library/socket.rst:784
msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"Создайте экземпляр сокета на основе данных, полученных с помощью метода :"
"meth:`socket.share`. Предполагается, что сокет находится в блокирующем "
"режиме."

#: ../../library/socket.rst:787 ../../library/socket.rst:1879
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../library/socket.rst:794
msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"Это объект типа Python, который представляет тип объекта сокета. Это то же "
"самое, что и ``type(socket(...))``."

#: ../../library/socket.rst:799
msgid "Other functions"
msgstr "Другие функции"

#: ../../library/socket.rst:801
msgid "The :mod:`socket` module also offers various network-related services:"
msgstr "Модуль :mod:`socket` также предлагает различные сетевые сервисы:"

#: ../../library/socket.rst:806
msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"Закройте дескриптор файла сокета. Это похоже на :func:`os.close`, но для "
"сокетов. На некоторых платформах (наиболее заметно в Windows) :func:`os."
"close` не работает для дескрипторов файлов сокетов."

#: ../../library/socket.rst:814
msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"Переведите аргумент *host*/*port* в последовательность из 5 кортежей, "
"содержащих все необходимые аргументы для создания сокета, подключенного к "
"этой службе. *host* — это доменное имя, строковое представление адреса IPv4/"
"v6 или «Нет». *port* — это строковое имя службы, например http, числовой "
"номер порта или None. Передав None в качестве значения *host* и *port*, вы "
"можете передать NULL в базовый C API."

#: ../../library/socket.rst:821
msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"Аргументы *family*, *type* и *proto* можно указать дополнительно, чтобы "
"сузить список возвращаемых адресов. Передача нуля в качестве значения для "
"каждого из этих аргументов выбирает полный диапазон результатов. Аргумент "
"*flags* может быть одной или несколькими константами ``AI_*`` и будет влиять "
"на то, как результаты вычисляются и возвращаются. Например, :const:"
"`AI_NUMERICHOST` отключит разрешение доменного имени и выдаст ошибку, если "
"*host* является именем домена."

#: ../../library/socket.rst:829
msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "Функция возвращает список из 5 кортежей следующей структуры:"

#: ../../library/socket.rst:831
msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(family, type, proto, canonname, sockaddr)``"

#: ../../library/socket.rst:833
msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`~socket.socket` function.  *canonname* will be a "
"string representing the canonical name of the *host* if :const:"
"`AI_CANONNAME` is part of the *flags* argument; else *canonname* will be "
"empty.  *sockaddr* is a tuple describing a socket address, whose format "
"depends on the returned *family* (a ``(address, port)`` 2-tuple for :const:"
"`AF_INET`, a ``(address, port, flowinfo, scope_id)`` 4-tuple for :const:"
"`AF_INET6`), and is meant to be passed to the :meth:`socket.connect` method."
msgstr ""
"В этих кортежах *family*, *type*, *proto* являются целыми числами и "
"предназначены для передачи в функцию :func:`~socket.socket`. *canonname* "
"будет строкой, представляющей каноническое имя *хоста*, если :const:"
"`AI_CANONNAME` является частью аргумента *flags*; иначе *canonname* будет "
"пустым. *sockaddr* — это кортеж, описывающий адрес сокета, формат которого "
"зависит от возвращаемого *семейства* (2-кортеж ``(адрес, порт)`` для :const:"
"`AF_INET`, ``(адрес, порт, flowinfo,scope_id)`` 4-кортеж для :const:"
"`AF_INET6`), и предназначен для передачи в метод :meth:`socket.connect`."

#: ../../library/socket.rst:854
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``socket.getaddrinfo`` с "
"аргументами ``host``, ``port``, ``family``, ``type``, ``protocol`` ."

#: ../../library/socket.rst:845
msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"Следующий пример извлекает информацию об адресе для гипотетического TCP-"
"соединения с ``example.org`` через порт 80 (результаты могут отличаться в "
"вашей системе, если IPv6 не включен)::"

#: ../../library/socket.rst:855
msgid "parameters can now be passed using keyword arguments."
msgstr ""
"параметры теперь можно передавать с использованием аргументов ключевого "
"слова."

#: ../../library/socket.rst:858
msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""
"для адресов многоадресной рассылки IPv6 строка, представляющая адрес, не "
"будет содержать `` %s cope_id`` часть."

#: ../../library/socket.rst:864
msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"Верните полное доменное имя для *name*. Если *name* опущено или пусто, оно "
"интерпретируется как локальный хост. Чтобы найти полное имя, проверяется имя "
"хоста, возвращаемое :func:`gethostbyaddr`, а затем псевдонимы хоста, если "
"они доступны. Выбирается первое имя, включающее точку. Если полное доменное "
"имя недоступно и было указано *name*, оно возвращается без изменений. Если "
"*name* пусто или равно ``'0.0.0.0'``, возвращается имя хоста из :func:"
"`gethostname`."

#: ../../library/socket.rst:875
msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Переведите имя хоста в формат адреса IPv4. Адрес IPv4 возвращается в виде "
"строки, например ``'100.50.200.5'``. Если имя хоста само является адресом "
"IPv4, оно возвращается без изменений. См. :func:`gethostbyname_ex` для более "
"полного интерфейса. :func:`gethostbyname` не поддерживает разрешение имен "
"IPv6, и вместо этого следует использовать :func:`getaddrinfo` для поддержки "
"двойного стека IPv4/v6."

#: ../../library/socket.rst:892 ../../library/socket.rst:908
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.gethostbyname`` с "
"аргументом ``hostname``."

#: ../../library/socket.rst:883 ../../library/socket.rst:899
#: ../../library/socket.rst:912 ../../library/socket.rst:927
#: ../../library/socket.rst:944 ../../library/socket.rst:955
#: ../../library/socket.rst:966 ../../library/socket.rst:977
#: ../../library/socket.rst:1301 ../../library/socket.rst:1348
#: ../../library/socket.rst:1362 ../../library/socket.rst:1382
#: ../../library/socket.rst:1429 ../../library/socket.rst:1474
#: ../../library/socket.rst:1857 ../../library/socket.rst:1867
msgid ":ref:`Availability <availability>`: not WASI."
msgstr ":ref:`Availability <availability>`: not WASI."

#: ../../library/socket.rst:888
msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a 3-"
"tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Переведите имя хоста в формат адреса IPv4, расширенный интерфейс. Возвращает "
"трехкортеж ``(hostname, aliaslist, ipaddrlist)``, где *hostname* — это "
"основное имя хоста, *aliaslist* — это (возможно, пустой) список "
"альтернативных имен хостов для того же адреса, а *ipaddrlist* — это список "
"адресов IPv4 для одного и того же интерфейса на одном хосте (часто, но не "
"всегда, один адрес). :func:`gethostbyname_ex` не поддерживает разрешение "
"имен IPv6, и вместо этого следует использовать :func:`getaddrinfo` для "
"поддержки двойного стека IPv4/v6."

#: ../../library/socket.rst:904
msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Верните строку, содержащую имя хоста компьютера, на котором в данный момент "
"выполняется интерпретатор Python."

#: ../../library/socket.rst:918
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"Вызывает событие аудита <auditing>``socket.gethostname`` без аргументов."

#: ../../library/socket.rst:909
msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"Примечание. :func:`gethostname` не всегда возвращает полное доменное имя; "
"используйте для этого :func:`getfqdn`."

#: ../../library/socket.rst:917
msgid ""
"Return a 3-tuple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"Возвращает трехкортеж ``(hostname, aliaslist, ipaddrlist)``, где *hostname* "
"— это основное имя хоста, отвечающее на заданный *ip_адрес*, *aliaslist* — "
"это (возможно, пустой) список альтернативных имен хостов для того же самого "
"хоста. адрес, а *ipaddrlist* — это список адресов IPv4/v6 для одного и того "
"же интерфейса на одном хосте (скорее всего, содержащий только один адрес). "
"Чтобы найти полное доменное имя, используйте функцию :func:`getfqdn`. :func:"
"`gethostbyaddr` поддерживает как IPv4, так и IPv6."

#: ../../library/socket.rst:936
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.gethostbyaddr`` с "
"аргументом ``ip_address``."

#: ../../library/socket.rst:932
msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""
"Преобразуйте адрес сокета *sockaddr* в двухкортежный ``(хост, порт)``. В "
"зависимости от настроек *flags* результат может содержать полное доменное "
"имя или числовое представление адреса в *host*. Аналогично, *port* может "
"содержать строковое имя порта или числовой номер порта."

#: ../../library/socket.rst:937
msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"Для адресов IPv6 `` %s ope_id`` добавляется к части хоста, если *sockaddr* "
"содержит значимый *scope_id*. Обычно это происходит для групповых адресов."

#: ../../library/socket.rst:940
msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr ""
"Для получения дополнительной информации о *флагах* вы можете обратиться к :"
"manpage:`getnameinfo(3)`."

#: ../../library/socket.rst:953
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.getnameinfo`` с аргументом "
"``sockaddr``."

#: ../../library/socket.rst:949
msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`~socket."
"socket` function.  This is usually only needed for sockets opened in \"raw\" "
"mode (:const:`SOCK_RAW`); for the normal socket modes, the correct protocol "
"is chosen automatically if the protocol is omitted or zero."
msgstr ""
"Преобразуйте имя интернет-протокола (например, ``'icmp'``) в константу, "
"подходящую для передачи в качестве (необязательного) третьего аргумента "
"функции :func:`~socket.socket`. Обычно это необходимо только для сокетов, "
"открытых в «необработанном» режиме (:const:`SOCK_RAW`); для обычных режимов "
"сокетов правильный протокол выбирается автоматически, если протокол опущен "
"или равен нулю."

#: ../../library/socket.rst:960
msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Переведите имя интернет-службы и имя протокола в номер порта для этой "
"службы. Необязательное имя протокола, если оно указано, должно быть "
"``'tcp'`` или ``'udp'``, в противном случае подойдет любой протокол."

#: ../../library/socket.rst:975
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.getservbyname`` с "
"аргументами ``servicename``, ``protocolname``."

#: ../../library/socket.rst:971
msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Переведите номер интернет-порта и имя протокола в имя службы для этой "
"службы. Необязательное имя протокола, если оно указано, должно быть "
"``'tcp'`` или ``'udp'``, в противном случае подойдет любой протокол."

#: ../../library/socket.rst:986
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.getservbyport`` с "
"аргументами ``port``, ``protocolname``."

#: ../../library/socket.rst:982
msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Преобразование 32-битных положительных целых чисел из сетевого порядка "
"байтов в хостовый. На машинах, где порядок байтов хоста такой же, как "
"порядок байтов в сети, это недопустимо; в противном случае он выполняет "
"операцию замены 4 байтов."

#: ../../library/socket.rst:989
msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Преобразование 16-битных положительных целых чисел из сетевого порядка "
"байтов в хостовый. На машинах, где порядок байтов хоста такой же, как "
"порядок байтов в сети, это недопустимо; в противном случае он выполняет "
"операцию замены 2 байтов."

#: ../../library/socket.rst:993 ../../library/socket.rst:1011
msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr ""
"Вызывает :exc:`OverflowError`, если *x* не помещается в 16-битное целое "
"число без знака."

#: ../../library/socket.rst:1000
msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Преобразуйте 32-битные положительные целые числа из порядка байтов хоста в "
"сетевой. На машинах, где порядок байтов хоста такой же, как порядок байтов в "
"сети, это недопустимо; в противном случае он выполняет операцию замены 4 "
"байтов."

#: ../../library/socket.rst:1007
msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Преобразуйте 16-битные положительные целые числа из хостового в сетевой "
"порядок байтов. На машинах, где порядок байтов хоста такой же, как порядок "
"байтов в сети, это недопустимо; в противном случае он выполняет операцию "
"замены 2 байтов."

#: ../../library/socket.rst:1018
msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""
"Преобразуйте адрес IPv4 из формата четверки с точками (например, "
"«123.45.67.89») в 32-битный упакованный двоичный формат в виде байтового "
"объекта длиной четыре символа. Это полезно при общении с программой, которая "
"использует стандартную библиотеку C и нуждается в объектах типа :c:struct:"
"`in_addr`, который является типом C для 32-битного упакованного двоичного "
"файла, возвращаемого этой функцией."

#: ../../library/socket.rst:1024
msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` также принимает строки, содержащие менее трех точек; "
"подробности см. на странице руководства Unix :manpage:`inet(3)`."

#: ../../library/socket.rst:1027
msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"Если строка адреса IPv4, переданная этой функции, недействительна, будет "
"вызвано :exc:`OSError`. Обратите внимание, что именно то, что действительно, "
"зависит от базовой реализации :c:func:`inet_aton` на языке C."

#: ../../library/socket.rst:1031
msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` не поддерживает IPv6, и вместо него следует использовать :"
"func:`inet_pton` для поддержки двойного стека IPv4/v6."

#: ../../library/socket.rst:1037
msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""
"Преобразуйте 32-битный упакованный адрес IPv4 (объект, подобный :term:"
"`bytes` длиной в четыре байта) в его стандартное строковое представление, "
"состоящее из четырех точек (например, '123.45.67.89'). Это полезно при "
"общении с программой, которая использует стандартную библиотеку C и "
"нуждается в объектах типа :c:struct:`in_addr`, который является типом C для "
"32-битных упакованных двоичных данных, которые эта функция принимает в "
"качестве аргумента."

#: ../../library/socket.rst:1044
msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"Если длина последовательности байтов, переданной в эту функцию, не равна "
"точно 4 байтам, будет выдано сообщение :exc:`OSError`. :func:`inet_ntoa` не "
"поддерживает IPv6, и вместо него следует использовать :func:`inet_ntop` для "
"поддержки двойного стека IPv4/v6."

#: ../../library/socket.rst:1055
msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""
"Преобразуйте IP-адрес из строкового формата, специфичного для семейства, в "
"упакованный двоичный формат. :func:`inet_pton` полезен, когда библиотека или "
"сетевой протокол вызывает объект типа :c:struct:`in_addr` (аналогично :func:"
"`inet_aton`) или :c:struct:`in6_addr`."

#: ../../library/socket.rst:1060
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"Поддерживаемые значения для *address_family* в настоящее время: :const:"
"`AF_INET` и :const:`AF_INET6`. Если строка IP-адреса *ip_string* "
"недействительна, будет вызвано :exc:`OSError`. Обратите внимание, что именно "
"то, что действительно, зависит как от значения *address_family*, так и от "
"базовой реализации :c:func:`inet_pton`."

#: ../../library/socket.rst:1066 ../../library/socket.rst:1086
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ""
":ref:`Наличие\n"
"`: Юникс, Windows."

#: ../../library/socket.rst:1068 ../../library/socket.rst:1088
msgid "Windows support added"
msgstr "Добавлена поддержка Windows"

#: ../../library/socket.rst:1074
msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""
"Преобразование упакованного IP-адреса (объекта, подобного :term:`bytes`, "
"состоящего из некоторого количества байтов) в его стандартное, специфичное "
"для семейства строковое представление (например, ``'7.10.0.5'`` или ``'5aef: "
"2б::8'``). :func:`inet_ntop` полезен, когда библиотека или сетевой протокол "
"возвращает объект типа :c:struct:`in_addr` (аналогично :func:`inet_ntoa`) "
"или :c:struct:`in6_addr`."

#: ../../library/socket.rst:1081
msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"Поддерживаемые значения для *address_family* в настоящее время: :const:"
"`AF_INET` и :const:`AF_INET6`. Если длина объекта байтов *packed_ip* не "
"соответствует указанному семейству адресов, будет выдано :exc:`ValueError`. :"
"exc:`OSError` возникает в случае ошибок при вызове :func:`inet_ntop`."

#: ../../library/socket.rst:1103
msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"Возвращает общую длину без завершающих дополнений элемента вспомогательных "
"данных со связанными данными заданной *длины*. Это значение часто можно "
"использовать в качестве размера буфера для :meth:`~socket.recvmsg` для "
"получения одного элемента вспомогательных данных, но :rfc:`3542` требует, "
"чтобы переносимые приложения использовали :func:`CMSG_SPACE` и, таким "
"образом, включали место для заполнения, даже если элемент будет последним в "
"буфере. Вызывает :exc:`OverflowError`, если *длина* выходит за пределы "
"допустимого диапазона значений."

#: ../../library/socket.rst:1112 ../../library/socket.rst:1135
msgid ":ref:`Availability <availability>`: Unix, not Emscripten, not WASI."
msgstr ""

#: ../../library/socket.rst:1114 ../../library/socket.rst:1605
#: ../../library/socket.rst:1649 ../../library/socket.rst:1757
msgid "Most Unix platforms."
msgstr "Большинство платформ Unix."

#: ../../library/socket.rst:1121
msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"Возвращает размер буфера, необходимый для :meth:`~socket.recvmsg` для "
"получения вспомогательного элемента данных со связанными данными заданной "
"*длины* вместе с любым завершающим дополнением. Буферное пространство, "
"необходимое для приема нескольких элементов, представляет собой сумму "
"значений :func:`CMSG_SPACE` для связанных с ними длин данных. Вызывает :exc:"
"`OverflowError`, если *длина* выходит за пределы допустимого диапазона "
"значений."

#: ../../library/socket.rst:1129
msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"Обратите внимание, что некоторые системы могут поддерживать вспомогательные "
"данные, не предоставляя эту функцию. Также обратите внимание, что установка "
"размера буфера с использованием результатов этой функции не может точно "
"ограничить объем вспомогательных данных, которые могут быть получены, "
"поскольку дополнительные данные могут поместиться в область заполнения."

#: ../../library/socket.rst:1137
msgid "most Unix platforms."
msgstr "большинство платформ Unix."

#: ../../library/socket.rst:1144
msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"Возвращает таймаут по умолчанию в секундах (с плавающей запятой) для новых "
"объектов сокета. Значение None указывает, что новые объекты сокета не имеют "
"тайм-аута. Когда модуль сокета импортируется впервые, значением по умолчанию "
"является «Нет»."

#: ../../library/socket.rst:1151
msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"Установите таймаут по умолчанию в секундах (с плавающей запятой) для новых "
"объектов сокета. Когда модуль сокета импортируется впервые, значением по "
"умолчанию является «Нет». См. :meth:`~socket.settimeout` для возможных "
"значений и их соответствующих значений."

#: ../../library/socket.rst:1159
msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"Установите имя хоста машины на *name*. Это вызовет :exc:`OSError`, если у "
"вас недостаточно прав."

#: ../../library/socket.rst:1173
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"Вызывает событие аудита <auditing>``socket.sethostname`` с аргументом "
"``name``."

#: ../../library/socket.rst:1164 ../../library/socket.rst:1603
#: ../../library/socket.rst:1647
msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Availability <availability>`: Unix."

#: ../../library/socket.rst:1171
msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"Возвращает список кортежей с информацией о сетевом интерфейсе (индекс int, "
"строка имени). :exc:`OSError`, если системный вызов завершился неудачно."

#: ../../library/socket.rst:1175 ../../library/socket.rst:1202
#: ../../library/socket.rst:1219 ../../library/socket.rst:1236
#: ../../library/socket.rst:1250
msgid ""
":ref:`Availability <availability>`: Unix, Windows, not Emscripten, not WASI."
msgstr ""

#: ../../library/socket.rst:1179 ../../library/socket.rst:1206
#: ../../library/socket.rst:1223
msgid "Windows support was added."
msgstr "Добавлена ​​поддержка Windows."

#: ../../library/socket.rst:1184
msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"В Windows сетевые интерфейсы имеют разные имена в разных контекстах (все "
"имена являются примерами):"

#: ../../library/socket.rst:1187
msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

#: ../../library/socket.rst:1188
msgid "name: ``ethernet_32770``"
msgstr "имя: ``ethernet_32770``"

#: ../../library/socket.rst:1189
msgid "friendly name: ``vEthernet (nat)``"
msgstr "понятное имя: ``vEthernet (nat)``"

#: ../../library/socket.rst:1190
msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "описание: ``Виртуальный Ethernet-адаптер Hyper-V``"

#: ../../library/socket.rst:1192
msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""
"Эта функция возвращает имена второй формы из списка, в данном примере "
"``ethernet_32770``."

#: ../../library/socket.rst:1198
msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"Возвращает индексный номер сетевого интерфейса, соответствующий имени "
"интерфейса. :exc:`OSError`, если интерфейс с данным именем не существует."

#: ../../library/socket.rst:1210 ../../library/socket.rst:1227
msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr "«Имя интерфейса» — это имя, описанное в :func:`if_nameindex`."

#: ../../library/socket.rst:1215
msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"Возвращает имя сетевого интерфейса, соответствующее индексному номеру "
"интерфейса. :exc:`OSError`, если интерфейс с данным индексом не существует."

#: ../../library/socket.rst:1232
msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`~socket.sendmsg` for the documentation of these parameters."
msgstr ""
"Отправьте список файловых дескрипторов *fds* через сокет :const:`AF_UNIX` "
"*sock*. Параметр *fds* представляет собой последовательность файловых "
"дескрипторов. Обратитесь к :meth:`~socket.sendmsg` за документацией по этим "
"параметрам."

#: ../../library/socket.rst:1238 ../../library/socket.rst:1252
msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""
"Платформы Unix, поддерживающие механизм :meth:`~socket.sendmsg` и :const:"
"`SCM_RIGHTS`."

#: ../../library/socket.rst:1246
msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`~socket."
"recvmsg` for the documentation of these parameters."
msgstr ""
"Получите до *maxfds* файловых дескрипторов из сокета :const:`AF_UNIX` "
"*sock*. Возврат ``(msg, list(fds), flags, addr)``. Обратитесь к :meth:"
"`~socket.recvmsg` для получения документации по этим параметрам."

#: ../../library/socket.rst:1259
msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "Любые усеченные целые числа в конце списка файловых дескрипторов."

#: ../../library/socket.rst:1265
msgid "Socket Objects"
msgstr "Объекты сокетов"

#: ../../library/socket.rst:1267
msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"Объекты сокетов имеют следующие методы. За исключением :meth:`~socket."
"makefile`, они соответствуют системным вызовам Unix, применимым к сокетам."

#: ../../library/socket.rst:1271
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"Добавлена ​​поддержка протокола :term:`контекстного менеджера`. Выход из "
"контекстного менеджера эквивалентен вызову :meth:`~socket.close`."

#: ../../library/socket.rst:1278
msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"Примите соединение. Сокет должен быть привязан к адресу и прослушивать "
"соединения. Возвращаемое значение представляет собой пару ``(conn, адрес)``, "
"где *conn* — это *новый* объект сокета, используемый для отправки и "
"получения данных по соединению, а *address* — это адрес, привязанный к "
"сокету на другом конец соединения."

#: ../../library/socket.rst:1285 ../../library/socket.rst:1379
msgid "The socket is now non-inheritable."
msgstr "Сокет теперь не наследуется."

#: ../../library/socket.rst:1288 ../../library/socket.rst:1518
#: ../../library/socket.rst:1532 ../../library/socket.rst:1609
#: ../../library/socket.rst:1682 ../../library/socket.rst:1701
#: ../../library/socket.rst:1718 ../../library/socket.rst:1763
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Если системный вызов прерывается и обработчик сигнала не генерирует "
"исключение, метод теперь повторяет системный вызов вместо того, чтобы "
"вызывать исключение :exc:`InterruptedError` (обоснование см. в :pep:`475`)."

#: ../../library/socket.rst:1296
msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Привяжите сокет к *адресу*. Сокет еще не должен быть привязан. (Формат "
"*адреса* зависит от семейства адресов — см. выше.)"

#: ../../library/socket.rst:1310
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.bind`` с аргументами "
"``self``, ``address``."

#: ../../library/socket.rst:1306
msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""

#: ../../library/socket.rst:1312
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"Сокеты автоматически закрываются при сборке мусора, но рекомендуется :meth:"
"`закрывать` их явно или использовать вокруг них оператор :keyword:`with`."

#: ../../library/socket.rst:1316
msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` теперь вызывается, если при выполнении базового вызова :c:"
"func:`close` возникает ошибка."

#: ../../library/socket.rst:1322
msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""

#: ../../library/socket.rst:1330
msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"Подключитесь к удаленному сокету по адресу *адрес*. (Формат *адреса* зависит "
"от семейства адресов — см. выше.)"

#: ../../library/socket.rst:1333
msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""
"Если соединение прерывается сигналом, метод ожидает завершения соединения "
"или вызывает :exc:`TimeoutError` по таймауту, если обработчик сигнала не "
"вызывает исключение, а сокет блокируется или имеет тайм-аут. Для "
"неблокирующих сокетов метод вызывает исключение :exc:`InterruptedError`, "
"если соединение прерывается сигналом (или исключением, вызванным "
"обработчиком сигнала)."

#: ../../library/socket.rst:1351 ../../library/socket.rst:1371
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.connect`` с аргументами "
"``self``, ``address``."

#: ../../library/socket.rst:1342
msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"Теперь метод ожидает завершения соединения вместо того, чтобы вызывать "
"исключение :exc:`InterruptedError`, если соединение прерывается сигналом, "
"обработчик сигнала не вызывает исключение, а сокет блокируется или имеет "
"тайм-аут (см. pep:`475` для обоснования)."

#: ../../library/socket.rst:1353
msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"Подобно ``connect(address)``, но возвращает индикатор ошибки вместо того, "
"чтобы вызывать исключение для ошибок, возвращаемых вызовом :c:func:`connect` "
"уровня C (другие проблемы, такие как «хост не найден», могут все еще "
"вызывают исключения). Индикатор ошибки равен ``0``, если операция "
"завершилась успешно, в противном случае значением переменной :c:data:"
"`errno`. Это полезно, например, для поддержки асинхронных подключений."

#: ../../library/socket.rst:1366
msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"Переведите объект сокета в закрытое состояние, фактически не закрывая "
"базовый файловый дескриптор. Дескриптор файла возвращается и может быть "
"повторно использован для других целей."

#: ../../library/socket.rst:1375
msgid "Duplicate the socket."
msgstr "Дублируйте сокет."

#: ../../library/socket.rst:1387
msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"Возвращает файловый дескриптор сокета (маленькое целое число) или -1 в "
"случае ошибки. Это полезно с :func:`select.select`."

#: ../../library/socket.rst:1390
msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"В Windows небольшое целое число, возвращаемое этим методом, нельзя "
"использовать там, где можно использовать файловый дескриптор (например, :"
"func:`os.fdopen`). Unix не имеет этого ограничения."

#: ../../library/socket.rst:1396
msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"Получите :ref:`inheritable flag <fd_inheritance>` файлового дескриптора "
"сокета или дескриптора сокета: ``True``, если сокет может быть унаследован в "
"дочерних процессах, ``False``, если нет."

#: ../../library/socket.rst:1405
msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"Верните удаленный адрес, к которому подключен сокет. Это полезно, например, "
"для определения номера порта удаленного сокета IPv4/v6. (Формат "
"возвращаемого адреса зависит от семейства адресов — см. выше.) В некоторых "
"системах эта функция не поддерживается."

#: ../../library/socket.rst:1413
msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"Верните собственный адрес сокета. Это полезно, например, для определения "
"номера порта сокета IPv4/v6. (Формат возвращаемого адреса зависит от "
"семейства адресов — см. выше.)"

#: ../../library/socket.rst:1420
msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:ref:`SO_\\* etc. <socket-"
"unix-constants>`) are defined in this module.  If *buflen* is absent, an "
"integer option is assumed and its integer value is returned by the "
"function.  If *buflen* is present, it specifies the maximum length of the "
"buffer used to receive the option in, and this buffer is returned as a bytes "
"object.  It is up to the caller to decode the contents of the buffer (see "
"the optional built-in module :mod:`struct` for a way to decode C structures "
"encoded as byte strings)."
msgstr ""
"Возвращает значение данного параметра сокета (см. справочную страницу Unix :"
"manpage:`getsockopt(2)`). В этом модуле определены необходимые символические "
"константы (:ref:`SO_\\* и т.д. <socket-unix-constants>`). Если *buflen* "
"отсутствует, предполагается целочисленная опция, и функция возвращает ее "
"целочисленное значение. Если присутствует *buflen*, он определяет "
"максимальную длину буфера, используемого для приема опции, и этот буфер "
"возвращается как байтовый объект. Вызывающая сторона должна декодировать "
"содержимое буфера (см. дополнительный встроенный модуль :mod:`struct`, чтобы "
"узнать, как декодировать структуры C, закодированные как байтовые строки)."

#: ../../library/socket.rst:1434
msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"Верните True, если сокет находится в блокирующем режиме, и False, если в "
"неблокирующем."

#: ../../library/socket.rst:1437
msgid "This is equivalent to checking ``socket.gettimeout() != 0``."
msgstr "Это эквивалентно проверке ``socket.gettimeout() != 0``."

#: ../../library/socket.rst:1444
msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"Возвращает тайм-аут в секундах (с плавающей запятой), связанный с операциями "
"сокета, или ``None``, если тайм-аут не установлен. Это отражает последний "
"вызов :meth:`setblocking` или :meth:`settimeout`."

#: ../../library/socket.rst:0
msgid "platform"
msgstr "платформа"

#: ../../library/socket.rst:1451
msgid "Windows"
msgstr "Windows"

#: ../../library/socket.rst:1453
msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
"Метод :meth:`ioctl` представляет собой ограниченный интерфейс к системному "
"интерфейсу WSAIoctl. Дополнительную информацию см. в документации Win32 "
"<https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx>_."

#: ../../library/socket.rst:1458
msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"На других платформах могут использоваться общие функции :func:`fcntl.fcntl` "
"и :func:`fcntl.ioctl`; они принимают объект сокета в качестве своего первого "
"аргумента."

#: ../../library/socket.rst:1461
msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"В настоящее время поддерживаются только следующие управляющие коды: "
"SIO_RCVALL, SIO_KEEPALIVE_VALS и SIO_LOOPBACK_FAST_PATH."

#: ../../library/socket.rst:1469
msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"Включите сервер для приема соединений. Если указано *backlog*, оно должно "
"быть не менее 0 (если оно меньше, оно устанавливается в 0); он определяет "
"количество непринятых соединений, которые система разрешит, прежде чем "
"отклонять новые соединения. Если не указано, выбирается разумное значение по "
"умолчанию."

#: ../../library/socket.rst:1476
msgid "The *backlog* parameter is now optional."
msgstr "Параметр *backlog* теперь является необязательным."

#: ../../library/socket.rst:1485
msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""

#: ../../library/socket.rst:1490
msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"Сокет должен находиться в режиме блокировки; у него может быть тайм-аут, но "
"внутренний буфер файлового объекта может оказаться в несогласованном "
"состоянии, если произойдет тайм-аут."

#: ../../library/socket.rst:1494
msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"Закрытие файлового объекта, возвращаемого :meth:`makefile`, не закроет "
"исходный сокет, пока все другие файловые объекты не будут закрыты и для "
"объекта сокета не будет вызван :meth:`socket.close`."

#: ../../library/socket.rst:1500
msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"В Windows файловый объект, созданный :meth:`makefile`, не может "
"использоваться там, где ожидается файловый объект с файловым дескриптором, "
"например, аргументы потока :meth:`subprocess.Popen`."

#: ../../library/socket.rst:1507
msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*. A returned empty bytes object indicates "
"that the client has disconnected. See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"Получить данные из сокета. Возвращаемое значение — это байтовый объект, "
"представляющий полученные данные. Максимальный объем данных, принимаемых за "
"один раз, определяется *bufsize*. Возвращенный объект с пустыми байтами "
"указывает на то, что клиент отключился. См. страницу руководства Unix :"
"manpage:`recv(2)`, чтобы узнать значение необязательного аргумента *flags*; "
"по умолчанию он равен нулю."

#: ../../library/socket.rst:1515
msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"Для лучшего соответствия аппаратным и сетевым реалиям значение *bufsize* "
"должно быть относительно небольшой степенью 2, например, 4096."

#: ../../library/socket.rst:1526
msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Получить данные из сокета. Возвращаемое значение представляет собой пару "
"``(байты, адрес)``, где *bytes* — это байтовый объект, представляющий "
"полученные данные, а *address* — это адрес сокета, отправляющего данные. См. "
"страницу руководства Unix :manpage:`recv(2)`, чтобы узнать значение "
"необязательного аргумента *flags*; по умолчанию он равен нулю. (Формат "
"*адреса* зависит от семейства адресов — см. выше.)"

#: ../../library/socket.rst:1537
msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"Для многоадресного IPv6-адреса первый элемент *address* не содержит `` %s "
"copy_id`` больше не является частью. Чтобы получить полный адрес IPv6, "
"используйте :func:`getnameinfo`."

#: ../../library/socket.rst:1544
msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"Получать обычные данные (до *bufsize* байт) и вспомогательные данные из "
"сокета. Аргумент *ancbufsize* устанавливает размер в байтах внутреннего "
"буфера, используемого для приема вспомогательных данных; по умолчанию он "
"равен 0, что означает, что никакие вспомогательные данные не будут получены. "
"Соответствующие размеры буфера для вспомогательных данных можно рассчитать с "
"помощью :func:`CMSG_SPACE` или :func:`CMSG_LEN`, а элементы, которые не "
"помещаются в буфер, могут быть усечены или отброшены. Аргумент *flags* по "
"умолчанию равен 0 и имеет то же значение, что и :meth:`recv`."

#: ../../library/socket.rst:1554
msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"Возвращаемое значение представляет собой кортеж из четырех элементов: "
"``(data, ancdata, msg_flags, адрес)``. Элемент *data* представляет собой "
"объект :class:`bytes`, содержащий полученные невспомогательные данные. "
"Элемент *ancdata* представляет собой список из нуля или более кортежей "
"``(cmsg_level, cmsg_type, cmsg_data)``, представляющих полученные "
"вспомогательные данные (управляющие сообщения): *cmsg_level* и *cmsg_type* — "
"целые числа, определяющие уровень протокола и протокол- определенного типа "
"соответственно, а *cmsg_data* — это объект :class:`bytes`, содержащий "
"связанные данные. Элемент *msg_flags* представляет собой побитовое ИЛИ "
"различных флагов, указывающих условия принятого сообщения; подробности см. в "
"документации к вашей системе. Если принимающий сокет не подключен, *адрес* — "
"это адрес отправляющего сокета, если он доступен; в противном случае его "
"значение не указано."

#: ../../library/socket.rst:1568
msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""
"В некоторых системах :meth:`sendmsg` и :meth:`recvmsg` могут использоваться "
"для передачи дескрипторов файлов между процессами через сокет :const:"
"`AF_UNIX`. Когда используется эта возможность (она часто ограничена "
"сокетами :const:`SOCK_STREAM`), :meth:`recvmsg` будет возвращать в своих "
"вспомогательных данных элементы формы ``(socket.SOL_SOCKET, socket."
"SCM_RIGHTS, fds )``, где *fds* — это объект :class:`bytes`, представляющий "
"новые файловые дескрипторы в виде двоичного массива собственного типа C :c:"
"expr:`int`. Если :meth:`recvmsg` вызывает исключение после возврата "
"системного вызова, он сначала попытается закрыть любые файловые дескрипторы, "
"полученные через этот механизм."

#: ../../library/socket.rst:1579
msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"Некоторые системы не указывают сокращенную длину элементов вспомогательных "
"данных, которые были получены лишь частично. Если элемент выходит за пределы "
"буфера, :meth:`recvmsg` выдаст :exc:`RuntimeWarning` и вернет ту его часть, "
"которая находится внутри буфера, при условии, что она не была усечена до "
"начала. связанных с ним данных."

#: ../../library/socket.rst:1586
msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"В системах, поддерживающих механизм :const:`SCM_RIGHTS`, следующая функция "
"получит до *maxfds* файловых дескрипторов, возвращая данные сообщения и "
"список, содержащий дескрипторы (при этом игнорируя непредвиденные условия, "
"такие как получение несвязанных управляющих сообщений). См. также :meth:"
"`sendmsg`. ::"

#: ../../library/socket.rst:1617
msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"Получает обычные и вспомогательные данные из сокета, ведя себя как :meth:"
"`recvmsg`, но распределяет невспомогательные данные по ряду буферов вместо "
"возврата нового байтового объекта. Аргумент *buffers* должен быть "
"итерируемым объектом, который экспортирует записываемые буферы (например, "
"объекты :class:`bytearray`); они будут заполняться последовательными "
"фрагментами невспомогательных данных до тех пор, пока все они не будут "
"записаны или пока не закончатся буферы. Операционная система может "
"установить ограничение (:func:`~os.sysconf`, значение ``SC_IOV_MAX``) на "
"количество буферов, которые можно использовать. Аргументы *ancbufsize* и "
"*flags* имеют то же значение, что и :meth:`recvmsg`."

#: ../../library/socket.rst:1628
msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"Возвращаемое значение представляет собой кортеж из четырех элементов: "
"``(nbytes, ancdata, msg_flags, адрес)``, где *nbytes* — общее количество "
"байтов невспомогательных данных, записанных в буферы, а *ancdata*, "
"*msg_flags. * и *адрес* такие же, как и для :meth:`recvmsg`."

#: ../../library/socket.rst:1633
msgid "Example::"
msgstr "Пример::"

#: ../../library/socket.rst:1656
msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Получайте данные из сокета, записывая их в *буфер* вместо создания новой "
"байтовой строки. Возвращаемое значение представляет собой пару ``(nbytes, "
"адрес)``, где *nbytes* — количество полученных байт, а *address* — адрес "
"сокета, отправляющего данные. См. страницу руководства Unix :manpage:"
"`recv(2)`, чтобы узнать значение необязательного аргумента *flags*; по "
"умолчанию он равен нулю. (Формат *адреса* зависит от семейства адресов — см. "
"выше.)"

#: ../../library/socket.rst:1666
msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"Получайте до *nbytes* байт из сокета, сохраняя данные в буфере, а не "
"создавая новую строку байтов. Если *nbytes* не указано (или 0), получить до "
"размера, доступного в данном буфере. Возвращает количество полученных "
"байтов. См. страницу руководства Unix :manpage:`recv(2)`, чтобы узнать "
"значение необязательного аргумента *flags*; по умолчанию он равен нулю."

#: ../../library/socket.rst:1675
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"Отправьте данные в сокет. Розетка должна быть подключена к удаленной "
"розетке. Необязательный аргумент *flags* имеет то же значение, что и для :"
"meth:`recv` выше. Возвращает количество отправленных байтов. Приложения "
"отвечают за проверку отправки всех данных; если была передана только часть "
"данных, приложению необходимо попытаться доставить оставшиеся данные. Для "
"получения дополнительной информации по этой теме обратитесь к :ref:`socket-"
"howto`."

#: ../../library/socket.rst:1690
msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"Отправьте данные в сокет. Розетка должна быть подключена к удаленной "
"розетке. Необязательный аргумент *flags* имеет то же значение, что и для :"
"meth:`recv` выше. В отличие от :meth:`send`, этот метод продолжает "
"отправлять данные из *байтов* до тех пор, пока не будут отправлены все "
"данные или не произойдет ошибка. ``None`` возвращается в случае успеха. В "
"случае ошибки возникает исключение, и невозможно определить, какой объем "
"данных (если таковые имеются) был успешно отправлен."

#: ../../library/socket.rst:1697
msgid ""
"The socket timeout is no longer reset each time data is sent successfully. "
"The socket timeout is now the maximum total duration to send all data."
msgstr ""
"Тайм-аут сокета больше не сбрасывается при каждой успешной отправке данных. "
"Тайм-аут сокета теперь равен максимальной общей продолжительности отправки "
"всех данных."

#: ../../library/socket.rst:1710
msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Отправьте данные в сокет. Сокет не должен быть подключен к удаленному "
"сокету, поскольку сокет назначения указывается *адресом*. Необязательный "
"аргумент *flags* имеет то же значение, что и для :meth:`recv` выше. "
"Возвращает количество отправленных байтов. (Формат *адреса* зависит от "
"семейства адресов — см. выше.)"

#: ../../library/socket.rst:1727
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.sendto`` с аргументами "
"``self``, ``address``."

#: ../../library/socket.rst:1726
msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"Отправьте в сокет обычные и вспомогательные данные, собрав невспомогательные "
"данные из ряда буферов и объединив их в одно сообщение. Аргумент *buffers* "
"определяет невспомогательные данные как итерацию :term:`bytes-like object "
"<bytes-like object>` (например, :class:`bytes` объектов); операционная "
"система может установить ограничение (:func:`~os.sysconf` значение "
"``SC_IOV_MAX``) на количество буферов, которые могут быть использованы. "
"Аргумент *ancdata* определяет вспомогательные данные (управляющие сообщения) "
"как итерацию из нуля или более кортежей ``(cmsg_level, cmsg_type, "
"cmsg_data)``, где *cmsg_level* и *cmsg_type* — целые числа, определяющие "
"уровень протокола и протокол. определенного типа соответственно, а "
"*cmsg_data* — это байтовый объект, содержащий связанные данные. Обратите "
"внимание, что некоторые системы (в частности, системы без :func:"
"`CMSG_SPACE`) могут поддерживать отправку только одного управляющего "
"сообщения за вызов. Аргумент *flags* по умолчанию равен 0 и имеет то же "
"значение, что и :meth:`send`. Если указан *адрес*, а не «Нет», "
"устанавливается адрес назначения для сообщения. Возвращаемое значение — это "
"количество отправленных байтов невспомогательных данных."

#: ../../library/socket.rst:1746
msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"Следующая функция отправляет список файловых дескрипторов *fds* через сокет :"
"const:`AF_UNIX` в системах, которые поддерживают механизм :const:"
"`SCM_RIGHTS`. См. также :meth:`recvmsg`. ::"

#: ../../library/socket.rst:1755
msgid ":ref:`Availability <availability>`: Unix, not WASI."
msgstr ""
":ref:`Наличие\n"
"`: Unix, а не WASI."

#: ../../library/socket.rst:1770
msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``socket.sendmsg`` с аргументами "
"``self``, ``address``."

#: ../../library/socket.rst:1770
msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"Специализированная версия :meth:`~socket.sendmsg` для сокета :const:"
"`AF_ALG`. Установите режим, IV, длину связанных с AEAD данных и флаги для "
"сокета :const:`AF_ALG`."

#: ../../library/socket.rst:1779
msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"Отправляйте файл до тех пор, пока не будет достигнут EOF, используя "
"высокопроизводительный :mod:`os.sendfile` и возвращайте общее количество "
"отправленных байтов. *файл* должен быть обычным файловым объектом, открытым "
"в двоичном режиме. Если :mod:`os.sendfile` недоступен (например, Windows) "
"или *file* не является обычным файлом, вместо него будет использоваться :"
"meth:`send`. *offset* указывает, с чего начать чтение файла. Если указано, "
"*count* — это общее количество байтов для передачи вместо отправки файла до "
"достижения EOF. Позиция файла обновляется при возврате, а также в случае "
"ошибки, и в этом случае :meth:`file.tell() <io.IOBase.tell>` можно "
"использовать для определения количества отправленных байтов. Сокет должен "
"иметь тип :const:`SOCK_STREAM`. Неблокирующие сокеты не поддерживаются."

#: ../../library/socket.rst:1795
msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"Установите :ref:`inheritable флаг <fd_inheritance>` дескриптора файла сокета "
"или дескриптора сокета."

#: ../../library/socket.rst:1803
msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"Установите блокирующий или неблокирующий режим сокета: если *flag* имеет "
"значение false, сокет устанавливается в неблокирующий режим, в противном "
"случае — в блокирующий режим."

#: ../../library/socket.rst:1806
msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr ""
"Этот метод является сокращением для некоторых вызовов :meth:`~socket."
"settimeout`:"

#: ../../library/socket.rst:1808
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` эквивалентен ``sock.settimeout(None)``"

#: ../../library/socket.rst:1810
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` эквивалентен ``sock.settimeout(0.0)``"

#: ../../library/socket.rst:1812
msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Этот метод больше не применяет флаг :const:`SOCK_NONBLOCK` к :attr:`socket."
"type`."

#: ../../library/socket.rst:1819
msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""

#: ../../library/socket.rst:1826
msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"Для получения дополнительной информации обратитесь к :ref:`примечаниям по "
"таймаутам сокетов <socket-timeouts>`."

#: ../../library/socket.rst:1828
msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Метод больше не переключает флаг :const:`SOCK_NONBLOCK` на :attr:`socket."
"type`."

#: ../../library/socket.rst:1841
msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in this module "
"(:ref:`!SO_\\* etc. <socket-unix-constants>`).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"Установите значение данной опции сокета (см. страницу руководства Unix :"
"manpage:`setsockopt(2)`). В этом модуле определены необходимые символические "
"константы (:ref:`!SO_\\* и т. д. <socket-unix-constants>`). Значение может "
"быть целым числом, None или :term:`байтовым объектом`, представляющим буфер. "
"В последнем случае вызывающая сторона должна убедиться, что строка байтов "
"содержит правильные биты (см. дополнительный встроенный модуль :mod:"
"`struct`, чтобы узнать, как кодировать структуры C как строки байтов). Если "
"для *value* установлено значение None, требуется аргумент *optlen*. Это "
"эквивалентно вызову функции C :c:func:`setsockopt` с ``optval=NULL`` и "
"``optlen=optlen``."

#: ../../library/socket.rst:1854
msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "Добавлена ​​форма setockopt(level, optname, None, optlen: int)."

#: ../../library/socket.rst:1862
msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"Отключите одну или обе половины соединения. Если *как* установлено :const:"
"`SHUT_RD`, дальнейшие получения запрещены. Если *how* равно :const:"
"`SHUT_WR`, дальнейшие отправки запрещены. Если *how* равно :const:"
"`SHUT_RDWR`, дальнейшая отправка и получение запрещены."

#: ../../library/socket.rst:1872
msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"Дублируйте сокет и подготовьте его для совместного использования целевым "
"процессом. Целевому процессу должен быть присвоен *process_id*. "
"Результирующий объект байтов затем может быть передан целевому процессу, "
"используя некоторую форму межпроцессного взаимодействия, и сокет может быть "
"воссоздан там с помощью :func:`fromshare`. После вызова этого метода можно "
"безопасно закрыть сокет, поскольку операционная система уже продублировала "
"его для целевого процесса."

#: ../../library/socket.rst:1884
msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"Обратите внимание, что здесь нет методов :meth:`read` или :meth:`write`; "
"вместо этого используйте :meth:`~socket.recv` и :meth:`~socket.send` без "
"аргумента *flags*."

#: ../../library/socket.rst:1887
msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"Объекты сокетов также имеют эти атрибуты (только для чтения), которые "
"соответствуют значениям, заданным конструктору :class:`~socket.socket`."

#: ../../library/socket.rst:1893
msgid "The socket family."
msgstr "Семейство сокетов."

#: ../../library/socket.rst:1898
msgid "The socket type."
msgstr "Тип сокета"

#: ../../library/socket.rst:1903
msgid "The socket protocol."
msgstr "Протокол сокета."

#: ../../library/socket.rst:1910
msgid "Notes on socket timeouts"
msgstr "Примечания о тайм-аутах сокетов"

#: ../../library/socket.rst:1912
msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"Объект сокета может находиться в одном из трех режимов: блокирующий, "
"неблокирующий или тайм-аут. Сокеты по умолчанию всегда создаются в "
"блокирующем режиме, но это можно изменить, вызвав :func:`setdefaulttimeout`."

#: ../../library/socket.rst:1916
msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"В *режиме блокировки* операции блокируются до завершения или до тех пор, "
"пока система не вернет ошибку (например, время ожидания соединения истекло)."

#: ../../library/socket.rst:1919
msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` module can be used to know when and whether a socket is "
"available for reading or writing."
msgstr ""
"В *неблокирующем режиме* операции завершаются неудачно (с ошибкой, которая, "
"к сожалению, зависит от системы), если они не могут быть завершены "
"немедленно: функции из модуля :mod:`select` можно использовать, чтобы "
"узнать, когда и доступен ли сокет. для чтения или письма."

#: ../../library/socket.rst:1924
msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"В *режиме таймаута* операции завершаются неудачей, если они не могут быть "
"завершены в течение таймаута, указанного для сокета (они вызывают "
"исключение :exc:`timeout`) или если система возвращает ошибку."

#: ../../library/socket.rst:1929
msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""

#: ../../library/socket.rst:1936
msgid "Timeouts and the ``connect`` method"
msgstr "Таймауты и метод подключения"

#: ../../library/socket.rst:1938
msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
"На операцию :meth:`~socket.connect` также распространяется настройка "
"таймаута, и обычно рекомендуется вызывать :meth:`~socket.settimeout` перед "
"вызовом :meth:`~socket.connect` или передавать параметр timeout для :meth:"
"`create_connection`. Однако системный сетевой стек также может возвращать "
"собственную ошибку тайм-аута соединения независимо от каких-либо настроек "
"тайм-аута сокета Python."

#: ../../library/socket.rst:1946
msgid "Timeouts and the ``accept`` method"
msgstr "Таймауты и метод Accept"

#: ../../library/socket.rst:1948
msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"Если :func:`getdefaulttimeout` не равен :const:`None`, сокеты, возвращаемые "
"методом :meth:`~socket.accept`, наследуют этот таймаут. В противном случае "
"поведение зависит от настроек прослушивающего сокета:"

#: ../../library/socket.rst:1952
msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"если сокет прослушивания находится в *режиме блокировки* или в *режиме тайм-"
"аута*, сокет, возвращаемый :meth:`~socket.accept`, находится в *режиме "
"блокировки*;"

#: ../../library/socket.rst:1955
msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"если сокет прослушивания находится в *неблокирующем режиме*, то, находится "
"ли сокет, возвращаемый :meth:`~socket.accept`, в блокирующем или "
"неблокирующем режиме, зависит от операционной системы. Если вы хотите "
"обеспечить кросс-платформенное поведение, рекомендуется вручную "
"переопределить этот параметр."

#: ../../library/socket.rst:1964
msgid "Example"
msgstr "Пример"

#: ../../library/socket.rst:1966
msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:"
"`~socket.socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:"
"`~socket.accept` (possibly repeating the :meth:`~socket.accept` to service "
"more than one client), while a client only needs the sequence :func:`~socket."
"socket`, :meth:`~socket.connect`.  Also note that the server does not :meth:"
"`~socket.sendall`/:meth:`~socket.recv` on the socket it is listening on but "
"on the new socket returned by :meth:`~socket.accept`."
msgstr ""
"Вот четыре минимальных примера программы, использующих протокол TCP/IP: "
"сервер, который отображает все данные, которые он получает обратно "
"(обслуживая только одного клиента), и клиент, использующий его. Обратите "
"внимание, что сервер должен выполнить последовательность :func:`~socket."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (возможно, повторяя :meth:`~socket.accept` для обслуживания более "
"чем одного клиента), в то время как клиенту нужна только последовательность :"
"func:`~socket.socket`, :meth:`~socket.connect`. Также обратите внимание, что "
"сервер не :meth:`~socket.sendall`/:meth:`~socket.recv` для сокета, который "
"он прослушивает, а для нового сокета, возвращаемого :meth:`~socket.accept`."

#: ../../library/socket.rst:1976
msgid "The first two examples support IPv4 only. ::"
msgstr "Первые два примера поддерживают только IPv4. ::"

#: ../../library/socket.rst:2007
msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to all the addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"Следующие два примера идентичны двум приведенным выше, но поддерживают как "
"IPv4, так и IPv6. Серверная часть будет прослушивать первое доступное "
"семейство адресов (вместо этого она должна прослушивать оба). В большинстве "
"систем, поддерживающих IPv6, IPv6 будет иметь приоритет, и сервер может не "
"принимать трафик IPv4. Клиентская сторона попытается подключиться ко всем "
"адресам, возвращенным в результате разрешения имени, и отправит трафик на "
"первый успешно подключенный адрес. ::"

#: ../../library/socket.rst:2079
msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"В следующем примере показано, как написать очень простой сетевой анализатор "
"с необработанными сокетами в Windows. В примере требуются права "
"администратора для изменения интерфейса::"

#: ../../library/socket.rst:2104
msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"В следующем примере показано, как использовать интерфейс сокета для связи с "
"сетью CAN с использованием протокола необработанных сокетов. Чтобы вместо "
"этого использовать CAN с протоколом диспетчера широковещания, откройте сокет "
"с помощью::"

#: ../../library/socket.rst:2110
msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send` and :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"После привязки (:const:`CAN_RAW`) или подключения (:const:`CAN_BCM`) сокета "
"вы можете использовать операции :meth:`socket.send` и :meth:`socket.recv` (и "
"их аналоги) на объекте сокета, как обычно."

#: ../../library/socket.rst:2114
msgid "This last example might require special privileges::"
msgstr "Этот последний пример может потребовать особых привилегий:"

#: ../../library/socket.rst:2154
msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"Запуск примера несколько раз со слишком маленькой задержкой между "
"выполнениями может привести к этой ошибке:"

#: ../../library/socket.rst:2159
msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"Это связано с тем, что предыдущее выполнение оставило сокет в состоянии "
"TIME_WAIT и не может быть немедленно использовано повторно."

#: ../../library/socket.rst:2162
msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :const:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"Чтобы предотвратить это, необходимо установить флаг :mod:`socket` :const:"
"`socket.SO_REUSEADDR`::"

#: ../../library/socket.rst:2169
msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
"Флаг :data:`SO_REUSEADDR` сообщает ядру повторно использовать локальный "
"сокет в состоянии ``TIME_WAIT``, не дожидаясь истечения его естественного "
"тайм-аута."

#: ../../library/socket.rst:2175
msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr "Введение в программирование сокетов (на C) см. в следующих статьях:"

#: ../../library/socket.rst:2177
msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*Вводное руководство по межпроцессному общению в 4.3BSD*, Стюарт Сехрест"

#: ../../library/socket.rst:2179
msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*Усовершенствованное руководство по межпроцессному взаимодействию в 4.3BSD*, "
"автор: Сэмюэл Дж. Леффлер и др.,"

#: ../../library/socket.rst:2182
msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"как в Руководстве программиста UNIX, Дополнительные документы 1 (разделы "
"PS1:7 и PS1:8). Справочные материалы по различным системным вызовам, "
"связанным с сокетами, также являются ценным источником информации о деталях "
"семантики сокетов. Для Unix обратитесь к страницам руководства; для Windows "
"см. спецификацию WinSock (или Winsock 2). Для API-интерфейсов, готовых к "
"IPv6, читатели могут обратиться к :rfc:`3493` под названием Basic Socket "
"Interface Extensions для IPv6."

#: ../../library/socket.rst:22
msgid "object"
msgstr "объект"

#: ../../library/socket.rst:22
msgid "socket"
msgstr "сокет"

#: ../../library/socket.rst:1483
msgid "I/O control"
msgstr "управление ввода/вывода"

#: ../../library/socket.rst:1483
msgid "buffering"
msgstr "буферизация"

#: ../../library/socket.rst:1839
msgid "module"
msgstr "модуль"

#: ../../library/socket.rst:1839
msgid "struct"
msgstr "struct"
