# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:53+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ""

#: ../../library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**Исходный код:** :source:`Lib/io.py`"

#: ../../library/io.rst:22
msgid "Overview"
msgstr "Обзор"

#: ../../library/io.rst:27
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging to "
"any of these categories is called a :term:`file object`.  Other common terms "
"are *stream* and *file-like object*."
msgstr ""
"Модуль :mod:`io` предоставляет основные возможности Python для работы с "
"различными типами ввода-вывода. Существует три основных типа ввода-вывода: "
"*текстовый ввод-вывод*, *двоичный ввод-вывод* и *необработанный ввод-вывод*. "
"Это общие категории, и для каждой из них можно использовать различные "
"резервные хранилища. Конкретный объект, принадлежащий к любой из этих "
"категорий, называется файловым объектом. Другими распространенными терминами "
"являются *поток* и *файлоподобный объект*."

#: ../../library/io.rst:34
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It can "
"also allow arbitrary random access (seeking forwards or backwards to any "
"location), or only sequential access (for example in the case of a socket or "
"pipe)."
msgstr ""
"Независимо от категории, каждый конкретный объект потока также будет иметь "
"различные возможности: он может быть доступен только для чтения, только для "
"записи или чтения-записи. Он также может разрешить произвольный произвольный "
"доступ (переход к любому местоположению вперед или назад) или только "
"последовательный доступ (например, в случае сокета или канала)."

#: ../../library/io.rst:40
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the ``write()`` method of a binary "
"stream will raise a :exc:`TypeError`.  So will giving a :class:`bytes` "
"object to the ``write()`` method of a text stream."
msgstr ""

#: ../../library/io.rst:45
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, "
"since :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
"Операции, которые раньше вызывали :exc:`IOError`, теперь вызывают :exc:"
"`OSError`, поскольку :exc:`IOError` теперь является псевдонимом :exc:"
"`OSError`."

#: ../../library/io.rst:51 ../../library/io.rst:848 ../../library/io.rst:1109
msgid "Text I/O"
msgstr "Текстовый ввод/вывод"

#: ../../library/io.rst:53
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case of "
"a file), encoding and decoding of data is made transparently as well as "
"optional translation of platform-specific newline characters."
msgstr ""
"Текстовый ввод-вывод ожидает и создает объекты :class:`str`. Это означает, "
"что всякий раз, когда резервное хранилище изначально состоит из байтов "
"(например, в случае с файлом), кодирование и декодирование данных "
"выполняется прозрачно, а также необязательный перевод символов новой строки, "
"специфичных для платформы."

#: ../../library/io.rst:58
msgid ""
"The easiest way to create a text stream is with :meth:`open()`, optionally "
"specifying an encoding::"
msgstr ""

#: ../../library/io.rst:63
msgid ""
"In-memory text streams are also available as :class:`StringIO` objects::"
msgstr ""
"Текстовые потоки в памяти также доступны как объекты :class:`StringIO`::"

#: ../../library/io.rst:67
msgid ""
"The text stream API is described in detail in the documentation of :class:"
"`TextIOBase`."
msgstr ""
"API текстового потока подробно описан в документации :class:`TextIOBase`."

#: ../../library/io.rst:72 ../../library/io.rst:1097
msgid "Binary I/O"
msgstr "Бинарный ввод/вывод"

#: ../../library/io.rst:74
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects "
"<bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams can "
"be used for all kinds of non-text data, and also when manual control over "
"the handling of text data is desired."
msgstr ""
"Двоичный ввод-вывод (также называемый *буферизованным вводом-выводом*) "
"ожидает :term:`байтоподобных объектов <байтоподобный объект>` и создает :"
"class:`байтовые` объекты. Кодирование, декодирование или перевод новой "
"строки не выполняются. Эту категорию потоков можно использовать для всех "
"видов нетекстовых данных, а также когда желательно ручное управление "
"обработкой текстовых данных."

#: ../../library/io.rst:80
msgid ""
"The easiest way to create a binary stream is with :meth:`open()` with "
"``'b'`` in the mode string::"
msgstr ""

#: ../../library/io.rst:85
msgid ""
"In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr "Бинарные потоки в памяти также доступны как объекты :class:`BytesIO`::"

#: ../../library/io.rst:89
msgid ""
"The binary stream API is described in detail in the docs of :class:"
"`BufferedIOBase`."
msgstr ""
"API двоичного потока подробно описан в документации :class:`BufferedIOBase`."

#: ../../library/io.rst:92
msgid ""
"Other library modules may provide additional ways to create text or binary "
"streams.  See :meth:`socket.socket.makefile` for example."
msgstr ""
"Другие библиотечные модули могут предоставлять дополнительные способы "
"создания текстовых или двоичных потоков. См., например, :meth:`socket.socket."
"makefile`."

#: ../../library/io.rst:97
msgid "Raw I/O"
msgstr "Необработанный ввод/вывод"

#: ../../library/io.rst:99
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to directly "
"manipulate a raw stream from user code.  Nevertheless, you can create a raw "
"stream by opening a file in binary mode with buffering disabled::"
msgstr ""
"Необработанный ввод-вывод (также называемый *небуферизованным вводом-"
"выводом*) обычно используется в качестве низкоуровневого строительного блока "
"для двоичных и текстовых потоков; Редко бывает полезно напрямую "
"манипулировать необработанным потоком из пользовательского кода. Тем не "
"менее, вы можете создать необработанный поток, открыв файл в двоичном режиме "
"с отключенной буферизацией:"

#: ../../library/io.rst:106
msgid ""
"The raw stream API is described in detail in the docs of :class:`RawIOBase`."
msgstr ""
"API необработанного потока подробно описан в документации :class:`RawIOBase`."

#: ../../library/io.rst:112
msgid "Text Encoding"
msgstr "Кодирование текста"

#: ../../library/io.rst:114
msgid ""
"The default encoding of :class:`TextIOWrapper` and :func:`open` is locale-"
"specific (:func:`locale.getpreferredencoding(False) <locale."
"getpreferredencoding>`)."
msgstr ""

#: ../../library/io.rst:117
msgid ""
"However, many developers forget to specify the encoding when opening text "
"files encoded in UTF-8 (e.g. JSON, TOML, Markdown, etc...) since most Unix "
"platforms use UTF-8 locale by default. This causes bugs because the locale "
"encoding is not UTF-8 for most Windows users. For example::"
msgstr ""
"Однако многие разработчики забывают указывать кодировку при открытии "
"текстовых файлов, закодированных в UTF-8 (например, JSON, TOML, Markdown и "
"т. д.), поскольку большинство платформ Unix по умолчанию используют локаль "
"UTF-8. Это вызывает ошибки, поскольку для большинства пользователей Windows "
"кодировка локали отличается от UTF-8. Например::"

#: ../../library/io.rst:126
msgid ""
"Additionally, while there is no concrete plan as of yet, Python may change "
"the default text file encoding to UTF-8 in the future."
msgstr ""

#: ../../library/io.rst:129
msgid ""
"Accordingly, it is highly recommended that you specify the encoding "
"explicitly when opening text files. If you want to use UTF-8, pass "
"``encoding=\"utf-8\"``. To use the current locale encoding, "
"``encoding=\"locale\"`` is supported in Python 3.10."
msgstr ""

#: ../../library/io.rst:134
msgid ""
"When you need to run existing code on Windows that attempts to open UTF-8 "
"files using the default locale encoding, you can enable the UTF-8 mode. See :"
"ref:`UTF-8 mode on Windows <win-utf8-mode>`."
msgstr ""

#: ../../library/io.rst:141
msgid "Opt-in EncodingWarning"
msgstr "Предупреждение о согласии на кодирование"

#: ../../library/io.rst:143
msgid "See :pep:`597` for more details."
msgstr "См. :pep:`597` для более подробной информации."

#: ../../library/io.rst:146
msgid ""
"To find where the default locale encoding is used, you can enable the ``-X "
"warn_default_encoding`` command line option or set the :envvar:"
"`PYTHONWARNDEFAULTENCODING` environment variable, which will emit an :exc:"
"`EncodingWarning` when the default encoding is used."
msgstr ""

#: ../../library/io.rst:151
msgid ""
"If you are providing an API that uses :func:`open` or :class:`TextIOWrapper` "
"and passes ``encoding=None`` as a parameter, you can use :func:"
"`text_encoding` so that callers of the API will emit an :exc:"
"`EncodingWarning` if they don't pass an ``encoding``. However, please "
"consider using UTF-8 by default (i.e. ``encoding=\"utf-8\"``) for new APIs."
msgstr ""
"Если вы предоставляете API, который использует :func:`open` или :class:"
"`TextIOWrapper` и передает ``encoding=None`` в качестве параметра, вы можете "
"использовать :func:`text_encoding`, чтобы вызывающие API выдать :exc:"
"`EncodingWarning`, если они не передают ``кодировку``. Однако рассмотрите "
"возможность использования UTF-8 по умолчанию (т. е. encoding=\"utf-8\"``) "
"для новых API."

#: ../../library/io.rst:160
msgid "High-level Module Interface"
msgstr "Высокоуровневый модульный интерфейс"

#: ../../library/io.rst:164
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""
"Целое число, содержащее размер буфера по умолчанию, используемый "
"буферизованными классами ввода-вывода модуля. :func:`open` использует "
"blksize файла (полученный :func:`os.stat`), если это возможно."

#: ../../library/io.rst:171
msgid "This is an alias for the builtin :func:`open` function."
msgstr "Это псевдоним встроенной функции :func:`open`."

#: ../../library/io.rst:173
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"Raises an :ref:`auditing event\n"
"` ``open`` with arguments ``path``, ``mode``, ``flags``."

#: ../../library/io.rst:175
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments ``path``, ``mode`` and ``flags``. The ``mode`` and ``flags`` "
"arguments may have been modified or inferred from the original call."
msgstr ""

#: ../../library/io.rst:182
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr ""
"Открывает предоставленный файл в режиме ``'rb'``. Эту функцию следует "
"использовать, когда намерение состоит в том, чтобы рассматривать содержимое "
"как исполняемый код."

#: ../../library/io.rst:185
msgid "``path`` should be a :class:`str` and an absolute path."
msgstr ""

#: ../../library/io.rst:187
msgid ""
"The behavior of this function may be overridden by an earlier call to the :c:"
"func:`PyFile_SetOpenCodeHook`. However, assuming that ``path`` is a :class:"
"`str` and an absolute path, ``open_code(path)`` should always behave the "
"same as ``open(path, 'rb')``. Overriding the behavior is intended for "
"additional validation or preprocessing of the file."
msgstr ""

#: ../../library/io.rst:198
msgid ""
"This is a helper function for callables that use :func:`open` or :class:"
"`TextIOWrapper` and have an ``encoding=None`` parameter."
msgstr ""
"Это вспомогательная функция для вызываемых объектов, которые используют :"
"func:`open` или :class:`TextIOWrapper` и имеют параметр ``encoding=None``."

#: ../../library/io.rst:201
msgid ""
"This function returns *encoding* if it is not ``None`` and ``\"locale\"`` if "
"*encoding* is ``None``."
msgstr ""

#: ../../library/io.rst:204
msgid ""
"This function emits an :class:`EncodingWarning` if :data:`sys.flags."
"warn_default_encoding <sys.flags>` is true and *encoding* is None. "
"*stacklevel* specifies where the warning is emitted. For example::"
msgstr ""

#: ../../library/io.rst:214
msgid ""
"In this example, an :class:`EncodingWarning` is emitted for the caller of "
"``read_text()``."
msgstr ""
"В этом примере для вызывающего метода read_text() выдается :class:"
"`EncodingWarning``."

#: ../../library/io.rst:217
msgid "See :ref:`io-text-encoding` for more information."
msgstr "См. :ref:`io-text-encoding` для получения дополнительной информации."

#: ../../library/io.rst:224
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr ""
"Это псевдоним совместимости для встроенного исключения :exc:"
"`BlockingIOError`."

#: ../../library/io.rst:230
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ""
"Исключение, наследующее :exc:`OSError` и :exc:`ValueError`, которое "
"возникает, когда в потоке вызывается неподдерживаемая операция."

#: ../../library/io.rst:237
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../../library/io.rst:237
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, "
"and :data:`sys.stderr`."
msgstr ""
"содержит стандартные потоки ввода-вывода: :data:`sys.stdin`, :data:`sys."
"stdout` и :data:`sys.stderr`."

#: ../../library/io.rst:242
msgid "Class hierarchy"
msgstr "Иерархия классов"

#: ../../library/io.rst:244
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes.  "
"First :term:`abstract base classes <abstract base class>` (ABCs), which are "
"used to specify the various categories of streams, then concrete classes "
"providing the standard stream implementations."
msgstr ""
"Реализация потоков ввода-вывода организована в виде иерархии классов. "
"Сначала абстрактные базовые классы <абстрактный базовый класс> (ABC), "
"которые используются для определения различных категорий потоков, затем "
"конкретные классы, предоставляющие стандартные реализации потоков."

#: ../../library/io.rst:251
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of :"
"meth:`~IOBase.readinto` and :meth:`~IOBase.readline`."
msgstr ""

#: ../../library/io.rst:256
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to raise :exc:`UnsupportedOperation` if they do not support a given "
"operation."
msgstr ""
"На вершине иерархии ввода-вывода находится абстрактный базовый класс :class:"
"`IOBase`. Он определяет базовый интерфейс для потока. Однако обратите "
"внимание, что нет разделения между чтением и записью в потоки; реализациям "
"разрешено вызывать :exc:`UnsupportedOperation`, если они не поддерживают "
"данную операцию."

#: ../../library/io.rst:261
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses :class:"
"`RawIOBase` to provide an interface to files in the machine's file system."
msgstr ""
":class:`RawIOBase` ABC расширяет :class:`IOBase`. Он занимается чтением и "
"записью байтов в поток. :class:`FileIO` подклассы :class:`RawIOBase` для "
"обеспечения интерфейса к файлам в файловой системе машины."

#: ../../library/io.rst:265
msgid ""
"The :class:`BufferedIOBase` ABC extends :class:`IOBase`.  It deals with "
"buffering on a raw binary stream (:class:`RawIOBase`).  Its subclasses, :"
"class:`BufferedWriter`, :class:`BufferedReader`, and :class:`BufferedRWPair` "
"buffer raw binary streams that are writable, readable, and both readable and "
"writable, respectively. :class:`BufferedRandom` provides a buffered "
"interface to seekable streams. Another :class:`BufferedIOBase` subclass, :"
"class:`BytesIO`, is a stream of in-memory bytes."
msgstr ""
":class:`BufferedIOBase` ABC расширяет :class:`IOBase`. Он занимается "
"буферизацией необработанного двоичного потока (:class:`RawIOBase`). Его "
"подклассы :class:`BufferedWriter`, :class:`BufferedReader` и :class:"
"`BufferedRWPair` буферизуют необработанные двоичные потоки, которые доступны "
"для записи, чтения, а также для чтения и записи соответственно. :class:"
"`BufferedRandom` предоставляет буферизованный интерфейс для поиска потоков. "
"Другой подкласс :class:`BufferedIOBase`, :class:`BytesIO`, представляет "
"собой поток байтов в памяти."

#: ../../library/io.rst:273
msgid ""
"The :class:`TextIOBase` ABC extends :class:`IOBase`.  It deals with streams "
"whose bytes represent text, and handles encoding and decoding to and from "
"strings.  :class:`TextIOWrapper`, which extends :class:`TextIOBase`, is a "
"buffered text interface to a buffered raw stream (:class:`BufferedIOBase`).  "
"Finally, :class:`StringIO` is an in-memory stream for text."
msgstr ""
":class:`TextIOBase` ABC расширяет :class:`IOBase`. Он имеет дело с потоками, "
"байты которых представляют текст, и обрабатывает кодирование и декодирование "
"строк. :class:`TextIOWrapper`, который расширяет :class:`TextIOBase`, "
"представляет собой буферизованный текстовый интерфейс для буферизованного "
"необработанного потока (:class:`BufferedIOBase`). Наконец, :class:`StringIO` "
"— это поток текста в памяти."

#: ../../library/io.rst:279
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`open` are intended to be used as keyword arguments."
msgstr ""
"Имена аргументов не являются частью спецификации, и только аргументы :func:"
"`open` предназначены для использования в качестве аргументов ключевого слова."

#: ../../library/io.rst:282
msgid ""
"The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr ""
"В следующей таблице суммированы ABC, предоставляемые модулем :mod:`io`:"

#: ../../library/io.rst:287
msgid "ABC"
msgstr "ABC"

#: ../../library/io.rst:287
msgid "Inherits"
msgstr "Наследует"

#: ../../library/io.rst:287
msgid "Stub Methods"
msgstr "Методы заглушки"

#: ../../library/io.rst:287
msgid "Mixin Methods and Properties"
msgstr "Методы и свойства миксинов"

#: ../../library/io.rst:289 ../../library/io.rst:294 ../../library/io.rst:296
#: ../../library/io.rst:298
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../../library/io.rst:289
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``, ``seek`` и ``truncate``"

#: ../../library/io.rst:289
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"

#: ../../library/io.rst:294
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../../library/io.rst:294
msgid "``readinto`` and ``write``"
msgstr "``readinto`` и ``write``"

#: ../../library/io.rst:294
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "Унаследованные методы :class:`IOBase`, ``read`` и ``readall``"

#: ../../library/io.rst:296
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../../library/io.rst:296
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``, ``read``, ``read1``, and ``write``"

#: ../../library/io.rst:296
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "Унаследованные методы :class:`IOBase`, ``readinto`` и ``readinto1``"

#: ../../library/io.rst:298
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../../library/io.rst:298
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``, ``read``, ``readline``, and ``write``"

#: ../../library/io.rst:298
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and ``newlines``"
msgstr ""
"Унаследованные методы :class:`IOBase`, ``кодирование``, ``ошибки`` и ``новая "
"строка``"

#: ../../library/io.rst:305
msgid "I/O Base Classes"
msgstr "Базовые классы ввода/вывода"

#: ../../library/io.rst:309
msgid "The abstract base class for all I/O classes."
msgstr "Абстрактный базовый класс для всех классов ввода-вывода."

#: ../../library/io.rst:311
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""
"Этот класс предоставляет пустые абстрактные реализации для многих методов, "
"которые производные классы могут выборочно переопределять; реализации по "
"умолчанию представляют файл, который нельзя прочитать, записать или найти."

#: ../../library/io.rst:316
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read` or :meth:`write` "
"because their signatures will vary, implementations and clients should "
"consider those methods part of the interface.  Also, implementations may "
"raise a :exc:`ValueError` (or :exc:`UnsupportedOperation`) when operations "
"they do not support are called."
msgstr ""

#: ../../library/io.rst:322
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are accepted "
"as method arguments too.  Text I/O classes work with :class:`str` data."
msgstr ""
"Базовый тип, используемый для двоичных данных, считываемых из файла или "
"записываемых в него, — это :class:`bytes`. Другие :term:`байтоподобные "
"объекты <байтоподобный объект>` также принимаются в качестве аргументов "
"метода. Классы текстового ввода-вывода работают с данными :class:`str`."

#: ../../library/io.rst:326
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr ""
"Обратите внимание, что вызов любого метода (даже запроса) в закрытом потоке "
"не определен. В этом случае реализации могут вызвать :exc:`ValueError`."

#: ../../library/io.rst:329
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, meaning "
"that an :class:`IOBase` object can be iterated over yielding the lines in a "
"stream.  Lines are defined slightly differently depending on whether the "
"stream is a binary stream (yielding bytes), or a text stream (yielding "
"character strings).  See :meth:`~IOBase.readline` below."
msgstr ""
":class:`IOBase` (и его подклассы) поддерживает протокол итератора, что "
"означает, что объект :class:`IOBase` может быть перебором для получения "
"строк в потоке. Строки определяются немного по-разному в зависимости от "
"того, является ли поток двоичным (выдающим байты) или текстовым потоком "
"(выдающим строки символов). См. :meth:`~IOBase.readline` ниже."

#: ../../library/io.rst:335
msgid ""
":class:`IOBase` is also a context manager and therefore supports the :"
"keyword:`with` statement.  In this example, *file* is closed after the :"
"keyword:`!with` statement's suite is finished---even if an exception occurs::"
msgstr ""
":class:`IOBase` также является менеджером контекста и поэтому поддерживает "
"оператор :keyword:`with`. В этом примере *file* закрывается после завершения "
"набора операторов :keyword:`!with` --- даже если возникает исключение::"

#: ../../library/io.rst:342
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` предоставляет следующие атрибуты данных и методы:"

#: ../../library/io.rst:346
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""
"Очистите и закройте этот поток. Этот метод не имеет эффекта, если файл уже "
"закрыт. После закрытия файла любая операция с ним (например, чтение или "
"запись) вызовет ошибку :exc:`ValueError`."

#: ../../library/io.rst:350
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr ""
"Для удобства разрешено вызывать этот метод более одного раза; Однако только "
"первый звонок будет иметь эффект."

#: ../../library/io.rst:355
msgid "``True`` if the stream is closed."
msgstr "``True``, если поток закрыт."

#: ../../library/io.rst:359
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file "
"descriptor."
msgstr ""
"Возвращает базовый файловый дескриптор (целое число) потока, если он "
"существует. Ошибка :exc:`OSError` возникает, если объект ввода-вывода не "
"использует дескриптор файла."

#: ../../library/io.rst:365
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr ""
"Очистите буферы записи потока, если это применимо. Это ничего не дает для "
"потоков только для чтения и неблокирующих потоков."

#: ../../library/io.rst:370
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr ""
"Верните ``True``, если поток является интерактивным (т. е. подключен к "
"терминалу/терминальному устройству)."

#: ../../library/io.rst:375
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`OSError`."
msgstr ""

#: ../../library/io.rst:380
msgid ""
"Read and return one line from the stream.  If *size* is specified, at most "
"*size* bytes will be read."
msgstr ""
"Прочитайте и верните одну строку из потока. Если указан *size*, будет "
"прочитано не более *size* байт."

#: ../../library/io.rst:383
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`open` can be used to select the line "
"terminator(s) recognized."
msgstr ""
"Терминатором строки всегда является ``b'\\n'`` для двоичных файлов; для "
"текстовых файлов аргумент *newline* функции :func:`open` может "
"использоваться для выбора распознаваемого признака конца строки."

#: ../../library/io.rst:389
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"Прочитайте и верните список строк из потока. *hint* можно указать для "
"управления количеством прочитанных строк: строки больше не будут читаться, "
"если общий размер (в байтах/символах) всех строк на данный момент превышает "
"*hint*."

#: ../../library/io.rst:393
msgid ""
"*hint* values of ``0`` or less, as well as ``None``, are treated as no hint."
msgstr ""
"Значения *hint*, равные ``0`` или меньше, а также ``None``, не "
"рассматриваются как отсутствие подсказки."

#: ../../library/io.rst:396
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr ""

#: ../../library/io.rst:401
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr ""

#: ../../library/io.rst:405
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ""

#: ../../library/io.rst:407
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ""

#: ../../library/io.rst:409
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ""

#: ../../library/io.rst:412
msgid "Return the new absolute position."
msgstr ""

#: ../../library/io.rst:414 ../../library/io.rst:923
msgid "The ``SEEK_*`` constants."
msgstr ""

#: ../../library/io.rst:417
msgid ""
"Some operating systems could support additional values, like :data:`os."
"SEEK_HOLE` or :data:`os.SEEK_DATA`. The valid values for a file could depend "
"on it being open in text or binary mode."
msgstr ""

#: ../../library/io.rst:424
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"Верните True, если поток поддерживает произвольный доступ. Если ``False``, :"
"meth:`seek`, :meth:`tell` и :meth:`truncate` вызовут :exc:`OSError`."

#: ../../library/io.rst:429
msgid "Return the current stream position."
msgstr "Вернуть текущую позицию потока."

#: ../../library/io.rst:433
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled).  The new file size is returned."
msgstr ""
"Измените размер потока до заданного *размера* в байтах (или текущей позиции, "
"если *размер* не указан). Текущая позиция потока не изменяется. Это "
"изменение размера может увеличить или уменьшить текущий размер файла. В "
"случае расширения содержимое новой файловой области зависит от платформы (в "
"большинстве систем дополнительные байты заполняются нулями). Возвращается "
"новый размер файла."

#: ../../library/io.rst:440
msgid "Windows will now zero-fill files when extending."
msgstr "Windows теперь будет заполнять файлы нулями при расширении."

#: ../../library/io.rst:445
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write` "
"and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""

#: ../../library/io.rst:450
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr ""
"Записать список строк в поток. Разделители строк не добавляются, поэтому "
"обычно каждая из предоставленных строк имеет разделитель строк в конце."

#: ../../library/io.rst:456
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's :meth:`~IOBase."
"close` method."
msgstr ""
"Приготовьтесь к уничтожению объекта. :class:`IOBase` предоставляет "
"реализацию этого метода по умолчанию, которая вызывает метод :meth:`~IOBase."
"close` экземпляра."

#: ../../library/io.rst:463
msgid "Base class for raw binary streams.  It inherits :class:`IOBase`."
msgstr ""

#: ../../library/io.rst:465
msgid ""
"Raw binary streams typically provide low-level access to an underlying OS "
"device or API, and do not try to encapsulate it in high-level primitives "
"(this functionality is done at a higher-level in buffered binary streams and "
"text streams, described later in this page)."
msgstr ""
"Необработанные двоичные потоки обычно обеспечивают низкоуровневый доступ к "
"базовому устройству ОС или API и не пытаются инкапсулировать его в примитивы "
"высокого уровня (эта функциональность реализуется на более высоком уровне в "
"буферизованных двоичных потоках и текстовых потоках, описанных позже в "
"разделе эту страницу)."

#: ../../library/io.rst:470
msgid ""
":class:`RawIOBase` provides these methods in addition to those from :class:"
"`IOBase`:"
msgstr ""
":class:`RawIOBase` предоставляет эти методы в дополнение к методам из :class:"
"`IOBase`:"

#: ../../library/io.rst:475
msgid ""
"Read up to *size* bytes from the object and return them.  As a convenience, "
"if *size* is unspecified or -1, all bytes until EOF are returned. Otherwise, "
"only one system call is ever made.  Fewer than *size* bytes may be returned "
"if the operating system call returns fewer than *size* bytes."
msgstr ""
"Считайте до *size* байт из объекта и верните их. Для удобства, если *size* "
"не указано или равно -1, возвращаются все байты до EOF. В противном случае "
"выполняется только один системный вызов. Может быть возвращено меньше *size* "
"байт, если вызов операционной системы возвращает менее *size* байт."

#: ../../library/io.rst:480
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of file. "
"If the object is in non-blocking mode and no bytes are available, ``None`` "
"is returned."
msgstr ""
"Если возвращается 0 байт, а *size* не равно 0, это указывает на конец файла. "
"Если объект находится в неблокирующем режиме и нет доступных байтов, "
"возвращается None."

#: ../../library/io.rst:484
msgid ""
"The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr ""
"Реализация по умолчанию относится к :meth:`readall` и :meth:`readinto`."

#: ../../library/io.rst:489
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr ""
"Считайте и верните все байты из потока до EOF, при необходимости используя "
"несколько вызовов потока."

#: ../../library/io.rst:494
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, and "
"return the number of bytes read.  For example, *b* might be a :class:"
"`bytearray`. If the object is in non-blocking mode and no bytes are "
"available, ``None`` is returned."
msgstr ""
"Считайте байты в предварительно выделенный, доступный для записи :term:"
"`байтовый объект` *b* и верните количество прочитанных байтов. Например, *b* "
"может быть :class:`bytearray`. Если объект находится в неблокирующем режиме "
"и нет доступных байтов, возвращается None."

#: ../../library/io.rst:502
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than the "
"length of *b* in bytes, depending on specifics of the underlying raw stream, "
"and especially if it is in non-blocking mode.  ``None`` is returned if the "
"raw stream is set not to block and no single byte could be readily written "
"to it.  The caller may release or mutate *b* after this method returns, so "
"the implementation should only access *b* during the method call."
msgstr ""
"Запишите данный :term:`байтоподобный объект`, *b*, в базовый необработанный "
"поток и верните количество записанных байтов. Это может быть меньше длины "
"*b* в байтах, в зависимости от особенностей базового необработанного потока, "
"особенно если он находится в неблокирующем режиме. ``None`` возвращается, "
"если необработанный поток не блокируется и в него не может быть легко "
"записан ни один байт. Вызывающий может освободить или изменить *b* после "
"возврата этого метода, поэтому реализация должна обращаться к *b* только во "
"время вызова метода."

#: ../../library/io.rst:515
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`."
msgstr ""

#: ../../library/io.rst:518
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, :"
"meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ""
"Основное отличие от :class:`RawIOBase` заключается в том, что методы :meth:"
"`read`, :meth:`readinto` и :meth:`write` будут пытаться (соответственно) "
"прочитать столько входных данных, сколько запрошено, или использовать все "
"заданные данные. вывод, за счет выполнения, возможно, более одного "
"системного вызова."

#: ../../library/io.rst:523
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough "
"data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr ""
"Кроме того, эти методы могут вызвать :exc:`BlockingIOError`, если базовый "
"необработанный поток находится в неблокирующем режиме и не может принять или "
"передать достаточно данных; в отличие от своих аналогов :class:`RawIOBase`, "
"они никогда не возвращают ``None``."

#: ../../library/io.rst:528
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that "
"defers to :meth:`readinto`."
msgstr ""
"Кроме того, метод :meth:`read` не имеет реализации по умолчанию, которая "
"подчинялась бы :meth:`readinto`."

#: ../../library/io.rst:531
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a :"
"class:`RawIOBase` implementation, but wrap one, like :class:`BufferedWriter` "
"and :class:`BufferedReader` do."
msgstr ""
"Типичная реализация :class:`BufferedIOBase` не должна наследовать от "
"реализации :class:`RawIOBase`, а должна быть ее оберткой, как это делают :"
"class:`BufferedWriter` и :class:`BufferedReader`."

#: ../../library/io.rst:535
msgid ""
":class:`BufferedIOBase` provides or overrides these data attributes and "
"methods in addition to those from :class:`IOBase`:"
msgstr ""
":class:`BufferedIOBase` предоставляет или переопределяет эти атрибуты и "
"методы данных в дополнение к атрибутам и методам из :class:`IOBase`:"

#: ../../library/io.rst:540
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that :class:"
"`BufferedIOBase` deals with.  This is not part of the :class:"
"`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
"Базовый необработанный поток (экземпляр :class:`RawIOBase`), с которым "
"работает :class:`BufferedIOBase`. Это не часть API :class:`BufferedIOBase` и "
"может отсутствовать в некоторых реализациях."

#: ../../library/io.rst:546
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "Отделите базовый необработанный поток от буфера и верните его."

#: ../../library/io.rst:548
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr ""
"После отсоединения необработанного потока буфер находится в непригодном для "
"использования состоянии."

#: ../../library/io.rst:551
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw "
"stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""
"Некоторые буферы, такие как :class:`BytesIO`, не имеют концепции единого "
"необработанного потока, возвращаемого этим методом. Они вызывают :exc:"
"`UnsupportedOperation`."

#: ../../library/io.rst:559
msgid ""
"Read and return up to *size* bytes.  If the argument is omitted, ``None``, "
"or negative, data is read and returned until EOF is reached.  An empty :"
"class:`bytes` object is returned if the stream is already at EOF."
msgstr ""
"Чтение и возврат до *size* байт. Если аргумент опущен, «Нет» или "
"отрицательный, данные считываются и возвращаются до тех пор, пока не будет "
"достигнут EOF. Пустой объект :class:`bytes` возвращается, если поток уже "
"находится в EOF."

#: ../../library/io.rst:563
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""
"Если аргумент положительный, а базовый необработанный поток не является "
"интерактивным, может быть выполнено несколько необработанных операций чтения "
"для удовлетворения количества байтов (если сначала не будет достигнут EOF). "
"Но для интерактивных необработанных потоков будет выполнено не более одного "
"необработанного чтения, и короткий результат не означает, что EOF неизбежен."

#: ../../library/io.rst:569 ../../library/io.rst:592 ../../library/io.rst:602
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr ""
"Ошибка :exc:`BlockingIOError` возникает, если базовый необработанный поток "
"находится в неблокирующем режиме и в данный момент не имеет доступных данных."

#: ../../library/io.rst:574
msgid ""
"Read and return up to *size* bytes, with at most one call to the underlying "
"raw stream's :meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) "
"method.  This can be useful if you are implementing your own buffering on "
"top of a :class:`BufferedIOBase` object."
msgstr ""
"Чтение и возврат до *size* байт, не более чем с одним вызовом метода :meth:"
"`~RawIOBase.read` (или :meth:`~RawIOBase.readinto`) базового необработанного "
"потока. Это может быть полезно, если вы реализуете собственную буферизацию "
"поверх объекта :class:`BufferedIOBase`."

#: ../../library/io.rst:580
msgid ""
"If *size* is ``-1`` (the default), an arbitrary number of bytes are returned "
"(more than zero unless EOF is reached)."
msgstr ""
"Если *size* равен ``-1`` (по умолчанию), возвращается произвольное "
"количество байтов (больше нуля, если не достигнут EOF)."

#: ../../library/io.rst:585
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* and "
"return the number of bytes read. For example, *b* might be a :class:"
"`bytearray`."
msgstr ""
"Считайте байты в предварительно выделенный, доступный для записи :term:"
"`байтовый объект` *b* и верните количество прочитанных байтов. Например, *b* "
"может быть :class:`bytearray`."

#: ../../library/io.rst:589
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr ""
"Как и :meth:`read`, к базовому необработанному потоку может быть выполнено "
"несколько операций чтения, если только последний не является интерактивным."

#: ../../library/io.rst:597
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's :meth:`~RawIOBase."
"read` (or :meth:`~RawIOBase.readinto`) method. Return the number of bytes "
"read."
msgstr ""
"Считайте байты в предварительно выделенный, доступный для записи :term:"
"`bytes-like объект` *b*, используя не более одного вызова :meth:`~RawIOBase."
"read` базового необработанного потока (или :meth:`~RawIOBase. readinto`) "
"метод. Возвращает количество прочитанных байт."

#: ../../library/io.rst:609
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream, "
"or held in a buffer for performance and latency reasons."
msgstr ""
"Запишите заданный :term:`байтоподобный объект`, *b*, и верните количество "
"записанных байтов (всегда равное длине *b* в байтах, поскольку в случае сбоя "
"записи выдается :exc:`OSError` быть поднята). В зависимости от фактической "
"реализации эти байты могут быть легко записаны в базовый поток или сохранены "
"в буфере по соображениям производительности и задержки."

#: ../../library/io.rst:616
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr ""
"В неблокирующем режиме возникает ошибка :exc:`BlockingIOError`, если данные "
"необходимо записать в необработанный поток, но он не может принять все "
"данные без блокировки."

#: ../../library/io.rst:620
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr ""
"Вызывающий может освободить или изменить *b* после возврата этого метода, "
"поэтому реализация должна обращаться к *b* только во время вызова метода."

#: ../../library/io.rst:625
msgid "Raw File I/O"
msgstr "Ввод/вывод необработанного файла"

#: ../../library/io.rst:629
msgid ""
"A raw binary stream representing an OS-level file containing bytes data.  It "
"inherits :class:`RawIOBase`."
msgstr ""

#: ../../library/io.rst:632
msgid "The *name* can be one of two things:"
msgstr "*name* может быть одним из двух:"

#: ../../library/io.rst:634
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"строка символов или объект :class:`bytes`, представляющий путь к файлу, "
"который будет открыт. В этом случае closefd должен иметь значение True (по "
"умолчанию), иначе будет выдана ошибка."

#: ../../library/io.rst:637
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access. When the "
"FileIO object is closed this fd will be closed as well, unless *closefd* is "
"set to ``False``."
msgstr ""
"целое число, представляющее номер существующего файлового дескриптора уровня "
"ОС, к которому результирующий объект :class:`FileIO` предоставит доступ. "
"Когда объект FileIO закрывается, этот файловый каталог также будет закрыт, "
"если только для *closefd* не установлено значение «False»."

#: ../../library/io.rst:642
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will be "
"truncated when opened for writing. :exc:`FileExistsError` will be raised if "
"it already exists when opened for creating. Opening a file for creating "
"implies writing, so this mode behaves in a similar way to ``'w'``. Add a "
"``'+'`` to the mode to allow simultaneous reading and writing."
msgstr ""
"*mode* может быть ``'r'``, ``'w'``, ``'x'`` или ``'a'`` для чтения (по "
"умолчанию), записи, эксклюзивного создания или добавления. Файл будет "
"создан, если он не существует при открытии для записи или добавления; он "
"будет усечен при открытии для записи. :exc:`FileExistsError` будет вызван, "
"если он уже существовал при открытии для создания. Открытие файла для "
"создания подразумевает запись, поэтому этот режим ведет себя аналогично "
"режиму ``'w'``. Добавьте ``'+'`` к режиму, чтобы разрешить одновременное "
"чтение и запись."

#: ../../library/io.rst:650
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr ""

#: ../../library/io.rst:653
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*name*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"Пользовательский открыватель можно использовать, передав вызываемый объект "
"как *opener*. Базовый файловый дескриптор файлового объекта затем получается "
"путем вызова *opener* с (*name*, *flags*). *opener* должен возвращать "
"дескриптор открытого файла (передача :mod:`os.open` как *opener* приводит к "
"функциональности, аналогичной передаче ``None``)."

#: ../../library/io.rst:659
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "Новый созданный файл - это :ref:`non-inheritable <fd_inheritance>`."

#: ../../library/io.rst:661
msgid ""
"See the :func:`open` built-in function for examples on using the *opener* "
"parameter."
msgstr ""
"См. встроенную функцию :func:`open` для примеров использования параметра "
"*opener*."

#: ../../library/io.rst:664
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr "Добавлен параметр *opener*. Добавлен режим ``'x'``."

#: ../../library/io.rst:668
msgid "The file is now non-inheritable."
msgstr "Файл теперь не наследуется."

#: ../../library/io.rst:671
msgid ""
":class:`FileIO` provides these data attributes in addition to those from :"
"class:`RawIOBase` and :class:`IOBase`:"
msgstr ""
":class:`FileIO` предоставляет эти атрибуты данных в дополнение к атрибутам "
"из :class:`RawIOBase` и :class:`IOBase`:"

#: ../../library/io.rst:676
msgid "The mode as given in the constructor."
msgstr "Режим, заданный в конструкторе."

#: ../../library/io.rst:680
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr ""
"Имя файла. Это файловый дескриптор файла, если в конструкторе не указано имя."

#: ../../library/io.rst:685
msgid "Buffered Streams"
msgstr "Буферизованные потоки"

#: ../../library/io.rst:687
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr ""
"Буферизованные потоки ввода-вывода обеспечивают интерфейс более высокого "
"уровня для устройства ввода-вывода, чем необработанный ввод-вывод."

#: ../../library/io.rst:692
msgid ""
"A binary stream using an in-memory bytes buffer.  It inherits :class:"
"`BufferedIOBase`.  The buffer is discarded when the :meth:`~IOBase.close` "
"method is called."
msgstr ""

#: ../../library/io.rst:696
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that "
"contains initial data."
msgstr ""
"Необязательный аргумент *initial_bytes* представляет собой объект типа :term:"
"`bytes`, который содержит исходные данные."

#: ../../library/io.rst:699
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BytesIO` предоставляет или переопределяет эти методы в дополнение к "
"методам из :class:`BufferedIOBase` и :class:`IOBase`:"

#: ../../library/io.rst:704
msgid ""
"Return a readable and writable view over the contents of the buffer without "
"copying them.  Also, mutating the view will transparently update the "
"contents of the buffer::"
msgstr ""
"Возвращает доступное для чтения и записи представление содержимого буфера "
"без его копирования. Кроме того, изменение представления прозрачно обновит "
"содержимое буфера::"

#: ../../library/io.rst:715
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized or "
"closed."
msgstr ""
"Пока представление существует, объект :class:`BytesIO` не может быть изменен "
"или закрыт."

#: ../../library/io.rst:722
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr "Возврат :class:`bytes`, содержащий все содержимое буфера."

#: ../../library/io.rst:727
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr "В :class:`BytesIO` это то же самое, что :meth:`~BufferedIOBase.read`."

#: ../../library/io.rst:729 ../../library/io.rst:772
msgid "The *size* argument is now optional."
msgstr "Аргумент *size* теперь является необязательным."

#: ../../library/io.rst:734
msgid ""
"In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr ""
"В :class:`BytesIO` это то же самое, что :meth:`~BufferedIOBase.readinto`."

#: ../../library/io.rst:740
msgid ""
"A buffered binary stream providing higher-level access to a readable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""

#: ../../library/io.rst:744
msgid ""
"When reading data from this object, a larger amount of data may be requested "
"from the underlying raw stream, and kept in an internal buffer. The buffered "
"data can then be returned directly on subsequent reads."
msgstr ""
"При чтении данных из этого объекта больший объем данных может быть запрошен "
"из базового необработанного потока и сохранен во внутреннем буфере. "
"Буферизованные данные затем могут быть возвращены непосредственно при "
"последующих чтениях."

#: ../../library/io.rst:748
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""
"Конструктор создает :class:`BufferedReader` для данного читаемого *raw* "
"потока и *buffer_size*. Если *buffer_size* опущен, используется :data:"
"`DEFAULT_BUFFER_SIZE`."

#: ../../library/io.rst:752
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedReader` предоставляет или переопределяет эти методы в "
"дополнение к методам из :class:`BufferedIOBase` и :class:`IOBase`:"

#: ../../library/io.rst:757
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr ""
"Возвращает байты из потока без перемещения позиции. Для удовлетворения "
"вызова выполняется не более одного чтения необработанного потока. Количество "
"возвращенных байтов может быть меньше или больше запрошенного."

#: ../../library/io.rst:763
msgid ""
"Read and return *size* bytes, or if *size* is not given or negative, until "
"EOF or if the read call would block in non-blocking mode."
msgstr ""
"Считайте и верните *size* байты, или, если *size* не задано или "
"отрицательное значение, до тех пор, пока не будет достигнут конец EOF или "
"если вызов чтения не заблокируется в неблокирующем режиме."

#: ../../library/io.rst:768
msgid ""
"Read and return up to *size* bytes with only one call on the raw stream. If "
"at least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr ""
"Чтение и возврат до *размера* байтов за один вызов необработанного потока. "
"Если хотя бы один байт находится в буфере, возвращаются только "
"буферизованные байты. В противном случае выполняется один вызов чтения "
"необработанного потока."

#: ../../library/io.rst:778
msgid ""
"A buffered binary stream providing higher-level access to a writeable, non "
"seekable :class:`RawIOBase` raw binary stream.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""

#: ../../library/io.rst:782
msgid ""
"When writing to this object, data is normally placed into an internal "
"buffer.  The buffer will be written out to the underlying :class:`RawIOBase` "
"object under various conditions, including:"
msgstr ""
"При записи в этот объект данные обычно помещаются во внутренний буфер. Буфер "
"будет записан в базовый объект :class:`RawIOBase` при различных условиях, "
"включая:"

#: ../../library/io.rst:786
msgid "when the buffer gets too small for all pending data;"
msgstr "когда буфер становится слишком мал для всех ожидающих данных;"

#: ../../library/io.rst:787
msgid "when :meth:`flush()` is called;"
msgstr ""

#: ../../library/io.rst:788
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr ""

#: ../../library/io.rst:789
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr "когда объект :class:`BufferedWriter` закрыт или уничтожен."

#: ../../library/io.rst:791
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"Конструктор создает :class:`BufferedWriter` для данного записываемого *raw* "
"потока. Если *buffer_size* не указан, по умолчанию используется значение :"
"data:`DEFAULT_BUFFER_SIZE`."

#: ../../library/io.rst:795
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedWriter` предоставляет или переопределяет эти методы в "
"дополнение к методам из :class:`BufferedIOBase` и :class:`IOBase`:"

#: ../../library/io.rst:800
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""
"Принудительно включить байты, хранящиеся в буфере, в необработанный поток. "
"Ошибка :exc:`BlockingIOError` должна возникнуть, если необработанный поток "
"блокируется."

#: ../../library/io.rst:805
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` is raised if "
"the buffer needs to be written out but the raw stream blocks."
msgstr ""
"Напишите :term:`байтовый объект`, *b*, и верните количество записанных "
"байтов. В неблокирующем режиме возникает ошибка :exc:`BlockingIOError`, если "
"буфер необходимо записать, но необработанный поток блокируется."

#: ../../library/io.rst:813
msgid ""
"A buffered binary stream providing higher-level access to a seekable :class:"
"`RawIOBase` raw binary stream.  It inherits :class:`BufferedReader` and :"
"class:`BufferedWriter`."
msgstr ""

#: ../../library/io.rst:817
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"Конструктор создает средства чтения и записи для доступного для поиска "
"необработанного потока, заданного в первом аргументе. Если *buffer_size* "
"опущен, по умолчанию используется значение :data:`DEFAULT_BUFFER_SIZE`."

#: ../../library/io.rst:821
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do.  In addition, :meth:`seek` and :meth:`tell` "
"are guaranteed to be implemented."
msgstr ""

#: ../../library/io.rst:828
msgid ""
"A buffered binary stream providing higher-level access to two non seekable :"
"class:`RawIOBase` raw binary streams---one readable, the other writeable. It "
"inherits :class:`BufferedIOBase`."
msgstr ""

#: ../../library/io.rst:832
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"*reader* и *writer* — это объекты :class:`RawIOBase`, которые доступны для "
"чтения и записи соответственно. Если *buffer_size* опущен, по умолчанию "
"используется значение :data:`DEFAULT_BUFFER_SIZE`."

#: ../../library/io.rst:836
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises :exc:"
"`UnsupportedOperation`."
msgstr ""
":class:`BufferedRWPair` реализует все методы :class:`BufferedIOBase`\\, за "
"исключением :meth:`~BufferedIOBase.detach`, который вызывает :exc:"
"`UnsupportedOperation`."

#: ../../library/io.rst:842
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""
":class:`BufferedRWPair` не пытается синхронизировать доступ к своим базовым "
"необработанным потокам. Вы не должны передавать ему тот же объект, что и "
"читателю и писателю; вместо этого используйте :class:`BufferedRandom`."

#: ../../library/io.rst:852
msgid ""
"Base class for text streams.  This class provides a character and line based "
"interface to stream I/O.  It inherits :class:`IOBase`."
msgstr ""

#: ../../library/io.rst:855
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ""
":class:`TextIOBase` предоставляет или переопределяет эти атрибуты и методы "
"данных в дополнение к атрибутам и методам из :class:`IOBase`:"

#: ../../library/io.rst:860
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr ""
"Имя кодировки, используемой для декодирования байтов потока в строки и для "
"кодирования строк в байты."

#: ../../library/io.rst:865
msgid "The error setting of the decoder or encoder."
msgstr "Ошибка настройки декодера или кодера."

#: ../../library/io.rst:869
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr ""
"Строка, кортеж строк или «Нет», указывающий переведенные на данный момент "
"символы новой строки. В зависимости от реализации и исходных флагов "
"конструктора это может быть недоступно."

#: ../../library/io.rst:875
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that :"
"class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase` "
"API and may not exist in some implementations."
msgstr ""
"Базовый двоичный буфер (экземпляр :class:`BufferedIOBase`), с которым "
"работает :class:`TextIOBase`. Это не часть API :class:`TextIOBase` и может "
"отсутствовать в некоторых реализациях."

#: ../../library/io.rst:881
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr "Отделите базовый двоичный буфер от :class:`TextIOBase` и верните его."

#: ../../library/io.rst:884
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in "
"an unusable state."
msgstr ""
"После отсоединения базового буфера :class:`TextIOBase` находится в "
"непригодном для использования состоянии."

#: ../../library/io.rst:887
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise :"
"exc:`UnsupportedOperation`."
msgstr ""
"Некоторые реализации :class:`TextIOBase`, такие как :class:`StringIO`, могут "
"не иметь концепции базового буфера, и вызов этого метода вызовет :exc:"
"`UnsupportedOperation`."

#: ../../library/io.rst:895
msgid ""
"Read and return at most *size* characters from the stream as a single :class:"
"`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr ""
"Считайте и верните не более символов *size* из потока как один :class:`str`. "
"Если *size* отрицательное значение или ``Нет``, читается до EOF."

#: ../../library/io.rst:900
msgid ""
"Read until newline or EOF and return a single ``str``.  If the stream is "
"already at EOF, an empty string is returned."
msgstr ""

#: ../../library/io.rst:903
msgid "If *size* is specified, at most *size* characters will be read."
msgstr "Если указан *size*, будет прочитано не более символов *size*."

#: ../../library/io.rst:907
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr ""

#: ../../library/io.rst:911
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""

#: ../../library/io.rst:915
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ""

#: ../../library/io.rst:918
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ""

#: ../../library/io.rst:921
msgid "Return the new absolute position as an opaque number."
msgstr "Верните новую абсолютную позицию в виде непрозрачного числа."

#: ../../library/io.rst:928
msgid ""
"Return the current stream position as an opaque number.  The number does not "
"usually represent a number of bytes in the underlying binary storage."
msgstr ""
"Верните текущую позицию потока в виде непрозрачного числа. Число обычно не "
"представляет количество байтов в базовой двоичной памяти."

#: ../../library/io.rst:934
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr "Запишите строку *s* в поток и верните количество записанных символов."

#: ../../library/io.rst:941
msgid ""
"A buffered text stream providing higher-level access to a :class:"
"`BufferedIOBase` buffered binary stream.  It inherits :class:`TextIOBase`."
msgstr ""

#: ../../library/io.rst:945
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getpreferredencoding(False) "
"<locale.getpreferredencoding>`. ``encoding=\"locale\"`` can be used to "
"specify the current locale's encoding explicitly. See :ref:`io-text-"
"encoding` for more information."
msgstr ""

#: ../../library/io.rst:951
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data. "
"``'backslashreplace'`` causes malformed data to be replaced by a backslashed "
"escape sequence.  When writing, ``'xmlcharrefreplace'`` (replace with the "
"appropriate XML character reference)  or ``'namereplace'`` (replace with "
"``\\N{...}`` escape sequences) can be used.  Any other error handling name "
"that has been registered with :func:`codecs.register_error` is also valid."
msgstr ""
"*errors* — необязательная строка, определяющая способ обработки ошибок "
"кодирования и декодирования. Передайте ``'strict'``, чтобы вызвать "
"исключение :exc:`ValueError`, если есть ошибка кодирования (по умолчанию "
"``None`` имеет тот же эффект), или передайте ``'ignore'``, чтобы "
"игнорировать ошибки. (Обратите внимание, что игнорирование ошибок "
"кодирования может привести к потере данных.) ``'replace'`` приводит к "
"вставке маркера замены (например, ``'?'``) там, где есть искаженные данные. "
"``'backslashreplace'`` заставляет некорректные данные заменяться escape-"
"последовательностью с обратной косой чертой. При записи можно использовать "
"``'xmlcharrefreplace'`` (заменить соответствующей ссылкой на символ XML) или "
"``'namereplace'`` (заменить управляющими последовательностями ``\\N{...}``). "
"Любое другое имя обработки ошибок, зарегистрированное с помощью :func:"
"`codecs.register_error`, также допустимо."

#: ../../library/io.rst:967
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* управляет обработкой концов строк. Это может быть ``None``, "
"``''``, ``'\\n'``, ``'\\r'`` и ``'\\r\\n'``. Это работает следующим образом:"

#: ../../library/io.rst:970
msgid ""
"When reading input from the stream, if *newline* is ``None``, :term:"
"`universal newlines` mode is enabled.  Lines in the input can end in "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If *newline* is ``''``, "
"universal newlines mode is enabled, but line endings are returned to the "
"caller untranslated.  If *newline* has any of the other legal values, input "
"lines are only terminated by the given string, and the line ending is "
"returned to the caller untranslated."
msgstr ""
"Если при чтении входных данных из потока *newline* имеет значение ``None``, "
"включается режим :term:`универсальных новых строк`. Строки во входных данных "
"могут заканчиваться на ``'\\n'``, ``'\\r'`` или ``'\\r\\n'``, и они "
"преобразуются в ``'\\n'`` перед возвратом вызывающему абоненту. Если "
"*newline* равно ``''``, включен универсальный режим новой строки, но "
"окончания строк возвращаются вызывающей стороне непереведенными. Если "
"*newline* имеет любое другое допустимое значение, входные строки завершаются "
"только заданной строкой, а окончание строки возвращается вызывающей стороне "
"непереведенным."

#: ../../library/io.rst:979
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"При записи вывода в поток, если *newline* равно ``None``, все символы "
"``'\\n'``, записанные, будут преобразованы в системный разделитель строк по "
"умолчанию, :data:`os.linesep`. Если *newline* равно ``''`` или ``'\\n'``, "
"преобразование не выполняется. Если *newline* равно любому другому "
"допустимому значению, все символы ``'\\n'``, записанные, будут преобразованы "
"в заданную строку."

#: ../../library/io.rst:985
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character or a carriage return."
msgstr ""

#: ../../library/io.rst:988
msgid ""
"If *write_through* is ``True``, calls to :meth:`write` are guaranteed not to "
"be buffered: any data written on the :class:`TextIOWrapper` object is "
"immediately handled to its underlying binary *buffer*."
msgstr ""

#: ../../library/io.rst:992
msgid "The *write_through* argument has been added."
msgstr "Добавлен аргумент *write_through*."

#: ../../library/io.rst:995
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` instead "
"of ``locale.getpreferredencoding()``. Don't change temporary the locale "
"encoding using :func:`locale.setlocale`, use the current locale encoding "
"instead of the user preferred encoding."
msgstr ""
"Кодировка по умолчанию* теперь равна ``locale.getpreferredencoding(False)`` "
"вместо ``locale.getpreferredencoding()``. Не меняйте временно кодировку "
"локали с помощью :func:`locale.setlocale`, используйте текущую кодировку "
"локали вместо кодировки, предпочитаемой пользователем."

#: ../../library/io.rst:1001
msgid ""
"The *encoding* argument now supports the ``\"locale\"`` dummy encoding name."
msgstr ""
"Аргумент *encoding* теперь поддерживает фиктивное имя кодировки "
"``\"locale\"``."

#: ../../library/io.rst:1004
msgid ""
":class:`TextIOWrapper` provides these data attributes and methods in "
"addition to those from :class:`TextIOBase` and :class:`IOBase`:"
msgstr ""
":class:`TextIOWrapper` предоставляет эти атрибуты данных и методы в "
"дополнение к атрибутам и методам из :class:`TextIOBase` и :class:`IOBase`:"

#: ../../library/io.rst:1009
msgid "Whether line buffering is enabled."
msgstr "Включена ли буферизация строк."

#: ../../library/io.rst:1013
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr "Передаются ли записи немедленно в базовый двоичный буфер."

#: ../../library/io.rst:1021
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*, "
"*newline*, *line_buffering* and *write_through*."
msgstr ""
"Переконфигурируйте этот текстовый поток, используя новые настройки для "
"*encoding*, *errors*, *newline*, *line_buffering* и *write_through*."

#: ../../library/io.rst:1024
msgid ""
"Parameters not specified keep current settings, except ``errors='strict'`` "
"is used when *encoding* is specified but *errors* is not specified."
msgstr ""
"Неуказанные параметры сохраняют текущие настройки, за исключением того, что "
"``errors='strict'`` используется, когда указано *encoding*, но *errors* не "
"указано."

#: ../../library/io.rst:1028
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr ""
"Невозможно изменить кодировку или новую строку, если некоторые данные уже "
"были прочитаны из потока. С другой стороны, изменение кодировки после записи "
"возможно."

#: ../../library/io.rst:1032
msgid ""
"This method does an implicit stream flush before setting the new parameters."
msgstr ""
"Этот метод выполняет неявную очистку потока перед установкой новых "
"параметров."

#: ../../library/io.rst:1040
msgid ""
"A text stream using an in-memory text buffer.  It inherits :class:"
"`TextIOBase`."
msgstr ""

#: ../../library/io.rst:1043
msgid ""
"The text buffer is discarded when the :meth:`~IOBase.close` method is called."
msgstr "Текстовый буфер удаляется при вызове метода :meth:`~IOBase.close`."

#: ../../library/io.rst:1046
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by :meth:"
"`~TextIOBase.write`.  The stream is positioned at the start of the buffer."
msgstr ""

#: ../../library/io.rst:1051
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`, except "
"that when writing output to the stream, if *newline* is ``None``, newlines "
"are written as ``\\n`` on all platforms."
msgstr ""
"Аргумент *newline* работает аналогично аргументу :class:`TextIOWrapper`, за "
"исключением того, что при записи вывода в поток, если *newline* имеет "
"значение ``None``, новые строки записываются как ``\\n`` на всех платформах."

#: ../../library/io.rst:1055
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOBase` and :class:`IOBase`:"
msgstr ""
":class:`StringIO` предоставляет этот метод в дополнение к методам из :class:"
"`TextIOBase` и :class:`IOBase`:"

#: ../../library/io.rst:1060
msgid ""
"Return a ``str`` containing the entire contents of the buffer. Newlines are "
"decoded as if by :meth:`~TextIOBase.read`, although the stream position is "
"not changed."
msgstr ""

#: ../../library/io.rst:1064
msgid "Example usage::"
msgstr "Пример использования::"

#: ../../library/io.rst:1086
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It "
"inherits :class:`codecs.IncrementalDecoder`."
msgstr ""

#: ../../library/io.rst:1091
msgid "Performance"
msgstr "Производительность"

#: ../../library/io.rst:1093
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr ""
"В этом разделе обсуждается производительность предоставленных конкретных "
"реализаций ввода-вывода."

#: ../../library/io.rst:1099
msgid ""
"By reading and writing only large chunks of data even when the user asks for "
"a single byte, buffered I/O hides any inefficiency in calling and executing "
"the operating system's unbuffered I/O routines.  The gain depends on the OS "
"and the kind of I/O which is performed.  For example, on some modern OSes "
"such as Linux, unbuffered disk I/O can be as fast as buffered I/O.  The "
"bottom line, however, is that buffered I/O offers predictable performance "
"regardless of the platform and the backing device.  Therefore, it is almost "
"always preferable to use buffered I/O rather than unbuffered I/O for binary "
"data."
msgstr ""
"Благодаря чтению и записи только больших фрагментов данных, даже когда "
"пользователь запрашивает один байт, буферизованный ввод-вывод скрывает любую "
"неэффективность при вызове и выполнении небуферизованных процедур ввода-"
"вывода операционной системы. Прирост зависит от ОС и типа выполняемого ввода-"
"вывода. Например, в некоторых современных операционных системах, таких как "
"Linux, небуферизованный дисковый ввод-вывод может быть таким же быстрым, как "
"и буферизованный ввод-вывод. Однако суть в том, что буферизованный ввод-"
"вывод обеспечивает предсказуемую производительность независимо от платформы "
"и вспомогательного устройства. Поэтому почти всегда предпочтительнее "
"использовать буферизованный ввод-вывод, а не небуферизованный ввод-вывод для "
"двоичных данных."

#: ../../library/io.rst:1111
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than "
"binary I/O over the same storage, because it requires conversions between "
"unicode and binary data using a character codec.  This can become noticeable "
"handling huge amounts of text data like large log files.  Also, :meth:"
"`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both quite slow due "
"to the reconstruction algorithm used."
msgstr ""

#: ../../library/io.rst:1118
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will "
"exhibit similar speed to :class:`BytesIO`."
msgstr ""
":class:`StringIO`, однако, является собственным контейнером Unicode в памяти "
"и будет демонстрировать скорость, аналогичную :class:`BytesIO`."

#: ../../library/io.rst:1122
msgid "Multi-threading"
msgstr "Многопоточность"

#: ../../library/io.rst:1124
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they wrap are thread-safe too."
msgstr ""

#: ../../library/io.rst:1127
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) "
"protect their internal structures using a lock; it is therefore safe to call "
"them from multiple threads at once."
msgstr ""
"Двоичные буферизованные объекты (экземпляры :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` и :class:`BufferedRWPair`) "
"защищают свои внутренние структуры с помощью блокировки; поэтому безопасно "
"вызывать их из нескольких потоков одновременно."

#: ../../library/io.rst:1132
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr "Объекты :class:`TextIOWrapper` не являются потокобезопасными."

#: ../../library/io.rst:1135
msgid "Reentrancy"
msgstr "повторный вход"

#: ../../library/io.rst:1137
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) are "
"not reentrant.  While reentrant calls will not happen in normal situations, "
"they can arise from doing I/O in a :mod:`signal` handler.  If a thread tries "
"to re-enter a buffered object which it is already accessing, a :exc:"
"`RuntimeError` is raised.  Note this doesn't prohibit a different thread "
"from entering the buffered object."
msgstr ""
"Двоичные буферизованные объекты (экземпляры :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` и :class:`BufferedRWPair`) не "
"являются реентерабельными. Хотя реентерабельные вызовы не происходят в "
"обычных ситуациях, они могут возникнуть в результате выполнения ввода-вывода "
"в обработчике :mod:`signal`. Если поток пытается повторно войти в "
"буферизованный объект, к которому он уже имеет доступ, возникает ошибка :exc:"
"`RuntimeError`. Обратите внимание, что это не запрещает другому потоку войти "
"в буферизованный объект."

#: ../../library/io.rst:1145
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in :func:`print()` "
"function as well."
msgstr ""
