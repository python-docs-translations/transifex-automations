# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/socketserver.rst:2
msgid ":mod:`!socketserver` --- A framework for network servers"
msgstr ":mod:`!socketserver` --- Фреймворк для сетевых серверов."

#: ../../library/socketserver.rst:7
msgid "**Source code:** :source:`Lib/socketserver.py`"
msgstr "**Исходный код:** :source:`Lib/socketserver.py`"

#: ../../library/socketserver.rst:11
msgid ""
"The :mod:`socketserver` module simplifies the task of writing network "
"servers."
msgstr "Модуль :mod:`socketserver` упрощает задачу написания сетевых серверов."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Доступность"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Этот модуль не работает или недоступен на платформах WebAssembly «wasm32-"
"emscripten» и «wasm32-wasi». См. :ref:`wasm-availability` для получения "
"дополнительной информации."

#: ../../library/socketserver.rst:15
msgid "There are four basic concrete server classes:"
msgstr "Существует четыре основных конкретных класса серверов:"

#: ../../library/socketserver.rst:20
msgid ""
"This uses the internet TCP protocol, which provides for continuous streams "
"of data between the client and server. If *bind_and_activate* is true, the "
"constructor automatically attempts to invoke :meth:`~BaseServer.server_bind` "
"and :meth:`~BaseServer.server_activate`.  The other parameters are passed to "
"the :class:`BaseServer` base class."
msgstr ""
"При этом используется интернет-протокол TCP, который обеспечивает "
"непрерывные потоки данных между клиентом и сервером. Если "
"*bind_and_activate* имеет значение true, конструктор автоматически пытается "
"вызвать :meth:`~BaseServer.server_bind` и :meth:`~BaseServer."
"server_activate`. Остальные параметры передаются базовому классу :class:"
"`BaseServer`."

#: ../../library/socketserver.rst:30
msgid ""
"This uses datagrams, which are discrete packets of information that may "
"arrive out of order or be lost while in transit.  The parameters are the "
"same as for :class:`TCPServer`."
msgstr ""
"При этом используются дейтаграммы, представляющие собой отдельные пакеты "
"информации, которые могут прийти не по порядку или быть потеряны во время "
"передачи. Параметры такие же, как и для :class:`TCPServer`."

#: ../../library/socketserver.rst:38
msgid ""
"These more infrequently used classes are similar to the TCP and UDP classes, "
"but use Unix domain sockets; they're not available on non-Unix platforms.  "
"The parameters are the same as for :class:`TCPServer`."
msgstr ""
"Эти более редко используемые классы похожи на классы TCP и UDP, но "
"используют сокеты домена Unix; они недоступны на платформах, отличных от "
"Unix. Параметры такие же, как и для :class:`TCPServer`."

#: ../../library/socketserver.rst:44
msgid ""
"These four classes process requests :dfn:`synchronously`; each request must "
"be completed before the next request can be started.  This isn't suitable if "
"each request takes a long time to complete, because it requires a lot of "
"computation, or because it returns a lot of data which the client is slow to "
"process.  The solution is to create a separate process or thread to handle "
"each request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in "
"classes can be used to support asynchronous behaviour."
msgstr ""
"Эти четыре класса обрабатывают запросы :dfn:`синхронно`; каждый запрос "
"должен быть завершен, прежде чем можно будет запустить следующий запрос. Это "
"не подходит, если выполнение каждого запроса занимает много времени, "
"поскольку требует большого количества вычислений или возвращает много "
"данных, которые клиент медленно обрабатывает. Решение состоит в том, чтобы "
"создать отдельный процесс или поток для обработки каждого запроса; смешанные "
"классы :class:`ForkingMixIn` и :class:`ThreadingMixIn` могут использоваться "
"для поддержки асинхронного поведения."

#: ../../library/socketserver.rst:52
msgid ""
"Creating a server requires several steps.  First, you must create a request "
"handler class by subclassing the :class:`BaseRequestHandler` class and "
"overriding its :meth:`~BaseRequestHandler.handle` method; this method will "
"process incoming requests.  Second, you must instantiate one of the server "
"classes, passing it the server's address and the request handler class. It "
"is recommended to use the server in a :keyword:`with` statement. Then call "
"the :meth:`~BaseServer.handle_request` or :meth:`~BaseServer.serve_forever` "
"method of the server object to process one or many requests.  Finally, call :"
"meth:`~BaseServer.server_close` to close the socket (unless you used a :"
"keyword:`!with` statement)."
msgstr ""
"Создание сервера требует нескольких шагов. Во-первых, вы должны создать "
"класс обработчика запросов, создав подкласс класса :class:"
"`BaseRequestHandler` и переопределив его метод :meth:`~BaseRequestHandler."
"handle`; этот метод будет обрабатывать входящие запросы. Во-вторых, вы "
"должны создать экземпляр одного из классов сервера, передав ему адрес "
"сервера и класс обработчика запросов. Рекомендуется использовать сервер в "
"операторе :keyword:`with`. Затем вызовите метод :meth:`~BaseServer."
"handle_request` или :meth:`~BaseServer.serve_forever` объекта сервера для "
"обработки одного или нескольких запросов. Наконец, вызовите :meth:"
"`~BaseServer.server_close`, чтобы закрыть сокет (если вы не использовали "
"оператор :keyword:`!with`)."

#: ../../library/socketserver.rst:64
msgid ""
"When inheriting from :class:`ThreadingMixIn` for threaded connection "
"behavior, you should explicitly declare how you want your threads to behave "
"on an abrupt shutdown.  The :class:`ThreadingMixIn` class defines an "
"attribute *daemon_threads*, which indicates whether or not the server should "
"wait for thread termination.  You should set the flag explicitly if you "
"would like threads to behave autonomously; the default is :const:`False`, "
"meaning that Python will not exit until all threads created by :class:"
"`ThreadingMixIn` have exited."
msgstr ""
"При наследовании от :class:`ThreadingMixIn` для поведения потокового "
"соединения вы должны явно указать, как вы хотите, чтобы ваши потоки вели "
"себя при внезапном завершении работы. Класс :class:`ThreadingMixIn` "
"определяет атрибут *daemon_threads*, который указывает, должен ли сервер "
"ожидать завершения потока. Вам следует установить этот флаг явно, если вы "
"хотите, чтобы потоки работали автономно; значение по умолчанию — :const:"
"`False`, что означает, что Python не завершит работу до тех пор, пока не "
"закроются все потоки, созданные :class:`ThreadingMixIn`."

#: ../../library/socketserver.rst:73
msgid ""
"Server classes have the same external methods and attributes, no matter what "
"network protocol they use."
msgstr ""
"Классы серверов имеют одни и те же внешние методы и атрибуты независимо от "
"того, какой сетевой протокол они используют."

#: ../../library/socketserver.rst:78
msgid "Server Creation Notes"
msgstr "Примечания по созданию сервера"

#: ../../library/socketserver.rst:80
msgid ""
"There are five classes in an inheritance diagram, four of which represent "
"synchronous servers of four types::"
msgstr ""
"На диаграмме наследования имеется пять классов, четыре из которых "
"представляют собой синхронные серверы четырех типов:"

#: ../../library/socketserver.rst:83
msgid ""
"+------------+\n"
"| BaseServer |\n"
"+------------+\n"
"      |\n"
"      v\n"
"+-----------+        +------------------+\n"
"| TCPServer |------->| UnixStreamServer |\n"
"+-----------+        +------------------+\n"
"      |\n"
"      v\n"
"+-----------+        +--------------------+\n"
"| UDPServer |------->| UnixDatagramServer |\n"
"+-----------+        +--------------------+"
msgstr ""
"+------------+\n"
"| BaseServer |\n"
"+------------+\n"
"      |\n"
"      v\n"
"+-----------+        +------------------+\n"
"| TCPServer |------->| UnixStreamServer |\n"
"+-----------+        +------------------+\n"
"      |\n"
"      v\n"
"+-----------+        +--------------------+\n"
"| UDPServer |------->| UnixDatagramServer |\n"
"+-----------+        +--------------------+"

#: ../../library/socketserver.rst:97
msgid ""
"Note that :class:`UnixDatagramServer` derives from :class:`UDPServer`, not "
"from :class:`UnixStreamServer` --- the only difference between an IP and a "
"Unix server is the address family."
msgstr ""
"Обратите внимание, что :class:`UnixDatagramServer` происходит от :class:"
"`UDPServer`, а не от :class:`UnixStreamServer` --- единственная разница "
"между IP-сервером и сервером Unix - это семейство адресов."

#: ../../library/socketserver.rst:105
msgid ""
"Forking and threading versions of each type of server can be created using "
"these mix-in classes.  For instance, :class:`ThreadingUDPServer` is created "
"as follows::"
msgstr ""
"С помощью этих смешанных классов можно создать версии разветвления и "
"многопоточности для каждого типа сервера. Например, :class:"
"`ThreadingUDPServer` создается следующим образом::"

#: ../../library/socketserver.rst:109
msgid ""
"class ThreadingUDPServer(ThreadingMixIn, UDPServer):\n"
"    pass"
msgstr "класс ThreadingUDPServer (ThreadingMixIn, UDPServer): проходить"

#: ../../library/socketserver.rst:112
msgid ""
"The mix-in class comes first, since it overrides a method defined in :class:"
"`UDPServer`.  Setting the various attributes also changes the behavior of "
"the underlying server mechanism."
msgstr ""
"На первом месте стоит дополнительный класс, поскольку он переопределяет "
"метод, определенный в :class:`UDPServer`. Установка различных атрибутов "
"также меняет поведение базового серверного механизма."

#: ../../library/socketserver.rst:116
msgid ""
":class:`ForkingMixIn` and the Forking classes mentioned below are only "
"available on POSIX platforms that support :func:`~os.fork`."
msgstr ""
":class:`ForkingMixIn` и упомянутые ниже классы Forking доступны только на "
"платформах POSIX, поддерживающих :func:`~os.fork`."

#: ../../library/socketserver.rst:121
msgid ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` waits until all "
"child processes complete, except if :attr:`block_on_close` attribute is "
"``False``."
msgstr ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` ожидает "
"завершения всех дочерних процессов, за исключением случаев, когда атрибут :"
"attr:`block_on_close` имеет значение ``False``."

#: ../../library/socketserver.rst:125
msgid ""
":meth:`ThreadingMixIn.server_close <BaseServer.server_close>` waits until "
"all non-daemon threads complete, except if :attr:`block_on_close` attribute "
"is ``False``."
msgstr ""
":meth:`ThreadingMixIn.server_close <BaseServer.server_close>` ожидает "
"завершения всех потоков, не являющихся демонами, за исключением случаев, "
"когда атрибут :attr:`block_on_close` имеет значение ``False``."

#: ../../library/socketserver.rst:131
msgid ""
"For :class:`ThreadingMixIn` use daemonic threads by setting :data:"
"`ThreadingMixIn.daemon_threads <daemon_threads>` to ``True`` to not wait "
"until threads complete."
msgstr ""
"Для :class:`ThreadingMixIn` используйте демонические потоки, установив для :"
"data:`ThreadingMixIn.daemon_threads <daemon_threads>` значение ``True``, "
"чтобы не ждать завершения потоков."

#: ../../library/socketserver.rst:137
msgid ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` and :meth:"
"`ThreadingMixIn.server_close <BaseServer.server_close>` now waits until all "
"child processes and non-daemonic threads complete. Add a new :attr:"
"`ForkingMixIn.block_on_close <block_on_close>` class attribute to opt-in for "
"the pre-3.7 behaviour."
msgstr ""
":meth:`ForkingMixIn.server_close <BaseServer.server_close>` и :meth:"
"`ThreadingMixIn.server_close <BaseServer.server_close>` теперь ждут "
"завершения всех дочерних процессов и недемонических потоков. Добавьте новый "
"атрибут класса :attr:`ForkingMixIn.block_on_close <block_on_close>`, чтобы "
"включить поведение версии до версии 3.7."

#: ../../library/socketserver.rst:153
msgid "These classes are pre-defined using the mix-in classes."
msgstr ""
"Эти классы предварительно определены с использованием дополнительных классов."

#: ../../library/socketserver.rst:155
msgid ""
"The ``ForkingUnixStreamServer`` and ``ForkingUnixDatagramServer`` classes "
"were added."
msgstr ""
"Были добавлены классы ForkingUnixStreamServer и ForkingUnixDatagramServer."

#: ../../library/socketserver.rst:159
msgid ""
"To implement a service, you must derive a class from :class:"
"`BaseRequestHandler` and redefine its :meth:`~BaseRequestHandler.handle` "
"method. You can then run various versions of the service by combining one of "
"the server classes with your request handler class.  The request handler "
"class must be different for datagram or stream services.  This can be hidden "
"by using the handler subclasses :class:`StreamRequestHandler` or :class:"
"`DatagramRequestHandler`."
msgstr ""
"Чтобы реализовать службу, вы должны получить класс от :class:"
"`BaseRequestHandler` и переопределить его метод :meth:`~BaseRequestHandler."
"handle`. Затем вы можете запускать различные версии службы, комбинируя один "
"из классов сервера с классом обработчика запросов. Класс обработчика "
"запросов должен быть разным для датаграммных или потоковых служб. Это можно "
"скрыть с помощью подклассов обработчиков :class:`StreamRequestHandler` или :"
"class:`DatagramRequestHandler`."

#: ../../library/socketserver.rst:167
msgid ""
"Of course, you still have to use your head!  For instance, it makes no sense "
"to use a forking server if the service contains state in memory that can be "
"modified by different requests, since the modifications in the child process "
"would never reach the initial state kept in the parent process and passed to "
"each child.  In this case, you can use a threading server, but you will "
"probably have to use locks to protect the integrity of the shared data."
msgstr ""
"Конечно, вам все равно придется работать головой! Например, нет смысла "
"использовать разветвляющийся сервер, если служба содержит состояние в "
"памяти, которое может быть изменено различными запросами, поскольку "
"изменения в дочернем процессе никогда не достигнут начального состояния, "
"хранящегося в родительском процессе и передаваемого каждому дочернему "
"процессу. . В этом случае вы можете использовать потоковый сервер, но вам, "
"вероятно, придется использовать блокировки для защиты целостности общих "
"данных."

#: ../../library/socketserver.rst:174
msgid ""
"On the other hand, if you are building an HTTP server where all data is "
"stored externally (for instance, in the file system), a synchronous class "
"will essentially render the service \"deaf\" while one request is being "
"handled -- which may be for a very long time if a client is slow to receive "
"all the data it has requested.  Here a threading or forking server is "
"appropriate."
msgstr ""
"С другой стороны, если вы создаете HTTP-сервер, на котором все данные "
"хранятся снаружи (например, в файловой системе), синхронный класс по "
"существу сделает службу «глухой», пока обрабатывается один запрос, что может "
"быть в течение очень долгого времени, если клиент медленно получает все "
"запрошенные данные. Здесь уместен многопоточный или разветвляющийся сервер."

#: ../../library/socketserver.rst:180
msgid ""
"In some cases, it may be appropriate to process part of a request "
"synchronously, but to finish processing in a forked child depending on the "
"request data.  This can be implemented by using a synchronous server and "
"doing an explicit fork in the request handler class :meth:"
"`~BaseRequestHandler.handle` method."
msgstr ""
"В некоторых случаях может оказаться целесообразным обрабатывать часть "
"запроса синхронно, но завершать обработку в разветвленном дочернем элементе "
"в зависимости от данных запроса. Это можно реализовать с помощью синхронного "
"сервера и явного разветвления метода класса обработчика запроса :meth:"
"`~BaseRequestHandler.handle`."

#: ../../library/socketserver.rst:185
msgid ""
"Another approach to handling multiple simultaneous requests in an "
"environment that supports neither threads nor :func:`~os.fork` (or where "
"these are too expensive or inappropriate for the service) is to maintain an "
"explicit table of partially finished requests and to use :mod:`selectors` to "
"decide which request to work on next (or whether to handle a new incoming "
"request).  This is particularly important for stream services where each "
"client can potentially be connected for a long time (if threads or "
"subprocesses cannot be used)."
msgstr ""
"Другой подход к обработке нескольких одновременных запросов в среде, которая "
"не поддерживает ни потоки, ни :func:`~os.fork` (или там, где они слишком "
"дороги или не подходят для службы), состоит в том, чтобы поддерживать явную "
"таблицу частично завершенных запросов и использовать :mod:`селекторы`, чтобы "
"решить, над каким запросом работать дальше (или обрабатывать ли новый "
"входящий запрос). Это особенно важно для потоковых сервисов, где каждый "
"клиент потенциально может быть подключен в течение длительного времени (если "
"невозможно использовать потоки или подпроцессы)."

#: ../../library/socketserver.rst:198
msgid "Server Objects"
msgstr "Объекты сервера"

#: ../../library/socketserver.rst:202
msgid ""
"This is the superclass of all Server objects in the module.  It defines the "
"interface, given below, but does not implement most of the methods, which is "
"done in subclasses.  The two parameters are stored in the respective :attr:"
"`server_address` and :attr:`RequestHandlerClass` attributes."
msgstr ""
"Это суперкласс всех объектов Сервера в модуле. Он определяет интерфейс, "
"представленный ниже, но не реализует большинство методов, что делается в "
"подклассах. Эти два параметра хранятся в соответствующих атрибутах :attr:"
"`server_address` и :attr:`RequestHandlerClass`."

#: ../../library/socketserver.rst:210
msgid ""
"Return an integer file descriptor for the socket on which the server is "
"listening.  This function is most commonly passed to :mod:`selectors`, to "
"allow monitoring multiple servers in the same process."
msgstr ""
"Возвращает целочисленный файловый дескриптор сокета, который прослушивает "
"сервер. Эта функция чаще всего передается :mod:`selectors`, чтобы позволить "
"контролировать несколько серверов в одном процессе."

#: ../../library/socketserver.rst:217
msgid ""
"Process a single request.  This function calls the following methods in "
"order: :meth:`get_request`, :meth:`verify_request`, and :meth:"
"`process_request`.  If the user-provided :meth:`~BaseRequestHandler.handle` "
"method of the handler class raises an exception, the server's :meth:"
"`handle_error` method will be called.  If no request is received within :"
"attr:`timeout` seconds, :meth:`handle_timeout` will be called and :meth:"
"`handle_request` will return."
msgstr ""
"Обработка одного запроса. Эта функция вызывает следующие методы по порядку: :"
"meth:`get_request`, :meth:`verify_request` и :meth:`process_request`. Если "
"предоставленный пользователем метод :meth:`~BaseRequestHandler.handle` "
"класса обработчика вызывает исключение, будет вызван серверный метод :meth:"
"`handle_error`. Если в течение :attr:`timeout` секунд не будет получено ни "
"одного запроса, будет вызван :meth:`handle_timeout` и :meth:`handle_request` "
"вернет значение."

#: ../../library/socketserver.rst:229
msgid ""
"Handle requests until an explicit :meth:`shutdown` request.  Poll for "
"shutdown every *poll_interval* seconds. Ignores the :attr:`timeout` "
"attribute.  It also calls :meth:`service_actions`, which may be used by a "
"subclass or mixin to provide actions specific to a given service.  For "
"example, the :class:`ForkingMixIn` class uses :meth:`service_actions` to "
"clean up zombie child processes."
msgstr ""
"Обрабатывать запросы до тех пор, пока не будет получен явный запрос :meth:"
"`shutdown`. Опрос на выключение каждые *poll_interval* секунд. Игнорирует "
"атрибут :attr:`timeout`. Он также вызывает :meth:`service_actions`, который "
"может использоваться подклассом или миксином для выполнения действий, "
"специфичных для данного сервиса. Например, класс :class:`ForkingMixIn` "
"использует :meth:`service_actions` для очистки дочерних процессов-зомби."

#: ../../library/socketserver.rst:237
msgid "Added ``service_actions`` call to the ``serve_forever`` method."
msgstr "Добавлен вызов service_actions к методу serve_forever."

#: ../../library/socketserver.rst:243
msgid ""
"This is called in the :meth:`serve_forever` loop. This method can be "
"overridden by subclasses or mixin classes to perform actions specific to a "
"given service, such as cleanup actions."
msgstr ""
"Это вызывается в цикле :meth:`serve_forever`. Этот метод может быть "
"переопределен подклассами или классами примеси для выполнения действий, "
"специфичных для данной службы, таких как действия по очистке."

#: ../../library/socketserver.rst:251
msgid ""
"Tell the :meth:`serve_forever` loop to stop and wait until it does. :meth:"
"`shutdown` must be called while :meth:`serve_forever` is running in a "
"different thread otherwise it will deadlock."
msgstr ""
"Прикажите циклу :meth:`serve_forever` остановиться и подождать, пока он это "
"сделает. :meth:`shutdown` должен вызываться, пока :meth:`serve_forever` "
"работает в другом потоке, иначе произойдет тупиковая ситуация."

#: ../../library/socketserver.rst:258
msgid "Clean up the server. May be overridden."
msgstr "Очистите сервер. Может быть переопределено."

#: ../../library/socketserver.rst:263
msgid ""
"The family of protocols to which the server's socket belongs.  Common "
"examples are :const:`socket.AF_INET`, :const:`socket.AF_INET6`, and :const:"
"`socket.AF_UNIX`.  Subclass the TCP or UDP server classes in this module "
"with class attribute ``address_family = AF_INET6`` set if you want IPv6 "
"server classes."
msgstr ""
"Семейство протоколов, которым принадлежит сокет сервера. Общие примеры: "
"const: `socket.af_inet`,: const:` socket.af_inet6` и: const: `socket."
"af_unix`. Подкласс классов TCP или UDP -сервера в этом модуле с атрибутом "
"класса `` address_family = af_inet6`` Установите, если вы хотите классы "
"сервера IPv6."

#: ../../library/socketserver.rst:272
msgid ""
"The user-provided request handler class; an instance of this class is "
"created for each request."
msgstr ""
"Класс обработчика пользовательских запросов; экземпляр этого класса "
"создается для каждого запроса."

#: ../../library/socketserver.rst:278
msgid ""
"The address on which the server is listening.  The format of addresses "
"varies depending on the protocol family; see the documentation for the :mod:"
"`socket` module for details.  For internet protocols, this is a tuple "
"containing a string giving the address, and an integer port number: "
"``('127.0.0.1', 80)``, for example."
msgstr ""
"Адрес, который прослушивает сервер. Формат адресов варьируется в зависимости "
"от семейства протоколов; подробности см. в документации модуля :mod:"
"`socket`. Для интернет-протоколов это кортеж, содержащий строку, задающую "
"адрес, и целочисленный номер порта: например, ``('127.0.0.1', 80)``."

#: ../../library/socketserver.rst:287
msgid ""
"The socket object on which the server will listen for incoming requests."
msgstr "Объект сокета, на котором сервер будет прослушивать входящие запросы."

#: ../../library/socketserver.rst:290
msgid "The server classes support the following class variables:"
msgstr "Классы сервера поддерживают следующие переменные класса:"

#: ../../library/socketserver.rst:296
msgid ""
"Whether the server will allow the reuse of an address.  This defaults to :"
"const:`False`, and can be set in subclasses to change the policy."
msgstr ""
"Разрешит ли сервер повторное использование адреса. По умолчанию это :const:"
"`False` и может быть установлено в подклассах для изменения политики."

#: ../../library/socketserver.rst:302
msgid ""
"The size of the request queue.  If it takes a long time to process a single "
"request, any requests that arrive while the server is busy are placed into a "
"queue, up to :attr:`request_queue_size` requests.  Once the queue is full, "
"further requests from clients will get a \"Connection denied\" error.  The "
"default value is usually 5, but this can be overridden by subclasses."
msgstr ""
"Размер очереди запросов. Если обработка одного запроса занимает много "
"времени, любые запросы, поступающие, пока сервер занят, помещаются в "
"очередь, вплоть до запросов :attr:`request_queue_size`. Как только очередь "
"заполнится, дальнейшие запросы от клиентов будут получать ошибку «Соединение "
"отклонено». Значение по умолчанию обычно равно 5, но оно может быть "
"переопределено подклассами."

#: ../../library/socketserver.rst:311
msgid ""
"The type of socket used by the server; :const:`socket.SOCK_STREAM` and :"
"const:`socket.SOCK_DGRAM` are two common values."
msgstr ""
"Тип сокета, используемый сервером; :const:`socket.SOCK_STREAM` и :const:"
"`socket.SOCK_DGRAM` — два общих значения."

#: ../../library/socketserver.rst:317
msgid ""
"Timeout duration, measured in seconds, or :const:`None` if no timeout is "
"desired.  If :meth:`handle_request` receives no incoming requests within the "
"timeout period, the :meth:`handle_timeout` method is called."
msgstr ""
"Продолжительность тайм-аута, измеряемая в секундах, или :const:`None`, если "
"тайм-аут не требуется. Если :meth:`handle_request` не получает входящих "
"запросов в течение периода ожидания, вызывается метод :meth:`handle_timeout`."

#: ../../library/socketserver.rst:322
msgid ""
"There are various server methods that can be overridden by subclasses of "
"base server classes like :class:`TCPServer`; these methods aren't useful to "
"external users of the server object."
msgstr ""
"Существуют различные серверные методы, которые могут быть переопределены "
"подклассами базовых серверных классов, например :class:`TCPServer`; эти "
"методы бесполезны для внешних пользователей объекта сервера."

#: ../../library/socketserver.rst:331
msgid ""
"Actually processes the request by instantiating :attr:`RequestHandlerClass` "
"and calling its :meth:`~BaseRequestHandler.handle` method."
msgstr ""
"Фактически обрабатывает запрос, создавая экземпляр :attr:"
"`RequestHandlerClass` и вызывая его метод :meth:`~BaseRequestHandler.handle`."

#: ../../library/socketserver.rst:337
msgid ""
"Must accept a request from the socket, and return a 2-tuple containing the "
"*new* socket object to be used to communicate with the client, and the "
"client's address."
msgstr ""
"Должен принять запрос из сокета и вернуть кортеж из двух элементов, "
"содержащий *новый* объект сокета, который будет использоваться для связи с "
"клиентом, и адрес клиента."

#: ../../library/socketserver.rst:344
msgid ""
"This function is called if the :meth:`~BaseRequestHandler.handle` method of "
"a :attr:`RequestHandlerClass` instance raises an exception.  The default "
"action is to print the traceback to standard error and continue handling "
"further requests."
msgstr ""
"Эта функция вызывается, если метод :meth:`~BaseRequestHandler.handle` "
"экземпляра :attr:`RequestHandlerClass` вызывает исключение. Действие по "
"умолчанию — распечатать обратную трассировку до стандартной ошибки и "
"продолжить обработку дальнейших запросов."

#: ../../library/socketserver.rst:349
msgid "Now only called for exceptions derived from the :exc:`Exception` class."
msgstr ""
"Теперь вызывается только для исключений, производных от класса :exc:"
"`Exception`."

#: ../../library/socketserver.rst:356
msgid ""
"This function is called when the :attr:`timeout` attribute has been set to a "
"value other than :const:`None` and the timeout period has passed with no "
"requests being received.  The default action for forking servers is to "
"collect the status of any child processes that have exited, while in "
"threading servers this method does nothing."
msgstr ""
"Эта функция вызывается, когда для атрибута :attr:`timeout` установлено "
"значение, отличное от :const:`None`, и период таймаута прошел, а запросы не "
"получены. Действием по умолчанию для разветвленных серверов является сбор "
"состояния всех завершившихся дочерних процессов, тогда как на многопоточных "
"серверах этот метод ничего не делает."

#: ../../library/socketserver.rst:365
msgid ""
"Calls :meth:`finish_request` to create an instance of the :attr:"
"`RequestHandlerClass`.  If desired, this function can create a new process "
"or thread to handle the request; the :class:`ForkingMixIn` and :class:"
"`ThreadingMixIn` classes do this."
msgstr ""
"Вызывает :meth:`finish_request` для создания экземпляра :attr:"
"`RequestHandlerClass`. При желании эта функция может создать новый процесс "
"или поток для обработки запроса; это делают классы :class:`ForkingMixIn` и :"
"class:`ThreadingMixIn`."

#: ../../library/socketserver.rst:377
msgid ""
"Called by the server's constructor to activate the server.  The default "
"behavior for a TCP server just invokes :meth:`~socket.socket.listen` on the "
"server's socket.  May be overridden."
msgstr ""
"Вызывается конструктором сервера для активации сервера. Поведение по "
"умолчанию для TCP-сервера просто вызывает :meth:`~socket.socket.listen` в "
"сокете сервера. Может быть переопределено."

#: ../../library/socketserver.rst:384
msgid ""
"Called by the server's constructor to bind the socket to the desired "
"address. May be overridden."
msgstr ""
"Вызывается конструктором сервера для привязки сокета к желаемому адресу. "
"Может быть переопределено."

#: ../../library/socketserver.rst:390
msgid ""
"Must return a Boolean value; if the value is :const:`True`, the request will "
"be processed, and if it's :const:`False`, the request will be denied.  This "
"function can be overridden to implement access controls for a server. The "
"default implementation always returns :const:`True`."
msgstr ""
"Должен возвращать логическое значение; если значение :const:`True`, запрос "
"будет обработан, а если :const:`False`, запрос будет отклонен. Эту функцию "
"можно переопределить для реализации контроля доступа к серверу. Реализация "
"по умолчанию всегда возвращает :const:`True`."

#: ../../library/socketserver.rst:396
msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`server_close`."
msgstr ""
"Добавлена ​​поддержка протокола :term:`контекстного менеджера`. Выход из "
"контекстного менеджера эквивалентен вызову :meth:`server_close`."

#: ../../library/socketserver.rst:402
msgid "Request Handler Objects"
msgstr "Объекты обработчика запроса"

#: ../../library/socketserver.rst:406
msgid ""
"This is the superclass of all request handler objects.  It defines the "
"interface, given below.  A concrete request handler subclass must define a "
"new :meth:`handle` method, and can override any of the other methods.  A new "
"instance of the subclass is created for each request."
msgstr ""
"Это суперкласс всех объектов-обработчиков запросов. Он определяет интерфейс, "
"приведенный ниже. Конкретный подкласс обработчика запросов должен определять "
"новый метод :meth:`handle` и может переопределять любой другой метод. Для "
"каждого запроса создается новый экземпляр подкласса."

#: ../../library/socketserver.rst:415
msgid ""
"Called before the :meth:`handle` method to perform any initialization "
"actions required.  The default implementation does nothing."
msgstr ""
"Вызывается перед методом :meth:`handle` для выполнения любых необходимых "
"действий по инициализации. Реализация по умолчанию ничего не делает."

#: ../../library/socketserver.rst:421
msgid ""
"This function must do all the work required to service a request.  The "
"default implementation does nothing.  Several instance attributes are "
"available to it; the request is available as :attr:`request`; the client "
"address as :attr:`client_address`; and the server instance as :attr:"
"`server`, in case it needs access to per-server information."
msgstr ""
"Эта функция должна выполнять всю работу, необходимую для обслуживания "
"запроса. Реализация по умолчанию ничего не делает. Ему доступны несколько "
"атрибутов экземпляра; запрос доступен как :attr:`request`; адрес клиента "
"как :attr:`client_address`; и экземпляр сервера как :attr:`server`, на "
"случай, если ему потребуется доступ к информации по каждому серверу."

#: ../../library/socketserver.rst:427
msgid ""
"The type of :attr:`request` is different for datagram or stream services.  "
"For stream services, :attr:`request` is a socket object; for datagram "
"services, :attr:`request` is a pair of string and socket."
msgstr ""
"Тип :attr:`request` различен для дейтаграммных и потоковых сервисов. Для "
"потоковых сервисов :attr:`request` — это объект сокета; для служб "
"дейтаграмм :attr:`request` — это пара строки и сокета."

#: ../../library/socketserver.rst:434
msgid ""
"Called after the :meth:`handle` method to perform any clean-up actions "
"required.  The default implementation does nothing.  If :meth:`setup` raises "
"an exception, this function will not be called."
msgstr ""
"Вызывается после метода :meth:`handle` для выполнения любых необходимых "
"действий по очистке. Реализация по умолчанию ничего не делает. Если :meth:"
"`setup` вызывает исключение, эта функция не будет вызвана."

#: ../../library/socketserver.rst:441
msgid ""
"The *new* :class:`socket.socket` object to be used to communicate with the "
"client."
msgstr ""
"*новый* объект :class:`socket.socket`, который будет использоваться для "
"связи с клиентом."

#: ../../library/socketserver.rst:447
msgid "Client address returned by :meth:`BaseServer.get_request`."
msgstr "Адрес клиента, возвращаемый :meth:`BaseServer.get_request`."

#: ../../library/socketserver.rst:452
msgid ":class:`BaseServer` object used for handling the request."
msgstr "Объект :class:`BaseServer`, используемый для обработки запроса."

#: ../../library/socketserver.rst:458
msgid ""
"These :class:`BaseRequestHandler` subclasses override the :meth:"
"`~BaseRequestHandler.setup` and :meth:`~BaseRequestHandler.finish` methods, "
"and provide :attr:`rfile` and :attr:`wfile` attributes."
msgstr ""
"Эти подклассы :class:`BaseRequestHandler` переопределяют методы :meth:"
"`~BaseRequestHandler.setup` и :meth:`~BaseRequestHandler.finish` и "
"предоставляют атрибуты :attr:`rfile` и :attr:`wfile`."

#: ../../library/socketserver.rst:464
msgid ""
"A file object from which receives the request is read. Support the :class:"
"`io.BufferedIOBase` readable interface."
msgstr ""
"Читается файловый объект, из которого поступает запрос. Поддержка читаемого "
"интерфейса :class:`io.BufferedIOBase`."

#: ../../library/socketserver.rst:469
msgid ""
"A file object to which the reply is written. Support the :class:`io."
"BufferedIOBase` writable interface"
msgstr ""
"Файловый объект, в который записывается ответ. Поддержка записываемого "
"интерфейса :class:`io.BufferedIOBase`."

#: ../../library/socketserver.rst:473
msgid ""
":attr:`wfile` also supports the :class:`io.BufferedIOBase` writable "
"interface."
msgstr ""
":attr:`wfile` также поддерживает записываемый интерфейс :class:`io."
"BufferedIOBase`."

#: ../../library/socketserver.rst:479
msgid "Examples"
msgstr "Примеры"

#: ../../library/socketserver.rst:482
msgid ":class:`socketserver.TCPServer` Example"
msgstr "Пример :class:`socketserver.TCPServer`"

#: ../../library/socketserver.rst:484 ../../library/socketserver.rst:595
msgid "This is the server side::"
msgstr "Это серверная часть::"

#: ../../library/socketserver.rst:486
msgid ""
"import socketserver\n"
"\n"
"class MyTCPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    The request handler class for our server.\n"
"\n"
"    It is instantiated once per connection to the server, and must\n"
"    override the handle() method to implement communication to the\n"
"    client.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        # self.request is the TCP socket connected to the client\n"
"        pieces = [b'']\n"
"        total = 0\n"
"        while b'\\n' not in pieces[-1] and total < 10_000:\n"
"            pieces.append(self.request.recv(2000))\n"
"            total += len(pieces[-1])\n"
"        self.data = b''.join(pieces)\n"
"        print(f\"Received from {self.client_address[0]}:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # just send back the same data, but upper-cased\n"
"        self.request.sendall(self.data.upper())\n"
"        # after we return, the socket will be closed.\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"\n"
"    # Create the server, binding to localhost on port 9999\n"
"    with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:\n"
"        # Activate the server; this will keep running until you\n"
"        # interrupt the program with Ctrl-C\n"
"        server.serve_forever()"
msgstr ""
"import socketserver\n"
"\n"
"class MyTCPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    The request handler class for our server.\n"
"\n"
"    It is instantiated once per connection to the server, and must\n"
"    override the handle() method to implement communication to the\n"
"    client.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        # self.request is the TCP socket connected to the client\n"
"        pieces = [b'']\n"
"        total = 0\n"
"        while b'\\n' not in pieces[-1] and total < 10_000:\n"
"            pieces.append(self.request.recv(2000))\n"
"            total += len(pieces[-1])\n"
"        self.data = b''.join(pieces)\n"
"        print(f\"Received from {self.client_address[0]}:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # just send back the same data, but upper-cased\n"
"        self.request.sendall(self.data.upper())\n"
"        # after we return, the socket will be closed.\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"\n"
"    # Create the server, binding to localhost on port 9999\n"
"    with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:\n"
"        # Activate the server; this will keep running until you\n"
"        # interrupt the program with Ctrl-C\n"
"        server.serve_forever()"

#: ../../library/socketserver.rst:520
msgid ""
"An alternative request handler class that makes use of streams (file-like "
"objects that simplify communication by providing the standard file "
"interface)::"
msgstr ""
"Альтернативный класс обработчика запросов, использующий потоки "
"(файлоподобные объекты, которые упрощают взаимодействие, предоставляя "
"стандартный файловый интерфейс)::"

#: ../../library/socketserver.rst:523
msgid ""
"class MyTCPHandler(socketserver.StreamRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        # self.rfile is a file-like object created by the handler.\n"
"        # We can now use e.g. readline() instead of raw recv() calls.\n"
"        # We limit ourselves to 10000 bytes to avoid abuse by the sender.\n"
"        self.data = self.rfile.readline(10000).rstrip()\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # Likewise, self.wfile is a file-like object used to write back\n"
"        # to the client\n"
"        self.wfile.write(self.data.upper())"
msgstr ""
"class MyTCPHandler(socketserver.StreamRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        # self.rfile is a file-like object created by the handler.\n"
"        # We can now use e.g. readline() instead of raw recv() calls.\n"
"        # We limit ourselves to 10000 bytes to avoid abuse by the sender.\n"
"        self.data = self.rfile.readline(10000).rstrip()\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(self.data.decode(\"utf-8\"))\n"
"        # Likewise, self.wfile is a file-like object used to write back\n"
"        # to the client\n"
"        self.wfile.write(self.data.upper())"

#: ../../library/socketserver.rst:536
msgid ""
"The difference is that the ``readline()`` call in the second handler will "
"call ``recv()`` multiple times until it encounters a newline character, "
"while the the first handler had to use a ``recv()`` loop to accumulate data "
"until a newline itself.  If it had just used a single ``recv()`` without the "
"loop it would just have returned what has been received so far from the "
"client. TCP is stream based: data arrives in the order it was sent, but "
"there no correlation between client ``send()`` or ``sendall()`` calls and "
"the number of ``recv()`` calls on the server required to receive it."
msgstr ""
"Разница в том, что вызов `` `readline ()` `` во втором обработчике назовет "
"`` recv () `` несколько раз, пока не столкнется с новым символом, в то время "
"как первый обработчик должен был использовать `recv ()` `Цикл для накопления "
"данных до самой новой линии. Если бы он только что использовал один `` recv "
"() `` без цикла, это просто вернуло бы то, что было получено так далеко от "
"клиента. TCP основан на потоке: данные поступают в заказ, который он был "
"отправлен, но нет никакой корреляции между клиентом `` send () `` `` "
"`sendall ()` `` `и количество` `recv ()` `Вызовы на сервер, необходимый для "
"его получения."

#: ../../library/socketserver.rst:546 ../../library/socketserver.rst:619
msgid "This is the client side::"
msgstr "Это клиентская сторона::"

#: ../../library/socketserver.rst:548
msgid ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# Create a socket (SOCK_STREAM means a TCP socket)\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"    # Connect to server and send data\n"
"    sock.connect((HOST, PORT))\n"
"    sock.sendall(bytes(data, \"utf-8\"))\n"
"    sock.sendall(b\"\\n\")\n"
"\n"
"    # Receive data from the server and shut down\n"
"    received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"
msgstr ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# Create a socket (SOCK_STREAM means a TCP socket)\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"    # Connect to server and send data\n"
"    sock.connect((HOST, PORT))\n"
"    sock.sendall(bytes(data, \"utf-8\"))\n"
"    sock.sendall(b\"\\n\")\n"
"\n"
"    # Receive data from the server and shut down\n"
"    received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"

#: ../../library/socketserver.rst:568 ../../library/socketserver.rst:694
msgid "The output of the example should look something like this:"
msgstr "Вывод примера должен выглядеть примерно так:"

#: ../../library/socketserver.rst:570
msgid "Server:"
msgstr "Сервер:"

#: ../../library/socketserver.rst:572
msgid ""
"$ python TCPServer.py\n"
"127.0.0.1 wrote:\n"
"b'hello world with TCP'\n"
"127.0.0.1 wrote:\n"
"b'python is nice'"
msgstr ""
"$ python TCPServer.py\n"
"127.0.0.1 wrote:\n"
"b'hello world with TCP'\n"
"127.0.0.1 wrote:\n"
"b'python is nice'"

#: ../../library/socketserver.rst:580
msgid "Client:"
msgstr "Клиент:"

#: ../../library/socketserver.rst:582
msgid ""
"$ python TCPClient.py hello world with TCP\n"
"Sent:     hello world with TCP\n"
"Received: HELLO WORLD WITH TCP\n"
"$ python TCPClient.py python is nice\n"
"Sent:     python is nice\n"
"Received: PYTHON IS NICE"
msgstr ""
"$ python TCPClient.py hello world with TCP\n"
"Sent:     hello world with TCP\n"
"Received: HELLO WORLD WITH TCP\n"
"$ python TCPClient.py python is nice\n"
"Sent:     python is nice\n"
"Received: PYTHON IS NICE"

#: ../../library/socketserver.rst:593
msgid ":class:`socketserver.UDPServer` Example"
msgstr "Пример :class:`socketserver.UDPServer`"

#: ../../library/socketserver.rst:597
msgid ""
"import socketserver\n"
"\n"
"class MyUDPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    This class works similar to the TCP handler class, except that\n"
"    self.request consists of a pair of data and client socket, and since\n"
"    there is no connection the client address must be given explicitly\n"
"    when sending data back via sendto().\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        data = self.request[0].strip()\n"
"        socket = self.request[1]\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(data)\n"
"        socket.sendto(data.upper(), self.client_address)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"    with socketserver.UDPServer((HOST, PORT), MyUDPHandler) as server:\n"
"        server.serve_forever()"
msgstr ""
"import socketserver\n"
"\n"
"class MyUDPHandler(socketserver.BaseRequestHandler):\n"
"    \"\"\"\n"
"    This class works similar to the TCP handler class, except that\n"
"    self.request consists of a pair of data and client socket, and since\n"
"    there is no connection the client address must be given explicitly\n"
"    when sending data back via sendto().\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        data = self.request[0].strip()\n"
"        socket = self.request[1]\n"
"        print(f\"{self.client_address[0]} wrote:\")\n"
"        print(data)\n"
"        socket.sendto(data.upper(), self.client_address)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    HOST, PORT = \"localhost\", 9999\n"
"    with socketserver.UDPServer((HOST, PORT), MyUDPHandler) as server:\n"
"        server.serve_forever()"

#: ../../library/socketserver.rst:621
msgid ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# SOCK_DGRAM is the socket type to use for UDP sockets\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n"
"\n"
"# As you can see, there is no connect() call; UDP has no connections.\n"
"# Instead, data is directly sent to the recipient via sendto().\n"
"sock.sendto(bytes(data + \"\\n\", \"utf-8\"), (HOST, PORT))\n"
"received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"
msgstr ""
"import socket\n"
"import sys\n"
"\n"
"HOST, PORT = \"localhost\", 9999\n"
"data = \" \".join(sys.argv[1:])\n"
"\n"
"# SOCK_DGRAM is the socket type to use for UDP sockets\n"
"sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n"
"\n"
"# As you can see, there is no connect() call; UDP has no connections.\n"
"# Instead, data is directly sent to the recipient via sendto().\n"
"sock.sendto(bytes(data + \"\\n\", \"utf-8\"), (HOST, PORT))\n"
"received = str(sock.recv(1024), \"utf-8\")\n"
"\n"
"print(\"Sent:    \", data)\n"
"print(\"Received:\", received)"

#: ../../library/socketserver.rst:638
msgid ""
"The output of the example should look exactly like for the TCP server "
"example."
msgstr ""
"Вывод примера должен выглядеть точно так же, как в примере с TCP-сервером."

#: ../../library/socketserver.rst:642
msgid "Asynchronous Mixins"
msgstr "Асинхронные миксеры"

#: ../../library/socketserver.rst:644
msgid ""
"To build asynchronous handlers, use the :class:`ThreadingMixIn` and :class:"
"`ForkingMixIn` classes."
msgstr ""
"Для создания асинхронных обработчиков используйте классы :class:"
"`ThreadingMixIn` и :class:`ForkingMixIn`."

#: ../../library/socketserver.rst:647
msgid "An example for the :class:`ThreadingMixIn` class::"
msgstr "Пример класса :class:`ThreadingMixIn`::"

#: ../../library/socketserver.rst:649
msgid ""
"import socket\n"
"import threading\n"
"import socketserver\n"
"\n"
"class ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        data = str(self.request.recv(1024), 'ascii')\n"
"        cur_thread = threading.current_thread()\n"
"        response = bytes(\"{}: {}\".format(cur_thread.name, data), 'ascii')\n"
"        self.request.sendall(response)\n"
"\n"
"class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver."
"TCPServer):\n"
"    pass\n"
"\n"
"def client(ip, port, message):\n"
"    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"        sock.connect((ip, port))\n"
"        sock.sendall(bytes(message, 'ascii'))\n"
"        response = str(sock.recv(1024), 'ascii')\n"
"        print(\"Received: {}\".format(response))\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Port 0 means to select an arbitrary unused port\n"
"    HOST, PORT = \"localhost\", 0\n"
"\n"
"    server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)\n"
"    with server:\n"
"        ip, port = server.server_address\n"
"\n"
"        # Start a thread with the server -- that thread will then start one\n"
"        # more thread for each request\n"
"        server_thread = threading.Thread(target=server.serve_forever)\n"
"        # Exit the server thread when the main thread terminates\n"
"        server_thread.daemon = True\n"
"        server_thread.start()\n"
"        print(\"Server loop running in thread:\", server_thread.name)\n"
"\n"
"        client(ip, port, \"Hello World 1\")\n"
"        client(ip, port, \"Hello World 2\")\n"
"        client(ip, port, \"Hello World 3\")\n"
"\n"
"        server.shutdown()"
msgstr ""
"import socket\n"
"import threading\n"
"import socketserver\n"
"\n"
"class ThreadedTCPRequestHandler(socketserver.BaseRequestHandler):\n"
"\n"
"    def handle(self):\n"
"        data = str(self.request.recv(1024), 'ascii')\n"
"        cur_thread = threading.current_thread()\n"
"        response = bytes(\"{}: {}\".format(cur_thread.name, data), 'ascii')\n"
"        self.request.sendall(response)\n"
"\n"
"class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver."
"TCPServer):\n"
"    pass\n"
"\n"
"def client(ip, port, message):\n"
"    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n"
"        sock.connect((ip, port))\n"
"        sock.sendall(bytes(message, 'ascii'))\n"
"        response = str(sock.recv(1024), 'ascii')\n"
"        print(\"Received: {}\".format(response))\n"
"\n"
"if __name__ == \"__main__\":\n"
"    # Port 0 means to select an arbitrary unused port\n"
"    HOST, PORT = \"localhost\", 0\n"
"\n"
"    server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)\n"
"    with server:\n"
"        ip, port = server.server_address\n"
"\n"
"        # Start a thread with the server -- that thread will then start one\n"
"        # more thread for each request\n"
"        server_thread = threading.Thread(target=server.serve_forever)\n"
"        # Exit the server thread when the main thread terminates\n"
"        server_thread.daemon = True\n"
"        server_thread.start()\n"
"        print(\"Server loop running in thread:\", server_thread.name)\n"
"\n"
"        client(ip, port, \"Hello World 1\")\n"
"        client(ip, port, \"Hello World 2\")\n"
"        client(ip, port, \"Hello World 3\")\n"
"\n"
"        server.shutdown()"

#: ../../library/socketserver.rst:696
msgid ""
"$ python ThreadedTCPServer.py\n"
"Server loop running in thread: Thread-1\n"
"Received: Thread-2: Hello World 1\n"
"Received: Thread-3: Hello World 2\n"
"Received: Thread-4: Hello World 3"
msgstr ""
"$ python ThreadedTCPServer.py\n"
"Server loop running in thread: Thread-1\n"
"Received: Thread-2: Hello World 1\n"
"Received: Thread-3: Hello World 2\n"
"Received: Thread-4: Hello World 3"

#: ../../library/socketserver.rst:705
msgid ""
"The :class:`ForkingMixIn` class is used in the same way, except that the "
"server will spawn a new process for each request. Available only on POSIX "
"platforms that support :func:`~os.fork`."
msgstr ""
"Класс :class:`ForkingMixIn` используется таким же образом, за исключением "
"того, что сервер будет запускать новый процесс для каждого запроса. Доступно "
"только на платформах POSIX, поддерживающих :func:`~os.fork`."
