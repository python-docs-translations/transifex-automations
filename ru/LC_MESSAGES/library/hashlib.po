# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:16+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/hashlib.rst:2
msgid ":mod:`hashlib` --- Secure hashes and message digests"
msgstr ""

#: ../../library/hashlib.rst:10
msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Исходный код:** :source:`Lib/hashlib.py`"

#: ../../library/hashlib.rst:23
msgid ""
"This module implements a common interface to many different secure hash and "
"message digest algorithms.  Included are the FIPS secure hash algorithms "
"SHA1, SHA224, SHA256, SHA384, SHA512, (defined in `the FIPS 180-4 "
"standard`_), the SHA-3 series (defined in `the FIPS 202 standard`_) as well "
"as RSA's MD5 algorithm (defined in internet :rfc:`1321`).  The terms "
"\"secure hash\" and \"message digest\" are interchangeable.  Older "
"algorithms were called message digests.  The modern term is secure hash."
msgstr ""
"Этот модуль реализует общий интерфейс для множества различных алгоритмов "
"безопасного хеширования и дайджеста сообщений. Включены безопасные алгоритмы "
"хеширования FIPS SHA1, SHA224, SHA256, SHA384, SHA512 (определенные в "
"«стандарте FIPS 180-4»), серия SHA-3 (определенная в «стандарте FIPS 202»_), "
"а также Алгоритм RSA MD5 (определен в Интернете:rfc:`1321`). Термины "
"«безопасный хэш» и «дайджест сообщения» взаимозаменяемы. Старые алгоритмы "
"назывались дайджестами сообщений. Современный термин — безопасный хэш."

#: ../../library/hashlib.rst:33
msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the :"
"mod:`zlib` module."
msgstr ""
"Если вам нужны хеш-функции adler32 или crc32, они доступны в модуле :mod:"
"`zlib`."

#: ../../library/hashlib.rst:40
msgid "Hash algorithms"
msgstr "Алгоритмы хэширования"

#: ../../library/hashlib.rst:42
msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use :func:"
"`sha256` to create a SHA-256 hash object. You can now feed this object with :"
"term:`bytes-like objects <bytes-like object>` (normally :class:`bytes`) "
"using the :meth:`update<hash.update>` method.  At any point you can ask it "
"for the :dfn:`digest` of the concatenation of the data fed to it so far "
"using the :meth:`digest()<hash.digest>` or :meth:`hexdigest()<hash."
"hexdigest>` methods."
msgstr ""
"Для каждого типа :dfn:`hash` назван один метод-конструктор. Все они "
"возвращают хэш-объект с одним и тем же простым интерфейсом. Например: "
"используйте :func:`sha256` для создания хеш-объекта SHA-256. Теперь вы "
"можете передать этому объекту :term:`bytes-like object <bytes-like object>` "
"(обычно :class:`bytes`), используя метод :meth:`update<hash.update>`. В "
"любой момент вы можете запросить у него :dfn:`digest` объединения переданных "
"ему данных, используя :meth:`digest()<hash.digest>` или :meth:`hexdigest()< "
"методы hash.hexdigest>`."

#: ../../library/hashlib.rst:50
msgid ""
"To allow multithreading, the Python :term:`GIL` is released while computing "
"a hash supplied more than 2047 bytes of data at once in its constructor or :"
"meth:`.update<hash.update>` method."
msgstr ""
"Чтобы обеспечить многопоточность, Python :term:`GIL` высвобождается при "
"вычислении хеша, предоставляющего более 2047 байтов данных одновременно в "
"его конструкторе или методе :meth:`.update<hash.update>`."

#: ../../library/hashlib.rst:57
msgid ""
"Constructors for hash algorithms that are always present in this module are :"
"func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:"
"`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:`blake2b`, and :func:"
"`blake2s`. :func:`md5` is normally available as well, though it may be "
"missing or blocked if you are using a rare \"FIPS compliant\" build of "
"Python. These correspond to :data:`algorithms_guaranteed`."
msgstr ""
"Конструкторы для хэш-алгоритмов, которые всегда присутствуют в этом модуле: :"
"func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func: `sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:"
"`sha3_512`, :func:`shake_128`, :func:`shake_256`, :func:`blake2b` и :func: "
"`blake2s`. :func:`md5` обычно также доступен, хотя он может отсутствовать "
"или блокироваться, если вы используете редкую сборку Python, совместимую с "
"FIPS. Они соответствуют :data:`algorithms_guarantee`."

#: ../../library/hashlib.rst:65
msgid ""
"Additional algorithms may also be available if your Python distribution's :"
"mod:`hashlib` was linked against a build of OpenSSL that provides others. "
"Others *are not guaranteed available* on all installations and will only be "
"accessible by name via :func:`new`.  See :data:`algorithms_available`."
msgstr ""
"Дополнительные алгоритмы также могут быть доступны, если :mod:`hashlib` "
"вашего дистрибутива Python был связан со сборкой OpenSSL, которая "
"предоставляет другие. Другие *не гарантированно доступны* во всех установках "
"и будут доступны только по имени через :func:`new`. См. :data:"
"`algorithms_available`."

#: ../../library/hashlib.rst:72
msgid ""
"Some algorithms have known hash collision weaknesses (including MD5 and "
"SHA1). Refer to `Attacks on cryptographic hash algorithms`_ and the `hashlib-"
"seealso`_ section at the end of this document."
msgstr ""
"Некоторые алгоритмы имеют известные недостатки коллизий хэшей (включая MD5 и "
"SHA1). Обратитесь к разделу «Атаки на криптографические алгоритмы "
"хэширования» и разделу «hashlib-seealso» в конце этого документа."

#: ../../library/hashlib.rst:76
msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` were "
"added. :func:`blake2b` and :func:`blake2s` were added."
msgstr ""
"Добавлены конструкторы SHA3 (Keccak) и SHAKE :func:`sha3_224`, :func:"
"`sha3_256`, :func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:"
"`shake_256`. . Были добавлены :func:`blake2b` и :func:`blake2s`."

#: ../../library/hashlib.rst:84
msgid ""
"All hashlib constructors take a keyword-only argument *usedforsecurity* with "
"default value ``True``. A false value allows the use of insecure and blocked "
"hashing algorithms in restricted environments. ``False`` indicates that the "
"hashing algorithm is not used in a security context, e.g. as a non-"
"cryptographic one-way compression function."
msgstr ""
"Все конструкторы hashlib принимают аргумент, содержащий только ключевые "
"слова *usedforsecurity* со значением по умолчанию ``True``. Ложное значение "
"позволяет использовать небезопасные и заблокированные алгоритмы хеширования "
"в средах с ограниченным доступом. «False» указывает, что алгоритм "
"хеширования не используется в контексте безопасности, например, как "
"некриптографическая односторонняя функция сжатия."

#: ../../library/hashlib.rst:91
msgid "Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it."
msgstr ""
"Hashlib теперь использует SHA3 и SHAKE из OpenSSL, если он их предоставляет."

#: ../../library/hashlib.rst:95
msgid "Usage"
msgstr "Использование"

#: ../../library/hashlib.rst:97
msgid ""
"To obtain the digest of the byte string ``b\"Nobody inspects the spammish "
"repetition\"``::"
msgstr ""
"Чтобы получить дайджест байтовой строки ``b\"Никто не проверяет повторение "
"спама\"``::"

#: ../../library/hashlib.rst:109
msgid "More condensed:"
msgstr "Более сжато:"

#: ../../library/hashlib.rst:115
msgid "Constructors"
msgstr "Конструкторы"

#: ../../library/hashlib.rst:119
msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer."
msgstr ""
"Это универсальный конструктор, который принимает строку *имя* желаемого "
"алгоритма в качестве первого параметра. Он также существует для обеспечения "
"доступа к перечисленным выше хешам, а также к любым другим алгоритмам, "
"которые может предложить ваша библиотека OpenSSL."

#: ../../library/hashlib.rst:124
msgid "Using :func:`new` with an algorithm name:"
msgstr "Использование :func:`new` с именем алгоритма:"

#: ../../library/hashlib.rst:143
msgid ""
"Named constructors such as these are faster than passing an algorithm name "
"to :func:`new`."
msgstr ""
"Именованные конструкторы, подобные этим, работают быстрее, чем передача "
"имени алгоритма в :func:`new`."

#: ../../library/hashlib.rst:147
msgid "Attributes"
msgstr "Атрибуты"

#: ../../library/hashlib.rst:149
msgid "Hashlib provides the following constant module attributes:"
msgstr "Hashlib предоставляет следующие постоянные атрибуты модуля:"

#: ../../library/hashlib.rst:153
msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported "
"by this module on all platforms.  Note that 'md5' is in this list despite "
"some upstream vendors offering an odd \"FIPS compliant\" Python build that "
"excludes it."
msgstr ""
"Набор, содержащий названия алгоритмов хеширования, которые гарантированно "
"поддерживаются этим модулем на всех платформах. Обратите внимание, что «md5» "
"присутствует в этом списке, несмотря на то, что некоторые поставщики "
"исходного кода предлагают странную «совместимую с FIPS» сборку Python, "
"которая исключает его."

#: ../../library/hashlib.rst:162
msgid ""
"A set containing the names of the hash algorithms that are available in the "
"running Python interpreter.  These names will be recognized when passed to :"
"func:`new`.  :attr:`algorithms_guaranteed` will always be a subset.  The "
"same algorithm may appear multiple times in this set under different names "
"(thanks to OpenSSL)."
msgstr ""
"Набор, содержащий имена хеш-алгоритмов, доступных в работающем "
"интерпретаторе Python. Эти имена будут распознаны при передаче в :func:"
"`new`. :attr:`algorithms_guarantee` всегда будет подмножеством. Один и тот "
"же алгоритм может появляться в этом наборе несколько раз под разными именами "
"(спасибо OpenSSL)."

#: ../../library/hashlib.rst:171
msgid "Hash Objects"
msgstr "Хэш-объекты"

#: ../../library/hashlib.rst:173
msgid ""
"The following values are provided as constant attributes of the hash objects "
"returned by the constructors:"
msgstr ""
"Следующие значения предоставляются как постоянные атрибуты хеш-объектов, "
"возвращаемых конструкторами:"

#: ../../library/hashlib.rst:178
msgid "The size of the resulting hash in bytes."
msgstr "Размер полученного хеша в байтах."

#: ../../library/hashlib.rst:182
msgid "The internal block size of the hash algorithm in bytes."
msgstr "Размер внутреннего блока хэш-алгоритма в байтах."

#: ../../library/hashlib.rst:184
msgid "A hash object has the following attributes:"
msgstr "Хэш-объект имеет следующие атрибуты:"

#: ../../library/hashlib.rst:188
msgid ""
"The canonical name of this hash, always lowercase and always suitable as a "
"parameter to :func:`new` to create another hash of this type."
msgstr ""
"Каноническое имя этого хеша, всегда в нижнем регистре и всегда подходящее в "
"качестве параметра :func:`new` для создания другого хеша этого типа."

#: ../../library/hashlib.rst:191
msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"Атрибут name присутствовал в CPython с момента его создания, но до версии "
"Python 3.4 он не был официально определен, поэтому может не существовать на "
"некоторых платформах."

#: ../../library/hashlib.rst:196
msgid "A hash object has the following methods:"
msgstr "Хэш-объект имеет следующие методы:"

#: ../../library/hashlib.rst:201
msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls "
"are equivalent to a single call with the concatenation of all the arguments: "
"``m.update(a); m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Обновите хеш-объект, добавив в него :term:`bytes-like object`. Повторные "
"вызовы эквивалентны одному вызову с объединением всех аргументов: ``m."
"update(a); m.update(b)`` эквивалентен ``m.update(a+b)``."

#: ../../library/hashlib.rst:206
msgid ""
"The Python GIL is released to allow other threads to run while hash updates "
"on data larger than 2047 bytes is taking place when using hash algorithms "
"supplied by OpenSSL."
msgstr ""

#: ../../library/hashlib.rst:214
msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size :attr:`digest_size` which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"Возвращает дайджест данных, переданных в метод :meth:`update`. Это байтовый "
"объект размером :attr:`digest_size`, который может содержать байты во всем "
"диапазоне от 0 до 255."

#: ../../library/hashlib.rst:221
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
"Аналогично :meth:`digest`, за исключением того, что дайджест возвращается в "
"виде строкового объекта двойной длины, содержащего только шестнадцатеричные "
"цифры. Это можно использовать для безопасного обмена значениями по "
"электронной почте или в других недвоичных средах."

#: ../../library/hashlib.rst:228
msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial substring."
msgstr ""
"Вернуть копию («клон») хэш-объекта. Это можно использовать для эффективного "
"вычисления дайджестов данных, имеющих общую начальную подстроку."

#: ../../library/hashlib.rst:233
msgid "SHAKE variable length digests"
msgstr "Дайджесты SHAKE переменной длины"

#: ../../library/hashlib.rst:238
msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. As "
"such, their digest methods require a length. Maximum length is not limited "
"by the SHAKE algorithm."
msgstr ""
"Алгоритмы :func:`shake_128` и :func:`shake_256` обеспечивают дайджесты "
"переменной длины с length_in_bits//2 до 128 или 256 бит безопасности. Таким "
"образом, их методы дайджеста требуют длины. Максимальная длина не ограничена "
"алгоритмом SHAKE."

#: ../../library/hashlib.rst:245
msgid ""
"Return the digest of the data passed to the :meth:`~hash.update` method so "
"far. This is a bytes object of size *length* which may contain bytes in the "
"whole range from 0 to 255."
msgstr ""
"Возвращает дайджест данных, переданных в метод :meth:`~hash.update`. Это "
"байтовый объект размером *длина*, который может содержать байты во всем "
"диапазоне от 0 до 255."

#: ../../library/hashlib.rst:252
msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value in email or other non-binary environments."
msgstr ""
"Аналогично :meth:`digest`, за исключением того, что дайджест возвращается в "
"виде строкового объекта двойной длины, содержащего только шестнадцатеричные "
"цифры. Это можно использовать для обмена значением по электронной почте или "
"в других недвоичных средах."

#: ../../library/hashlib.rst:256
msgid "Example use:"
msgstr "Пример использования:"

#: ../../library/hashlib.rst:263
msgid "File hashing"
msgstr "Хеширование файлов"

#: ../../library/hashlib.rst:265
msgid ""
"The hashlib module provides a helper function for efficient hashing of a "
"file or file-like object."
msgstr ""
"Модуль hashlib предоставляет вспомогательную функцию для эффективного "
"хеширования файла или файловоподобного объекта."

#: ../../library/hashlib.rst:270
msgid ""
"Return a digest object that has been updated with contents of file object."
msgstr ""
"Возвращает объект дайджеста, который был обновлен содержимым файлового "
"объекта."

#: ../../library/hashlib.rst:272
msgid ""
"*fileobj* must be a file-like object opened for reading in binary mode. It "
"accepts file objects from  builtin :func:`open`, :class:`~io.BytesIO` "
"instances, SocketIO objects from :meth:`socket.socket.makefile`, and "
"similar. The function may bypass Python's I/O and use the file descriptor "
"from :meth:`~io.IOBase.fileno` directly. *fileobj* must be assumed to be in "
"an unknown state after this function returns or raises. It is up to the "
"caller to close *fileobj*."
msgstr ""
"*fileobj* должен быть файлоподобным объектом, открытым для чтения в двоичном "
"режиме. Он принимает файловые объекты из встроенных экземпляров :func:"
"`open`, :class:`~io.BytesIO`, объекты SocketIO из :meth:`socket.socket."
"makefile` и т.п. Функция может обходить ввод-вывод Python и напрямую "
"использовать дескриптор файла из :meth:`~io.IOBase.fileno`. Предполагается, "
"что *fileobj* находится в неизвестном состоянии после того, как эта функция "
"вернет или вызовет вызов. Вызывающая сторона должна закрыть *fileobj*."

#: ../../library/hashlib.rst:280
msgid ""
"*digest* must either be a hash algorithm name as a *str*, a hash "
"constructor, or a callable that returns a hash object."
msgstr ""
"*digest* должно быть либо именем алгоритма хэширования в виде *str*, либо "
"конструктором хэша, либо вызываемым объектом, который возвращает хэш-объект."

#: ../../library/hashlib.rst:283
msgid "Example:"
msgstr "Пример:"

#: ../../library/hashlib.rst:306
msgid "Key derivation"
msgstr "Ключевое происхождение"

#: ../../library/hashlib.rst:308
msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function must "
"be tunable, slow, and include a `salt <https://en.wikipedia.org/wiki/"
"Salt_%28cryptography%29>`_."
msgstr ""
"Алгоритмы получения и растяжения ключей предназначены для безопасного "
"хеширования паролей. Наивные алгоритмы, такие как «sha1(password)», не "
"устойчивы к атакам методом перебора. Хорошая функция хеширования паролей "
"должна быть настраиваемой, медленной и включать «соль» <https://en.wikipedia."
"org/wiki/Salt_. %28c ryptography%29>`_."

#: ../../library/hashlib.rst:316
msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It "
"uses HMAC as pseudorandom function."
msgstr ""
"Функция обеспечивает функцию получения ключа на основе пароля PKCS#5 2. Она "
"использует HMAC в качестве псевдослучайной функции."

#: ../../library/hashlib.rst:319
msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for "
"HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted as "
"buffers of bytes. Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024). *salt* should be about 16 or more bytes from a "
"proper source, e.g. :func:`os.urandom`."
msgstr ""
"Строка *hash_name* — это желаемое имя алгоритма хеш-дайджеста для HMAC, "
"например «sha1» или «sha256». *password* и *salt* интерпретируются как "
"буферы байтов. Приложения и библиотеки должны ограничивать *пароль* разумной "
"длиной (например, 1024). Размер *salt* должен составлять около 16 или более "
"байт из надлежащего источника, например :func:`os.urandom`."

#: ../../library/hashlib.rst:325
msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and "
"computing power. As of 2022, hundreds of thousands of iterations of SHA-256 "
"are suggested. For rationale as to why and how to choose what is best for "
"your application, read *Appendix A.2.2* of NIST-SP-800-132_. The answers on "
"the `stackexchange pbkdf2 iterations question`_ explain in detail."
msgstr ""
"Количество *итераций* должно выбираться на основе алгоритма хеширования и "
"вычислительной мощности. По состоянию на 2022 год предлагаются сотни тысяч "
"итераций SHA-256. Для обоснования того, почему и как выбрать то, что лучше "
"всего подходит для вашего применения, прочтите *Приложение A.2.2* NIST-"
"SP-800-132_. Ответы на вопрос об итерациях stackexchange pbkdf2 объясняют "
"подробно."

#: ../../library/hashlib.rst:331
msgid ""
"*dklen* is the length of the derived key. If *dklen* is ``None`` then the "
"digest size of the hash algorithm *hash_name* is used, e.g. 64 for SHA-512."
msgstr ""

#: ../../library/hashlib.rst:344
msgid ""
"A fast implementation of *pbkdf2_hmac* is available with OpenSSL.  The "
"Python implementation uses an inline version of :mod:`hmac`. It is about "
"three times slower and doesn't release the GIL."
msgstr ""

#: ../../library/hashlib.rst:350
msgid ""
"Slow Python implementation of *pbkdf2_hmac* is deprecated. In the future the "
"function will only be available when Python is compiled with OpenSSL."
msgstr ""

#: ../../library/hashlib.rst:356
msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr ""
"Эта функция обеспечивает функцию получения ключей на основе пароля, как "
"определено в :rfc:`7914`."

#: ../../library/hashlib.rst:359
msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a sensible "
"length (e.g. 1024).  *salt* should be about 16 or more bytes from a proper "
"source, e.g. :func:`os.urandom`."
msgstr ""
"*пароль* и *salt* должны быть :term:`байтоподобными объектами <байтоподобный "
"объект>`. Приложения и библиотеки должны ограничивать *пароль* разумной "
"длиной (например, 1024). Размер *salt* должен составлять около 16 или более "
"байт из надлежащего источника, например :func:`os.urandom`."

#: ../../library/hashlib.rst:364
msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization "
"factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). "
"*dklen* is the length of the derived key."
msgstr ""

#: ../../library/hashlib.rst:372
msgid "BLAKE2"
msgstr "BLAKE2"

#: ../../library/hashlib.rst:379
msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes "
"in two flavors:"
msgstr ""
"BLAKE2_ — это криптографическая хеш-функция, определенная в :rfc:`7693`, "
"которая существует в двух вариантах:"

#: ../../library/hashlib.rst:382
msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size "
"between 1 and 64 bytes,"
msgstr ""
"**BLAKE2b** оптимизирован для 64-битных платформ и создает дайджесты любого "
"размера от 1 до 64 байт."

#: ../../library/hashlib.rst:385
msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of "
"any size between 1 and 32 bytes."
msgstr ""
"**BLAKE2s** оптимизирован для 8-32-битных платформ и создает дайджесты "
"любого размера от 1 до 32 байт."

#: ../../library/hashlib.rst:388
msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_), "
"**salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 поддерживает **режим с ключами** (более быстрая и простая замена "
"HMAC_), **соленое хеширование**, **персонализацию** и **хеширование дерева**."

#: ../../library/hashlib.rst:391
msgid ""
"Hash objects from this module follow the API of standard library's :mod:"
"`hashlib` objects."
msgstr ""
"Хэш-объекты из этого модуля соответствуют API объектов :mod:`hashlib` "
"стандартной библиотеки."

#: ../../library/hashlib.rst:396
msgid "Creating hash objects"
msgstr "Создание хэш-объектов"

#: ../../library/hashlib.rst:398
msgid "New hash objects are created by calling constructor functions:"
msgstr "Новые хэш-объекты создаются путем вызова функций-конструкторов:"

#: ../../library/hashlib.rst:412
msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Эти функции возвращают соответствующие хэш-объекты для вычисления BLAKE2b "
"или BLAKE2. Они опционально принимают следующие общие параметры:"

#: ../../library/hashlib.rst:415
msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data*: начальный фрагмент данных для хеширования, который должен быть :term:"
"`байтоподобным объектом`. Его можно передать только как позиционный аргумент."

#: ../../library/hashlib.rst:418
msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: размер выходного дайджеста в байтах."

#: ../../library/hashlib.rst:420
msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for "
"BLAKE2s)."
msgstr ""
"*key*: ключ для хеширования с ключом (до 64 байт для BLAKE2b, до 32 байт для "
"BLAKE2)."

#: ../../library/hashlib.rst:423
msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr ""
"*salt*: соль для рандомизированного хеширования (до 16 байт для BLAKE2b, до "
"8 байт для BLAKE2)."

#: ../../library/hashlib.rst:426
msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes "
"for BLAKE2s)."
msgstr ""
"*person*: строка персонализации (до 16 байт для BLAKE2b, до 8 байт для "
"BLAKE2)."

#: ../../library/hashlib.rst:429
msgid "The following table shows limits for general parameters (in bytes):"
msgstr ""
"В следующей таблице приведены ограничения для общих параметров (в байтах).:"

#: ../../library/hashlib.rst:432
msgid "Hash"
msgstr "Hash"

#: ../../library/hashlib.rst:432
msgid "digest_size"
msgstr "digest_size"

#: ../../library/hashlib.rst:432
msgid "len(key)"
msgstr "len(key)"

#: ../../library/hashlib.rst:432
msgid "len(salt)"
msgstr "len(salt)"

#: ../../library/hashlib.rst:432
msgid "len(person)"
msgstr "len(person)"

#: ../../library/hashlib.rst:434
msgid "BLAKE2b"
msgstr "BLAKE2b"

#: ../../library/hashlib.rst:434
msgid "64"
msgstr "64"

#: ../../library/hashlib.rst:434
msgid "16"
msgstr "16"

#: ../../library/hashlib.rst:435
msgid "BLAKE2s"
msgstr "BLAKE2s"

#: ../../library/hashlib.rst:435
msgid "32"
msgstr "32"

#: ../../library/hashlib.rst:435
msgid "8"
msgstr "8"

#: ../../library/hashlib.rst:440
msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization "
"parameters, however, for convenience, this implementation accepts byte "
"strings of any size up to the specified length. If the length of the "
"parameter is less than specified, it is padded with zeros, thus, for "
"example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. (This is not "
"the case for *key*.)"
msgstr ""
"Спецификация BLAKE2 определяет постоянную длину для соли и параметров "
"персонализации, однако для удобства эта реализация принимает строки байтов "
"любого размера до указанной длины. Если длина параметра меньше указанной, он "
"дополняется нулями, таким образом, например, ``b'salt'`` и ``b'salt\\x00'`` "
"имеют одно и то же значение. (Это не относится к *key*.)"

#: ../../library/hashlib.rst:447
msgid "These sizes are available as module `constants`_ described below."
msgstr "Эти размеры доступны как константы модуля, описанные ниже."

#: ../../library/hashlib.rst:449
msgid ""
"Constructor functions also accept the following tree hashing parameters:"
msgstr ""
"Функции конструктора также принимают следующие параметры хеширования дерева:"

#: ../../library/hashlib.rst:451
msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr ""
"*fanout*: разветвление (от 0 до 255, 0, если неограниченно, 1 в "
"последовательном режиме)."

#: ../../library/hashlib.rst:453
msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential "
"mode)."
msgstr ""
"*глубина*: максимальная глубина дерева (от 1 до 255, 255, если "
"неограниченно, 1 в последовательном режиме)."

#: ../../library/hashlib.rst:456
msgid ""
"*leaf_size*: maximal byte length of leaf (0 to ``2**32-1``, 0 if unlimited "
"or in sequential mode)."
msgstr ""
"*leaf_size*: максимальная длина листа в байтах (от 0 до ``2**32-1``, 0, если "
"неограниченно или в последовательном режиме)."

#: ../../library/hashlib.rst:459
msgid ""
"*node_offset*: node offset (0 to ``2**64-1`` for BLAKE2b, 0 to ``2**48-1`` "
"for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset*: смещение узла (от 0 до ``2**64-1`` для BLAKE2b, от 0 до "
"``2**48-1`` для BLAKE2, 0 для первого, крайнего левого, листового или в "
"последовательном режиме. )."

#: ../../library/hashlib.rst:462
msgid ""
"*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_глубина*: глубина узла (от 0 до 255, 0 для листьев или в "
"последовательном режиме)."

#: ../../library/hashlib.rst:464
msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 "
"in sequential mode)."
msgstr ""
"*inner_size*: размер внутреннего дайджеста (от 0 до 64 для BLAKE2b, от 0 до "
"32 для BLAKE2, 0 в последовательном режиме)."

#: ../../library/hashlib.rst:467
msgid ""
"*last_node*: boolean indicating whether the processed node is the last one "
"(``False`` for sequential mode)."
msgstr ""
"*last_node*: логическое значение, указывающее, является ли обработанный узел "
"последним («False» для последовательного режима)."

#: ../../library/hashlib.rst-1
msgid "Explanation of tree mode parameters."
msgstr "Пояснения к параметрам режима дерева."

#: ../../library/hashlib.rst:474
msgid ""
"See section 2.10 in `BLAKE2 specification <https://www.blake2.net/"
"blake2_20130129.pdf>`_ for comprehensive review of tree hashing."
msgstr ""
"См. раздел 2.10 в `Спецификации BLAKE2 <https://www.blake2.net/"
"blake2_20130129.pdf>`_ для подробного обзора хеширования дерева."

#: ../../library/hashlib.rst:480
msgid "Constants"
msgstr "Константы"

#: ../../library/hashlib.rst:485
msgid "Salt length (maximum length accepted by constructors)."
msgstr "Длина соли (максимальная длина, принятая конструкторами)."

#: ../../library/hashlib.rst:491
msgid ""
"Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Длина строки персонализации (максимальная длина, принимаемая конструкторами)."

#: ../../library/hashlib.rst:497
msgid "Maximum key size."
msgstr "Максимальный размер ключа."

#: ../../library/hashlib.rst:503
msgid "Maximum digest size that the hash function can output."
msgstr "Максимальный размер дайджеста, который может вывести хеш-функция."

#: ../../library/hashlib.rst:507
msgid "Examples"
msgstr "Примеры"

#: ../../library/hashlib.rst:510
msgid "Simple hashing"
msgstr "Простое хэширование"

#: ../../library/hashlib.rst:512
msgid ""
"To calculate hash of some data, you should first construct a hash object by "
"calling the appropriate constructor function (:func:`blake2b` or :func:"
"`blake2s`), then update it with the data by calling :meth:`~hash.update` on "
"the object, and, finally, get the digest out of the object by calling :meth:"
"`~hash.digest` (or :meth:`~hash.hexdigest` for hex-encoded string)."
msgstr ""
"Чтобы вычислить хэш некоторых данных, вам следует сначала создать хэш-"
"объект, вызвав соответствующую функцию-конструктор (:func:`blake2b` или :"
"func:`blake2s`), а затем обновить его данными, вызвав :meth:`~hash .update` "
"объекта и, наконец, получите дайджест объекта, вызвав :meth:`~hash.digest` "
"(или :meth:`~hash.hexdigest` для строки в шестнадцатеричном формате)."

#: ../../library/hashlib.rst:525
msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to "
"the constructor as the positional argument:"
msgstr ""
"В качестве ярлыка вы можете передать первый фрагмент данных для обновления "
"непосредственно конструктору в качестве позиционного аргумента:"

#: ../../library/hashlib.rst:532
msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively "
"update the hash:"
msgstr ""
"Вы можете вызывать :meth:`hash.update` столько раз, сколько вам нужно, чтобы "
"итеративно обновить хэш:"

#: ../../library/hashlib.rst:545
msgid "Using different digest sizes"
msgstr "Использование разных размеров дайджеста"

#: ../../library/hashlib.rst:547
msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to "
"32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without "
"changing the size of output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 имеет настраиваемый размер дайджестов до 64 байтов для BLAKE2b и до "
"32 байтов для BLAKE2. Например, чтобы заменить SHA-1 на BLAKE2b без "
"изменения размера вывода, мы можем указать BLAKE2b создавать 20-байтовые "
"дайджесты:"

#: ../../library/hashlib.rst:561
msgid ""
"Hash objects with different digest sizes have completely different outputs "
"(shorter hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s "
"produce different outputs even if the output length is the same:"
msgstr ""
"Хэш-объекты с разными размерами дайджеста имеют совершенно разные выходные "
"данные (более короткие хэши *не* являются префиксами более длинных хэшей); "
"BLAKE2b и BLAKE2 выдают разные выходные данные, даже если длина выходных "
"данных одинакова:"

#: ../../library/hashlib.rst:577
msgid "Keyed hashing"
msgstr "Хеширование с ключом"

#: ../../library/hashlib.rst:579
msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code <https://en."
"wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 can be securely used in prefix-MAC "
"mode thanks to the indifferentiability property inherited from BLAKE."
msgstr ""
"Хеширование с ключом можно использовать для аутентификации как более быструю "
"и простую замену «кода аутентификации сообщения на основе хэша <https://en."
"wikipedia.org/wiki/HMAC>»_ (HMAC). BLAKE2 можно безопасно использовать в "
"режиме префикса-MAC благодаря свойству недифференцируемости, унаследованному "
"от BLAKE."

#: ../../library/hashlib.rst:585
msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code "
"for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"В этом примере показано, как получить (шестнадцатеричный) 128-битный код "
"аутентификации для сообщения ``b'message data'`` с ключом ``b'pseudorandom "
"key'``::"

#: ../../library/hashlib.rst:595
msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered with::"
msgstr ""
"В качестве практического примера веб-приложение может симметрично "
"подписывать файлы cookie, отправленные пользователям, а затем проверять их, "
"чтобы убедиться, что они не были подделаны:"

#: ../../library/hashlib.rst:624
msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be "
"used in HMAC construction with :mod:`hmac` module::"
msgstr ""
"Несмотря на то, что существует собственный режим хеширования с ключом, "
"BLAKE2, конечно, можно использовать в построении HMAC с модулем :mod:`hmac`::"

#: ../../library/hashlib.rst:635
msgid "Randomized hashing"
msgstr "Рандомизированное хэширование"

#: ../../library/hashlib.rst:637
msgid ""
"By setting *salt* parameter users can introduce randomization to the hash "
"function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"Установив параметр *salt*, пользователи могут ввести рандомизацию в хеш-"
"функцию. Рандомизированное хеширование полезно для защиты от коллизионных "
"атак на хеш-функцию, используемую в цифровых подписях."

#: ../../library/hashlib.rst:641
msgid ""
"Randomized hashing is designed for situations where one party, the message "
"preparer, generates all or part of a message to be signed by a second party, "
"the message signer. If the message preparer is able to find cryptographic "
"hash function collisions (i.e., two messages producing the same hash value), "
"then they might prepare meaningful versions of the message that would "
"produce the same hash value and digital signature, but with different "
"results (e.g., transferring $1,000,000 to an account, rather than $10). "
"Cryptographic hash functions have been designed with collision resistance as "
"a major goal, but the current concentration on attacking cryptographic hash "
"functions may result in a given cryptographic hash function providing less "
"collision resistance than expected. Randomized hashing offers the signer "
"additional protection by reducing the likelihood that a preparer can "
"generate two or more messages that ultimately yield the same hash value "
"during the digital signature generation process --- even if it is practical "
"to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature "
"when all portions of the message are prepared by the signer."
msgstr ""
"Рандомизированное хеширование предназначено для ситуаций, когда одна "
"сторона, составитель сообщения, генерирует все или часть сообщения, которое "
"должно быть подписано второй стороной, подписывающей стороной сообщения. "
"Если составитель сообщения способен обнаружить коллизии криптографических "
"хеш-функций (т. е. два сообщения, производящие одно и то же значение хеш-"
"функции), тогда он может подготовить значимые версии сообщения, которые "
"будут создавать одно и то же значение хеш-функции и цифровую подпись, но с "
"разными результатами (например, , переведя на счет 1 000 000 долларов США, а "
"не 10 долларов США). Криптографические хэш-функции были разработаны с учетом "
"устойчивости к коллизиям в качестве основной цели, но текущая концентрация "
"на атаках на криптографические хэш-функции может привести к тому, что данная "
"криптографическая хеш-функция будет обеспечивать меньшую устойчивость к "
"коллизиям, чем ожидалось. Рандомизированное хеширование обеспечивает "
"подписавшему дополнительную защиту, уменьшая вероятность того, что "
"составитель сможет сгенерировать два или более сообщений, которые в конечном "
"итоге дадут одно и то же значение хеш-функции в процессе генерации цифровой "
"подписи, даже если практически возможно найти коллизии для хеш-функции. "
"Однако использование рандомизированного хеширования может снизить уровень "
"безопасности, обеспечиваемый цифровой подписью, когда все части сообщения "
"подготовлены подписывающим лицом."

#: ../../library/hashlib.rst:660
msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/publications/detail/sp/800-106/archive/2009-02-25>`_)"
msgstr ""

#: ../../library/hashlib.rst:663
msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression function."
msgstr ""
"В BLAKE2 соль обрабатывается как одноразовый входной сигнал хэш-функции во "
"время инициализации, а не как входной сигнал для каждой функции сжатия."

#: ../../library/hashlib.rst:668
msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing "
"passwords.  See `BLAKE2 FAQ <https://www.blake2.net/#qa>`_ for more "
"information."
msgstr ""
"*Соленое хеширование* (или просто хеширование) с помощью BLAKE2 или любой "
"другой криптографической хэш-функции общего назначения, такой как SHA-256, "
"не подходит для хеширования паролей. Дополнительную информацию см. в разделе "
"«Часто задаваемые вопросы по BLAKE2 <https://www.blake2.net/#qa>»."

#: ../../library/hashlib.rst:691
msgid "Personalization"
msgstr "Персонализация"

#: ../../library/hashlib.rst:693
msgid ""
"Sometimes it is useful to force hash function to produce different digests "
"for the same input for different purposes. Quoting the authors of the Skein "
"hash function:"
msgstr ""
"Иногда полезно заставить хэш-функцию создавать разные дайджесты для одного и "
"того же ввода для разных целей. Цитируем авторов хеш-функции Skein:"

#: ../../library/hashlib.rst:697
msgid ""
"We recommend that all application designers seriously consider doing this; "
"we have seen many protocols where a hash that is computed in one part of the "
"protocol can be used in an entirely different part because two hash "
"computations were done on similar or related data, and the attacker can "
"force the application to make the hash inputs the same. Personalizing each "
"hash function used in the protocol summarily stops this type of attack."
msgstr ""
"Мы рекомендуем всем разработчикам приложений серьезно подумать об этом; мы "
"видели много протоколов, в которых хэш, вычисленный в одной части протокола, "
"может использоваться в совершенно другой части, поскольку два хеш-вычисления "
"были выполнены для аналогичных или связанных данных, и злоумышленник может "
"заставить приложение сделать хэш-входы такой же. Персонализация каждой хеш-"
"функции, используемой в протоколе, полностью останавливает этот тип атаки."

#: ../../library/hashlib.rst:704
msgid ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, p. 21)"
msgstr ""
"(`Семейство хеш-функций Skein <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, стр. 21)"

#: ../../library/hashlib.rst:708
msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2 можно персонализировать, передав байты в аргумент *person*::"

#: ../../library/hashlib.rst:722
msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr ""
"Персонализация вместе с режимом с ключами также может использоваться для "
"получения разных ключей из одного."

#: ../../library/hashlib.rst:736
msgid "Tree mode"
msgstr "Режим дерева"

#: ../../library/hashlib.rst:738
msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr "Вот пример хеширования минимального дерева с двумя листовыми узлами:"

#: ../../library/hashlib.rst:744
msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final "
"digest::"
msgstr ""
"В этом примере используются 64-байтовые внутренние дайджесты и возвращается "
"32-байтовый окончательный дайджест:"

#: ../../library/hashlib.rst:774
msgid "Credits"
msgstr "Авторы"

#: ../../library/hashlib.rst:776
msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ "
"created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and "
"*Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ был разработан *Жаном-Филиппом Омассоном*, *Сэмюэлем Невесом*, *Зуко "
"Уилкокс-О'Хирном* и *Кристианом Виннерляйном* на основе финалиста SHA-3_ "
"BLAKE_, созданного *Жан-Филиппом Омассоном*, *Лука Хензен* , *Вилли Мейер* и "
"*Рафаэль К.-В. Фан*."

#: ../../library/hashlib.rst:781
msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr ""
"Он использует основной алгоритм шифра ChaCha_, разработанный *Дэниелом Дж. "
"Бернштейном*."

#: ../../library/hashlib.rst:783
msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by "
"*Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. The "
"documentation was copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"Реализация stdlib основана на модуле pyblake2_. Он был написан *Дмитрием "
"Честных* на основе реализации C, написанной *Сэмюэлем Невесом*. Документация "
"была скопирована с pyblake2_ и написана *Дмитрием Честных*."

#: ../../library/hashlib.rst:787
msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr "Код C был частично переписан для Python *Кристианом Хеймсом*."

#: ../../library/hashlib.rst:789
msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr ""
"Следующее общедоступное определение применимо как к реализации хэш-функции "
"C, коду расширения, так и к этой документации:"

#: ../../library/hashlib.rst:792
msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright "
"and related and neighboring rights to this software to the public domain "
"worldwide. This software is distributed without any warranty."
msgstr ""
"В той мере, в какой это возможно по закону, автор(ы) передали все авторские "
"и смежные права на это программное обеспечение в общественное достояние по "
"всему миру. Это программное обеспечение распространяется без каких-либо "
"гарантий."

#: ../../library/hashlib.rst:796
msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along "
"with this software. If not, see https://creativecommons.org/publicdomain/"
"zero/1.0/."
msgstr ""
"Вместе с этим программным обеспечением вы должны были получить копию "
"Посвящения CC0 Public Domain. Если нет, см. https://creativecommons.org/"
"publicdomain/zero/1.0/."

#: ../../library/hashlib.rst:800
msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"Следующие люди помогали в разработке или вносили свои изменения в проект и "
"общественное достояние в соответствии с лицензией Creative Commons Public "
"Domain Dedication 1.0 Universal:"

#: ../../library/hashlib.rst:804
msgid "*Alexandr Sokolovskiy*"
msgstr "*Александр Соколовский*"

#: ../../library/hashlib.rst:824
msgid "Module :mod:`hmac`"
msgstr "Модуль :mod:`hmac`"

#: ../../library/hashlib.rst:824
msgid "A module to generate message authentication codes using hashes."
msgstr ""
"Модуль для генерации кодов аутентификации сообщений с использованием хэшей."

#: ../../library/hashlib.rst:827
msgid "Module :mod:`base64`"
msgstr "Модуль :mod:`base64`"

#: ../../library/hashlib.rst:827
msgid "Another way to encode binary hashes for non-binary environments."
msgstr "Еще один способ кодирования двоичных хэшей для недвоичных сред."

#: ../../library/hashlib.rst:830
msgid "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"
msgstr "https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf"

#: ../../library/hashlib.rst:830
msgid "The FIPS 180-4 publication on Secure Hash Algorithms."
msgstr "Публикация FIPS 180-4 по алгоритмам безопасного хеширования."

#: ../../library/hashlib.rst:833
msgid "https://csrc.nist.gov/publications/detail/fips/202/final"
msgstr "https://csrc.nist.gov/publications/detail/fips/202/final"

#: ../../library/hashlib.rst:833
msgid "The FIPS 202 publication on the SHA-3 Standard."
msgstr "Публикация FIPS 202 по стандарту SHA-3."

#: ../../library/hashlib.rst:836
msgid "https://www.blake2.net/"
msgstr "https://www.blake2.net/"

#: ../../library/hashlib.rst:836
msgid "Official BLAKE2 website."
msgstr "Официальный сайт BLAKE2."

#: ../../library/hashlib.rst:840
msgid "https://en.wikipedia.org/wiki/Cryptographic_hash_function"
msgstr "https://en.wikipedia.org/wiki/Cryptographic_hash_function"

#: ../../library/hashlib.rst:839
msgid ""
"Wikipedia article with information on which algorithms have known issues and "
"what that means regarding their use."
msgstr ""
"Статья в Википедии с информацией о том, какие алгоритмы имеют известные "
"проблемы и что это означает в отношении их использования."

#: ../../library/hashlib.rst:843
msgid "https://www.ietf.org/rfc/rfc8018.txt"
msgstr "https://www.ietf.org/rfc/rfc8018.txt"

#: ../../library/hashlib.rst:843
msgid "PKCS #5: Password-Based Cryptography Specification Version 2.1"
msgstr "PKCS #5: Спецификация шифрования на основе паролей, версия 2.1"

#: ../../library/hashlib.rst:845
msgid ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"
msgstr ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"

#: ../../library/hashlib.rst:846
msgid "NIST Recommendation for Password-Based Key Derivation."
msgstr "Рекомендации NIST по получению ключей на основе пароля."

#: ../../library/hashlib.rst:12
msgid "message digest, MD5"
msgstr "дайджест сообщения, MD5"

#: ../../library/hashlib.rst:12
msgid ""
"secure hash algorithm, SHA1, SHA2, SHA224, SHA256, SHA384, SHA512, SHA3, "
"Shake, Blake2"
msgstr ""
"алгоритм безопасного хеширования, SHA1, SHA2, SHA224, SHA256, SHA384, "
"SHA512, SHA3, Shake, Blake2"

#: ../../library/hashlib.rst:55
msgid "OpenSSL"
msgstr "OpenSSL"

#: ../../library/hashlib.rst:55
msgid "(use in module hashlib)"
msgstr "(используйте в хеш-библиотеке модуля)"

#: ../../library/hashlib.rst:376
msgid "blake2b, blake2s"
msgstr "blake2b, blake2s"
