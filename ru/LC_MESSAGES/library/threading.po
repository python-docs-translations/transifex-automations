# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:20+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/threading.rst:2
msgid ":mod:`threading` --- Thread-based parallelism"
msgstr ""

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Исходный код:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr ""
"Этот модуль создает интерфейсы потоков более высокого уровня поверх модуля "
"нижнего уровня :mod:`_thread`."

#: ../../library/threading.rst:14
msgid "This module used to be optional, it is now always available."
msgstr "Раньше этот модуль был необязательным, теперь он всегда доступен."

#: ../../library/threading.rst:19
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` предлагает интерфейс более "
"высокого уровня для передачи задач в фоновый поток без блокировки выполнения "
"вызывающего потока, но при этом с возможностью получения их результатов при "
"необходимости."

#: ../../library/threading.rst:23
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""
":mod:`queue` предоставляет потокобезопасный интерфейс для обмена данными "
"между запущенными потоками."

#: ../../library/threading.rst:26
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""
":mod:`asyncio` предлагает альтернативный подход к достижению параллелизма на "
"уровне задач без необходимости использования нескольких потоков операционной "
"системы."

#: ../../library/threading.rst:31
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""
"В серии Python 2.x этот модуль содержал имена CamelCase для некоторых "
"методов и функций. Начиная с Python 3.10 они устарели, но по-прежнему "
"поддерживаются для совместимости с Python 2.5 и более ранними версиями."

#: ../../library/threading.rst:38
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"В CPython из-за :term:`Global Interpreter Lock <глобальная блокировка "
"интерпретатора>` только один поток может выполнять код Python одновременно "
"(хотя некоторые библиотеки, ориентированные на производительность, могут "
"обойти это ограничение). Если вы хотите, чтобы ваше приложение лучше "
"использовало вычислительные ресурсы многоядерных машин, вам рекомендуется "
"использовать :mod:`multiprocessing` или :class:`concurrent.futures."
"ProcessPoolExecutor`. Однако многопоточность по-прежнему является подходящей "
"моделью, если вы хотите одновременно выполнять несколько задач, связанных с "
"вводом-выводом."

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Этот модуль не работает или недоступен на платформах WebAssembly «wasm32-"
"emscripten» и «wasm32-wasi». См. :ref:`wasm-availability` для получения "
"дополнительной информации."

#: ../../library/threading.rst:50
msgid "This module defines the following functions:"
msgstr "Этот модуль определяет следующие функции:"

#: ../../library/threading.rst:55
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Возвращает количество живых объектов :class:`Thread`. Возвращаемое "
"количество равно длине списка, возвращаемого :func:`.enumerate`."

#: ../../library/threading.rst:58
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "Функция activeCount — устаревший псевдоним этой функции."

#: ../../library/threading.rst:63
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"Возвращает текущий объект :class:`Thread`, соответствующий потоку управления "
"вызывающего объекта. Если поток управления вызывающего объекта не был создан "
"с помощью модуля :mod:`threading`, возвращается фиктивный объект потока с "
"ограниченной функциональностью."

#: ../../library/threading.rst:68
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr "Функция currentThread является устаревшим псевдонимом этой функции."

#: ../../library/threading.rst:73
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "Обработка неперехваченного исключения, вызванного :func:`Thread.run`."

#: ../../library/threading.rst:75
msgid "The *args* argument has the following attributes:"
msgstr "Аргумент *args* имеет следующие атрибуты:"

#: ../../library/threading.rst:77
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: Тип исключения."

#: ../../library/threading.rst:78
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*: Значение исключения, может быть «Нет»."

#: ../../library/threading.rst:79
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: обратная трассировка исключений, может быть «Нет»."

#: ../../library/threading.rst:80
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*thread*: Поток, вызвавший исключение, может иметь значение «Нет»."

#: ../../library/threading.rst:82
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"Если *exc_type* имеет значение :exc:`SystemExit`, исключение игнорируется. В "
"противном случае исключение распечатывается в :data:`sys.stderr`."

#: ../../library/threading.rst:85
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""
"Если эта функция вызывает исключение, для его обработки вызывается :func:"
"`sys.excepthook`."

#: ../../library/threading.rst:88
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` можно переопределить, чтобы контролировать, как "
"обрабатываются неперехваченные исключения, вызванные :func:`Thread.run`."

#: ../../library/threading.rst:91
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr ""
"Сохранение *exc_value* с использованием специального перехватчика может "
"создать ссылочный цикл. Его следует очистить явно, чтобы прервать ссылочный "
"цикл, когда исключение больше не требуется."

#: ../../library/threading.rst:95
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"Сохранение *потока* с использованием пользовательского хука может воскресить "
"его, если он установлен на объект, который находится в стадии финализации. "
"Избегайте сохранения *thread* после завершения пользовательского "
"перехватчика, чтобы избежать воскрешения объектов."

#: ../../library/threading.rst:100
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` обрабатывает неперехваченные исключения."

#: ../../library/threading.rst:106
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"Содержит исходное значение :func:`threading.excepthook`. Он сохраняется для "
"того, чтобы можно было восстановить исходное значение в случае его замены "
"сломанными или альтернативными объектами."

#: ../../library/threading.rst:114
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Возвращает «идентификатор потока» текущего потока. Это ненулевое целое "
"число. Его значение не имеет прямого значения; он задуман как волшебный файл "
"cookie, который можно использовать, например, для индексации словаря данных, "
"специфичных для потока. Идентификаторы потоков могут быть переработаны при "
"выходе из потока и создании другого потока."

#: ../../library/threading.rst:125
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Возвращает собственный целочисленный идентификатор потока текущего потока, "
"назначенный ядром. Это неотрицательное целое число. Его значение может "
"использоваться для уникальной идентификации этого конкретного потока в "
"масштабе всей системы (до тех пор, пока поток не завершится, после чего "
"значение может быть повторно использовано ОС)."

#: ../../library/threading.rst:130
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX."
msgstr ""

#: ../../library/threading.rst:137
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""
"Возвращает список всех активных в данный момент объектов :class:`Thread`. В "
"список входят демонические потоки и фиктивные объекты потоков, созданные :"
"func:`current_thread`. Он исключает завершенные потоки и потоки, которые еще "
"не были запущены. Однако основной поток всегда является частью результата, "
"даже если он завершается."

#: ../../library/threading.rst:146
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Верните основной объект :class:`Thread`. В обычных условиях основным потоком "
"является поток, из которого был запущен интерпретатор Python."

#: ../../library/threading.rst:157
msgid ""
"Set a trace function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"Установите функцию трассировки для всех потоков, запущенных из модуля :mod:"
"`threading`. *func* будет передана в :func:`sys.settrace` для каждого потока "
"перед вызовом его метода :meth:`~Thread.run`."

#: ../../library/threading.rst:168
msgid "Get the trace function as set by :func:`settrace`."
msgstr "Получите функцию трассировки, установленную :func:`settrace`."

#: ../../library/threading.rst:177
msgid ""
"Set a profile function for all threads started from the :mod:`threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"Установите функцию профиля для всех потоков, запускаемых из модуля :mod:"
"`threading`. *func* будет передаваться в :func:`sys.setprofile` для каждого "
"потока перед вызовом его метода :meth:`~Thread.run`."

#: ../../library/threading.rst:186
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "Получите функцию профилировщика, установленную :func:`setprofile`."

#: ../../library/threading.rst:193
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Возвращает размер стека потоков, используемый при создании новых потоков. "
"Необязательный аргумент *size* указывает размер стека, который будет "
"использоваться для последующих создаваемых потоков, и должен быть равен 0 "
"(используйте платформу или настроенное по умолчанию) или положительному "
"целому значению не менее 32 768 (32 КиБ). Если *размер* не указан, "
"используется 0. Если изменение размера стека потока не поддерживается, "
"выдается ошибка :exc:`RuntimeError`. Если указанный размер стека "
"недействителен, возникает ошибка :exc:`ValueError` и размер стека не "
"изменяется. 32 КиБ в настоящее время является минимальным поддерживаемым "
"значением размера стека, гарантирующим достаточно места в стеке для самого "
"интерпретатора. Обратите внимание, что на некоторых платформах могут быть "
"особые ограничения на значения размера стека, например, требование "
"минимального размера стека> 32 КБ или требование выделения, кратного размеру "
"страницы системной памяти. Для получения дополнительной информации следует "
"обратиться к документации платформы (страницы 4 КБ). распространены; при "
"отсутствии более конкретной информации рекомендуется использовать размер "
"стека, кратный 4096)."

#: ../../library/threading.rst:208
msgid ":ref:`Availability <availability>`: Windows, pthreads."
msgstr ":ref:`Availability <availability>`: Windows, pthreads."

#: ../../library/threading.rst:210
msgid "Unix platforms with POSIX threads support."
msgstr "Платформы Unix с поддержкой потоков POSIX."

#: ../../library/threading.rst:213
msgid "This module also defines the following constant:"
msgstr "Этот модуль также определяет следующую константу:"

#: ../../library/threading.rst:217
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"Максимальное значение, допустимое для параметра *timeout* функций блокировки "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait` и т. "
"д.). Указание таймаута, превышающего это значение, вызовет ошибку :exc:"
"`OverflowError`."

#: ../../library/threading.rst:225
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"Этот модуль определяет ряд классов, которые подробно описаны в разделах ниже."

#: ../../library/threading.rst:228
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"Дизайн этого модуля во многом основан на модели потоков Java. Однако там, "
"где Java делает блокировки и условные переменные основным поведением каждого "
"объекта, в Python они являются отдельными объектами. Класс :class:`Thread` в "
"Python поддерживает подмножество поведения класса Thread в Java; в настоящее "
"время нет ни приоритетов, ни групп потоков, и потоки не могут быть "
"уничтожены, остановлены, приостановлены, возобновлены или прерваны. "
"Статические методы класса Java Java при реализации сопоставляются с "
"функциями уровня модуля."

#: ../../library/threading.rst:236
msgid "All of the methods described below are executed atomically."
msgstr "Все описанные ниже методы выполняются атомарно."

#: ../../library/threading.rst:240
msgid "Thread-Local Data"
msgstr "Локальные данные потока"

#: ../../library/threading.rst:242
msgid ""
"Thread-local data is data whose values are thread specific.  To manage "
"thread-local data, just create an instance of :class:`local` (or a subclass) "
"and store attributes on it::"
msgstr ""
"Локальные данные потока — это данные, значения которых зависят от потока. "
"Чтобы управлять локальными данными потока, просто создайте экземпляр :class:"
"`local` (или подкласс) и сохраните в нем атрибуты::"

#: ../../library/threading.rst:249
msgid "The instance's values will be different for separate threads."
msgstr "Значения экземпляра будут разными для отдельных потоков."

#: ../../library/threading.rst:254
msgid "A class that represents thread-local data."
msgstr "Класс, представляющий локальные данные потока."

#: ../../library/threading.rst:256
msgid ""
"For more details and extensive examples, see the documentation string of "
"the :mod:`!_threading_local` module: :source:`Lib/_threading_local.py`."
msgstr ""
"Более подробную информацию и подробные примеры см. в строке документации "
"модуля :mod:`!_threading_local`: :source:`Lib/_threading_local.py`."

#: ../../library/threading.rst:263
msgid "Thread Objects"
msgstr "Объекты потока"

#: ../../library/threading.rst:265
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the "
"``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""
"Класс :class:`Thread` представляет собой действие, которое выполняется в "
"отдельном потоке управления. Есть два способа указать действие: передать "
"вызываемый объект конструктору или переопределить метод :meth:`~Thread.run` "
"в подклассе. Никакие другие методы (кроме конструктора) не должны "
"переопределяться в подклассе. Другими словами, *только* переопределяются "
"методы ``__init__()`` и :meth:`~Thread.run` этого класса."

#: ../../library/threading.rst:272
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"После создания объекта потока его активность должна быть запущена путем "
"вызова метода потока :meth:`~Thread.start`. Это вызывает метод :meth:"
"`~Thread.run` в отдельном потоке управления."

#: ../../library/threading.rst:276
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"Как только активность потока начинается, поток считается «живым». Он "
"перестает быть активным, когда его метод :meth:`~Thread.run` завершается - "
"либо обычным способом, либо путем возникновения необработанного исключения. "
"Метод :meth:`~Thread.is_alive` проверяет, активен ли поток."

#: ../../library/threading.rst:281
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"Другие потоки могут вызывать метод потока :meth:`~Thread.join`. Это "
"блокирует вызывающий поток до тех пор, пока поток, чей метод :meth:`~Thread."
"join` не будет завершен, будет завершен."

#: ../../library/threading.rst:285
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"У потока есть имя. Имя можно передать конструктору, а также прочитать или "
"изменить с помощью атрибута :attr:`~Thread.name`."

#: ../../library/threading.rst:288
msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""
"Если метод :meth:`~Thread.run` вызывает исключение, для его обработки "
"вызывается :func:`threading.excepthook`. По умолчанию :func:`threading."
"excepthook` молча игнорирует :exc:`SystemExit`."

#: ../../library/threading.rst:292
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"Поток может быть помечен как «поток демона». Значение этого флага "
"заключается в том, что вся программа Python завершает работу, когда остаются "
"только потоки демона. Начальное значение наследуется от создающего потока. "
"Флаг можно установить с помощью свойства :attr:`~Thread.daemon` или "
"аргумента конструктора *daemon*."

#: ../../library/threading.rst:299
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"Потоки демона внезапно останавливаются при завершении работы. Их ресурсы "
"(такие как открытые файлы, транзакции базы данных и т. д.) могут не "
"освобождаться должным образом. Если вы хотите, чтобы ваши потоки корректно "
"останавливались, сделайте их недемоническими и используйте подходящий "
"механизм сигнализации, например :class:`Event`."

#: ../../library/threading.rst:304
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"Существует объект «основной поток»; это соответствует начальному потоку "
"управления в программе Python. Это не поток демона."

#: ../../library/threading.rst:307
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""
"Существует вероятность создания «фиктивных объектов потока». Это объекты "
"потоков, соответствующие «чужим потокам», которые представляют собой потоки "
"управления, запускаемые вне модуля потоков, например, непосредственно из "
"кода C. Объекты фиктивного потока имеют ограниченную функциональность; они "
"всегда считаются живыми и демоническими и не могут быть :ref:`присоединены к "
"<meth-thread-join>`. Они никогда не удаляются, так как невозможно обнаружить "
"завершение чужих потоков."

#: ../../library/threading.rst:318
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Этот конструктор всегда следует вызывать с ключевыми аргументами. Аргументы:"

#: ../../library/threading.rst:321
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:`!"
"ThreadGroup` class is implemented."
msgstr ""
"*group* должно быть ``None``; зарезервировано для будущего расширения при "
"реализации класса :class:`!ThreadGroup`."

#: ../../library/threading.rst:324
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* — это вызываемый объект, который будет вызываться методом :meth:"
"`run`. По умолчанию установлено значение None, что означает, что ничего не "
"вызывается."

#: ../../library/threading.rst:327
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*имя* — это имя потока. По умолчанию уникальное имя создается в форме "
"«Thread-*N*», где *N* — небольшое десятичное число, или «Thread-*N* (цель)», "
"где «цель» — это ``target.__name__` ` если указан аргумент *target*."

#: ../../library/threading.rst:332
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr ""
"*args* — это список или кортеж аргументов для целевого вызова. По умолчанию "
"``()``."

#: ../../library/threading.rst:334
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* — это словарь аргументов ключевых слов для целевого вызова. По "
"умолчанию ``{}``."

#: ../../library/threading.rst:337
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"Если не ``None``, *daemon* явно устанавливает, является ли поток "
"демоническим. Если «Нет» (по умолчанию), демоническое свойство наследуется "
"от текущего потока."

#: ../../library/threading.rst:341
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"Если подкласс переопределяет конструктор, он должен обязательно вызвать "
"конструктор базового класса (``Thread.__init__()``), прежде чем делать что-"
"либо еще с потоком."

#: ../../library/threading.rst:345
msgid "Added the *daemon* parameter."
msgstr "Добавлен параметр *daemon*."

#: ../../library/threading.rst:348
msgid "Use the *target* name if *name* argument is omitted."
msgstr "Используйте имя *target*, если аргумент *name* опущен."

#: ../../library/threading.rst:353
msgid "Start the thread's activity."
msgstr "Запустите активность потока."

#: ../../library/threading.rst:355
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Его необходимо вызывать не более одного раза для каждого объекта потока. Он "
"обеспечивает вызов метода :meth:`~Thread.run` объекта в отдельном потоке "
"управления."

#: ../../library/threading.rst:359
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"Этот метод вызовет ошибку :exc:`RuntimeError`, если он будет вызван более "
"одного раза для одного и того же объекта потока."

#: ../../library/threading.rst:364
msgid "Method representing the thread's activity."
msgstr "Метод, представляющий активность потока."

#: ../../library/threading.rst:366
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Вы можете переопределить этот метод в подклассе. Стандартный метод :meth:"
"`run` вызывает вызываемый объект, передаваемый конструктору объекта в "
"качестве аргумента *target*, если таковой имеется, с позиционными "
"аргументами и аргументами ключевого слова, взятыми из аргументов *args* и "
"*kwargs* соответственно."

#: ../../library/threading.rst:371
msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr ""
"Использование списка или кортежа в качестве аргумента *args*, передаваемого "
"в :class:`Thread`, может привести к такому же эффекту."

#: ../../library/threading.rst:374
msgid "Example::"
msgstr "Пример::"

#: ../../library/threading.rst:388
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Подождите, пока поток не завершится. Это блокирует вызывающий поток до тех "
"пор, пока поток, чей метод :meth:`~Thread.join` не завершится - либо "
"нормально, либо через необработанное исключение - или пока не наступит "
"необязательный тайм-аут."

#: ../../library/threading.rst:393
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""

#: ../../library/threading.rst:400
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Если аргумент *timeout* отсутствует или ``Нет``, операция будет "
"блокироваться до тех пор, пока поток не завершится."

#: ../../library/threading.rst:403
msgid "A thread can be joined many times."
msgstr "Поток можно объединять много раз."

#: ../../library/threading.rst:405
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` вызывает :exc:`RuntimeError`, если предпринимается "
"попытка присоединиться к текущему потоку, поскольку это может привести к "
"взаимоблокировке. Также ошибкой является :meth:`~Thread.join` потока до его "
"запуска, и попытки сделать это вызывают такое же исключение."

#: ../../library/threading.rst:412
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"Строка, используемая только в целях идентификации. Оно не имеет семантики. "
"Многим потокам может быть присвоено одно и то же имя. Первоначальное имя "
"задается конструктором."

#: ../../library/threading.rst:419
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"Устаревший API-интерфейс получения/установки для :attr:`~Thread.name`; "
"вместо этого используйте его непосредственно как свойство."

#: ../../library/threading.rst:426
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"«Идентификатор потока» этого потока или «Нет», если поток не был запущен. "
"Это ненулевое целое число. См. функцию :func:`get_ident`. Идентификаторы "
"потоков могут быть переработаны при выходе из потока и создании другого "
"потока. Идентификатор доступен даже после выхода из потока."

#: ../../library/threading.rst:434
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Идентификатор потока («TID») этого потока, назначенный ОС (ядром). Это "
"неотрицательное целое число или None, если поток не был запущен. См. "
"функцию :func:`get_native_id`. Это значение может использоваться для "
"уникальной идентификации этого конкретного потока в масштабе всей системы "
"(до тех пор, пока поток не завершится, после чего значение может быть "
"повторно использовано ОС)."

#: ../../library/threading.rst:443
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""
"Подобно идентификаторам процессов, идентификаторы потоков действительны "
"(гарантированно уникальны для всей системы) только с момента создания потока "
"до момента его завершения."

#: ../../library/threading.rst:447
msgid ""
":ref:`Availability <availability>`: Windows, FreeBSD, Linux, macOS, OpenBSD, "
"NetBSD, AIX, DragonFlyBSD."
msgstr ""

#: ../../library/threading.rst:453
msgid "Return whether the thread is alive."
msgstr "Возвращает, жив ли поток."

#: ../../library/threading.rst:455
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Этот метод возвращает True непосредственно перед запуском метода :meth:"
"`~Thread.run` и до тех пор, пока метод :meth:`~Thread.run` не завершится. "
"Функция модуля :func:`.enumerate` возвращает список всех активных потоков."

#: ../../library/threading.rst:461
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""
"Логическое значение, указывающее, является ли этот поток потоком демона "
"(«True») или нет («False»). Это должно быть установлено до вызова :meth:"
"`~Thread.start`, в противном случае будет вызвано :exc:`RuntimeError`. Его "
"начальное значение наследуется от создающего потока; основной поток не "
"является потоком демона, и поэтому все потоки, созданные в основном потоке, "
"по умолчанию имеют значение :attr:`~Thread.daemon` = ``False``."

#: ../../library/threading.rst:468
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"Вся программа Python завершается, когда не остается живых потоков, не "
"являющихся демонами."

#: ../../library/threading.rst:473
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""
"Устаревший API-интерфейс получения/установки для :attr:`~Thread.daemon`; "
"вместо этого используйте его непосредственно как свойство."

#: ../../library/threading.rst:482
msgid "Lock Objects"
msgstr "Блокировка объектов"

#: ../../library/threading.rst:484
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"Примитивная блокировка — это примитив синхронизации, который в "
"заблокированном состоянии не принадлежит конкретному потоку. В Python на "
"данный момент это примитив синхронизации самого низкого уровня, реализуемый "
"непосредственно модулем расширения :mod:`_thread`."

#: ../../library/threading.rst:489
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"Примитивная блокировка находится в одном из двух состояний: «заблокировано» "
"или «разблокировано». Он создается в разблокированном состоянии. Он имеет "
"два основных метода: :meth:`~Lock.acquire` и :meth:`~Lock.release`. Когда "
"состояние разблокировано, :meth:`~Lock.acquire` меняет состояние на "
"заблокированное и немедленно возвращается. Когда состояние заблокировано, :"
"meth:`~Lock.acquire` блокируется до тех пор, пока вызов :meth:`~Lock."
"release` в другом потоке не изменит его на разблокированное, затем вызов :"
"meth:`~Lock.acquire` сбрасывается он заблокирован и возвращается. Метод :"
"meth:`~Lock.release` следует вызывать только в заблокированном состоянии; он "
"меняет состояние на разблокированное и немедленно возвращается. Если будет "
"предпринята попытка снять разблокированную блокировку, будет выдано "
"сообщение :exc:`RuntimeError`."

#: ../../library/threading.rst:500
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Блокировки также поддерживают протокол управления контекстом <with-locks>."

#: ../../library/threading.rst:502
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"Если в :meth:`~Lock.acquire` заблокировано более одного потока, ожидающего "
"перехода состояния в разблокированное, только один поток продолжит работу, "
"когда вызов :meth:`~Lock.release` сбрасывает состояние на разблокированное; "
"какой из ожидающих потоков продолжит работу, не определено и может "
"различаться в зависимости от реализации."

#: ../../library/threading.rst:507
msgid "All methods are executed atomically."
msgstr "Все методы выполняются атомарно."

#: ../../library/threading.rst:512
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"Класс, реализующий примитивные объекты блокировки. Как только поток получил "
"блокировку, последующие попытки получить ее блокируются до тех пор, пока она "
"не будет снята; любой поток может освободить его."

#: ../../library/threading.rst:516
msgid ""
"Note that ``Lock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete Lock class that is supported "
"by the platform."
msgstr ""
"Обратите внимание, что Lock на самом деле является фабричной функцией, "
"которая возвращает экземпляр наиболее эффективной версии конкретного класса "
"Lock, поддерживаемого платформой."

#: ../../library/threading.rst:523 ../../library/threading.rst:603
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Приобретите блокировку"

#: ../../library/threading.rst:525
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"При вызове с аргументом *blocking*, установленным в ``True`` (по умолчанию), "
"блокируется до тех пор, пока блокировка не будет разблокирована, затем "
"установите ее в значение locked и верните ``True``."

#: ../../library/threading.rst:528
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"При вызове с аргументом *blocking*, установленным в значение False, не "
"блокировать. Если вызов с *blocking*, установленным на ``True``, будет "
"заблокирован, немедленно верните ``False``; в противном случае установите "
"блокировку на заблокированную и верните ``True``."

#: ../../library/threading.rst:532
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"При вызове с аргументом *timeout* с плавающей запятой, установленным в "
"положительное значение, блокируется не более чем на количество секунд, "
"указанное в *timeout*, и до тех пор, пока блокировка не может быть получена. "
"Аргумент *timeout* со значением ``-1`` указывает неограниченное ожидание. "
"Запрещено указывать *таймаут*, если *blocking* имеет значение «False»."

#: ../../library/threading.rst:538
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"Возвращаемое значение — «True», если блокировка получена успешно, и «False», "
"если нет (например, если истекло *тайм-аут*)."

#: ../../library/threading.rst:541 ../../library/threading.rst:625
#: ../../library/threading.rst:872
msgid "The *timeout* parameter is new."
msgstr "Параметр *timeout* является новым."

#: ../../library/threading.rst:544
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""
"Получение блокировки теперь может быть прервано сигналами POSIX, если "
"базовая реализация потоков поддерживает это."

#: ../../library/threading.rst:551
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"Снимите замок. Это можно вызвать из любого потока, а не только из потока, "
"получившего блокировку."

#: ../../library/threading.rst:554
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"Когда замок заблокирован, сбросьте его на разблокированный и вернитесь. Если "
"какие-либо другие потоки заблокированы в ожидании разблокировки блокировки, "
"разрешите продолжить работу только одному из них."

#: ../../library/threading.rst:558
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"При вызове разблокированной блокировки возникает ошибка :exc:`RuntimeError`."

#: ../../library/threading.rst:560 ../../library/threading.rst:641
msgid "There is no return value."
msgstr "Возвращаемого значения нет."

#: ../../library/threading.rst:564
msgid "Return ``True`` if the lock is acquired."
msgstr "Верните True, если блокировка получена."

#: ../../library/threading.rst:571
msgid "RLock Objects"
msgstr "Объекты RLock"

#: ../../library/threading.rst:573
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"Реентерабельная блокировка — это примитив синхронизации, который может быть "
"получен несколько раз одним и тем же потоком. Внутри он использует концепции "
"«владения потоком» и «уровня рекурсии» в дополнение к состоянию блокировки/"
"разблокировки, используемому примитивными блокировками. В заблокированном "
"состоянии блокировкой владеет какой-то поток; в разблокированном состоянии "
"им не владеет ни один поток."

#: ../../library/threading.rst:579
msgid ""
"To lock the lock, a thread calls its :meth:`~RLock.acquire` method; this "
"returns once the thread owns the lock.  To unlock the lock, a thread calls "
"its :meth:`~Lock.release` method. :meth:`~Lock.acquire`/:meth:`~Lock."
"release` call pairs may be nested; only the final :meth:`~Lock.release` "
"(the :meth:`~Lock.release` of the outermost pair) resets the lock to "
"unlocked and allows another thread blocked in :meth:`~Lock.acquire` to "
"proceed."
msgstr ""

#: ../../library/threading.rst:586
msgid ""
"Reentrant locks also support the :ref:`context management protocol <with-"
"locks>`."
msgstr ""

#: ../../library/threading.rst:591
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"Этот класс реализует объекты реентерабельной блокировки. Повторная "
"блокировка должна быть снята потоком, который ее приобрел. Как только поток "
"получил реентерабельную блокировку, тот же поток может получить ее снова без "
"блокировки; поток должен освободить его один раз за каждый раз, когда он его "
"завладел."

#: ../../library/threading.rst:596
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"Обратите внимание, что RLock на самом деле является фабричной функцией, "
"которая возвращает экземпляр наиболее эффективной версии конкретного класса "
"RLock, поддерживаемого платформой."

#: ../../library/threading.rst:605
msgid ""
"When invoked without arguments: if this thread already owns the lock, "
"increment the recursion level by one, and return immediately.  Otherwise, if "
"another thread owns the lock, block until the lock is unlocked.  Once the "
"lock is unlocked (not owned by any thread), then grab ownership, set the "
"recursion level to one, and return.  If more than one thread is blocked "
"waiting until the lock is unlocked, only one at a time will be able to grab "
"ownership of the lock. There is no return value in this case."
msgstr ""

#: ../../library/threading.rst:613
msgid ""
"When invoked with the *blocking* argument set to ``True``, do the same thing "
"as when called without arguments, and return ``True``."
msgstr ""

#: ../../library/threading.rst:616
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block.  "
"If a call without an argument would block, return ``False`` immediately; "
"otherwise, do the same thing as when called without arguments, and return "
"``True``."
msgstr ""

#: ../../library/threading.rst:620
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  Return ``True`` if the lock has been "
"acquired, ``False`` if the timeout has elapsed."
msgstr ""

#: ../../library/threading.rst:631
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"Снимите блокировку, уменьшив уровень рекурсии. Если после декремента он "
"равен нулю, сбросьте блокировку на разблокированную (не принадлежащую какому-"
"либо потоку), и если какие-либо другие потоки заблокированы в ожидании "
"разблокировки блокировки, разрешите продолжить работу ровно одному из них. "
"Если после уменьшения уровень рекурсии все еще не равен нулю, блокировка "
"остается заблокированной и принадлежит вызывающему потоку."

#: ../../library/threading.rst:637
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is unlocked."
msgstr ""

#: ../../library/threading.rst:647
msgid "Condition Objects"
msgstr "Объекты состояния"

#: ../../library/threading.rst:649
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"Условная переменная всегда связана с какой-либо блокировкой; его можно "
"передать или он будет создан по умолчанию. Передача одной из них полезна, "
"когда несколько условных переменных должны использовать одну и ту же "
"блокировку. Блокировка является частью объекта условия: ее не нужно "
"отслеживать отдельно."

#: ../../library/threading.rst:654
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"Условная переменная подчиняется протоколу управления контекстом <with-"
"locks>: использование оператора with позволяет получить связанную блокировку "
"на время существования вложенного блока. Методы :meth:`~Condition.acquire` "
"и :meth:`~Condition.release` также вызывают соответствующие методы связанной "
"блокировки."

#: ../../library/threading.rst:660
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"Другие методы должны вызываться с удержанием соответствующей блокировки. "
"Метод :meth:`~Condition.wait` снимает блокировку, а затем блокируется до тех "
"пор, пока другой поток не разбудит его, вызвав :meth:`~Condition.notify` "
"или :meth:`~Condition.notify_all`. Проснувшись, :meth:`~Condition.wait` "
"повторно захватывает блокировку и возвращается. Также можно указать таймаут."

#: ../../library/threading.rst:666
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
"Метод :meth:`~Condition.notify` пробуждает один из потоков, ожидающих "
"условную переменную, если таковые имеются. Метод :meth:`~Condition."
"notify_all` пробуждает все потоки, ожидающие условной переменной."

#: ../../library/threading.rst:670
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"Примечание: методы :meth:`~Condition.notify` и :meth:`~Condition.notify_all` "
"не снимают блокировку; это означает, что пробудившийся поток или потоки не "
"вернутся из своего вызова :meth:`~Condition.wait` немедленно, а только "
"тогда, когда поток, вызвавший :meth:`~Condition.notify` или :meth:"
"`~Condition.notify_all ` наконец отказывается от владения замком."

#: ../../library/threading.rst:676
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"Типичный стиль программирования с использованием условных переменных "
"использует блокировку для синхронизации доступа к некоторому общему "
"состоянию; потоки, которые заинтересованы в конкретном изменении состояния, "
"повторно вызывают :meth:`~Condition.wait`, пока не увидят желаемое "
"состояние, а потоки, которые изменяют состояние, вызывают :meth:`~Condition."
"notify` или :meth:`~ Condition.notify_all`, когда они меняют состояние таким "
"образом, чтобы оно могло быть желаемым для одного из официантов. Например, "
"следующий код представляет собой общую ситуацию производитель-потребитель с "
"неограниченной емкостью буфера:"

#: ../../library/threading.rst:696
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"Цикл while проверяет состояние приложения, поскольку :meth:`~Condition.wait` "
"может вернуться через произвольное долгое время, а условие, вызвавшее вызов :"
"meth:`~Condition.notify`, может отсутствовать. дольше оставаться верным. Это "
"свойственно многопоточному программированию. Метод :meth:`~Condition."
"wait_for` можно использовать для автоматизации проверки условий и упрощает "
"вычисление таймаутов:"

#: ../../library/threading.rst:708
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
"Чтобы выбрать между :meth:`~Condition.notify` и :meth:`~Condition."
"notify_all`, подумайте, может ли одно изменение состояния быть интересным "
"только для одного или нескольких ожидающих потоков. Например, в типичной "
"ситуации производитель-потребитель добавление одного элемента в буфер "
"требует пробуждения только одного потока-потребителя."

#: ../../library/threading.rst:716
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""
"Этот класс реализует объекты переменных состояния. Условная переменная "
"позволяет одному или нескольким потокам ждать, пока они не будут уведомлены "
"другим потоком."

#: ../../library/threading.rst:719
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"Если задан аргумент *lock*, а не ``None``, это должен быть объект :class:"
"`Lock` или :class:`RLock`, и он используется в качестве базовой блокировки. "
"В противном случае создается новый объект :class:`RLock` и используется в "
"качестве базовой блокировки."

#: ../../library/threading.rst:723 ../../library/threading.rst:847
#: ../../library/threading.rst:893 ../../library/threading.rst:945
#: ../../library/threading.rst:1013
msgid "changed from a factory function to a class."
msgstr "изменилась с фабричной функции на класс."

#: ../../library/threading.rst:728
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"Получите базовый замок. Этот метод вызывает соответствующий метод базовой "
"блокировки; возвращаемое значение — это все, что возвращает этот метод."

#: ../../library/threading.rst:733
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"Снимите основной замок. Этот метод вызывает соответствующий метод базовой "
"блокировки; нет возвращаемого значения."

#: ../../library/threading.rst:738
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"Дождитесь уведомления или истечения времени ожидания. Если вызывающий поток "
"не получил блокировку при вызове этого метода, возникает ошибка :exc:"
"`RuntimeError`."

#: ../../library/threading.rst:742
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"Этот метод снимает базовую блокировку, а затем блокируется до тех пор, пока "
"она не будет разбужена вызовом :meth:`notify` или :meth:`notify_all` для той "
"же переменной условия в другом потоке или до тех пор, пока не наступит "
"необязательный тайм-аут. После пробуждения или истечения времени ожидания он "
"повторно захватывает блокировку и возвращается."

#: ../../library/threading.rst:747
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""

#: ../../library/threading.rst:751
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"Когда базовой блокировкой является :class:`RLock`, она не освобождается с "
"помощью метода :meth:`release`, поскольку это может фактически не "
"разблокировать блокировку, если она была получена несколько раз рекурсивно. "
"Вместо этого используется внутренний интерфейс класса :class:`RLock`, "
"который действительно разблокирует его, даже если он был рекурсивно получен "
"несколько раз. Затем используется другой внутренний интерфейс для "
"восстановления уровня рекурсии при повторном получении блокировки."

#: ../../library/threading.rst:759
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""
"Возвращаемым значением является ``True``, если не истек заданный *timeout*, "
"в этом случае оно равно ``False``."

#: ../../library/threading.rst:762 ../../library/threading.rst:978
msgid "Previously, the method always returned ``None``."
msgstr "Раньше метод всегда возвращал None."

#: ../../library/threading.rst:767
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"Подождите, пока условие не станет истинным. *predicate* должен быть "
"вызываемым объектом, результат которого будет интерпретироваться как "
"логическое значение. Может быть предоставлен *тайм-аут*, дающий максимальное "
"время ожидания."

#: ../../library/threading.rst:771
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"Этот служебный метод может вызывать :meth:`wait` повторно, пока предикат не "
"будет удовлетворен или пока не истечет время ожидания. Возвращаемое значение "
"является последним возвращаемым значением предиката и будет иметь значение "
"False, если время ожидания метода истекло."

#: ../../library/threading.rst:776
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"Игнорируя функцию таймаута, вызов этого метода примерно эквивалентен "
"написанию::"

#: ../../library/threading.rst:782
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"Следовательно, применяются те же правила, что и в случае с :meth:`wait`: "
"блокировка должна удерживаться при вызове и повторно захватываться при "
"возврате. Предикат оценивается с удержанной блокировкой."

#: ../../library/threading.rst:790
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"По умолчанию пробуждается один поток, ожидающий этого условия, если таковой "
"имеется. Если вызывающий поток не получил блокировку при вызове этого "
"метода, возникает ошибка :exc:`RuntimeError`."

#: ../../library/threading.rst:794
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"Этот метод пробуждает не более *n* потоков, ожидающих условную переменную; "
"это пустая операция, если ни один поток не ожидает."

#: ../../library/threading.rst:797
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"Текущая реализация пробуждает ровно *n* потоков, если хотя бы *n* потоков "
"ожидают. Однако полагаться на такое поведение небезопасно. Будущая "
"оптимизированная реализация может иногда активировать более *n* потоков."

#: ../../library/threading.rst:802
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"Примечание: пробудившийся поток фактически не возвращается из своего вызова :"
"meth:`wait` до тех пор, пока не сможет повторно получить блокировку. "
"Поскольку :meth:`notify` не снимает блокировку, это должен сделать "
"вызывающий объект."

#: ../../library/threading.rst:808
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Разбудите все потоки, ожидающие выполнения этого условия. Этот метод "
"действует как :meth:`notify`, но пробуждает все ожидающие потоки вместо "
"одного. Если вызывающий поток не получил блокировку при вызове этого метода, "
"возникает ошибка :exc:`RuntimeError`."

#: ../../library/threading.rst:813
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "Метод notifyAll — устаревший псевдоним этого метода."

#: ../../library/threading.rst:819
msgid "Semaphore Objects"
msgstr "Семафорные объекты"

#: ../../library/threading.rst:821
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"Это один из старейших примитивов синхронизации в истории информатики, "
"изобретенный одним из первых голландских ученых-компьютерщиков Эдсгером В. "
"Дейкстрой (он использовал имена ``P()`` и ``V()`` вместо :meth. :`~Semaphore."
"acquire` и :meth:`~Semaphore.release`)."

#: ../../library/threading.rst:826
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"Семафор управляет внутренним счетчиком, который уменьшается при каждом "
"вызове :meth:`~Semaphore.acquire` и увеличивается при каждом вызове :meth:"
"`~Semaphore.release`. Счетчик никогда не может опуститься ниже нуля; когда :"
"meth:`~Semaphore.acquire` обнаруживает, что оно равно нулю, он блокируется, "
"ожидая, пока какой-нибудь другой поток не вызовет :meth:`~Semaphore.release`."

#: ../../library/threading.rst:832
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Семафоры также поддерживают протокол управления контекстом <with-locks>."

#: ../../library/threading.rst:837
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""
"Этот класс реализует объекты-семафоры. Семафор управляет атомарным "
"счетчиком, представляющим количество вызовов :meth:`release` минус "
"количество вызовов :meth:`acquire` и начальное значение. При необходимости "
"метод :meth:`acquire` блокируется до тех пор, пока он не сможет вернуться, "
"не делая счетчик отрицательным. Если не указано, *значение* по умолчанию "
"равно 1."

#: ../../library/threading.rst:843
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"Необязательный аргумент дает начальное *значение* внутреннего счетчика; по "
"умолчанию он равен ``1``. Если заданное *значение* меньше 0, возникает :exc:"
"`ValueError`."

#: ../../library/threading.rst:852
msgid "Acquire a semaphore."
msgstr "Приобретите семафор."

#: ../../library/threading.rst:854
msgid "When invoked without arguments:"
msgstr "При вызове без аргументов:"

#: ../../library/threading.rst:856
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""
"Если внутренний счетчик при вводе больше нуля, уменьшите его на единицу и "
"немедленно верните True."

#: ../../library/threading.rst:858
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"Если внутренний счетчик при входе равен нулю, блокируйте его до тех пор, "
"пока его не разбудит вызов :meth:`~Semaphore.release`. После пробуждения (и "
"счетчик больше 0) уменьшите счетчик на 1 и верните «True». Ровно один поток "
"будет пробуждаться при каждом вызове :meth:`~Semaphore.release`. Не следует "
"полагаться на порядок пробуждения потоков."

#: ../../library/threading.rst:864
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""
"При вызове с параметром *blocking*, установленным на «False», не "
"блокировать. Если вызов без аргумента будет заблокирован, немедленно верните "
"``False``; в противном случае сделайте то же самое, что и при вызове без "
"аргументов, и верните ``True``."

#: ../../library/threading.rst:868
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"При вызове с *таймаутом*, отличным от «Нет», он будет блокироваться не более "
"чем на *таймаут* секунд. Если получение не завершится успешно в этом "
"интервале, верните ``False``. В противном случае верните ``True``."

#: ../../library/threading.rst:877
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""
"Освободите семафор, увеличив внутренний счетчик на *n*. Когда при входе оно "
"было нулевым, а другие потоки ждут, пока оно снова станет больше нуля, "
"пробуждается *n* этих потоков."

#: ../../library/threading.rst:881
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""
"Добавлен параметр *n* для одновременного освобождения нескольких ожидающих "
"потоков."

#: ../../library/threading.rst:887
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"Класс, реализующий ограниченные объекты-семафоры. Ограниченный семафор "
"проверяет, не превышает ли его текущее значение начальное значение. Если да, "
"то возникает :exc:`ValueError`. В большинстве ситуаций семафоры используются "
"для защиты ресурсов с ограниченной емкостью. Если семафор выпускается "
"слишком много раз, это признак ошибки. Если не указано, *значение* по "
"умолчанию равно 1."

#: ../../library/threading.rst:900
msgid ":class:`Semaphore` Example"
msgstr "Пример :class:`Semaphore`"

#: ../../library/threading.rst:902
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"Семафоры часто используются для защиты ресурсов с ограниченной емкостью, "
"например сервера базы данных. В любой ситуации, когда размер ресурса "
"фиксирован, следует использовать ограниченный семафор. Прежде чем создавать "
"какие-либо рабочие потоки, ваш основной поток инициализирует семафор::"

#: ../../library/threading.rst:911
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"После создания рабочие потоки вызывают методы получения и выпуска семафора, "
"когда им необходимо подключиться к серверу:"

#: ../../library/threading.rst:921
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"Использование ограниченного семафора снижает вероятность того, что "
"программная ошибка, из-за которой семафор высвобождается больше, чем "
"получается, останется незамеченной."

#: ../../library/threading.rst:928
msgid "Event Objects"
msgstr "Объекты событий"

#: ../../library/threading.rst:930
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"Это один из простейших механизмов связи между потоками: один поток "
"сигнализирует о событии, а другие потоки ждут его."

#: ../../library/threading.rst:933
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"Объект события управляет внутренним флагом, которому можно установить "
"значение true с помощью метода :meth:`~Event.set` и сбросить значение false "
"с помощью метода :meth:`~Event.clear`. Метод :meth:`~Event.wait` блокируется "
"до тех пор, пока флаг не станет истинным."

#: ../../library/threading.rst:940
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"Класс, реализующий объекты событий. Событие управляет флагом, которому можно "
"установить значение true с помощью метода :meth:`~Event.set` и сбросить "
"значение false с помощью метода :meth:`clear`. Метод :meth:`wait` "
"блокируется до тех пор, пока флаг не станет истинным. Флаг изначально ложный."

#: ../../library/threading.rst:950
msgid "Return ``True`` if and only if the internal flag is true."
msgstr ""
"Возвращайте ``True`` тогда и только тогда, когда внутренний флаг равен true."

#: ../../library/threading.rst:952
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "Метод isSet является устаревшим псевдонимом этого метода."

#: ../../library/threading.rst:956
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"Установите внутренний флаг в значение true. Все потоки, ожидающие, пока это "
"станет правдой, пробуждаются. Потоки, которые вызывают :meth:`wait`, как "
"только флаг станет истинным, вообще не будут блокироваться."

#: ../../library/threading.rst:962
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"Сбросьте внутренний флаг на false. Впоследствии потоки, вызывающие :meth:"
"`wait`, будут блокироваться до тех пор, пока не будет вызван :meth:`.set`, "
"чтобы снова установить внутренний флаг в значение true."

#: ../../library/threading.rst:968
msgid ""
"Block as long as the internal flag is false and the timeout, if given, has "
"not expired. The return value represents the reason that this blocking "
"method returned; ``True`` if returning because the internal flag is set to "
"true, or ``False`` if a timeout is given and the the internal flag did not "
"become true within the given wait time."
msgstr ""

#: ../../library/threading.rst:974
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating point number specifying a timeout for the operation in seconds, or "
"fractions thereof."
msgstr ""

#: ../../library/threading.rst:985
msgid "Timer Objects"
msgstr "Объекты таймера"

#: ../../library/threading.rst:987
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"Этот класс представляет действие, которое должно выполняться только по "
"истечении определенного времени — таймера. :class:`Timer` является "
"подклассом :class:`Thread` и поэтому также служит примером создания "
"пользовательских потоков."

#: ../../library/threading.rst:991
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""
"Таймеры запускаются, как и потоки, вызовом их метода :meth:`Timer.start "
"<Thread.start>`. Таймер можно остановить (до начала его действия), вызвав "
"метод :meth:`~Timer.cancel`. Интервал, который таймер будет ждать перед "
"выполнением своего действия, может не совпадать с интервалом, указанным "
"пользователем."

#: ../../library/threading.rst:997
msgid "For example::"
msgstr "Например::"

#: ../../library/threading.rst:1008
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"Создайте таймер, который будет запускать *функцию* с аргументами *args* и "
"аргументами ключевого слова *kwargs* по истечении *интервала* секунд. Если "
"*args* имеет значение «None» (по умолчанию), то будет использоваться пустой "
"список. Если *kwargs* имеет значение «None» (по умолчанию), то будет "
"использоваться пустой словарь."

#: ../../library/threading.rst:1018
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"Остановите таймер и отмените выполнение действия таймера. Это будет работать "
"только в том случае, если таймер все еще находится в стадии ожидания."

#: ../../library/threading.rst:1023
msgid "Barrier Objects"
msgstr "Барьерные объекты"

#: ../../library/threading.rst:1027
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"Этот класс предоставляет простой примитив синхронизации для использования "
"фиксированным количеством потоков, которым необходимо ждать друг друга. "
"Каждый из потоков пытается преодолеть барьер, вызывая метод :meth:`~Barrier."
"wait`, и будет блокироваться до тех пор, пока все потоки не выполнят свои "
"вызовы :meth:`~Barrier.wait`. На этом этапе потоки освобождаются "
"одновременно."

#: ../../library/threading.rst:1033
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""
"Барьер можно использовать повторно любое количество раз для одного и того же "
"количества потоков."

#: ../../library/threading.rst:1035
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"В качестве примера, вот простой способ синхронизации потока клиента и "
"сервера:"

#: ../../library/threading.rst:1055
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"Создайте объект-барьер для количества *сторон* потоков. *Действие*, если оно "
"предусмотрено, представляет собой вызываемый объект, который будет "
"вызываться одним из потоков при их освобождении. *timeout* — это значение "
"таймаута по умолчанию, если для метода :meth:`wait` ничего не указано."

#: ../../library/threading.rst:1062
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"Пройдите барьер. Когда все потоки, участвующие в барьере, вызвали эту "
"функцию, все они освобождаются одновременно. Если указан *тайм-аут*, он "
"используется вместо любого, который был указан в конструкторе класса."

#: ../../library/threading.rst:1067
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"Возвращаемое значение — целое число в диапазоне от 0 до *party* -- 1, разное "
"для каждого потока. Это можно использовать для выбора потока для выполнения "
"какой-то специальной работы, например:"

#: ../../library/threading.rst:1076
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"Если конструктору было предоставлено *действие*, один из потоков вызовет его "
"до освобождения. Если этот вызов вызовет ошибку, барьер переводится в "
"сломанное состояние."

#: ../../library/threading.rst:1080
msgid "If the call times out, the barrier is put into the broken state."
msgstr "Если время вызова истекло, барьер переводится в сломанное состояние."

#: ../../library/threading.rst:1082
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""
"Этот метод может вызвать исключение :class:`BrokenBarrierError`, если барьер "
"нарушен или сброшен во время ожидания потока."

#: ../../library/threading.rst:1087
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Верните барьер в пустое состояние по умолчанию. Любые потоки, ожидающие "
"этого, получат исключение :class:`BrokenBarrierError`."

#: ../../library/threading.rst:1090
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""
"Обратите внимание, что использование этой функции может потребовать "
"некоторой внешней синхронизации, если существуют другие потоки, состояние "
"которых неизвестно. Если барьер разрушен, возможно, лучше просто оставить "
"его и создать новый."

#: ../../library/threading.rst:1096
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"Приведите барьер в сломанное состояние. Это приводит к сбою любых активных "
"или будущих вызовов :meth:`wait` с :class:`BrokenBarrierError`. Используйте "
"это, например, если один из потоков необходимо прервать, чтобы избежать "
"блокировки приложения."

#: ../../library/threading.rst:1101
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"Возможно, предпочтительнее просто создать барьер с разумным значением "
"*timeout*, чтобы автоматически защититься от сбоя в работе одного из потоков."

#: ../../library/threading.rst:1107
msgid "The number of threads required to pass the barrier."
msgstr "Число потоков, необходимое для прохождения барьера."

#: ../../library/threading.rst:1111
msgid "The number of threads currently waiting in the barrier."
msgstr "Число потоков, ожидающих в данный момент в барьере."

#: ../../library/threading.rst:1115
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""
"Логическое значение, имеющее значение «Истина», если барьер находится в "
"разрушенном состоянии."

#: ../../library/threading.rst:1120
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Это исключение, подкласс :exc:`RuntimeError`, возникает, когда объект :class:"
"`Barrier` сбрасывается или разрушается."

#: ../../library/threading.rst:1127
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr ""
"Использование блокировок, условий и семафоров в операторе :keyword:`!with`"

#: ../../library/threading.rst:1129
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered, "
"and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""
"Все объекты, предоставляемые этим модулем и имеющие методы acquire и "
"Release, могут использоваться в качестве менеджеров контекста для оператора :"
"keyword:`with`. Метод acquire будет вызываться при входе в блок, а метод "
"Release будет вызываться при выходе из блока. Следовательно, следующий "
"фрагмент:"

#: ../../library/threading.rst:1138
msgid "is equivalent to::"
msgstr "эквивалентно::"

#: ../../library/threading.rst:1146
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"В настоящее время объекты :class:`Lock`, :class:`RLock`, :class:"
"`Condition`, :class:`Semaphore` и :class:`BoundedSemaphore` могут "
"использоваться в качестве контекста оператора :keyword:`with`. менеджеры."

#: ../../library/threading.rst:155 ../../library/threading.rst:164
msgid "trace function"
msgstr "trace function"

#: ../../library/threading.rst:164
msgid "debugger"
msgstr "debugger"

#: ../../library/threading.rst:175 ../../library/threading.rst:184
msgid "profile function"
msgstr "profile function"
