# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:49+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/email.policy.rst:2
msgid ":mod:`!email.policy`: Policy Objects"
msgstr ":mod:`!email.policy`: Объекты политики"

#: ../../library/email.policy.rst:12
msgid "**Source code:** :source:`Lib/email/policy.py`"
msgstr "**Исходный код:** :source:`Lib/email/policy.py`"

#: ../../library/email.policy.rst:16
msgid ""
"The :mod:`email` package's prime focus is the handling of email messages as "
"described by the various email and MIME RFCs.  However, the general format "
"of email messages (a block of header fields each consisting of a name "
"followed by a colon followed by a value, the whole block followed by a blank "
"line and an arbitrary 'body'), is a format that has found utility outside of "
"the realm of email.  Some of these uses conform fairly closely to the main "
"email RFCs, some do not.  Even when working with email, there are times when "
"it is desirable to break strict compliance with the RFCs, such as generating "
"emails that interoperate with email servers that do not themselves follow "
"the standards, or that implement extensions you want to use in ways that "
"violate the standards."
msgstr ""
"Основное внимание пакета :mod:`email` уделяется обработке сообщений "
"электронной почты, как описано в различных RFC по электронной почте и MIME. "
"Однако общий формат сообщений электронной почты (блок полей заголовка, "
"каждое из которых состоит из имени, за которым следует двоеточие, за которым "
"следует значение, весь блок, за которым следует пустая строка и произвольное "
"«тело») — это формат, который нашел утилита за пределами электронной почты. "
"Некоторые из этих вариантов использования довольно близко соответствуют "
"основным RFC для электронной почты, некоторые — нет. Даже при работе с "
"электронной почтой бывают случаи, когда желательно нарушить строгое "
"соответствие RFC, например, создавать электронные письма, взаимодействующие "
"с почтовыми серверами, которые сами не соответствуют стандартам, или которые "
"реализуют расширения, которые вы хотите использовать, способами, нарушающими "
"их. стандарты."

#: ../../library/email.policy.rst:28
msgid ""
"Policy objects give the email package the flexibility to handle all these "
"disparate use cases."
msgstr ""
"Объекты политики дают пакету электронной почты гибкость для обработки всех "
"этих несопоставимых вариантов использования."

#: ../../library/email.policy.rst:31
msgid ""
"A :class:`Policy` object encapsulates a set of attributes and methods that "
"control the behavior of various components of the email package during use. :"
"class:`Policy` instances can be passed to various classes and methods in the "
"email package to alter the default behavior.  The settable values and their "
"defaults are described below."
msgstr ""
"Объект :class:`Policy` инкапсулирует набор атрибутов и методов, которые "
"управляют поведением различных компонентов пакета электронной почты во время "
"использования. Экземпляры :class:`Policy` можно передавать различным классам "
"и методам в пакете электронной почты, чтобы изменить поведение по умолчанию. "
"Настраиваемые значения и их значения по умолчанию описаны ниже."

#: ../../library/email.policy.rst:37
msgid ""
"There is a default policy used by all classes in the email package.  For all "
"of the :mod:`~email.parser` classes and the related convenience functions, "
"and for the :class:`~email.message.Message` class, this is the :class:"
"`Compat32` policy, via its corresponding pre-defined instance :const:"
"`compat32`.  This policy provides for complete backward compatibility (in "
"some cases, including bug compatibility) with the pre-Python3.3 version of "
"the email package."
msgstr ""
"Существует политика по умолчанию, используемая всеми классами в пакете "
"электронной почты. Для всех классов :mod:`~email.parser` и связанных с ними "
"удобных функций, а также для класса :class:`~email.message.Message` это "
"политика :class:`Compat32` через соответствующую предопределенный экземпляр :"
"const:`compat32`. Эта политика обеспечивает полную обратную совместимость (в "
"некоторых случаях, включая совместимость ошибок) с версией пакета "
"электронной почты до Python3.3."

#: ../../library/email.policy.rst:44
msgid ""
"This default value for the *policy* keyword to :class:`~email.message."
"EmailMessage` is the :class:`EmailPolicy` policy, via its pre-defined "
"instance :data:`~default`."
msgstr ""
"Это значение по умолчанию для ключевого слова *policy* для :class:`~email."
"message.EmailMessage` является политикой :class:`EmailPolicy` через ее "
"предопределенный экземпляр :data:`~default`."

#: ../../library/email.policy.rst:48
msgid ""
"When a :class:`~email.message.Message` or :class:`~email.message."
"EmailMessage` object is created, it acquires a policy.  If the message is "
"created by a :mod:`~email.parser`, a policy passed to the parser will be the "
"policy used by the message it creates.  If the message is created by the "
"program, then the policy can be specified when it is created.  When a "
"message is passed to a :mod:`~email.generator`, the generator uses the "
"policy from the message by default, but you can also pass a specific policy "
"to the generator that will override the one stored on the message object."
msgstr ""
"Когда создается объект :class:`~email.message.Message` или :class:`~email."
"message.EmailMessage`, он получает политику. Если сообщение создано :mod:"
"`~email.parser`, политика, переданная в анализатор, будет политикой, "
"используемой создаваемым им сообщением. Если сообщение создается программой, "
"то политику можно указать при его создании. Когда сообщение передается в :"
"mod:`~email.generator`, генератор по умолчанию использует политику из "
"сообщения, но вы также можете передать генератору определенную политику, "
"которая переопределит политику, хранящуюся в объекте сообщения."

#: ../../library/email.policy.rst:57
msgid ""
"The default value for the *policy* keyword for the :mod:`email.parser` "
"classes and the parser convenience functions **will be changing** in a "
"future version of Python.  Therefore you should **always specify explicitly "
"which policy you want to use** when calling any of the classes and functions "
"described in the :mod:`~email.parser` module."
msgstr ""
"Значение по умолчанию для ключевого слова *policy* для классов :mod:`email."
"parser` и удобных функций синтаксического анализатора **будет изменено** в "
"будущей версии Python. Поэтому вам следует **всегда явно указывать, какую "
"политику вы хотите использовать** при вызове любого из классов и функций, "
"описанных в модуле :mod:`~email.parser`."

#: ../../library/email.policy.rst:63
msgid ""
"The first part of this documentation covers the features of :class:`Policy`, "
"an :term:`abstract base class` that defines the features that are common to "
"all policy objects, including :const:`compat32`.  This includes certain hook "
"methods that are called internally by the email package, which a custom "
"policy could override to obtain different behavior.  The second part "
"describes the concrete classes :class:`EmailPolicy` and :class:`Compat32`, "
"which implement the hooks that provide the standard behavior and the "
"backward compatible behavior and features, respectively."
msgstr ""
"Первая часть этой документации описывает возможности :class:`Policy`, :term:"
"`абстрактного базового класса`, который определяет функции, общие для всех "
"объектов политики, включая :const:`compat32`. Сюда входят определенные "
"методы-перехватчики, вызываемые внутри пакета электронной почты, которые "
"пользовательская политика может переопределить для получения другого "
"поведения. Во второй части описываются конкретные классы :class:"
"`EmailPolicy` и :class:`Compat32`, которые реализуют перехватчики, "
"обеспечивающие стандартное поведение и обратно совместимое поведение и "
"функции соответственно."

#: ../../library/email.policy.rst:72
msgid ""
":class:`Policy` instances are immutable, but they can be cloned, accepting "
"the same keyword arguments as the class constructor and returning a new :"
"class:`Policy` instance that is a copy of the original but with the "
"specified attributes values changed."
msgstr ""
"Экземпляры :class:`Policy` неизменяемы, но их можно клонировать, принимая те "
"же ключевые аргументы, что и конструктор класса, и возвращая новый "
"экземпляр :class:`Policy`, который является копией оригинала, но с "
"измененными указанными значениями атрибутов. ."

#: ../../library/email.policy.rst:77
msgid ""
"As an example, the following code could be used to read an email message "
"from a file on disk and pass it to the system ``sendmail`` program on a Unix "
"system:"
msgstr ""
"Например, следующий код может быть использован для чтения сообщения "
"электронной почты из файла на диске и передачи его в системную программу "
"sendmail в системе Unix:"

#: ../../library/email.policy.rst:92
msgid ""
">>> from email import message_from_binary_file\n"
">>> from email.generator import BytesGenerator\n"
">>> from email import policy\n"
">>> from subprocess import Popen, PIPE\n"
">>> with open('mymsg.txt', 'rb') as f:\n"
"...     msg = message_from_binary_file(f, policy=policy.default)\n"
"...\n"
">>> p = Popen(['sendmail', msg['To'].addresses[0]], stdin=PIPE)\n"
">>> g = BytesGenerator(p.stdin, policy=msg.policy.clone(linesep='\\r\\n'))\n"
">>> g.flatten(msg)\n"
">>> p.stdin.close()\n"
">>> rc = p.wait()"
msgstr ""
">>> from email import message_from_binary_file\n"
">>> from email.generator import BytesGenerator\n"
">>> from email import policy\n"
">>> from subprocess import Popen, PIPE\n"
">>> with open('mymsg.txt', 'rb') as f:\n"
"...     msg = message_from_binary_file(f, policy=policy.default)\n"
"...\n"
">>> p = Popen(['sendmail', msg['To'].addresses[0]], stdin=PIPE)\n"
">>> g = BytesGenerator(p.stdin, policy=msg.policy.clone(linesep='\\r\\n'))\n"
">>> g.flatten(msg)\n"
">>> p.stdin.close()\n"
">>> rc = p.wait()"

#: ../../library/email.policy.rst:114
msgid ""
"Here we are telling :class:`~email.generator.BytesGenerator` to use the RFC "
"correct line separator characters when creating the binary string to feed "
"into ``sendmail's`` ``stdin``, where the default policy would use ``\\n`` "
"line separators."
msgstr ""
"Здесь мы говорим :class:`~email.generator.BytesGenerator` использовать "
"правильные символы-разделители строк RFC при создании двоичной строки для "
"подачи в ``sendmail`` ``stdin``, где политика по умолчанию будет "
"использовать `` \\n`` разделители строк."

#: ../../library/email.policy.rst:119
msgid ""
"Some email package methods accept a *policy* keyword argument, allowing the "
"policy to be overridden for that method.  For example, the following code "
"uses the :meth:`~email.message.Message.as_bytes` method of the *msg* object "
"from the previous example and writes the message to a file using the native "
"line separators for the platform on which it is running::"
msgstr ""
"Некоторые методы пакета электронной почты принимают аргумент ключевого слова "
"*policy*, позволяющий переопределить политику для этого метода. Например, "
"следующий код использует метод :meth:`~email.message.Message.as_bytes` "
"объекта *msg* из предыдущего примера и записывает сообщение в файл, "
"используя собственные разделители строк для платформы, на которой оно "
"работает::"

#: ../../library/email.policy.rst:125
msgid ""
">>> import os\n"
">>> with open('converted.txt', 'wb') as f:\n"
"...     f.write(msg.as_bytes(policy=msg.policy.clone(linesep=os.linesep)))\n"
"17"
msgstr ""
">>> import os\n"
">>> with open('converted.txt', 'wb') as f:\n"
"...     f.write(msg.as_bytes(policy=msg.policy.clone(linesep=os.linesep)))\n"
"17"

#: ../../library/email.policy.rst:130
msgid ""
"Policy objects can also be combined using the addition operator, producing a "
"policy object whose settings are a combination of the non-default values of "
"the summed objects::"
msgstr ""
"Объекты политики также можно объединять с помощью оператора сложения, "
"создавая объект политики, параметры которого представляют собой комбинацию "
"значений суммируемых объектов, отличных от умолчанию:"

#: ../../library/email.policy.rst:134
msgid ""
">>> compat_SMTP = policy.compat32.clone(linesep='\\r\\n')\n"
">>> compat_strict = policy.compat32.clone(raise_on_defect=True)\n"
">>> compat_strict_SMTP = compat_SMTP + compat_strict"
msgstr ""
">>> compat_SMTP = policy.compat32.clone(linesep='\\r\\n')\n"
">>> compat_strict = policy.compat32.clone(raise_on_defect=True)\n"
">>> compat_strict_SMTP = compat_SMTP + compat_strict"

#: ../../library/email.policy.rst:138
msgid ""
"This operation is not commutative; that is, the order in which the objects "
"are added matters.  To illustrate::"
msgstr ""
"Эта операция не является коммутативной; то есть порядок добавления объектов "
"имеет значение. Для иллюстрации:"

#: ../../library/email.policy.rst:141
msgid ""
">>> policy100 = policy.compat32.clone(max_line_length=100)\n"
">>> policy80 = policy.compat32.clone(max_line_length=80)\n"
">>> apolicy = policy100 + policy80\n"
">>> apolicy.max_line_length\n"
"80\n"
">>> apolicy = policy80 + policy100\n"
">>> apolicy.max_line_length\n"
"100"
msgstr ""
">>> policy100 = policy.compat32.clone(max_line_length=100)\n"
">>> policy80 = policy.compat32.clone(max_line_length=80)\n"
">>> apolicy = policy100 + policy80\n"
">>> apolicy.max_line_length\n"
"80\n"
">>> apolicy = policy80 + policy100\n"
">>> apolicy.max_line_length\n"
"100"

#: ../../library/email.policy.rst:153
msgid ""
"This is the :term:`abstract base class` for all policy classes.  It provides "
"default implementations for a couple of trivial methods, as well as the "
"implementation of the immutability property, the :meth:`clone` method, and "
"the constructor semantics."
msgstr ""
"Это :term:`абстрактный базовый класс` для всех классов политики. Он "
"предоставляет реализации по умолчанию для нескольких тривиальных методов, а "
"также реализацию свойства неизменяемости, метода :meth:`clone` и семантики "
"конструктора."

#: ../../library/email.policy.rst:158
msgid ""
"The constructor of a policy class can be passed various keyword arguments. "
"The arguments that may be specified are any non-method properties on this "
"class, plus any additional non-method properties on the concrete class.  A "
"value specified in the constructor will override the default value for the "
"corresponding attribute."
msgstr ""
"Конструктору класса политики могут быть переданы различные аргументы "
"ключевых слов. Аргументами, которые могут быть указаны, являются любые "
"свойства, не являющиеся методами, в этом классе, а также любые "
"дополнительные свойства, не являющиеся методами, в конкретном классе. "
"Значение, указанное в конструкторе, переопределит значение по умолчанию для "
"соответствующего атрибута."

#: ../../library/email.policy.rst:164
msgid ""
"This class defines the following properties, and thus values for the "
"following may be passed in the constructor of any policy class:"
msgstr ""
"Этот класс определяет следующие свойства, поэтому следующие значения могут "
"передаваться в конструктор любого класса политики:"

#: ../../library/email.policy.rst:170
msgid ""
"The maximum length of any line in the serialized output, not counting the "
"end of line character(s).  Default is 78, per :rfc:`5322`.  A value of ``0`` "
"or :const:`None` indicates that no line wrapping should be done at all."
msgstr ""
"Максимальная длина любой строки в сериализованном выводе, не считая символов "
"конца строки. По умолчанию — 78, согласно :rfc:`5322`. Значение ``0`` или :"
"const:`None` указывает, что перенос строк выполнять вообще не следует."

#: ../../library/email.policy.rst:178
msgid ""
"The string to be used to terminate lines in serialized output.  The default "
"is ``\\n`` because that's the internal end-of-line discipline used by "
"Python, though ``\\r\\n`` is required by the RFCs."
msgstr ""
"Строка, которая будет использоваться для завершения строк в сериализованном "
"выводе. По умолчанию используется ``\\n``, поскольку это внутренняя "
"дисциплина конца строки, используемая Python, хотя ``\\r\\n`` требуется для "
"RFC."

#: ../../library/email.policy.rst:185
msgid ""
"Controls the type of Content Transfer Encodings that may be or are required "
"to be used.  The possible values are:"
msgstr ""
"Управляет типом кодировки передачи контента, которую можно или необходимо "
"использовать. Возможные значения:"

#: ../../library/email.policy.rst:191
msgid "``7bit``"
msgstr "``7bit``"

#: ../../library/email.policy.rst:191
msgid ""
"all data must be \"7 bit clean\" (ASCII-only).  This means that where "
"necessary data will be encoded using either quoted-printable or base64 "
"encoding."
msgstr ""
"все данные должны быть «7-битными» (только ASCII). Это означает, что при "
"необходимости данные будут закодированы с использованием кодировки Quote-"
"printable или Base64."

#: ../../library/email.policy.rst:195
msgid "``8bit``"
msgstr "``8bit``"

#: ../../library/email.policy.rst:195
msgid ""
"data is not constrained to be 7 bit clean.  Data in headers is still "
"required to be ASCII-only and so will be encoded (see :meth:`fold_binary` "
"and :attr:`~EmailPolicy.utf8` below for exceptions), but body parts may use "
"the ``8bit`` CTE."
msgstr ""
"данные не ограничены 7-битной чистотой. Данные в заголовках по-прежнему "
"должны быть только ASCII и поэтому будут закодированы (исключения см. в :"
"meth:`fold_binary` и :attr:`~EmailPolicy.utf8` ниже), но части тела могут "
"использовать ``8bit`` КТР."

#: ../../library/email.policy.rst:201
msgid ""
"A ``cte_type`` value of ``8bit`` only works with ``BytesGenerator``, not "
"``Generator``, because strings cannot contain binary data.  If a "
"``Generator`` is operating under a policy that specifies ``cte_type=8bit``, "
"it will act as if ``cte_type`` is ``7bit``."
msgstr ""
"Значение cte_type, равное 8bit, работает только с BytesGenerator, а не с "
"Generator, поскольку строки не могут содержать двоичные данные. Если "
"``Генератор`` работает в соответствии с политикой, которая определяет "
"``cte_type=8bit``, он будет действовать так, как будто ``cte_type`` имеет "
"значение ``7bit``."

#: ../../library/email.policy.rst:209
msgid ""
"If :const:`True`, any defects encountered will be raised as errors.  If :"
"const:`False` (the default), defects will be passed to the :meth:"
"`register_defect` method."
msgstr ""
"Если :const:`True`, любые обнаруженные дефекты будут считаться ошибками. "
"Если :const:`False` (по умолчанию), дефекты будут переданы в метод :meth:"
"`register_defect`."

#: ../../library/email.policy.rst:216
msgid ""
"If :const:`True`, lines starting with *\"From \"* in the body are escaped by "
"putting a ``>`` in front of them. This parameter is used when the message is "
"being serialized by a generator. Default: :const:`False`."
msgstr ""
"Если :const:`True`, строки, начинающиеся с *\"From\"* в теле, экранируются "
"путем помещения перед ними ``>``. Этот параметр используется, когда "
"сообщение сериализуется генератором. По умолчанию: :const:`False`."

#: ../../library/email.policy.rst:226
msgid ""
"A factory function for constructing a new empty message object.  Used by the "
"parser when building messages.  Defaults to ``None``, in which case :class:"
"`~email.message.Message` is used."
msgstr ""
"Фабричная функция для создания нового пустого объекта сообщения. "
"Используется парсером при построении сообщений. По умолчанию установлено "
"значение None, в этом случае используется :class:`~email.message.Message`."

#: ../../library/email.policy.rst:235
msgid ""
"If ``True`` (the default), the generator will raise :exc:`~email.errors."
"HeaderWriteError` instead of writing a header that is improperly folded or "
"delimited, such that it would be parsed as multiple headers or joined with "
"adjacent data. Such headers can be generated by custom header classes or "
"bugs in the ``email`` module."
msgstr ""
"Если ``True`` (по умолчанию), генератор выдаст :exc:`~email.errors."
"HeaderWriteError` вместо записи заголовка, который неправильно сложен или "
"разделен, так что он будет анализироваться как несколько заголовков или "
"объединяться с помощью соседние данные. Такие заголовки могут быть созданы с "
"помощью пользовательских классов заголовков или ошибок в модуле электронной "
"почты."

#: ../../library/email.policy.rst:242
msgid ""
"As it's a security feature, this defaults to ``True`` even in the :class:"
"`~email.policy.Compat32` policy. For backwards compatible, but unsafe, "
"behavior, it must be set to ``False`` explicitly."
msgstr ""
"Поскольку это функция безопасности, по умолчанию для нее установлено "
"значение True даже в политике :class:`~email.policy.Compat32`. Для обратно "
"совместимого, но небезопасного поведения необходимо явно установить значение "
"False."

#: ../../library/email.policy.rst:250
msgid ""
"The following :class:`Policy` method is intended to be called by code using "
"the email library to create policy instances with custom settings:"
msgstr ""
"Следующий метод :class:`Policy` предназначен для вызова из кода с "
"использованием библиотеки электронной почты для создания экземпляров "
"политики с настраиваемыми настройками:"

#: ../../library/email.policy.rst:256
msgid ""
"Return a new :class:`Policy` instance whose attributes have the same values "
"as the current instance, except where those attributes are given new values "
"by the keyword arguments."
msgstr ""
"Возвращает новый экземпляр :class:`Policy`, атрибуты которого имеют те же "
"значения, что и текущий экземпляр, за исключением случаев, когда этим "
"атрибутам присваиваются новые значения с помощью аргументов ключевого слова."

#: ../../library/email.policy.rst:261
msgid ""
"The remaining :class:`Policy` methods are called by the email package code, "
"and are not intended to be called by an application using the email package. "
"A custom policy must implement all of these methods."
msgstr ""
"Остальные методы :class:`Policy` вызываются кодом пакета электронной почты и "
"не предназначены для вызова приложением, использующим пакет электронной "
"почты. Пользовательская политика должна реализовывать все эти методы."

#: ../../library/email.policy.rst:268
msgid ""
"Handle a *defect* found on *obj*.  When the email package calls this method, "
"*defect* will always be a subclass of :class:`~email.errors.MessageDefect`."
msgstr ""

#: ../../library/email.policy.rst:272
msgid ""
"The default implementation checks the :attr:`raise_on_defect` flag.  If it "
"is ``True``, *defect* is raised as an exception.  If it is ``False`` (the "
"default), *obj* and *defect* are passed to :meth:`register_defect`."
msgstr ""
"Реализация по умолчанию проверяет флаг :attr:`raise_on_defect`. Если это "
"``True``, *defect* выдается как исключение. Если это значение «False» (по "
"умолчанию), *obj* и *defect* передаются в :meth:`register_defect`."

#: ../../library/email.policy.rst:279
msgid ""
"Register a *defect* on *obj*.  In the email package, *defect* will always be "
"a subclass of :class:`~email.errors.MessageDefect`."
msgstr ""

#: ../../library/email.policy.rst:282
msgid ""
"The default implementation calls the ``append`` method of the ``defects`` "
"attribute of *obj*.  When the email package calls :attr:`handle_defect`, "
"*obj* will normally have a ``defects`` attribute that has an ``append`` "
"method.  Custom object types used with the email package (for example, "
"custom ``Message`` objects) should also provide such an attribute, otherwise "
"defects in parsed messages will raise unexpected errors."
msgstr ""
"Реализация по умолчанию вызывает метод ``append`` атрибута ``defects`` "
"*obj*. Когда пакет электронной почты вызывает :attr:`handle_defect`, *obj* "
"обычно имеет атрибут ``defects`` с методом ``append``. Пользовательские типы "
"объектов, используемые с пакетом электронной почты (например, "
"пользовательские объекты «Сообщение»), также должны предоставлять такой "
"атрибут, иначе дефекты в анализируемых сообщениях вызовут непредвиденные "
"ошибки."

#: ../../library/email.policy.rst:292
msgid "Return the maximum allowed number of headers named *name*."
msgstr ""
"Возвращает максимально допустимое количество заголовков с именем *имя*."

#: ../../library/email.policy.rst:294
msgid ""
"Called when a header is added to an :class:`~email.message.EmailMessage` or :"
"class:`~email.message.Message` object.  If the returned value is not ``0`` "
"or ``None``, and there are already a number of headers with the name *name* "
"greater than or equal to the value returned, a :exc:`ValueError` is raised."
msgstr ""
"Вызывается, когда заголовок добавляется к объекту :class:`~email.message."
"EmailMessage` или :class:`~email.message.Message`. Если возвращаемое "
"значение не ``0`` или ``None``, и уже существует несколько заголовков с "
"именем *name*, большим или равным возвращаемому значению, возникает ошибка :"
"exc:`ValueError`. ."

#: ../../library/email.policy.rst:300
msgid ""
"Because the default behavior of ``Message.__setitem__`` is to append the "
"value to the list of headers, it is easy to create duplicate headers without "
"realizing it.  This method allows certain headers to be limited in the "
"number of instances of that header that may be added to a ``Message`` "
"programmatically.  (The limit is not observed by the parser, which will "
"faithfully produce as many headers as exist in the message being parsed.)"
msgstr ""
"Поскольку поведение Message.__setitem__ по умолчанию заключается в "
"добавлении значения в список заголовков, легко создать дубликаты заголовков, "
"даже не осознавая этого. Этот метод позволяет ограничить количество "
"экземпляров определенных заголовков, которые могут быть добавлены к "
"сообщению программным путем. (Это ограничение не соблюдается анализатором, "
"который будет точно создавать столько заголовков, сколько существует в "
"анализируемом сообщении.)"

#: ../../library/email.policy.rst:308
msgid "The default implementation returns ``None`` for all header names."
msgstr "Реализация по умолчанию возвращает None для всех имен заголовков."

#: ../../library/email.policy.rst:313
msgid ""
"The email package calls this method with a list of strings, each string "
"ending with the line separation characters found in the source being "
"parsed.  The first line includes the field header name and separator. All "
"whitespace in the source is preserved.  The method should return the "
"``(name, value)`` tuple that is to be stored in the ``Message`` to represent "
"the parsed header."
msgstr ""
"Пакет электронной почты вызывает этот метод со списком строк, каждая строка "
"заканчивается символами разделения строк, найденными в анализируемом "
"источнике. Первая строка включает имя заголовка поля и разделитель. Все "
"пробелы в исходном коде сохраняются. Метод должен возвращать кортеж «(имя, "
"значение)», который должен быть сохранен в «Сообщении» для представления "
"проанализированного заголовка."

#: ../../library/email.policy.rst:320
msgid ""
"If an implementation wishes to retain compatibility with the existing email "
"package policies, *name* should be the case preserved name (all characters "
"up to the '``:``' separator), while *value* should be the unfolded value "
"(all line separator characters removed, but whitespace kept intact), "
"stripped of leading whitespace."
msgstr ""
"Если реализация желает сохранить совместимость с существующими политиками "
"пакетов электронной почты, *name* должно быть именем с сохранением регистра "
"(все символы до разделителя '``:``'), а *value* должно быть развернутым "
"значением (все символы-разделители строк удалены, но пробелы сохранены), "
"удалены ведущие пробелы."

#: ../../library/email.policy.rst:326
msgid "*sourcelines* may contain surrogateescaped binary data."
msgstr ""
"*исходные строки* могут содержать двоичные данные с суррогатным "
"экранированием."

#: ../../library/email.policy.rst:328 ../../library/email.policy.rst:344
#: ../../library/email.policy.rst:360
msgid "There is no default implementation"
msgstr "Нет реализации по умолчанию"

#: ../../library/email.policy.rst:333
msgid ""
"The email package calls this method with the name and value provided by the "
"application program when the application program is modifying a ``Message`` "
"programmatically (as opposed to a ``Message`` created by a parser).  The "
"method should return the ``(name, value)`` tuple that is to be stored in the "
"``Message`` to represent the header."
msgstr ""
"Пакет электронной почты вызывает этот метод с именем и значением, "
"предоставленными прикладной программой, когда прикладная программа изменяет "
"«Сообщение» программно (в отличие от «Сообщения», созданного анализатором). "
"Метод должен возвращать кортеж «(имя, значение)», который должен быть "
"сохранен в «Сообщении» для представления заголовка."

#: ../../library/email.policy.rst:339
msgid ""
"If an implementation wishes to retain compatibility with the existing email "
"package policies, the *name* and *value* should be strings or string "
"subclasses that do not change the content of the passed in arguments."
msgstr ""
"Если реализация желает сохранить совместимость с существующими политиками "
"пакетов электронной почты, *имя* и *значение* должны быть строками или "
"подклассами строк, которые не меняют содержимое переданных аргументов."

#: ../../library/email.policy.rst:349
msgid ""
"The email package calls this method with the *name* and *value* currently "
"stored in the ``Message`` when that header is requested by the application "
"program, and whatever the method returns is what is passed back to the "
"application as the value of the header being retrieved. Note that there may "
"be more than one header with the same name stored in the ``Message``; the "
"method is passed the specific name and value of the header destined to be "
"returned to the application."
msgstr ""
"Пакет электронной почты вызывает этот метод с *имя* и *значением*, которые в "
"настоящее время хранятся в ``Message``, когда этот заголовок запрашивается "
"прикладной программой, и все, что возвращает метод, передается обратно "
"приложению в качестве значения. извлекаемого заголовка. Обратите внимание, "
"что в сообщении ``Message`` может храниться более одного заголовка с одним и "
"тем же именем; методу передается конкретное имя и значение заголовка, "
"предназначенного для возврата в приложение."

#: ../../library/email.policy.rst:357
msgid ""
"*value* may contain surrogateescaped binary data.  There should be no "
"surrogateescaped binary data in the value returned by the method."
msgstr ""
"*value* может содержать двоичные данные с суррогатным экранированием. В "
"значении, возвращаемом методом, не должно быть никаких двоичных данных с "
"суррогатным экранированием."

#: ../../library/email.policy.rst:365
msgid ""
"The email package calls this method with the *name* and *value* currently "
"stored in the ``Message`` for a given header.  The method should return a "
"string that represents that header \"folded\" correctly (according to the "
"policy settings) by composing the *name* with the *value* and inserting :"
"attr:`linesep` characters at the appropriate places.  See :rfc:`5322` for a "
"discussion of the rules for folding email headers."
msgstr ""
"Пакет электронной почты вызывает этот метод с *имя* и *значением*, "
"хранящимися в настоящее время в ``Message`` для данного заголовка. Метод "
"должен возвращать строку, которая правильно представляет этот заголовок, "
"«свернутый» (в соответствии с настройками политики), объединяя *имя* со "
"*значением* и вставляя символы :attr:`linesep` в соответствующие места. См. :"
"rfc:`5322` для обсуждения правил сворачивания заголовков электронных писем."

#: ../../library/email.policy.rst:372
msgid ""
"*value* may contain surrogateescaped binary data.  There should be no "
"surrogateescaped binary data in the string returned by the method."
msgstr ""
"*value* может содержать двоичные данные с суррогатным экранированием. В "
"строке, возвращаемой методом, не должно быть двоичных данных с суррогатным "
"экранированием."

#: ../../library/email.policy.rst:378
msgid ""
"The same as :meth:`fold`, except that the returned value should be a bytes "
"object rather than a string."
msgstr ""
"То же, что и :meth:`fold`, за исключением того, что возвращаемое значение "
"должно быть байтовым объектом, а не строкой."

#: ../../library/email.policy.rst:381
msgid ""
"*value* may contain surrogateescaped binary data.  These could be converted "
"back into binary data in the returned bytes object."
msgstr ""
"*value* может содержать двоичные данные с суррогатным экранированием. Их "
"можно преобразовать обратно в двоичные данные в возвращаемом объекте байтов."

#: ../../library/email.policy.rst:388
msgid ""
"This concrete :class:`Policy` provides behavior that is intended to be fully "
"compliant with the current email RFCs.  These include (but are not limited "
"to) :rfc:`5322`, :rfc:`2047`, and the current MIME RFCs."
msgstr ""
"Эта конкретная :class:`Policy` обеспечивает поведение, которое должно "
"полностью соответствовать текущим RFC для электронной почты. К ним относятся "
"(но не ограничиваются): :rfc:`5322`, :rfc:`2047` и текущие MIME RFC."

#: ../../library/email.policy.rst:392
msgid ""
"This policy adds new header parsing and folding algorithms.  Instead of "
"simple strings, headers are ``str`` subclasses with attributes that depend "
"on the type of the field.  The parsing and folding algorithm fully "
"implement :rfc:`2047` and :rfc:`5322`."
msgstr ""
"Эта политика добавляет новые алгоритмы анализа и свертывания заголовков. "
"Вместо простых строк заголовки представляют собой подклассы str с "
"атрибутами, которые зависят от типа поля. Алгоритм синтаксического анализа и "
"свертывания полностью реализует :rfc:`2047` и :rfc:`5322`."

#: ../../library/email.policy.rst:397
msgid ""
"The default value for the :attr:`~email.policy.Policy.message_factory` "
"attribute is :class:`~email.message.EmailMessage`."
msgstr ""
"Значением по умолчанию для атрибута :attr:`~email.policy.Policy."
"message_factory` является :class:`~email.message.EmailMessage`."

#: ../../library/email.policy.rst:400
msgid ""
"In addition to the settable attributes listed above that apply to all "
"policies, this policy adds the following additional attributes:"
msgstr ""
"Помимо перечисленных выше настраиваемых атрибутов, применимых ко всем "
"политикам, эта политика добавляет следующие дополнительные атрибуты:"

#: ../../library/email.policy.rst:403
msgid "[1]_"
msgstr "[1]_"

#: ../../library/email.policy.rst:408
msgid ""
"If ``False``, follow :rfc:`5322`, supporting non-ASCII characters in headers "
"by encoding them as \"encoded words\".  If ``True``, follow :rfc:`6532` and "
"use ``utf-8`` encoding for headers.  Messages formatted in this way may be "
"passed to SMTP servers that support the ``SMTPUTF8`` extension (:rfc:`6531`)."
msgstr ""
"Если «False», следуйте :rfc:`5322`, поддерживая символы, отличные от ASCII, "
"в заголовках, кодируя их как «закодированные слова». Если ``True``, "
"следуйте :rfc:`6532` и используйте кодировку ``utf-8`` для заголовков. "
"Сообщения, отформатированные таким образом, могут передаваться на SMTP-"
"серверы, поддерживающие расширение SMTPUTF8 (:rfc:`6531`)."

#: ../../library/email.policy.rst:417
msgid ""
"If the value for a header in the ``Message`` object originated from a :mod:"
"`~email.parser` (as opposed to being set by a program), this attribute "
"indicates whether or not a generator should refold that value when "
"transforming the message back into serialized form.  The possible values are:"
msgstr ""
"Если значение заголовка в объекте ``Message`` получено из :mod:`~email."
"parser` (а не установлено программой), этот атрибут указывает, должен ли "
"генератор повторно сворачивать это значение при преобразование сообщения "
"обратно в сериализованную форму. Возможные значения:"

#: ../../library/email.policy.rst:424
msgid "``none``"
msgstr "``none``"

#: ../../library/email.policy.rst:424
msgid "all source values use original folding"
msgstr "все исходные значения используют оригинальное сворачивание"

#: ../../library/email.policy.rst:426
msgid "``long``"
msgstr "``long``"

#: ../../library/email.policy.rst:426
msgid ""
"source values that have any line that is longer than ``max_line_length`` "
"will be refolded"
msgstr ""
"исходные значения, длина любой строки которых превышает ``max_line_length``, "
"будут повторно свернуты"

#: ../../library/email.policy.rst:429
msgid "``all``"
msgstr "``all``"

#: ../../library/email.policy.rst:429
msgid "all values are refolded."
msgstr "все значения будут повторно свернуты."

#: ../../library/email.policy.rst:432
msgid "The default is ``long``."
msgstr "По умолчанию - ``long``."

#: ../../library/email.policy.rst:437
msgid ""
"A callable that takes two arguments, ``name`` and ``value``, where ``name`` "
"is a header field name and ``value`` is an unfolded header field value, and "
"returns a string subclass that represents that header.  A default "
"``header_factory`` (see :mod:`~email.headerregistry`) is provided that "
"supports custom parsing for the various address and date :RFC:`5322` header "
"field types, and the major MIME header field stypes.  Support for additional "
"custom parsing will be added in the future."
msgstr ""
"Вызываемый объект, который принимает два аргумента, ``name`` и ``value``, "
"где ``name`` — это имя поля заголовка, а ``value`` — это развернутое "
"значение поля заголовка, и возвращает строковый подкласс, который "
"представляет этот заголовок. По умолчанию предоставляется ``header_factory`` "
"(см. :mod:`~email.headerregistry`), который поддерживает индивидуальный "
"анализ различных типов полей заголовка адреса и даты :RFC:`5322`, а также "
"основных типов полей заголовка MIME. Поддержка дополнительного "
"пользовательского анализа будет добавлена ​​в будущем."

#: ../../library/email.policy.rst:448
msgid ""
"An object with at least two methods: get_content and set_content.  When the :"
"meth:`~email.message.EmailMessage.get_content` or :meth:`~email.message."
"EmailMessage.set_content` method of an :class:`~email.message.EmailMessage` "
"object is called, it calls the corresponding method of this object, passing "
"it the message object as its first argument, and any arguments or keywords "
"that were passed to it as additional arguments.  By default "
"``content_manager`` is set to :data:`~email.contentmanager.raw_data_manager`."
msgstr ""
"Объект, имеющий как минимум два метода: get_content и set_content. Когда "
"вызывается метод :meth:`~email.message.EmailMessage.get_content` или :meth:"
"`~email.message.EmailMessage.set_content` объекта :class:`~email.message."
"EmailMessage`, он вызывает соответствующий метод этого объекта, передав ему "
"объект сообщения в качестве первого аргумента, а также любые аргументы или "
"ключевые слова, которые были переданы ему в качестве дополнительных "
"аргументов. По умолчанию для ``content_manager`` установлено значение :data:"
"`~email.contentmanager.raw_data_manager`."

#: ../../library/email.policy.rst:460 ../../library/email.policy.rst:618
msgid ""
"The class provides the following concrete implementations of the abstract "
"methods of :class:`Policy`:"
msgstr ""
"Класс предоставляет следующие конкретные реализации абстрактных методов :"
"class:`Policy`:"

#: ../../library/email.policy.rst:466
msgid ""
"Returns the value of the :attr:`~email.headerregistry.BaseHeader.max_count` "
"attribute of the specialized class used to represent the header with the "
"given name."
msgstr ""
"Возвращает значение атрибута :attr:`~email.headerregistry.BaseHeader."
"max_count` специализированного класса, используемого для представления "
"заголовка с заданным именем."

#: ../../library/email.policy.rst:474 ../../library/email.policy.rst:624
msgid ""
"The name is parsed as everything up to the '``:``' and returned unmodified.  "
"The value is determined by stripping leading whitespace off the remainder of "
"the first line, joining all subsequent lines together, and stripping any "
"trailing carriage return or linefeed characters."
msgstr ""
"Имя анализируется как все до '``:``' и возвращается без изменений. Значение "
"определяется путем удаления начальных пробелов из оставшейся части первой "
"строки, объединения всех последующих строк вместе и удаления любых конечных "
"символов возврата каретки или перевода строки."

#: ../../library/email.policy.rst:482
msgid ""
"The name is returned unchanged.  If the input value has a ``name`` attribute "
"and it matches *name* ignoring case, the value is returned unchanged.  "
"Otherwise the *name* and *value* are passed to ``header_factory``, and the "
"resulting header object is returned as the value.  In this case a "
"``ValueError`` is raised if the input value contains CR or LF characters."
msgstr ""
"Имя возвращается без изменений. Если входное значение имеет атрибут ``name`` "
"и соответствует регистру *name*, значение возвращается без изменений. В "
"противном случае *имя* и *значение* передаются в ``header_factory``, и "
"результирующий объект заголовка возвращается как значение. В этом случае "
"выдается ``ValueError``, если входное значение содержит символы CR или LF."

#: ../../library/email.policy.rst:492
msgid ""
"If the value has a ``name`` attribute, it is returned to unmodified. "
"Otherwise the *name*, and the *value* with any CR or LF characters removed, "
"are passed to the ``header_factory``, and the resulting header object is "
"returned.  Any surrogateescaped bytes get turned into the unicode unknown-"
"character glyph."
msgstr ""
"Если значение имеет атрибут ``name``, оно возвращается в неизмененное "
"состояние. В противном случае *имя* и *значение* с удаленными символами CR "
"или LF передаются в ``header_factory``, и возвращается результирующий объект "
"заголовка. Любые суррогатно-экранированные байты преобразуются в глиф "
"неизвестного символа Юникода."

#: ../../library/email.policy.rst:501
msgid ""
"Header folding is controlled by the :attr:`refold_source` policy setting. A "
"value is considered to be a 'source value' if and only if it does not have a "
"``name`` attribute (having a ``name`` attribute means it is a header object "
"of some sort).  If a source value needs to be refolded according to the "
"policy, it is converted into a header object by passing the *name* and the "
"*value* with any CR and LF characters removed to the ``header_factory``.  "
"Folding of a header object is done by calling its ``fold`` method with the "
"current policy."
msgstr ""
"Свертывание заголовка контролируется параметром политики :attr:"
"`refold_source`. Значение считается «исходным значением» тогда и только "
"тогда, когда оно не имеет атрибута «name» (наличие атрибута «name» означает, "
"что это какой-то объект заголовка). Если исходное значение необходимо "
"пересвернуть в соответствии с политикой, оно преобразуется в объект "
"заголовка путем передачи *имя* и *значения* с удалением любых символов CR и "
"LF в ``header_factory``. Свертывание объекта заголовка выполняется путем "
"вызова его методаfold с текущей политикой."

#: ../../library/email.policy.rst:510
msgid ""
"Source values are split into lines using :meth:`~str.splitlines`.  If the "
"value is not to be refolded, the lines are rejoined using the ``linesep`` "
"from the policy and returned.  The exception is lines containing non-ascii "
"binary data.  In that case the value is refolded regardless of the "
"``refold_source`` setting, which causes the binary data to be CTE encoded "
"using the ``unknown-8bit`` charset."
msgstr ""
"Исходные значения разбиваются на строки с помощью :meth:`~str.splitlines`. "
"Если значение не должно быть перевернуто, строки соединяются с "
"использованием ``linesep`` из политики и возвращаются. Исключением являются "
"строки, содержащие двоичные данные, отличные от ascii. В этом случае "
"значение переворачивается независимо от настройки ``refold_source``, что "
"приводит к кодированию двоичных данных CTE с использованием кодировки "
"``unknown-8bit``."

#: ../../library/email.policy.rst:520
msgid ""
"The same as :meth:`fold` if :attr:`~Policy.cte_type` is ``7bit``, except "
"that the returned value is bytes."
msgstr ""
"То же, что и :meth:`fold`, если :attr:`~Policy.cte_type` имеет значение "
"``7bit``, за исключением того, что возвращаемое значение — байты."

#: ../../library/email.policy.rst:523
msgid ""
"If :attr:`~Policy.cte_type` is ``8bit``, non-ASCII binary data is converted "
"back into bytes.  Headers with binary data are not refolded, regardless of "
"the ``refold_header`` setting, since there is no way to know whether the "
"binary data consists of single byte characters or multibyte characters."
msgstr ""
"Если :attr:`~Policy.cte_type` имеет значение ``8bit``, двоичные данные, "
"отличные от ASCII, преобразуются обратно в байты. Заголовки с двоичными "
"данными не переворачиваются, независимо от настройки refold_header, "
"поскольку невозможно узнать, состоят ли двоичные данные из однобайтовых "
"символов или из многобайтовых символов."

#: ../../library/email.policy.rst:530
msgid ""
"The following instances of :class:`EmailPolicy` provide defaults suitable "
"for specific application domains.  Note that in the future the behavior of "
"these instances (in particular the ``HTTP`` instance) may be adjusted to "
"conform even more closely to the RFCs relevant to their domains."
msgstr ""
"Следующие экземпляры :class:`EmailPolicy` предоставляют значения по "
"умолчанию, подходящие для конкретных доменов приложений. Обратите внимание, "
"что в будущем поведение этих экземпляров (в частности, экземпляра HTTP) "
"может быть скорректировано, чтобы еще больше соответствовать RFC, "
"относящимся к их доменам."

#: ../../library/email.policy.rst:538
msgid ""
"An instance of ``EmailPolicy`` with all defaults unchanged.  This policy "
"uses the standard Python ``\\n`` line endings rather than the RFC-correct "
"``\\r\\n``."
msgstr ""
"Экземпляр EmailPolicy со всеми неизмененными значениями по умолчанию. Эта "
"политика использует стандартные окончания строк Python ``\\n`` вместо "
"правильного RFC ``\\r\\n``."

#: ../../library/email.policy.rst:545
msgid ""
"Suitable for serializing messages in conformance with the email RFCs. Like "
"``default``, but with ``linesep`` set to ``\\r\\n``, which is RFC compliant."
msgstr ""
"Подходит для сериализации сообщений в соответствии с RFC электронной почты. "
"Аналогично ``default``, но с ``linesep`` установленным в ``\\r\\n``, что "
"соответствует RFC."

#: ../../library/email.policy.rst:552
msgid ""
"The same as ``SMTP`` except that :attr:`~EmailPolicy.utf8` is ``True``. "
"Useful for serializing messages to a message store without using encoded "
"words in the headers.  Should only be used for SMTP transmission if the "
"sender or recipient addresses have non-ASCII characters (the :meth:`smtplib."
"SMTP.send_message` method handles this automatically)."
msgstr ""
"То же, что и SMTP, за исключением того, что :attr:~EmailPolicy.utf8 имеет "
"значение True. Полезно для сериализации сообщений в хранилище сообщений без "
"использования закодированных слов в заголовках. Следует использовать для "
"передачи SMTP только в том случае, если адреса отправителя или получателя "
"содержат символы, отличные от ASCII (метод :meth:`smtplib.SMTP.send_message` "
"обрабатывает это автоматически)."

#: ../../library/email.policy.rst:561
msgid ""
"Suitable for serializing headers with for use in HTTP traffic.  Like "
"``SMTP`` except that ``max_line_length`` is set to ``None`` (unlimited)."
msgstr ""
"Подходит для сериализации заголовков для использования в HTTP-трафике. "
"Аналогично SMTP, за исключением того, что для max_line_length установлено "
"значение None (неограниченно)."

#: ../../library/email.policy.rst:567
msgid ""
"Convenience instance.  The same as ``default`` except that "
"``raise_on_defect`` is set to ``True``.  This allows any policy to be made "
"strict by writing::"
msgstr ""
"Удобный экземпляр. То же, что и ``default``, за исключением того, что "
"``raise_on_defect`` имеет значение ``True``. Это позволяет сделать любую "
"политику строгой, написав:"

#: ../../library/email.policy.rst:571
msgid "somepolicy + policy.strict"
msgstr "somepolicy + policy.strict"

#: ../../library/email.policy.rst:574
msgid ""
"With all of these :class:`EmailPolicies <.EmailPolicy>`, the effective API "
"of the email package is changed from the Python 3.2 API in the following "
"ways:"
msgstr ""
"Со всеми этими :class:`EmailPolicies <.EmailPolicy>` эффективный API пакета "
"электронной почты изменяется по сравнению с API Python 3.2 следующим образом:"

#: ../../library/email.policy.rst:577
msgid ""
"Setting a header on a :class:`~email.message.Message` results in that header "
"being parsed and a header object created."
msgstr ""
"Установка заголовка в :class:`~email.message.Message` приводит к анализу "
"этого заголовка и созданию объекта заголовка."

#: ../../library/email.policy.rst:580
msgid ""
"Fetching a header value from a :class:`~email.message.Message` results in "
"that header being parsed and a header object created and returned."
msgstr ""
"Получение значения заголовка из :class:`~email.message.Message` приводит к "
"анализу этого заголовка и созданию и возврату объекта заголовка."

#: ../../library/email.policy.rst:584
msgid ""
"Any header object, or any header that is refolded due to the policy "
"settings, is folded using an algorithm that fully implements the RFC folding "
"algorithms, including knowing where encoded words are required and allowed."
msgstr ""
"Любой объект заголовка или любой заголовок, который сворачивается из-за "
"настроек политики, сворачивается с использованием алгоритма, который "
"полностью реализует алгоритмы свертывания RFC, включая знание того, где "
"закодированные слова необходимы и разрешены."

#: ../../library/email.policy.rst:589
msgid ""
"From the application view, this means that any header obtained through the :"
"class:`~email.message.EmailMessage` is a header object with extra "
"attributes, whose string value is the fully decoded unicode value of the "
"header.  Likewise, a header may be assigned a new value, or a new header "
"created, using a unicode string, and the policy will take care of converting "
"the unicode string into the correct RFC encoded form."
msgstr ""
"С точки зрения приложения это означает, что любой заголовок, полученный "
"через :class:`~email.message.EmailMessage`, является объектом заголовка с "
"дополнительными атрибутами, строковое значение которого представляет собой "
"полностью декодированное значение заголовка в Юникоде. Аналогично, заголовку "
"может быть присвоено новое значение или создан новый заголовок с "
"использованием строки Юникода, и политика позаботится о преобразовании "
"строки Юникода в правильную форму, закодированную в RFC."

#: ../../library/email.policy.rst:596
msgid ""
"The header objects and their attributes are described in :mod:`~email."
"headerregistry`."
msgstr ""
"Объекты заголовков и их атрибуты описаны в :mod:`~email.headerregistry`."

#: ../../library/email.policy.rst:603
msgid ""
"This concrete :class:`Policy` is the backward compatibility policy.  It "
"replicates the behavior of the email package in Python 3.2.  The :mod:"
"`~email.policy` module also defines an instance of this class, :const:"
"`compat32`, that is used as the default policy.  Thus the default behavior "
"of the email package is to maintain compatibility with Python 3.2."
msgstr ""
"Эта конкретная :class:`Policy` является политикой обратной совместимости. Он "
"повторяет поведение пакета электронной почты в Python 3.2. Модуль :mod:"
"`~email.policy` также определяет экземпляр этого класса, :const:`compat32`, "
"который используется в качестве политики по умолчанию. Таким образом, по "
"умолчанию пакет электронной почты обеспечивает совместимость с Python 3.2."

#: ../../library/email.policy.rst:609
msgid ""
"The following attributes have values that are different from the :class:"
"`Policy` default:"
msgstr ""
"Следующие атрибуты имеют значения, отличные от значений по умолчанию :class:"
"`Policy`:"

#: ../../library/email.policy.rst:615
msgid "The default is ``True``."
msgstr "По умолчанию - ``True``."

#: ../../library/email.policy.rst:632
msgid "The name and value are returned unmodified."
msgstr "Имя и значение возвращаются без изменений."

#: ../../library/email.policy.rst:637
msgid ""
"If the value contains binary data, it is converted into a :class:`~email."
"header.Header` object using the ``unknown-8bit`` charset. Otherwise it is "
"returned unmodified."
msgstr ""
"Если значение содержит двоичные данные, оно преобразуется в объект :class:"
"`~email.header.Header` с использованием кодировки ``unknown-8bit``. В "
"противном случае он возвращается без изменений."

#: ../../library/email.policy.rst:644
msgid ""
"Headers are folded using the :class:`~email.header.Header` folding "
"algorithm, which preserves existing line breaks in the value, and wraps each "
"resulting line to the ``max_line_length``.  Non-ASCII binary data are CTE "
"encoded using the ``unknown-8bit`` charset."
msgstr ""
"Заголовки сворачиваются с использованием алгоритма свертывания :class:"
"`~email.header.Header`, который сохраняет существующие разрывы строк в "
"значении и переносит каждую результирующую строку в ``max_line_length``. "
"Двоичные данные, отличные от ASCII, кодируются CTE с использованием "
"кодировки ``unknown-8bit``."

#: ../../library/email.policy.rst:652
msgid ""
"Headers are folded using the :class:`~email.header.Header` folding "
"algorithm, which preserves existing line breaks in the value, and wraps each "
"resulting line to the ``max_line_length``.  If ``cte_type`` is ``7bit``, non-"
"ascii binary data is CTE encoded using the ``unknown-8bit`` charset.  "
"Otherwise the original source header is used, with its existing line breaks "
"and any (RFC invalid) binary data it may contain."
msgstr ""
"Заголовки сворачиваются с использованием алгоритма свертывания :class:"
"`~email.header.Header`, который сохраняет существующие разрывы строк в "
"значении и переносит каждую результирующую строку в ``max_line_length``. "
"Если ``cte_type`` равен ``7bit``, двоичные данные, отличные от ascii, "
"кодируются CTE с использованием кодировки ``unknown-8bit``. В противном "
"случае используется исходный заголовок источника с существующими разрывами "
"строк и любыми (недействительными RFC) двоичными данными, которые он может "
"содержать."

#: ../../library/email.policy.rst:662
msgid ""
"An instance of :class:`Compat32`, providing  backward compatibility with the "
"behavior of the email package in Python 3.2."
msgstr ""
"Экземпляр :class:`Compat32`, обеспечивающий обратную совместимость с "
"поведением пакета электронной почты в Python 3.2."

#: ../../library/email.policy.rst:667
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/email.policy.rst:668
msgid ""
"Originally added in 3.3 as a :term:`provisional feature <provisional "
"package>`."
msgstr ""
"Первоначально добавлен в версии 3.3 как :term:`предварительная функция "
"<предварительный пакет>`."
