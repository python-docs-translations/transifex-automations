# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/urllib.request.rst:2
msgid ":mod:`urllib.request` --- Extensible library for opening URLs"
msgstr ""

#: ../../library/urllib.request.rst:11
msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**Исходный код:** :source:`Lib/urllib/request.py`"

#: ../../library/urllib.request.rst:15
msgid ""
"The :mod:`urllib.request` module defines functions and classes which help in "
"opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
"Модуль :mod:`urllib.request` определяет функции и классы, которые помогают "
"открывать URL-адреса (в основном HTTP) в сложном мире — базовую и дайджест-"
"аутентификацию, перенаправление, файлы cookie и многое другое."

#: ../../library/urllib.request.rst:21
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"`Пакет Requests <https://requests.readthedocs.io/en/master/>`_ рекомендуется "
"для клиентского интерфейса HTTP более высокого уровня."

#: ../../library/urllib.request.rst:25
msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr "Модуль :mod:`urllib.request` определяет следующие функции:"

#: ../../library/urllib.request.rst:30
msgid ""
"Open the URL *url*, which can be either a string or a :class:`Request` "
"object."
msgstr ""

#: ../../library/urllib.request.rst:33
msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data* должен быть объектом, определяющим дополнительные данные, которые "
"будут отправлены на сервер, или ``None``, если такие данные не требуются. "
"Подробности смотрите в :class:`Request`."

#: ../../library/urllib.request.rst:37
msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` header "
"in its HTTP requests."
msgstr ""
"Модуль urllib.request использует HTTP/1.1 и включает заголовок Connection: "
"close в свои HTTP-запросы."

#: ../../library/urllib.request.rst:40
msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used).  This actually only works for HTTP, HTTPS and "
"FTP connections."
msgstr ""
"Необязательный параметр *timeout* указывает тайм-аут в секундах для "
"блокировки таких операций, как попытка подключения (если он не указан, будет "
"использоваться глобальная настройка тайм-аута по умолчанию). На самом деле "
"это работает только для соединений HTTP, HTTPS и FTP."

#: ../../library/urllib.request.rst:45
msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See :class:`~http.client."
"HTTPSConnection` for more details."
msgstr ""
"Если указан *context*, это должен быть экземпляр :class:`ssl.SSLContext`, "
"описывающий различные параметры SSL. См. :class:`~http.client."
"HTTPSConnection` для более подробной информации."

#: ../../library/urllib.request.rst:49
msgid ""
"The optional *cafile* and *capath* parameters specify a set of trusted CA "
"certificates for HTTPS requests.  *cafile* should point to a single file "
"containing a bundle of CA certificates, whereas *capath* should point to a "
"directory of hashed certificate files.  More information can be found in :"
"meth:`ssl.SSLContext.load_verify_locations`."
msgstr ""
"Необязательные параметры *cafile* и *capath* указывают набор доверенных "
"сертификатов CA для запросов HTTPS. *cafile* должен указывать на один файл, "
"содержащий пакет сертификатов CA, тогда как *capath* должен указывать на "
"каталог хешированных файлов сертификатов. Дополнительную информацию можно "
"найти в :meth:`ssl.SSLContext.load_verify_locations`."

#: ../../library/urllib.request.rst:55
msgid "The *cadefault* parameter is ignored."
msgstr "Параметр *cadefault* игнорируется."

#: ../../library/urllib.request.rst:57
msgid ""
"This function always returns an object which can work as a :term:`context "
"manager` and has the properties *url*, *headers*, and *status*. See :class:"
"`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"Эта функция всегда возвращает объект, который может работать как контекстный "
"менеджер и имеет свойства *url*, *headers* и *status*. См. :class:`urllib."
"response.addinourl` для получения более подробной информации об этих "
"свойствах."

#: ../../library/urllib.request.rst:61
msgid ""
"For HTTP and HTTPS URLs, this function returns a :class:`http.client."
"HTTPResponse` object slightly modified. In addition to the three new methods "
"above, the msg attribute contains the same information as the :attr:`~http."
"client.HTTPResponse.reason` attribute --- the reason phrase returned by "
"server --- instead of the response headers as it is specified in the "
"documentation for :class:`~http.client.HTTPResponse`."
msgstr ""
"Для URL-адресов HTTP и HTTPS эта функция возвращает слегка измененный "
"объект :class:`http.client.HTTPResponse`. В дополнение к трем новым методам, "
"описанным выше, атрибут msg содержит ту же информацию, что и атрибут :attr:"
"`~http.client.HTTPResponse.reason` --- фразу причины, возвращаемую сервером "
"--- вместо заголовков ответа, как это указано в документации для :class:"
"`~http.client.HTTPResponse`."

#: ../../library/urllib.request.rst:69
msgid ""
"For FTP, file, and data URLs and requests explicitly handled by legacy :"
"class:`URLopener` and :class:`FancyURLopener` classes, this function returns "
"a :class:`urllib.response.addinfourl` object."
msgstr ""
"Для URL-адресов FTP, файлов и данных, а также запросов, явно обрабатываемых "
"устаревшими классами :class:`URLopener` и :class:`FancyURLopener`, эта "
"функция возвращает объект :class:`urllib.response.addinourl`."

#: ../../library/urllib.request.rst:73
msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr "Вызывает :exc:`~urllib.error.URLError` при ошибках протокола."

#: ../../library/urllib.request.rst:75
msgid ""
"Note that ``None`` may be returned if no handler handles the request (though "
"the default installed global :class:`OpenerDirector` uses :class:"
"`UnknownHandler` to ensure this never happens)."
msgstr ""
"Обратите внимание, что ``None`` может быть возвращено, если ни один "
"обработчик не обрабатывает запрос (хотя установленный по умолчанию "
"глобальный :class:`OpenerDirector` использует :class:`UnknownHandler`, чтобы "
"гарантировать, что этого никогда не произойдет)."

#: ../../library/urllib.request.rst:79
msgid ""
"In addition, if proxy settings are detected (for example, when a ``*_proxy`` "
"environment variable like :envvar:`http_proxy` is set), :class:"
"`ProxyHandler` is default installed and makes sure the requests are handled "
"through the proxy."
msgstr ""

#: ../../library/urllib.request.rst:84
msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has been "
"discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a dictionary "
"parameter to ``urllib.urlopen``, can be obtained by using :class:"
"`ProxyHandler` objects."
msgstr ""
"Устаревшая функция urllib.urlopen из Python 2.6 и более ранних версий "
"прекращена; :func:`urllib.request.urlopen` соответствует старому ``urllib2."
"urlopen``. Обработку прокси, которая выполнялась путем передачи параметра "
"словаря в ``urllib.urlopen``, можно получить с помощью объектов :class:"
"`ProxyHandler`."

#: ../../library/urllib.request.rst:90
msgid ""
"Raises an :ref:`auditing event <auditing>` ``urllib.Request`` with arguments "
"``fullurl``, ``data``, ``headers``, ``method``."
msgstr ""

#: ../../library/urllib.request.rst:92
msgid ""
"The default opener raises an :ref:`auditing event <auditing>` ``urllib."
"Request`` with arguments ``fullurl``, ``data``, ``headers``, ``method`` "
"taken from the request object."
msgstr ""
"Средство открытия по умолчанию вызывает событие аудита <auditing>` urllib."
"Request`` с аргументами ``fullurl``, ``data``, ``headers``, ``method``, "
"взятыми из объект запроса."

#: ../../library/urllib.request.rst:96
msgid "*cafile* and *capath* were added."
msgstr "Были добавлены *cafile* и *capath*."

#: ../../library/urllib.request.rst:99
msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if :data:`ssl."
"HAS_SNI` is true)."
msgstr ""

#: ../../library/urllib.request.rst:103
msgid "*data* can be an iterable object."
msgstr "*data* может быть итерируемым объектом."

#: ../../library/urllib.request.rst:106
msgid "*cadefault* was added."
msgstr "*cadedefault* был добавлен."

#: ../../library/urllib.request.rst:109
msgid "*context* was added."
msgstr "*context* был добавлен."

#: ../../library/urllib.request.rst:112
msgid ""
"HTTPS connection now send an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN "
"protocols with :meth:`~ssl.SSLContext.set_alpn_protocol`."
msgstr ""

#: ../../library/urllib.request.rst:119
msgid ""
"*cafile*, *capath* and *cadefault* are deprecated in favor of *context*. "
"Please use :meth:`ssl.SSLContext.load_cert_chain` instead, or let :func:`ssl."
"create_default_context` select the system's trusted CA certificates for you."
msgstr ""
"*cafile*, *capath* и *cadefault* устарели в пользу *context*. Вместо этого "
"используйте :meth:`ssl.SSLContext.load_cert_chain` или позвольте :func:`ssl."
"create_default_context` выбрать за вас доверенные сертификаты CA системы."

#: ../../library/urllib.request.rst:127
msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener. "
"Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of :func:"
"`~urllib.request.urlopen`.  The code does not check for a real :class:"
"`OpenerDirector`, and any class with the appropriate interface will work."
msgstr ""
"Установите экземпляр :class:`OpenerDirector` в качестве глобального средства "
"открытия по умолчанию. Установка открывателя необходима только в том случае, "
"если вы хотите, чтобы urlopen использовал этот открыватель; в противном "
"случае просто вызовите :meth:`OpenerDirector.open` вместо :func:`~urllib."
"request.urlopen`. Код не проверяет настоящий :class:`OpenerDirector`, и "
"любой класс с соответствующим интерфейсом будет работать."

#: ../../library/urllib.request.rst:137
msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in the "
"order given. *handler*\\s can be either instances of :class:`BaseHandler`, "
"or subclasses of :class:`BaseHandler` (in which case it must be possible to "
"call the constructor without any parameters).  Instances of the following "
"classes will be in front of the *handler*\\s, unless the *handler*\\s "
"contain them, instances of them or subclasses of them: :class:`ProxyHandler` "
"(if proxy settings are detected), :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."
msgstr ""
"Возвращает экземпляр :class:`OpenerDirector`, который связывает обработчики "
"в указанном порядке. *handler*\\s могут быть либо экземплярами :class:"
"`BaseHandler`, либо подклассами :class:`BaseHandler` (в этом случае должна "
"быть возможность вызвать конструктор без каких-либо параметров). Экземпляры "
"следующих классов будут находиться перед *handler*\\s, если *handler*\\s не "
"содержит их, их экземпляров или их подклассов: :class:`ProxyHandler` (если "
"обнаружены настройки прокси), : class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."

#: ../../library/urllib.request.rst:147
msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` module "
"can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"Если установка Python имеет поддержку SSL (т. е. если модуль :mod:`ssl` "
"можно импортировать), :class:`HTTPSHandler` также будет добавлен."

#: ../../library/urllib.request.rst:150
msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order` "
"attribute to modify its position in the handlers list."
msgstr ""
"Подкласс :class:`BaseHandler` также может изменить свой атрибут :attr:"
"`handler_order`, чтобы изменить свою позицию в списке обработчиков."

#: ../../library/urllib.request.rst:156
msgid ""
"Convert the pathname *path* from the local syntax for a path to the form "
"used in the path component of a URL.  This does not produce a complete URL.  "
"The return value will already be quoted using the :func:`~urllib.parse."
"quote` function."
msgstr ""
"Преобразуйте имя пути *path* из локального синтаксиса пути в форму, "
"используемую в компоненте пути URL-адреса. Это не создает полный URL-адрес. "
"Возвращаемое значение уже будет заключено в кавычки с помощью функции :func:"
"`~urllib.parse.quote`."

#: ../../library/urllib.request.rst:163
msgid ""
"Convert the path component *path* from a percent-encoded URL to the local "
"syntax for a path.  This does not accept a complete URL.  This function "
"uses :func:`~urllib.parse.unquote` to decode *path*."
msgstr ""
"Преобразуйте компонент пути *path* из URL-адреса в процентном кодировании в "
"локальный синтаксис пути. Это не принимает полный URL-адрес. Эта функция "
"использует :func:`~urllib.parse.unquote` для декодирования *path*."

#: ../../library/urllib.request.rst:169
msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named ``<scheme>_proxy``, "
"in a case insensitive approach, for all operating systems first, and when it "
"cannot find it, looks for proxy information from System Configuration for "
"macOS and Windows Systems Registry for Windows. If both lowercase and "
"uppercase environment variables exist (and disagree), lowercase is preferred."
msgstr ""
"Эта вспомогательная функция возвращает словарь схем для сопоставлений URL-"
"адресов прокси-сервера. Он сканирует среду на наличие переменных с именем "
"``<scheme>_proxy``, используя подход без учета регистра, сначала для всех "
"операционных систем, а когда не может их найти, ищет информацию о прокси-"
"сервере в конфигурации системы для macOS и системном реестре Windows для "
"Windows. . Если существуют переменные среды как в нижнем, так и в верхнем "
"регистре (и не совпадают), предпочтительнее использовать строчные буквы."

#: ../../library/urllib.request.rst:179
msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" HTTP "
"header. If you need to use an HTTP proxy in a CGI environment, either use "
"``ProxyHandler`` explicitly, or make sure the variable name is in lowercase "
"(or at least the ``_proxy`` suffix)."
msgstr ""
"Если установлена ​​переменная среды REQUEST_METHOD, что обычно указывает на "
"то, что ваш скрипт работает в среде CGI, переменная среды HTTP_PROXY "
"(заглавные буквы _PROXY) будет игнорироваться. Это связано с тем, что эта "
"переменная может быть введена клиентом с помощью HTTP-заголовка «Proxy:». "
"Если вам нужно использовать HTTP-прокси в среде CGI, либо используйте "
"ProxyHandler явно, либо убедитесь, что имя переменной написано строчными "
"буквами (или, по крайней мере, суффиксом _proxy)."

#: ../../library/urllib.request.rst:188
msgid "The following classes are provided:"
msgstr "Предусмотрены следующие занятия:"

#: ../../library/urllib.request.rst:192
msgid "This class is an abstraction of a URL request."
msgstr "Этот класс представляет собой абстракцию URL-запроса."

#: ../../library/urllib.request.rst:194
msgid "*url* should be a string containing a valid URL."
msgstr ""

#: ../../library/urllib.request.rst:196
msgid ""
"*data* must be an object specifying additional data to send to the server, "
"or ``None`` if no such data is needed.  Currently HTTP requests are the only "
"ones that use *data*.  The supported object types include bytes, file-like "
"objects, and iterables of bytes-like objects. If no ``Content-Length`` nor "
"``Transfer-Encoding`` header field has been provided, :class:`HTTPHandler` "
"will set these headers according to the type of *data*.  ``Content-Length`` "
"will be used to send bytes objects, while ``Transfer-Encoding: chunked`` as "
"specified in :rfc:`7230`, Section 3.3.1 will be used to send files and other "
"iterables."
msgstr ""
"*data* должен быть объектом, определяющим дополнительные данные для отправки "
"на сервер, или ``None``, если такие данные не нужны. В настоящее время HTTP-"
"запросы — единственные, которые используют *данные*. Поддерживаемые типы "
"объектов включают байты, файловоподобные объекты и итерации байтоподобных "
"объектов. Если поле заголовка Content-Length или Transfer-Encoding не "
"указано, :class:HTTPHandler установит эти заголовки в соответствии с типом "
"*данных*. ``Content-Length`` будет использоваться для отправки байтовых "
"объектов, а ``Transfer-Encoding: chunked``, как указано в :rfc:`7230`, "
"раздел 3.3.1, будет использоваться для отправки файлов и других итераций."

#: ../../library/urllib.request.rst:206
msgid ""
"For an HTTP POST request method, *data* should be a buffer in the standard :"
"mimetype:`application/x-www-form-urlencoded` format.  The :func:`urllib."
"parse.urlencode` function takes a mapping or sequence of 2-tuples and "
"returns an ASCII string in this format. It should be encoded to bytes before "
"being used as the *data* parameter."
msgstr ""
"Для метода запроса HTTP POST *data* должен быть буфером в стандартном "
"формате :mimetype:`application/x-www-form-urlencoded`. Функция :func:`urllib."
"parse.urlencode` принимает отображение или последовательность двух кортежей "
"и возвращает строку ASCII в этом формате. Прежде чем использовать его в "
"качестве параметра *data*, его следует закодировать в байтах."

#: ../../library/urllib.request.rst:212
msgid ""
"*headers* should be a dictionary, and will be treated as if :meth:"
"`add_header` was called with each key and value as arguments. This is often "
"used to \"spoof\" the ``User-Agent`` header value, which is used by a "
"browser to identify itself -- some HTTP servers only allow requests coming "
"from common browsers as opposed to scripts. For example, Mozilla Firefox may "
"identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user agent string is "
"``\"Python-urllib/2.6\"`` (on Python 2.6). All header keys are sent in camel "
"case."
msgstr ""
"*headers* должен быть словарем и будет обрабатываться так, как если бы :meth:"
"`add_header` был вызван с каждым ключом и значением в качестве аргументов. "
"Это часто используется для «подмены» значения заголовка «User-Agent», "
"которое используется браузером для идентификации — некоторые HTTP-серверы "
"разрешают запросы, поступающие только от обычных браузеров, а не от "
"сценариев. Например, Mozilla Firefox может идентифицировать себя как "
"``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11\"``, в "
"то время как строка пользовательского агента по умолчанию для :mod:`urllib` "
"равна `` `\"Python-urllib/2.6\"`` (на Python 2.6). Все ключи заголовков "
"отправляются в верблюжьем футляре."

#: ../../library/urllib.request.rst:223
msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is not "
"None, ``Content-Type: application/x-www-form-urlencoded`` will be added as a "
"default."
msgstr ""

#: ../../library/urllib.request.rst:228
msgid ""
"The next two arguments are only of interest for correct handling of third-"
"party HTTP cookies:"
msgstr ""
"Следующие два аргумента интересны только для правильной обработки сторонних "
"файлов cookie HTTP:"

#: ../../library/urllib.request.rst:231
msgid ""
"*origin_req_host* should be the request-host of the origin transaction, as "
"defined by :rfc:`2965`.  It defaults to ``http.cookiejar."
"request_host(self)``.  This is the host name or IP address of the original "
"request that was initiated by the user. For example, if the request is for "
"an image in an HTML document, this should be the request-host of the request "
"for the page containing the image."
msgstr ""
"*origin_req_host* должен быть хостом запроса исходной транзакции, как "
"определено в :rfc:`2965`. По умолчанию используется ``http.cookiejar."
"request_host(self)``. Это имя хоста или IP-адрес исходного запроса, "
"инициированного пользователем. Например, если запрос касается изображения в "
"HTML-документе, это должен быть хост запроса страницы, содержащей "
"изображение."

#: ../../library/urllib.request.rst:239
msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable request "
"is one whose URL the user did not have the option to approve.  For example, "
"if the request is for an image in an HTML document, and the user had no "
"option to approve the automatic fetching of the image, this should be true."
msgstr ""
"*unverifying* должен указывать, является ли запрос непроверяемым, как "
"определено в :rfc:`2965`. По умолчанию установлено значение «False». "
"Непроверяемый запрос — это запрос, URL-адрес которого пользователь не смог "
"одобрить. Например, если запрос касается изображения в HTML-документе, и у "
"пользователя не было возможности одобрить автоматическое получение "
"изображения, это должно быть правдой."

#: ../../library/urllib.request.rst:246
msgid ""
"*method* should be a string that indicates the HTTP request method that will "
"be used (e.g. ``'HEAD'``).  If provided, its value is stored in the :attr:"
"`~Request.method` attribute and is used by :meth:`get_method()`. The default "
"is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. Subclasses may "
"indicate a different default method by setting the :attr:`~Request.method` "
"attribute in the class itself."
msgstr ""

#: ../../library/urllib.request.rst:254
msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP redirects "
"or authentication.  The *data* is sent to the HTTP server right away after "
"the headers.  There is no support for a 100-continue expectation in the "
"library."
msgstr ""
"Запрос не будет работать должным образом, если объект данных не может "
"доставить свое содержимое более одного раза (например, файл или итерируемый "
"объект, который может создать содержимое только один раз), и запрос "
"повторяется для перенаправления HTTP или аутентификации. *Данные* "
"отправляются на HTTP-сервер сразу после заголовков. В библиотеке нет "
"поддержки ожидания 100 продолжений."

#: ../../library/urllib.request.rst:261
msgid ":attr:`Request.method` argument is added to the Request class."
msgstr ":attr:`Аргумент Request.method` добавляется в класс Request."

#: ../../library/urllib.request.rst:264
msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr ""
"По умолчанию :attr:`Request.method` может быть указан на уровне класса."

#: ../../library/urllib.request.rst:267
msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and "
"*data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"Не выдавайте ошибку, если ``Content-Length`` не был предоставлен и *data* не "
"является ни ``None``, ни байтовым объектом. Вместо этого вернитесь к "
"использованию фрагментированного кодирования передачи."

#: ../../library/urllib.request.rst:274
msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s "
"chained together. It manages the chaining of handlers, and recovery from "
"errors."
msgstr ""
"Класс :class:`OpenerDirector` открывает URL-адреса через :class:"
"`BaseHandler`\\, связанные вместе. Он управляет цепочкой обработчиков и "
"восстановлением после ошибок."

#: ../../library/urllib.request.rst:280
msgid ""
"This is the base class for all registered handlers --- and handles only the "
"simple mechanics of registration."
msgstr ""
"Это базовый класс для всех зарегистрированных обработчиков, который "
"обрабатывает только простой механизм регистрации."

#: ../../library/urllib.request.rst:286
msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr ""
"Класс, который определяет обработчик по умолчанию для ответов об ошибках "
"HTTP; все ответы преобразуются в исключения :exc:`~urllib.error.HTTPError`."

#: ../../library/urllib.request.rst:292
msgid "A class to handle redirections."
msgstr "Класс для обработки перенаправлений."

#: ../../library/urllib.request.rst:297
msgid "A class to handle HTTP Cookies."
msgstr "Класс для обработки файлов cookie HTTP."

#: ../../library/urllib.request.rst:302
msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a "
"dictionary mapping protocol names to URLs of proxies. The default is to read "
"the list of proxies from the environment variables ``<protocol>_proxy``.  If "
"no proxy environment variables are set, then in a Windows environment proxy "
"settings are obtained from the registry's Internet Settings section, and in "
"a macOS environment proxy information is retrieved from the System "
"Configuration Framework."
msgstr ""
"Заставить запросы проходить через прокси. Если указано *proxies*, это должен "
"быть словарь, сопоставляющий имена протоколов с URL-адресами прокси. По "
"умолчанию список прокси считывается из переменных среды "
"``<protocol>_proxy``. Если переменные среды прокси-сервера не заданы, то в "
"среде Windows настройки прокси-сервера получаются из раздела «Настройки "
"Интернета» реестра, а в среде macOS информация о прокси-сервере извлекается "
"из платформы конфигурации системы."

#: ../../library/urllib.request.rst:310
msgid "To disable autodetected proxy pass an empty dictionary."
msgstr ""
"Чтобы отключить автоматически определяемый прокси-сервер, передайте пустой "
"словарь."

#: ../../library/urllib.request.rst:312
msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-separated "
"list of hostname suffixes, optionally with ``:port`` appended, for example "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
"Переменная среды :envvar:`no_proxy` может использоваться для указания "
"хостов, к которым не следует обращаться через прокси; если установлено, это "
"должен быть список суффиксов имен хостов, разделенных запятыми, возможно с "
"добавлением ``:port``, например ``cern.ch,ncsa.uiuc.edu,some.host:8080``."

#: ../../library/urllib.request.rst:319
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` будет игнорироваться, если установлена ​​переменная "
"``REQUEST_METHOD``; см. документацию по :func:`~urllib.request.getproxies`."

#: ../../library/urllib.request.rst:325
msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr ""
"Сохраните базу данных сопоставлений ``(область, uri) -> (пользователь, "
"пароль)``."

#: ../../library/urllib.request.rst:330
msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm "
"of ``None`` is considered a catch-all realm, which is searched if no other "
"realm fits."
msgstr ""
"Сохраните базу данных сопоставлений ``(область, uri) -> (пользователь, "
"пароль)``. Область «Нет» считается универсальной областью, в которой "
"выполняется поиск, если ни одна другая область не подходит."

#: ../../library/urllib.request.rst:337
msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
"Вариант :class:`HTTPPasswordMgrWithDefaultRealm`, который также имеет базу "
"данных сопоставлений ``uri -> is_authenticated``. Может использоваться "
"обработчиком BasicAuth, чтобы определить, когда отправлять учетные данные "
"для аутентификации немедленно, вместо того, чтобы сначала ждать ответа 401."

#: ../../library/urllib.request.rst:347
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials are "
"not sent, and then if a ``401`` response is received the request is re-sent "
"with the authentication credentials.  If authentication succeeds, "
"``update_authenticated`` is called to set ``is_authenticated`` ``True`` for "
"the URI, so that subsequent requests to the URI or any of its super-URIs "
"will automatically include the authentication credentials."
msgstr ""
"Это класс-примесь, который помогает с аутентификацией HTTP как на удаленном "
"хосте, так и на прокси-сервере. *password_mgr*, если он указан, должен быть "
"совместимым с :class:`HTTPPasswordMgr`; обратитесь к разделу :ref:`http-"
"password-mgr` для получения информации об интерфейсе, который должен "
"поддерживаться. Если *passwd_mgr* также предоставляет методы "
"is_authenticated и update_authenticated (см. :ref:`http-password-mgr-with-"
"prior-auth`), то обработчик будет использовать результат is_authenticated``. "
"для данного URI, чтобы определить, отправлять ли учетные данные "
"аутентификации вместе с запросом. Если is_authenticated возвращает True для "
"URI, учетные данные отправляются. Если is_authenticated имеет значение "
"False, учетные данные не отправляются, а затем, если получен ответ 401, "
"запрос отправляется повторно с учетными данными аутентификации. Если "
"аутентификация прошла успешно, вызывается update_authenticated, чтобы "
"установить is_authenticated ``True`` для URI, чтобы последующие запросы к "
"URI или любому из его супер-URI автоматически включали учетные данные "
"аутентификации."

#: ../../library/urllib.request.rst:364
msgid "Added ``is_authenticated`` support."
msgstr "Добавлена поддержка ``is_authenticated``."

#: ../../library/urllib.request.rst:370
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. HTTPBasicAuthHandler will raise a :exc:`ValueError` when "
"presented with a wrong Authentication scheme."
msgstr ""
"Обработка аутентификации на удаленном хосте. *password_mgr*, если он указан, "
"должен быть совместимым с :class:`HTTPPasswordMgr`; обратитесь к разделу :"
"ref:`http-password-mgr` для получения информации об интерфейсе, который "
"должен поддерживаться. HTTPBasicAuthHandler выдаст ошибку :exc:`ValueError` "
"при представлении неправильной схемы аутентификации."

#: ../../library/urllib.request.rst:379 ../../library/urllib.request.rst:413
msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be "
"something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported."
msgstr ""
"Обработка аутентификации с помощью прокси. *password_mgr*, если он указан, "
"должен быть совместимым с :class:`HTTPPasswordMgr`; обратитесь к разделу :"
"ref:`http-password-mgr` для получения информации об интерфейсе, который "
"должен поддерживаться."

#: ../../library/urllib.request.rst:387
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be supported."
msgstr ""
"Это класс-примесь, который помогает с аутентификацией HTTP как на удаленном "
"хосте, так и на прокси-сервере. *password_mgr*, если он указан, должен быть "
"совместимым с :class:`HTTPPasswordMgr`; обратитесь к разделу :ref:`http-"
"password-mgr` для получения информации об интерфейсе, который должен "
"поддерживаться."

#: ../../library/urllib.request.rst:396
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. When both Digest Authentication Handler and Basic "
"Authentication Handler are both added, Digest Authentication is always tried "
"first. If the Digest Authentication returns a 40x response again, it is sent "
"to Basic Authentication handler to Handle.  This Handler method will raise "
"a :exc:`ValueError` when presented with an authentication scheme other than "
"Digest or Basic."
msgstr ""
"Обработка аутентификации на удаленном хосте. *password_mgr*, если он указан, "
"должен быть совместимым с :class:`HTTPPasswordMgr`; обратитесь к разделу :"
"ref:`http-password-mgr` для получения информации об интерфейсе, который "
"должен поддерживаться. Если добавлены и обработчик дайджест-аутентификации, "
"и базовый обработчик аутентификации, сначала всегда пробуется дайджест-"
"аутентификация. Если дайджест-аутентификация снова возвращает ответ 40x, он "
"отправляется обработчику базовой аутентификации для обработки. Этот метод "
"Handler вызовет :exc:`ValueError` при использовании схемы аутентификации, "
"отличной от Digest или Basic."

#: ../../library/urllib.request.rst:406
msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "Вызовите :exc:`ValueError` для неподдерживаемой схемы аутентификации."

#: ../../library/urllib.request.rst:421
msgid "A class to handle opening of HTTP URLs."
msgstr "Класс для обработки открытия URL-адресов HTTP."

#: ../../library/urllib.request.rst:426
msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"Класс для открытия URL-адресов HTTPS. *context* и *check_hostname* имеют то "
"же значение, что и в :class:`http.client.HTTPSConnection`."

#: ../../library/urllib.request.rst:429
msgid "*context* and *check_hostname* were added."
msgstr "Были добавлены *context* и *check_hostname*."

#: ../../library/urllib.request.rst:435
msgid "Open local files."
msgstr "Откройте локальные файлы."

#: ../../library/urllib.request.rst:439
msgid "Open data URLs."
msgstr "URL-адреса открытых данных."

#: ../../library/urllib.request.rst:445
msgid "Open FTP URLs."
msgstr "Открыть URL-адреса FTP."

#: ../../library/urllib.request.rst:450
msgid ""
"Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr ""
"Открытые URL-адреса FTP, сохраняя кеш открытых FTP-соединений для "
"минимизации задержек."

#: ../../library/urllib.request.rst:455
msgid "A catch-all class to handle unknown URLs."
msgstr "Универсальный класс для обработки неизвестных URL-адресов."

#: ../../library/urllib.request.rst:460 ../../library/urllib.request.rst:1156
msgid "Process HTTP error responses."
msgstr "Обработка ответов об ошибках HTTP."

#: ../../library/urllib.request.rst:466
msgid "Request Objects"
msgstr "Объекты запроса"

#: ../../library/urllib.request.rst:468
msgid ""
"The following methods describe :class:`Request`'s public interface, and so "
"all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"Следующие методы описывают общедоступный интерфейс :class:`Request`, поэтому "
"все они могут быть переопределены в подклассах. Он также определяет "
"несколько общедоступных атрибутов, которые могут использоваться клиентами "
"для проверки проанализированного запроса."

#: ../../library/urllib.request.rst:475
msgid "The original URL passed to the constructor."
msgstr "Исходный URL-адрес передается конструктору."

#: ../../library/urllib.request.rst:479
msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting :"
"attr:`~Request.full_url` returns the original request URL with the fragment, "
"if it was present."
msgstr ""
"Request.full_url — это свойство с установщиком, геттером и удалением. "
"Получение :attr:`~Request.full_url` возвращает исходный URL-адрес запроса с "
"фрагментом, если он присутствовал."

#: ../../library/urllib.request.rst:485
msgid "The URI scheme."
msgstr "Схема URI."

#: ../../library/urllib.request.rst:489
msgid ""
"The URI authority, typically a host, but may also contain a port separated "
"by a colon."
msgstr ""
"Центр URI, обычно хост, но может также содержать порт, разделенный "
"двоеточием."

#: ../../library/urllib.request.rst:494
msgid "The original host for the request, without port."
msgstr "Исходный хост запроса без порта."

#: ../../library/urllib.request.rst:498
msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will be "
"the full URL that is passed to the proxy."
msgstr ""
"Путь URI. Если :class:`Request` использует прокси, то селектором будет "
"полный URL-адрес, передаваемый прокси."

#: ../../library/urllib.request.rst:503
msgid "The entity body for the request, or ``None`` if not specified."
msgstr "Тело объекта запроса или None, если не указано."

#: ../../library/urllib.request.rst:505
msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" header "
"if it was previously set or calculated."
msgstr ""
"Изменение значения :attr:`Request.data` теперь удаляет заголовок «Content-"
"Length», если он был ранее установлен или рассчитан."

#: ../../library/urllib.request.rst:511
msgid ""
"boolean, indicates whether the request is unverifiable as defined by :rfc:"
"`2965`."
msgstr ""
"логическое значение, указывает, является ли запрос непроверяемым, как "
"определено в :rfc:`2965`."

#: ../../library/urllib.request.rst:516
msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal computation "
"of the method to be used.  Its value can be set (thus overriding the default "
"computation in :meth:`~Request.get_method`) either by providing a default "
"value by setting it at the class level in a :class:`Request` subclass, or by "
"passing a value in to the :class:`Request` constructor via the *method* "
"argument."
msgstr ""
"Используемый метод HTTP-запроса. По умолчанию его значение — :const:`None`, "
"что означает, что :meth:`~Request.get_method` будет выполнять обычные "
"вычисления метода, который будет использоваться. Его значение может быть "
"установлено (таким образом, переопределяя вычисления по умолчанию в :meth:"
"`~Request.get_method`) либо путем предоставления значения по умолчанию, "
"установив его на уровне класса в подклассе :class:`Request`, либо путем "
"передачи значения в конструктор :class:`Request` через аргумент *method*."

#: ../../library/urllib.request.rst:526
msgid ""
"A default value can now be set in subclasses; previously it could only be "
"set via the constructor argument."
msgstr ""
"Значение по умолчанию теперь можно установить в подклассах; раньше его можно "
"было установить только через аргумент конструктора."

#: ../../library/urllib.request.rst:533
msgid ""
"Return a string indicating the HTTP request method.  If :attr:`Request."
"method` is not ``None``, return its value, otherwise return ``'GET'`` if :"
"attr:`Request.data` is ``None``, or ``'POST'`` if it's not. This is only "
"meaningful for HTTP requests."
msgstr ""
"Возвращает строку, указывающую метод HTTP-запроса. Если :attr:`Request."
"method` не ``None``, верните его значение, в противном случае верните "
"``'GET'``, если :attr:`Request.data` имеет значение ``None`` или ``' "
"POST'``, если это не так. Это имеет смысл только для HTTP-запросов."

#: ../../library/urllib.request.rst:538
msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "get_method теперь смотрит на значение :attr:`Request.method`."

#: ../../library/urllib.request.rst:544
msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of headers "
"sent to the server.  Note that there cannot be more than one header with the "
"same name, and later calls will overwrite previous calls in case the *key* "
"collides. Currently, this is no loss of HTTP functionality, since all "
"headers which have meaning when used more than once have a (header-specific) "
"way of gaining the same functionality using only one header.  Note that "
"headers added using this method are also added to redirected requests."
msgstr ""
"Добавьте в запрос еще один заголовок. Заголовки в настоящее время "
"игнорируются всеми обработчиками, кроме обработчиков HTTP, где они "
"добавляются в список заголовков, отправляемых на сервер. Обратите внимание, "
"что не может быть более одного заголовка с одним и тем же именем, и "
"последующие вызовы перезапишут предыдущие вызовы в случае конфликта *key*. В "
"настоящее время это не является потерей функциональности HTTP, поскольку все "
"заголовки, которые имеют значение при многократном использовании, имеют "
"(специфичный для заголовка) способ получить ту же функциональность, "
"используя только один заголовок. Обратите внимание, что заголовки, "
"добавленные с помощью этого метода, также добавляются к перенаправленным "
"запросам."

#: ../../library/urllib.request.rst:556
msgid "Add a header that will not be added to a redirected request."
msgstr ""
"Добавьте заголовок, который не будет добавлен в перенаправленный запрос."

#: ../../library/urllib.request.rst:561
msgid ""
"Return whether the instance has the named header (checks both regular and "
"unredirected)."
msgstr ""
"Возвращает информацию о том, имеет ли экземпляр именованный заголовок "
"(проверяется как обычный, так и неперенаправленный)."

#: ../../library/urllib.request.rst:567
msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr ""
"Удалить именованный заголовок из экземпляра запроса (как из обычных, так и "
"из неперенаправленных заголовков)."

#: ../../library/urllib.request.rst:575
msgid "Return the URL given in the constructor."
msgstr "Верните URL-адрес, указанный в конструкторе."

#: ../../library/urllib.request.rst:579
msgid "Returns :attr:`Request.full_url`"
msgstr "Возвращает :attr:`Request.full_url`"

#: ../../library/urllib.request.rst:584
msgid ""
"Prepare the request by connecting to a proxy server. The *host* and *type* "
"will replace those of the instance, and the instance's selector will be the "
"original URL given in the constructor."
msgstr ""
"Подготовьте запрос, подключившись к прокси-серверу. *host* и *type* заменят "
"значения экземпляра, а селектором экземпляра будет исходный URL-адрес, "
"указанный в конструкторе."

#: ../../library/urllib.request.rst:591
msgid ""
"Return the value of the given header. If the header is not present, return "
"the default value."
msgstr ""
"Вернуть значение данного заголовка. Если заголовок отсутствует, верните "
"значение по умолчанию."

#: ../../library/urllib.request.rst:597
msgid ""
"Return a list of tuples (header_name, header_value) of the Request headers."
msgstr ""
"Возвращает список кортежей (имя_заголовка, значение_заголовка) заголовков "
"запроса."

#: ../../library/urllib.request.rst:599
msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were deprecated "
"since 3.3 have been removed."
msgstr ""
"Методы запроса add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host и is_unverifying, которые устарели с "
"версии 3.3, были удалены."

#: ../../library/urllib.request.rst:608
msgid "OpenerDirector Objects"
msgstr "Объекты OpenerDirector"

#: ../../library/urllib.request.rst:610
msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr "Экземпляры :class:`OpenerDirector` имеют следующие методы:"

#: ../../library/urllib.request.rst:615
msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* should "
"be replaced with the actual protocol to handle, for example :meth:"
"`http_response` would be the HTTP protocol response handler.  Also *type* "
"should be replaced with the actual HTTP code, for example :meth:"
"`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler* должен быть экземпляром :class:`BaseHandler`. Следующие методы "
"ищутся и добавляются к возможным цепочкам (обратите внимание, что ошибки "
"HTTP — это особый случай). Обратите внимание, что в дальнейшем *protocol* "
"следует заменить фактическим обрабатываемым протоколом, например :meth:"
"`http_response` будет обработчиком ответа протокола HTTP. Также *type* "
"следует заменить фактическим кодом HTTP, например :meth:`http_error_404` "
"будет обрабатывать ошибки HTTP 404."

#: ../../library/urllib.request.rst:623
msgid ""
":meth:`<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ""

#: ../../library/urllib.request.rst:626
msgid "See |protocol_open|_ for more information."
msgstr "Видеть |протокол_открытый|_ для получения дополнительной информации."

#: ../../library/urllib.request.rst:628
msgid ""
":meth:`http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""

#: ../../library/urllib.request.rst:631
msgid "See |http_error_nnn|_ for more information."
msgstr "Видеть |http_error_nnn|_ для получения дополнительной информации."

#: ../../library/urllib.request.rst:633
msgid ""
":meth:`<protocol>_error` --- signal that the handler knows how to handle "
"errors from (non-\\ ``http``) *protocol*."
msgstr ""

#: ../../library/urllib.request.rst:636
msgid ""
":meth:`<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ""

#: ../../library/urllib.request.rst:639
msgid "See |protocol_request|_ for more information."
msgstr "Видеть |запрос_протокола|_ для получения дополнительной информации."

#: ../../library/urllib.request.rst:641
msgid ""
":meth:`<protocol>_response` --- signal that the handler knows how to post-"
"process *protocol* responses."
msgstr ""

#: ../../library/urllib.request.rst:644
msgid "See |protocol_response|_ for more information."
msgstr "Видеть |ответ_протокола|_ для получения дополнительной информации."

#: ../../library/urllib.request.rst:653
msgid ""
"Open the given *url* (which can be a request object or a string), optionally "
"passing the given *data*. Arguments, return values and exceptions raised are "
"the same as those of :func:`urlopen` (which simply calls the :meth:`open` "
"method on the currently installed global :class:`OpenerDirector`).  The "
"optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used). The timeout feature actually works only for "
"HTTP, HTTPS and FTP connections."
msgstr ""
"Откройте данный *url* (который может быть объектом запроса или строкой), при "
"необходимости передав указанные *данные*. Аргументы, возвращаемые значения и "
"возникающие исключения такие же, как у :func:`urlopen` (который просто "
"вызывает метод :meth:`open` для текущего установленного глобального :class:"
"`OpenerDirector`). Необязательный параметр *timeout* указывает тайм-аут в "
"секундах для блокировки таких операций, как попытка подключения (если он не "
"указан, будет использоваться глобальная настройка тайм-аута по умолчанию). "
"Функция тайм-аута фактически работает только для соединений HTTP, HTTPS и "
"FTP."

#: ../../library/urllib.request.rst:665
msgid ""
"Handle an error of the given protocol.  This will call the registered error "
"handlers for the given protocol with the given arguments (which are protocol "
"specific).  The HTTP protocol is a special case which uses the HTTP response "
"code to determine the specific error handler; refer to the :meth:"
"`http_error_\\<type\\>` methods of the handler classes."
msgstr ""

#: ../../library/urllib.request.rst:671
msgid ""
"Return values and exceptions raised are the same as those of :func:`urlopen`."
msgstr ""
"Возвращаемые значения и возникающие исключения такие же, как у :func:"
"`urlopen`."

#: ../../library/urllib.request.rst:673
msgid "OpenerDirector objects open URLs in three stages:"
msgstr "Объекты OpenerDirector открывают URL-адреса в три этапа:"

#: ../../library/urllib.request.rst:675
msgid ""
"The order in which these methods are called within each stage is determined "
"by sorting the handler instances."
msgstr ""
"Порядок вызова этих методов на каждом этапе определяется путем сортировки "
"экземпляров обработчика."

#: ../../library/urllib.request.rst:678
msgid ""
"Every handler with a method named like :meth:`<protocol>_request` has that "
"method called to pre-process the request."
msgstr ""

#: ../../library/urllib.request.rst:681
msgid ""
"Handlers with a method named like :meth:`<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a non-\\ :"
"const:`None` value (ie. a response), or raises an exception (usually :exc:"
"`~urllib.error.URLError`).  Exceptions are allowed to propagate."
msgstr ""

#: ../../library/urllib.request.rst:686
msgid ""
"In fact, the above algorithm is first tried for methods named :meth:"
"`default_open`.  If all such methods return :const:`None`, the algorithm is "
"repeated for methods named like :meth:`<protocol>_open`.  If all such "
"methods return :const:`None`, the algorithm is repeated for methods named :"
"meth:`unknown_open`."
msgstr ""

#: ../../library/urllib.request.rst:692
msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and :"
"meth:`~OpenerDirector.error` methods."
msgstr ""
"Обратите внимание, что реализация этих методов может включать вызовы "
"методов :meth:`~OpenerDirector.open` и :meth:`~OpenerDirector.error` "
"родительского экземпляра :class:`OpenerDirector`."

#: ../../library/urllib.request.rst:696
msgid ""
"Every handler with a method named like :meth:`<protocol>_response` has that "
"method called to post-process the response."
msgstr ""

#: ../../library/urllib.request.rst:703
msgid "BaseHandler Objects"
msgstr "Объекты BaseHandler"

#: ../../library/urllib.request.rst:705
msgid ""
":class:`BaseHandler` objects provide a couple of methods that are directly "
"useful, and others that are meant to be used by derived classes.  These are "
"intended for direct use:"
msgstr ""
"Объекты :class:`BaseHandler` предоставляют несколько методов, которые "
"непосредственно полезны, а также другие, предназначенные для использования "
"производными классами. Они предназначены для прямого использования:"

#: ../../library/urllib.request.rst:712
msgid "Add a director as parent."
msgstr "Добавьте директора в качестве родителя."

#: ../../library/urllib.request.rst:717
msgid "Remove any parents."
msgstr "Удалите всех родителей."

#: ../../library/urllib.request.rst:719
msgid ""
"The following attribute and methods should only be used by classes derived "
"from :class:`BaseHandler`."
msgstr ""
"Следующий атрибут и методы должны использоваться только классами, "
"производными от :class:`BaseHandler`."

#: ../../library/urllib.request.rst:724
msgid ""
"The convention has been adopted that subclasses defining :meth:"
"`<protocol>_request` or :meth:`<protocol>_response` methods are named :class:"
"`\\*Processor`; all others are named :class:`\\*Handler`."
msgstr ""

#: ../../library/urllib.request.rst:731
msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a different "
"protocol, or handle errors."
msgstr ""
"Действительный :class:`OpenerDirector`, который можно использовать для "
"открытия с использованием другого протокола или обработки ошибок."

#: ../../library/urllib.request.rst:737
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs."
msgstr ""
"Этот метод *не* определен в :class:`BaseHandler`, но подклассы должны "
"определять его, если они хотят перехватывать все URL-адреса."

#: ../../library/urllib.request.rst:740
msgid ""
"This method, if implemented, will be called by the parent :class:"
"`OpenerDirector`.  It should return a file-like object as described in the "
"return value of the :meth:`~OpenerDirector.open` method of :class:"
"`OpenerDirector`, or ``None``. It should raise :exc:`~urllib.error."
"URLError`, unless a truly exceptional thing happens (for example, :exc:"
"`MemoryError` should not be mapped to :exc:`URLError`)."
msgstr ""

#: ../../library/urllib.request.rst:747
msgid "This method will be called before any protocol-specific open method."
msgstr ""
"Этот метод будет вызываться перед любым открытым методом, специфичным для "
"протокола."

#: ../../library/urllib.request.rst:754
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to handle URLs with the given protocol."
msgstr ""
"Этот метод *не* определен в :class:`BaseHandler`, но подклассы должны "
"определять его, если они хотят обрабатывать URL-адреса с помощью данного "
"протокола."

#: ../../library/urllib.request.rst:757
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. Return values should be the same as for  :meth:"
"`default_open`."
msgstr ""

#: ../../library/urllib.request.rst:763
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs with no specific registered handler "
"to open it."
msgstr ""
"Этот метод *не* определен в :class:`BaseHandler`, но подклассы должны "
"определять его, если они хотят перехватывать все URL-адреса без "
"определенного зарегистрированного обработчика для его открытия."

#: ../../library/urllib.request.rst:767
msgid ""
"This method, if implemented, will be called by the :attr:`parent` :class:"
"`OpenerDirector`.  Return values should be the same as for :meth:"
"`default_open`."
msgstr ""
"Этот метод, если он реализован, будет вызываться :attr:`parent` :class:"
"`OpenerDirector`. Возвращаемые значения должны быть такими же, как для :meth:"
"`default_open`."

#: ../../library/urllib.request.rst:774
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"override it if they intend to provide a catch-all for otherwise unhandled "
"HTTP errors.  It will be called automatically by the  :class:"
"`OpenerDirector` getting the error, and should not normally be called in "
"other circumstances."
msgstr ""
"Этот метод *не* определен в :class:`BaseHandler`, но подклассы должны "
"переопределять его, если они намерены обеспечить комплексный подход к "
"необработанным в противном случае ошибкам HTTP. Он будет вызван "
"автоматически :class:`OpenerDirector`, получившим ошибку, и обычно его не "
"следует вызывать в других обстоятельствах."

#: ../../library/urllib.request.rst:779
msgid ""
"*req* will be a :class:`Request` object, *fp* will be a file-like object "
"with the HTTP error body, *code* will be the three-digit code of the error, "
"*msg* will be the user-visible explanation of the code and *hdrs* will be a "
"mapping object with the headers of the error."
msgstr ""
"*req* будет объектом :class:`Request`, *fp* будет файловым объектом с телом "
"ошибки HTTP, *code* будет трехзначным кодом ошибки, *msg* будет видимое "
"пользователю объяснение кода, а *hdrs* будет объектом сопоставления с "
"заголовками ошибки."

#: ../../library/urllib.request.rst:784
msgid ""
"Return values and exceptions raised should be the same as those of :func:"
"`urlopen`."
msgstr ""
"Возвращаемые значения и возникающие исключения должны быть такими же, как у :"
"func:`urlopen`."

#: ../../library/urllib.request.rst:791
msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn* должен быть трехзначным кодом ошибки HTTP. Этот метод также не "
"определен в :class:`BaseHandler`, но будет вызываться, если он существует, в "
"экземпляре подкласса, когда возникает ошибка HTTP с кодом *nnn*."

#: ../../library/urllib.request.rst:795
msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr ""
"Подклассы должны переопределять этот метод для обработки определенных ошибок "
"HTTP."

#: ../../library/urllib.request.rst:797
msgid ""
"Arguments, return values and exceptions raised should be the same as for :"
"meth:`http_error_default`."
msgstr ""

#: ../../library/urllib.request.rst:805
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to pre-process requests of the given protocol."
msgstr ""
"Этот метод *не* определен в :class:`BaseHandler`, но подклассы должны "
"определять его, если они хотят предварительно обрабатывать запросы данного "
"протокола."

#: ../../library/urllib.request.rst:808
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. The return value "
"should be a :class:`Request` object."
msgstr ""
"Этот метод, если он определен, будет вызываться родительским :class:"
"`OpenerDirector`. *req* будет объектом :class:`Request`. Возвращаемое "
"значение должно быть объектом :class:`Request`."

#: ../../library/urllib.request.rst:817
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to post-process responses of the given protocol."
msgstr ""
"Этот метод *не* определен в :class:`BaseHandler`, но подклассы должны "
"определять его, если они хотят постобрабатывать ответы данного протокола."

#: ../../library/urllib.request.rst:820
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. *response* will "
"be an object implementing the same interface as the return value of :func:"
"`urlopen`.  The return value should implement the same interface as the "
"return value of :func:`urlopen`."
msgstr ""
"Этот метод, если он определен, будет вызываться родительским :class:"
"`OpenerDirector`. *req* будет объектом :class:`Request`. *response* будет "
"объектом, реализующим тот же интерфейс, что и возвращаемое значение :func:"
"`urlopen`. Возвращаемое значение должно реализовывать тот же интерфейс, что "
"и возвращаемое значение :func:`urlopen`."

#: ../../library/urllib.request.rst:830
msgid "HTTPRedirectHandler Objects"
msgstr "Объекты HTTPRedirectHandler"

#: ../../library/urllib.request.rst:834
msgid ""
"Some HTTP redirections require action from this module's client code.  If "
"this is the case, :exc:`~urllib.error.HTTPError` is raised.  See :rfc:`2616` "
"for details of the precise meanings of the various redirection codes."
msgstr ""
"Некоторые перенаправления HTTP требуют действий со стороны клиентского кода "
"этого модуля. В этом случае возникает :exc:`~urllib.error.HTTPError`. См. :"
"rfc:`2616` для получения подробной информации о точном значении различных "
"кодов перенаправления."

#: ../../library/urllib.request.rst:838
msgid ""
"An :class:`HTTPError` exception raised as a security consideration if the "
"HTTPRedirectHandler is presented with a redirected URL which is not an HTTP, "
"HTTPS or FTP URL."
msgstr ""

#: ../../library/urllib.request.rst:845
msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection "
"should take place, return a new :class:`Request` to allow :meth:"
"`http_error_30\\*` to perform the redirect to *newurl*.  Otherwise, raise :"
"exc:`~urllib.error.HTTPError` if no other handler should try to handle this "
"URL, or return ``None`` if you can't but another handler might."
msgstr ""

#: ../../library/urllib.request.rst:855
msgid ""
"The default implementation of this method does not strictly follow :rfc:"
"`2616`, which says that 301 and 302 responses to ``POST`` requests must not "
"be automatically redirected without confirmation by the user.  In reality, "
"browsers do allow automatic redirection of these responses, changing the "
"POST to a ``GET``, and the default implementation reproduces this behavior."
msgstr ""
"Реализация этого метода по умолчанию не строго соответствует :rfc:`2616`, в "
"котором говорится, что ответы 301 и 302 на запросы POST не должны "
"автоматически перенаправляться без подтверждения пользователя. На самом деле "
"браузеры допускают автоматическое перенаправление этих ответов, заменяя POST "
"на GET, и реализация по умолчанию воспроизводит это поведение."

#: ../../library/urllib.request.rst:864
msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the "
"parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' "
"response."
msgstr ""
"Перенаправление на URL-адрес ``Location:`` или ``URI:``. Этот метод "
"вызывается родительским классом OpenerDirector при получении HTTP-ответа "
"«перемещено навсегда»."

#: ../../library/urllib.request.rst:870
msgid ""
"The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr "То же, что и :meth:`http_error_301`, но вызывает ответ «найден»."

#: ../../library/urllib.request.rst:875
msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' response."
msgstr ""
"То же, что и :meth:`http_error_301`, но требует ответа «посмотреть другое»."

#: ../../library/urllib.request.rst:880
msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary redirect' "
"response."
msgstr ""

#: ../../library/urllib.request.rst:887
msgid "HTTPCookieProcessor Objects"
msgstr "Объекты HTTPCookieProcessor"

#: ../../library/urllib.request.rst:889
msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr "Экземпляры :class:`HTTPCookieProcessor` имеют один атрибут:"

#: ../../library/urllib.request.rst:893
msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr ":class:`http.cookiejar.CookieJar`, в котором хранятся файлы cookie."

#: ../../library/urllib.request.rst:899
msgid "ProxyHandler Objects"
msgstr "Объекты ProxyHandler"

#: ../../library/urllib.request.rst:905
msgid ""
"The :class:`ProxyHandler` will have a method :meth:`<protocol>_open` for "
"every *protocol* which has a proxy in the *proxies* dictionary given in the "
"constructor.  The method will modify requests to go through the proxy, by "
"calling ``request.set_proxy()``, and call the next handler in the chain to "
"actually execute the protocol."
msgstr ""

#: ../../library/urllib.request.rst:915
msgid "HTTPPasswordMgr Objects"
msgstr "Объекты HTTPPasswordMgr"

#: ../../library/urllib.request.rst:917
msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and :class:"
"`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"Эти методы доступны для объектов :class:`HTTPPasswordMgr` и :class:"
"`HTTPPasswordMgrWithDefaultRealm`."

#: ../../library/urllib.request.rst:923
msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* and "
"*passwd* must be strings. This causes ``(user, passwd)`` to be used as "
"authentication tokens when authentication for *realm* and a super-URI of any "
"of the given URIs is given."
msgstr ""
"*uri* может быть либо одним URI, либо последовательностью URI. *realm*, "
"*user* и *passwd* должны быть строками. Это приводит к использованию "
"``(user, passwd)`` в качестве токенов аутентификации при аутентификации для "
"*realm* и супер-URI любого из заданных URI."

#: ../../library/urllib.request.rst:931
msgid ""
"Get user/password for given realm and URI, if any.  This method will return "
"``(None, None)`` if there is no matching user/password."
msgstr ""
"Получите пользователя/пароль для данной области и URI, если таковой имеется. "
"Этот метод вернет ``(None, None)``, если нет подходящего пользователя/пароля."

#: ../../library/urllib.request.rst:934
msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
"Для объектов :class:`HTTPPasswordMgrWithDefaultRealm` будет выполняться "
"поиск в области ``None``, если в данной *области* нет соответствующего "
"пользователя/пароля."

#: ../../library/urllib.request.rst:941
msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "Объекты HTTPPasswordMgrWithPriorAuth"

#: ../../library/urllib.request.rst:943
msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to "
"support tracking URIs for which authentication credentials should always be "
"sent."
msgstr ""
"Этот менеджер паролей расширяет :class:`HTTPPasswordMgrWithDefaultRealm` для "
"поддержки отслеживания URI, для которых всегда должны отправляться учетные "
"данные аутентификации."

#: ../../library/urllib.request.rst:950
msgid ""
"*realm*, *uri*, *user*, *passwd* are as for :meth:`HTTPPasswordMgr."
"add_password`.  *is_authenticated* sets the initial value of the "
"``is_authenticated`` flag for the given URI or list of URIs. If "
"*is_authenticated* is specified as ``True``, *realm* is ignored."
msgstr ""
"*realm*, *uri*, *user*, *passwd* аналогичны :meth:`HTTPPasswordMgr."
"add_password`. *is_authenticated* устанавливает начальное значение флага "
"is_authenticated для данного URI или списка URI. Если для *is_authenticated* "
"указано ``True``, *realm* игнорируется."

#: ../../library/urllib.request.rst:958
msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr "То же, что и для объектов :class:`HTTPPasswordMgrWithDefaultRealm`"

#: ../../library/urllib.request.rst:964
msgid ""
"Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr "Обновите флаг is_authenticated для данного *uri* или списка URI."

#: ../../library/urllib.request.rst:970
msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given URI."
msgstr "Возвращает текущее состояние флага is_authenticated для данного URI."

#: ../../library/urllib.request.rst:977
msgid "AbstractBasicAuthHandler Objects"
msgstr "Объекты AbstractBasicAuthHandler"

#: ../../library/urllib.request.rst:982
msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the "
"information about the realm is included in the request, *host* specifies the "
"URL and path to authenticate for, *req* should be the (failed) :class:"
"`Request` object, and *headers* should be the error headers."
msgstr ""
"Обработайте запрос аутентификации, получив пару пользователь/пароль и "
"повторив запрос. *authreq* должно быть именем заголовка, в котором в запрос "
"включена информация о области, *host* указывает URL-адрес и путь для "
"аутентификации, *req* должен быть (неудачным) объектом :class:`Request` , а "
"*headers* должны быть заголовками ошибок."

#: ../../library/urllib.request.rst:988
msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL containing "
"an authority component (e.g. ``\"http://python.org/\"``). In either case, "
"the authority must not contain a userinfo component (so, ``\"python.org\"`` "
"and ``\"python.org:80\"`` are fine, ``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host* — это либо авторитет (например, ``\"python.org\"``), либо URL-адрес, "
"содержащий компонент авторитета (например, ``\"http://python.org/\"``). В "
"любом случае полномочия не должны содержать компонент userinfo (поэтому "
"``\"python.org\"`` и ``\"python.org:80\"`` подходят, ``\"joe:password@python."
"org\" `` нет)."

#: ../../library/urllib.request.rst:997
msgid "HTTPBasicAuthHandler Objects"
msgstr "Объекты HTTPBasicAuthHandler"

#: ../../library/urllib.request.rst:1002 ../../library/urllib.request.rst:1013
#: ../../library/urllib.request.rst:1038 ../../library/urllib.request.rst:1049
msgid "Retry the request with authentication information, if available."
msgstr "Повторите запрос, указав данные аутентификации, если они доступны."

#: ../../library/urllib.request.rst:1008
msgid "ProxyBasicAuthHandler Objects"
msgstr "Объекты ProxyBasicAuthHandler"

#: ../../library/urllib.request.rst:1019
msgid "AbstractDigestAuthHandler Objects"
msgstr "Объекты AbstractDigestAuthHandler"

#: ../../library/urllib.request.rst:1024
msgid ""
"*authreq* should be the name of the header where the information about the "
"realm is included in the request, *host* should be the host to authenticate "
"to, *req* should be the (failed) :class:`Request` object, and *headers* "
"should be the error headers."
msgstr ""
"*authreq* должно быть именем заголовка, в который в запрос включена "
"информация о области, *host* должен быть хостом для аутентификации, *req* "
"должен быть (неудачным) объектом :class:`Request`, и *headers* должны быть "
"заголовками ошибок."

#: ../../library/urllib.request.rst:1033
msgid "HTTPDigestAuthHandler Objects"
msgstr "Объекты HTTPDigestAuthHandler"

#: ../../library/urllib.request.rst:1044
msgid "ProxyDigestAuthHandler Objects"
msgstr "Объекты ProxyDigestAuthHandler"

#: ../../library/urllib.request.rst:1055
msgid "HTTPHandler Objects"
msgstr "Объекты HTTPHandler"

#: ../../library/urllib.request.rst:1060
msgid ""
"Send an HTTP request, which can be either GET or POST, depending on ``req."
"has_data()``."
msgstr ""
"Отправьте HTTP-запрос, который может быть GET или POST, в зависимости от "
"``req.has_data()``."

#: ../../library/urllib.request.rst:1067
msgid "HTTPSHandler Objects"
msgstr "Объекты HTTPSHandler"

#: ../../library/urllib.request.rst:1072
msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on ``req."
"has_data()``."
msgstr ""
"Отправьте HTTPS-запрос, который может быть GET или POST, в зависимости от "
"``req.has_data()``."

#: ../../library/urllib.request.rst:1079
msgid "FileHandler Objects"
msgstr "Объекты FileHandler"

#: ../../library/urllib.request.rst:1084
msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr ""
"Откройте файл локально, если имя хоста отсутствует или имя хоста "
"``'localhost'``."

#: ../../library/urllib.request.rst:1087
msgid ""
"This method is applicable only for local hostnames.  When a remote hostname "
"is given, an :exc:`~urllib.error.URLError` is raised."
msgstr ""

#: ../../library/urllib.request.rst:1095
msgid "DataHandler Objects"
msgstr "Объекты DataHandler"

#: ../../library/urllib.request.rst:1099
msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL "
"itself. The data URL syntax is specified in :rfc:`2397`. This implementation "
"ignores white spaces in base64 encoded data URLs so the URL may be wrapped "
"in whatever source file it comes from. But even though some browsers don't "
"mind about a missing padding at the end of a base64 encoded data URL, this "
"implementation will raise an :exc:`ValueError` in that case."
msgstr ""

#: ../../library/urllib.request.rst:1110
msgid "FTPHandler Objects"
msgstr "Объекты FTPHandler"

#: ../../library/urllib.request.rst:1115
msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty "
"username and password."
msgstr ""
"Откройте FTP-файл, указанный *req*. Вход всегда осуществляется с пустым "
"именем пользователя и паролем."

#: ../../library/urllib.request.rst:1122
msgid "CacheFTPHandler Objects"
msgstr "Объекты CacheFTPHandler"

#: ../../library/urllib.request.rst:1124
msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the "
"following additional methods:"
msgstr ""
"Объекты :class:`CacheFTPHandler` — это объекты :class:`FTPHandler` со "
"следующими дополнительными методами:"

#: ../../library/urllib.request.rst:1130
msgid "Set timeout of connections to *t* seconds."
msgstr "Установите таймаут соединений на *t* секунд."

#: ../../library/urllib.request.rst:1135
msgid "Set maximum number of cached connections to *m*."
msgstr "Установите максимальное количество кэшированных соединений на *m*."

#: ../../library/urllib.request.rst:1141
msgid "UnknownHandler Objects"
msgstr "Объекты UnknownHandler"

#: ../../library/urllib.request.rst:1146
msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr "Вызовите исключение :exc:`~urllib.error.URLError`."

#: ../../library/urllib.request.rst:1152
msgid "HTTPErrorProcessor Objects"
msgstr "Объекты HTTPErrorProcessor"

#: ../../library/urllib.request.rst:1158
msgid "For 200 error codes, the response object is returned immediately."
msgstr "Для 200 кодов ошибок объект ответа возвращается немедленно."

#: ../../library/urllib.request.rst:1160
msgid ""
"For non-200 error codes, this simply passes the job on to the :meth:"
"`http_error_\\<type\\>` handler methods, via :meth:`OpenerDirector.error`. "
"Eventually, :class:`HTTPDefaultErrorHandler` will raise an :exc:`~urllib."
"error.HTTPError` if no other handler handles the error."
msgstr ""

#: ../../library/urllib.request.rst:1168
msgid "Process HTTPS error responses."
msgstr "Обработка ответов об ошибках HTTPS."

#: ../../library/urllib.request.rst:1170
msgid "The behavior is same as :meth:`http_response`."
msgstr "Поведение такое же, как у :meth:`http_response`."

#: ../../library/urllib.request.rst:1176
msgid "Examples"
msgstr "Примеры"

#: ../../library/urllib.request.rst:1178
msgid ""
"In addition to the examples below, more examples are given in :ref:`urllib-"
"howto`."
msgstr ""
"В дополнение к примерам ниже, дополнительные примеры приведены в :ref:"
"`urllib-howto`."

#: ../../library/urllib.request.rst:1181
msgid ""
"This example gets the python.org main page and displays the first 300 bytes "
"of it. ::"
msgstr ""
"В этом примере получается главная страница python.org и отображаются первые "
"300 ее байтов. ::"

#: ../../library/urllib.request.rst:1194
msgid ""
"Note that urlopen returns a bytes object.  This is because there is no way "
"for urlopen to automatically determine the encoding of the byte stream it "
"receives from the HTTP server. In general, a program will decode the "
"returned bytes object to string once it determines or guesses the "
"appropriate encoding."
msgstr ""
"Обратите внимание, что urlopen возвращает объект bytes. Это связано с тем, "
"что urlopen не может автоматически определять кодировку потока байтов, "
"который он получает от HTTP-сервера. В общем, программа декодирует "
"возвращенный объект байтов в строку, как только определит или угадает "
"соответствующую кодировку."

#: ../../library/urllib.request.rst:1200
msgid ""
"The following W3C document, https://www.w3.org/International/O-charset\\ , "
"lists the various ways in which an (X)HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"В следующем документе W3C, https://www.w3.org/International/O-charset\\, "
"перечислены различные способы, которыми документ (X)HTML или XML мог бы "
"указать информацию о своей кодировке."

#: ../../library/urllib.request.rst:1204
msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object. ::"
msgstr ""
"Поскольку веб-сайт python.org использует кодировку *utf-8*, указанную в его "
"метатеге, мы будем использовать ее для декодирования объекта bytes. ::"

#: ../../library/urllib.request.rst:1213
msgid ""
"It is also possible to achieve the same result without using the :term:"
"`context manager` approach. ::"
msgstr ""
"Того же результата можно добиться и без использования подхода :term:"
"`контекстного менеджера`. ::"

#: ../../library/urllib.request.rst:1222
msgid ""
"In the following example, we are sending a data-stream to the stdin of a CGI "
"and reading the data it returns to us. Note that this example will only work "
"when the Python installation supports SSL. ::"
msgstr ""
"В следующем примере мы отправляем поток данных на стандартный ввод CGI и "
"читаем данные, которые он нам возвращает. Обратите внимание, что этот пример "
"будет работать только в том случае, если установка Python поддерживает "
"SSL. ::"

#: ../../library/urllib.request.rst:1234
msgid "The code for the sample CGI used in the above example is::"
msgstr "Код примера CGI, использованного в приведенном выше примере:"

#: ../../library/urllib.request.rst:1241
msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr "Вот пример выполнения запроса PUT с использованием :class:`Request`::"

#: ../../library/urllib.request.rst:1251
msgid "Use of Basic HTTP Authentication::"
msgstr "Использование базовой HTTP-аутентификации::"

#: ../../library/urllib.request.rst:1265
msgid ""
":func:`build_opener` provides many handlers by default, including a :class:"
"`ProxyHandler`.  By default, :class:`ProxyHandler` uses the environment "
"variables named ``<scheme>_proxy``, where ``<scheme>`` is the URL scheme "
"involved.  For example, the :envvar:`http_proxy` environment variable is "
"read to obtain the HTTP proxy's URL."
msgstr ""

#: ../../library/urllib.request.rst:1271
msgid ""
"This example replaces the default :class:`ProxyHandler` with one that uses "
"programmatically supplied proxy URLs, and adds proxy authorization support "
"with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""
"В этом примере стандартный :class:`ProxyHandler` заменяется на тот, который "
"использует программно предоставленные URL-адреса прокси-сервера, и "
"добавляется поддержка авторизации прокси-сервера с помощью :class:"
"`ProxyBasicAuthHandler`. ::"

#: ../../library/urllib.request.rst:1283
msgid "Adding HTTP headers:"
msgstr "Добавление HTTP-заголовков:"

#: ../../library/urllib.request.rst:1285
msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr "Используйте аргумент *headers* для конструктора :class:`Request` или::"

#: ../../library/urllib.request.rst:1294
msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` header "
"to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector` автоматически добавляет заголовок :mailheader:`User-"
"Agent` к каждому :class:`Request`. Чтобы изменить это:"

#: ../../library/urllib.request.rst:1302
msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`, :"
"mailheader:`Content-Type` and :mailheader:`Host`) are added when the :class:"
"`Request` is passed to :func:`urlopen` (or :meth:`OpenerDirector.open`)."
msgstr ""
"Также помните, что несколько стандартных заголовков (:mailheader:`Content-"
"Length`, :mailheader:`Content-Type` и :mailheader:`Host`) добавляются, "
"когда :class:`Request` передается :func: `urlopen` (или :meth:"
"`OpenerDirector.open`)."

#: ../../library/urllib.request.rst:1309
msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL "
"containing parameters::"
msgstr ""
"Вот пример сеанса, в котором используется метод GET для получения URL-"
"адреса, содержащего параметры:"

#: ../../library/urllib.request.rst:1320
msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as "
"data::"
msgstr ""
"В следующем примере вместо этого используется метод POST. Обратите внимание, "
"что выходные данные params из urlencode кодируются в байтах перед отправкой "
"в ​​urlopen как данные::"

#: ../../library/urllib.request.rst:1331
msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding "
"environment settings::"
msgstr ""
"В следующем примере используется явно указанный HTTP-прокси, "
"переопределяющий настройки среды:"

#: ../../library/urllib.request.rst:1341
msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr ""
"В следующем примере вообще не используются прокси-серверы, переопределяя "
"настройки среды::"

#: ../../library/urllib.request.rst:1351
msgid "Legacy interface"
msgstr "Устаревший интерфейс"

#: ../../library/urllib.request.rst:1353
msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr ""
"Следующие функции и классы перенесены из модуля Python 2 urllib (в отличие "
"от urllib2). В какой-то момент в будущем они могут стать устаревшими."

#: ../../library/urllib.request.rst:1359
msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points to "
"a local file, the object will not be copied unless filename is supplied. "
"Return a tuple ``(filename, headers)`` where *filename* is the local file "
"name under which the object can be found, and *headers* is whatever the :"
"meth:`info` method of the object returned by :func:`urlopen` returned (for a "
"remote object). Exceptions are the same as for :func:`urlopen`."
msgstr ""

#: ../../library/urllib.request.rst:1366
msgid ""
"The second argument, if present, specifies the file location to copy to (if "
"absent, the location will be a tempfile with a generated name). The third "
"argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of blocks "
"transferred so far, a block size in bytes, and the total size of the file.  "
"The third argument may be ``-1`` on older FTP servers which do not return a "
"file size in response to a retrieval request."
msgstr ""
"Второй аргумент, если он присутствует, указывает расположение файла для "
"копирования (если он отсутствует, это будет временный файл со "
"сгенерированным именем). Третий аргумент, если он присутствует, является "
"вызываемым объектом, который будет вызываться один раз при установлении "
"сетевого соединения и один раз после каждого последующего чтения блока. "
"Вызываемому объекту будут переданы три аргумента; количество переданных "
"блоков, размер блока в байтах и ​​общий размер файла. Третий аргумент может "
"быть ``-1`` на старых FTP-серверах, которые не возвращают размер файла в "
"ответ на запрос на получение."

#: ../../library/urllib.request.rst:1375
msgid "The following example illustrates the most common usage scenario::"
msgstr ""
"Следующий пример иллюстрирует наиболее распространенный сценарий "
"использования:"

#: ../../library/urllib.request.rst:1382
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must be a bytes object in standard :"
"mimetype:`application/x-www-form-urlencoded` format; see the :func:`urllib."
"parse.urlencode` function."
msgstr ""
"Если *url* использует идентификатор схемы :file:`http:`, можно указать "
"необязательный аргумент *data* для указания запроса ``POST`` (обычно тип "
"запроса - ``GET``). Аргумент *data* должен быть байтовым объектом в "
"стандартном формате :mimetype:`application/x-www-form-urlencoded`; см. "
"функцию :func:`urllib.parse.urlencode`."

#: ../../library/urllib.request.rst:1388
msgid ""
":func:`urlretrieve` will raise :exc:`ContentTooShortError` when it detects "
"that the amount of data available  was less than the expected amount (which "
"is the size reported by a  *Content-Length* header). This can occur, for "
"example, when the  download is interrupted."
msgstr ""

#: ../../library/urllib.request.rst:1393
msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  to "
"read, urlretrieve reads more data, but if less data is available,  it raises "
"the exception."
msgstr ""
"*Content-Length* рассматривается как нижняя граница: если нужно прочитать "
"больше данных, urlretrive считывает больше данных, но если доступно меньше "
"данных, возникает исключение."

#: ../../library/urllib.request.rst:1397
msgid ""
"You can still retrieve the downloaded data in this case, it is stored  in "
"the :attr:`content` attribute of the exception instance."
msgstr ""

#: ../../library/urllib.request.rst:1400
msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the "
"size of the data it has downloaded, and just returns it.  In this case you "
"just have to assume that the download was successful."
msgstr ""
"Если заголовок *Content-Length* не был указан, urlretrieve не может "
"проверить размер загруженных данных и просто возвращает их. В этом случае "
"вам остается лишь предположить, что загрузка прошла успешно."

#: ../../library/urllib.request.rst:1406
msgid ""
"Cleans up temporary files that may have been left behind by previous calls "
"to :func:`urlretrieve`."
msgstr ""
"Очищает временные файлы, которые могли остаться после предыдущих вызовов :"
"func:`urlretrieve`."

#: ../../library/urllib.request.rst:1413
msgid ""
"Base class for opening and reading URLs.  Unless you need to support opening "
"objects using schemes other than :file:`http:`, :file:`ftp:`, or :file:`file:"
"`, you probably want to use :class:`FancyURLopener`."
msgstr ""
"Базовый класс для открытия и чтения URL-адресов. Если вам не требуется "
"поддержка открытия объектов с использованием схем, отличных от :file:`http:"
"`, :file:`ftp:` или :file:`file:`, вы, вероятно, захотите использовать :"
"class:`FancyURLopener`."

#: ../../library/urllib.request.rst:1417
msgid ""
"By default, the :class:`URLopener` class sends a :mailheader:`User-Agent` "
"header of ``urllib/VVV``, where *VVV* is the :mod:`urllib` version number. "
"Applications can define their own :mailheader:`User-Agent` header by "
"subclassing :class:`URLopener` or :class:`FancyURLopener` and setting the "
"class attribute :attr:`version` to an appropriate string value in the "
"subclass definition."
msgstr ""
"По умолчанию класс :class:`URLopener` отправляет заголовок :mailheader:`User-"
"Agent` ``urllib/VVV``, где *VVV* — номер версии :mod:`urllib`. Приложения "
"могут определить свой собственный заголовок :mailheader:`User-Agent`, создав "
"подкласс :class:`URLopener` или :class:`FancyURLopener` и установив для "
"атрибута класса :attr:`version` соответствующее строковое значение в "
"определении подкласса."

#: ../../library/urllib.request.rst:1423
msgid ""
"The optional *proxies* parameter should be a dictionary mapping scheme names "
"to proxy URLs, where an empty dictionary turns proxies off completely.  Its "
"default value is ``None``, in which case environmental proxy settings will "
"be used if present, as discussed in the definition of :func:`urlopen`, above."
msgstr ""
"Необязательный параметр *proxies* должен представлять собой имена схем "
"сопоставления словаря с URL-адресами прокси-серверов, где пустой словарь "
"полностью отключает прокси-серверы. Его значение по умолчанию — None, и в "
"этом случае будут использоваться настройки прокси-сервера среды, если они "
"присутствуют, как описано в определении :func:`urlopen` выше."

#: ../../library/urllib.request.rst:1428
msgid ""
"Additional keyword parameters, collected in *x509*, may be used for "
"authentication of the client when using the :file:`https:` scheme.  The "
"keywords *key_file* and *cert_file* are supported to provide an  SSL key and "
"certificate; both are needed to support client authentication."
msgstr ""
"Дополнительные параметры ключевого слова, собранные в *x509*, могут "
"использоваться для аутентификации клиента при использовании схемы :file:"
"`https:`. Ключевые слова *key_file* и *cert_file* поддерживаются для "
"предоставления ключа и сертификата SSL; оба необходимы для поддержки "
"аутентификации клиента."

#: ../../library/urllib.request.rst:1433
msgid ""
":class:`URLopener` objects will raise an :exc:`OSError` exception if the "
"server returns an error code."
msgstr ""
"Объекты :class:`URLopener` вызовут исключение :exc:`OSError`, если сервер "
"вернет код ошибки."

#: ../../library/urllib.request.rst:1438
msgid ""
"Open *fullurl* using the appropriate protocol.  This method sets up cache "
"and proxy information, then calls the appropriate open method with its input "
"arguments.  If the scheme is not recognized, :meth:`open_unknown` is called. "
"The *data* argument has the same meaning as the *data* argument of :func:"
"`urlopen`."
msgstr ""
"Откройте *fullurl*, используя соответствующий протокол. Этот метод "
"устанавливает информацию о кеше и прокси, а затем вызывает соответствующий "
"открытый метод с его входными аргументами. Если схема не распознана, "
"вызывается :meth:`open_unknown`. Аргумент *data* имеет то же значение, что и "
"аргумент *data* функции :func:`urlopen`."

#: ../../library/urllib.request.rst:1444
msgid "This method always quotes *fullurl* using :func:`~urllib.parse.quote`."
msgstr ""
"Этот метод всегда цитирует *fullurl*, используя :func:`~urllib.parse.quote`."

#: ../../library/urllib.request.rst:1448
msgid "Overridable interface to open unknown URL types."
msgstr "Переопределяемый интерфейс для открытия неизвестных типов URL."

#: ../../library/urllib.request.rst:1453
msgid ""
"Retrieves the contents of *url* and places it in *filename*.  The return "
"value is a tuple consisting of a local filename and either an :class:`email."
"message.Message` object containing the response headers (for remote URLs) or "
"``None`` (for local URLs).  The caller must then open and read the contents "
"of *filename*.  If *filename* is not given and the URL refers to a local "
"file, the input filename is returned.  If the URL is non-local and "
"*filename* is not given, the filename is the output of :func:`tempfile."
"mktemp` with a suffix that matches the suffix of the last path component of "
"the input URL.  If *reporthook* is given, it must be a function accepting "
"three numeric parameters: A chunk number, the maximum size chunks are read "
"in and the total size of the download (-1 if unknown).  It will be called "
"once at the start and after each chunk of data is read from the network.  "
"*reporthook* is ignored for local URLs."
msgstr ""
"Извлекает содержимое *url* и ​​помещает его в *имя_файла*. Возвращаемое "
"значение представляет собой кортеж, состоящий из имени локального файла и "
"либо объекта :class:`email.message.Message`, содержащего заголовки ответа "
"(для удаленных URL-адресов), либо объекта ``None`` (для локальных URL-"
"адресов). Затем вызывающая сторона должна открыть и прочитать содержимое "
"*filename*. Если *filename* не указано и URL-адрес ссылается на локальный "
"файл, возвращается входное имя файла. Если URL-адрес нелокальный и "
"*имя_файла* не указано, имя файла является результатом :func:`tempfile."
"mktemp` с суффиксом, который соответствует суффиксу последнего компонента "
"пути входного URL-адреса. Если указан *reporthook*, это должна быть функция, "
"принимающая три числовых параметра: номер фрагмента, максимальный размер "
"считываемых фрагментов и общий размер загрузки (-1, если неизвестно). Он "
"будет вызываться один раз в начале и после чтения каждого фрагмента данных "
"из сети. *reporthook* игнорируется для локальных URL-адресов."

#: ../../library/urllib.request.rst:1466
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must in standard :mimetype:"
"`application/x-www-form-urlencoded` format; see the :func:`urllib.parse."
"urlencode` function."
msgstr ""
"Если *url* использует идентификатор схемы :file:`http:`, можно указать "
"необязательный аргумент *data* для указания запроса ``POST`` (обычно тип "
"запроса - ``GET``). Аргумент *data* должен быть в стандартном формате :"
"mimetype:`application/x-www-form-urlencoded`; см. функцию :func:`urllib."
"parse.urlencode`."

#: ../../library/urllib.request.rst:1475
msgid ""
"Variable that specifies the user agent of the opener object.  To get :mod:"
"`urllib` to tell servers that it is a particular user agent, set this in a "
"subclass as a class variable or in the constructor before calling the base "
"constructor."
msgstr ""
"Переменная, указывающая пользовательский агент открывающего объекта. Чтобы "
"заставить :mod:`urllib` сообщать серверам, что это конкретный "
"пользовательский агент, установите это в подклассе как переменную класса или "
"в конструкторе перед вызовом базового конструктора."

#: ../../library/urllib.request.rst:1485
msgid ""
":class:`FancyURLopener` subclasses :class:`URLopener` providing default "
"handling for the following HTTP response codes: 301, 302, 303, 307 and 401.  "
"For the 30x response codes listed above, the :mailheader:`Location` header "
"is used to fetch the actual URL.  For 401 response codes (authentication "
"required), basic HTTP authentication is performed.  For the 30x response "
"codes, recursion is bounded by the value of the *maxtries* attribute, which "
"defaults to 10."
msgstr ""
"Подклассы :class:`FancyURLopener` :class:`URLopener` обеспечивают обработку "
"по умолчанию для следующих кодов ответа HTTP: 301, 302, 303, 307 и 401. Для "
"кодов ответа 30x, перечисленных выше, заголовок :mailheader:`Location` имеет "
"вид используется для получения фактического URL-адреса. Для кодов ответа 401 "
"(требуется аутентификация) выполняется базовая HTTP-аутентификация. Для "
"кодов ответа 30x рекурсия ограничена значением атрибута *maxtries*, который "
"по умолчанию равен 10."

#: ../../library/urllib.request.rst:1492
msgid ""
"For all other response codes, the method :meth:`http_error_default` is "
"called which you can override in subclasses to handle the error "
"appropriately."
msgstr ""

#: ../../library/urllib.request.rst:1497
msgid ""
"According to the letter of :rfc:`2616`, 301 and 302 responses to POST "
"requests must not be automatically redirected without confirmation by the "
"user.  In reality, browsers do allow automatic redirection of these "
"responses, changing the POST to a GET, and :mod:`urllib` reproduces this "
"behaviour."
msgstr ""
"Согласно письму :rfc:`2616`, ответы 301 и 302 на POST-запросы не должны "
"автоматически перенаправляться без подтверждения пользователя. На самом деле "
"браузеры допускают автоматическое перенаправление этих ответов, заменяя POST "
"на GET, и :mod:`urllib` воспроизводит это поведение."

#: ../../library/urllib.request.rst:1502
msgid ""
"The parameters to the constructor are the same as those for :class:"
"`URLopener`."
msgstr "Параметры конструктора такие же, как и у :class:`URLopener`."

#: ../../library/urllib.request.rst:1506
msgid ""
"When performing basic authentication, a :class:`FancyURLopener` instance "
"calls its :meth:`prompt_user_passwd` method.  The default implementation "
"asks the users for the required information on the controlling terminal.  A "
"subclass may override this method to support more appropriate behavior if "
"needed."
msgstr ""
"При выполнении базовой аутентификации экземпляр :class:`FancyURLopener` "
"вызывает свой метод :meth:`prompt_user_passwd`. Реализация по умолчанию "
"запрашивает у пользователей необходимую информацию на управляющем терминале. "
"При необходимости подкласс может переопределить этот метод для поддержки "
"более подходящего поведения."

#: ../../library/urllib.request.rst:1511
msgid ""
"The :class:`FancyURLopener` class offers one additional method that should "
"be overloaded to provide the appropriate behavior:"
msgstr ""
"Класс :class:`FancyURLopener` предлагает один дополнительный метод, который "
"следует перегрузить, чтобы обеспечить соответствующее поведение:"

#: ../../library/urllib.request.rst:1516
msgid ""
"Return information needed to authenticate the user at the given host in the "
"specified security realm.  The return value should be a tuple, ``(user, "
"password)``, which can be used for basic authentication."
msgstr ""
"Возвращает информацию, необходимую для аутентификации пользователя на данном "
"хосте в указанной области безопасности. Возвращаемое значение должно быть "
"кортежем ``(пользователь, пароль)``, который можно использовать для базовой "
"аутентификации."

#: ../../library/urllib.request.rst:1520
msgid ""
"The implementation prompts for this information on the terminal; an "
"application should override this method to use an appropriate interaction "
"model in the local environment."
msgstr ""
"Реализация запрашивает эту информацию на терминале; приложение должно "
"переопределить этот метод, чтобы использовать соответствующую модель "
"взаимодействия в локальной среде."

#: ../../library/urllib.request.rst:1526
msgid ":mod:`urllib.request` Restrictions"
msgstr "Ограничения :mod:`urllib.request`"

#: ../../library/urllib.request.rst:1532
msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9 "
"and 1.0), FTP, local files, and data URLs."
msgstr ""
"В настоящее время поддерживаются только следующие протоколы: HTTP (версии "
"0.9 и 1.0), FTP, локальные файлы и URL-адреса данных."

#: ../../library/urllib.request.rst:1535
msgid "Added support for data URLs."
msgstr "Добавлена ​​поддержка URL-адресов данных."

#: ../../library/urllib.request.rst:1537
msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until someone "
"finds the time to hack proper processing of Expiration time headers."
msgstr ""
"Функция кэширования :func:`urlretrieve` была отключена до тех пор, пока кто-"
"нибудь не найдет время взломать правильную обработку заголовков времени "
"истечения срока действия."

#: ../../library/urllib.request.rst:1540
msgid ""
"There should be a function to query whether a particular URL is in the cache."
msgstr ""
"Должна быть функция для запроса, находится ли конкретный URL-адрес в кеше."

#: ../../library/urllib.request.rst:1542
msgid ""
"For backward compatibility, if a URL appears to point to a local file but "
"the file can't be opened, the URL is re-interpreted using the FTP protocol.  "
"This can sometimes cause confusing error messages."
msgstr ""
"В целях обратной совместимости, если URL-адрес указывает на локальный файл, "
"но его невозможно открыть, URL-адрес интерпретируется заново с "
"использованием протокола FTP. Иногда это может привести к появлению "
"запутанных сообщений об ошибках."

#: ../../library/urllib.request.rst:1546
msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause arbitrarily "
"long delays while waiting for a network connection to be set up.  This means "
"that it is difficult to build an interactive web client using these "
"functions without using threads."
msgstr ""
"Функции :func:`urlopen` и :func:`urlretrieve` могут вызывать сколь угодно "
"длительные задержки при ожидании установки сетевого подключения. Это "
"означает, что сложно создать интерактивный веб-клиент с использованием этих "
"функций без использования потоков."

#: ../../library/urllib.request.rst:1555
msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw data "
"returned by the server.  This may be binary data (such as an image), plain "
"text or (for example) HTML.  The HTTP protocol provides type information in "
"the reply header, which can be inspected by looking at the :mailheader:"
"`Content-Type` header.  If the returned data is HTML, you can use the "
"module :mod:`html.parser` to parse it."
msgstr ""
"Данные, возвращаемые :func:`urlopen` или :func:`urlretrive`, являются "
"необработанными данными, возвращаемыми сервером. Это могут быть двоичные "
"данные (например, изображение), обычный текст или (например) HTML. Протокол "
"HTTP предоставляет информацию о типе в заголовке ответа, которую можно "
"проверить, просмотрев заголовок :mailheader:`Content-Type`. Если "
"возвращаемые данные представляют собой HTML, вы можете использовать модуль :"
"mod:`html.parser` для их анализа."

#: ../../library/urllib.request.rst:1564
msgid ""
"The code handling the FTP protocol cannot differentiate between a file and a "
"directory.  This can lead to unexpected behavior when attempting to read a "
"URL that points to a file that is not accessible.  If the URL ends in a ``/"
"``, it is assumed to refer to a directory and will be handled accordingly.  "
"But if an attempt to read a file leads to a 550 error (meaning the URL "
"cannot be found or is not accessible, often for permission reasons), then "
"the path is treated as a directory in order to handle the case when a "
"directory is specified by a URL but the trailing ``/`` has been left off.  "
"This can cause misleading results when you try to fetch a file whose read "
"permissions make it inaccessible; the FTP code will try to read it, fail "
"with a 550 error, and then perform a directory listing for the unreadable "
"file. If fine-grained control is needed, consider using the :mod:`ftplib` "
"module, subclassing :class:`FancyURLopener`, or changing *_urlopener* to "
"meet your needs."
msgstr ""
"Код, обрабатывающий протокол FTP, не может различать файл и каталог. Это "
"может привести к неожиданному поведению при попытке прочитать URL-адрес, "
"указывающий на недоступный файл. Если URL-адрес заканчивается на ``/``, "
"предполагается, что он относится к каталогу и будет обрабатываться "
"соответствующим образом. Но если попытка прочитать файл приводит к ошибке "
"550 (это означает, что URL-адрес не может быть найден или недоступен, часто "
"по причинам разрешения), тогда путь рассматривается как каталог, чтобы "
"обработать случай, когда каталог указан. по URL-адресу, но завершающий ``/`` "
"опущен. Это может привести к ошибочным результатам при попытке получить "
"файл, права на чтение которого делают его недоступным; код FTP попытается "
"прочитать его, но выдаст ошибку 550, а затем выполнит просмотр каталога для "
"нечитаемого файла. Если необходим детальный контроль, рассмотрите "
"возможность использования модуля :mod:`ftplib`, создания подкласса :class:"
"`FancyURLopener` или изменения *_urlopener* в соответствии с вашими "
"потребностями."

#: ../../library/urllib.request.rst:1581
msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- Классы ответов, используемые urllib"

#: ../../library/urllib.request.rst:1586
msgid ""
"The :mod:`urllib.response` module defines functions and classes which define "
"a minimal file-like interface, including ``read()`` and ``readline()``. "
"Functions defined by this module are used internally by the :mod:`urllib."
"request` module. The typical response object is a :class:`urllib.response."
"addinfourl` instance:"
msgstr ""
"Модуль :mod:`urllib.response` определяет функции и классы, которые "
"определяют минимальный файловый интерфейс, включая ``read()`` и "
"``readline()``. Функции, определенные этим модулем, используются внутри "
"модуля :mod:`urllib.request`. Типичным объектом ответа является экземпляр :"
"class:`urllib.response.addinourl`:"

#: ../../library/urllib.request.rst:1595
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr ""
"URL-адрес полученного ресурса, обычно используемый для определения того, "
"было ли выполнено перенаправление."

#: ../../library/urllib.request.rst:1599
msgid ""
"Returns the headers of the response in the form of an :class:`~email.message."
"EmailMessage` instance."
msgstr ""
"Возвращает заголовки ответа в форме экземпляра :class:`~email.message."
"EmailMessage`."

#: ../../library/urllib.request.rst:1605
msgid "Status code returned by server."
msgstr "Код состояния, возвращенный сервером."

#: ../../library/urllib.request.rst:1609
msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "Устарело в пользу :attr:`~addinourl.url`."

#: ../../library/urllib.request.rst:1614
msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "Устарело в пользу :attr:`~addinourl.headers`."

#: ../../library/urllib.request.rst:1619 ../../library/urllib.request.rst:1624
msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "Устарело в пользу :attr:`~addinourl.status`."
