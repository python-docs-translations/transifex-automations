# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/inspect.rst:2
msgid ":mod:`!inspect` --- Inspect live objects"
msgstr ":mod:`!inspect` --- Осмотр живых объектов"

#: ../../library/inspect.rst:15
msgid "**Source code:** :source:`Lib/inspect.py`"
msgstr "**Исходный код:** :source:`Lib/inspect.py`"

#: ../../library/inspect.rst:19
msgid ""
"The :mod:`inspect` module provides several useful functions to help get "
"information about live objects such as modules, classes, methods, functions, "
"tracebacks, frame objects, and code objects.  For example, it can help you "
"examine the contents of a class, retrieve the source code of a method, "
"extract and format the argument list for a function, or get all the "
"information you need to display a detailed traceback."
msgstr ""
"Модуль :mod:`inspect` предоставляет несколько полезных функций, помогающих "
"получить информацию о живых объектах, таких как модули, классы, методы, "
"функции, обратные трассировки, объекты фреймов и объекты кода. Например, он "
"может помочь вам изучить содержимое класса, получить исходный код метода, "
"извлечь и отформатировать список аргументов функции или получить всю "
"информацию, необходимую для отображения подробной обратной трассировки."

#: ../../library/inspect.rst:26
msgid ""
"There are four main kinds of services provided by this module: type "
"checking, getting source code, inspecting classes and functions, and "
"examining the interpreter stack."
msgstr ""
"Этот модуль предоставляет четыре основных вида услуг: проверка типов, "
"получение исходного кода, проверка классов и функций и проверка стека "
"интерпретатора."

#: ../../library/inspect.rst:34
msgid "Types and members"
msgstr "Типы и члены"

#: ../../library/inspect.rst:36
msgid ""
"The :func:`getmembers` function retrieves the members of an object such as a "
"class or module. The functions whose names begin with \"is\" are mainly "
"provided as convenient choices for the second argument to :func:"
"`getmembers`. They also help you determine when you can expect to find the "
"following special attributes (see :ref:`import-mod-attrs` for module "
"attributes):"
msgstr ""
"Функция :func:`getmembers` извлекает члены объекта, такого как класс или "
"модуль. Функции, имена которых начинаются с «is», в основном предоставляются "
"в качестве удобного выбора для второго аргумента :func:`getmembers`. Они "
"также помогут вам определить, когда вы можете ожидать появления следующих "
"специальных атрибутов (см. :ref:`import-mod-attrs` для атрибутов модуля):"

#: ../../library/inspect.rst:46
msgid "Type"
msgstr "Тип"

#: ../../library/inspect.rst:46
msgid "Attribute"
msgstr "Атрибут"

#: ../../library/inspect.rst:46
msgid "Description"
msgstr "Описание"

#: ../../library/inspect.rst:48
msgid "class"
msgstr "класс"

#: ../../library/inspect.rst:48 ../../library/inspect.rst:63
#: ../../library/inspect.rst:81 ../../library/inspect.rst:261
msgid "__doc__"
msgstr "__doc__"

#: ../../library/inspect.rst:48 ../../library/inspect.rst:63
#: ../../library/inspect.rst:81 ../../library/inspect.rst:261
msgid "documentation string"
msgstr "строка документации"

#: ../../library/inspect.rst:50 ../../library/inspect.rst:65
#: ../../library/inspect.rst:83 ../../library/inspect.rst:217
#: ../../library/inspect.rst:231 ../../library/inspect.rst:244
#: ../../library/inspect.rst:263
msgid "__name__"
msgstr "__name__"

#: ../../library/inspect.rst:50
msgid "name with which this class was defined"
msgstr "имя, с которым был определен этот класс"

#: ../../library/inspect.rst:53 ../../library/inspect.rst:68
#: ../../library/inspect.rst:86 ../../library/inspect.rst:219
#: ../../library/inspect.rst:233 ../../library/inspect.rst:246
#: ../../library/inspect.rst:266
msgid "__qualname__"
msgstr "__qualname__"

#: ../../library/inspect.rst:53 ../../library/inspect.rst:68
#: ../../library/inspect.rst:86 ../../library/inspect.rst:219
#: ../../library/inspect.rst:233 ../../library/inspect.rst:246
#: ../../library/inspect.rst:266
msgid "qualified name"
msgstr "полное имя"

#: ../../library/inspect.rst:55 ../../library/inspect.rst:78
#: ../../library/inspect.rst:116
msgid "__module__"
msgstr "__module__"

#: ../../library/inspect.rst:55
msgid "name of module in which this class was defined"
msgstr "имя модуля, в котором был определен этот класс"

#: ../../library/inspect.rst:58 ../../library/inspect.rst:111
msgid "__type_params__"
msgstr "__type_params__"

#: ../../library/inspect.rst:58
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a generic "
"class"
msgstr ""
"Кортеж, содержащий параметры типа <type-params>` универсального класса."

#: ../../library/inspect.rst:63
msgid "method"
msgstr "метод"

#: ../../library/inspect.rst:65
msgid "name with which this method was defined"
msgstr "имя, с которым был определен этот метод"

#: ../../library/inspect.rst:70
msgid "__func__"
msgstr "__func__"

#: ../../library/inspect.rst:70
msgid "function object containing implementation of method"
msgstr "функциональный объект, содержащий реализацию метода"

#: ../../library/inspect.rst:74 ../../library/inspect.rst:268
msgid "__self__"
msgstr "__self__"

#: ../../library/inspect.rst:74
msgid "instance to which this method is bound, or ``None``"
msgstr "экземпляр, к которому привязан этот метод, или ``None``"

#: ../../library/inspect.rst:78
msgid "name of module in which this method was defined"
msgstr "имя модуля, в котором был определен этот метод"

#: ../../library/inspect.rst:81
msgid "function"
msgstr "функция"

#: ../../library/inspect.rst:83
msgid "name with which this function was defined"
msgstr "имя, с которым была определена эта функция"

#: ../../library/inspect.rst:88
msgid "__code__"
msgstr "__code__"

#: ../../library/inspect.rst:88
msgid "code object containing compiled function :term:`bytecode`"
msgstr "объект кода, содержащий скомпилированную функцию :term:`bytecode`"

#: ../../library/inspect.rst:92
msgid "__defaults__"
msgstr "__defaults__"

#: ../../library/inspect.rst:92
msgid "tuple of any default values for positional or keyword parameters"
msgstr ""
"кортеж любых значений по умолчанию для позиционных или ключевых параметров"

#: ../../library/inspect.rst:96
msgid "__kwdefaults__"
msgstr "__kwdefaults__"

#: ../../library/inspect.rst:96
msgid "mapping of any default values for keyword-only parameters"
msgstr ""
"сопоставление любых значений по умолчанию для параметров, содержащих только "
"ключевые слова"

#: ../../library/inspect.rst:100
msgid "__globals__"
msgstr "__globals__"

#: ../../library/inspect.rst:100
msgid "global namespace in which this function was defined"
msgstr "глобальное пространство имен, в котором была определена эта функция"

#: ../../library/inspect.rst:103
msgid "__builtins__"
msgstr "__builtins__"

#: ../../library/inspect.rst:103
msgid "builtins namespace"
msgstr "встроенное пространство имен"

#: ../../library/inspect.rst:105
msgid "__annotations__"
msgstr "__annotations__"

#: ../../library/inspect.rst:105
msgid ""
"mapping of parameters names to annotations; ``\"return\"`` key is reserved "
"for return annotations."
msgstr ""
"сопоставление имен параметров с аннотациями; Ключ ``\"return\"`` "
"зарезервирован для аннотаций возврата."

#: ../../library/inspect.rst:111
msgid ""
"A tuple containing the :ref:`type parameters <type-params>` of a generic "
"function"
msgstr ""
"Кортеж, содержащий параметры типа <type-params>` универсальной функции."

#: ../../library/inspect.rst:116
msgid "name of module in which this function was defined"
msgstr "имя модуля, в котором была определена эта функция"

#: ../../library/inspect.rst:119
msgid "traceback"
msgstr "трассировка"

#: ../../library/inspect.rst:119
msgid "tb_frame"
msgstr "tb_frame"

#: ../../library/inspect.rst:119
msgid "frame object at this level"
msgstr "кадрировать объект на этом уровне"

#: ../../library/inspect.rst:122
msgid "tb_lasti"
msgstr "tb_lasti"

#: ../../library/inspect.rst:122 ../../library/inspect.rst:144
msgid "index of last attempted instruction in bytecode"
msgstr "индекс последней попытки выполнения команды в байт-коде"

#: ../../library/inspect.rst:125
msgid "tb_lineno"
msgstr "tb_lineno"

#: ../../library/inspect.rst:125 ../../library/inspect.rst:147
msgid "current line number in Python source code"
msgstr "текущий номер строки в исходном коде Python"

#: ../../library/inspect.rst:128
msgid "tb_next"
msgstr "tb_next"

#: ../../library/inspect.rst:128
msgid "next inner traceback object (called by this level)"
msgstr ""
"следующий внутренний объект обратной трассировки (вызываемый этим уровнем)"

#: ../../library/inspect.rst:132 ../../library/inspect.rst:221
#: ../../library/inspect.rst:238 ../../library/inspect.rst:251
msgid "frame"
msgstr "фрейм"

#: ../../library/inspect.rst:132
msgid "f_back"
msgstr "f_back"

#: ../../library/inspect.rst:132
msgid "next outer frame object (this frame's caller)"
msgstr "следующий объект внешнего фрейма (вызывающая сторона этого фрейма)"

#: ../../library/inspect.rst:135
msgid "f_builtins"
msgstr "f_builtins"

#: ../../library/inspect.rst:135
msgid "builtins namespace seen by this frame"
msgstr "встроенное пространство имен, видимое этим фреймом"

#: ../../library/inspect.rst:138
msgid "f_code"
msgstr "f_code"

#: ../../library/inspect.rst:138
msgid "code object being executed in this frame"
msgstr "объект кода, выполняемый в этом кадре"

#: ../../library/inspect.rst:141
msgid "f_globals"
msgstr "f_globals"

#: ../../library/inspect.rst:141
msgid "global namespace seen by this frame"
msgstr "глобальное пространство имен, видимое этим фреймом"

#: ../../library/inspect.rst:144
msgid "f_lasti"
msgstr "f_lasti"

#: ../../library/inspect.rst:147
msgid "f_lineno"
msgstr "f_lineno"

#: ../../library/inspect.rst:150
msgid "f_locals"
msgstr "f_locals"

#: ../../library/inspect.rst:150
msgid "local namespace seen by this frame"
msgstr "локальное пространство имен, видимое этим фреймом"

#: ../../library/inspect.rst:153
msgid "f_trace"
msgstr "f_trace"

#: ../../library/inspect.rst:153
msgid "tracing function for this frame, or ``None``"
msgstr "функция трассировки для этого кадра или ``Нет``"

#: ../../library/inspect.rst:156 ../../library/inspect.rst:225
#: ../../library/inspect.rst:242 ../../library/inspect.rst:255
msgid "code"
msgstr "код"

#: ../../library/inspect.rst:156
msgid "co_argcount"
msgstr "co_argcount"

#: ../../library/inspect.rst:156
msgid ""
"number of arguments (not including keyword only arguments, \\* or \\*\\* "
"args)"
msgstr ""
"количество аргументов (не включая аргументы только по ключевым словам, \\* "
"или \\*\\* args)"

#: ../../library/inspect.rst:161
msgid "co_code"
msgstr "co_code"

#: ../../library/inspect.rst:161
msgid "string of raw compiled bytecode"
msgstr "строка необработанного скомпилированного байт-кода"

#: ../../library/inspect.rst:164
msgid "co_cellvars"
msgstr "co_cellvars"

#: ../../library/inspect.rst:164
msgid "tuple of names of cell variables (referenced by containing scopes)"
msgstr ""
"кортеж имен переменных ячейки (на которые ссылаются содержащие области "
"видимости)"

#: ../../library/inspect.rst:168
msgid "co_consts"
msgstr "co_consts"

#: ../../library/inspect.rst:168
msgid "tuple of constants used in the bytecode"
msgstr "кортеж констант, используемых в байт-коде"

#: ../../library/inspect.rst:171
msgid "co_filename"
msgstr "co_filename"

#: ../../library/inspect.rst:171
msgid "name of file in which this code object was created"
msgstr "имя файла, в котором был создан этот объект кода"

#: ../../library/inspect.rst:175
msgid "co_firstlineno"
msgstr "co_firstlineno"

#: ../../library/inspect.rst:175
msgid "number of first line in Python source code"
msgstr "номер первой строки в исходном коде Python"

#: ../../library/inspect.rst:178
msgid "co_flags"
msgstr "co_flags"

#: ../../library/inspect.rst:178
msgid ""
"bitmap of ``CO_*`` flags, read more :ref:`here <inspect-module-co-flags>`"
msgstr ""
"растровое изображение флагов ``CO_*``, подробнее :ref:`здесь <inspect-module-"
"co-flags>`"

#: ../../library/inspect.rst:182
msgid "co_lnotab"
msgstr "co_lnotab"

#: ../../library/inspect.rst:182
msgid "encoded mapping of line numbers to bytecode indices"
msgstr "закодированное сопоставление номеров строк с индексами байт-кода"

#: ../../library/inspect.rst:186
msgid "co_freevars"
msgstr "co_freevars"

#: ../../library/inspect.rst:186
msgid "tuple of names of free variables (referenced via a function's closure)"
msgstr ""
"кортеж имен свободных переменных (на которые ссылаются через замыкание "
"функции)"

#: ../../library/inspect.rst:190
msgid "co_posonlyargcount"
msgstr "co_posonlyargcount"

#: ../../library/inspect.rst:190
msgid "number of positional only arguments"
msgstr "количество только позиционных аргументов"

#: ../../library/inspect.rst:193
msgid "co_kwonlyargcount"
msgstr "co_kwonlyargcount"

#: ../../library/inspect.rst:193
msgid "number of keyword only arguments (not including \\*\\* arg)"
msgstr ""
"количество аргументов, состоящих только из ключевых слов (не включая \\*\\* "
"arg)"

#: ../../library/inspect.rst:197
msgid "co_name"
msgstr "co_name"

#: ../../library/inspect.rst:197
msgid "name with which this code object was defined"
msgstr "имя, с которым был определен этот объект кода"

#: ../../library/inspect.rst:200
msgid "co_qualname"
msgstr "co_qualname"

#: ../../library/inspect.rst:200
msgid "fully qualified name with which this code object was defined"
msgstr "полное имя, с которым был определен этот объект кода"

#: ../../library/inspect.rst:204
msgid "co_names"
msgstr "co_names"

#: ../../library/inspect.rst:204
msgid "tuple of names other than arguments and function locals"
msgstr "кортеж имен, отличных от аргументов и локальных переменных функции"

#: ../../library/inspect.rst:208
msgid "co_nlocals"
msgstr "co_nlocals"

#: ../../library/inspect.rst:208
msgid "number of local variables"
msgstr "количество локальных переменных"

#: ../../library/inspect.rst:210
msgid "co_stacksize"
msgstr "co_stacksize"

#: ../../library/inspect.rst:210
msgid "virtual machine stack space required"
msgstr "требуется место в стеке виртуальной машины"

#: ../../library/inspect.rst:213
msgid "co_varnames"
msgstr "co_varnames"

#: ../../library/inspect.rst:213
msgid "tuple of names of arguments and local variables"
msgstr "кортеж имен аргументов и локальных переменных"

#: ../../library/inspect.rst:217
msgid "generator"
msgstr "генератор"

#: ../../library/inspect.rst:217 ../../library/inspect.rst:231
#: ../../library/inspect.rst:244
msgid "name"
msgstr "имя"

#: ../../library/inspect.rst:221
msgid "gi_frame"
msgstr "gi_frame"

#: ../../library/inspect.rst:223
msgid "gi_running"
msgstr "gi_running"

#: ../../library/inspect.rst:223 ../../library/inspect.rst:240
msgid "is the generator running?"
msgstr "генератор работает?"

#: ../../library/inspect.rst:225
msgid "gi_code"
msgstr "gi_code"

#: ../../library/inspect.rst:227
msgid "gi_yieldfrom"
msgstr "gi_yieldfrom"

#: ../../library/inspect.rst:227
msgid "object being iterated by ``yield from``, or ``None``"
msgstr "объект, итерируемый по ``yield from`` или ``None``"

#: ../../library/inspect.rst:231
msgid "async generator"
msgstr "асинхронный генератор"

#: ../../library/inspect.rst:235
msgid "ag_await"
msgstr "ag_await"

#: ../../library/inspect.rst:235 ../../library/inspect.rst:248
msgid "object being awaited on, or ``None``"
msgstr "ожидаемый объект или ``Нет``"

#: ../../library/inspect.rst:238
msgid "ag_frame"
msgstr "ag_frame"

#: ../../library/inspect.rst:240
msgid "ag_running"
msgstr "ag_running"

#: ../../library/inspect.rst:242
msgid "ag_code"
msgstr "ag_code"

#: ../../library/inspect.rst:244
msgid "coroutine"
msgstr "корутина"

#: ../../library/inspect.rst:248
msgid "cr_await"
msgstr "cr_await"

#: ../../library/inspect.rst:251
msgid "cr_frame"
msgstr "cr_frame"

#: ../../library/inspect.rst:253
msgid "cr_running"
msgstr "cr_running"

#: ../../library/inspect.rst:253
msgid "is the coroutine running?"
msgstr "сопрограмма работает?"

#: ../../library/inspect.rst:255
msgid "cr_code"
msgstr "cr_code"

#: ../../library/inspect.rst:257
msgid "cr_origin"
msgstr "cr_origin"

#: ../../library/inspect.rst:257
msgid "where coroutine was created, or ``None``. See |coroutine-origin-link|"
msgstr ""
"где была создана сопрограмма, или «Нет». Видеть |ссылка-исходная-корутина|"

#: ../../library/inspect.rst:261
msgid "builtin"
msgstr "встроенный"

#: ../../library/inspect.rst:263
msgid "original name of this function or method"
msgstr "оригинальное имя этой функции или метода"

#: ../../library/inspect.rst:268
msgid "instance to which a method is bound, or ``None``"
msgstr "экземпляр, к которому привязан метод, или ``None``"

#: ../../library/inspect.rst:275
msgid "Add ``__qualname__`` and ``gi_yieldfrom`` attributes to generators."
msgstr "Добавьте атрибуты __qualname__ и gi_yieldfrom в генераторы."

#: ../../library/inspect.rst:277
msgid ""
"The ``__name__`` attribute of generators is now set from the function name, "
"instead of the code name, and it can now be modified."
msgstr ""
"Атрибут генераторов ``__name__`` теперь устанавливается по имени функции, а "
"не по кодовому имени, и теперь его можно изменить."

#: ../../library/inspect.rst:282
msgid "Add ``cr_origin`` attribute to coroutines."
msgstr "Добавьте атрибут cr_origin в сопрограммы."

#: ../../library/inspect.rst:286
msgid "Add ``__builtins__`` attribute to functions."
msgstr "Добавьте атрибут ``__builtins__`` к функциям."

#: ../../library/inspect.rst:290
msgid ""
"Return all the members of an object in a list of ``(name, value)`` pairs "
"sorted by name. If the optional *predicate* argument—which will be called "
"with the ``value`` object of each member—is supplied, only members for which "
"the predicate returns a true value are included."
msgstr ""
"Возвращает все члены объекта в списке пар ``(имя, значение)``, "
"отсортированных по имени. Если указан необязательный аргумент *predicate*, "
"который будет вызываться с объектом ``value`` каждого члена, будут включены "
"только те элементы, для которых предикат возвращает истинное значение."

#: ../../library/inspect.rst:297
msgid ""
":func:`getmembers` will only return class attributes defined in the "
"metaclass when the argument is a class and those attributes have been listed "
"in the metaclass' custom :meth:`~object.__dir__`."
msgstr ""
":func:`getmembers` будет возвращать атрибуты класса, определенные в "
"метаклассе, только если аргументом является класс и эти атрибуты перечислены "
"в пользовательском :meth:`~object.__dir__` метакласса."

#: ../../library/inspect.rst:304
msgid ""
"Return all the members of an object in a list of ``(name, value)`` pairs "
"sorted by name without triggering dynamic lookup via the descriptor "
"protocol, __getattr__ or __getattribute__. Optionally, only return members "
"that satisfy a given predicate."
msgstr ""
"Возвращает все члены объекта в списке пар ``(имя, значение)``, "
"отсортированных по имени, без запуска динамического поиска через протокол "
"дескриптора __getattr__ или __getattribute__. При необходимости возвращайте "
"только те члены, которые удовлетворяют заданному предикату."

#: ../../library/inspect.rst:311
msgid ""
":func:`getmembers_static` may not be able to retrieve all members that "
"getmembers can fetch (like dynamically created attributes) and may find "
"members that getmembers can't (like descriptors that raise AttributeError). "
"It can also return descriptor objects instead of instance members in some "
"cases."
msgstr ""
":func:`getmembers_static` может быть не в состоянии получить все члены, "
"которые getmembers может получить (например, динамически созданные "
"атрибуты), и может найти элементы, которые getmembers не может (например, "
"дескрипторы, которые вызывают AttributeError). В некоторых случаях он также "
"может возвращать объекты дескриптора вместо членов экземпляра."

#: ../../library/inspect.rst:322
msgid ""
"Return the name of the module named by the file *path*, without including "
"the names of enclosing packages. The file extension is checked against all "
"of the entries in :func:`importlib.machinery.all_suffixes`. If it matches, "
"the final path component is returned with the extension removed. Otherwise, "
"``None`` is returned."
msgstr ""
"Возвращает имя модуля, указанного в файле *path*, без включения имен "
"включающих его пакетов. Расширение файла проверяется по всем записям в :func:"
"`importlib.machinery.all_suffixes`. Если оно соответствует, последний "
"компонент пути возвращается с удаленным расширением. В противном случае "
"возвращается ``None``."

#: ../../library/inspect.rst:328
msgid ""
"Note that this function *only* returns a meaningful name for actual Python "
"modules - paths that potentially refer to Python packages will still return "
"``None``."
msgstr ""
"Обратите внимание, что эта функция *только* возвращает осмысленное имя для "
"реальных модулей Python — пути, которые потенциально ссылаются на пакеты "
"Python, все равно будут возвращать ``None``."

#: ../../library/inspect.rst:332
msgid "The function is based directly on :mod:`importlib`."
msgstr "Функция основана непосредственно на :mod:`importlib`."

#: ../../library/inspect.rst:338
msgid "Return ``True`` if the object is a module."
msgstr "Верните True, если объект является модулем."

#: ../../library/inspect.rst:343
msgid ""
"Return ``True`` if the object is a class, whether built-in or created in "
"Python code."
msgstr ""
"Возвращайте True, если объект является классом, встроенным или созданным в "
"коде Python."

#: ../../library/inspect.rst:349
msgid "Return ``True`` if the object is a bound method written in Python."
msgstr ""
"Верните ``True``, если объект является привязанным методом, написанным на "
"Python."

#: ../../library/inspect.rst:354
msgid ""
"Return ``True`` if the object is a Python function, which includes functions "
"created by a :term:`lambda` expression."
msgstr ""
"Возвращайте ``True``, если объект является функцией Python, которая включает "
"в себя функции, созданные с помощью выражения :term:`lambda`."

#: ../../library/inspect.rst:360
msgid "Return ``True`` if the object is a Python generator function."
msgstr "Верните True, если объект является функцией генератора Python."

#: ../../library/inspect.rst:362
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the "
"wrapped function is a Python generator function."
msgstr ""
"Функции, заключенные в :func:`functools.partial`, теперь возвращают "
"``True``, если обернутая функция является функцией генератора Python."

#: ../../library/inspect.rst:369
msgid "Return ``True`` if the object is a generator."
msgstr "Верните True, если объект является генератором."

#: ../../library/inspect.rst:374
msgid ""
"Return ``True`` if the object is a :term:`coroutine function` (a function "
"defined with an :keyword:`async def` syntax), a :func:`functools.partial` "
"wrapping a :term:`coroutine function`, or a sync function marked with :func:"
"`markcoroutinefunction`."
msgstr ""
"Возвращает ``True``, если объект представляет собой :term:`coroutine "
"function` (функция, определенная с помощью :keyword:`async def` "
"синтаксиса), :func:`functools.partial`, обертывающий :term:`coroutine "
"function` или функцию синхронизации, отмеченную :func:"
"`markcoroutinefunction`."

#: ../../library/inspect.rst:381
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the "
"wrapped function is a :term:`coroutine function`."
msgstr ""
"Функции, заключенные в :func:`functools.partial`, теперь возвращают "
"``True``, если обернутая функция является :term:`сопрограммой`."

#: ../../library/inspect.rst:385
msgid ""
"Sync functions marked with :func:`markcoroutinefunction` now return ``True``."
msgstr ""
"Функции синхронизации, отмеченные :func:`markcoroutinefunction`, теперь "
"возвращают ``True``."

#: ../../library/inspect.rst:392
msgid ""
"Decorator to mark a callable as a :term:`coroutine function` if it would not "
"otherwise be detected by :func:`iscoroutinefunction`."
msgstr ""
"Декоратор, чтобы пометить вызываемый объект как :term:`coroutine function`, "
"если иначе он не был бы обнаружен :func:`iscoroutinefunction`."

#: ../../library/inspect.rst:395
msgid ""
"This may be of use for sync functions that return a :term:`coroutine`, if "
"the function is passed to an API that requires :func:`iscoroutinefunction`."
msgstr ""
"Это может быть полезно для функций синхронизации, которые возвращают :term:"
"`coroutine`, если функция передается в API, которому требуется :func:"
"`iscoroutinefunction`."

#: ../../library/inspect.rst:398
msgid ""
"When possible, using an :keyword:`async def` function is preferred. Also "
"acceptable is calling the function and testing the return with :func:"
"`iscoroutine`."
msgstr ""
"Когда это возможно, предпочтительнее использовать функцию :keyword:`async "
"def`. Также приемлемым является вызов функции и проверка возврата с помощью :"
"func:`iscoroutine`."

#: ../../library/inspect.rst:407
msgid ""
"Return ``True`` if the object is a :term:`coroutine` created by an :keyword:"
"`async def` function."
msgstr ""
"Возвращайте ``True``, если объект является :term:`сопрограммой`, созданной :"
"keyword:`async def` функцией."

#: ../../library/inspect.rst:415
msgid ""
"Return ``True`` if the object can be used in :keyword:`await` expression."
msgstr ""
"Верните True, если объект можно использовать в выражении :keyword:`await`."

#: ../../library/inspect.rst:417
msgid ""
"Can also be used to distinguish generator-based coroutines from regular "
"generators:"
msgstr ""
"Также может использоваться для отличия сопрограмм на основе генератора от "
"обычных генераторов:"

#: ../../library/inspect.rst:420
msgid ""
"import types\n"
"\n"
"def gen():\n"
"    yield\n"
"@types.coroutine\n"
"def gen_coro():\n"
"    yield\n"
"\n"
"assert not isawaitable(gen())\n"
"assert isawaitable(gen_coro())"
msgstr ""
"import types\n"
"\n"
"def gen():\n"
"    yield\n"
"@types.coroutine\n"
"def gen_coro():\n"
"    yield\n"
"\n"
"assert not isawaitable(gen())\n"
"assert isawaitable(gen_coro())"

#: ../../library/inspect.rst:438
msgid ""
"Return ``True`` if the object is an :term:`asynchronous generator` function, "
"for example:"
msgstr ""
"Верните True, если объект является функцией асинхронного генератора, "
"например:"

#: ../../library/inspect.rst:441
msgid ""
">>> async def agen():\n"
"...     yield 1\n"
"...\n"
">>> inspect.isasyncgenfunction(agen)\n"
"True"
msgstr ""
">>> async def agen():\n"
"...     yield 1\n"
"...\n"
">>> inspect.isasyncgenfunction(agen)\n"
"True"

#: ../../library/inspect.rst:451
msgid ""
"Functions wrapped in :func:`functools.partial` now return ``True`` if the "
"wrapped function is an :term:`asynchronous generator` function."
msgstr ""
"Функции, заключенные в :func:`functools.partial`, теперь возвращают "
"``True``, если обернутая функция является функцией :term:`асинхронного "
"генератора`."

#: ../../library/inspect.rst:458
msgid ""
"Return ``True`` if the object is an :term:`asynchronous generator iterator` "
"created by an :term:`asynchronous generator` function."
msgstr ""
"Возвращает ``True``, если объект является :term:`итератором асинхронного "
"генератора`, созданным функцией :term:`асинхронного генератора`."

#: ../../library/inspect.rst:465
msgid "Return ``True`` if the object is a traceback."
msgstr "Верните ``True``, если объект является обратной трассировкой."

#: ../../library/inspect.rst:470
msgid "Return ``True`` if the object is a frame."
msgstr "Верните True, если объект является фреймом."

#: ../../library/inspect.rst:475
msgid "Return ``True`` if the object is a code."
msgstr "Верните ``True``, если объект является кодом."

#: ../../library/inspect.rst:480
msgid ""
"Return ``True`` if the object is a built-in function or a bound built-in "
"method."
msgstr ""
"Возвращайте True, если объект является встроенной функцией или связанным "
"встроенным методом."

#: ../../library/inspect.rst:485
msgid ""
"Return ``True`` if the type of object is a :class:`~types.MethodWrapperType`."
msgstr ""
"Возвращает ``True``, если тип объекта — :class:`~types.MethodWrapperType`."

#: ../../library/inspect.rst:487
msgid ""
"These are instances of :class:`~types.MethodWrapperType`, such as :meth:"
"`~object.__str__`, :meth:`~object.__eq__` and :meth:`~object.__repr__`."
msgstr ""
"Это экземпляры :class:`~types.MethodWrapperType`, такие как :meth:`~object."
"__str__`, :meth:`~object.__eq__` и :meth:`~object.__repr__`."

#: ../../library/inspect.rst:495
msgid ""
"Return ``True`` if the object is a user-defined or built-in function or "
"method."
msgstr ""
"Возвращайте True, если объект является пользовательской или встроенной "
"функцией или методом."

#: ../../library/inspect.rst:500
msgid "Return ``True`` if the object is an abstract base class."
msgstr "Верните ``True``, если объект является абстрактным базовым классом."

#: ../../library/inspect.rst:505
msgid ""
"Return ``True`` if the object is a method descriptor, but not if :func:"
"`ismethod`, :func:`isclass`, :func:`isfunction` or :func:`isbuiltin` are "
"true."
msgstr ""
"Возвращайте ``True``, если объект является дескриптором метода, но не в том "
"случае, если :func:`ismethod`, :func:`isclass`, :func:`isfunction` или :func:"
"`isbuiltin` имеют значение true."

#: ../../library/inspect.rst:509
msgid ""
"This, for example, is true of ``int.__add__``.  An object passing this test "
"has a :meth:`~object.__get__` method but not a :meth:`~object.__set__` "
"method, but beyond that the set of attributes varies.  A :attr:`~definition."
"__name__` attribute is usually sensible, and :attr:`~definition.__doc__` "
"often is."
msgstr ""
"Это, например, справедливо для ``int.__add__``. Объект, прошедший этот тест, "
"имеет метод :meth:`~object.__get__`, но не имеет метода :meth:`~object."
"__set__`, но помимо этого набор атрибутов варьируется. Атрибут :attr:"
"`~definition.__name__` обычно имеет смысл, как и :attr:`~definition.__doc__`."

#: ../../library/inspect.rst:515
msgid ""
"Methods implemented via descriptors that also pass one of the other tests "
"return ``False`` from the :func:`ismethoddescriptor` test, simply because "
"the other tests promise more -- you can, e.g., count on having the :attr:"
"`~method.__func__` attribute (etc) when an object passes :func:`ismethod`."
msgstr ""
"Методы, реализованные через дескрипторы, которые также проходят один из "
"других тестов, возвращают значение False из теста :func:`ismethoddescriptor` "
"просто потому, что другие тесты обещают больше - вы можете, например, "
"рассчитывать на наличие :attr:` Атрибут ~method.__func__` (и т. д.), когда "
"объект передает :func:`ismethod`."

#: ../../library/inspect.rst:524
msgid "Return ``True`` if the object is a data descriptor."
msgstr "Верните True, если объект является дескриптором данных."

#: ../../library/inspect.rst:526
msgid ""
"Data descriptors have a :attr:`~object.__set__` or a :attr:`~object."
"__delete__` method. Examples are properties (defined in Python), getsets, "
"and members.  The latter two are defined in C and there are more specific "
"tests available for those types, which is robust across Python "
"implementations.  Typically, data descriptors will also have :attr:"
"`~definition.__name__` and :attr:`!__doc__` attributes (properties, getsets, "
"and members have both of these attributes), but this is not guaranteed."
msgstr ""
"Дескрипторы данных имеют метод :attr:`~object.__set__` или :attr:`~object."
"__delete__`. Примерами являются свойства (определенные в Python), наборы "
"данных и члены. Последние два определены в C, и для этих типов доступны "
"более конкретные тесты, которые устойчивы во всех реализациях Python. Обычно "
"дескрипторы данных также имеют атрибуты :attr:`~definition.__name__` и :attr:"
"`!__doc__` (свойства, getsets и члены имеют оба этих атрибута), но это не "
"гарантируется."

#: ../../library/inspect.rst:537
msgid "Return ``True`` if the object is a getset descriptor."
msgstr "Верните True, если объект является дескриптором getset."

#: ../../library/inspect.rst:541
msgid ""
"getsets are attributes defined in extension modules via :c:type:"
"`PyGetSetDef` structures.  For Python implementations without such types, "
"this method will always return ``False``."
msgstr ""
"getsets — это атрибуты, определенные в модулях расширения через структуры :c:"
"type:`PyGetSetDef`. Для реализаций Python без таких типов этот метод всегда "
"будет возвращать False."

#: ../../library/inspect.rst:548
msgid "Return ``True`` if the object is a member descriptor."
msgstr "Верните True, если объект является дескриптором-членом."

#: ../../library/inspect.rst:552
msgid ""
"Member descriptors are attributes defined in extension modules via :c:type:"
"`PyMemberDef` structures.  For Python implementations without such types, "
"this method will always return ``False``."
msgstr ""
"Дескрипторы членов — это атрибуты, определенные в модулях расширения через "
"структуры :c:type:`PyMemberDef`. Для реализаций Python без таких типов этот "
"метод всегда будет возвращать False."

#: ../../library/inspect.rst:560
msgid "Retrieving source code"
msgstr "Получение исходного кода"

#: ../../library/inspect.rst:564
msgid ""
"Get the documentation string for an object, cleaned up with :func:"
"`cleandoc`. If the documentation string for an object is not provided and "
"the object is a class, a method, a property or a descriptor, retrieve the "
"documentation string from the inheritance hierarchy. Return ``None`` if the "
"documentation string is invalid or missing."
msgstr ""
"Получите строку документации для объекта, очищенную с помощью :func:"
"`cleandoc`. Если строка документации для объекта не указана и объект "
"является классом, методом, свойством или дескриптором, извлеките строку "
"документации из иерархии наследования. Верните None, если строка "
"документации недействительна или отсутствует."

#: ../../library/inspect.rst:570
msgid "Documentation strings are now inherited if not overridden."
msgstr "Строки документации теперь наследуются, если не переопределяются."

#: ../../library/inspect.rst:576
msgid ""
"Return in a single string any lines of comments immediately preceding the "
"object's source code (for a class, function, or method), or at the top of "
"the Python source file (if the object is a module).  If the object's source "
"code is unavailable, return ``None``.  This could happen if the object has "
"been defined in C or the interactive shell."
msgstr ""
"Возвращайте в одной строке любые строки комментариев, непосредственно "
"предшествующие исходному коду объекта (для класса, функции или метода) или в "
"верхней части исходного файла Python (если объект является модулем). Если "
"исходный код объекта недоступен, верните None. Это может произойти, если "
"объект определен на языке C или в интерактивной оболочке."

#: ../../library/inspect.rst:585
msgid ""
"Return the name of the (text or binary) file in which an object was defined. "
"This will fail with a :exc:`TypeError` if the object is a built-in module, "
"class, or function."
msgstr ""
"Возвращает имя файла (текстового или двоичного), в котором был определен "
"объект. Это завершится ошибкой :exc:`TypeError`, если объект является "
"встроенным модулем, классом или функцией."

#: ../../library/inspect.rst:592
msgid ""
"Try to guess which module an object was defined in. Return ``None`` if the "
"module cannot be determined."
msgstr ""
"Попробуйте угадать, в каком модуле был определен объект. Верните None, если "
"модуль не может быть определен."

#: ../../library/inspect.rst:598
msgid ""
"Return the name of the Python source file in which an object was defined or "
"``None`` if no way can be identified to get the source.  This will fail with "
"a :exc:`TypeError` if the object is a built-in module, class, or function."
msgstr ""
"Возвращает имя исходного файла Python, в котором был определен объект, или "
"«Нет», если невозможно определить способ получения источника. Это завершится "
"ошибкой :exc:`TypeError`, если объект является встроенным модулем, классом "
"или функцией."

#: ../../library/inspect.rst:606
msgid ""
"Return a list of source lines and starting line number for an object. The "
"argument may be a module, class, method, function, traceback, frame, or code "
"object.  The source code is returned as a list of the lines corresponding to "
"the object and the line number indicates where in the original source file "
"the first line of code was found.  An :exc:`OSError` is raised if the source "
"code cannot be retrieved. A :exc:`TypeError` is raised if the object is a "
"built-in module, class, or function."
msgstr ""
"Возвращает список исходных строк и номер начальной строки объекта. "
"Аргументом может быть модуль, класс, метод, функция, обратная трассировка, "
"кадр или объект кода. Исходный код возвращается в виде списка строк, "
"соответствующих объекту, а номер строки указывает, где в исходном файле была "
"найдена первая строка кода. Ошибка :exc:`OSError` возникает, если исходный "
"код не может быть получен. Ошибка :exc:`TypeError` возникает, если объект "
"является встроенным модулем, классом или функцией."

#: ../../library/inspect.rst:615 ../../library/inspect.rst:629
msgid ""
":exc:`OSError` is raised instead of :exc:`IOError`, now an alias of the "
"former."
msgstr ""
":exc:`OSError` возникает вместо :exc:`IOError`, который теперь является "
"псевдонимом первого."

#: ../../library/inspect.rst:622
msgid ""
"Return the text of the source code for an object. The argument may be a "
"module, class, method, function, traceback, frame, or code object.  The "
"source code is returned as a single string.  An :exc:`OSError` is raised if "
"the source code cannot be retrieved. A :exc:`TypeError` is raised if the "
"object is a built-in module, class, or function."
msgstr ""
"Возвращает текст исходного кода объекта. Аргументом может быть модуль, "
"класс, метод, функция, обратная трассировка, кадр или объект кода. Исходный "
"код возвращается в виде одной строки. Ошибка :exc:`OSError` возникает, если "
"исходный код не может быть получен. Ошибка :exc:`TypeError` возникает, если "
"объект является встроенным модулем, классом или функцией."

#: ../../library/inspect.rst:636
msgid ""
"Clean up indentation from docstrings that are indented to line up with "
"blocks of code."
msgstr ""
"Удалите отступы в строках документации, которые имеют отступы, "
"соответствующие блокам кода."

#: ../../library/inspect.rst:639
msgid ""
"All leading whitespace is removed from the first line.  Any leading "
"whitespace that can be uniformly removed from the second line onwards is "
"removed.  Empty lines at the beginning and end are subsequently removed.  "
"Also, all tabs are expanded to spaces."
msgstr ""
"Все ведущие пробелы удаляются из первой строки. Любые ведущие пробелы, "
"которые можно равномерно удалить, начиная со второй строки, удаляются. "
"Пустые строки в начале и конце впоследствии удаляются. Также все табы "
"разворачиваются до пробелов."

#: ../../library/inspect.rst:648
msgid "Introspecting callables with the Signature object"
msgstr "Анализ вызываемых объектов с помощью объекта Signature"

#: ../../library/inspect.rst:652
msgid ""
"The :class:`Signature` object represents the call signature of a callable "
"object and its return annotation. To retrieve a :class:`!Signature` object, "
"use the :func:`!signature` function."
msgstr ""
"Объект :class:`Signature` представляет подпись вызова вызываемого объекта и "
"его возвращаемую аннотацию. Чтобы получить объект :class:`!Signature`, "
"используйте функцию :func:`!signature`."

#: ../../library/inspect.rst:659
msgid "Return a :class:`Signature` object for the given *callable*:"
msgstr "Вернуть объект :class:`Signature` для данного *callable*:"

#: ../../library/inspect.rst:661
msgid ""
">>> from inspect import signature\n"
">>> def foo(a, *, b:int, **kwargs):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
"\n"
">>> str(sig)\n"
"'(a, *, b: int, **kwargs)'\n"
"\n"
">>> str(sig.parameters['b'])\n"
"'b: int'\n"
"\n"
">>> sig.parameters['b'].annotation\n"
"<class 'int'>"
msgstr ""
">>> from inspect import signature\n"
">>> def foo(a, *, b:int, **kwargs):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
"\n"
">>> str(sig)\n"
"'(a, *, b: int, **kwargs)'\n"
"\n"
">>> str(sig.parameters['b'])\n"
"'b: int'\n"
"\n"
">>> sig.parameters['b'].annotation\n"
"<class 'int'>"

#: ../../library/inspect.rst:678
msgid ""
"Accepts a wide range of Python callables, from plain functions and classes "
"to :func:`functools.partial` objects."
msgstr ""
"Принимает широкий спектр вызовов Python, от простых функций и классов до "
"объектов :func:`functools.partial`."

#: ../../library/inspect.rst:681
msgid ""
"For objects defined in modules using stringized annotations (``from "
"__future__ import annotations``), :func:`signature` will attempt to "
"automatically un-stringize the annotations using :func:`get_annotations`.  "
"The *globals*, *locals*, and *eval_str* parameters are passed into :func:"
"`get_annotations` when resolving the annotations; see the documentation for :"
"func:`get_annotations` for instructions on how to use these parameters."
msgstr ""
"Для объектов, определенных в модулях с использованием строковых аннотаций "
"(``из __future__ import annotations``), :func:`signature` попытается "
"автоматически удалить строки из аннотаций, используя :func:"
"`get_annotations`. Параметры *globals*, *locals* и *eval_str* передаются в :"
"func:`get_annotations` при разрешении аннотаций; инструкции по использованию "
"этих параметров см. в документации :func:`get_annotations`."

#: ../../library/inspect.rst:690
msgid ""
"Raises :exc:`ValueError` if no signature can be provided, and :exc:"
"`TypeError` if that type of object is not supported.  Also, if the "
"annotations are stringized, and *eval_str* is not false, the ``eval()`` "
"call(s) to un-stringize the annotations in :func:`get_annotations` could "
"potentially raise any kind of exception."
msgstr ""
"Вызывает :exc:`ValueError`, если подпись не может быть предоставлена, и :exc:"
"`TypeError`, если этот тип объекта не поддерживается. Кроме того, если "
"аннотации имеют строковую форму и *eval_str* не имеет значения false, вызовы "
"``eval()`` для удаления строковых аннотаций в :func:`get_annotations` "
"потенциально могут вызвать любое исключение."

#: ../../library/inspect.rst:696
msgid ""
"A slash(/) in the signature of a function denotes that the parameters prior "
"to it are positional-only. For more info, see :ref:`the FAQ entry on "
"positional-only parameters <faq-positional-only-arguments>`."
msgstr ""
"Косая черта (/) в сигнатуре функции означает, что параметры перед ней "
"являются только позиционными. Для получения дополнительной информации см. :"
"ref:`запись часто задаваемых вопросов о позиционных параметрах <faq-"
"positional-only-arguments>`."

#: ../../library/inspect.rst:700
msgid ""
"The *follow_wrapped* parameter was added. Pass ``False`` to get a signature "
"of *callable* specifically (``callable.__wrapped__`` will not be used to "
"unwrap decorated callables.)"
msgstr ""
"Добавлен параметр *follow_wrapped*. Передайте ``False``, чтобы получить "
"подпись *callable* (``callable.__wrapped__`` не будет использоваться для "
"развертывания декорированных вызываемых объектов.)"

#: ../../library/inspect.rst:706 ../../library/inspect.rst:816
msgid "The *globals*, *locals*, and *eval_str* parameters were added."
msgstr "Были добавлены параметры *globals*, *locals* и *eval_str*."

#: ../../library/inspect.rst:711
msgid ""
"Some callables may not be introspectable in certain implementations of "
"Python.  For example, in CPython, some built-in functions defined in C "
"provide no metadata about their arguments."
msgstr ""
"Некоторые вызываемые объекты могут быть недоступны для самоанализа в "
"некоторых реализациях Python. Например, в CPython некоторые встроенные "
"функции, определенные в C, не предоставляют метаданных о своих аргументах."

#: ../../library/inspect.rst:717
msgid ""
"If the passed object has a :attr:`!__signature__` attribute, we may use it "
"to create the signature. The exact semantics are an implementation detail "
"and are subject to unannounced changes. Consult the source code for current "
"semantics."
msgstr ""
"Если переданный объект имеет атрибут :attr:`!__signature__`, мы можем "
"использовать его для создания подписи. Точная семантика является деталью "
"реализации и может быть изменена без предварительного уведомления. "
"Обратитесь к исходному коду для получения текущей семантики."

#: ../../library/inspect.rst:725
msgid ""
"A :class:`!Signature` object represents the call signature of a function and "
"its return annotation.  For each parameter accepted by the function it "
"stores a :class:`Parameter` object in its :attr:`parameters` collection."
msgstr ""
"Объект :class:`!Signature` представляет сигнатуру вызова функции и аннотацию "
"ее возврата. Для каждого параметра, принимаемого функцией, она сохраняет "
"объект :class:`Parameter` в своей коллекции :attr:`parameters`."

#: ../../library/inspect.rst:730
msgid ""
"The optional *parameters* argument is a sequence of :class:`Parameter` "
"objects, which is validated to check that there are no parameters with "
"duplicate names, and that the parameters are in the right order, i.e. "
"positional-only first, then positional-or-keyword, and that parameters with "
"defaults follow parameters without defaults."
msgstr ""
"Необязательный аргумент *parameters* представляет собой последовательность "
"объектов :class:`Parameter`, которая проверяется на отсутствие параметров с "
"повторяющимися именами и на то, что параметры находятся в правильном "
"порядке, т.е. сначала только позиционные, затем позиционные. -или-ключевое "
"слово, и что параметры со значениями по умолчанию следуют за параметрами без "
"значений по умолчанию."

#: ../../library/inspect.rst:736
msgid ""
"The optional *return_annotation* argument can be an arbitrary Python object. "
"It represents the \"return\" annotation of the callable."
msgstr ""
"Необязательный аргумент *return_annotation* может быть произвольным объектом "
"Python. Он представляет собой аннотацию «возврата» вызываемого объекта."

#: ../../library/inspect.rst:739
msgid ""
":class:`!Signature` objects are *immutable*.  Use :meth:`Signature.replace` "
"to make a modified copy."
msgstr ""
":class:`!Signature` объекты *неизменяемы*. Используйте :meth:`Signature."
"replace`, чтобы создать измененную копию."

#: ../../library/inspect.rst:742
msgid ":class:`!Signature` objects are now picklable and :term:`hashable`."
msgstr ""
"Объекты :class:`!Signature` теперь можно выбирать и :term:`хешировать`."

#: ../../library/inspect.rst:747
msgid "A special class-level marker to specify absence of a return annotation."
msgstr ""
"Специальный маркер уровня класса, указывающий отсутствие аннотации возврата."

#: ../../library/inspect.rst:751
msgid ""
"An ordered mapping of parameters' names to the corresponding :class:"
"`Parameter` objects.  Parameters appear in strict definition order, "
"including keyword-only parameters."
msgstr ""
"Упорядоченное сопоставление имен параметров с соответствующими объектами :"
"class:`Parameter`. Параметры отображаются в строгом порядке определения, "
"включая параметры, содержащие только ключевые слова."

#: ../../library/inspect.rst:755 ../../library/inspect.rst:1093
msgid ""
"Python only explicitly guaranteed that it preserved the declaration order of "
"keyword-only parameters as of version 3.7, although in practice this order "
"had always been preserved in Python 3."
msgstr ""
"Python только явно гарантировал, что он сохраняет порядок объявления "
"параметров, содержащих только ключевые слова, начиная с версии 3.7, хотя на "
"практике этот порядок всегда сохранялся в Python 3."

#: ../../library/inspect.rst:762
msgid ""
"The \"return\" annotation for the callable.  If the callable has no "
"\"return\" annotation, this attribute is set to :attr:`Signature.empty`."
msgstr ""
"Аннотация «возврата» для вызываемого объекта. Если вызываемый объект не "
"имеет аннотации «возврат», для этого атрибута установлено значение :attr:"
"`Signature.empty`."

#: ../../library/inspect.rst:767
msgid ""
"Create a mapping from positional and keyword arguments to parameters. "
"Returns :class:`BoundArguments` if ``*args`` and ``**kwargs`` match the "
"signature, or raises a :exc:`TypeError`."
msgstr ""
"Создайте сопоставление позиционных и ключевых аргументов с параметрами. "
"Возвращает :class:`BoundArguments`, если ``*args`` и ``**kwargs`` "
"соответствуют сигнатуре, или вызывает :exc:`TypeError`."

#: ../../library/inspect.rst:773
msgid ""
"Works the same way as :meth:`Signature.bind`, but allows the omission of "
"some required arguments (mimics :func:`functools.partial` behavior.) "
"Returns :class:`BoundArguments`, or raises a :exc:`TypeError` if the passed "
"arguments do not match the signature."
msgstr ""
"Работает так же, как :meth:`Signature.bind`, но позволяет опускать некоторые "
"обязательные аргументы (имитирует поведение :func:`functools.partial`). "
"Возвращает :class:`BoundArguments` или вызывает :exc:` TypeError`, если "
"переданные аргументы не соответствуют сигнатуре."

#: ../../library/inspect.rst:780
msgid ""
"Create a new :class:`Signature` instance based on the instance :meth:"
"`replace` was invoked on. It is possible to pass different *parameters* and/"
"or *return_annotation* to override the corresponding properties of the base "
"signature.  To remove ``return_annotation`` from the copied :class:`!"
"Signature`, pass in :attr:`Signature.empty`."
msgstr ""
"Создайте новый экземпляр :class:`Signature` на основе экземпляра :meth:"
"`replace`, который был вызван. Можно передать различные *параметры* и/или "
"*return_annotation*, чтобы переопределить соответствующие свойства базовой "
"подписи. Чтобы удалить ``return_annotation`` из скопированной :class:`!"
"Signature`, передайте :attr:`Signature.empty`."

#: ../../library/inspect.rst:788
msgid ""
">>> def test(a, b):\n"
"...     pass\n"
"...\n"
">>> sig = signature(test)\n"
">>> new_sig = sig.replace(return_annotation=\"new return anno\")\n"
">>> str(new_sig)\n"
"\"(a, b) -> 'new return anno'\""
msgstr ""
">>> def test(a, b):\n"
"...     pass\n"
"...\n"
">>> sig = signature(test)\n"
">>> new_sig = sig.replace(return_annotation=\"new return anno\")\n"
">>> str(new_sig)\n"
"\"(a, b) -> 'new return anno'\""

#: ../../library/inspect.rst:800
msgid ""
"Return a :class:`Signature` (or its subclass) object for a given callable "
"*obj*."
msgstr ""
"Возвращает объект :class:`Signature` (или его подкласс) для данного "
"вызываемого объекта *obj*."

#: ../../library/inspect.rst:803
msgid "This method simplifies subclassing of :class:`Signature`:"
msgstr "Этот метод упрощает создание подклассов :class:`Signature`:"

#: ../../library/inspect.rst:805
msgid ""
"class MySignature(Signature):\n"
"    pass\n"
"sig = MySignature.from_callable(sum)\n"
"assert isinstance(sig, MySignature)"
msgstr ""
"class MySignature(Signature):\n"
"    pass\n"
"sig = MySignature.from_callable(sum)\n"
"assert isinstance(sig, MySignature)"

#: ../../library/inspect.rst:812
msgid "Its behavior is otherwise identical to that of :func:`signature`."
msgstr "В остальном его поведение идентично поведению :func:`signature`."

#: ../../library/inspect.rst:822
msgid ""
":class:`!Parameter` objects are *immutable*. Instead of modifying a :class:`!"
"Parameter` object, you can use :meth:`Parameter.replace` to create a "
"modified copy."
msgstr ""
":class:`!Parameter` объекты *неизменяемы*. Вместо изменения объекта :class:`!"
"Parameter` вы можете использовать :meth:`Parameter.replace` для создания "
"измененной копии."

#: ../../library/inspect.rst:826
msgid "Parameter objects are now picklable and :term:`hashable`."
msgstr "Объекты параметров теперь можно выбирать и хешировать."

#: ../../library/inspect.rst:831
msgid ""
"A special class-level marker to specify absence of default values and "
"annotations."
msgstr ""
"Специальный маркер уровня класса, указывающий отсутствие значений и "
"аннотаций по умолчанию."

#: ../../library/inspect.rst:836
msgid ""
"The name of the parameter as a string.  The name must be a valid Python "
"identifier."
msgstr ""
"Имя параметра в виде строки. Имя должно быть действительным идентификатором "
"Python."

#: ../../library/inspect.rst:841
msgid ""
"CPython generates implicit parameter names of the form ``.0`` on the code "
"objects used to implement comprehensions and generator expressions."
msgstr ""
"CPython генерирует неявные имена параметров в форме ``.0`` для объектов "
"кода, используемых для реализации понятий и выражений генератора."

#: ../../library/inspect.rst:845
msgid ""
"These parameter names are now exposed by this module as names like "
"``implicit0``."
msgstr ""
"Имена этих параметров теперь предоставляются этим модулем как имена типа "
"«implicit0»."

#: ../../library/inspect.rst:851
msgid ""
"The default value for the parameter.  If the parameter has no default value, "
"this attribute is set to :attr:`Parameter.empty`."
msgstr ""
"Значение по умолчанию для параметра. Если параметр не имеет значения по "
"умолчанию, этому атрибуту присваивается значение :attr:`Parameter.empty`."

#: ../../library/inspect.rst:856
msgid ""
"The annotation for the parameter.  If the parameter has no annotation, this "
"attribute is set to :attr:`Parameter.empty`."
msgstr ""
"Аннотация к параметру. Если параметр не имеет аннотации, для этого атрибута "
"установлено значение :attr:`Parameter.empty`."

#: ../../library/inspect.rst:861
msgid ""
"Describes how argument values are bound to the parameter.  The possible "
"values are accessible via :class:`Parameter` (like ``Parameter."
"KEYWORD_ONLY``), and support comparison and ordering, in the following order:"
msgstr ""
"Описывает, как значения аргументов привязываются к параметру. Возможные "
"значения доступны через :class:`Parameter` (например, ``Parameter."
"KEYWORD_ONLY``) и поддерживают сравнение и упорядочивание в следующем "
"порядке:"

#: ../../library/inspect.rst:868
msgid "Name"
msgstr "Имя"

#: ../../library/inspect.rst:868
msgid "Meaning"
msgstr "Значение"

#: ../../library/inspect.rst:870
msgid "*POSITIONAL_ONLY*"
msgstr "*POSITIONAL_ONLY*"

#: ../../library/inspect.rst:870
msgid ""
"Value must be supplied as a positional argument. Positional only parameters "
"are those which appear before a ``/`` entry (if present) in a Python "
"function definition."
msgstr ""
"Значение должно быть указано как позиционный аргумент. Только позиционные "
"параметры — это те, которые появляются перед записью ``/`` (если она "
"присутствует) в определении функции Python."

#: ../../library/inspect.rst:875
msgid "*POSITIONAL_OR_KEYWORD*"
msgstr "*POSITIONAL_OR_KEYWORD*"

#: ../../library/inspect.rst:875
msgid ""
"Value may be supplied as either a keyword or positional argument (this is "
"the standard binding behaviour for functions implemented in Python.)"
msgstr ""
"Значение может быть предоставлено как ключевое слово или позиционный "
"аргумент (это стандартное поведение привязки для функций, реализованных в "
"Python)."

#: ../../library/inspect.rst:880
msgid "*VAR_POSITIONAL*"
msgstr "*VAR_POSITIONAL*"

#: ../../library/inspect.rst:880
msgid ""
"A tuple of positional arguments that aren't bound to any other parameter. "
"This corresponds to a ``*args`` parameter in a Python function definition."
msgstr ""
"Кортеж позиционных аргументов, не привязанных ни к какому другому параметру. "
"Это соответствует параметру ``*args`` в определении функции Python."

#: ../../library/inspect.rst:885
msgid "*KEYWORD_ONLY*"
msgstr "*KEYWORD_ONLY*"

#: ../../library/inspect.rst:885
msgid ""
"Value must be supplied as a keyword argument. Keyword only parameters are "
"those which appear after a ``*`` or ``*args`` entry in a Python function "
"definition."
msgstr ""
"Значение должно быть указано в качестве аргумента ключевого слова. Параметры "
"только по ключевому слову — это те, которые появляются после записи ``*`` "
"или ``*args`` в определении функции Python."

#: ../../library/inspect.rst:890
msgid "*VAR_KEYWORD*"
msgstr "*VAR_KEYWORD*"

#: ../../library/inspect.rst:890
msgid ""
"A dict of keyword arguments that aren't bound to any other parameter. This "
"corresponds to a ``**kwargs`` parameter in a Python function definition."
msgstr ""
"Набор аргументов ключевого слова, которые не привязаны ни к какому другому "
"параметру. Это соответствует параметру ``**kwargs`` в определении функции "
"Python."

#: ../../library/inspect.rst:896
msgid "Example: print all keyword-only arguments without default values:"
msgstr ""
"Пример: вывести все аргументы, содержащие только ключевые слова, без "
"значений по умолчанию:"

#: ../../library/inspect.rst:898
msgid ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     if (param.kind == param.KEYWORD_ONLY and\n"
"...                        param.default is param.empty):\n"
"...         print('Parameter:', param)\n"
"Parameter: c"
msgstr ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     if (param.kind == param.KEYWORD_ONLY and\n"
"...                        param.default is param.empty):\n"
"...         print('Parameter:', param)\n"
"Parameter: c"

#: ../../library/inspect.rst:912
msgid "Describes an enum value of :attr:`Parameter.kind`."
msgstr "Описывает значение перечисления :attr:`Parameter.kind`."

#: ../../library/inspect.rst:916
msgid "Example: print all descriptions of arguments:"
msgstr "Пример: вывести все описания аргументов:"

#: ../../library/inspect.rst:918
msgid ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     print(param.kind.description)\n"
"positional or keyword\n"
"positional or keyword\n"
"keyword-only\n"
"keyword-only"
msgstr ""
">>> def foo(a, b, *, c, d=10):\n"
"...     pass\n"
"\n"
">>> sig = signature(foo)\n"
">>> for param in sig.parameters.values():\n"
"...     print(param.kind.description)\n"
"positional or keyword\n"
"positional or keyword\n"
"keyword-only\n"
"keyword-only"

#: ../../library/inspect.rst:933
msgid ""
"Create a new :class:`Parameter` instance based on the instance replaced was "
"invoked on.  To override a :class:`!Parameter` attribute, pass the "
"corresponding argument.  To remove a default value or/and an annotation from "
"a :class:`!Parameter`, pass :attr:`Parameter.empty`."
msgstr ""
"Создайте новый экземпляр :class:`Parameter` на основе замененного "
"экземпляра, который был вызван. Чтобы переопределить атрибут :class:`!"
"Parameter`, передайте соответствующий аргумент. Чтобы удалить значение по "
"умолчанию и/или аннотацию из :class:`!Parameter`, передайте :attr:`Parameter."
"empty`."

#: ../../library/inspect.rst:938
msgid ""
">>> from inspect import Parameter\n"
">>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)\n"
">>> str(param)\n"
"'foo=42'\n"
"\n"
">>> str(param.replace()) # Will create a shallow copy of 'param'\n"
"'foo=42'\n"
"\n"
">>> str(param.replace(default=Parameter.empty, annotation='spam'))\n"
"\"foo: 'spam'\""
msgstr ""
">>> from inspect import Parameter\n"
">>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)\n"
">>> str(param)\n"
"'foo=42'\n"
"\n"
">>> str(param.replace()) # Will create a shallow copy of 'param'\n"
"'foo=42'\n"
"\n"
">>> str(param.replace(default=Parameter.empty, annotation='spam'))\n"
"\"foo: 'spam'\""

#: ../../library/inspect.rst:951
msgid ""
"In Python 3.3 :class:`Parameter` objects were allowed to have ``name`` set "
"to ``None`` if their ``kind`` was set to ``POSITIONAL_ONLY``. This is no "
"longer permitted."
msgstr ""
"В Python 3.3 объектам :class:`Parameter` было разрешено иметь ``name`` со "
"значением ``None``, если их ``вид`` был установлен на ``POSITIONAL_ONLY``. "
"Это больше не разрешено."

#: ../../library/inspect.rst:958
msgid ""
"Result of a :meth:`Signature.bind` or :meth:`Signature.bind_partial` call. "
"Holds the mapping of arguments to the function's parameters."
msgstr ""
"Результат вызова :meth:`Signature.bind` или :meth:`Signature.bind_partial`. "
"Содержит сопоставление аргументов с параметрами функции."

#: ../../library/inspect.rst:963
msgid ""
"A mutable mapping of parameters' names to arguments' values. Contains only "
"explicitly bound arguments.  Changes in :attr:`arguments` will reflect in :"
"attr:`args` and :attr:`kwargs`."
msgstr ""
"Изменяемое сопоставление имен параметров со значениями аргументов. Содержит "
"только явно связанные аргументы. Изменения в :attr:`arguments` отразятся в :"
"attr:`args` и :attr:`kwargs`."

#: ../../library/inspect.rst:967
msgid ""
"Should be used in conjunction with :attr:`Signature.parameters` for any "
"argument processing purposes."
msgstr ""
"Следует использовать вместе с :attr:`Signature.parameters` для любых целей "
"обработки аргументов."

#: ../../library/inspect.rst:972
msgid ""
"Arguments for which :meth:`Signature.bind` or :meth:`Signature.bind_partial` "
"relied on a default value are skipped. However, if needed, use :meth:"
"`BoundArguments.apply_defaults` to add them."
msgstr ""
"Аргументы, для которых :meth:`Signature.bind` или :meth:`Signature."
"bind_partial` используют значение по умолчанию, пропускаются. Однако, если "
"необходимо, используйте :meth:`BoundArguments.apply_defaults`, чтобы "
"добавить их."

#: ../../library/inspect.rst:977
msgid ""
":attr:`arguments` is now of type :class:`dict`. Formerly, it was of type :"
"class:`collections.OrderedDict`."
msgstr ""
":attr:`arguments` теперь имеет тип :class:`dict`. Раньше он имел тип :class:"
"`collections.OrderedDict`."

#: ../../library/inspect.rst:983
msgid ""
"A tuple of positional arguments values.  Dynamically computed from the :attr:"
"`arguments` attribute."
msgstr ""
"Кортеж значений позиционных аргументов. Динамически вычисляется на основе "
"атрибута :attr:`arguments`."

#: ../../library/inspect.rst:988
msgid ""
"A dict of keyword arguments values.  Dynamically computed from the :attr:"
"`arguments` attribute.  Arguments that can be passed positionally are "
"included in :attr:`args` instead."
msgstr ""
"Набор значений аргументов ключевого слова. Динамически вычисляется на основе "
"атрибута :attr:`arguments`. Аргументы, которые можно передавать позиционно, "
"вместо этого включаются в :attr:`args`."

#: ../../library/inspect.rst:994
msgid "A reference to the parent :class:`Signature` object."
msgstr "Ссылка на родительский объект :class:`Signature`."

#: ../../library/inspect.rst:998
msgid "Set default values for missing arguments."
msgstr "Установите значения по умолчанию для отсутствующих аргументов."

#: ../../library/inspect.rst:1000
msgid ""
"For variable-positional arguments (``*args``) the default is an empty tuple."
msgstr ""
"Для аргументов с переменной позицией (``*args``) по умолчанию используется "
"пустой кортеж."

#: ../../library/inspect.rst:1003
msgid ""
"For variable-keyword arguments (``**kwargs``) the default is an empty dict."
msgstr ""
"Для аргументов с переменным ключевым словом (``**kwargs``) по умолчанию "
"используется пустой словарь."

#: ../../library/inspect.rst:1006
msgid ""
">>> def foo(a, b='ham', *args): pass\n"
">>> ba = inspect.signature(foo).bind('spam')\n"
">>> ba.apply_defaults()\n"
">>> ba.arguments\n"
"{'a': 'spam', 'b': 'ham', 'args': ()}"
msgstr ""
">>> def foo(a, b='ham', *args): pass\n"
">>> ba = inspect.signature(foo).bind('spam')\n"
">>> ba.apply_defaults()\n"
">>> ba.arguments\n"
"{'a': 'spam', 'b': 'ham', 'args': ()}"

#: ../../library/inspect.rst:1016
msgid ""
"The :attr:`args` and :attr:`kwargs` properties can be used to invoke "
"functions:"
msgstr ""
"Свойства :attr:`args` и :attr:`kwargs` можно использовать для вызова функций:"

#: ../../library/inspect.rst:1019
msgid ""
"def test(a, *, b):\n"
"    ...\n"
"\n"
"sig = signature(test)\n"
"ba = sig.bind(10, b=20)\n"
"test(*ba.args, **ba.kwargs)"
msgstr ""
"def test(a, *, b):\n"
"    ...\n"
"\n"
"sig = signature(test)\n"
"ba = sig.bind(10, b=20)\n"
"test(*ba.args, **ba.kwargs)"

#: ../../library/inspect.rst:1031
msgid ":pep:`362` - Function Signature Object."
msgstr ":pep:`362` - Объект сигнатуры функции."

#: ../../library/inspect.rst:1032
msgid "The detailed specification, implementation details and examples."
msgstr "Подробная спецификация, детали реализации и примеры."

#: ../../library/inspect.rst:1038
msgid "Classes and functions"
msgstr "Классы и функции"

#: ../../library/inspect.rst:1042
msgid ""
"Arrange the given list of classes into a hierarchy of nested lists. Where a "
"nested list appears, it contains classes derived from the class whose entry "
"immediately precedes the list.  Each entry is a 2-tuple containing a class "
"and a tuple of its base classes.  If the *unique* argument is true, exactly "
"one entry appears in the returned structure for each class in the given "
"list.  Otherwise, classes using multiple inheritance and their descendants "
"will appear multiple times."
msgstr ""
"Организуйте данный список классов в иерархию вложенных списков. Там, где "
"появляется вложенный список, он содержит классы, производные от класса, "
"запись которого непосредственно предшествует списку. Каждая запись "
"представляет собой кортеж из двух классов, содержащий класс и кортеж его "
"базовых классов. Если аргумент *unique* имеет значение true, в возвращаемой "
"структуре для каждого класса в данном списке появляется ровно одна запись. В "
"противном случае классы, использующие множественное наследование, и их "
"потомки будут появляться несколько раз."

#: ../../library/inspect.rst:1053
msgid ""
"Get the names and default values of a Python function's parameters.  A :term:"
"`named tuple` is returned:"
msgstr ""
"Получите имена и значения по умолчанию параметров функции Python. "
"Возвращается :term:`named tuple`:"

#: ../../library/inspect.rst:1056
msgid ""
"``FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, "
"annotations)``"
msgstr ""
"``FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, "
"аннотации)``"

#: ../../library/inspect.rst:1059
msgid ""
"*args* is a list of the positional parameter names. *varargs* is the name of "
"the ``*`` parameter or ``None`` if arbitrary positional arguments are not "
"accepted. *varkw* is the name of the ``**`` parameter or ``None`` if "
"arbitrary keyword arguments are not accepted. *defaults* is an *n*-tuple of "
"default argument values corresponding to the last *n* positional parameters, "
"or ``None`` if there are no such defaults defined. *kwonlyargs* is a list of "
"keyword-only parameter names in declaration order. *kwonlydefaults* is a "
"dictionary mapping parameter names from *kwonlyargs* to the default values "
"used if no argument is supplied. *annotations* is a dictionary mapping "
"parameter names to annotations. The special key ``\"return\"`` is used to "
"report the function return value annotation (if any)."
msgstr ""
"*args* — список имен позиционных параметров. *varargs* — это имя параметра "
"``*`` или ``None``, если произвольные позиционные аргументы не принимаются. "
"*varkw* — это имя параметра ``**`` или ``None``, если произвольные аргументы "
"ключевого слова не принимаются. *defaults* — это *n*-кортеж значений "
"аргументов по умолчанию, соответствующих последним *n* позиционным "
"параметрам, или ``None``, если такие значения по умолчанию не определены. "
"*kwonlyargs* — это список имен параметров, содержащих только ключевые слова, "
"в порядке объявления. *kwonlydefaults* — это словарь, сопоставляющий имена "
"параметров из *kwonlyargs* со значениями по умолчанию, используемыми, если "
"аргумент не указан. *annotations* — словарь, сопоставляющий имена параметров "
"с аннотациями. Специальный ключ ``\"return\"`` используется для сообщения "
"аннотации возвращаемого значения функции (если таковая имеется)."

#: ../../library/inspect.rst:1074
msgid ""
"Note that :func:`signature` and :ref:`Signature Object <inspect-signature-"
"object>` provide the recommended API for callable introspection, and support "
"additional behaviours (like positional-only arguments) that are sometimes "
"encountered in extension module APIs. This function is retained primarily "
"for use in code that needs to maintain compatibility with the Python 2 "
"``inspect`` module API."
msgstr ""
"Обратите внимание, что :func:`signature` и :ref:`Signature Object <inspect-"
"signature-object>` предоставляют рекомендуемый API для вызываемой "
"интроспекции и поддерживают дополнительное поведение (например, позиционные "
"аргументы), которые иногда встречаются в API модуля расширения. . Эта "
"функция сохранена в первую очередь для использования в коде, который должен "
"поддерживать совместимость с API модуля ``inspect`` Python 2."

#: ../../library/inspect.rst:1081
msgid ""
"This function is now based on :func:`signature`, but still ignores "
"``__wrapped__`` attributes and includes the already bound first parameter in "
"the signature output for bound methods."
msgstr ""
"Эта функция теперь основана на :func:`signature`, но по-прежнему игнорирует "
"атрибуты __wrapped__`` и включает уже связанный первый параметр в выходные "
"данные сигнатуры для связанных методов."

#: ../../library/inspect.rst:1086
msgid ""
"This method was previously documented as deprecated in favour of :func:"
"`signature` in Python 3.5, but that decision has been reversed in order to "
"restore a clearly supported standard interface for single-source Python 2/3 "
"code migrating away from the legacy :func:`getargspec` API."
msgstr ""
"Ранее этот метод был задокументирован как устаревший в пользу :func:"
"`signature` в Python 3.5, но это решение было отменено, чтобы восстановить "
"четко поддерживаемый стандартный интерфейс для кода Python 2/3 с одним "
"исходным кодом, мигрирующий от устаревшего: func:`getargspec` API."

#: ../../library/inspect.rst:1101
msgid ""
"Get information about arguments passed into a particular frame.  A :term:"
"`named tuple` ``ArgInfo(args, varargs, keywords, locals)`` is returned. "
"*args* is a list of the argument names.  *varargs* and *keywords* are the "
"names of the ``*`` and ``**`` arguments or ``None``.  *locals* is the locals "
"dictionary of the given frame."
msgstr ""
"Получите информацию об аргументах, переданных в конкретный кадр. "
"Возвращается :term:`именованный кортеж` ``ArgInfo(args, varargs, ключевые "
"слова, локальные значения)``. *args* — список имен аргументов. *varargs* и "
"*keywords* — это имена аргументов ``*`` и ``**`` или ``None``. *locals* — "
"словарь локальных значений данного фрейма."

#: ../../library/inspect.rst:1108 ../../library/inspect.rst:1118
msgid "This function was inadvertently marked as deprecated in Python 3.5."
msgstr "Эта функция была случайно помечена как устаревшая в Python 3.5."

#: ../../library/inspect.rst:1113
msgid ""
"Format a pretty argument spec from the four values returned by :func:"
"`getargvalues`.  The format\\* arguments are the corresponding optional "
"formatting functions that are called to turn names and values into strings."
msgstr ""
"Отформатируйте красивую спецификацию аргумента из четырех значений, "
"возвращаемых :func:`getargvalues`. Аргументы format\\* — это соответствующие "
"дополнительные функции форматирования, которые вызываются для преобразования "
"имен и значений в строки."

#: ../../library/inspect.rst:1123
msgid ""
"Return a tuple of class cls's base classes, including cls, in method "
"resolution order.  No class appears more than once in this tuple. Note that "
"the method resolution order depends on cls's type.  Unless a very peculiar "
"user-defined metatype is in use, cls will be the first element of the tuple."
msgstr ""
"Возвращает кортеж базовых классов класса cls, включая cls, в порядке "
"разрешения методов. Ни один класс не встречается в этом кортеже более одного "
"раза. Обратите внимание, что порядок разрешения метода зависит от типа cls. "
"Если не используется очень специфический пользовательский метатип, cls будет "
"первым элементом кортежа."

#: ../../library/inspect.rst:1131
msgid ""
"Bind the *args* and *kwds* to the argument names of the Python function or "
"method *func*, as if it was called with them. For bound methods, bind also "
"the first argument (typically named ``self``) to the associated instance. A "
"dict is returned, mapping the argument names (including the names of the "
"``*`` and ``**`` arguments, if any) to their values from *args* and *kwds*. "
"In case of invoking *func* incorrectly, i.e. whenever ``func(*args, "
"**kwds)`` would raise an exception because of incompatible signature, an "
"exception of the same type and the same or similar message is raised. For "
"example:"
msgstr ""
"Привяжите *args* и *kwds* к именам аргументов функции или метода Python "
"*func*, как если бы они были вызваны вместе с ними. Для связанных методов "
"привяжите также первый аргумент (обычно называемый «self») к связанному "
"экземпляру. Возвращается словарь, сопоставляющий имена аргументов (включая "
"имена аргументов ``*`` и ``**``, если таковые имеются) с их значениями из "
"*args* и *kwds*. В случае неправильного вызова *func*, т.е. всякий раз, "
"когда ``func(*args, **kwds)`` вызывает исключение из-за несовместимой "
"сигнатуры, возникает исключение того же типа и того же или похожего "
"сообщения. Например:"

#: ../../library/inspect.rst:1140
msgid ""
">>> from inspect import getcallargs\n"
">>> def f(a, b=1, *pos, **named):\n"
"...     pass\n"
"...\n"
">>> getcallargs(f, 1, 2, 3) == {'a': 1, 'named': {}, 'b': 2, 'pos': (3,)}\n"
"True\n"
">>> getcallargs(f, a=2, x=4) == {'a': 2, 'named': {'x': 4}, 'b': 1, 'pos': "
"()}\n"
"True\n"
">>> getcallargs(f)\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: f() missing 1 required positional argument: 'a'"
msgstr ""
">>> from inspect import getcallargs\n"
">>> def f(a, b=1, *pos, **named):\n"
"...     pass\n"
"...\n"
">>> getcallargs(f, 1, 2, 3) == {'a': 1, 'named': {}, 'b': 2, 'pos': (3,)}\n"
"True\n"
">>> getcallargs(f, a=2, x=4) == {'a': 2, 'named': {'x': 4}, 'b': 1, 'pos': "
"()}\n"
"True\n"
">>> getcallargs(f)\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: f() missing 1 required positional argument: 'a'"

#: ../../library/inspect.rst:1157
msgid "Use :meth:`Signature.bind` and :meth:`Signature.bind_partial` instead."
msgstr ""
"Вместо этого используйте :meth:`Signature.bind` и :meth:`Signature."
"bind_partial`."

#: ../../library/inspect.rst:1163
msgid ""
"Get the mapping of external name references in a Python function or method "
"*func* to their current values. A :term:`named tuple` "
"``ClosureVars(nonlocals, globals, builtins, unbound)`` is returned. "
"*nonlocals* maps referenced names to lexical closure variables, *globals* to "
"the function's module globals and *builtins* to the builtins visible from "
"the function body. *unbound* is the set of names referenced in the function "
"that could not be resolved at all given the current module globals and "
"builtins."
msgstr ""
"Получите сопоставление ссылок на внешние имена в функции или методе Python "
"*func* с их текущими значениями. Возвращается :term:`named tuple` "
"``ClosureVars(nonlocals, globals, встроенные, несвязанные)``. *nonlocals* "
"сопоставляет ссылочные имена с переменными лексического замыкания, *globals* "
"— с глобальными переменными модуля функции, а *builtins* — со встроенными "
"функциями, видимыми из тела функции. *unbound* — это набор имен, на которые "
"ссылается функция, которые вообще невозможно разрешить, учитывая текущие "
"глобальные и встроенные функции модуля."

#: ../../library/inspect.rst:1172
msgid ""
":exc:`TypeError` is raised if *func* is not a Python function or method."
msgstr ""
":exc:`TypeError` возникает, если *func* не является функцией или методом "
"Python."

#: ../../library/inspect.rst:1179
msgid ""
"Get the object wrapped by *func*. It follows the chain of :attr:"
"`__wrapped__` attributes returning the last object in the chain."
msgstr ""
"Получите объект, завернутый в *func*. Он следует за цепочкой атрибутов :attr:"
"`__wrapped__`, возвращая последний объект в цепочке."

#: ../../library/inspect.rst:1182
msgid ""
"*stop* is an optional callback accepting an object in the wrapper chain as "
"its sole argument that allows the unwrapping to be terminated early if the "
"callback returns a true value. If the callback never returns a true value, "
"the last object in the chain is returned as usual. For example, :func:"
"`signature` uses this to stop unwrapping if any object in the chain has a "
"``__signature__`` attribute defined."
msgstr ""
"*stop* — это необязательный обратный вызов, принимающий объект в цепочке "
"оболочки в качестве единственного аргумента, который позволяет досрочно "
"завершить развертывание, если обратный вызов возвращает истинное значение. "
"Если обратный вызов никогда не возвращает истинное значение, последний "
"объект в цепочке возвращается как обычно. Например, :func:`signature` "
"использует это, чтобы остановить развертывание, если для какого-либо объекта "
"в цепочке определен атрибут __signature__``."

#: ../../library/inspect.rst:1189
msgid ":exc:`ValueError` is raised if a cycle is encountered."
msgstr ":exc:`ValueError` возникает, если встречается цикл."

#: ../../library/inspect.rst:1196
msgid "Compute the annotations dict for an object."
msgstr "Вычислите аннотации dict для объекта."

#: ../../library/inspect.rst:1198
msgid ""
"``obj`` may be a callable, class, or module. Passing in an object of any "
"other type raises :exc:`TypeError`."
msgstr ""
"``obj`` может быть вызываемым объектом, классом или модулем. Передача "
"объекта любого другого типа вызывает :exc:`TypeError`."

#: ../../library/inspect.rst:1201
msgid ""
"Returns a dict.  ``get_annotations()`` returns a new dict every time it's "
"called; calling it twice on the same object will return two different but "
"equivalent dicts."
msgstr ""
"Возвращает диктат. ``get_annotations()`` возвращает новый словарь каждый "
"раз, когда он вызывается; вызов его дважды для одного и того же объекта "
"вернет два разных, но эквивалентных слова."

#: ../../library/inspect.rst:1205
msgid "This function handles several details for you:"
msgstr "Эта функция обрабатывает для вас несколько деталей:"

#: ../../library/inspect.rst:1207
msgid ""
"If ``eval_str`` is true, values of type ``str`` will be un-stringized using :"
"func:`eval`.  This is intended for use with stringized annotations (``from "
"__future__ import annotations``)."
msgstr ""
"Если ``eval_str`` имеет значение true, значения типа ``str`` будут "
"преобразованы в строки с использованием :func:`eval`. Это предназначено для "
"использования со строковыми аннотациями («из __future__ import annotations»)."

#: ../../library/inspect.rst:1211
msgid ""
"If ``obj`` doesn't have an annotations dict, returns an empty dict.  "
"(Functions and methods always have an annotations dict; classes, modules, "
"and other types of callables may not.)"
msgstr ""
"Если ``obj`` не имеет словаря аннотаций, возвращается пустой словарь. "
"(Функции и методы всегда имеют аннотации; классы, модули и другие типы "
"вызываемых объектов могут отсутствовать.)"

#: ../../library/inspect.rst:1215
msgid ""
"Ignores inherited annotations on classes.  If a class doesn't have its own "
"annotations dict, returns an empty dict."
msgstr ""
"Игнорирует унаследованные аннотации к классам. Если у класса нет "
"собственного словаря аннотаций, возвращается пустой словарь."

#: ../../library/inspect.rst:1217
msgid ""
"All accesses to object members and dict values are done using ``getattr()`` "
"and ``dict.get()`` for safety."
msgstr ""
"Весь доступ к членам объекта и значениям dict осуществляется с "
"использованием ``getattr()`` и ``dict.get()`` в целях безопасности."

#: ../../library/inspect.rst:1219
msgid "Always, always, always returns a freshly created dict."
msgstr "Всегда, всегда, всегда возвращает только что созданный словарь."

#: ../../library/inspect.rst:1221
msgid ""
"``eval_str`` controls whether or not values of type ``str`` are replaced "
"with the result of calling :func:`eval` on those values:"
msgstr ""
"``eval_str`` контролирует, заменяются ли значения типа ``str`` результатом "
"вызова :func:`eval` для этих значений:"

#: ../../library/inspect.rst:1224
msgid ""
"If eval_str is true, :func:`eval` is called on values of type ``str``. (Note "
"that ``get_annotations`` doesn't catch exceptions; if :func:`eval` raises an "
"exception, it will unwind the stack past the ``get_annotations`` call.)"
msgstr ""
"Если eval_str имеет значение true, :func:`eval` вызывается для значений типа "
"``str``. (Обратите внимание, что ``get_annotations`` не перехватывает "
"исключения; если :func:`eval` вызывает исключение, он раскручивает стек "
"после вызова ``get_annotations``.)"

#: ../../library/inspect.rst:1228
msgid ""
"If eval_str is false (the default), values of type ``str`` are unchanged."
msgstr ""
"Если eval_str имеет значение false (по умолчанию), значения типа ``str`` не "
"изменяются."

#: ../../library/inspect.rst:1230
msgid ""
"``globals`` and ``locals`` are passed in to :func:`eval`; see the "
"documentation for :func:`eval` for more information.  If ``globals`` or "
"``locals`` is ``None``, this function may replace that value with a context-"
"specific default, contingent on ``type(obj)``:"
msgstr ""
"``globals`` и ``locals`` передаются в :func:`eval`; дополнительную "
"информацию смотрите в документации по :func:`eval`. Если ``globals`` или "
"``locals`` имеют значение ``None``, эта функция может заменить это значение "
"контекстно-зависимым значением по умолчанию, зависящим от ``type(obj)``:"

#: ../../library/inspect.rst:1235
msgid "If ``obj`` is a module, ``globals`` defaults to ``obj.__dict__``."
msgstr ""
"Если ``obj`` является модулем, ``globals`` по умолчанию имеет значение ``obj."
"__dict__``."

#: ../../library/inspect.rst:1236
msgid ""
"If ``obj`` is a class, ``globals`` defaults to ``sys.modules[obj.__module__]."
"__dict__`` and ``locals`` defaults to the ``obj`` class namespace."
msgstr ""
"Если obj`` является классом, ``globals`` по умолчанию имеет значение ``sys."
"modules[obj.__module__].__dict__``, а ``locals`` по умолчанию использует "
"пространство имен класса ``obj``."

#: ../../library/inspect.rst:1239
msgid ""
"If ``obj`` is a callable, ``globals`` defaults to :attr:`obj.__globals__ "
"<function.__globals__>`, although if ``obj`` is a wrapped function (using :"
"func:`functools.update_wrapper`) it is first unwrapped."
msgstr ""
"Если obj`` является вызываемой функцией, ``globals`` по умолчанию имеет "
"значение :attr:`obj.__globals__ <function.__globals__>`, хотя если ``obj`` "
"является обернутой функцией (с использованием :func:`functools. "
"update_wrapper`) сначала разворачивается."

#: ../../library/inspect.rst:1244
msgid ""
"Calling ``get_annotations`` is best practice for accessing the annotations "
"dict of any object.  See :ref:`annotations-howto` for more information on "
"annotations best practices."
msgstr ""
"Вызов get_annotations — лучший способ получить доступ к аннотациям любого "
"объекта. См. :ref:`annotations-howto` для получения дополнительной "
"информации о лучших практиках аннотаций."

#: ../../library/inspect.rst:1254
msgid "The interpreter stack"
msgstr "Стек интерпретатора"

#: ../../library/inspect.rst:1256
msgid ""
"Some of the following functions return :class:`FrameInfo` objects. For "
"backwards compatibility these objects allow tuple-like operations on all "
"attributes except ``positions``. This behavior is considered deprecated and "
"may be removed in the future."
msgstr ""
"Некоторые из следующих функций возвращают объекты :class:`FrameInfo`. В "
"целях обратной совместимости эти объекты допускают операции, подобные "
"кортежам, со всеми атрибутами, кроме позиций. Такое поведение считается "
"устаревшим и может быть удалено в будущем."

#: ../../library/inspect.rst:1265
msgid "The :ref:`frame object <frame-objects>` that the record corresponds to."
msgstr "Объект :ref:`frame <frame-objects>`, которому соответствует запись."

#: ../../library/inspect.rst:1269
msgid ""
"The file name associated with the code being executed by the frame this "
"record corresponds to."
msgstr ""
"Имя файла, связанное с кодом, выполняемым кадром, которому соответствует эта "
"запись."

#: ../../library/inspect.rst:1274
msgid ""
"The line number of the current line associated with the code being executed "
"by the frame this record corresponds to."
msgstr ""
"Номер текущей строки, связанной с кодом, исполняемым кадром, которому "
"соответствует эта запись."

#: ../../library/inspect.rst:1279
msgid ""
"The function name that is being executed by the frame this record "
"corresponds to."
msgstr ""
"Имя функции, которая выполняется кадром, которому соответствует эта запись."

#: ../../library/inspect.rst:1283
msgid ""
"A list of lines of context from the source code that's being executed by the "
"frame this record corresponds to."
msgstr ""
"Список строк контекста из исходного кода, который выполняется кадром, "
"которому соответствует эта запись."

#: ../../library/inspect.rst:1288 ../../library/inspect.rst:1327
msgid ""
"The index of the current line being executed in the :attr:`code_context` "
"list."
msgstr "Индекс текущей исполняемой строки в списке :attr:`code_context`."

#: ../../library/inspect.rst:1292
msgid ""
"A :class:`dis.Positions` object containing the start line number, end line "
"number, start column offset, and end column offset associated with the "
"instruction being executed by the frame this record corresponds to."
msgstr ""
"Объект :class:`dis.Positions`, содержащий номер начальной строки, номер "
"конечной строки, смещение начального столбца и смещение конечного столбца, "
"связанное с инструкцией, выполняемой кадром, которому соответствует эта "
"запись."

#: ../../library/inspect.rst:1296
msgid "Return a :term:`named tuple` instead of a :class:`tuple`."
msgstr "Верните :term:`named tuple` вместо :class:`tuple`."

#: ../../library/inspect.rst:1299
msgid ""
":class:`!FrameInfo` is now a class instance (that is backwards compatible "
"with the previous :term:`named tuple`)."
msgstr ""
":class:`!FrameInfo` теперь является экземпляром класса (который обратно "
"совместим с предыдущим :term:`named tuple`)."

#: ../../library/inspect.rst:1308
msgid ""
"The file name associated with the code being executed by the frame this "
"traceback corresponds to."
msgstr ""
"Имя файла, связанное с кодом, выполняемым кадром, которому соответствует эта "
"обратная трассировка."

#: ../../library/inspect.rst:1313
msgid ""
"The line number of the current line associated with the code being executed "
"by the frame this traceback corresponds to."
msgstr ""
"Номер текущей строки, связанной с кодом, выполняемым кадром, которому "
"соответствует эта обратная трассировка."

#: ../../library/inspect.rst:1318
msgid ""
"The function name that is being executed by the frame this traceback "
"corresponds to."
msgstr ""
"Имя функции, которая выполняется кадром, которому соответствует эта обратная "
"трассировка."

#: ../../library/inspect.rst:1322
msgid ""
"A list of lines of context from the source code that's being executed by the "
"frame this traceback corresponds to."
msgstr ""
"Список строк контекста из исходного кода, который выполняется кадром, "
"которому соответствует эта обратная трассировка."

#: ../../library/inspect.rst:1331
msgid ""
"A :class:`dis.Positions` object containing the start line number, end line "
"number, start column offset, and end column offset associated with the "
"instruction being executed by the frame this traceback corresponds to."
msgstr ""
"Объект :class:`dis.Positions`, содержащий номер начальной строки, номер "
"конечной строки, смещение начального столбца и смещение конечного столбца, "
"связанное с инструкцией, выполняемой кадром, которому соответствует эта "
"обратная трассировка."

#: ../../library/inspect.rst:1336
msgid ""
":class:`!Traceback` is now a class instance (that is backwards compatible "
"with the previous :term:`named tuple`)."
msgstr ""
":class:`!Traceback` теперь является экземпляром класса (который обратно "
"совместим с предыдущим :term:`named tuple`)."

#: ../../library/inspect.rst:1343
msgid ""
"Keeping references to frame objects, as found in the first element of the "
"frame records these functions return, can cause your program to create "
"reference cycles.  Once a reference cycle has been created, the lifespan of "
"all objects which can be accessed from the objects which form the cycle can "
"become much longer even if Python's optional cycle detector is enabled.  If "
"such cycles must be created, it is important to ensure they are explicitly "
"broken to avoid the delayed destruction of objects and increased memory "
"consumption which occurs."
msgstr ""
"Сохранение ссылок на объекты фрейма, обнаруженные в первом элементе записей "
"фрейма, возвращаемых этими функциями, может привести к тому, что ваша "
"программа создаст ссылочные циклы. После создания эталонного цикла "
"продолжительность жизни всех объектов, к которым можно получить доступ из "
"объектов, образующих цикл, может стать намного дольше, даже если включен "
"дополнительный детектор цикла Python. Если такие циклы необходимо создавать, "
"важно убедиться, что они явно нарушены, чтобы избежать отложенного "
"разрушения объектов и увеличения потребления памяти."

#: ../../library/inspect.rst:1351
msgid ""
"Though the cycle detector will catch these, destruction of the frames (and "
"local variables) can be made deterministic by removing the cycle in a :"
"keyword:`finally` clause.  This is also important if the cycle detector was "
"disabled when Python was compiled or using :func:`gc.disable`.  For example::"
msgstr ""
"Хотя детектор циклов их улавливает, уничтожение кадров (и локальных "
"переменных) можно сделать детерминированным, удалив цикл в предложении :"
"keyword:`finally`. Это также важно, если детектор циклов был отключен при "
"компиляции Python или при использовании :func:`gc.disable`. Например::"

#: ../../library/inspect.rst:1356
msgid ""
"def handle_stackframe_without_leak():\n"
"    frame = inspect.currentframe()\n"
"    try:\n"
"        # do something with the frame\n"
"    finally:\n"
"        del frame"
msgstr ""
"def handle_stackframe_without_leak():\n"
"    frame = inspect.currentframe()\n"
"    try:\n"
"        # do something with the frame\n"
"    finally:\n"
"        del frame"

#: ../../library/inspect.rst:1363
msgid ""
"If you want to keep the frame around (for example to print a traceback "
"later), you can also break reference cycles by using the :meth:`frame.clear` "
"method."
msgstr ""
"Если вы хотите сохранить фрейм (например, чтобы позже распечатать обратную "
"трассировку), вы также можете разорвать ссылочные циклы, используя метод :"
"meth:`frame.clear`."

#: ../../library/inspect.rst:1367
msgid ""
"The optional *context* argument supported by most of these functions "
"specifies the number of lines of context to return, which are centered "
"around the current line."
msgstr ""
"Необязательный аргумент *context*, поддерживаемый большинством этих функций, "
"указывает количество возвращаемых строк контекста, которые сосредоточены "
"вокруг текущей строки."

#: ../../library/inspect.rst:1374
msgid ""
"Get information about a frame or traceback object.  A :class:`Traceback` "
"object is returned."
msgstr ""
"Получите информацию о кадре или объекте трассировки. Возвращается объект :"
"class:`Traceback`."

#: ../../library/inspect.rst:1377
msgid "A :class:`Traceback` object is returned instead of a named tuple."
msgstr "Вместо именованного кортежа возвращается объект :class:`Traceback`."

#: ../../library/inspect.rst:1382
msgid ""
"Get a list of :class:`FrameInfo` objects for a frame and all outer frames. "
"These frames represent the calls that lead to the creation of *frame*. The "
"first entry in the returned list represents *frame*; the last entry "
"represents the outermost call on *frame*'s stack."
msgstr ""
"Получите список объектов :class:`FrameInfo` для фрейма и всех внешних "
"фреймов. Эти кадры представляют собой вызовы, которые приводят к созданию "
"*frame*. Первая запись в возвращаемом списке представляет *frame*; последняя "
"запись представляет собой самый внешний вызов в стеке *frame*."

#: ../../library/inspect.rst:1387 ../../library/inspect.rst:1402
#: ../../library/inspect.rst:1428 ../../library/inspect.rst:1443
msgid ""
"A list of :term:`named tuples <named tuple>` ``FrameInfo(frame, filename, "
"lineno, function, code_context, index)`` is returned."
msgstr ""
"Возвращается список :term:`именованных кортежей <named tuple>` "
"``FrameInfo(frame, filename, lineno, function, code_context, index)``."

#: ../../library/inspect.rst:1392 ../../library/inspect.rst:1407
#: ../../library/inspect.rst:1433 ../../library/inspect.rst:1448
msgid "A list of :class:`FrameInfo` objects is returned."
msgstr "Возвращается список объектов :class:`FrameInfo`."

#: ../../library/inspect.rst:1397
msgid ""
"Get a list of :class:`FrameInfo` objects for a traceback's frame and all "
"inner frames.  These frames represent calls made as a consequence of "
"*frame*. The first entry in the list represents *traceback*; the last entry "
"represents where the exception was raised."
msgstr ""
"Получите список объектов :class:`FrameInfo` для фрейма трассировки и всех "
"внутренних фреймов. Эти кадры представляют собой вызовы, сделанные "
"вследствие *frame*. Первая запись в списке представляет *traceback*; "
"последняя запись указывает место возникновения исключения."

#: ../../library/inspect.rst:1412
msgid "Return the frame object for the caller's stack frame."
msgstr "Возвращает объект кадра для кадра стека вызывающего объекта."

#: ../../library/inspect.rst:1416
msgid ""
"This function relies on Python stack frame support in the interpreter, which "
"isn't guaranteed to exist in all implementations of Python.  If running in "
"an implementation without Python stack frame support this function returns "
"``None``."
msgstr ""
"Эта функция опирается на поддержку фреймов стека Python в интерпретаторе, "
"наличие которой не гарантируется во всех реализациях Python. При запуске в "
"реализации без поддержки фреймов стека Python эта функция возвращает None."

#: ../../library/inspect.rst:1424
msgid ""
"Return a list of :class:`FrameInfo` objects for the caller's stack.  The "
"first entry in the returned list represents the caller; the last entry "
"represents the outermost call on the stack."
msgstr ""
"Возвращает список объектов :class:`FrameInfo` для стека вызывающего объекта. "
"Первая запись в возвращаемом списке представляет вызывающего абонента; "
"последняя запись представляет собой самый внешний вызов в стеке."

#: ../../library/inspect.rst:1438
msgid ""
"Return a list of :class:`FrameInfo` objects for the stack between the "
"current frame and the frame in which an exception currently being handled "
"was raised in.  The first entry in the list represents the caller; the last "
"entry represents where the exception was raised."
msgstr ""
"Возвращает список объектов :class:`FrameInfo` для стека между текущим кадром "
"и кадром, в котором возникло обрабатываемое в данный момент исключение. "
"Первая запись в списке представляет вызывающую сторону; последняя запись "
"указывает место возникновения исключения."

#: ../../library/inspect.rst:1452
msgid "Fetching attributes statically"
msgstr "Статическая выборка атрибутов"

#: ../../library/inspect.rst:1454
msgid ""
"Both :func:`getattr` and :func:`hasattr` can trigger code execution when "
"fetching or checking for the existence of attributes. Descriptors, like "
"properties, will be invoked and :meth:`~object.__getattr__` and :meth:"
"`~object.__getattribute__` may be called."
msgstr ""
"И :func:`getattr`, и :func:`hasattr` могут инициировать выполнение кода при "
"получении или проверке существования атрибутов. Дескрипторы, как и свойства, "
"будут вызываться и могут вызываться :meth:`~object.__getattr__` и :meth:"
"`~object.__getattribute__`."

#: ../../library/inspect.rst:1460
msgid ""
"For cases where you want passive introspection, like documentation tools, "
"this can be inconvenient. :func:`getattr_static` has the same signature as :"
"func:`getattr` but avoids executing code when it fetches attributes."
msgstr ""
"В случаях, когда вам нужен пассивный самоанализ, например, в инструментах "
"документирования, это может быть неудобно. :func:`getattr_static` имеет ту "
"же сигнатуру, что и :func:`getattr`, но избегает выполнения кода при "
"получении атрибутов."

#: ../../library/inspect.rst:1466
msgid ""
"Retrieve attributes without triggering dynamic lookup via the descriptor "
"protocol, :meth:`~object.__getattr__` or :meth:`~object.__getattribute__`."
msgstr ""
"Получайте атрибуты без запуска динамического поиска через протокол "
"дескриптора :meth:`~object.__getattr__` или :meth:`~object.__getattribute__`."

#: ../../library/inspect.rst:1470
msgid ""
"Note: this function may not be able to retrieve all attributes that getattr "
"can fetch (like dynamically created attributes) and may find attributes that "
"getattr can't (like descriptors that raise AttributeError). It can also "
"return descriptors objects instead of instance members."
msgstr ""
"Примечание. Эта функция может быть не в состоянии получить все атрибуты, "
"которые может получить getattr (например, динамически созданные атрибуты), и "
"может найти атрибуты, которые getattr не может получить (например, "
"дескрипторы, которые вызывают AttributeError). Он также может возвращать "
"объекты дескрипторов вместо членов экземпляра."

#: ../../library/inspect.rst:1476
msgid ""
"If the instance :attr:`~object.__dict__` is shadowed by another member (for "
"example a property) then this function will be unable to find instance "
"members."
msgstr ""
"Если экземпляр :attr:`~object.__dict__` затенен другим элементом (например, "
"свойством), то эта функция не сможет найти члены экземпляра."

#: ../../library/inspect.rst:1482
msgid ""
":func:`getattr_static` does not resolve descriptors, for example slot "
"descriptors or getset descriptors on objects implemented in C. The "
"descriptor object is returned instead of the underlying attribute."
msgstr ""
":func:`getattr_static` не разрешает дескрипторы, например дескрипторы слотов "
"или дескрипторы getset для объектов, реализованных в C. Вместо базового "
"атрибута возвращается объект дескриптора."

#: ../../library/inspect.rst:1486
msgid ""
"You can handle these with code like the following. Note that for arbitrary "
"getset descriptors invoking these may trigger code execution::"
msgstr ""
"Вы можете справиться с этим с помощью кода, подобного следующему. Обратите "
"внимание, что вызов произвольных дескрипторов getset может вызвать "
"выполнение кода:"

#: ../../library/inspect.rst:1490
msgid ""
"# example code for resolving the builtin descriptor types\n"
"class _foo:\n"
"    __slots__ = ['foo']\n"
"\n"
"slot_descriptor = type(_foo.foo)\n"
"getset_descriptor = type(type(open(__file__)).name)\n"
"wrapper_descriptor = type(str.__dict__['__add__'])\n"
"descriptor_types = (slot_descriptor, getset_descriptor, wrapper_descriptor)\n"
"\n"
"result = getattr_static(some_object, 'foo')\n"
"if type(result) in descriptor_types:\n"
"    try:\n"
"        result = result.__get__()\n"
"    except AttributeError:\n"
"        # descriptors can raise AttributeError to\n"
"        # indicate there is no underlying value\n"
"        # in which case the descriptor itself will\n"
"        # have to do\n"
"        pass"
msgstr ""
"# example code for resolving the builtin descriptor types\n"
"class _foo:\n"
"    __slots__ = ['foo']\n"
"\n"
"slot_descriptor = type(_foo.foo)\n"
"getset_descriptor = type(type(open(__file__)).name)\n"
"wrapper_descriptor = type(str.__dict__['__add__'])\n"
"descriptor_types = (slot_descriptor, getset_descriptor, wrapper_descriptor)\n"
"\n"
"result = getattr_static(some_object, 'foo')\n"
"if type(result) in descriptor_types:\n"
"    try:\n"
"        result = result.__get__()\n"
"    except AttributeError:\n"
"        # descriptors can raise AttributeError to\n"
"        # indicate there is no underlying value\n"
"        # in which case the descriptor itself will\n"
"        # have to do\n"
"        pass"

#: ../../library/inspect.rst:1512
msgid "Current State of Generators, Coroutines, and Asynchronous Generators"
msgstr "Текущее состояние генераторов, сопрограмм и асинхронных генераторов"

#: ../../library/inspect.rst:1514
msgid ""
"When implementing coroutine schedulers and for other advanced uses of "
"generators, it is useful to determine whether a generator is currently "
"executing, is waiting to start or resume or execution, or has already "
"terminated. :func:`getgeneratorstate` allows the current state of a "
"generator to be determined easily."
msgstr ""
"При реализации планировщиков сопрограмм и других расширенных применениях "
"генераторов полезно определить, выполняется ли генератор в данный момент, "
"ожидает запуска, возобновления или выполнения или уже завершился. :func:"
"`getgeneratorstate` позволяет легко определить текущее состояние генератора."

#: ../../library/inspect.rst:1522
msgid "Get current state of a generator-iterator."
msgstr "Получить текущее состояние генератора-итератора."

#: ../../library/inspect.rst:1524 ../../library/inspect.rst:1540
#: ../../library/inspect.rst:1557
msgid "Possible states are:"
msgstr "Возможны следующие состояния:"

#: ../../library/inspect.rst:1526
msgid "GEN_CREATED: Waiting to start execution."
msgstr "GEN_CREATED: Ожидание начала выполнения."

#: ../../library/inspect.rst:1527
msgid "GEN_RUNNING: Currently being executed by the interpreter."
msgstr "GEN_RUNNING: В настоящее время выполняется интерпретатором."

#: ../../library/inspect.rst:1528
msgid "GEN_SUSPENDED: Currently suspended at a yield expression."
msgstr ""
"GEN_SUSPENDED: в настоящее время приостановлено по выражению доходности."

#: ../../library/inspect.rst:1529
msgid "GEN_CLOSED: Execution has completed."
msgstr "GEN_CLOSED: выполнение завершено."

#: ../../library/inspect.rst:1535
msgid ""
"Get current state of a coroutine object.  The function is intended to be "
"used with coroutine objects created by :keyword:`async def` functions, but "
"will accept any coroutine-like object that has ``cr_running`` and "
"``cr_frame`` attributes."
msgstr ""
"Получить текущее состояние объекта сопрограммы. Функция предназначена для "
"использования с объектами сопрограмм, созданными функциями async def, но она "
"принимает любой объект, подобный сопрограмме, который имеет атрибуты "
"cr_running и cr_frame."

#: ../../library/inspect.rst:1542
msgid "CORO_CREATED: Waiting to start execution."
msgstr "CORO_CREATED: Ожидание начала выполнения."

#: ../../library/inspect.rst:1543
msgid "CORO_RUNNING: Currently being executed by the interpreter."
msgstr "CORO_RUNNING: В настоящее время выполняется интерпретатором."

#: ../../library/inspect.rst:1544
msgid "CORO_SUSPENDED: Currently suspended at an await expression."
msgstr ""
"CORO_SUSPENDED: в настоящее время приостановлено по выражению ожидания."

#: ../../library/inspect.rst:1545
msgid "CORO_CLOSED: Execution has completed."
msgstr "CORO_CLOSED: выполнение завершено."

#: ../../library/inspect.rst:1551
msgid ""
"Get current state of an asynchronous generator object.  The function is "
"intended to be used with asynchronous iterator objects created by :keyword:"
"`async def` functions which use the :keyword:`yield` statement, but will "
"accept any asynchronous generator-like object that has ``ag_running`` and "
"``ag_frame`` attributes."
msgstr ""
"Получите текущее состояние объекта асинхронного генератора. Функция "
"предназначена для использования с асинхронными объектами-итераторами, "
"созданными функциями :keyword:`async def`, которые используют оператор :"
"keyword:`yield`, но принимают любой асинхронный объект, подобный генератору, "
"который имеет ``ag_running`` и `` Атрибуты `ag_frame``."

#: ../../library/inspect.rst:1559
msgid "AGEN_CREATED: Waiting to start execution."
msgstr "AGEN_CREATED: Ожидание начала выполнения."

#: ../../library/inspect.rst:1560
msgid "AGEN_RUNNING: Currently being executed by the interpreter."
msgstr "AGEN_RUNNING: В настоящее время выполняется интерпретатором."

#: ../../library/inspect.rst:1561
msgid "AGEN_SUSPENDED: Currently suspended at a yield expression."
msgstr ""
"AGEN_SUSPENDED: в настоящее время приостановлено по выражению доходности."

#: ../../library/inspect.rst:1562
msgid "AGEN_CLOSED: Execution has completed."
msgstr "AGEN_CLOSED: выполнение завершено."

#: ../../library/inspect.rst:1566
msgid ""
"The current internal state of the generator can also be queried. This is "
"mostly useful for testing purposes, to ensure that internal state is being "
"updated as expected:"
msgstr ""
"Также можно запросить текущее внутреннее состояние генератора. Это в "
"основном полезно в целях тестирования, чтобы гарантировать, что внутреннее "
"состояние обновляется должным образом:"

#: ../../library/inspect.rst:1572
msgid ""
"Get the mapping of live local variables in *generator* to their current "
"values.  A dictionary is returned that maps from variable names to values. "
"This is the equivalent of calling :func:`locals` in the body of the "
"generator, and all the same caveats apply."
msgstr ""
"Получите сопоставление действующих локальных переменных в *генераторе* с их "
"текущими значениями. Возвращается словарь, который отображает имена "
"переменных в значения. Это эквивалент вызова :func:`locals` в теле "
"генератора, и здесь применяются все те же предостережения."

#: ../../library/inspect.rst:1577
msgid ""
"If *generator* is a :term:`generator` with no currently associated frame, "
"then an empty dictionary is returned.  :exc:`TypeError` is raised if "
"*generator* is not a Python generator object."
msgstr ""
"Если *generator* является :term:`generator` без связанного в данный момент "
"фрейма, то возвращается пустой словарь. :exc:`TypeError` возникает, если "
"*generator* не является объектом генератора Python."

#: ../../library/inspect.rst:1583
msgid ""
"This function relies on the generator exposing a Python stack frame for "
"introspection, which isn't guaranteed to be the case in all implementations "
"of Python. In such cases, this function will always return an empty "
"dictionary."
msgstr ""
"Эта функция использует генератор, предоставляющий кадр стека Python для "
"самоанализа, что не гарантируется во всех реализациях Python. В таких "
"случаях эта функция всегда будет возвращать пустой словарь."

#: ../../library/inspect.rst:1592
msgid ""
"This function is analogous to :func:`~inspect.getgeneratorlocals`, but works "
"for coroutine objects created by :keyword:`async def` functions."
msgstr ""
"Эта функция аналогична :func:`~inspect.getgeneratorlocals`, но работает для "
"объектов сопрограмм, созданных с помощью :keyword:`async def` функций."

#: ../../library/inspect.rst:1599
msgid ""
"This function is analogous to :func:`~inspect.getgeneratorlocals`, but works "
"for asynchronous generator objects created by :keyword:`async def` functions "
"which use the :keyword:`yield` statement."
msgstr ""
"Эта функция аналогична :func:`~inspect.getgeneratorlocals`, но работает для "
"объектов асинхронного генератора, созданных функциями :keyword:`async def`, "
"которые используют оператор :keyword:`yield`."

#: ../../library/inspect.rst:1609
msgid "Code Objects Bit Flags"
msgstr "Битовые флаги объектов кода"

#: ../../library/inspect.rst:1611
msgid ""
"Python code objects have a :attr:`~codeobject.co_flags` attribute, which is "
"a bitmap of the following flags:"
msgstr ""
"Объекты кода Python имеют атрибут :attr:`~codeobject.co_flags`, который "
"представляет собой растровое изображение следующих флагов:"

#: ../../library/inspect.rst:1616
msgid "The code object is optimized, using fast locals."
msgstr ""
"Объект кода оптимизирован с использованием быстрых локальных переменных."

#: ../../library/inspect.rst:1620
msgid ""
"If set, a new dict will be created for the frame's :attr:`~frame.f_locals` "
"when the code object is executed."
msgstr ""
"Если установлено, новый словарь будет создан для :attr:`~frame.f_locals` "
"фрейма при выполнении объекта кода."

#: ../../library/inspect.rst:1625
msgid "The code object has a variable positional parameter (``*args``-like)."
msgstr ""
"Объект кода имеет переменный позиционный параметр (подобный ``*args``)."

#: ../../library/inspect.rst:1629
msgid "The code object has a variable keyword parameter (``**kwargs``-like)."
msgstr ""
"Объект кода имеет переменный параметр ключевого слова (подобный "
"``**kwargs``)."

#: ../../library/inspect.rst:1633
msgid "The flag is set when the code object is a nested function."
msgstr "Флаг устанавливается, когда объект кода является вложенной функцией."

#: ../../library/inspect.rst:1637
msgid ""
"The flag is set when the code object is a generator function, i.e. a "
"generator object is returned when the code object is executed."
msgstr ""
"Флаг устанавливается, когда объект кода является функцией-генератором, т. е. "
"объект-генератор возвращается при выполнении объекта кода."

#: ../../library/inspect.rst:1642
msgid ""
"The flag is set when the code object is a coroutine function. When the code "
"object is executed it returns a coroutine object. See :pep:`492` for more "
"details."
msgstr ""
"Флаг устанавливается, когда объект кода является функцией сопрограммы. Когда "
"объект кода выполняется, он возвращает объект сопрограммы. См. :pep:`492` "
"для более подробной информации."

#: ../../library/inspect.rst:1650
msgid ""
"The flag is used to transform generators into generator-based coroutines.  "
"Generator objects with this flag can be used in ``await`` expression, and "
"can ``yield from`` coroutine objects. See :pep:`492` for more details."
msgstr ""
"Флаг используется для преобразования генераторов в сопрограммы на основе "
"генераторов. Объекты-генераторы с этим флагом могут использоваться в "
"выражении await и могут создаваться из объектов сопрограммы. См. :pep:`492` "
"для более подробной информации."

#: ../../library/inspect.rst:1659
msgid ""
"The flag is set when the code object is an asynchronous generator function.  "
"When the code object is executed it returns an asynchronous generator "
"object.  See :pep:`525` for more details."
msgstr ""
"Флаг устанавливается, когда объект кода является функцией асинхронного "
"генератора. Когда объект кода выполняется, он возвращает объект асинхронного "
"генератора. См. :pep:`525` для более подробной информации."

#: ../../library/inspect.rst:1666
msgid ""
"The flags are specific to CPython, and may not be defined in other Python "
"implementations.  Furthermore, the flags are an implementation detail, and "
"can be removed or deprecated in future Python releases. It's recommended to "
"use public APIs from the :mod:`inspect` module for any introspection needs."
msgstr ""
"Флаги специфичны для CPython и не могут быть определены в других реализациях "
"Python. Более того, флаги являются деталью реализации и могут быть удалены "
"или признаны устаревшими в будущих выпусках Python. Рекомендуется "
"использовать общедоступные API из модуля :mod:`inspect` для любых нужд "
"самоанализа."

#: ../../library/inspect.rst:1674
msgid "Buffer flags"
msgstr "Флаги буфера"

#: ../../library/inspect.rst:1678
msgid ""
"This is an :class:`enum.IntFlag` that represents the flags that can be "
"passed to the :meth:`~object.__buffer__` method of objects implementing the :"
"ref:`buffer protocol <bufferobjects>`."
msgstr ""
"Это :class:`enum.IntFlag`, который представляет флаги, которые могут быть "
"переданы в :meth:`~object.__buffer__` метод объектов, реализующих :ref:"
"`буферный протокол <bufferobjects>`."

#: ../../library/inspect.rst:1682
msgid "The meaning of the flags is explained at :ref:`buffer-request-types`."
msgstr "Значение флагов объясняется в :ref:`buffer-request-types`."

#: ../../library/inspect.rst:1709
msgid "Command Line Interface"
msgstr "Интерфейс командной строки"

#: ../../library/inspect.rst:1711
msgid ""
"The :mod:`inspect` module also provides a basic introspection capability "
"from the command line."
msgstr ""
"Модуль :mod:`inspect` также предоставляет базовые возможности самоанализа из "
"командной строки."

#: ../../library/inspect.rst:1716
msgid ""
"By default, accepts the name of a module and prints the source of that "
"module. A class or function within the module can be printed instead by "
"appended a colon and the qualified name of the target object."
msgstr ""
"По умолчанию принимает имя модуля и печатает исходный код этого модуля. "
"Вместо этого можно вывести класс или функцию внутри модуля, добавив "
"двоеточие и уточненное имя целевого объекта."

#: ../../library/inspect.rst:1722
msgid ""
"Print information about the specified object rather than the source code"
msgstr "Выводить информацию об указанном объекте, а не исходный код"
