# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/asyncio-sync.rst:7
msgid "Synchronization Primitives"
msgstr "Примитивы синхронизации"

#: ../../library/asyncio-sync.rst:9
msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**Исходный код:** :source:`Lib/asyncio/locks.py`"

#: ../../library/asyncio-sync.rst:13
msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr ""
"Примитивы синхронизации asyncio аналогичны примитивам модуля :mod:"
"`threading` с двумя важными оговорками:"

#: ../../library/asyncio-sync.rst:16
msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""
"Примитивы asyncio не являются потокобезопасными, поэтому их не следует "
"использовать для синхронизации потоков ОС (для этого используйте :mod:"
"`threading`);"

#: ../../library/asyncio-sync.rst:20
msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr ""
"методы этих примитивов синхронизации не принимают аргумент *timeout*; "
"используйте функцию :func:`asyncio.wait_for` для выполнения операций с "
"таймаутами."

#: ../../library/asyncio-sync.rst:24
msgid "asyncio has the following basic synchronization primitives:"
msgstr "asyncio имеет следующие базовые примитивы синхронизации:"

#: ../../library/asyncio-sync.rst:26
msgid ":class:`Lock`"
msgstr ":class:`Lock`"

#: ../../library/asyncio-sync.rst:27
msgid ":class:`Event`"
msgstr ":class:`Event`"

#: ../../library/asyncio-sync.rst:28
msgid ":class:`Condition`"
msgstr ":class:`Condition`"

#: ../../library/asyncio-sync.rst:29
msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

#: ../../library/asyncio-sync.rst:30
msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

#: ../../library/asyncio-sync.rst:31
msgid ":class:`Barrier`"
msgstr ":class:`Barrier`"

#: ../../library/asyncio-sync.rst:38
msgid "Lock"
msgstr "Блокировка"

#: ../../library/asyncio-sync.rst:42
msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr ""
"Реализует блокировку мьютекса для асинхронных задач. Не потокобезопасный."

#: ../../library/asyncio-sync.rst:44
msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""
"Блокировку asyncio можно использовать, чтобы гарантировать монопольный "
"доступ к общему ресурсу."

#: ../../library/asyncio-sync.rst:47
msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""
"Предпочтительным способом использования блокировки является оператор :"
"keyword:`async with`::"

#: ../../library/asyncio-sync.rst:50
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"

#: ../../library/asyncio-sync.rst:56 ../../library/asyncio-sync.rst:201
#: ../../library/asyncio-sync.rst:304
msgid "which is equivalent to::"
msgstr "что эквивалентно::"

#: ../../library/asyncio-sync.rst:58
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"

#: ../../library/asyncio-sync.rst:67 ../../library/asyncio-sync.rst:113
#: ../../library/asyncio-sync.rst:189 ../../library/asyncio-sync.rst:292
#: ../../library/asyncio-sync.rst:348
msgid "Removed the *loop* parameter."
msgstr "Удален параметр *loop*."

#: ../../library/asyncio-sync.rst:73
msgid "Acquire the lock."
msgstr "Приобретите замок."

#: ../../library/asyncio-sync.rst:75
msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""
"Этот метод ждет, пока блокировка не будет *разблокирована*, устанавливает ее "
"в значение *locked* и возвращает ``True``."

#: ../../library/asyncio-sync.rst:78
msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr ""
"Когда более одной сопрограммы блокируется в :meth:`acquire` в ожидании "
"разблокировки блокировки, в конечном итоге работает только одна сопрограмма."

#: ../../library/asyncio-sync.rst:82
msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr ""
"Получение блокировки является *справедливым*: выполняемая сопрограмма будет "
"первой сопрограммой, которая начала ожидать блокировки."

#: ../../library/asyncio-sync.rst:87
msgid "Release the lock."
msgstr "Отпустите замок."

#: ../../library/asyncio-sync.rst:89
msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr ""
"Когда замок *заблокирован*, сбросьте его на *разблокирован* и вернитесь."

#: ../../library/asyncio-sync.rst:91
msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr "Если блокировка *разблокирована*, выдается ошибка :exc:`RuntimeError`."

#: ../../library/asyncio-sync.rst:95
msgid "Return ``True`` if the lock is *locked*."
msgstr "Верните ``True``, если замок *заблокирован*."

#: ../../library/asyncio-sync.rst:99
msgid "Event"
msgstr "Событие"

#: ../../library/asyncio-sync.rst:103
msgid "An event object.  Not thread-safe."
msgstr "Объект события. Не потокобезопасный."

#: ../../library/asyncio-sync.rst:105
msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""
"Событие asyncio можно использовать для уведомления нескольких задач asyncio "
"о том, что произошло какое-то событие."

#: ../../library/asyncio-sync.rst:108
msgid ""
"An Event object manages an internal flag that can be set to *true* with the :"
"meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Объект Event управляет внутренним флагом, которому можно установить значение "
"*true* с помощью метода :meth:`~Event.set` и сбросить значение *false* с "
"помощью метода :meth:`clear`. Метод :meth:`~Event.wait` блокируется до тех "
"пор, пока флаг не будет установлен в значение *true*. Изначально флаг "
"установлен в значение *false*."

#: ../../library/asyncio-sync.rst:118 ../../library/asyncio-sync.rst:372
msgid "Example::"
msgstr "Пример::"

#: ../../library/asyncio-sync.rst:120
msgid ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-sync.rst:144
msgid "Wait until the event is set."
msgstr "Подождите, пока событие не будет установлено."

#: ../../library/asyncio-sync.rst:146
msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr ""
"Если событие установлено, немедленно верните ``True``. В противном случае "
"заблокируйте, пока другая задача не вызовет :meth:`~Event.set`."

#: ../../library/asyncio-sync.rst:151
msgid "Set the event."
msgstr "Установите событие."

#: ../../library/asyncio-sync.rst:153
msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""
"Все задачи, ожидающие установки события, будут немедленно активированы."

#: ../../library/asyncio-sync.rst:158
msgid "Clear (unset) the event."
msgstr "Очистить (сбросить) событие."

#: ../../library/asyncio-sync.rst:160
msgid ""
"Tasks awaiting on :meth:`~Event.wait` will now block until the :meth:`~Event."
"set` method is called again."
msgstr ""
"Задачи, ожидающие :meth:`~Event.wait`, теперь будут блокироваться до тех "
"пор, пока метод :meth:`~Event.set` не будет вызван снова."

#: ../../library/asyncio-sync.rst:165
msgid "Return ``True`` if the event is set."
msgstr "Верните ``True``, если событие установлено."

#: ../../library/asyncio-sync.rst:169
msgid "Condition"
msgstr "Состояние"

#: ../../library/asyncio-sync.rst:173
msgid "A Condition object.  Not thread-safe."
msgstr "Объект условия. Не потокобезопасный."

#: ../../library/asyncio-sync.rst:175
msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr ""
"Примитив условия asyncio может использоваться задачей для ожидания "
"наступления какого-либо события и последующего получения монопольного "
"доступа к общему ресурсу."

#: ../../library/asyncio-sync.rst:179
msgid ""
"In essence, a Condition object combines the functionality of an :class:"
"`Event` and a :class:`Lock`.  It is possible to have multiple Condition "
"objects share one Lock, which allows coordinating exclusive access to a "
"shared resource between different tasks interested in particular states of "
"that shared resource."
msgstr ""
"По сути, объект Condition сочетает в себе функциональность :class:`Event` и :"
"class:`Lock`. Возможно, что несколько объектов Condition совместно "
"используют один Lock, что позволяет координировать монопольный доступ к "
"общему ресурсу между различными задачами, заинтересованными в определенных "
"состояниях этого общего ресурса."

#: ../../library/asyncio-sync.rst:185
msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In "
"the latter case a new Lock object is created automatically."
msgstr ""
"Необязательный аргумент *lock* должен быть объектом :class:`Lock` или "
"``None``. В последнем случае новый объект Lock создается автоматически."

#: ../../library/asyncio-sync.rst:192
msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr ""
"Предпочтительным способом использования Условия является оператор :keyword:"
"`async with`::"

#: ../../library/asyncio-sync.rst:195
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"

#: ../../library/asyncio-sync.rst:203
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"

#: ../../library/asyncio-sync.rst:215
msgid "Acquire the underlying lock."
msgstr "Получите базовый замок."

#: ../../library/asyncio-sync.rst:217
msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""
"Этот метод ждет, пока базовая блокировка не будет *разблокирована*, "
"устанавливает ее в значение *locked* и возвращает ``True``."

#: ../../library/asyncio-sync.rst:222
msgid ""
"Wake up at most *n* tasks (1 by default) waiting on this condition.  The "
"method is no-op if no tasks are waiting."
msgstr ""
"Пробуждение не более *n* задач (1 по умолчанию), ожидающих этого условия. "
"Этот метод является пустым, если нет ожидающих задач."

#: ../../library/asyncio-sync.rst:225 ../../library/asyncio-sync.rst:240
msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"Блокировка должна быть получена до вызова этого метода и вскоре после этого "
"снята. При вызове с *разблокированной* блокировкой возникает ошибка :exc:"
"`RuntimeError`."

#: ../../library/asyncio-sync.rst:231
msgid "Return ``True`` if the underlying lock is acquired."
msgstr "Верните True, если базовая блокировка получена."

#: ../../library/asyncio-sync.rst:235
msgid "Wake up all tasks waiting on this condition."
msgstr "Разбудите все задачи, ожидающие этого условия."

#: ../../library/asyncio-sync.rst:237
msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""
"Этот метод действует как :meth:`notify`, но пробуждает все ожидающие задачи."

#: ../../library/asyncio-sync.rst:246
msgid "Release the underlying lock."
msgstr "Снимите основной замок."

#: ../../library/asyncio-sync.rst:248
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"При вызове разблокированной блокировки возникает ошибка :exc:`RuntimeError`."

#: ../../library/asyncio-sync.rst:254
msgid "Wait until notified."
msgstr "Подождите, пока вас не уведомят."

#: ../../library/asyncio-sync.rst:256
msgid ""
"If the calling task has not acquired the lock when this method is called, a :"
"exc:`RuntimeError` is raised."
msgstr ""
"Если вызывающая задача не получила блокировку при вызове этого метода, "
"возникает ошибка :exc:`RuntimeError`."

#: ../../library/asyncio-sync.rst:259
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"Этот метод снимает базовую блокировку, а затем блокируется до тех пор, пока "
"она не будет разбужена вызовом :meth:`notify` или :meth:`notify_all`. После "
"пробуждения Condition повторно получает блокировку, и этот метод возвращает "
"True."

#: ../../library/asyncio-sync.rst:267
msgid "Wait until a predicate becomes *true*."
msgstr "Подождите, пока предикат не станет *истиной*."

#: ../../library/asyncio-sync.rst:269
msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The method will repeatedly :meth:`~Condition.wait` until the "
"predicate evaluates to *true*. The final value is the return value."
msgstr ""
"Предикат должен быть вызываемым, результат которого будет интерпретироваться "
"как логическое значение. Метод будет повторять :meth:`~Condition.wait` до "
"тех пор, пока предикат не примет значение *true*. Окончательное значение "
"является возвращаемым значением."

#: ../../library/asyncio-sync.rst:276
msgid "Semaphore"
msgstr "Семафор"

#: ../../library/asyncio-sync.rst:280
msgid "A Semaphore object.  Not thread-safe."
msgstr "Объект Семафор. Не потокобезопасный."

#: ../../library/asyncio-sync.rst:282
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call. The counter can "
"never go below zero; when :meth:`acquire` finds that it is zero, it blocks, "
"waiting until some task calls :meth:`release`."
msgstr ""
"Семафор управляет внутренним счетчиком, который уменьшается при каждом "
"вызове :meth:`acquire` и увеличивается при каждом вызове :meth:`release`. "
"Счетчик никогда не может опуститься ниже нуля; когда :meth:`acquire` "
"обнаруживает, что оно равно нулю, он блокируется, ожидая, пока какая-нибудь "
"задача не вызовет :meth:`release`."

#: ../../library/asyncio-sync.rst:288
msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a :exc:"
"`ValueError` is raised."
msgstr ""
"Необязательный аргумент *value* дает начальное значение внутреннего счетчика "
"(по умолчанию «1»). Если заданное значение меньше ``0``, возникает ошибка :"
"exc:`ValueError`."

#: ../../library/asyncio-sync.rst:295
msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr ""
"Предпочтительным способом использования семафора является оператор :keyword:"
"`async with`::"

#: ../../library/asyncio-sync.rst:298
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"

#: ../../library/asyncio-sync.rst:306
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"

#: ../../library/asyncio-sync.rst:318
msgid "Acquire a semaphore."
msgstr "Приобретите семафор."

#: ../../library/asyncio-sync.rst:320
msgid ""
"If the internal counter is greater than zero, decrement it by one and return "
"``True`` immediately.  If it is zero, wait until a :meth:`release` is called "
"and return ``True``."
msgstr ""
"Если внутренний счетчик больше нуля, уменьшите его на единицу и немедленно "
"верните True. Если оно равно нулю, дождитесь вызова :meth:`release` и "
"верните ``True``."

#: ../../library/asyncio-sync.rst:326
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "Возвращает True, если семафор не может быть получен немедленно."

#: ../../library/asyncio-sync.rst:330
msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a "
"task waiting to acquire the semaphore."
msgstr ""
"Освободите семафор, увеличив внутренний счетчик на единицу. Может разбудить "
"задачу, ожидающую получения семафора."

#: ../../library/asyncio-sync.rst:333
msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
"В отличие от :class:`BoundedSemaphore`, :class:`Semaphore` позволяет "
"выполнять больше вызовов ``release()``, чем ``acquire()``."

#: ../../library/asyncio-sync.rst:338
msgid "BoundedSemaphore"
msgstr "BoundedSemaphore"

#: ../../library/asyncio-sync.rst:342
msgid "A bounded semaphore object.  Not thread-safe."
msgstr "Ограниченный объект-семафор. Не потокобезопасный."

#: ../../library/asyncio-sync.rst:344
msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a :exc:"
"`ValueError` in :meth:`~Semaphore.release` if it increases the internal "
"counter above the initial *value*."
msgstr ""
"Ограниченный семафор — это версия :class:`Semaphore`, которая вызывает :exc:"
"`ValueError` в :meth:`~Semaphore.release`, если внутренний счетчик превышает "
"начальное *значение*."

#: ../../library/asyncio-sync.rst:353
msgid "Barrier"
msgstr "Барьер"

#: ../../library/asyncio-sync.rst:357
msgid "A barrier object.  Not thread-safe."
msgstr "Барьерный объект. Не потокобезопасный."

#: ../../library/asyncio-sync.rst:359
msgid ""
"A barrier is a simple synchronization primitive that allows to block until "
"*parties* number of tasks are waiting on it. Tasks can wait on the :meth:"
"`~Barrier.wait` method and would be blocked until the specified number of "
"tasks end up waiting on :meth:`~Barrier.wait`. At that point all of the "
"waiting tasks would unblock simultaneously."
msgstr ""
"Барьер — это простой примитив синхронизации, который позволяет блокировать "
"до тех пор, пока на нем не будет ожидать *сторон* ряд задач. Задачи могут "
"ждать метода :meth:`~Barrier.wait` и будут заблокированы до тех пор, пока "
"указанное количество задач не окажется в ожидании :meth:`~Barrier.wait`. В "
"этот момент все ожидающие задачи разблокируются одновременно."

#: ../../library/asyncio-sync.rst:365
msgid ""
":keyword:`async with` can be used as an alternative to awaiting on :meth:"
"`~Barrier.wait`."
msgstr ""
":keyword:`async with` можно использовать как альтернативу ожиданию :meth:"
"`~Barrier.wait`."

#: ../../library/asyncio-sync.rst:368
msgid "The barrier can be reused any number of times."
msgstr "Барьер можно использовать повторно любое количество раз."

#: ../../library/asyncio-sync.rst:374
msgid ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"
msgstr ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"

#: ../../library/asyncio-sync.rst:395
msgid "Result of this example is::"
msgstr "Результат этого примера::"

#: ../../library/asyncio-sync.rst:397
msgid ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"
msgstr ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"

#: ../../library/asyncio-sync.rst:407
msgid ""
"Pass the barrier. When all the tasks party to the barrier have called this "
"function, they are all unblocked simultaneously."
msgstr ""
"Пройдите барьер. Когда все задачи, участвующие в барьере, вызвали эту "
"функцию, все они разблокируются одновременно."

#: ../../library/asyncio-sync.rst:410
msgid ""
"When a waiting or blocked task in the barrier is cancelled, this task exits "
"the barrier which stays in the same state. If the state of the barrier is "
"\"filling\", the number of waiting task decreases by 1."
msgstr ""
"Когда ожидающая или заблокированная задача в барьере отменяется, эта задача "
"выходит из барьера, оставаясь в том же состоянии. Если состояние барьера "
"«заполнение», количество ожидающих задач уменьшается на 1."

#: ../../library/asyncio-sync.rst:415
msgid ""
"The return value is an integer in the range of 0 to ``parties-1``, different "
"for each task. This can be used to select a task to do some special "
"housekeeping, e.g.::"
msgstr ""
"Возвращаемое значение представляет собой целое число в диапазоне от 0 до "
"``party-1``, различное для каждой задачи. Это можно использовать для выбора "
"задачи для выполнения какой-либо специальной хозяйственной деятельности, "
"например:"

#: ../../library/asyncio-sync.rst:419
msgid ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"
msgstr ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"

#: ../../library/asyncio-sync.rst:425
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a task is waiting. It could raise a :exc:"
"`CancelledError` if a task is cancelled."
msgstr ""
"Этот метод может вызвать исключение :class:`BrokenBarrierError`, если барьер "
"сломан или сброшен во время ожидания задачи. Это может вызвать :exc:"
"`CancelledError`, если задача отменена."

#: ../../library/asyncio-sync.rst:432
msgid ""
"Return the barrier to the default, empty state.  Any tasks waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Верните барьер в пустое состояние по умолчанию. Любые задачи, ожидающие его, "
"получат исключение :class:`BrokenBarrierError`."

#: ../../library/asyncio-sync.rst:435
msgid ""
"If a barrier is broken it may be better to just leave it and create a new "
"one."
msgstr ""
"Если барьер разрушен, возможно, лучше просто оставить его и создать новый."

#: ../../library/asyncio-sync.rst:440
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`~Barrier.wait` to fail with the :class:`BrokenBarrierError`. Use "
"this for example if one of the tasks needs to abort, to avoid infinite "
"waiting tasks."
msgstr ""
"Приведите барьер в сломанное состояние. Это приводит к тому, что любые "
"активные или будущие вызовы :meth:`~Barrier.wait` завершаются с ошибкой :"
"class:`BrokenBarrierError`. Используйте это, например, если одну из задач "
"необходимо прервать, чтобы избежать бесконечного ожидания задач."

#: ../../library/asyncio-sync.rst:447
msgid "The number of tasks required to pass the barrier."
msgstr "Количество задач, необходимых для прохождения барьера."

#: ../../library/asyncio-sync.rst:451
msgid "The number of tasks currently waiting in the barrier while filling."
msgstr ""
"Количество задач, ожидающих в настоящее время в барьере при заполнении."

#: ../../library/asyncio-sync.rst:455
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""
"Логическое значение, имеющее значение «Истина», если барьер находится в "
"разрушенном состоянии."

#: ../../library/asyncio-sync.rst:460
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Это исключение, подкласс :exc:`RuntimeError`, возникает, когда объект :class:"
"`Barrier` сбрасывается или разрушается."

#: ../../library/asyncio-sync.rst:468
msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or :keyword:"
"`with` statement (``with await lock``, ``with (yield from lock)``) was "
"removed.  Use ``async with lock`` instead."
msgstr ""
"Получение блокировки с помощью оператора ``await lock`` или ``yield from "
"lock`` и/или :keyword:`with` (``with await lock``, ``with (yield from "
"lock)``) было удалено. . Вместо этого используйте ``async с блокировкой``."
