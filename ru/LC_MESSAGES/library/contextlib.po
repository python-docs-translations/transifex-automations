# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/contextlib.rst:2
msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ""
":mod:`!contextlib` --- Утилиты для контекстов :keyword:`!with`\\ -statement"

#: ../../library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**Исходный код:** :source:`Lib/contextlib.py`"

#: ../../library/contextlib.rst:11
msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"Этот модуль предоставляет утилиты для распространенных задач, связанных с "
"оператором :keyword:`with`. Для получения дополнительной информации см. "
"также :ref:`typecontextmanager` и :ref:`context-managers`."

#: ../../library/contextlib.rst:17
msgid "Utilities"
msgstr "Утилиты"

#: ../../library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr "Предоставляемые функции и классы:"

#: ../../library/contextlib.rst:23
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
":term:`абстрактный базовый класс` для классов, реализующих :meth:`object."
"__enter__` и :meth:`object.__exit__`. Предоставляется реализация по "
"умолчанию для :meth:`object.__enter__`, которая возвращает ``self``, в то "
"время как :meth:`object.__exit__` является абстрактным методом, который по "
"умолчанию возвращает ``None``. См. также определение :ref:"
"`typecontextmanager`."

#: ../../library/contextlib.rst:34
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
":term:`абстрактный базовый класс` для классов, реализующих :meth:`object."
"__aenter__` и :meth:`object.__aexit__`. Предоставляется реализация по "
"умолчанию для :meth:`object.__aenter__`, которая возвращает ``self``, в то "
"время как :meth:`object.__aexit__` является абстрактным методом, который по "
"умолчанию возвращает ``None``. См. также определение :ref:`async-context-"
"managers`."

#: ../../library/contextlib.rst:46
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`~object.__enter__` and :meth:`~object."
"__exit__` methods."
msgstr ""
"Эта функция представляет собой :term:`декоратор`, который можно использовать "
"для определения фабричной функции для менеджеров контекста операторов :"
"keyword:`with` без необходимости создания класса или отдельных :meth:"
"`~object.__enter__` и :meth :`~object.__exit__` методы."

#: ../../library/contextlib.rst:50
msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``"
msgstr ""
"Хотя многие объекты изначально поддерживают использование операторов with, "
"иногда необходимо управлять ресурсом, который сам по себе не является "
"контекстным менеджером и не реализует метод close() для использования с "
"contextlib. закрытие``"

#: ../../library/contextlib.rst:54
msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""
"Абстрактным примером обеспечения правильного управления ресурсами может быть "
"следующий:"

#: ../../library/contextlib.rst:57
msgid ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def managed_resource(*args, **kwds):\n"
"    # Code to acquire resource, e.g.:\n"
"    resource = acquire_resource(*args, **kwds)\n"
"    try:\n"
"        yield resource\n"
"    finally:\n"
"        # Code to release resource, e.g.:\n"
"        release_resource(resource)"
msgstr ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def managed_resource(*args, **kwds):\n"
"    # Code to acquire resource, e.g.:\n"
"    resource = acquire_resource(*args, **kwds)\n"
"    try:\n"
"        yield resource\n"
"    finally:\n"
"        # Code to release resource, e.g.:\n"
"        release_resource(resource)"

#: ../../library/contextlib.rst:69
msgid "The function can then be used like this::"
msgstr "Затем функцию можно использовать следующим образом:"

#: ../../library/contextlib.rst:71
msgid ""
">>> with managed_resource(timeout=3600) as resource:\n"
"...     # Resource is released at the end of this block,\n"
"...     # even if code in the block raises an exception"
msgstr ""
">>> with managed_resource(timeout=3600) as resource:\n"
"...     # Resource is released at the end of this block,\n"
"...     # even if code in the block raises an exception"

#: ../../library/contextlib.rst:75
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"Декорируемая функция при вызове должна возвращать итератор :term:"
"`generator`. Этот итератор должен возвращать ровно одно значение, которое "
"будет привязано к целям в предложении :keyword:`!as` оператора :keyword:"
"`with`, если таковое имеется."

#: ../../library/contextlib.rst:79
msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"В тот момент, когда генератор завершает работу, выполняется блок, вложенный "
"в оператор :keyword:`with`. Затем генератор возобновляется после выхода из "
"блока. Если в блоке возникает необработанное исключение, оно повторно "
"возбуждается внутри генератора в той точке, где произошел выход. Таким "
"образом, вы можете использовать оператор :keyword:`try`...\\ :keyword:"
"`Exception`...\\ :keyword:`finally` для перехвата ошибки (если таковая "
"имеется) или обеспечения некоторой очистки. Если исключение перехватывается "
"просто для того, чтобы зарегистрировать его или выполнить какое-либо "
"действие (вместо того, чтобы полностью его подавить), генератор должен "
"повторно вызвать это исключение. В противном случае менеджер контекста "
"генератора укажет оператору :keyword:`!with`, что исключение было "
"обработано, и выполнение возобновится с оператора, следующего сразу за "
"оператором :keyword:`!with`."

#: ../../library/contextlib.rst:91
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` использует :class:`ContextDecorator`, поэтому "
"создаваемые им контекстные менеджеры могут использоваться как декораторы, а "
"также в операторах :keyword:`with`. При использовании в качестве декоратора "
"новый экземпляр генератора неявно создается при каждом вызове функции (это "
"позволяет «одноразовым» контекстным менеджерам, созданным :func:"
"`contextmanager`, удовлетворять требованию, чтобы контекстные менеджеры "
"поддерживали множественные вызовы для того, чтобы использоваться в качестве "
"декораторов)."

#: ../../library/contextlib.rst:98
msgid "Use of :class:`ContextDecorator`."
msgstr "Использование :class:`ContextDecorator`."

#: ../../library/contextlib.rst:104
msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
"Похож на :func:`~contextlib.contextmanager`, но создаёт :ref:`асинхронный "
"менеджер контекста <async-context-managers>`."

#: ../../library/contextlib.rst:107
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`~object.__aenter__` "
"and :meth:`~object.__aexit__` methods. It must be applied to an :term:"
"`asynchronous generator` function."
msgstr ""
"Эта функция представляет собой :term:`декоратор`, который можно использовать "
"для определения фабричной функции для :keyword:`async with` операторных "
"асинхронных контекстных менеджеров без необходимости создания класса или "
"отдельного :meth:`~object.__aenter__` и :meth:`~object.__aexit__` методы. "
"Его необходимо применить к функции асинхронного генератора."

#: ../../library/contextlib.rst:113
msgid "A simple example::"
msgstr "Простой пример::"

#: ../../library/contextlib.rst:115
msgid ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def get_connection():\n"
"    conn = await acquire_db_connection()\n"
"    try:\n"
"        yield conn\n"
"    finally:\n"
"        await release_db_connection(conn)\n"
"\n"
"async def get_all_users():\n"
"    async with get_connection() as conn:\n"
"        return conn.query('SELECT ...')"
msgstr ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def get_connection():\n"
"    conn = await acquire_db_connection()\n"
"    try:\n"
"        yield conn\n"
"    finally:\n"
"        await release_db_connection(conn)\n"
"\n"
"async def get_all_users():\n"
"    async with get_connection() as conn:\n"
"        return conn.query('SELECT ...')"

#: ../../library/contextlib.rst:131
msgid ""
"Context managers defined with :func:`asynccontextmanager` can be used either "
"as decorators or with :keyword:`async with` statements::"
msgstr ""
"Менеджеры контекста, определенные с помощью :func:`asynccontextmanager`, "
"могут использоваться либо как декораторы, либо с операторами :keyword:`async "
"with`::"

#: ../../library/contextlib.rst:134
msgid ""
"import time\n"
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def timeit():\n"
"    now = time.monotonic()\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        print(f'it took {time.monotonic() - now}s to run')\n"
"\n"
"@timeit()\n"
"async def main():\n"
"    # ... async code ..."
msgstr ""
"import time\n"
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def timeit():\n"
"    now = time.monotonic()\n"
"    try:\n"
"        yield\n"
"    finally:\n"
"        print(f'it took {time.monotonic() - now}s to run')\n"
"\n"
"@timeit()\n"
"async def main():\n"
"    # ... async code ..."

#: ../../library/contextlib.rst:149
msgid ""
"When used as a decorator, a new generator instance is implicitly created on "
"each function call. This allows the otherwise \"one-shot\" context managers "
"created by :func:`asynccontextmanager` to meet the requirement that context "
"managers support multiple invocations in order to be used as decorators."
msgstr ""
"При использовании в качестве декоратора новый экземпляр генератора неявно "
"создается при каждом вызове функции. Это позволяет «одноразовым» менеджерам "
"контекста, созданным :func:`asynccontextmanager`, удовлетворять требованию, "
"чтобы контекстные менеджеры поддерживали множественные вызовы для "
"использования в качестве декораторов."

#: ../../library/contextlib.rst:154
msgid ""
"Async context managers created with :func:`asynccontextmanager` can be used "
"as decorators."
msgstr ""
"Менеджеры асинхронного контекста, созданные с помощью :func:"
"`asynccontextmanager`, могут использоваться в качестве декораторов."

#: ../../library/contextlib.rst:161
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""
"Возвращает менеджер контекста, который закрывает *thing* после завершения "
"блока. Это в основном эквивалентно::"

#: ../../library/contextlib.rst:164
msgid ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def closing(thing):\n"
"    try:\n"
"        yield thing\n"
"    finally:\n"
"        thing.close()"
msgstr ""
"from contextlib import contextmanager\n"
"\n"
"@contextmanager\n"
"def closing(thing):\n"
"    try:\n"
"        yield thing\n"
"    finally:\n"
"        thing.close()"

#: ../../library/contextlib.rst:173
msgid "And lets you write code like this::"
msgstr "И позволяет писать такой код::"

#: ../../library/contextlib.rst:175
msgid ""
"from contextlib import closing\n"
"from urllib.request import urlopen\n"
"\n"
"with closing(urlopen('https://www.python.org')) as page:\n"
"    for line in page:\n"
"        print(line)"
msgstr ""
"from contextlib import closing\n"
"from urllib.request import urlopen\n"
"\n"
"with closing(urlopen('https://www.python.org')) as page:\n"
"    for line in page:\n"
"        print(line)"

#: ../../library/contextlib.rst:182
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"без необходимости явно закрывать страницу. Даже если произойдет ошибка, page."
"close() будет вызвана при выходе из блока :keyword:`with`."

#: ../../library/contextlib.rst:187
msgid ""
"Most types managing resources support the :term:`context manager` protocol, "
"which closes *thing* on leaving the :keyword:`with` statement. As such, :"
"func:`!closing` is most useful for third party types that don't support "
"context managers. This example is purely for illustration purposes, as :func:"
"`~urllib.request.urlopen` would normally be used in a context manager."
msgstr ""
"Большинство типов управления ресурсами поддерживают протокол :term:"
"`контекстного менеджера`, который закрывает *thing* при выходе из оператора :"
"keyword:`with`. Таким образом, :func:`!closing` наиболее полезен для "
"сторонних типов, которые не поддерживают менеджеры контекста. Этот пример "
"предназначен исключительно для иллюстрации, поскольку :func:`~urllib.request."
"urlopen` обычно используется в менеджере контекста."

#: ../../library/contextlib.rst:196
msgid ""
"Return an async context manager that calls the ``aclose()`` method of "
"*thing* upon completion of the block.  This is basically equivalent to::"
msgstr ""
"Возвращает асинхронный контекстный менеджер, который вызывает метод aclose() "
"объекта *thing* после завершения блока. Это в основном эквивалентно::"

#: ../../library/contextlib.rst:199
msgid ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def aclosing(thing):\n"
"    try:\n"
"        yield thing\n"
"    finally:\n"
"        await thing.aclose()"
msgstr ""
"from contextlib import asynccontextmanager\n"
"\n"
"@asynccontextmanager\n"
"async def aclosing(thing):\n"
"    try:\n"
"        yield thing\n"
"    finally:\n"
"        await thing.aclose()"

#: ../../library/contextlib.rst:208
msgid ""
"Significantly, ``aclosing()`` supports deterministic cleanup of async "
"generators when they happen to exit early by :keyword:`break` or an "
"exception.  For example::"
msgstr ""
"Примечательно, что ``aclosing()`` поддерживает детерминированную очистку "
"асинхронных генераторов, когда они завершают работу раньше по причине :"
"keyword:`break` или исключения. Например::"

#: ../../library/contextlib.rst:212
msgid ""
"from contextlib import aclosing\n"
"\n"
"async with aclosing(my_generator()) as values:\n"
"    async for value in values:\n"
"        if value == 42:\n"
"            break"
msgstr ""
"from contextlib import aclosing\n"
"\n"
"async with aclosing(my_generator()) as values:\n"
"    async for value in values:\n"
"        if value == 42:\n"
"            break"

#: ../../library/contextlib.rst:219
msgid ""
"This pattern ensures that the generator's async exit code is executed in the "
"same context as its iterations (so that exceptions and context variables "
"work as expected, and the exit code isn't run after the lifetime of some "
"task it depends on)."
msgstr ""
"Этот шаблон гарантирует, что асинхронный код выхода генератора выполняется в "
"том же контексте, что и его итерации (так что исключения и переменные "
"контекста работают должным образом, а код выхода не запускается по истечении "
"времени существования какой-либо задачи, от которой он зависит)."

#: ../../library/contextlib.rst:231
msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"Возвращает менеджер контекста, который возвращает *enter_result* из "
"``__enter__``, но в остальном ничего не делает. Он предназначен для "
"использования в качестве замены дополнительного контекстного менеджера, "
"например::"

#: ../../library/contextlib.rst:235
msgid ""
"def myfunction(arg, ignore_exceptions=False):\n"
"    if ignore_exceptions:\n"
"        # Use suppress to ignore all exceptions.\n"
"        cm = contextlib.suppress(Exception)\n"
"    else:\n"
"        # Do not ignore any exceptions, cm has no effect.\n"
"        cm = contextlib.nullcontext()\n"
"    with cm:\n"
"        # Do something"
msgstr ""
"def myfunction(arg, ignore_exceptions=False):\n"
"    if ignore_exceptions:\n"
"        # Use suppress to ignore all exceptions.\n"
"        cm = contextlib.suppress(Exception)\n"
"    else:\n"
"        # Do not ignore any exceptions, cm has no effect.\n"
"        cm = contextlib.nullcontext()\n"
"    with cm:\n"
"        # Do something"

#: ../../library/contextlib.rst:245
msgid "An example using *enter_result*::"
msgstr "Пример использования *enter_result*::"

#: ../../library/contextlib.rst:247
msgid ""
"def process_file(file_or_path):\n"
"    if isinstance(file_or_path, str):\n"
"        # If string, open file\n"
"        cm = open(file_or_path)\n"
"    else:\n"
"        # Caller is responsible for closing file\n"
"        cm = nullcontext(file_or_path)\n"
"\n"
"    with cm as file:\n"
"        # Perform processing on the file"
msgstr ""
"def process_file(file_or_path):\n"
"    if isinstance(file_or_path, str):\n"
"        # If string, open file\n"
"        cm = open(file_or_path)\n"
"    else:\n"
"        # Caller is responsible for closing file\n"
"        cm = nullcontext(file_or_path)\n"
"\n"
"    with cm as file:\n"
"        # Perform processing on the file"

#: ../../library/contextlib.rst:258
msgid ""
"It can also be used as a stand-in for :ref:`asynchronous context managers "
"<async-context-managers>`::"
msgstr ""
"Его также можно использовать в качестве замены :ref:`асинхронных контекстных "
"менеджеров <async-context-managers>`::"

#: ../../library/contextlib.rst:261
msgid ""
"async def send_http(session=None):\n"
"    if not session:\n"
"        # If no http session, create it with aiohttp\n"
"        cm = aiohttp.ClientSession()\n"
"    else:\n"
"        # Caller is responsible for closing the session\n"
"        cm = nullcontext(session)\n"
"\n"
"    async with cm as session:\n"
"        # Send http requests with session"
msgstr ""
"async def send_http(session=None):\n"
"    if not session:\n"
"        # If no http session, create it with aiohttp\n"
"        cm = aiohttp.ClientSession()\n"
"    else:\n"
"        # Caller is responsible for closing the session\n"
"        cm = nullcontext(session)\n"
"\n"
"    async with cm as session:\n"
"        # Send http requests with session"

#: ../../library/contextlib.rst:274
msgid ":term:`asynchronous context manager` support was added."
msgstr ":term:`добавлена ​​поддержка асинхронного контекстного менеджера`."

#: ../../library/contextlib.rst:281
msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a :keyword:`!with` statement and then resumes "
"execution with the first statement following the end of the :keyword:`!with` "
"statement."
msgstr ""
"Возвращает диспетчер контекста, который подавляет любое из указанных "
"исключений, если они возникают в теле оператора :keyword:`!with`, а затем "
"возобновляет выполнение с первого оператора, следующего за концом оператора :"
"keyword:`!with`."

#: ../../library/contextlib.rst:286
msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr ""
"Как и любой другой механизм, который полностью подавляет исключения, этот "
"контекстный менеджер следует использовать только для устранения очень "
"конкретных ошибок, когда известно, что молчаливое продолжение выполнения "
"программы является правильным."

#: ../../library/contextlib.rst:291
msgid "For example::"
msgstr "Например::"

#: ../../library/contextlib.rst:293
msgid ""
"from contextlib import suppress\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('somefile.tmp')\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('someotherfile.tmp')"
msgstr ""
"from contextlib import suppress\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('somefile.tmp')\n"
"\n"
"with suppress(FileNotFoundError):\n"
"    os.remove('someotherfile.tmp')"

#: ../../library/contextlib.rst:301
msgid "This code is equivalent to::"
msgstr "Этот код эквивалентен::"

#: ../../library/contextlib.rst:303
msgid ""
"try:\n"
"    os.remove('somefile.tmp')\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"try:\n"
"    os.remove('someotherfile.tmp')\n"
"except FileNotFoundError:\n"
"    pass"
msgstr ""
"try:\n"
"    os.remove('somefile.tmp')\n"
"except FileNotFoundError:\n"
"    pass\n"
"\n"
"try:\n"
"    os.remove('someotherfile.tmp')\n"
"except FileNotFoundError:\n"
"    pass"

#: ../../library/contextlib.rst:313 ../../library/contextlib.rst:362
#: ../../library/contextlib.rst:372 ../../library/contextlib.rst:389
msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "Этот контекстный менеджер — :ref:`reentrant <reentrant-cms>`."

#: ../../library/contextlib.rst:315
msgid ""
"If the code within the :keyword:`!with` block raises a :exc:"
"`BaseExceptionGroup`, suppressed exceptions are removed from the group.  Any "
"exceptions of the group which are not suppressed are re-raised in a new "
"group which is created using the original group's :meth:`~BaseExceptionGroup."
"derive` method."
msgstr ""
"Если код внутри блока :keyword:`!with` вызывает :exc:`BaseExceptionGroup`, "
"подавленные исключения удаляются из группы. Любые исключения группы, которые "
"не подавлены, повторно вызываются в новой группе, которая создается с "
"использованием метода :meth:`~BaseExceptionGroup.derive` исходной группы."

#: ../../library/contextlib.rst:323
msgid ""
"``suppress`` now supports suppressing exceptions raised as part of a :exc:"
"`BaseExceptionGroup`."
msgstr ""
"``suppress`` теперь поддерживает подавление исключений, возникающих как "
"часть :exc:`BaseExceptionGroup`."

#: ../../library/contextlib.rst:329
msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""
"Менеджер контекста для временного перенаправления :data:`sys.stdout` в "
"другой файл или файловоподобный объект."

#: ../../library/contextlib.rst:332
msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""
"Этот инструмент добавляет гибкость существующим функциям или классам, вывод "
"которых жестко привязан к стандартному выводу."

#: ../../library/contextlib.rst:335
msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object. The replacement stream is returned from the "
"``__enter__`` method and so is available as the target of the :keyword:"
"`with` statement::"
msgstr ""
"Например, вывод :func:`help` обычно отправляется в *sys.stdout*. Вы можете "
"записать этот вывод в строку, перенаправив вывод на объект :class:`io."
"StringIO`. Поток замены возвращается из метода ``__enter__`` и поэтому "
"доступен в качестве цели оператора :keyword:`with`::"

#: ../../library/contextlib.rst:341
msgid ""
"with redirect_stdout(io.StringIO()) as f:\n"
"    help(pow)\n"
"s = f.getvalue()"
msgstr ""
"with redirect_stdout(io.StringIO()) as f:\n"
"    help(pow)\n"
"s = f.getvalue()"

#: ../../library/contextlib.rst:345
msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr ""
"Чтобы отправить вывод :func:`help` в файл на диске, перенаправьте вывод в "
"обычный файл::"

#: ../../library/contextlib.rst:348
msgid ""
"with open('help.txt', 'w') as f:\n"
"    with redirect_stdout(f):\n"
"        help(pow)"
msgstr ""
"with open('help.txt', 'w') as f:\n"
"    with redirect_stdout(f):\n"
"        help(pow)"

#: ../../library/contextlib.rst:352
msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr "Чтобы отправить вывод :func:`help` в *sys.stderr*::"

#: ../../library/contextlib.rst:354
msgid ""
"with redirect_stdout(sys.stderr):\n"
"    help(pow)"
msgstr ""
"with redirect_stdout(sys.stderr):\n"
"    help(pow)"

#: ../../library/contextlib.rst:357
msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
"Обратите внимание, что глобальный побочный эффект :data:`sys.stdout` "
"означает, что этот контекстный менеджер не подходит для использования в "
"библиотечном коде и большинстве многопоточных приложений. Это также не "
"влияет на выходные данные подпроцессов. Тем не менее, это по-прежнему "
"полезный подход для многих служебных сценариев."

#: ../../library/contextlib.rst:369
msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
"Аналогично :func:`~contextlib.redirect_stdout`, но перенаправляет :data:`sys."
"stderr` в другой файл или файловоподобный объект."

#: ../../library/contextlib.rst:379
msgid ""
"Non parallel-safe context manager to change the current working directory. "
"As this changes a global state, the working directory, it is not suitable "
"for use in most threaded or async contexts. It is also not suitable for most "
"non-linear code execution, like generators, where the program execution is "
"temporarily relinquished -- unless explicitly desired, you should not yield "
"when this context manager is active."
msgstr ""
"Непараллельный контекстный менеджер для изменения текущего рабочего "
"каталога. Поскольку при этом изменяется глобальное состояние, рабочий "
"каталог, он не подходит для использования в большинстве многопоточных или "
"асинхронных контекстов. Он также не подходит для выполнения большинства "
"нелинейных кодов, таких как генераторы, где выполнение программы временно "
"приостанавливается - если это явно не требуется, вы не должны уступать, "
"когда этот контекстный менеджер активен."

#: ../../library/contextlib.rst:386
msgid ""
"This is a simple wrapper around :func:`~os.chdir`, it changes the current "
"working directory upon entering and restores the old one on exit."
msgstr ""
"Это простая оболочка :func:`~os.chdir`, она меняет текущий рабочий каталог "
"при входе и восстанавливает старый при выходе."

#: ../../library/contextlib.rst:396
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""
"Базовый класс, который позволяет использовать менеджер контекста в качестве "
"декоратора."

#: ../../library/contextlib.rst:398
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"Менеджеры контекста, наследующие от ContextDecorator, должны реализовать "
"__enter__ и __exit__ как обычно. ``__exit__`` сохраняет необязательную "
"обработку исключений даже при использовании в качестве декоратора."

#: ../../library/contextlib.rst:402
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
"``ContextDecorator`` используется :func:`contextmanager`, поэтому вы "
"получаете эту функциональность автоматически."

#: ../../library/contextlib.rst:405
msgid "Example of ``ContextDecorator``::"
msgstr "Пример ``ContextDecorator``::"

#: ../../library/contextlib.rst:407
msgid ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextDecorator):\n"
"    def __enter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"
msgstr ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextDecorator):\n"
"    def __enter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"

#: ../../library/contextlib.rst:418 ../../library/contextlib.rst:490
msgid "The class can then be used like this::"
msgstr "Затем класс можно использовать следующим образом:"

#: ../../library/contextlib.rst:420
msgid ""
">>> @mycontext()\n"
"... def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> function()\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> with mycontext():\n"
"...     print('The bit in the middle')\n"
"...\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"
msgstr ""
">>> @mycontext()\n"
"... def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> function()\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> with mycontext():\n"
"...     print('The bit in the middle')\n"
"...\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"

#: ../../library/contextlib.rst:436
msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr ""
"Это изменение является просто синтаксическим сахаром для любой конструкции "
"следующей формы:"

#: ../../library/contextlib.rst:438
msgid ""
"def f():\n"
"    with cm():\n"
"        # Do stuff"
msgstr ""
"def f():\n"
"    with cm():\n"
"        # Do stuff"

#: ../../library/contextlib.rst:442
msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` позволяет вместо этого писать::"

#: ../../library/contextlib.rst:444
msgid ""
"@cm()\n"
"def f():\n"
"    # Do stuff"
msgstr ""
"@cm()\n"
"def f():\n"
"    # Do stuff"

#: ../../library/contextlib.rst:448
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"Это ясно дает понять, что ``cm`` применяется ко всей функции, а не только к "
"ее части (и сохранение уровня отступа тоже полезно)."

#: ../../library/contextlib.rst:451
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"Существующие контекстные менеджеры, у которых уже есть базовый класс, можно "
"расширить, используя ContextDecorator в качестве примеси:"

#: ../../library/contextlib.rst:454
msgid ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextBaseClass, ContextDecorator):\n"
"    def __enter__(self):\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        return False"
msgstr ""
"from contextlib import ContextDecorator\n"
"\n"
"class mycontext(ContextBaseClass, ContextDecorator):\n"
"    def __enter__(self):\n"
"        return self\n"
"\n"
"    def __exit__(self, *exc):\n"
"        return False"

#: ../../library/contextlib.rst:464
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"Поскольку декорированную функцию можно вызывать несколько раз, базовый "
"менеджер контекста должен поддерживать использование в нескольких "
"операторах :keyword:`with`. Если это не так, то следует использовать "
"исходную конструкцию с явным оператором :keyword:`!with` внутри функции."

#: ../../library/contextlib.rst:474
msgid ""
"Similar to :class:`ContextDecorator` but only for asynchronous functions."
msgstr ""
"Аналогично :class:`ContextDecorator`, но только для асинхронных функций."

#: ../../library/contextlib.rst:476
msgid "Example of ``AsyncContextDecorator``::"
msgstr "Пример ``AsyncContextDecorator``::"

#: ../../library/contextlib.rst:478
msgid ""
"from asyncio import run\n"
"from contextlib import AsyncContextDecorator\n"
"\n"
"class mycontext(AsyncContextDecorator):\n"
"    async def __aenter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    async def __aexit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"
msgstr ""
"from asyncio import run\n"
"from contextlib import AsyncContextDecorator\n"
"\n"
"class mycontext(AsyncContextDecorator):\n"
"    async def __aenter__(self):\n"
"        print('Starting')\n"
"        return self\n"
"\n"
"    async def __aexit__(self, *exc):\n"
"        print('Finishing')\n"
"        return False"

#: ../../library/contextlib.rst:492
msgid ""
">>> @mycontext()\n"
"... async def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> async def function():\n"
"...    async with mycontext():\n"
"...         print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"
msgstr ""
">>> @mycontext()\n"
"... async def function():\n"
"...     print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing\n"
"\n"
">>> async def function():\n"
"...    async with mycontext():\n"
"...         print('The bit in the middle')\n"
"...\n"
">>> run(function())\n"
"Starting\n"
"The bit in the middle\n"
"Finishing"

#: ../../library/contextlib.rst:515
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"Менеджер контекста, предназначенный для упрощения программного объединения "
"других менеджеров контекста и функций очистки, особенно тех, которые "
"являются необязательными или иным образом управляются входными данными."

#: ../../library/contextlib.rst:519
msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr ""
"Например, набор файлов можно легко обработать в одном операторе with "
"следующим образом:"

#: ../../library/contextlib.rst:522
msgid ""
"with ExitStack() as stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filenames]\n"
"    # All opened files will automatically be closed at the end of\n"
"    # the with statement, even if attempts to open files later\n"
"    # in the list raise an exception"
msgstr ""
"with ExitStack() as stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filenames]\n"
"    # All opened files will automatically be closed at the end of\n"
"    # the with statement, even if attempts to open files later\n"
"    # in the list raise an exception"

#: ../../library/contextlib.rst:528
msgid ""
"The :meth:`~object.__enter__` method returns the :class:`ExitStack` "
"instance, and performs no additional operations."
msgstr ""
"Метод :meth:`~object.__enter__` возвращает экземпляр :class:`ExitStack` и не "
"выполняет никаких дополнительных операций."

#: ../../library/contextlib.rst:531
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"Каждый экземпляр поддерживает стек зарегистрированных обратных вызовов, "
"которые вызываются в обратном порядке при закрытии экземпляра (явно или "
"неявно в конце оператора :keyword:`with`). Обратите внимание, что обратные "
"вызовы *не* вызываются неявно, когда экземпляр контекстного стека "
"подвергается сборке мусора."

#: ../../library/contextlib.rst:536
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""
"Эта модель стека используется для корректной обработки контекстных "
"менеджеров, которые получают свои ресурсы с помощью метода ``__init__`` "
"(например, файловые объекты)."

#: ../../library/contextlib.rst:540
msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"Поскольку зарегистрированные обратные вызовы вызываются в порядке, обратном "
"регистрации, в конечном итоге это ведет себя так, как если бы с "
"зарегистрированным набором обратных вызовов использовалось несколько "
"вложенных операторов :keyword:`with`. Это распространяется даже на обработку "
"исключений: если внутренний обратный вызов подавляет или заменяет "
"исключение, то внешним обратным вызовам будут переданы аргументы на основе "
"этого обновленного состояния."

#: ../../library/contextlib.rst:547
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"Это API относительно низкого уровня, который заботится о деталях правильного "
"развертывания стека обратных вызовов выхода. Он обеспечивает подходящую "
"основу для менеджеров контекста более высокого уровня, которые манипулируют "
"стеком выхода способами, специфичными для приложения."

#: ../../library/contextlib.rst:556
msgid ""
"Enters a new context manager and adds its :meth:`~object.__exit__` method to "
"the callback stack. The return value is the result of the context manager's "
"own :meth:`~object.__enter__` method."
msgstr ""
"Вводит новый менеджер контекста и добавляет его метод :meth:`~object."
"__exit__` в стек обратного вызова. Возвращаемое значение является "
"результатом работы собственного метода :meth:`~object.__enter__` "
"контекстного менеджера."

#: ../../library/contextlib.rst:560
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""
"Эти менеджеры контекста могут подавлять исключения так же, как обычно, если "
"они используются непосредственно как часть оператора :keyword:`with`."

#: ../../library/contextlib.rst:563
msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not a "
"context manager."
msgstr ""
"Вызывает :exc:`TypeError` вместо :exc:`AttributeError`, если *cm* не "
"является менеджером контекста."

#: ../../library/contextlib.rst:569
msgid ""
"Adds a context manager's :meth:`~object.__exit__` method to the callback "
"stack."
msgstr ""
"Добавляет метод :meth:`~object.__exit__` контекстного менеджера в стек "
"обратного вызова."

#: ../../library/contextlib.rst:571
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`~object.__enter__` implementation with a context manager's own :"
"meth:`~object.__exit__` method."
msgstr ""
"Поскольку ``__enter__`` *не* вызывается, этот метод можно использовать для "
"покрытия части реализации :meth:`~object.__enter__` собственным методом :"
"meth:`~object.__exit__` контекстного менеджера."

#: ../../library/contextlib.rst:575
msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`~object."
"__exit__` method and adds it directly to the callback stack."
msgstr ""
"Если передан объект, который не является менеджером контекста, этот метод "
"предполагает, что это обратный вызов с той же сигнатурой, что и метод :meth:"
"`~object.__exit__` контекстного менеджера, и добавляет его непосредственно в "
"стек обратного вызова."

#: ../../library/contextlib.rst:579
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`~object.__exit__` methods can."
msgstr ""
"Возвращая истинные значения, эти обратные вызовы могут подавлять исключения "
"так же, как это могут делать методы контекстного менеджера :meth:`~object."
"__exit__`."

#: ../../library/contextlib.rst:582
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""
"Переданный объект возвращается из функции, что позволяет использовать этот "
"метод в качестве декоратора функции."

#: ../../library/contextlib.rst:587
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr ""
"Принимает произвольную функцию обратного вызова и аргументы и добавляет ее в "
"стек обратного вызова."

#: ../../library/contextlib.rst:590
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""
"В отличие от других методов, обратные вызовы, добавленные таким образом, не "
"могут подавлять исключения (поскольку им никогда не передаются сведения об "
"исключении)."

#: ../../library/contextlib.rst:593
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""
"Переданный обратный вызов возвращается из функции, что позволяет "
"использовать этот метод в качестве декоратора функции."

#: ../../library/contextlib.rst:598
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"Переносит стек обратного вызова в новый экземпляр :class:`ExitStack` и "
"возвращает его. Эта операция не вызывает никаких обратных вызовов — вместо "
"этого они теперь будут вызываться при закрытии нового стека (явно или неявно "
"в конце оператора :keyword:`with`)."

#: ../../library/contextlib.rst:603
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""
"Например, группу файлов можно открыть как операцию «все или ничего» "
"следующим образом:"

#: ../../library/contextlib.rst:606
msgid ""
"with ExitStack() as stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filenames]\n"
"    # Hold onto the close method, but don't call it yet.\n"
"    close_files = stack.pop_all().close\n"
"    # If opening any file fails, all previously opened files will be\n"
"    # closed automatically. If all files are opened successfully,\n"
"    # they will remain open even after the with statement ends.\n"
"    # close_files() can then be invoked explicitly to close them all."
msgstr ""
"with ExitStack() as stack:\n"
"    files = [stack.enter_context(open(fname)) for fname in filenames]\n"
"    # Hold onto the close method, but don't call it yet.\n"
"    close_files = stack.pop_all().close\n"
"    # If opening any file fails, all previously opened files will be\n"
"    # closed automatically. If all files are opened successfully,\n"
"    # they will remain open even after the with statement ends.\n"
"    # close_files() can then be invoked explicitly to close them all."

#: ../../library/contextlib.rst:617
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""
"Немедленно разворачивает стек обратных вызовов, вызывая обратные вызовы в "
"порядке, обратном регистрации. Для любых зарегистрированных менеджеров "
"контекста и обратных вызовов выхода переданные аргументы будут указывать на "
"отсутствие исключений."

#: ../../library/contextlib.rst:624
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
":ref:`асинхронный контекстный менеджер <async-context-managers>`, "
"аналогичный :class:`ExitStack`, который поддерживает сочетание синхронных и "
"асинхронных контекстных менеджеров, а также имеет сопрограммы для логики "
"очистки."

#: ../../library/contextlib.rst:629
msgid ""
"The :meth:`~ExitStack.close` method is not implemented; :meth:`aclose` must "
"be used instead."
msgstr ""
"Метод :meth:`~ExitStack.close` не реализован; Вместо этого следует "
"использовать :meth:`aclose`."

#: ../../library/contextlib.rst:635
msgid ""
"Similar to :meth:`ExitStack.enter_context` but expects an asynchronous "
"context manager."
msgstr ""
"Аналогично :meth:`ExitStack.enter_context`, но требует асинхронного "
"менеджера контекста."

#: ../../library/contextlib.rst:638
msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not an "
"asynchronous context manager."
msgstr ""
"Вызывает :exc:`TypeError` вместо :exc:`AttributeError`, если *cm* не "
"является асинхронным менеджером контекста."

#: ../../library/contextlib.rst:644
msgid ""
"Similar to :meth:`ExitStack.push` but expects either an asynchronous context "
"manager or a coroutine function."
msgstr ""
"Похож на :meth:`ExitStack.push`, но ожидает либо асинхронного контекстного "
"менеджера, либо сопрограммной функции."

#: ../../library/contextlib.rst:649
msgid "Similar to :meth:`ExitStack.callback` but expects a coroutine function."
msgstr ""
"Аналогично :meth:`ExitStack.callback`, но ожидает сопрограммную функцию."

#: ../../library/contextlib.rst:654
msgid "Similar to :meth:`ExitStack.close` but properly handles awaitables."
msgstr ""
"Похож на :meth:`ExitStack.close`, но правильно обрабатывает ожидаемые "
"объекты."

#: ../../library/contextlib.rst:656
msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr "Продолжая пример для :func:`asynccontextmanager`::"

#: ../../library/contextlib.rst:658
msgid ""
"async with AsyncExitStack() as stack:\n"
"    connections = [await stack.enter_async_context(get_connection())\n"
"        for i in range(5)]\n"
"    # All opened connections will automatically be released at the end of\n"
"    # the async with statement, even if attempts to open a connection\n"
"    # later in the list raise an exception."
msgstr ""
"async with AsyncExitStack() as stack:\n"
"    connections = [await stack.enter_async_context(get_connection())\n"
"        for i in range(5)]\n"
"    # All opened connections will automatically be released at the end of\n"
"    # the async with statement, even if attempts to open a connection\n"
"    # later in the list raise an exception."

#: ../../library/contextlib.rst:668
msgid "Examples and Recipes"
msgstr "Примеры и рецепты"

#: ../../library/contextlib.rst:670
msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""
"В этом разделе описаны некоторые примеры и рецепты эффективного "
"использования инструментов, предоставляемых :mod:`contextlib`."

#: ../../library/contextlib.rst:675
msgid "Supporting a variable number of context managers"
msgstr "Поддержка переменного количества контекстных менеджеров"

#: ../../library/contextlib.rst:677
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
"Основной вариант использования :class:`ExitStack` указан в документации "
"класса: поддержка переменного количества контекстных менеджеров и других "
"операций очистки в одном операторе :keyword:`with`. Вариативность может быть "
"обусловлена ​​количеством необходимых менеджеров контекста, управляемых "
"пользовательским вводом (например, открытием заданной пользователем "
"коллекции файлов), или тем, что некоторые из менеджеров контекста являются "
"необязательными:"

#: ../../library/contextlib.rst:684
msgid ""
"with ExitStack() as stack:\n"
"    for resource in resources:\n"
"        stack.enter_context(resource)\n"
"    if need_special_resource():\n"
"        special = acquire_special_resource()\n"
"        stack.callback(release_special_resource, special)\n"
"    # Perform operations that use the acquired resources"
msgstr ""
"with ExitStack() as stack:\n"
"    for resource in resources:\n"
"        stack.enter_context(resource)\n"
"    if need_special_resource():\n"
"        special = acquire_special_resource()\n"
"        stack.callback(release_special_resource, special)\n"
"    # Perform operations that use the acquired resources"

#: ../../library/contextlib.rst:692
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"Как показано, :class:`ExitStack` также позволяет довольно легко использовать "
"операторы :keyword:`with` для управления произвольными ресурсами, которые "
"изначально не поддерживают протокол управления контекстом."

#: ../../library/contextlib.rst:698
msgid "Catching exceptions from ``__enter__`` methods"
msgstr "Перехват исключений из методов ``__enter__``"

#: ../../library/contextlib.rst:700
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"Иногда желательно перехватывать исключения из реализации метода "
"``__enter__``, *без* случайного перехвата исключений из тела оператора :"
"keyword:`with` или метода ``__exit__`` контекстного менеджера. Используя :"
"class:`ExitStack`, шаги в протоколе управления контекстом можно немного "
"разделить, чтобы это можно было сделать:"

#: ../../library/contextlib.rst:706
msgid ""
"stack = ExitStack()\n"
"try:\n"
"    x = stack.enter_context(cm)\n"
"except Exception:\n"
"    # handle __enter__ exception\n"
"else:\n"
"    with stack:\n"
"        # Handle normal case"
msgstr ""
"stack = ExitStack()\n"
"try:\n"
"    x = stack.enter_context(cm)\n"
"except Exception:\n"
"    # handle __enter__ exception\n"
"else:\n"
"    with stack:\n"
"        # Handle normal case"

#: ../../library/contextlib.rst:715
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"На самом деле необходимость сделать это, скорее всего, означает, что базовый "
"API должен предоставлять интерфейс прямого управления ресурсами для "
"использования с операторами :keyword:`try`/:keyword:`Exception`/:keyword:"
"`finally`, но не со всеми API. хорошо спроектированы в этом отношении. Если "
"контекстный менеджер является единственным предоставляемым API управления "
"ресурсами, то :class:`ExitStack` может упростить обработку различных "
"ситуаций, которые невозможно обработать непосредственно в операторе :keyword:"
"`with`."

#: ../../library/contextlib.rst:725
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "Очистка в реализации ``__enter__``"

#: ../../library/contextlib.rst:727
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`~object.__enter__` implementation fail."
msgstr ""
"Как отмечено в документации :meth:`ExitStack.push`, этот метод может быть "
"полезен при очистке уже выделенного ресурса, если последующие шаги "
"реализации :meth:`~object.__enter__` завершатся неудачно."

#: ../../library/contextlib.rst:731
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"Вот пример того, как это сделать для контекстного менеджера, который "
"принимает функции получения и освобождения ресурсов, а также дополнительную "
"функцию проверки и сопоставляет их с протоколом управления контекстом:"

#: ../../library/contextlib.rst:735
msgid ""
"from contextlib import contextmanager, AbstractContextManager, ExitStack\n"
"\n"
"class ResourceManager(AbstractContextManager):\n"
"\n"
"    def __init__(self, acquire_resource, release_resource, "
"check_resource_ok=None):\n"
"        self.acquire_resource = acquire_resource\n"
"        self.release_resource = release_resource\n"
"        if check_resource_ok is None:\n"
"            def check_resource_ok(resource):\n"
"                return True\n"
"        self.check_resource_ok = check_resource_ok\n"
"\n"
"    @contextmanager\n"
"    def _cleanup_on_error(self):\n"
"        with ExitStack() as stack:\n"
"            stack.push(self)\n"
"            yield\n"
"            # The validation check passed and didn't raise an exception\n"
"            # Accordingly, we want to keep the resource, and pass it\n"
"            # back to our caller\n"
"            stack.pop_all()\n"
"\n"
"    def __enter__(self):\n"
"        resource = self.acquire_resource()\n"
"        with self._cleanup_on_error():\n"
"            if not self.check_resource_ok(resource):\n"
"                msg = \"Failed validation for {!r}\"\n"
"                raise RuntimeError(msg.format(resource))\n"
"        return resource\n"
"\n"
"    def __exit__(self, *exc_details):\n"
"        # We don't need to duplicate any of our resource release logic\n"
"        self.release_resource()"
msgstr ""
"from contextlib import contextmanager, AbstractContextManager, ExitStack\n"
"\n"
"class ResourceManager(AbstractContextManager):\n"
"\n"
"    def __init__(self, acquire_resource, release_resource, "
"check_resource_ok=None):\n"
"        self.acquire_resource = acquire_resource\n"
"        self.release_resource = release_resource\n"
"        if check_resource_ok is None:\n"
"            def check_resource_ok(resource):\n"
"                return True\n"
"        self.check_resource_ok = check_resource_ok\n"
"\n"
"    @contextmanager\n"
"    def _cleanup_on_error(self):\n"
"        with ExitStack() as stack:\n"
"            stack.push(self)\n"
"            yield\n"
"            # The validation check passed and didn't raise an exception\n"
"            # Accordingly, we want to keep the resource, and pass it\n"
"            # back to our caller\n"
"            stack.pop_all()\n"
"\n"
"    def __enter__(self):\n"
"        resource = self.acquire_resource()\n"
"        with self._cleanup_on_error():\n"
"            if not self.check_resource_ok(resource):\n"
"                msg = \"Failed validation for {!r}\"\n"
"                raise RuntimeError(msg.format(resource))\n"
"        return resource\n"
"\n"
"    def __exit__(self, *exc_details):\n"
"        # We don't need to duplicate any of our resource release logic\n"
"        self.release_resource()"

#: ../../library/contextlib.rst:771
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "Замена любого использования переменных ``try-finally`` и flag."

#: ../../library/contextlib.rst:773
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"Шаблон, который вы иногда увидите, представляет собой оператор try-finally с "
"переменной-флагом, указывающей, должно ли выполняться тело "
"предложенияfinally. В своей простейшей форме (которую уже невозможно "
"обработать, просто используя вместо этого предложение «кроме»), это выглядит "
"примерно так:"

#: ../../library/contextlib.rst:778
msgid ""
"cleanup_needed = True\n"
"try:\n"
"    result = perform_operation()\n"
"    if result:\n"
"        cleanup_needed = False\n"
"finally:\n"
"    if cleanup_needed:\n"
"        cleanup_resources()"
msgstr ""
"cleanup_needed = True\n"
"try:\n"
"    result = perform_operation()\n"
"    if result:\n"
"        cleanup_needed = False\n"
"finally:\n"
"    if cleanup_needed:\n"
"        cleanup_resources()"

#: ../../library/contextlib.rst:787
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"Как и в случае с любым кодом, основанным на операторе ``try``, это может "
"вызвать проблемы при разработке и проверке, поскольку код установки и код "
"очистки могут оказаться разделенными фрагментами кода произвольной длины."

#: ../../library/contextlib.rst:791
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` позволяет вместо этого зарегистрировать обратный вызов "
"для выполнения в конце оператора ``with``, а затем позже решить пропустить "
"выполнение этого обратного вызова::"

#: ../../library/contextlib.rst:795
msgid ""
"from contextlib import ExitStack\n"
"\n"
"with ExitStack() as stack:\n"
"    stack.callback(cleanup_resources)\n"
"    result = perform_operation()\n"
"    if result:\n"
"        stack.pop_all()"
msgstr ""
"from contextlib import ExitStack\n"
"\n"
"with ExitStack() as stack:\n"
"    stack.callback(cleanup_resources)\n"
"    result = perform_operation()\n"
"    if result:\n"
"        stack.pop_all()"

#: ../../library/contextlib.rst:803
msgid ""
"This allows the intended cleanup behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""
"Это позволяет заранее указать предполагаемое поведение очистки, не требуя "
"отдельной переменной-флага."

#: ../../library/contextlib.rst:806
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""
"Если конкретное приложение часто использует этот шаблон, его можно еще "
"упростить с помощью небольшого вспомогательного класса:"

#: ../../library/contextlib.rst:809
msgid ""
"from contextlib import ExitStack\n"
"\n"
"class Callback(ExitStack):\n"
"    def __init__(self, callback, /, *args, **kwds):\n"
"        super().__init__()\n"
"        self.callback(callback, *args, **kwds)\n"
"\n"
"    def cancel(self):\n"
"        self.pop_all()\n"
"\n"
"with Callback(cleanup_resources) as cb:\n"
"    result = perform_operation()\n"
"    if result:\n"
"        cb.cancel()"
msgstr ""
"from contextlib import ExitStack\n"
"\n"
"class Callback(ExitStack):\n"
"    def __init__(self, callback, /, *args, **kwds):\n"
"        super().__init__()\n"
"        self.callback(callback, *args, **kwds)\n"
"\n"
"    def cancel(self):\n"
"        self.pop_all()\n"
"\n"
"with Callback(cleanup_resources) as cb:\n"
"    result = perform_operation()\n"
"    if result:\n"
"        cb.cancel()"

#: ../../library/contextlib.rst:824
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"Если очистка ресурса еще не объединена в отдельную функцию, все равно можно "
"использовать форму декоратора :meth:`ExitStack.callback`, чтобы заранее "
"объявить очистку ресурса::"

#: ../../library/contextlib.rst:829
msgid ""
"from contextlib import ExitStack\n"
"\n"
"with ExitStack() as stack:\n"
"    @stack.callback\n"
"    def cleanup_resources():\n"
"        ...\n"
"    result = perform_operation()\n"
"    if result:\n"
"        stack.pop_all()"
msgstr ""
"from contextlib import ExitStack\n"
"\n"
"with ExitStack() as stack:\n"
"    @stack.callback\n"
"    def cleanup_resources():\n"
"        ...\n"
"    result = perform_operation()\n"
"    if result:\n"
"        stack.pop_all()"

#: ../../library/contextlib.rst:839
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""
"Из-за особенностей работы протокола декоратора объявленная таким образом "
"функция обратного вызова не может принимать никаких параметров. Вместо этого "
"к любым освобождаемым ресурсам необходимо обращаться как к переменным "
"закрытия."

#: ../../library/contextlib.rst:845
msgid "Using a context manager as a function decorator"
msgstr "Использование контекстного менеджера в качестве декоратора функции"

#: ../../library/contextlib.rst:847
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` позволяет использовать контекстный менеджер как в "
"обычном операторе ``with``, так и в качестве декоратора функции."

#: ../../library/contextlib.rst:850
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"Например, иногда полезно обернуть функции или группы операторов логгером, "
"который может отслеживать время входа и время выхода. Вместо того, чтобы "
"писать для задачи декоратор функции и менеджер контекста, наследование от :"
"class:`ContextDecorator` предоставляет обе возможности в одном определении::"

#: ../../library/contextlib.rst:856
msgid ""
"from contextlib import ContextDecorator\n"
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class track_entry_and_exit(ContextDecorator):\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def __enter__(self):\n"
"        logging.info('Entering: %s', self.name)\n"
"\n"
"    def __exit__(self, exc_type, exc, exc_tb):\n"
"        logging.info('Exiting: %s', self.name)"
msgstr ""
"from contextlib import ContextDecorator\n"
"import logging\n"
"\n"
"logging.basicConfig(level=logging.INFO)\n"
"\n"
"class track_entry_and_exit(ContextDecorator):\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def __enter__(self):\n"
"        logging.info('Entering: %s', self.name)\n"
"\n"
"    def __exit__(self, exc_type, exc, exc_tb):\n"
"        logging.info('Exiting: %s', self.name)"

#: ../../library/contextlib.rst:871
msgid "Instances of this class can be used as both a context manager::"
msgstr ""
"Экземпляры этого класса можно использовать как в качестве менеджера "
"контекста::"

#: ../../library/contextlib.rst:873
msgid ""
"with track_entry_and_exit('widget loader'):\n"
"    print('Some time consuming activity goes here')\n"
"    load_widget()"
msgstr ""
"with track_entry_and_exit('widget loader'):\n"
"    print('Some time consuming activity goes here')\n"
"    load_widget()"

#: ../../library/contextlib.rst:877
msgid "And also as a function decorator::"
msgstr "А также в качестве декоратора функции::"

#: ../../library/contextlib.rst:879
msgid ""
"@track_entry_and_exit('widget loader')\n"
"def activity():\n"
"    print('Some time consuming activity goes here')\n"
"    load_widget()"
msgstr ""
"@track_entry_and_exit('widget loader')\n"
"def activity():\n"
"    print('Some time consuming activity goes here')\n"
"    load_widget()"

#: ../../library/contextlib.rst:884
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`~object.__enter__`. If that value is needed, then it is still necessary to "
"use an explicit ``with`` statement."
msgstr ""
"Обратите внимание, что при использовании контекстных менеджеров в качестве "
"декораторов функций существует одно дополнительное ограничение: невозможно "
"получить доступ к возвращаемому значению :meth:`~object.__enter__`. Если это "
"значение необходимо, то все равно необходимо использовать явный оператор "
"``with``."

#: ../../library/contextlib.rst:891
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Оператор \"with\""

#: ../../library/contextlib.rst:892
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Спецификация, предыстория и примеры оператора Python :keyword:`with`."

#: ../../library/contextlib.rst:898
msgid "Single use, reusable and reentrant context managers"
msgstr "Одноразовые, многоразовые и реентерабельные контекстные менеджеры"

#: ../../library/contextlib.rst:900
msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"Большинство контекстных менеджеров написаны таким образом, что их можно "
"эффективно использовать в операторе :keyword:`with` только один раз. Эти "
"одноразовые контекстные менеджеры необходимо создавать заново каждый раз, "
"когда они используются. Попытка использовать их во второй раз вызовет "
"исключение или иным образом не будет работать правильно."

#: ../../library/contextlib.rst:906
msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""
"Это общее ограничение означает, что обычно рекомендуется создавать менеджеры "
"контекста непосредственно в заголовке оператора :keyword:`with`, где они "
"используются (как показано во всех примерах использования выше)."

#: ../../library/contextlib.rst:910
msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"Файлы являются примером эффективных одноразовых контекстных менеджеров, "
"поскольку первый оператор :keyword:`with` закроет файл, предотвращая любые "
"дальнейшие операции ввода-вывода с использованием этого файлового объекта."

#: ../../library/contextlib.rst:914
msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
"Менеджеры контекста, созданные с помощью :func:`contextmanager`, также "
"являются контекстными менеджерами одноразового использования и будут "
"жаловаться на то, что базовый генератор не сработает, если будет предпринята "
"попытка использовать их во второй раз:"

#: ../../library/contextlib.rst:918
msgid ""
">>> from contextlib import contextmanager\n"
">>> @contextmanager\n"
"... def singleuse():\n"
"...     print(\"Before\")\n"
"...     yield\n"
"...     print(\"After\")\n"
"...\n"
">>> cm = singleuse()\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Before\n"
"After\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Traceback (most recent call last):\n"
"    ...\n"
"RuntimeError: generator didn't yield"
msgstr ""
">>> from contextlib import contextmanager\n"
">>> @contextmanager\n"
"... def singleuse():\n"
"...     print(\"Before\")\n"
"...     yield\n"
"...     print(\"After\")\n"
"...\n"
">>> cm = singleuse()\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Before\n"
"After\n"
">>> with cm:\n"
"...     pass\n"
"...\n"
"Traceback (most recent call last):\n"
"    ...\n"
"RuntimeError: generator didn't yield"

#: ../../library/contextlib.rst:942
msgid "Reentrant context managers"
msgstr "Реентерабельные контекстные менеджеры"

#: ../../library/contextlib.rst:944
msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"Более сложные менеджеры контекста могут быть «реентерабельными». Эти "
"менеджеры контекста могут использоваться не только в нескольких операторах :"
"keyword:`with`, но также могут использоваться *внутри* оператора :keyword:`!"
"with`, который уже использует тот же менеджер контекста."

#: ../../library/contextlib.rst:949
msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress`, :func:`redirect_stdout`, and :func:`chdir`. Here's a "
"very simple example of reentrant use::"
msgstr ""
":class:`threading.RLock` является примером реентерабельного менеджера "
"контекста, как и :func:`suppress`, :func:`redirect_stdout` и :func:`chdir`. "
"Вот очень простой пример реентерабельного использования:"

#: ../../library/contextlib.rst:953
msgid ""
">>> from contextlib import redirect_stdout\n"
">>> from io import StringIO\n"
">>> stream = StringIO()\n"
">>> write_to_stream = redirect_stdout(stream)\n"
">>> with write_to_stream:\n"
"...     print(\"This is written to the stream rather than stdout\")\n"
"...     with write_to_stream:\n"
"...         print(\"This is also written to the stream\")\n"
"...\n"
">>> print(\"This is written directly to stdout\")\n"
"This is written directly to stdout\n"
">>> print(stream.getvalue())\n"
"This is written to the stream rather than stdout\n"
"This is also written to the stream"
msgstr ""
">>> from contextlib import redirect_stdout\n"
">>> from io import StringIO\n"
">>> stream = StringIO()\n"
">>> write_to_stream = redirect_stdout(stream)\n"
">>> with write_to_stream:\n"
"...     print(\"This is written to the stream rather than stdout\")\n"
"...     with write_to_stream:\n"
"...         print(\"This is also written to the stream\")\n"
"...\n"
">>> print(\"This is written directly to stdout\")\n"
"This is written directly to stdout\n"
">>> print(stream.getvalue())\n"
"This is written to the stream rather than stdout\n"
"This is also written to the stream"

#: ../../library/contextlib.rst:968
msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""
"Реальные примеры повторного входа, скорее всего, будут включать несколько "
"функций, вызывающих друг друга, и, следовательно, будут намного сложнее, чем "
"этот пример."

#: ../../library/contextlib.rst:972
msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"Также обратите внимание, что реентерабельность — это *не* то же самое, что "
"потокобезопасность. :func:`redirect_stdout`, например, определенно не "
"является потокобезопасным, поскольку он вносит глобальную модификацию "
"состояния системы, привязывая :data:`sys.stdout` к другому потоку."

#: ../../library/contextlib.rst:981
msgid "Reusable context managers"
msgstr "Многоразоваые контекстные менеджеры"

#: ../../library/contextlib.rst:983
msgid ""
"Distinct from both single use and reentrant context managers are "
"\"reusable\" context managers (or, to be completely explicit, \"reusable, "
"but not reentrant\" context managers, since reentrant context managers are "
"also reusable). These context managers support being used multiple times, "
"but will fail (or otherwise not work correctly) if the specific context "
"manager instance has already been used in a containing with statement."
msgstr ""
"В отличие от одноразовых и реентерабельных контекстных менеджеров есть "
"«многоразовые» контекстные менеджеры (или, если быть совершенно ясным, "
"«многоразовые, но не реентерабельные» контекстные менеджеры, поскольку "
"реентерабельные контекстные менеджеры также могут использоваться повторно). "
"Эти менеджеры контекста поддерживают многократное использование, но не "
"сработают (или иным образом не будут работать правильно), если конкретный "
"экземпляр менеджера контекста уже использовался в операторе, содержащем with."

#: ../../library/contextlib.rst:990
msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` — это пример многоразового, но не реентерабельного "
"контекстного менеджера (для реентерабельной блокировки вместо этого "
"необходимо использовать :class:`threading.RLock`)."

#: ../../library/contextlib.rst:994
msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"Другим примером многоразового, но не реентерабельного контекстного менеджера "
"является :class:`ExitStack`, поскольку он вызывает *все* зарегистрированные "
"в данный момент обратные вызовы при выходе из любого оператора with, "
"независимо от того, где эти обратные вызовы были добавлены::"

#: ../../library/contextlib.rst:999
msgid ""
">>> from contextlib import ExitStack\n"
">>> stack = ExitStack()\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from first context\")\n"
"...     print(\"Leaving first context\")\n"
"...\n"
"Leaving first context\n"
"Callback: from first context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from second context\")\n"
"...     print(\"Leaving second context\")\n"
"...\n"
"Leaving second context\n"
"Callback: from second context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from outer context\")\n"
"...     with stack:\n"
"...         stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Callback: from outer context\n"
"Leaving outer context"
msgstr ""
">>> from contextlib import ExitStack\n"
">>> stack = ExitStack()\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from first context\")\n"
"...     print(\"Leaving first context\")\n"
"...\n"
"Leaving first context\n"
"Callback: from first context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from second context\")\n"
"...     print(\"Leaving second context\")\n"
"...\n"
"Leaving second context\n"
"Callback: from second context\n"
">>> with stack:\n"
"...     stack.callback(print, \"Callback: from outer context\")\n"
"...     with stack:\n"
"...         stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Callback: from outer context\n"
"Leaving outer context"

#: ../../library/contextlib.rst:1025
msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"Как показывают выходные данные примера, повторное использование одного "
"объекта стека в нескольких операторах with работает правильно, но попытка "
"вложить их приведет к очистке стека в конце самого внутреннего оператора "
"with, что вряд ли будет желательным поведением."

#: ../../library/contextlib.rst:1030
msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
"Использование отдельных экземпляров :class:`ExitStack` вместо повторного "
"использования одного экземпляра позволяет избежать этой проблемы:"

#: ../../library/contextlib.rst:1033
msgid ""
">>> from contextlib import ExitStack\n"
">>> with ExitStack() as outer_stack:\n"
"...     outer_stack.callback(print, \"Callback: from outer context\")\n"
"...     with ExitStack() as inner_stack:\n"
"...         inner_stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Leaving outer context\n"
"Callback: from outer context"
msgstr ""
">>> from contextlib import ExitStack\n"
">>> with ExitStack() as outer_stack:\n"
"...     outer_stack.callback(print, \"Callback: from outer context\")\n"
"...     with ExitStack() as inner_stack:\n"
"...         inner_stack.callback(print, \"Callback: from inner context\")\n"
"...         print(\"Leaving inner context\")\n"
"...     print(\"Leaving outer context\")\n"
"...\n"
"Leaving inner context\n"
"Callback: from inner context\n"
"Leaving outer context\n"
"Callback: from outer context"
