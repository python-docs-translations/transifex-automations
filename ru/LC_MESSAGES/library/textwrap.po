# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 14:49+0000\n"
"PO-Revision-Date: 2024-05-11 00:33+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/textwrap.rst:2
msgid ":mod:`!textwrap` --- Text wrapping and filling"
msgstr ":mod:`!textwrap` --- Перенос и заполнение текста"

#: ../../library/textwrap.rst:10
msgid "**Source code:** :source:`Lib/textwrap.py`"
msgstr "**Исходный код:** :source:`Lib/textwrap.py`"

#: ../../library/textwrap.rst:14
msgid ""
"The :mod:`textwrap` module provides some convenience functions, as well as :"
"class:`TextWrapper`, the class that does all the work. If you're just "
"wrapping or filling one or two text strings, the convenience functions "
"should be good enough; otherwise, you should use an instance of :class:"
"`TextWrapper` for efficiency."
msgstr ""
"Модуль :mod:`textwrap` предоставляет некоторые удобные функции, а также :"
"class:`TextWrapper`, класс, который выполняет всю работу. Если вы просто "
"переносите или заполняете одну или две текстовые строки, удобных функций "
"должно быть достаточно; в противном случае для повышения эффективности вам "
"следует использовать экземпляр :class:`TextWrapper`."

#: ../../library/textwrap.rst:27
msgid ""
"Wraps the single paragraph in *text* (a string) so every line is at most "
"*width* characters long.  Returns a list of output lines, without final "
"newlines."
msgstr ""
"Обертывает один абзац в *текст* (строку), поэтому длина каждой строки не "
"превышает *ширину* символов. Возвращает список выходных строк без последних "
"символов новой строки."

#: ../../library/textwrap.rst:31
msgid ""
"Optional keyword arguments correspond to the instance attributes of :class:"
"`TextWrapper`, documented below."
msgstr ""
"Необязательные аргументы ключевого слова соответствуют атрибутам экземпляра :"
"class:`TextWrapper`, описанным ниже."

#: ../../library/textwrap.rst:34
msgid ""
"See the :meth:`TextWrapper.wrap` method for additional details on how :func:"
"`wrap` behaves."
msgstr ""
"Дополнительную информацию о том, как ведет себя :func:`wrap`, смотрите в "
"методе :meth:`TextWrapper.wrap`."

#: ../../library/textwrap.rst:45
msgid ""
"Wraps the single paragraph in *text*, and returns a single string containing "
"the wrapped paragraph.  :func:`fill` is shorthand for  ::"
msgstr ""
"Обертывает один абзац в *текст* и возвращает одну строку, содержащую "
"заключенный абзац. :func:`fill` — это сокращение от ::"

#: ../../library/textwrap.rst:48
msgid "\"\\n\".join(wrap(text, ...))"
msgstr "\"\\n\".join(wrap(text, ...))"

#: ../../library/textwrap.rst:50
msgid ""
"In particular, :func:`fill` accepts exactly the same keyword arguments as :"
"func:`wrap`."
msgstr ""
"В частности, :func:`fill` принимает точно такие же ключевые аргументы, что "
"и :func:`wrap`."

#: ../../library/textwrap.rst:58
msgid "Collapse and truncate the given *text* to fit in the given *width*."
msgstr ""
"Свернуть и обрезать заданный *текст*, чтобы он соответствовал заданной "
"*ширине*."

#: ../../library/textwrap.rst:60
msgid ""
"First the whitespace in *text* is collapsed (all whitespace is replaced by "
"single spaces).  If the result fits in the *width*, it is returned. "
"Otherwise, enough words are dropped from the end so that the remaining words "
"plus the *placeholder* fit within *width*::"
msgstr ""
"Сначала пробелы в *text* сворачиваются (все пробелы заменяются одиночными "
"пробелами). Если результат соответствует *ширине*, он возвращается. В "
"противном случае с конца удаляется достаточно слов, чтобы оставшиеся слова "
"плюс *заполнитель* поместились в пределах *ширины*::"

#: ../../library/textwrap.rst:65
msgid ""
">>> textwrap.shorten(\"Hello  world!\", width=12)\n"
"'Hello world!'\n"
">>> textwrap.shorten(\"Hello  world!\", width=11)\n"
"'Hello [...]'\n"
">>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\")\n"
"'Hello...'"
msgstr ""
">>> textwrap.shorten(\"Hello  world!\", width=12)\n"
"'Hello world!'\n"
">>> textwrap.shorten(\"Hello  world!\", width=11)\n"
"'Hello [...]'\n"
">>> textwrap.shorten(\"Hello world\", width=10, placeholder=\"...\")\n"
"'Hello...'"

#: ../../library/textwrap.rst:72
msgid ""
"Optional keyword arguments correspond to the instance attributes of :class:"
"`TextWrapper`, documented below.  Note that the whitespace is collapsed "
"before the text is passed to the :class:`TextWrapper` :meth:`fill` function, "
"so changing the value of :attr:`.tabsize`, :attr:`.expand_tabs`, :attr:`."
"drop_whitespace`, and :attr:`.replace_whitespace` will have no effect."
msgstr ""
"Необязательные аргументы ключевого слова соответствуют атрибутам экземпляра :"
"class:`TextWrapper`, описанным ниже. Обратите внимание, что пробелы "
"сворачиваются перед передачей текста в функцию :class:`TextWrapper` :meth:"
"`fill`, поэтому изменяется значение :attr:`.tabsize`, :attr:`.expand_tabs`, :"
"attr. :`.drop_whitespace` и :attr:`.replace_whitespace` не будут иметь "
"никакого эффекта."

#: ../../library/textwrap.rst:82
msgid "Remove any common leading whitespace from every line in *text*."
msgstr "Удалите все общие начальные пробелы из каждой строки *text*."

#: ../../library/textwrap.rst:84
msgid ""
"This can be used to make triple-quoted strings line up with the left edge of "
"the display, while still presenting them in the source code in indented form."
msgstr ""
"Это можно использовать для выравнивания строк в тройных кавычках по левому "
"краю экрана, при этом они по-прежнему будут представлены в исходном коде в "
"форме с отступом."

#: ../../library/textwrap.rst:87
msgid ""
"Note that tabs and spaces are both treated as whitespace, but they are not "
"equal: the lines ``\"  hello\"`` and ``\"\\thello\"`` are considered to have "
"no common leading whitespace."
msgstr ""
"Обратите внимание, что табуляция и пробелы рассматриваются как пробелы, но "
"они не равны: строки ``\" hello\"`` и ``\"\\thello\"`` считаются не имеющими "
"общего начального пробела."

#: ../../library/textwrap.rst:91
msgid ""
"Lines containing only whitespace are ignored in the input and normalized to "
"a single newline character in the output."
msgstr ""
"Строки, содержащие только пробелы, игнорируются на входе и нормализуются до "
"одного символа новой строки на выходе."

#: ../../library/textwrap.rst:94 ../../library/textwrap.rst:115
msgid "For example::"
msgstr "Например::"

#: ../../library/textwrap.rst:96
msgid ""
"def test():\n"
"    # end first line with \\ to avoid the empty line!\n"
"    s = '''\\\n"
"    hello\n"
"      world\n"
"    '''\n"
"    print(repr(s))          # prints '    hello\\n      world\\n    '\n"
"    print(repr(dedent(s)))  # prints 'hello\\n  world\\n'"
msgstr ""
"def test():\n"
"    # end first line with \\ to avoid the empty line!\n"
"    s = '''\\\n"
"    hello\n"
"      world\n"
"    '''\n"
"    print(repr(s))          # prints '    hello\\n      world\\n    '\n"
"    print(repr(dedent(s)))  # prints 'hello\\n  world\\n'"

#: ../../library/textwrap.rst:108
msgid "Add *prefix* to the beginning of selected lines in *text*."
msgstr "Добавьте *префикс* в начало выбранных строк в *тексте*."

#: ../../library/textwrap.rst:110
msgid "Lines are separated by calling ``text.splitlines(True)``."
msgstr "Строки разделяются вызовом ``text.splitlines(True)``."

#: ../../library/textwrap.rst:112
msgid ""
"By default, *prefix* is added to all lines that do not consist solely of "
"whitespace (including any line endings)."
msgstr ""
"По умолчанию *префикс* добавляется ко всем строкам, которые не состоят "
"исключительно из пробелов (включая окончания строк)."

#: ../../library/textwrap.rst:117
msgid ""
">>> s = 'hello\\n\\n \\nworld'\n"
">>> indent(s, '  ')\n"
"'  hello\\n\\n \\n  world'"
msgstr ""
">>> s = 'hello\\n\\n \\nworld'\n"
">>> indent(s, '  ')\n"
"'  hello\\n\\n \\n  world'"

#: ../../library/textwrap.rst:121
msgid ""
"The optional *predicate* argument can be used to control which lines are "
"indented. For example, it is easy to add *prefix* to even empty and "
"whitespace-only lines::"
msgstr ""
"Необязательный аргумент *predicate* можно использовать для управления "
"отступом строк. Например, легко добавить *префикс* даже к пустым строкам, "
"содержащим только пробелы::"

#: ../../library/textwrap.rst:125
msgid ""
">>> print(indent(s, '+ ', lambda line: True))\n"
"+ hello\n"
"+\n"
"+\n"
"+ world"
msgstr ""
">>> print(indent(s, '+ ', lambda line: True))\n"
"+ hello\n"
"+\n"
"+\n"
"+ world"

#: ../../library/textwrap.rst:134
msgid ""
":func:`wrap`, :func:`fill` and :func:`shorten` work by creating a :class:"
"`TextWrapper` instance and calling a single method on it.  That instance is "
"not reused, so for applications that process many text strings using :func:"
"`wrap` and/or :func:`fill`, it may be more efficient to create your own :"
"class:`TextWrapper` object."
msgstr ""
":func:`wrap`, :func:`fill` и :func:`shorten` работают, создавая экземпляр :"
"class:`TextWrapper` и вызывая для него один метод. Этот экземпляр не "
"используется повторно, поэтому для приложений, которые обрабатывают "
"множество текстовых строк с помощью :func:`wrap` и/или :func:`fill`, может "
"оказаться более эффективным создать собственный объект :class:`TextWrapper`."

#: ../../library/textwrap.rst:140
msgid ""
"Text is preferably wrapped on whitespaces and right after the hyphens in "
"hyphenated words; only then will long words be broken if necessary, unless :"
"attr:`TextWrapper.break_long_words` is set to false."
msgstr ""
"Текст желательно заключать в пробелы и сразу после дефисов в словах, "
"написанных через дефис; только тогда длинные слова будут разбиваться при "
"необходимости, если только для :attr:`TextWrapper.break_long_words` не "
"установлено значение false."

#: ../../library/textwrap.rst:146
msgid ""
"The :class:`TextWrapper` constructor accepts a number of optional keyword "
"arguments.  Each keyword argument corresponds to an instance attribute, so "
"for example ::"
msgstr ""
"Конструктор :class:`TextWrapper` принимает ряд необязательных аргументов-"
"ключевых слов. Каждый аргумент ключевого слова соответствует атрибуту "
"экземпляра, например:::"

#: ../../library/textwrap.rst:150
msgid "wrapper = TextWrapper(initial_indent=\"* \")"
msgstr "wrapper = TextWrapper(initial_indent=\"* \")"

#: ../../library/textwrap.rst:152
msgid "is the same as  ::"
msgstr "то же самое, что:::"

#: ../../library/textwrap.rst:154
msgid ""
"wrapper = TextWrapper()\n"
"wrapper.initial_indent = \"* \""
msgstr ""
"wrapper = TextWrapper()\n"
"wrapper.initial_indent = \"* \""

#: ../../library/textwrap.rst:157
msgid ""
"You can reuse the same :class:`TextWrapper` object many times, and you can "
"change any of its options through direct assignment to instance attributes "
"between uses."
msgstr ""
"Вы можете повторно использовать один и тот же объект :class:`TextWrapper` "
"много раз и можете изменять любые его параметры путем прямого присвоения "
"атрибутам экземпляра между использованиями."

#: ../../library/textwrap.rst:161
msgid ""
"The :class:`TextWrapper` instance attributes (and keyword arguments to the "
"constructor) are as follows:"
msgstr ""
"Атрибуты экземпляра :class:`TextWrapper` (и ключевые аргументы конструктора) "
"следующие:"

#: ../../library/textwrap.rst:167
msgid ""
"(default: ``70``) The maximum length of wrapped lines.  As long as there are "
"no individual words in the input text longer than :attr:`width`, :class:"
"`TextWrapper` guarantees that no output line will be longer than :attr:"
"`width` characters."
msgstr ""
"(по умолчанию: ``70``) Максимальная длина переносимых строк. Пока во входном "
"тексте нет отдельных слов длиной более :attr:`width`, :class:`TextWrapper` "
"гарантирует, что ни одна выходная строка не будет длиннее символов :attr:"
"`width`."

#: ../../library/textwrap.rst:175
msgid ""
"(default: ``True``) If true, then all tab characters in *text* will be "
"expanded to spaces using the :meth:`~str.expandtabs` method of *text*."
msgstr ""
"(по умолчанию: ``True``) Если true, то все символы табуляции в *text* будут "
"расширены до пробелов с использованием метода :meth:`~str.expandtabs` *text*."

#: ../../library/textwrap.rst:181
msgid ""
"(default: ``8``) If :attr:`expand_tabs` is true, then all tab characters in "
"*text* will be expanded to zero or more spaces, depending on the current "
"column and the given tab size."
msgstr ""
"(по умолчанию: ``8``) Если :attr:`expand_tabs` имеет значение true, то все "
"символы табуляции в *text* будут расширены до нуля или более пробелов, в "
"зависимости от текущего столбца и заданного размера табуляции."

#: ../../library/textwrap.rst:190
msgid ""
"(default: ``True``) If true, after tab expansion but before wrapping, the :"
"meth:`wrap` method will replace each whitespace character with a single "
"space.  The whitespace characters replaced are as follows: tab, newline, "
"vertical tab, formfeed, and carriage return (``'\\t\\n\\v\\f\\r'``)."
msgstr ""
"(по умолчанию: ``True``) Если true, после раскрытия табуляции, но перед "
"переносом, метод :meth:`wrap` заменит каждый пробельный символ одним "
"пробелом. Заменены следующие пробельные символы: табуляция, новая строка, "
"вертикальная табуляция, перевод страницы и возврат каретки "
"(``'\\t\\n\\v\\f\\r'``)."

#: ../../library/textwrap.rst:198
msgid ""
"If :attr:`expand_tabs` is false and :attr:`replace_whitespace` is true, each "
"tab character will be replaced by a single space, which is *not* the same as "
"tab expansion."
msgstr ""
"Если :attr:`expand_tabs` имеет значение false, а :attr:`replace_whitespace` "
"имеет значение true, каждый символ табуляции будет заменен одним пробелом, "
"что *не* совпадает с раскрытием табуляции."

#: ../../library/textwrap.rst:204
msgid ""
"If :attr:`replace_whitespace` is false, newlines may appear in the middle of "
"a line and cause strange output. For this reason, text should be split into "
"paragraphs (using :meth:`str.splitlines` or similar) which are wrapped "
"separately."
msgstr ""
"Если :attr:`replace_whitespace` имеет значение false, символы новой строки "
"могут появиться в середине строки и привести к странному выводу. По этой "
"причине текст следует разбивать на абзацы (используя :meth:`str.splitlines` "
"или аналогичный), которые переносятся отдельно."

#: ../../library/textwrap.rst:212
msgid ""
"(default: ``True``) If true, whitespace at the beginning and ending of every "
"line (after wrapping but before indenting) is dropped. Whitespace at the "
"beginning of the paragraph, however, is not dropped if non-whitespace "
"follows it.  If whitespace being dropped takes up an entire line, the whole "
"line is dropped."
msgstr ""
"(по умолчанию: ``True``) Если true, пробелы в начале и конце каждой строки "
"(после переноса, но перед отступом) удаляются. Однако пробелы в начале "
"абзаца не удаляются, если за ними следуют непробельные символы. Если "
"удаляемые пробелы занимают целую строку, удаляется вся строка."

#: ../../library/textwrap.rst:221
msgid ""
"(default: ``''``) String that will be prepended to the first line of wrapped "
"output.  Counts towards the length of the first line.  The empty string is "
"not indented."
msgstr ""
"(по умолчанию: ``''``) Строка, которая будет добавлена ​​к первой строке "
"обернутого вывода. Учитывается длина первой строки. Пустая строка не имеет "
"отступа."

#: ../../library/textwrap.rst:228
msgid ""
"(default: ``''``) String that will be prepended to all lines of wrapped "
"output except the first.  Counts towards the length of each line except the "
"first."
msgstr ""
"(по умолчанию: ``''``) Строка, которая будет добавляться ко всем строкам "
"обернутого вывода, кроме первой. Учитывается длина каждой строки, кроме "
"первой."

#: ../../library/textwrap.rst:235
msgid ""
"(default: ``False``) If true, :class:`TextWrapper` attempts to detect "
"sentence endings and ensure that sentences are always separated by exactly "
"two spaces.  This is generally desired for text in a monospaced font. "
"However, the sentence detection algorithm is imperfect: it assumes that a "
"sentence ending consists of a lowercase letter followed by one of ``'.'``, "
"``'!'``, or ``'?'``, possibly followed by one of ``'\"'`` or ``\"'\"``, "
"followed by a space.  One problem with this algorithm is that it is unable "
"to detect the difference between \"Dr.\" in ::"
msgstr ""
"(по умолчанию: ``False``) Если true, :class:`TextWrapper` пытается "
"обнаружить окончания предложений и гарантировать, что предложения всегда "
"разделены ровно двумя пробелами. Обычно это желательно для текста, "
"написанного моноширинным шрифтом. Однако алгоритм обнаружения предложений "
"несовершенен: он предполагает, что окончание предложения состоит из строчной "
"буквы, за которой следует одно из символов ``'.'``, ``'!'`` или ``'?'``, "
"возможно за которым следует одно из ``'\"'`` или ``\"'\"``, за которым "
"следует пробел. Одна из проблем этого алгоритма заключается в том, что он не "
"может обнаружить разницу между \"Доктор.\" в ::"

#: ../../library/textwrap.rst:244
msgid "[...] Dr. Frankenstein's monster [...]"
msgstr "[...] Монстр доктора Франкенштейна [...]"

#: ../../library/textwrap.rst:246
msgid "and \"Spot.\" in ::"
msgstr "and \"Spot.\" in ::"

#: ../../library/textwrap.rst:248
msgid "[...] See Spot. See Spot run [...]"
msgstr "[...] См. Спот. См. спотовый забег [...]"

#: ../../library/textwrap.rst:250
msgid ":attr:`fix_sentence_endings` is false by default."
msgstr ":attr:`fix_sentence_endings` по умолчанию имеет значение false."

#: ../../library/textwrap.rst:252
msgid ""
"Since the sentence detection algorithm relies on ``string.lowercase`` for "
"the definition of \"lowercase letter\", and a convention of using two spaces "
"after a period to separate sentences on the same line, it is specific to "
"English-language texts."
msgstr ""
"Поскольку алгоритм обнаружения предложений использует ``string.lowercase`` "
"для определения «строчной буквы» и соглашение об использовании двух пробелов "
"после точки для разделения предложений в одной строке, он специфичен для "
"англоязычных текстов."

#: ../../library/textwrap.rst:260
msgid ""
"(default: ``True``) If true, then words longer than :attr:`width` will be "
"broken in order to ensure that no lines are longer than :attr:`width`.  If "
"it is false, long words will not be broken, and some lines may be longer "
"than :attr:`width`.  (Long words will be put on a line by themselves, in "
"order to minimize the amount by which :attr:`width` is exceeded.)"
msgstr ""
"(по умолчанию: ``True``) Если true, то слова длиннее :attr:`width` будут "
"разбиваться, чтобы гарантировать, что ни одна строка не будет длиннее :attr:"
"`width`. Если оно ложно, длинные слова не будут разбиваться, а некоторые "
"строки могут быть длиннее, чем :attr:`width`. (Длинные слова будут "
"помещаться в одну строку, чтобы минимизировать превышение :attr:`width`.)"

#: ../../library/textwrap.rst:269
msgid ""
"(default: ``True``) If true, wrapping will occur preferably on whitespaces "
"and right after hyphens in compound words, as it is customary in English. If "
"false, only whitespaces will be considered as potentially good places for "
"line breaks, but you need to set :attr:`break_long_words` to false if you "
"want truly insecable words.  Default behaviour in previous versions was to "
"always allow breaking hyphenated words."
msgstr ""
"(по умолчанию: ``True``) Если true, перенос будет происходить "
"предпочтительно по пробелам и сразу после дефисов в составных словах, как "
"это принято в английском языке. Если значение false, только пробелы будут "
"считаться потенциально хорошими местами для разрывов строк, но вам нужно "
"установить для :attr:`break_long_words` значение false, если вы хотите, "
"чтобы слова действительно были неразрывными. Поведение по умолчанию в "
"предыдущих версиях всегда позволяло разбивать слова, написанные через дефис."

#: ../../library/textwrap.rst:279
msgid ""
"(default: ``None``) If not ``None``, then the output will contain at most "
"*max_lines* lines, with *placeholder* appearing at the end of the output."
msgstr ""
"(по умолчанию: ``None``) Если не ``None``, то выходные данные будут "
"содержать не более *max_lines* строк, а в конце вывода появится "
"*placeholder*."

#: ../../library/textwrap.rst:289
msgid ""
"(default: ``' [...]'``) String that will appear at the end of the output "
"text if it has been truncated."
msgstr ""
"(по умолчанию: ``' [...]'``) Строка, которая появится в конце выходного "
"текста, если он был усечен."

#: ../../library/textwrap.rst:295
msgid ""
":class:`TextWrapper` also provides some public methods, analogous to the "
"module-level convenience functions:"
msgstr ""
":class:`TextWrapper` также предоставляет некоторые общедоступные методы, "
"аналогичные удобным функциям уровня модуля:"

#: ../../library/textwrap.rst:300
msgid ""
"Wraps the single paragraph in *text* (a string) so every line is at most :"
"attr:`width` characters long.  All wrapping options are taken from instance "
"attributes of the :class:`TextWrapper` instance.  Returns a list of output "
"lines, without final newlines.  If the wrapped output has no content, the "
"returned list is empty."
msgstr ""
"Обертывает один абзац в *текст* (строку), поэтому длина каждой строки не "
"превышает :attr:`width` символов. Все параметры переноса берутся из "
"атрибутов экземпляра :class:`TextWrapper`. Возвращает список выходных строк "
"без последних символов новой строки. Если обернутый вывод не имеет "
"содержимого, возвращаемый список пуст."

#: ../../library/textwrap.rst:309
msgid ""
"Wraps the single paragraph in *text*, and returns a single string containing "
"the wrapped paragraph."
msgstr ""
"Обертывает один абзац в *текст* и возвращает одну строку, содержащую "
"заключенный абзац."

#: ../../library/textwrap.rst:285
msgid "..."
msgstr "..."

#: ../../library/textwrap.rst:285
msgid "placeholder"
msgstr "placeholder"
