# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ""

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Исходный код:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Этот модуль обеспечивает доступ к средствам шифрования транспортного уровня "
"(часто называемого «Secure Sockets Layer») и одноранговой аутентификации для "
"сетевых сокетов, как на стороне клиента, так и на стороне сервера. Этот "
"модуль использует библиотеку OpenSSL. Он доступен на всех современных "
"системах Unix, Windows, macOS и, возможно, на дополнительных платформах, "
"если на этой платформе установлен OpenSSL."

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 with OpenSSL version "
"1.1.1."
msgstr ""

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"Не используйте этот модуль, не прочитав :ref:`ssl-security`. Это может "
"привести к ложному чувству безопасности, поскольку настройки модуля SSL по "
"умолчанию не обязательно подходят для вашего приложения."

#: ../../library/ssl.rst:37
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"В этом разделе описаны объекты и функции модуля ``ssl``; Для получения более "
"общей информации о TLS, SSL и сертификатах читатель может обратиться к "
"документам в разделе «См. также» внизу."

#: ../../library/ssl.rst:41
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection."
msgstr ""
"Этот модуль предоставляет класс :class:`ssl.SSLSocket`, который является "
"производным от типа :class:`socket.socket` и предоставляет оболочку, "
"подобную сокету, которая также шифрует и расшифровывает данные, проходящие "
"через сокет с помощью SSL. . Он поддерживает дополнительные методы, такие "
"как :meth:`getpeercert`, который получает сертификат другой стороны "
"соединения, и :meth:`cipher`, который получает шифр, используемый для "
"безопасного соединения."

#: ../../library/ssl.rst:48
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"Для более сложных приложений класс :class:`ssl.SSLContext` помогает "
"управлять настройками и сертификатами, которые затем могут быть унаследованы "
"SSL-сокетами, созданными с помощью метода :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:52
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Обновлено для поддержки связи с OpenSSL 1.1.0."

#: ../../library/ssl.rst:57
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 и 1.0.1 устарели и больше не поддерживаются. В будущем "
"для модуля SSL потребуется OpenSSL как минимум 1.0.2 или 1.1.0."

#: ../../library/ssl.rst:63
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""
":pep:`644` реализован. Для модуля SSL требуется OpenSSL 1.1.1 или новее."

#: ../../library/ssl.rst:66
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""
"Использование устаревших констант и функций приводит к появлению "
"предупреждений об устаревании."

#: ../../library/ssl.rst:70
msgid "Functions, Constants, and Exceptions"
msgstr "Функции, константы и исключения"

#: ../../library/ssl.rst:74
msgid "Socket creation"
msgstr "Создание сокетов"

#: ../../library/ssl.rst:76
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` of an :class:`SSLContext` instance to wrap sockets as :class:"
"`SSLSocket` objects. The helper functions :func:`create_default_context` "
"returns a new context with secure default settings. The old :func:"
"`wrap_socket` function is deprecated since it is both inefficient and has no "
"support for server name indication (SNI) and hostname matching."
msgstr ""

#: ../../library/ssl.rst:84
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""
"Пример клиентского сокета с контекстом по умолчанию и двойным стеком IPv4/"
"IPv6:"

#: ../../library/ssl.rst:97
msgid "Client socket example with custom context and IPv4::"
msgstr "Пример клиентского сокета с пользовательским контекстом и IPv4::"

#: ../../library/ssl.rst:109
msgid "Server socket example listening on localhost IPv4::"
msgstr "Пример сокета сервера, прослушивающего локальный хост IPv4::"

#: ../../library/ssl.rst:123
msgid "Context creation"
msgstr "Создание контекста"

#: ../../library/ssl.rst:125
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr "Удобная функция помогает создавать объекты SSLContext для общих целей."

#: ../../library/ssl.rst:130
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Вернуть новый объект :class:`SSLContext` с настройками по умолчанию для "
"данной *цели*. Настройки выбираются модулем :mod:`ssl` и обычно представляют "
"более высокий уровень безопасности, чем при непосредственном вызове "
"конструктора :class:`SSLContext`."

#: ../../library/ssl.rst:135
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* представляют собой дополнительные сертификаты "
"CA, которым можно доверять при проверке сертификата, как в :meth:`SSLContext."
"load_verify_locations`. Если все три имеют значение :const:`None`, эта "
"функция может вместо этого доверять сертификатам ЦС системы по умолчанию."

#: ../../library/ssl.rst:141
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :data:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""

#: ../../library/ssl.rst:150
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"Если поддерживается :attr:`~SSLContext.keylog_filename` и установлена ​​"
"переменная среды :envvar:`SSLKEYLOGFILE`, :func:`create_default_context` "
"включает регистрацию ключей."

#: ../../library/ssl.rst:155
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"Протокол, параметры, шифр и другие настройки могут быть изменены на более "
"строгие значения в любое время без предварительного прекращения поддержки. "
"Значения представляют собой справедливый баланс между совместимостью и "
"безопасностью."

#: ../../library/ssl.rst:159
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Если вашему приложению требуются определенные настройки, вам следует "
"создать :class:`SSLContext` и применить настройки самостоятельно."

#: ../../library/ssl.rst:163
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Если вы обнаружите, что когда некоторые старые клиенты или серверы пытаются "
"подключиться с помощью :class:`SSLContext`, созданного этой функцией, они "
"получают сообщение об ошибке «Несоответствие протокола или набора шифров», "
"возможно, они поддерживают только SSL3.0, который эта функция исключает "
"использование :data:`OP_NO_SSLv3`. SSL3.0 широко считается «полностью "
"сломанным <https://en.wikipedia.org/wiki/POODLE>». Если вы по-прежнему "
"хотите продолжать использовать эту функцию, но по-прежнему разрешаете "
"соединения SSL 3.0, вы можете повторно включить их, используя:"

#: ../../library/ssl.rst:179
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 был исключен из строки шифрования по умолчанию."

#: ../../library/ssl.rst:183
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 был добавлен в строку шифрования по умолчанию."

#: ../../library/ssl.rst:185
msgid "3DES was dropped from the default cipher string."
msgstr "3DES был исключен из строки шифрования по умолчанию."

#: ../../library/ssl.rst:189
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr "Добавлена ​​поддержка регистрации ключей в :envvar:`SSLKEYLOGFILE`."

#: ../../library/ssl.rst:193
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""
"Контекст теперь использует протокол :data:`PROTOCOL_TLS_CLIENT` или :data:"
"`PROTOCOL_TLS_SERVER` вместо общего :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:199
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/ssl.rst:203
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Вызывается, чтобы сигнализировать об ошибке базовой реализации SSL (в "
"настоящее время предоставляемой библиотекой OpenSSL). Это означает некоторую "
"проблему на уровне шифрования и аутентификации более высокого уровня, "
"который накладывается на базовое сетевое соединение. Эта ошибка является "
"подтипом :exc:`OSError`. Код ошибки и сообщение экземпляров :exc:`SSLError` "
"предоставляются библиотекой OpenSSL."

#: ../../library/ssl.rst:210
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` раньше был подтипом :exc:`socket.error`."

#: ../../library/ssl.rst:215
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"Строковая мнемоника, обозначающая субмодуль OpenSSL, в котором произошла "
"ошибка, например SSL, PEM или X509. Диапазон возможных значений зависит от "
"версии OpenSSL."

#: ../../library/ssl.rst:223
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"Строковая мнемоника, обозначающая причину возникновения этой ошибки, "
"например CERTIFICATE_VERIFY_FAILED. Диапазон возможных значений зависит от "
"версии OpenSSL."

#: ../../library/ssl.rst:231
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"Подкласс :exc:`SSLError`, возникающий при попытке чтения или записи, и SSL-"
"соединение было корректно закрыто. Обратите внимание, что это не означает, "
"что базовый транспорт (читай TCP) был закрыт."

#: ../../library/ssl.rst:239
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Подкласс :exc:`SSLError`, вызываемый :ref:`неблокирующим сокетом SSL <ssl-"
"nonblocking>` при попытке чтения или записи данных, но перед запросом "
"необходимо получить больше данных по базовому TCP-транспорту. может быть "
"выполнено."

#: ../../library/ssl.rst:248
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Подкласс :exc:`SSLError`, вызываемый :ref:`неблокирующим сокетом SSL <ssl-"
"nonblocking>` при попытке чтения или записи данных, но перед запросом "
"необходимо отправить больше данных по базовому TCP-транспорту. может быть "
"выполнено."

#: ../../library/ssl.rst:257
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"Подкласс :exc:`SSLError`, вызываемый при возникновении системной ошибки при "
"попытке выполнить операцию над сокетом SSL. К сожалению, нет простого "
"способа проверить исходный номер ошибки."

#: ../../library/ssl.rst:265
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"Подкласс :exc:`SSLError`, вызываемый при внезапном разрыве SSL-соединения. "
"Как правило, при возникновении этой ошибки не следует пытаться повторно "
"использовать базовый транспорт."

#: ../../library/ssl.rst:273
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"Подкласс :exc:`SSLError`, вызываемый при неудачной проверке сертификата."

#: ../../library/ssl.rst:280
msgid "A numeric error number that denotes the verification error."
msgstr "Числовой номер ошибки, обозначающий ошибку проверки."

#: ../../library/ssl.rst:284
msgid "A human readable string of the verification error."
msgstr "Удобочитаемая строка ошибки проверки."

#: ../../library/ssl.rst:288
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Псевдоним для :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:290
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr ""
"Исключением теперь является псевдоним для :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:295
msgid "Random generation"
msgstr "Случайная генерация"

#: ../../library/ssl.rst:299
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Возвращает *num* криптостойкие псевдослучайные байты. Вызывает :class:"
"`SSLError`, если в PRNG недостаточно данных или если операция не "
"поддерживается текущим методом RAND. :func:`RAND_status` можно использовать "
"для проверки статуса PRNG, а :func:`RAND_add` можно использовать для "
"заполнения PRNG."

#: ../../library/ssl.rst:305 ../../library/ssl.rst:326
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr ""
"Почти для всех приложений предпочтительнее использовать :func:`os.urandom`."

#: ../../library/ssl.rst:307
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Прочтите статью в Википедии «Криптографически безопасный генератор "
"псевдослучайных чисел (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>», чтобы узнать "
"требования к криптостойкому генератору."

#: ../../library/ssl.rst:316
msgid ""
"Return (bytes, is_cryptographic): bytes are *num* pseudo-random bytes, "
"is_cryptographic is ``True`` if the bytes generated are cryptographically "
"strong. Raises an :class:`SSLError` if the operation is not supported by the "
"current RAND method."
msgstr ""

#: ../../library/ssl.rst:321
msgid ""
"Generated pseudo-random byte sequences will be unique if they are of "
"sufficient length, but are not necessarily unpredictable. They can be used "
"for non-cryptographic purposes and for certain purposes in cryptographic "
"protocols, but usually not for key generation etc."
msgstr ""

#: ../../library/ssl.rst:332
msgid ""
"OpenSSL has deprecated :func:`ssl.RAND_pseudo_bytes`, use :func:`ssl."
"RAND_bytes` instead."
msgstr ""

#: ../../library/ssl.rst:337
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Возвращайте ``True``, если генератор псевдослучайных чисел SSL заполнил "
"\"достаточную\" случайность, и ``False`` в противном случае. Вы можете "
"использовать :func:`ssl.RAND_egd` и :func:`ssl.RAND_add` для увеличения "
"случайности генератора псевдослучайных чисел."

#: ../../library/ssl.rst:344
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""

#: ../../library/ssl.rst:349
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Доступный для записи :term:`байтовый объект` теперь принимается."

#: ../../library/ssl.rst:353
msgid "Certificate handling"
msgstr "Обработка сертификатов"

#: ../../library/ssl.rst:361
msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, :rfc:"
"`5280` and :rfc:`6125`.  In addition to HTTPS, this function should be "
"suitable for checking the identity of servers in various SSL-based protocols "
"such as FTPS, IMAPS, POPS and others."
msgstr ""

#: ../../library/ssl.rst:368
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""

#: ../../library/ssl.rst:381
msgid ""
"The function now follows :rfc:`6125`, section 6.4.3 and does neither match "
"multiple wildcards (e.g. ``*.*.com`` or ``*a*.example.org``) nor a wildcard "
"inside an internationalized domain names (IDN) fragment. IDN A-labels such "
"as ``www*.xn--pthon-kva.org`` are still supported, but ``x*.python.org`` no "
"longer matches ``xn--tda.python.org``."
msgstr ""

#: ../../library/ssl.rst:388
msgid ""
"Matching of IP addresses, when present in the subjectAltName field of the "
"certificate, is now supported."
msgstr ""

#: ../../library/ssl.rst:392
msgid ""
"The function is no longer used to TLS connections. Hostname matching is now "
"performed by OpenSSL."
msgstr ""

#: ../../library/ssl.rst:396
msgid ""
"Allow wildcard when it is the leftmost and the only character in that "
"segment. Partial wildcards like ``www*.example.com`` are no longer supported."
msgstr ""

#: ../../library/ssl.rst:404
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Возвращает время в секундах с начала Эпохи, учитывая строку ``cert_time``, "
"представляющую дату \"notBefore\" или \"notAfter\" из сертификата в ``\"%b. "
"%д %H:%M:%S %Y %Z\"`` формат strptime (локаль C)."

#: ../../library/ssl.rst:409
msgid "Here's an example:"
msgstr "Вот пример:"

#: ../../library/ssl.rst:421
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "Даты «notBefore» или «notAfter» должны использовать GMT (:rfc:`5280`)."

#: ../../library/ssl.rst:423
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Интерпретируйте входное время как время в формате UTC, указанное часовым "
"поясом GMT во входной строке. Ранее использовался местный часовой пояс. "
"Возвращает целое число (без долей секунды во входном формате)"

#: ../../library/ssl.rst:432
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :meth:`SSLContext."
"wrap_socket`.  The call will attempt to validate the server certificate "
"against that set of root certificates, and will fail if the validation "
"attempt fails.  A timeout can be specified with the ``timeout`` parameter."
msgstr ""

#: ../../library/ssl.rst:443
msgid "This function is now IPv6-compatible."
msgstr "Эта функция теперь совместима с IPv6."

#: ../../library/ssl.rst:446
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"Значение *ssl_version* по умолчанию изменено с :data:`PROTOCOL_SSLv3` на :"
"data:`PROTOCOL_TLS` для максимальной совместимости с современными серверами."

#: ../../library/ssl.rst:450
msgid "The *timeout* parameter was added."
msgstr "Добавлен параметр *timeout*."

#: ../../library/ssl.rst:455
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Если сертификат представляет собой блок байтов в кодировке DER, возвращается "
"строковая версия того же сертификата в кодировке PEM."

#: ../../library/ssl.rst:460
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Учитывая сертификат в виде строки ASCII PEM, возвращает последовательность "
"байтов в кодировке DER для этого же сертификата."

#: ../../library/ssl.rst:465
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Возвращает именованный кортеж с путями к файлу cafile и capath OpenSSL по "
"умолчанию. Пути такие же, как и в :meth:`SSLContext."
"set_default_verify_paths`. Возвращаемое значение представляет собой "
"именованный кортеж ``DefaultVerifyPaths``:"

#: ../../library/ssl.rst:470
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - разрешенный путь к cafile или ``None``, если файл не "
"существует,"

#: ../../library/ssl.rst:471
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - разрешенный путь к capath или ``None``, если каталог не "
"существует,"

#: ../../library/ssl.rst:472
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` — ключ среды OpenSSL, указывающий на файл cafile,"

#: ../../library/ssl.rst:473
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - жестко запрограммированный путь к файлу кафе,"

#: ../../library/ssl.rst:474
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` — ключ среды OpenSSL, указывающий на capath,"

#: ../../library/ssl.rst:475
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ""
":attr:`openssl_capath` — жестко запрограммированный путь к каталогу capath."

#: ../../library/ssl.rst:479
msgid ""
":ref:`Availability <availability>`: LibreSSL ignores the environment vars :"
"attr:`openssl_cafile_env` and :attr:`openssl_capath_env`."
msgstr ""

#: ../../library/ssl.rst:484
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Получите сертификаты из хранилища системных сертификатов Windows. "
"*store_name* может быть одним из ``CA``, ``ROOT`` или ``MY``. Windows также "
"может предоставлять дополнительные хранилища сертификатов."

#: ../../library/ssl.rst:488
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"Функция возвращает список кортежей (cert_bytes,coding_type,trust). "
"Тип_кодирования указывает кодировку cert_bytes. Это либо :const:`x509_asn` "
"для данных X.509 ASN.1, либо :const:`pkcs_7_asn` для данных PKCS#7 ASN.1. "
"Доверие определяет назначение сертификата в виде набора OIDS или в точности "
"«True», если сертификат заслуживает доверия для всех целей."

#: ../../library/ssl.rst:495 ../../library/ssl.rst:1639
#: ../../library/ssl.rst:1934
msgid "Example::"
msgstr "Пример::"

#: ../../library/ssl.rst:502 ../../library/ssl.rst:517
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../library/ssl.rst:507
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Получите CRL из хранилища системных сертификатов Windows. *store_name* может "
"быть одним из ``CA``, ``ROOT`` или ``MY``. Windows также может предоставлять "
"дополнительные хранилища сертификатов."

#: ../../library/ssl.rst:511
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"Функция возвращает список кортежей (cert_bytes,coding_type,trust). "
"Тип_кодирования указывает кодировку cert_bytes. Это либо :const:`x509_asn` "
"для данных X.509 ASN.1, либо :const:`pkcs_7_asn` для данных PKCS#7 ASN.1."

#: ../../library/ssl.rst:525
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  ``sock`` must be a :"
"data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""

#: ../../library/ssl.rst:530
msgid ""
"Internally, function creates a :class:`SSLContext` with protocol "
"*ssl_version* and :attr:`SSLContext.options` set to *cert_reqs*. If "
"parameters *keyfile*, *certfile*, *ca_certs* or *ciphers* are set, then the "
"values are passed to :meth:`SSLContext.load_cert_chain`, :meth:`SSLContext."
"load_verify_locations`, and :meth:`SSLContext.set_ciphers`."
msgstr ""

#: ../../library/ssl.rst:537
msgid ""
"The arguments *server_side*, *do_handshake_on_connect*, and "
"*suppress_ragged_eofs* have the same meaning as :meth:`SSLContext."
"wrap_socket`."
msgstr ""

#: ../../library/ssl.rst:543
msgid ""
"Since Python 3.2 and 2.7.9, it is recommended to use the :meth:`SSLContext."
"wrap_socket` instead of :func:`wrap_socket`. The top-level function is "
"limited and creates an insecure client socket without server name indication "
"or hostname matching."
msgstr ""

#: ../../library/ssl.rst:549
msgid "Constants"
msgstr "Константы"

#: ../../library/ssl.rst:551
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Все константы теперь представляют собой коллекции :class:`enum.IntEnum` или :"
"class:`enum.IntFlag`."

#: ../../library/ssl.rst:557
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  Except for :const:`PROTOCOL_TLS_CLIENT`, "
"it is the default mode.  With client-side sockets, just about any cert is "
"accepted.  Validation errors, such as untrusted or expired cert, are ignored "
"and do not abort the TLS/SSL handshake."
msgstr ""

#: ../../library/ssl.rst:563
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"В режиме сервера сертификат от клиента не запрашивается, поэтому клиент не "
"отправляет его для проверки подлинности сертификата клиента."

#: ../../library/ssl.rst:566 ../../library/ssl.rst:2342
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "См. обсуждение :ref:`ssl-security` ниже."

#: ../../library/ssl.rst:570
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In client mode, :const:`CERT_OPTIONAL` "
"has the same meaning as :const:`CERT_REQUIRED`. It is recommended to use :"
"const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""

#: ../../library/ssl.rst:575
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"В режиме сервера клиенту отправляется запрос сертификата клиента. Клиент "
"может либо проигнорировать запрос, либо отправить сертификат, чтобы "
"выполнить аутентификацию сертификата клиента TLS. Если клиент решает "
"отправить сертификат, он проверяется. Любая ошибка проверки немедленно "
"прерывает рукопожатие TLS."

#: ../../library/ssl.rst:581 ../../library/ssl.rst:601
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""

#: ../../library/ssl.rst:587
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails. This mode "
"is **not** sufficient to verify a certificate in client mode as it does not "
"match hostnames.  :attr:`~SSLContext.check_hostname` must be enabled as well "
"to verify the authenticity of a cert. :const:`PROTOCOL_TLS_CLIENT` uses :"
"const:`CERT_REQUIRED` and enables :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""

#: ../../library/ssl.rst:597
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"При использовании сокета сервера этот режим обеспечивает обязательную "
"аутентификацию сертификата клиента TLS. Запрос сертификата клиента "
"отправляется клиенту, и клиент должен предоставить действительный и надежный "
"сертификат."

#: ../../library/ssl.rst:607
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` коллекция констант CERT_*."

#: ../../library/ssl.rst:613
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags`. В этом режиме списки "
"отзыва сертификатов (CRL) не проверяются. По умолчанию OpenSSL не требует и "
"не проверяет CRL."

#: ../../library/ssl.rst:621
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags`. В этом режиме "
"проверяется только сертификат узла, но не проверяется ни один из "
"сертификатов промежуточного центра сертификации. Для этого режима требуется "
"действительный CRL, подписанный эмитентом однорангового сертификата (его "
"прямым предком CA). Если правильный CRL не был загружен с помощью :attr:"
"`SSLContext.load_verify_locations`, проверка завершится неудачно."

#: ../../library/ssl.rst:631
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags`. В этом режиме "
"проверяются CRL всех сертификатов в цепочке одноранговых сертификатов."

#: ../../library/ssl.rst:638
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags` для отключения "
"обходных путей для поврежденных сертификатов X.509."

#: ../../library/ssl.rst:645
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags`, чтобы включить "
"проверку сертификата прокси."

#: ../../library/ssl.rst:652
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags`. Он указывает OpenSSL "
"отдавать предпочтение доверенным сертификатам при построении цепочки доверия "
"для проверки сертификата. Этот флаг включен по умолчанию."

#: ../../library/ssl.rst:660
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
"Возможное значение для :attr:`SSLContext.verify_flags`. Он предписывает "
"OpenSSL принимать промежуточные центры сертификации в хранилище доверенных "
"сертификатов, которые будут рассматриваться как якоря доверия, так же, как и "
"самозаверяющие корневые сертификаты центра сертификации. Это позволяет "
"доверять сертификатам, выданным промежуточным центром сертификации, без "
"необходимости доверять своему родительскому корневому центру сертификации."

#: ../../library/ssl.rst:671
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` коллекция констант VERIFY_*."

#: ../../library/ssl.rst:677
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Выбирает самую высокую версию протокола, которую поддерживают как клиент, "
"так и сервер. Несмотря на название, эта опция может выбирать как протоколы "
"«SSL», так и «TLS»."

#: ../../library/ssl.rst:684
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Клиентам и серверам TLS требуются разные настройки по умолчанию для "
"безопасной связи. Общая константа протокола TLS устарела в пользу :data:"
"`PROTOCOL_TLS_CLIENT` и :data:`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:690
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Выполните автоматическое согласование самой высокой версии протокола, "
"которую поддерживают как клиент, так и сервер, и настройте контекстные "
"соединения на стороне клиента. Протокол включает :data:`CERT_REQUIRED` и :"
"attr:`~SSLContext.check_hostname` по умолчанию."

#: ../../library/ssl.rst:699
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""
"Выполните автоматическое согласование самой высокой версии протокола, "
"которую поддерживают как клиент, так и сервер, и настройте контекстные "
"соединения на стороне сервера."

#: ../../library/ssl.rst:706
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Псевдоним для :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:710
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Вместо этого используйте :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:714
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr ""

#: ../../library/ssl.rst:716
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl2`` "
"option."
msgstr ""

#: ../../library/ssl.rst:721
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr ""

#: ../../library/ssl.rst:725
msgid "OpenSSL has removed support for SSLv2."
msgstr ""

#: ../../library/ssl.rst:729
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Выбирает SSL версии 3 в качестве протокола шифрования канала."

#: ../../library/ssl.rst:731
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr "Этот протокол недоступен, если OpenSSL скомпилирован с опцией no-ssl3."

#: ../../library/ssl.rst:736
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "SSL версии 3 небезопасен. Его использование крайне не рекомендуется."

#: ../../library/ssl.rst:740
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"OpenSSL объявил устаревшими все протоколы конкретной версии. Вместо этого "
"используйте протокол по умолчанию :data:`PROTOCOL_TLS_SERVER` или :data:"
"`PROTOCOL_TLS_CLIENT` с :attr:`SSLContext.minimum_version` и :attr:"
"`SSLContext.maximum_version`."

#: ../../library/ssl.rst:748
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "В качестве протокола шифрования канала выбирается TLS версии 1.0."

#: ../../library/ssl.rst:752 ../../library/ssl.rst:763
#: ../../library/ssl.rst:774
msgid "OpenSSL has deprecated all version specific protocols."
msgstr "OpenSSL объявил устаревшими все протоколы конкретной версии."

#: ../../library/ssl.rst:756
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Выбирает TLS версии 1.1 в качестве протокола шифрования канала. Доступно "
"только с версией openssl 1.0.1+."

#: ../../library/ssl.rst:767
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"В качестве протокола шифрования канала выбирается TLS версии 1.2. Доступно "
"только с версией openssl 1.0.1+."

#: ../../library/ssl.rst:778
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Позволяет обходные пути для различных ошибок, присутствующих в других "
"реализациях SSL. Эта опция установлена ​​по умолчанию. Он не обязательно "
"устанавливает те же флаги, что и константа OpenSSL ``SSL_OP_ALL``."

#: ../../library/ssl.rst:786
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Запрещает соединение SSLv2. Эта опция применима только в сочетании с :const:"
"`PROTOCOL_TLS`. Это не позволяет узлам выбирать SSLv2 в качестве версии "
"протокола."

#: ../../library/ssl.rst:794
msgid "SSLv2 is deprecated"
msgstr "SSLv2 устарел"

#: ../../library/ssl.rst:798
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Запрещает соединение SSLv3. Эта опция применима только в сочетании с :const:"
"`PROTOCOL_TLS`. Это не позволяет узлам выбирать SSLv3 в качестве версии "
"протокола."

#: ../../library/ssl.rst:806
msgid "SSLv3 is deprecated"
msgstr "SSLv3 устарел"

#: ../../library/ssl.rst:810
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Запрещает соединение TLSv1. Эта опция применима только в сочетании с :const:"
"`PROTOCOL_TLS`. Это не позволяет узлам выбирать TLSv1 в качестве версии "
"протокола."

#: ../../library/ssl.rst:816
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"Эта опция устарела, начиная с OpenSSL 1.1.0, вместо нее используйте новые :"
"attr:`SSLContext.minimum_version` и :attr:`SSLContext.maximum_version`."

#: ../../library/ssl.rst:823
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Предотвращает соединение TLSv1.1. Эта опция применима только в сочетании с :"
"const:`PROTOCOL_TLS`. Это не позволяет узлам выбирать TLSv1.1 в качестве "
"версии протокола. Доступно только с версией openssl 1.0.1+."

#: ../../library/ssl.rst:829 ../../library/ssl.rst:840
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "Эта опция устарела, начиная с OpenSSL 1.1.0."

#: ../../library/ssl.rst:834
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Предотвращает соединение TLSv1.2. Эта опция применима только в сочетании с :"
"const:`PROTOCOL_TLS`. Это не позволяет узлам выбирать TLSv1.2 в качестве "
"версии протокола. Доступно только с версией openssl 1.0.1+."

#: ../../library/ssl.rst:845
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Предотвращает соединение TLSv1.3. Эта опция применима только в сочетании с :"
"const:`PROTOCOL_TLS`. Это не позволяет узлам выбирать TLSv1.3 в качестве "
"версии протокола. TLS 1.3 доступен с OpenSSL 1.1.1 или более поздней версии. "
"Если Python скомпилирован с использованием более старой версии OpenSSL, флаг "
"по умолчанию равен *0*."

#: ../../library/ssl.rst:853
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15, 3.6.3 "
"and 3.7.0 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""

#: ../../library/ssl.rst:859
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Отключите все повторные согласования в TLSv1.2 и более ранних версиях. Не "
"отправляйте сообщения HelloRequest и игнорируйте запросы на повторное "
"согласование через ClientHello."

#: ../../library/ssl.rst:862
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Эта опция доступна только в OpenSSL 1.1.0h и более поздних версиях."

#: ../../library/ssl.rst:868
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Используйте предпочтения порядка шифрования сервера, а не клиента. Этот "
"параметр не влияет на клиентские сокеты и серверные сокеты SSLv2."

#: ../../library/ssl.rst:875
msgid ""
"Prevents re-use of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""

#: ../../library/ssl.rst:883
msgid ""
"Prevents re-use of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""

#: ../../library/ssl.rst:891
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Отправляйте фиктивные сообщения Change Cipher Spec (CCS) при рукопожатии TLS "
"1.3, чтобы соединение TLS 1.3 больше походило на соединение TLS 1.2."

#: ../../library/ssl.rst:894
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Эта опция доступна только в OpenSSL 1.1.1 и более поздних версиях."

#: ../../library/ssl.rst:900
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Отключите сжатие на канале SSL. Это полезно, если протокол приложения "
"поддерживает собственную схему сжатия."

#: ../../library/ssl.rst:907
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` коллекция констант OP_*."

#: ../../library/ssl.rst:911
msgid "Prevent client side from requesting a session ticket."
msgstr "Запретить клиентской стороне запрос билета сеанса."

#: ../../library/ssl.rst:917
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Игнорировать неожиданное завершение соединений TLS."

#: ../../library/ssl.rst:919
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Эта опция доступна только в OpenSSL 3.0.0 и более поздних версиях."

#: ../../library/ssl.rst:925
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""
"Имеет ли библиотека OpenSSL встроенную поддержку расширения TLS *Application-"
"Layer Protocol Negotiation*, как описано в :rfc:`7301`."

#: ../../library/ssl.rst:932
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""
"Имеет ли библиотека OpenSSL встроенную поддержку отсутствия проверки общего "
"имени субъекта и возможность записи :attr:`SSLContext."
"hostname_checks_common_name`."

#: ../../library/ssl.rst:940
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""
"Имеет ли библиотека OpenSSL встроенную поддержку обмена ключами Диффи-"
"Хеллмана на основе эллиптической кривой. Это должно быть правдой, если эта "
"функция не была явно отключена дистрибьютором."

#: ../../library/ssl.rst:948
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""
"Имеет ли библиотека OpenSSL встроенную поддержку расширения *Индикация имени "
"сервера* (как определено в :rfc:`6066`)."

#: ../../library/ssl.rst:955
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""
"Имеет ли библиотека OpenSSL встроенную поддержку *Next Protocol "
"Negotiation*, как описано в `Согласование протокола прикладного уровня "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"Если это правда, вы можете использовать метод :meth:`SSLContext."
"set_npn_protocols`, чтобы объявить, какие протоколы вы хотите поддерживать."

#: ../../library/ssl.rst:965
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr "Имеет ли библиотека OpenSSL встроенную поддержку протокола SSL 2.0."

#: ../../library/ssl.rst:971
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr "Имеет ли библиотека OpenSSL встроенную поддержку протокола SSL 3.0."

#: ../../library/ssl.rst:977
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr "Имеет ли библиотека OpenSSL встроенную поддержку протокола TLS 1.0."

#: ../../library/ssl.rst:983
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr "Имеет ли библиотека OpenSSL встроенную поддержку протокола TLS 1.1."

#: ../../library/ssl.rst:989
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr "Имеет ли библиотека OpenSSL встроенную поддержку протокола TLS 1.2."

#: ../../library/ssl.rst:995
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr "Имеет ли библиотека OpenSSL встроенную поддержку протокола TLS 1.3."

#: ../../library/ssl.rst:1001
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Список поддерживаемых типов привязки канала TLS. Строки в этом списке можно "
"использовать в качестве аргументов для :meth:`SSLSocket.get_channel_binding`."

#: ../../library/ssl.rst:1008
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr "Строка версии библиотеки OpenSSL, загруженная интерпретатором::"

#: ../../library/ssl.rst:1017
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"Кортеж из пяти целых чисел, представляющих информацию о версии библиотеки "
"OpenSSL:"

#: ../../library/ssl.rst:1027
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""
"Необработанный номер версии библиотеки OpenSSL в виде одного целого числа::"

#: ../../library/ssl.rst:1040
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Описания предупреждений из :rfc:`5246` и других. `Реестр оповещений IANA TLS "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ содержит этот список и ссылки на RFC, в которых определено "
"их значение. ."

#: ../../library/ssl.rst:1044
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Используется в качестве возвращаемого значения функции обратного вызова в :"
"meth:`SSLContext.set_servername_callback`."

#: ../../library/ssl.rst:1051
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` коллекция констант ALERT_DESCRIPTION_*."

#: ../../library/ssl.rst:1057
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
"Опция для :func:`create_default_context` и :meth:`SSLContext."
"load_default_certs`. Это значение указывает, что контекст может "
"использоваться для аутентификации веб-серверов (поэтому он будет "
"использоваться для создания сокетов на стороне клиента)."

#: ../../library/ssl.rst:1066
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
"Опция для :func:`create_default_context` и :meth:`SSLContext."
"load_default_certs`. Это значение указывает, что контекст может "
"использоваться для аутентификации веб-клиентов (поэтому он будет "
"использоваться для создания сокетов на стороне сервера)."

#: ../../library/ssl.rst:1075
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` коллекция констант SSL_ERROR_*."

#: ../../library/ssl.rst:1081
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` коллекция версий SSL и TLS для :attr:`SSLContext."
"maximum_version` и :attr:`SSLContext.minimum_version`."

#: ../../library/ssl.rst:1089
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"Минимальная или максимальная поддерживаемая версия SSL или TLS. Это "
"магические константы. Их значения не отражают самые низкие и самые высокие "
"доступные версии TLS/SSL."

#: ../../library/ssl.rst:1099
msgid "SSL 3.0 to TLS 1.3."
msgstr "От SSL 3.0 до TLS 1.3."

#: ../../library/ssl.rst:1103
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"Все члены :class:`TLSVersion`, кроме :attr:`TLSVersion.TLSv1_2` и :attr:"
"`TLSVersion.TLSv1_3`, устарели."

#: ../../library/ssl.rst:1108
msgid "SSL Sockets"
msgstr "Сокеты SSL"

#: ../../library/ssl.rst:1112
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "Сокеты SSL предоставляют следующие методы :ref:`socket-objects`:"

#: ../../library/ssl.rst:1114
msgid ":meth:`~socket.socket.accept()`"
msgstr ":meth:`~socket.socket.accept()`"

#: ../../library/ssl.rst:1115
msgid ":meth:`~socket.socket.bind()`"
msgstr ":meth:`~socket.socket.bind()`"

#: ../../library/ssl.rst:1116
msgid ":meth:`~socket.socket.close()`"
msgstr ":meth:`~socket.socket.close()`"

#: ../../library/ssl.rst:1117
msgid ":meth:`~socket.socket.connect()`"
msgstr ":meth:`~socket.socket.connect()`"

#: ../../library/ssl.rst:1118
msgid ":meth:`~socket.socket.detach()`"
msgstr ":meth:`~socket.socket.detach()`"

#: ../../library/ssl.rst:1119
msgid ":meth:`~socket.socket.fileno()`"
msgstr ":meth:`~socket.socket.fileno()`"

#: ../../library/ssl.rst:1120
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"

#: ../../library/ssl.rst:1121
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"

#: ../../library/ssl.rst:1122
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"

#: ../../library/ssl.rst:1124
msgid ":meth:`~socket.socket.listen()`"
msgstr ":meth:`~socket.socket.listen()`"

#: ../../library/ssl.rst:1125
msgid ":meth:`~socket.socket.makefile()`"
msgstr ":meth:`~socket.socket.makefile()`"

#: ../../library/ssl.rst:1126
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""

#: ../../library/ssl.rst:1128
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""

#: ../../library/ssl.rst:1130
msgid ""
":meth:`~socket.socket.sendfile()` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send()` will be used)"
msgstr ""

#: ../../library/ssl.rst:1132
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ":meth:`~socket.socket.shutdown()`"

#: ../../library/ssl.rst:1134
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"Однако, поскольку протокол SSL (и TLS) имеет собственную структуру поверх "
"TCP, абстракция сокетов SSL может в некоторых отношениях отличаться от "
"спецификации обычных сокетов уровня ОС. Особенно смотрите :ref:`примечания о "
"неблокирующих сокетах <ssl-nonblocking>`."

#: ../../library/ssl.rst:1139
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Экземпляры :class:`SSLSocket` должны быть созданы с использованием метода :"
"meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:1142
msgid "The :meth:`sendfile` method was added."
msgstr "Был добавлен метод :meth:`sendfile`."

#: ../../library/ssl.rst:1145
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ""
":meth:`shutdown` не сбрасывает таймаут сокета каждый раз, когда байты "
"принимаются или отправляются. Тайм-аут сокета теперь равен максимальной "
"общей продолжительности выключения."

#: ../../library/ssl.rst:1150
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Устарело создавать экземпляр :class:`SSLSocket` напрямую, используйте :meth:"
"`SSLContext.wrap_socket` для переноса сокета."

#: ../../library/ssl.rst:1154
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"Экземпляры :class:`SSLSocket` должны создаваться с помощью :meth:"
"`~SSLContext.wrap_socket`. В более ранних версиях можно было создавать "
"экземпляры напрямую. Это никогда не было задокументировано и официально не "
"поддержано."

#: ../../library/ssl.rst:1160
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""
"Python теперь использует SSL_read_ex и SSL_write_ex внутри себя. Функции "
"поддерживают чтение и запись данных размером более 2 ГБ. Запись данных "
"нулевой длины больше не завершается ошибкой нарушения протокола."

#: ../../library/ssl.rst:1165
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "Сокеты SSL также имеют следующие дополнительные методы и атрибуты:"

#: ../../library/ssl.rst:1169
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Считайте до *len* байт данных из сокета SSL и верните результат в виде "
"экземпляра ``bytes``. Если указан *buffer*, вместо этого читайте в буфер и "
"возвращайте количество прочитанных байтов."

#: ../../library/ssl.rst:1173
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Поднимите :exc:`SSLWantReadError` или :exc:`SSLWantWriteError`, если сокет :"
"ref:`неблокирующий <ssl-nonblocking>` и чтение будет заблокировано."

#: ../../library/ssl.rst:1176
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Поскольку в любой момент возможно повторное согласование, вызов :meth:`read` "
"также может вызвать операции записи."

#: ../../library/ssl.rst:1179
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr ""
"Тайм-аут сокета больше не сбрасывается каждый раз при получении или отправке "
"байтов. Тайм-аут сокета теперь равен максимальной общей продолжительности "
"чтения до *len* байт."

#: ../../library/ssl.rst:1184
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "Используйте :meth:`~SSLSocket.recv` вместо :meth:`~SSLSocket.read`."

#: ../../library/ssl.rst:1189
msgid ""
"Write *buf* to the SSL socket and return the number of bytes written. The "
"*buf* argument must be an object supporting the buffer interface."
msgstr ""
"Запишите *buf* в сокет SSL и верните количество записанных байтов. Аргумент "
"*buf* должен быть объектом, поддерживающим интерфейс буфера."

#: ../../library/ssl.rst:1192
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Поднимите :exc:`SSLWantReadError` или :exc:`SSLWantWriteError`, если сокет :"
"ref:`неблокирующий <ssl-nonblocking>` и запись будет заблокирована."

#: ../../library/ssl.rst:1195
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Поскольку в любой момент возможно повторное согласование, вызов :meth:"
"`write` также может вызвать операции чтения."

#: ../../library/ssl.rst:1198
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *buf*."
msgstr ""
"Тайм-аут сокета больше не сбрасывается каждый раз при получении или отправке "
"байтов. Тайм-аут сокета теперь равен максимальной общей продолжительности "
"записи *buf*."

#: ../../library/ssl.rst:1202
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "Используйте :meth:`~SSLSocket.send` вместо :meth:`~SSLSocket.write`."

#: ../../library/ssl.rst:1207
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Методы :meth:`~SSLSocket.read` и :meth:`~SSLSocket.write` — это методы "
"низкого уровня, которые читают и записывают незашифрованные данные уровня "
"приложения и дешифруют/шифруют их в зашифрованные данные на уровне сети. Эти "
"методы требуют активного SSL-соединения, т.е. рукопожатие было завершено, а :"
"meth:`SSLSocket.unwrap` не был вызван."

#: ../../library/ssl.rst:1213
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Обычно вместо этих методов следует использовать методы API сокетов, такие "
"как :meth:`~socket.socket.recv` и :meth:`~socket.socket.send`."

#: ../../library/ssl.rst:1219
msgid "Perform the SSL setup handshake."
msgstr "Выполните подтверждение установки SSL."

#: ../../library/ssl.rst:1221
msgid ""
"The handshake method also performs :func:`match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"Метод рукопожатия также выполняет :func:`match_hostname`, когда атрибут :"
"attr:`~SSLContext.check_hostname` сокета :attr:`~SSLSocket.context` имеет "
"значение true."

#: ../../library/ssl.rst:1226
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr ""
"Тайм-аут сокета больше не сбрасывается каждый раз при получении или отправке "
"байтов. Тайм-аут сокета теперь равен максимальной общей продолжительности "
"рукопожатия."

#: ../../library/ssl.rst:1230
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""
"Имя хоста или IP-адрес сопоставляется OpenSSL во время рукопожатия. Функция :"
"func:`match_hostname` больше не используется. В случае, если OpenSSL "
"отклоняет имя хоста или IP-адрес, рукопожатие прерывается досрочно, и "
"партнеру отправляется предупреждающее сообщение TLS."

#: ../../library/ssl.rst:1238
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Если сертификат для узла на другом конце соединения отсутствует, верните "
"None. Если подтверждение SSL еще не выполнено, поднимите :exc:`ValueError`."

#: ../../library/ssl.rst:1242
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Если параметр ``binary_form`` имеет значение :const:`False` и сертификат был "
"получен от узла, этот метод возвращает экземпляр :class:`dict`. Если "
"сертификат не был проверен, словарь пуст. Если сертификат был проверен, он "
"возвращает dict с несколькими ключами, среди которых «субъект» (принципал, "
"для которого был выдан сертификат) и «эмитент» (принципал, выдавший "
"сертификат). Если сертификат содержит экземпляр расширения *Альтернативное "
"имя субъекта* (см. :rfc:`3280`), в словаре также будет ключ "
"``subjectAltName``."

#: ../../library/ssl.rst:1251
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Поля «субъект» и «эмитент» представляют собой кортежи, содержащие "
"последовательность относительных отличительных имен (RDN), заданных в "
"структуре данных сертификата для соответствующих полей, и каждое RDN "
"представляет собой последовательность пар имя-значение. Вот реальный пример:"

#: ../../library/ssl.rst:1277
msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr ""

#: ../../library/ssl.rst:1280
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Если параметр ``binary_form`` имеет значение :const:`True` и был "
"предоставлен сертификат, этот метод возвращает закодированную DER форму "
"всего сертификата в виде последовательности байтов или :const:`None`, если "
"партнер сертификат не предоставил. Предоставляет ли партнер сертификат, "
"зависит от роли сокета SSL:"

#: ../../library/ssl.rst:1286
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"для клиентского сокета SSL сервер всегда будет предоставлять сертификат, "
"независимо от того, требовалась ли проверка;"

#: ../../library/ssl.rst:1289
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"для сокета SSL сервера клиент будет предоставлять сертификат только по "
"запросу сервера; поэтому :meth:`getpeercert` вернет :const:`None`, если вы "
"использовали :const:`CERT_NONE` (а не :const:`CERT_OPTIONAL` или :const:"
"`CERT_REQUIRED`)."

#: ../../library/ssl.rst:1294
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"Возвращенный словарь включает дополнительные элементы, такие как «issuer» и "
"«notBefore»."

#: ../../library/ssl.rst:1298
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` возникает, когда рукопожатие не завершено. Возвращенный "
"словарь включает дополнительные элементы расширения X509v3, такие как "
"crlDistributionPoints, caIssuers и URI OCSP."

#: ../../library/ssl.rst:1303
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "Строки адреса IPv6 больше не имеют завершающей новой строки."

#: ../../library/ssl.rst:1308
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Возвращает кортеж из трех значений, содержащий имя используемого шифра, "
"версию протокола SSL, определяющую его использование, и количество "
"используемых секретных битов. Если соединение не установлено, возвращается "
"``None``."

#: ../../library/ssl.rst:1314
msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"Возвращает список шифров, доступных как на клиенте, так и на сервере. Каждая "
"запись возвращаемого списка представляет собой кортеж из трех значений, "
"содержащий имя шифра, версию протокола SSL, определяющую его использование, "
"и количество секретных битов, которые использует шифр. :meth:`~SSLSocket."
"shared_ciphers` возвращает ``None``, если соединение не установлено или "
"сокет является клиентским."

#: ../../library/ssl.rst:1325
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Возвращает используемый алгоритм сжатия в виде строки или «Нет», если "
"соединение не сжимается."

#: ../../library/ssl.rst:1328
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Если протокол более высокого уровня поддерживает собственный механизм "
"сжатия, вы можете использовать :data:`OP_NO_COMPRESSION`, чтобы отключить "
"сжатие на уровне SSL."

#: ../../library/ssl.rst:1335
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Получите данные привязки канала для текущего соединения в виде байтового "
"объекта. Возвращает None, если соединение не установлено или рукопожатие не "
"завершено."

#: ../../library/ssl.rst:1338
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"Параметр *cb_type* позволяет выбрать желаемый тип привязки канала. "
"Допустимые типы привязки каналов перечислены в списке :data:"
"`CHANNEL_BINDING_TYPES`. В настоящее время поддерживается только привязка "
"канала «tls-unique», определенная :rfc:`5929`. :exc:`ValueError` будет "
"вызван, если запрошен неподдерживаемый тип привязки канала."

#: ../../library/ssl.rst:1348
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Верните протокол, выбранный во время подтверждения TLS. Если :meth:"
"`SSLContext.set_alpn_protocols` не был вызван, если другая сторона не "
"поддерживает ALPN, если этот сокет не поддерживает ни один из предложенных "
"клиентом протоколов или если рукопожатие еще не произошло, ``Нет`` будет "
"вернулся."

#: ../../library/ssl.rst:1358
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Возвращает протокол более высокого уровня, который был выбран во время "
"установления связи TLS/SSL. Если :meth:`SSLContext.set_npn_protocols` не был "
"вызван, или если другая сторона не поддерживает NPN, или если рукопожатие "
"еще не произошло, это вернет ``None``."

#: ../../library/ssl.rst:1367 ../../library/ssl.rst:1727
msgid "NPN has been superseded by ALPN"
msgstr "NPN был заменен ALPN."

#: ../../library/ssl.rst:1371
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Выполняет подтверждение завершения SSL, которое удаляет уровень TLS из "
"базового сокета и возвращает базовый объект сокета. Это можно использовать "
"для перехода от зашифрованной операции через соединение к незашифрованной. "
"Возвращенный сокет всегда следует использовать для дальнейшего "
"взаимодействия с другой стороной соединения, а не исходный сокет."

#: ../../library/ssl.rst:1379
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Запрашивает аутентификацию после рукопожатия (PHA) от клиента TLS 1.3. PHA "
"может быть инициирован только для соединения TLS 1.3 из сокета на стороне "
"сервера, после первоначального подтверждения TLS и при включенном PHA с "
"обеих сторон, см. :attr:`SSLContext.post_handshake_auth`."

#: ../../library/ssl.rst:1384
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"Этот метод не выполняет обмен сертификатами немедленно. Серверная сторона "
"отправляет запрос сертификата во время следующего события записи и ожидает, "
"что клиент ответит сертификатом на следующее событие чтения."

#: ../../library/ssl.rst:1388
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Если какое-либо предварительное условие не выполнено (например, TLS 1.3 не "
"включен, PHA не включен), выдается ошибка :exc:`SSLError`."

#: ../../library/ssl.rst:1392
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Доступно только при включенном OpenSSL 1.1.1 и TLS 1.3. Без поддержки TLS "
"1.3 метод вызывает :exc:`NotImplementedError`."

#: ../../library/ssl.rst:1399
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Возвращает фактическую версию протокола SSL, согласованную соединением, в "
"виде строки или ``None``, если безопасное соединение не установлено. На "
"момент написания этой статьи возможные возвращаемые значения включали "
"``\"SSLv2\"``, ``\"SSLv3\"``, ``\"TLSv1\"``, ``\"TLSv1.1\"`` и ``\"TLSv1.2\" "
"``. Последние версии OpenSSL могут определять больше возвращаемых значений."

#: ../../library/ssl.rst:1409
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Возвращает количество уже расшифрованных байтов, доступных для чтения, "
"ожидающих соединения."

#: ../../library/ssl.rst:1414
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the deprecated :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""

#: ../../library/ssl.rst:1423
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"Логическое значение, которое имеет значение True для сокетов на стороне "
"сервера и False для сокетов на стороне клиента."

#: ../../library/ssl.rst:1430
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Имя хоста сервера: тип :class:`str` или ``None`` для сокета на стороне "
"сервера или если имя хоста не было указано в конструкторе."

#: ../../library/ssl.rst:1435
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"Атрибут теперь всегда представляет собой текст ASCII. Когда "
"``server_hostname`` является интернационализированным доменным именем (IDN), "
"этот атрибут теперь хранит форму A-метки (``\"xn--pythn-mua.org\"``), а не "
"форму U-метки (` `\"pythön.org\"``)."

#: ../../library/ssl.rst:1443
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
":class:`SSLSession` для этого SSL-соединения. Сеанс доступен для сокетов на "
"стороне клиента и сервера после выполнения подтверждения TLS. Для клиентских "
"сокетов сеанс может быть установлен до вызова :meth:`~SSLSocket."
"do_handshake` для повторного использования сеанса."

#: ../../library/ssl.rst:1456
msgid "SSL Contexts"
msgstr "Контексты SSL"

#: ../../library/ssl.rst:1460
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"Контекст SSL содержит различные данные, которые хранятся дольше, чем "
"отдельные соединения SSL, такие как параметры конфигурации SSL, "
"сертификат(ы) и закрытый ключ(и). Он также управляет кешем сеансов SSL для "
"сокетов на стороне сервера, чтобы ускорить повторные соединения от одних и "
"тех же клиентов."

#: ../../library/ssl.rst:1467
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Создайте новый контекст SSL. Вы можете передать *protocol*, который должен "
"быть одной из констант ``PROTOCOL_*``, определенных в этом модуле. Параметр "
"указывает, какую версию протокола SSL использовать. Обычно сервер выбирает "
"конкретную версию протокола, и клиент должен адаптироваться к выбору "
"сервера. Большинство версий несовместимы с другими версиями. Если не "
"указано, по умолчанию используется :data:`PROTOCOL_TLS`; он обеспечивает "
"максимальную совместимость с другими версиями."

#: ../../library/ssl.rst:1476
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Вот таблица, показывающая, какие версии на клиенте (внизу) могут "
"подключаться к каким версиям на сервере (вверху):"

#: ../../library/ssl.rst:1482
msgid "*client* / **server**"
msgstr "*клиент* / **сервер**"

#: ../../library/ssl.rst:1482
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1482
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1482
msgid "**TLS** [3]_"
msgstr "**ТЛС** [3]_"

#: ../../library/ssl.rst:1482
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1482
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1482
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1484
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1484 ../../library/ssl.rst:1485
#: ../../library/ssl.rst:1486 ../../library/ssl.rst:1487
#: ../../library/ssl.rst:1488 ../../library/ssl.rst:1489
msgid "yes"
msgstr "да"

#: ../../library/ssl.rst:1484 ../../library/ssl.rst:1485
#: ../../library/ssl.rst:1487 ../../library/ssl.rst:1488
#: ../../library/ssl.rst:1489
msgid "no"
msgstr "нет"

#: ../../library/ssl.rst:1484 ../../library/ssl.rst:1486
msgid "no [1]_"
msgstr "нет [1]_"

#: ../../library/ssl.rst:1485
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1485 ../../library/ssl.rst:1486
msgid "no [2]_"
msgstr "нет [2]_"

#: ../../library/ssl.rst:1486
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1487
msgid "*TLSv1*"
msgstr "*TLSv1*."

#: ../../library/ssl.rst:1488
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*."

#: ../../library/ssl.rst:1489
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*."

#: ../../library/ssl.rst:1492
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/ssl.rst:1493
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` по умолчанию отключает SSLv2 с помощью :data:"
"`OP_NO_SSLv2`."

#: ../../library/ssl.rst:1494
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` по умолчанию отключает SSLv3 с помощью :data:"
"`OP_NO_SSLv3`."

#: ../../library/ssl.rst:1495
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"Протокол TLS 1.3 будет доступен с :data:`PROTOCOL_TLS` в OpenSSL >= 1.1.1. "
"Специальной константы PROTOCOL только для TLS 1.3 не существует."

#: ../../library/ssl.rst:1500
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` позволяет модулю :mod:`ssl` выбирать "
"настройки безопасности для определенной цели."

#: ../../library/ssl.rst:1505
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` (except "
"for :data:`PROTOCOL_SSLv2`), and :data:`OP_NO_SSLv3` (except for :data:"
"`PROTOCOL_SSLv3`) are set by default. The initial cipher suite list contains "
"only ``HIGH`` ciphers, no ``NULL`` ciphers and no ``MD5`` ciphers (except "
"for :data:`PROTOCOL_SSLv2`)."
msgstr ""

#: ../../library/ssl.rst:1516
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` без аргумента протокола устарел. В будущем для класса "
"контекста потребуется либо протокол :data:`PROTOCOL_TLS_CLIENT`, либо :data:"
"`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:1522
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""
"Наборы шифров по умолчанию теперь включают только безопасные шифры AES и "
"ChaCha20 с прямой секретностью и уровнем безопасности 2. Ключи RSA и DH "
"длиной менее 2048 бит и ключи ECC длиной менее 224 бит запрещены. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT` и :data:`PROTOCOL_TLS_SERVER` "
"используют TLS 1.2 в качестве минимальной версии TLS."

#: ../../library/ssl.rst:1529
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr "Объекты :class:`SSLContext` имеют следующие методы и атрибуты:"

#: ../../library/ssl.rst:1533
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"Получайте статистику о количестве загруженных сертификатов X.509, количестве "
"сертификатов X.509, помеченных как сертификаты CA, и списках отзыва "
"сертификатов в виде словаря."

#: ../../library/ssl.rst:1537
msgid "Example for a context with one CA cert and one other cert::"
msgstr "Пример контекста с одним сертификатом CA и еще одним сертификатом::"

#: ../../library/ssl.rst:1547
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"Загрузите закрытый ключ и соответствующий сертификат. Строка *certfile* "
"должна представлять собой путь к одному файлу в формате PEM, содержащему "
"сертификат, а также любое количество сертификатов CA, необходимых для "
"установления подлинности сертификата. Строка *keyfile*, если она "
"присутствует, должна указывать на файл, содержащий закрытый ключ. В "
"противном случае закрытый ключ также будет взят из *certfile*. См. "
"обсуждение :ref:`ssl-certificates` для получения дополнительной информации о "
"том, как сертификат хранится в *certfile*."

#: ../../library/ssl.rst:1556
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"Аргумент *пароль* может быть функцией, которую нужно вызвать, чтобы получить "
"пароль для расшифровки закрытого ключа. Он будет вызываться только в том "
"случае, если закрытый ключ зашифрован и необходим пароль. Он будет "
"вызываться без аргументов и должен возвращать строку, байты или массив "
"байтов. Если возвращаемое значение является строкой, оно будет закодировано "
"как UTF-8, прежде чем использовать его для расшифровки ключа. В качестве "
"альтернативы строка, байты или значение массива байтов могут быть переданы "
"непосредственно в качестве аргумента *пароль*. Он будет игнорироваться, если "
"закрытый ключ не зашифрован и пароль не требуется."

#: ../../library/ssl.rst:1565
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Если аргумент *password* не указан и требуется пароль, встроенный механизм "
"запроса пароля OpenSSL будет использоваться для интерактивного запроса "
"пароля у пользователя."

#: ../../library/ssl.rst:1569
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
"Ошибка :class:`SSLError` возникает, если закрытый ключ не соответствует "
"сертификату."

#: ../../library/ssl.rst:1572
msgid "New optional argument *password*."
msgstr "Новый необязательный аргумент *password*."

#: ../../library/ssl.rst:1577
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"Загрузите набор сертификатов центра сертификации (CA) по умолчанию из мест "
"по умолчанию. В Windows он загружает сертификаты CA из системных хранилищ CA "
"и ROOT. Во всех системах он вызывает :meth:`SSLContext."
"set_default_verify_paths`. В будущем метод может загружать сертификаты CA и "
"из других мест."

#: ../../library/ssl.rst:1583
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""

#: ../../library/ssl.rst:1593
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Загрузите набор сертификатов «центра сертификации» (CA), используемых для "
"проверки сертификатов других узлов, если :data:`verify_mode` отличается от :"
"data:`CERT_NONE`. Должен быть указан хотя бы один из *cafile* или *capath*."

#: ../../library/ssl.rst:1597
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Этот метод также может загружать списки отзыва сертификатов (CRL) в формате "
"PEM или DER. Чтобы использовать CRL, необходимо правильно настроить :attr:"
"`SSLContext.verify_flags`."

#: ../../library/ssl.rst:1601
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"Строка *cafile*, если она присутствует, представляет собой путь к файлу "
"объединенных сертификатов CA в формате PEM. См. обсуждение :ref:`ssl-"
"certificates` для получения дополнительной информации о том, как расположить "
"сертификаты в этом файле."

#: ../../library/ssl.rst:1606
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations."
"html>`_."
msgstr ""

#: ../../library/ssl.rst:1611
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"Объект *cadata*, если он присутствует, представляет собой либо строку ASCII "
"одного или нескольких сертификатов в кодировке PEM, либо :term:`байтовый "
"объект` сертификатов в кодировке DER. Как и в случае с *capath*, "
"дополнительные строки вокруг сертификатов, закодированных в PEM, "
"игнорируются, но должен присутствовать хотя бы один сертификат."

#: ../../library/ssl.rst:1616
msgid "New optional argument *cadata*"
msgstr "Новый необязательный аргумент *cadata*"

#: ../../library/ssl.rst:1621
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Получите список загруженных сертификатов центра сертификации (CA). Если "
"параметр ``binary_form`` имеет значение :const:`False`, каждая запись списка "
"представляет собой словарь, подобный выводу :meth:`SSLSocket.getpeercert`. В "
"противном случае метод возвращает список сертификатов в кодировке DER. "
"Возвращенный список не содержит сертификатов из *capath*, если только "
"сертификат не был запрошен и загружен посредством SSL-соединения."

#: ../../library/ssl.rst:1629
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Сертификаты в каталоге capath не загружаются, если они не использовались "
"хотя бы один раз."

#: ../../library/ssl.rst:1636
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"Получить список включенных шифров. Список расположен в порядке приоритета "
"шифрования. См. :meth:`SSLContext.set_ciphers`."

#: ../../library/ssl.rst:1673
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Загрузите набор сертификатов «центра сертификации» (CA) по умолчанию из пути "
"файловой системы, определенного при создании библиотеки OpenSSL. К "
"сожалению, нет простого способа узнать, удался ли этот метод: ошибка не "
"возвращается, если сертификаты не найдены. Однако, если библиотека OpenSSL "
"предоставляется как часть операционной системы, она, скорее всего, будет "
"настроена правильно."

#: ../../library/ssl.rst:1682
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://www.openssl.org/docs/"
"manmaster/man1/ciphers.html>`_. If no cipher can be selected (because "
"compile-time options or other configuration forbids use of all the specified "
"ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../library/ssl.rst:1690
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"при подключении метод SSL-сокетов :meth:`SSLSocket.cipher` выдаст текущий "
"выбранный шифр."

#: ../../library/ssl.rst:1693
msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr ""
"Наборы шифров TLS 1.3 нельзя отключить с помощью :meth:`~SSLContext."
"set_ciphers`."

#: ../../library/ssl.rst:1698
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Укажите, какие протоколы должен объявлять сокет во время подтверждения SSL/"
"TLS. Это должен быть список строк ASCII, например ``['http/1.1', "
"'spdy/2']``, упорядоченный по предпочтениям. Выбор протокола произойдет во "
"время рукопожатия и будет выполняться в соответствии с :rfc:`7301`. После "
"успешного рукопожатия метод :meth:`SSLSocket.selected_alpn_protocol` вернет "
"согласованный протокол."

#: ../../library/ssl.rst:1705
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Этот метод вызовет :exc:`NotImplementedError`, если :data:`HAS_ALPN` имеет "
"значение ``False``."

#: ../../library/ssl.rst:1712
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Укажите, какие протоколы должен объявлять сокет во время подтверждения SSL/"
"TLS. Это должен быть список строк, например ``['http/1.1', 'spdy/2']``, "
"упорядоченный по предпочтениям. Выбор протокола произойдет во время "
"рукопожатия и будет выполняться в соответствии с `согласованием протокола "
"уровня приложения <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. После успешного рукопожатия метод :meth:"
"`SSLSocket.selected_npn_protocol` вернет согласованный протокол."

#: ../../library/ssl.rst:1720
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Этот метод вызовет :exc:`NotImplementedError`, если :data:`HAS_NPN` имеет "
"значение ``False``."

#: ../../library/ssl.rst:1731
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Зарегистрируйте функцию обратного вызова, которая будет вызываться после "
"получения сообщения подтверждения связи TLS Client Hello сервером SSL/TLS, "
"когда клиент TLS указывает указание имени сервера. Механизм указания имени "
"сервера указан в разделе 3 :rfc:`6066` — Указание имени сервера."

#: ../../library/ssl.rst:1736
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Для каждого ``SSLContext`` может быть установлен только один обратный вызов. "
"Если для *sni_callback* установлено значение «Нет», то обратный вызов "
"отключен. Вызов этой функции в последующий раз отключит ранее "
"зарегистрированный обратный вызов."

#: ../../library/ssl.rst:1740
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"Функция обратного вызова будет вызвана с тремя аргументами; первый — это :"
"class:`ssl.SSLSocket`, второй — это строка, представляющая имя сервера, с "
"которым клиент намеревается связаться (или :const:`None`, если TLS Client "
"Hello не содержит имя сервера) а третий аргумент — это исходный :class:"
"`SSLContext`. Аргумент имени сервера представляет собой текст. Для "
"интернационализированного доменного имени имя сервера представляет собой A-"
"метку IDN (``\"xn--pythn-mua.org\"``)."

#: ../../library/ssl.rst:1748
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"Типичное использование этого обратного вызова — изменение атрибута :attr:"
"`SSLSocket.context` :class:`ssl.SSLSocket` на новый объект типа :class:"
"`SSLContext`, представляющий цепочку сертификатов, соответствующую имени "
"сервера. ."

#: ../../library/ssl.rst:1753
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` and :meth:`SSLSocket.compression` "
"methods require that the TLS connection has progressed beyond the TLS Client "
"Hello and therefore will not return meaningful values nor can they be called "
"safely."
msgstr ""
"Из-за ранней фазы согласования TLS-соединения можно использовать только "
"ограниченные методы и атрибуты, такие как :meth:`SSLSocket."
"selected_alpn_protocol` и :attr:`SSLSocket.context`. Методы :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.cipher` и :meth:`SSLSocket.compression` "
"требуют, чтобы TLS-соединение вышло за пределы TLS Client Hello, и поэтому "
"не будут возвращать значимые значения и не могут вызываться безопасно."

#: ../../library/ssl.rst:1761
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"Функция *sni_callback* должна возвращать None, чтобы разрешить продолжение "
"согласования TLS. Если требуется сбой TLS, может быть возвращена константа :"
"const:`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>`. Другие "
"возвращаемые значения приведут к фатальной ошибке TLS с :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."

#: ../../library/ssl.rst:1767
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Если в функции *sni_callback* возникает исключение, соединение TLS прервется "
"с неустранимым предупреждающим сообщением TLS :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

#: ../../library/ssl.rst:1771
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Этот метод вызовет :exc:`NotImplementedError`, если в библиотеке OpenSSL при "
"ее сборке был определен OPENSSL_NO_TLSEXT."

#: ../../library/ssl.rst:1778
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Это устаревший API, сохраненный для обратной совместимости. По возможности "
"вместо этого следует использовать :attr:`sni_callback`. Данное "
"*server_name_callback* аналогично *sni_callback*, за исключением того, что, "
"когда имя хоста сервера является интернационализированным доменным именем в "
"кодировке IDN, *server_name_callback* получает декодированную U-метку "
"(``\"pythön.org\"``)."

#: ../../library/ssl.rst:1784
msgid ""
"If there is an decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""

#: ../../library/ssl.rst:1792
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Загрузите параметры генерации ключей для обмена ключами Диффи-Хеллмана (DH). "
"Использование обмена ключами DH улучшает прямую секретность за счет "
"вычислительных ресурсов (как на сервере, так и на клиенте). Параметр "
"*dhfile* должен указывать путь к файлу, содержащему параметры DH в формате "
"PEM."

#: ../../library/ssl.rst:1798
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Этот параметр не применяется к клиентским сокетам. Вы также можете "
"использовать опцию :data:`OP_SINGLE_DH_USE` для дальнейшего повышения "
"безопасности."

#: ../../library/ssl.rst:1805
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Задайте имя кривой для обмена ключами Диффи-Хеллмана (ECDH) на основе "
"эллиптической кривой. ECDH значительно быстрее обычного DH, но при этом, "
"возможно, столь же безопасен. Параметр *curve_name* должен представлять "
"собой строку, описывающую хорошо известную эллиптическую кривую, например "
"«prime256v1» для широко поддерживаемой кривой."

#: ../../library/ssl.rst:1811
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Этот параметр не применяется к клиентским сокетам. Вы также можете "
"использовать опцию :data:`OP_SINGLE_ECDH_USE` для дальнейшего повышения "
"безопасности."

#: ../../library/ssl.rst:1814
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Этот метод недоступен, если :data:`HAS_ECDH` имеет значение ``False``."

#: ../../library/ssl.rst:1819
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.im/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""

#: ../../library/ssl.rst:1820
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1826
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :data:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""

#: ../../library/ssl.rst:1832
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"Параметр server_side представляет собой логическое значение, которое "
"определяет, требуется ли от этого сокета поведение на стороне сервера или на "
"стороне клиента."

#: ../../library/ssl.rst:1835
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"Для клиентских сокетов построение контекста является ленивым; если базовый "
"сокет еще не подключен, построение контекста будет выполнено после вызова :"
"meth:`connect` в сокете. Для сокетов на стороне сервера, если у сокета нет "
"удаленного узла, предполагается, что он является прослушивающим сокетом, а "
"упаковка SSL на стороне сервера автоматически выполняется для клиентских "
"подключений, принятых с помощью метода :meth:`accept`. Этот метод может "
"вызвать ошибку :exc:`SSLError`."

#: ../../library/ssl.rst:1843
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"При клиентских подключениях необязательный параметр *server_hostname* "
"указывает имя хоста службы, к которой мы подключаемся. Это позволяет на "
"одном сервере размещать несколько служб на основе SSL с разными "
"сертификатами, что очень похоже на виртуальные хосты HTTP. Указание "
"*server_hostname* вызовет ошибку :exc:`ValueError`, если *server_side* имеет "
"значение true."

#: ../../library/ssl.rst:1849
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"Параметр do_handshake_on_connect определяет, будет ли SSL-подтверждение "
"выполняться автоматически после выполнения :meth:`socket.connect` или же "
"прикладная программа будет вызывать его явно, вызывая метод :meth:`SSLSocket."
"do_handshake`. Вызов :meth:`SSLSocket.do_handshake` явно дает программе "
"контроль над поведением блокировки сокетного ввода-вывода, участвующего в "
"рукопожатии."

#: ../../library/ssl.rst:1856
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"Параметр ``suppress_ragged_eofs`` определяет, как метод :meth:`SSLSocket."
"recv` должен сигнализировать о неожиданном EOF с другого конца соединения. "
"Если указано как :const:`True` (по умолчанию), он возвращает обычный EOF "
"(объект с пустыми байтами) в ответ на неожиданные ошибки EOF, возникшие из "
"базового сокета; если :const:`False`, исключения будут возвращены вызывающей "
"стороне."

#: ../../library/ssl.rst:1863
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, см. :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:1865
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Всегда разрешайте передачу server_hostname, даже если OpenSSL не имеет SNI."

#: ../../library/ssl.rst:1869 ../../library/ssl.rst:1895
msgid "*session* argument was added."
msgstr "Добавлен аргумент *session*."

#: ../../library/ssl.rst:1872
msgid ""
"The method returns on instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""

#: ../../library/ssl.rst:1878
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLSocket`."
msgstr ""
"Тип возвращаемого значения :meth:`SSLContext.wrap_socket` по умолчанию "
"равен :class:`SSLSocket`. Атрибут можно переопределить в экземпляре класса, "
"чтобы вернуть пользовательский подкласс :class:`SSLSocket`."

#: ../../library/ssl.rst:1887
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Оберните *входящие* и *исходящие* объекты BIO и верните экземпляр :attr:"
"`SSLContext.sslobject_class` (по умолчанию :class:`SSLObject`). Подпрограммы "
"SSL будут считывать входные данные из входящего BIO и записывать данные в "
"исходящий BIO."

#: ../../library/ssl.rst:1892
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Параметры *server_side*, *server_hostname* и *session* имеют то же значение, "
"что и в :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:1898
msgid ""
"The method returns on instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""

#: ../../library/ssl.rst:1904
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
"Тип возвращаемого значения :meth:`SSLContext.wrap_bio` по умолчанию равен :"
"class:`SSLObject`. Атрибут можно переопределить в экземпляре класса, чтобы "
"вернуть пользовательский подкласс :class:`SSLObject`."

#: ../../library/ssl.rst:1912
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_number.html>`_ to "
"their numeric values.  For example, here is the total number of hits and "
"misses in the session cache since the context was created::"
msgstr ""

#: ../../library/ssl.rst:1923
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"Соответствовать ли имени хоста однорангового сертификата в :meth:`SSLSocket."
"do_handshake`. Для :attr:`~SSLContext.verify_mode` контекста должно быть "
"установлено значение :data:`CERT_OPTIONAL` или :data:`CERT_REQUIRED`, и вы "
"должны передать *server_hostname* в :meth:`~SSLContext.wrap_socket` для "
"соответствия имя хоста. Включение проверки имени хоста автоматически "
"изменяет :attr:`~SSLContext.verify_mode` с :data:`CERT_NONE` на :data:"
"`CERT_REQUIRED`. Его нельзя вернуть обратно в :data:`CERT_NONE`, пока "
"включена проверка имени хоста. Протокол :data:`PROTOCOL_TLS_CLIENT` по "
"умолчанию включает проверку имени хоста. В других протоколах проверка имени "
"хоста должна быть включена явно."

#: ../../library/ssl.rst:1951
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSLContext.verify_mode` теперь автоматически меняется на :data:"
"`CERT_REQUIRED`, когда включена проверка имени хоста, а :attr:`~SSLContext."
"verify_mode` имеет значение :data:`CERT_NONE`. Раньше та же операция "
"завершалась бы неудачно с ошибкой :exc:`ValueError`."

#: ../../library/ssl.rst:1958
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Записывайте ключи TLS в файл журнала ключей при каждом создании или "
"получении материала ключа. Файл журнала ключей предназначен только для целей "
"отладки. Формат файла определяется NSS и используется многими анализаторами "
"трафика, такими как Wireshark. Файл журнала открывается в режиме только "
"добавления. Запись синхронизируется между потоками, но не между процессами."

#: ../../library/ssl.rst:1968
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :attr:`PROTOCOL_TLS`, :attr:"
"`PROTOCOL_TLS_CLIENT`, and :attr:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Член перечисления :class:`TLSVersion`, представляющий самую высокую "
"поддерживаемую версию TLS. По умолчанию используется значение :attr:"
"`TLSVersion.MAXIMUM_SUPPORTED`. Атрибут доступен только для чтения для "
"протоколов, отличных от :attr:`PROTOCOL_TLS`, :attr:`PROTOCOL_TLS_CLIENT` и :"
"attr:`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:1973
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"Атрибуты :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` и :attr:`SSLContext.options` влияют на поддерживаемые "
"версии контекста SSL и TLS. Реализация не предотвращает недопустимую "
"комбинацию. Например, контекст с :attr:`OP_NO_TLSv1_2` в :attr:`~SSLContext."
"options` и :attr:`~SSLContext.maximum_version` со значением :attr:"
"`TLSVersion.TLSv1_2` не сможет установить TLS 1.2. связь."

#: ../../library/ssl.rst:1986
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Аналогично :attr:`SSLContext.maximum_version`, за исключением того, что это "
"самая низкая поддерживаемая версия или :attr:`TLSVersion.MINIMUM_SUPPORTED`."

#: ../../library/ssl.rst:1993
msgid ""
"Control the number of TLS 1.3 session tickets of a :attr:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""
"Управляйте количеством билетов сеанса TLS 1.3 контекста :attr:"
"`PROTOCOL_TLS_SERVER`. Этот параметр не влияет на соединения TLS 1.0–1.2."

#: ../../library/ssl.rst:2001
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Целое число, представляющее набор параметров SSL, включенных в этом "
"контексте. Значением по умолчанию является :data:`OP_ALL`, но вы можете "
"указать другие параметры, такие как :data:`OP_NO_SSLv2`, соединив их вместе "
"с помощью OR."

#: ../../library/ssl.rst:2005
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` возвращает флаги :class:`Options`:"

#: ../../library/ssl.rst:2013
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""
"Все параметры ``OP_NO_SSL*`` и ``OP_NO_TLS*`` устарели, начиная с Python "
"3.7. Вместо этого используйте :attr:`SSLContext.minimum_version` и :attr:"
"`SSLContext.maximum_version`."

#: ../../library/ssl.rst:2019
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Включите аутентификацию клиента после подтверждения TLS 1.3. По умолчанию "
"аутентификация после рукопожатия отключена, и сервер может запрашивать "
"сертификат клиента TLS только во время первоначального рукопожатия. Если "
"этот параметр включен, сервер может запросить сертификат клиента TLS в любое "
"время после рукопожатия."

#: ../../library/ssl.rst:2024
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"При включении сокетов на стороне клиента клиент сигнализирует серверу, что "
"поддерживает аутентификацию после рукопожатия."

#: ../../library/ssl.rst:2027
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"При включении в сокетах на стороне сервера для :attr:`SSLContext."
"verify_mode` также должно быть установлено значение :data:`CERT_OPTIONAL` "
"или :data:`CERT_REQUIRED`. Фактический обмен сертификатами клиента "
"откладывается до тех пор, пока не будет вызван :meth:`SSLSocket."
"verify_client_post_handshake` и не будут выполнены некоторые операции ввода-"
"вывода."

#: ../../library/ssl.rst:2037
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"Версия протокола, выбранная при построении контекста. Этот атрибут доступен "
"только для чтения."

#: ../../library/ssl.rst:2042
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Возвращается ли :attr:`~SSLContext.check_hostname` для проверки общего имени "
"субъекта сертификата при отсутствии расширения альтернативного имени "
"субъекта (по умолчанию: true)."

#: ../../library/ssl.rst:2050
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1k. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""

#: ../../library/ssl.rst:2055
msgid ""
"An integer representing the `security level <https://www.openssl.org/docs/"
"manmaster/man3/SSL_CTX_get_security_level.html>`_ for the context. This "
"attribute is read-only."
msgstr ""

#: ../../library/ssl.rst:2063
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"Флаги операций проверки сертификата. Вы можете установить такие флаги, как :"
"data:`VERIFY_CRL_CHECK_LEAF`, соединив их вместе с помощью ИЛИ. По умолчанию "
"OpenSSL не требует и не проверяет списки отзыва сертификатов (CRL)."

#: ../../library/ssl.rst:2069
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags` возвращает флаги :class:`VerifyFlags`:"

#: ../../library/ssl.rst:2077
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Стоит ли пытаться проверить сертификаты других узлов и как действовать, если "
"проверка не удалась. Этот атрибут должен быть одним из :data:`CERT_NONE`, :"
"data:`CERT_OPTIONAL` или :data:`CERT_REQUIRED`."

#: ../../library/ssl.rst:2081
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ""
":attr:`SSLContext.verify_mode` возвращает :class:`VerifyMode` перечисление:"

#: ../../library/ssl.rst:2094
msgid "Certificates"
msgstr "Сертификаты"

#: ../../library/ssl.rst:2096
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"Сертификаты в целом являются частью системы открытого/закрытого ключей. В "
"этой системе каждому *участнику* (которым может быть машина, человек или "
"организация) назначается уникальный ключ шифрования, состоящий из двух "
"частей. Одна часть ключа является общедоступной и называется *открытым "
"ключом*; другая часть хранится в секрете и называется *закрытым ключом*. Эти "
"две части связаны тем, что если вы зашифруете сообщение с помощью одной из "
"частей, вы сможете расшифровать его с помощью другой части, и **только** с "
"помощью другой части."

#: ../../library/ssl.rst:2104
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Сертификат содержит информацию о двух принципалах. Он содержит имя "
"*субъекта* и открытый ключ субъекта. Он также содержит заявление второго "
"принципала, *эмитента*, о том, что субъект является тем, кем он себя "
"называет, и что это действительно открытый ключ субъекта. Заявление эмитента "
"подписывается закрытым ключом эмитента, который известен только эмитенту. "
"Однако любой может проверить заявление эмитента, найдя открытый ключ "
"эмитента, расшифровав с его помощью заявление и сравнив его с другой "
"информацией в сертификате. Сертификат также содержит информацию о периоде "
"времени, в течение которого он действителен. Это выражается в двух полях, "
"называемых «notBefore» и «notAfter»."

#: ../../library/ssl.rst:2114
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"При использовании сертификатов в Python клиент или сервер могут использовать "
"сертификат, чтобы доказать, кем они являются. Другой стороне сетевого "
"подключения также может потребоваться выдать сертификат, и этот сертификат "
"может быть проверен в соответствии с требованиями клиента или сервера, "
"которому требуется такая проверка. Попытку подключения можно настроить так, "
"чтобы она вызывала исключение в случае неудачной проверки. Проверка "
"выполняется автоматически базовой платформой OpenSSL; приложению не нужно "
"беспокоиться о своей механике. Но для осуществления этого процесса "
"приложению обычно необходимо предоставить наборы сертификатов."

#: ../../library/ssl.rst:2124
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"Python использует файлы для хранения сертификатов. Они должны быть "
"отформатированы как «PEM» (см. :rfc:`1422`), который представляет собой "
"форму в кодировке Base64, обернутую строкой заголовка и строкой нижнего "
"колонтитула:"

#: ../../library/ssl.rst:2133
msgid "Certificate chains"
msgstr "Цепочки сертификатов"

#: ../../library/ssl.rst:2135
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"Файлы Python, содержащие сертификаты, могут содержать последовательность "
"сертификатов, иногда называемую *цепочкой сертификатов*. Эта цепочка должна "
"начинаться с конкретного сертификата для принципала, который «является» "
"клиентом или сервером, затем сертификата для эмитента этого сертификата, а "
"затем сертификата для эмитента *этого* сертификата, и так далее по цепочке. "
"пока вы не дойдете до *самозаверяющего* сертификата, то есть сертификата, "
"имеющего тот же субъект и того же эмитента, который иногда называют "
"*корневым сертификатом*. Сертификаты следует просто объединить в файл "
"сертификата. Например, предположим, что у нас есть цепочка из трех "
"сертификатов: от сертификата нашего сервера до сертификата центра "
"сертификации, подписавшего наш сертификат сервера, до корневого сертификата "
"агентства, выдавшего сертификат центра сертификации:"

#: ../../library/ssl.rst:2159
msgid "CA certificates"
msgstr "Сертификаты CA"

#: ../../library/ssl.rst:2161
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"Если вам потребуется проверка другой стороны сертификата соединения, вам "
"необходимо предоставить файл «CA сертификаты», заполненный цепочками "
"сертификатов для каждого эмитента, которому вы готовы доверять. Опять же, "
"этот файл просто содержит эти цепочки, объединенные вместе. Для проверки "
"Python будет использовать первую найденную цепочку в файле, который "
"соответствует. Файл сертификатов платформы можно использовать, вызвав :meth:"
"`SSLContext.load_default_certs`, это делается автоматически с помощью :func:"
"`.create_default_context`."

#: ../../library/ssl.rst:2170
msgid "Combined key and certificate"
msgstr "Комбинированный ключ и сертификат"

#: ../../library/ssl.rst:2172
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""

#: ../../library/ssl.rst:2186
msgid "Self-signed certificates"
msgstr "Самоподписанные сертификаты"

#: ../../library/ssl.rst:2188
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Если вы собираетесь создать сервер, предоставляющий службы соединений с "
"шифрованием SSL, вам необходимо будет приобрести сертификат для этой службы. "
"Существует множество способов получения соответствующих сертификатов, "
"например покупка сертификата в центре сертификации. Другая распространенная "
"практика — создание самозаверяющего сертификата. Самый простой способ "
"сделать это — использовать пакет OpenSSL, используя что-то вроде следующего:"

#: ../../library/ssl.rst:2217
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"Недостаток самозаверяющего сертификата заключается в том, что это "
"собственный корневой сертификат, и никто другой не будет иметь его в своем "
"кеше известных (и доверенных) корневых сертификатов."

#: ../../library/ssl.rst:2223
msgid "Examples"
msgstr "Примеры"

#: ../../library/ssl.rst:2226
msgid "Testing for SSL support"
msgstr "Тестирование поддержки SSL"

#: ../../library/ssl.rst:2228
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"Чтобы проверить наличие поддержки SSL в установке Python, пользовательский "
"код должен использовать следующую идиому:"

#: ../../library/ssl.rst:2239
msgid "Client-side operation"
msgstr "Работа на стороне клиента"

#: ../../library/ssl.rst:2241
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"В этом примере создается контекст SSL с рекомендуемыми настройками "
"безопасности для клиентских сокетов, включая автоматическую проверку "
"сертификата:"

#: ../../library/ssl.rst:2246
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Если вы предпочитаете настраивать параметры безопасности самостоятельно, вы "
"можете создать контекст с нуля (но будьте осторожны, вы можете неправильно "
"настроить параметры)::"

#: ../../library/ssl.rst:2253
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(в этом фрагменте предполагается, что ваша операционная система помещает "
"пакет всех сертификатов CA в ``/etc/ssl/certs/ca-bundle.crt``; в противном "
"случае вы получите сообщение об ошибке и вам придется изменить "
"местоположение)"

#: ../../library/ssl.rst:2257
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"Протокол :data:`PROTOCOL_TLS_CLIENT` настраивает контекст для проверки "
"сертификатов и проверки имени хоста. Для :attr:`~SSLContext.verify_mode` "
"установлено значение :data:`CERT_REQUIRED`, а для :attr:`~SSLContext."
"check_hostname` установлено значение ``True``. Все остальные протоколы "
"создают контексты SSL с небезопасными настройками по умолчанию."

#: ../../library/ssl.rst:2262
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"Когда вы используете контекст для подключения к серверу, :const:"
"`CERT_REQUIRED` и :attr:`~SSLContext.check_hostname` проверяют сертификат "
"сервера: они гарантируют, что сертификат сервера был подписан одним из "
"сертификатов CA, проверяет подпись на правильность и проверяет другие "
"свойства, такие как достоверность и идентичность имени хоста::"

#: ../../library/ssl.rst:2272
msgid "You may then fetch the certificate::"
msgstr "Затем вы можете получить сертификат::"

#: ../../library/ssl.rst:2276
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"Визуальная проверка показывает, что сертификат действительно идентифицирует "
"нужную службу (то есть хост HTTPS www.python.org):"

#: ../../library/ssl.rst:2319
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Теперь SSL-канал установлен и сертификат проверен, можно приступать к "
"общению с сервером:"

#: ../../library/ssl.rst:2346
msgid "Server-side operation"
msgstr "Работа на стороне сервера"

#: ../../library/ssl.rst:2348
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"Для работы сервера обычно вам необходимо иметь сертификат сервера и закрытый "
"ключ, каждый из которых находится в файле. Сначала вы создадите контекст, "
"содержащий ключ и сертификат, чтобы клиенты могли проверить вашу "
"подлинность. Затем вы открываете сокет, привязываете его к порту, вызываете "
"на нем :meth:`listen` и начинаете ждать подключения клиентов::"

#: ../../library/ssl.rst:2363
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"Когда клиент подключается, вы вызываете :meth:`accept` для сокета, чтобы "
"получить новый сокет с другого конца, и используете контекстный метод :meth:"
"`SSLContext.wrap_socket` для создания SSL-сокета на стороне сервера для "
"соединение::"

#: ../../library/ssl.rst:2376
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Затем вы будете читать данные из ``connstream`` и что-то делать с ними, пока "
"не закончите работу с клиентом (или клиент не закончит работу с вами)::"

#: ../../library/ssl.rst:2390
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"И вернитесь к прослушиванию новых клиентских подключений (конечно, реальный "
"сервер, вероятно, будет обрабатывать каждое клиентское соединение в "
"отдельном потоке или переведет сокеты в :ref:`неблокирующий режим <ssl-"
"nonblocking>` и будет использовать событие петля)."

#: ../../library/ssl.rst:2398
msgid "Notes on non-blocking sockets"
msgstr "Примечания о неблокирующих сокетах"

#: ../../library/ssl.rst:2400
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"Сокеты SSL ведут себя немного иначе, чем обычные сокеты в неблокирующем "
"режиме. Таким образом, при работе с неблокирующими сокетами необходимо "
"учитывать несколько вещей:"

#: ../../library/ssl.rst:2404
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"Большинство методов :class:`SSLSocket` вызовут либо :exc:"
"`SSLWantWriteError`, либо :exc:`SSLWantReadError` вместо :exc:"
"`BlockingIOError`, если операция ввода-вывода блокируется. :exc:"
"`SSLWantReadError` будет вызываться, если необходима операция чтения в "
"базовом сокете, и :exc:`SSLWantWriteError` для операции записи в базовом "
"сокете. Обратите внимание, что попытки *записи* в сокет SSL могут сначала "
"потребовать *чтения* из базового сокета, а попытки *чтения* из сокета SSL "
"могут потребовать предварительной *записи* в базовый сокет."

#: ../../library/ssl.rst:2416
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"В более ранних версиях Python метод :meth:`!SSLSocket.send` возвращал ноль "
"вместо вызова :exc:`SSLWantWriteError` или :exc:`SSLWantReadError`."

#: ../../library/ssl.rst:2420
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"Вызов :func:`~select.select` сообщает вам, что сокет уровня ОС можно читать "
"(или записывать), но это не означает, что на верхнем уровне SSL имеется "
"достаточно данных. Например, могла быть доставлена ​​только часть кадра SSL. "
"Поэтому вы должны быть готовы обработать сбои :meth:`SSLSocket.recv` и :meth:"
"`SSLSocket.send` и повторить попытку после следующего вызова :func:`~select."
"select`."

#: ../../library/ssl.rst:2427
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"И наоборот, поскольку уровень SSL имеет свою собственную структуру, сокет "
"SSL может по-прежнему иметь данные, доступные для чтения, без :func:`~select."
"select` ведома об этом. Поэтому вам следует сначала вызвать :meth:`SSLSocket."
"recv`, чтобы удалить любые потенциально доступные данные, а затем "
"заблокировать вызов :func:`~select.select` только в том случае, если это все "
"еще необходимо."

#: ../../library/ssl.rst:2433
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(конечно, аналогичные положения применяются и при использовании других "
"примитивов, таких как :func:`~select.poll` или тех, которые находятся в "
"модуле :mod:`selectors`)"

#: ../../library/ssl.rst:2436
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"Само рукопожатие SSL будет неблокирующим: метод :meth:`SSLSocket."
"do_handshake` необходимо повторять до тех пор, пока он не вернется успешно. "
"Вот краткий обзор использования :func:`~select.select` для ожидания "
"готовности сокета::"

#: ../../library/ssl.rst:2452
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level API. It polls for events using "
"the :mod:`selectors` module and handles :exc:`SSLWantWriteError`, :exc:"
"`SSLWantReadError` and :exc:`BlockingIOError` exceptions. It runs the SSL "
"handshake asynchronously as well."
msgstr ""
"Модуль :mod:`asyncio` поддерживает :ref:`неблокирующие SSL-сокеты <ssl-"
"nonblocking>` и предоставляет API более высокого уровня. Он опрашивает "
"события с помощью модуля :mod:`selectors` и обрабатывает исключения :exc:"
"`SSLWantWriteError`, :exc:`SSLWantReadError` и :exc:`BlockingIOError`. Он "
"также выполняет подтверждение SSL асинхронно."

#: ../../library/ssl.rst:2461
msgid "Memory BIO Support"
msgstr "Поддержка памяти BIO"

#: ../../library/ssl.rst:2465
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"С тех пор, как модуль SSL был представлен в Python 2.6, класс :class:"
"`SSLSocket` предоставил две связанные, но разные области функциональности:"

#: ../../library/ssl.rst:2468
msgid "SSL protocol handling"
msgstr "Обработка протокола SSL"

#: ../../library/ssl.rst:2469
msgid "Network IO"
msgstr "Сетевой ввод-вывод"

#: ../../library/ssl.rst:2471
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"Сетевой API ввода-вывода идентичен тому, который предоставляется :class:"
"`socket.socket`, от которого также наследуется :class:`SSLSocket`. Это "
"позволяет использовать сокет SSL в качестве замены обычного сокета, что "
"упрощает добавление поддержки SSL в существующее приложение."

#: ../../library/ssl.rst:2476
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"Сочетание обработки протокола SSL и сетевого ввода-вывода обычно работает "
"хорошо, но в некоторых случаях это не так. Примером являются асинхронные "
"платформы ввода-вывода, которые хотят использовать другую модель "
"мультиплексирования ввода-вывода, отличную от модели «выбор/опрос файлового "
"дескриптора» (на основе готовности), которая предполагается классом:`socket."
"socket` и внутренним вводом-выводом сокета OpenSSL. процедуры. Это в "
"основном актуально для таких платформ, как Windows, где эта модель "
"неэффективна. Для этой цели предусмотрен вариант :class:`SSLSocket` с "
"ограниченной областью действия, называемый :class:`SSLObject`."

#: ../../library/ssl.rst:2487
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"Вариант :class:`SSLSocket` с ограниченной областью действия, представляющий "
"экземпляр протокола SSL, который не содержит никаких сетевых методов ввода-"
"вывода. Этот класс обычно используется авторами платформы, которые хотят "
"реализовать асинхронный ввод-вывод для SSL через буферы памяти."

#: ../../library/ssl.rst:2492
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Этот класс реализует интерфейс поверх объекта SSL низкого уровня, "
"реализованного OpenSSL. Этот объект фиксирует состояние SSL-соединения, но "
"сам не предоставляет никаких сетевых операций ввода-вывода. Ввод-вывод "
"должен выполняться через отдельные объекты «BIO», которые являются уровнем "
"абстракции ввода-вывода OpenSSL."

#: ../../library/ssl.rst:2497
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"У этого класса нет открытого конструктора. Экземпляр :class:`SSLObject` "
"должен быть создан с использованием метода :meth:`~SSLContext.wrap_bio`. "
"Этот метод создаст экземпляр :class:`SSLObject` и привяжет его к паре BIO. "
"*Входящий* BIO используется для передачи данных из Python в экземпляр "
"протокола SSL, а *исходящий* BIO используется для передачи данных наоборот."

#: ../../library/ssl.rst:2504
msgid "The following methods are available:"
msgstr "Доступны следующие методы:"

#: ../../library/ssl.rst:2506
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2507
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2508
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2509
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2510
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2511
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2512
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2513
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2514
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2515
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2516
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2517
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2518
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2519
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2520
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2521
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2522
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2523
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2524
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2526
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"По сравнению с :class:`SSLSocket`, этот объект лишен следующих функций:"

#: ../../library/ssl.rst:2529
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""
"Любая форма сетевого ввода-вывода; ``recv()`` и ``send()`` читают и "
"записывают только в базовые буферы :class:`MemoryBIO`."

#: ../../library/ssl.rst:2532
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"Механизма *do_handshake_on_connect* нет. Вы всегда должны вручную вызывать :"
"meth:`~SSLSocket.do_handshake`, чтобы начать рукопожатие."

#: ../../library/ssl.rst:2535
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"Обработка *suppress_ragged_eofs* не производится. Обо всех состояниях конца "
"файла, нарушающих протокол, сообщается через исключение :exc:`SSLEOFError`."

#: ../../library/ssl.rst:2539
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"Вызов метода :meth:`~SSLSocket.unwrap` ничего не возвращает, в отличие от "
"сокета SSL, где он возвращает базовый сокет."

#: ../../library/ssl.rst:2542
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"Обратный вызов *server_name_callback*, переданный в :meth:`SSLContext."
"set_servername_callback`, получит экземпляр :class:`SSLObject` вместо "
"экземпляра :class:`SSLSocket` в качестве первого параметра."

#: ../../library/ssl.rst:2546
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "Некоторые примечания, связанные с использованием :class:`SSLObject`:"

#: ../../library/ssl.rst:2548
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
"Все операции ввода-вывода на :class:`SSLObject` являются :ref:"
"`неблокирующими <ssl-nonblocking>`. Это означает, что, например, :meth:"
"`~SSLSocket.read` вызовет :exc:`SSLWantReadError`, если ему нужно больше "
"данных, чем доступно входящему BIO."

#: ../../library/ssl.rst:2553
msgid ""
"There is no module-level ``wrap_bio()`` call like there is for :meth:"
"`~SSLContext.wrap_socket`. An :class:`SSLObject` is always created via an :"
"class:`SSLContext`."
msgstr ""

#: ../../library/ssl.rst:2557
msgid ""
":class:`SSLObject` instances must to created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""

#: ../../library/ssl.rst:2563
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"SSLObject взаимодействует с внешним миром, используя буферы памяти. Класс :"
"class:`MemoryBIO` предоставляет буфер памяти, который можно использовать для "
"этой цели. Он оборачивает объект памяти OpenSSL BIO (Basic IO):"

#: ../../library/ssl.rst:2569
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"Буфер памяти, который можно использовать для передачи данных между Python и "
"экземпляром протокола SSL."

#: ../../library/ssl.rst:2574
msgid "Return the number of bytes currently in the memory buffer."
msgstr ""
"Возвращает количество байтов, находящихся в данный момент в буфере памяти."

#: ../../library/ssl.rst:2578
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"Логическое значение, указывающее, является ли память BIO текущей в позиции "
"конца файла."

#: ../../library/ssl.rst:2583
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Считайте до *n* байт из буфера памяти. Если *n* не указано или отрицательное "
"значение, возвращаются все байты."

#: ../../library/ssl.rst:2588
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Запишите байты из *buf* в память BIO. Аргумент *buf* должен быть объектом, "
"поддерживающим протокол буфера."

#: ../../library/ssl.rst:2591
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"Возвращаемое значение — это количество записанных байтов, которое всегда "
"равно длине *buf*."

#: ../../library/ssl.rst:2596
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"Запишите маркер EOF в память BIO. После вызова этого метода вызов :meth:"
"`~MemoryBIO.write` недопустим. Атрибут :attr:`eof` станет истинным после "
"того, как все данные, находящиеся в данный момент в буфере, будут прочитаны."

#: ../../library/ssl.rst:2602
msgid "SSL session"
msgstr "SSL-сессия"

#: ../../library/ssl.rst:2608
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Объект сеанса, используемый :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:2620
msgid "Security considerations"
msgstr "Соображения безопасности"

#: ../../library/ssl.rst:2623
msgid "Best defaults"
msgstr "Лучшие занчения по умолчанию"

#: ../../library/ssl.rst:2625
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"При **клиентском использовании**, если у вас нет каких-либо особых "
"требований к вашей политике безопасности, настоятельно рекомендуется "
"использовать функцию :func:`create_default_context` для создания контекста "
"SSL. Он загрузит доверенные сертификаты ЦС системы, включит проверку "
"сертификатов и проверку имени хоста, а также попытается выбрать достаточно "
"безопасный протокол и настройки шифрования."

#: ../../library/ssl.rst:2632
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Например, вот как можно использовать класс :class:`smtplib.SMTP` для "
"создания доверенного и безопасного соединения с SMTP-сервером:"

#: ../../library/ssl.rst:2641
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Если для соединения необходим сертификат клиента, его можно добавить с "
"помощью :meth:`SSLContext.load_cert_chain`."

#: ../../library/ssl.rst:2644
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Напротив, если вы создаете контекст SSL, вызывая конструктор :class:"
"`SSLContext` самостоятельно, по умолчанию в нем не будет включена ни "
"проверка сертификата, ни проверка имени хоста. Если вы это сделаете, "
"пожалуйста, прочитайте параграфы ниже, чтобы достичь хорошего уровня "
"безопасности."

#: ../../library/ssl.rst:2650
msgid "Manual settings"
msgstr "Ручные настройки"

#: ../../library/ssl.rst:2653
msgid "Verifying certificates"
msgstr "Проверка сертификатов"

#: ../../library/ssl.rst:2655
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of time you would "
"like to ensure the authenticity of the server you're talking to. Therefore, "
"when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used.  This common check is "
"automatically performed when :attr:`SSLContext.check_hostname` is enabled."
msgstr ""

#: ../../library/ssl.rst:2668
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`match_hostname`."
msgstr ""
"Сопоставление имен хостов теперь выполняется OpenSSL. Python больше не "
"использует :func:`match_hostname`."

#: ../../library/ssl.rst:2672
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"В режиме сервера, если вы хотите аутентифицировать своих клиентов с "
"использованием уровня SSL (вместо использования механизма аутентификации "
"более высокого уровня), вам также придется указать :const:`CERT_REQUIRED` и "
"аналогичным образом проверить сертификат клиента."

#: ../../library/ssl.rst:2678
msgid "Protocol versions"
msgstr "Версии протоколов"

#: ../../library/ssl.rst:2680
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"SSL версии 2 и 3 считаются небезопасными и поэтому их опасно использовать. "
"Если вам нужна максимальная совместимость между клиентами и серверами, "
"рекомендуется использовать :const:`PROTOCOL_TLS_CLIENT` или :const:"
"`PROTOCOL_TLS_SERVER` в качестве версии протокола. SSLv2 и SSLv3 отключены "
"по умолчанию."

#: ../../library/ssl.rst:2693
msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"Созданный выше контекст SSL позволит подключаться к серверу только по "
"протоколу TLSv1.3 и более поздних версий (если поддерживается вашей "
"системой). :const:`PROTOCOL_TLS_CLIENT` по умолчанию подразумевает проверку "
"сертификата и проверку имени хоста. Вам необходимо загрузить сертификаты в "
"контекст."

#: ../../library/ssl.rst:2700
msgid "Cipher selection"
msgstr "Выбор шифра"

#: ../../library/ssl.rst:2702
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://www.openssl.org/docs/man1.1.1/man1/ciphers."
"html#CIPHER-LIST-FORMAT>`_. If you want to check which ciphers are enabled "
"by a given cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl "
"ciphers`` command on your system."
msgstr ""

#: ../../library/ssl.rst:2713
msgid "Multi-processing"
msgstr "Мультиобработка"

#: ../../library/ssl.rst:2715
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:"
"`~ssl.RAND_pseudo_bytes` is sufficient."
msgstr ""

#: ../../library/ssl.rst:2727
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2731
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"Протокол TLS 1.3 ведет себя немного иначе, чем предыдущая версия TLS/SSL. "
"Некоторые новые функции TLS 1.3 пока недоступны."

#: ../../library/ssl.rst:2734
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"TLS 1.3 использует разрозненный набор наборов шифров. Все наборы шифров AES-"
"GCM и ChaCha20 включены по умолчанию. Метод :meth:`SSLContext.set_ciphers` "
"пока не может включать или отключать какие-либо шифры TLS 1.3, но :meth:"
"`SSLContext.get_ciphers` возвращает их."

#: ../../library/ssl.rst:2738
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Билеты сеанса больше не отправляются как часть первоначального рукопожатия и "
"обрабатываются по-другому. :attr:`SSLSocket.session` и :class:`SSLSession` "
"несовместимы с TLS 1.3."

#: ../../library/ssl.rst:2741
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Сертификаты на стороне клиента также больше не проверяются во время "
"первоначального подтверждения. Сервер может запросить сертификат в любое "
"время. Клиенты обрабатывают запросы сертификатов во время отправки или "
"получения данных приложения с сервера."

#: ../../library/ssl.rst:2745
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"Функции TLS 1.3, такие как ранние данные, отложенный запрос сертификата "
"клиента TLS, настройка алгоритма подписи и смена ключей, пока не "
"поддерживаются."

#: ../../library/ssl.rst:2752
msgid "Class :class:`socket.socket`"
msgstr "Класс :class:`socket.socket`"

#: ../../library/ssl.rst:2752
msgid "Documentation of underlying :mod:`socket` class"
msgstr "Документация базового класса :mod:`socket`"

#: ../../library/ssl.rst:2755
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`Сильное шифрование SSL/TLS: введение <https://httpd.apache.org/docs/trunk/"
"en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2755
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Введение из документации HTTP-сервера Apache."

#: ../../library/ssl.rst:2758
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Повышение конфиденциальности для электронной почты "
"Интернета: Часть II: Управление ключами на основе сертификатов <1422>`"

#: ../../library/ssl.rst:2758
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2761
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Требования случайности для безопасности <4086>`"

#: ../../library/ssl.rst:2761
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Дональд Э., Джеффри И. Шиллер"

#: ../../library/ssl.rst:2764
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Профиль сертификата инфраструктуры открытых ключей Internet "
"X.509 и списка отзыва сертификатов (CRL) <5280>`"

#: ../../library/ssl.rst:2764
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2767
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: Протокол безопасности транспортного уровня (TLS) версии 1.2 "
"<5246>`"

#: ../../library/ssl.rst:2767
msgid "T. Dierks et. al."
msgstr "Т. Диркс и др. к."

#: ../../library/ssl.rst:2770
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ""
":rfc:`RFC 6066: Расширения безопасности транспортного уровня (TLS) <6066>`"

#: ../../library/ssl.rst:2770
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2773
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Параметры безопасности транспортного уровня (TLS) <https://www."
"iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2773
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2776
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Рекомендации по безопасному использованию безопасности "
"транспортного уровня (TLS) и безопасности транспортного уровня дейтаграмм "
"(DTLS) <7525>`"

#: ../../library/ssl.rst:2776
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2778
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Рекомендации Mozilla по серверному TLS <https://wiki.mozilla.org/Security/"
"Server_Side_TLS>`_"

#: ../../library/ssl.rst:2779
msgid "Mozilla"
msgstr "Mozilla"
