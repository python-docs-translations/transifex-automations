# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ""

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Исходный код:** :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-notavail.rst:3
msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""
"Этот модуль не работает или недоступен на платформах WebAssembly «wasm32-"
"emscripten» и «wasm32-wasi». См. :ref:`wasm-availability` для получения "
"дополнительной информации."

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "Введение"

#: ../../library/multiprocessing.rst:16
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both Unix and Windows."
msgstr ""

#: ../../library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the :"
"class:`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""
"Модуль :mod:`multiprocessing` также представляет API, не имеющие аналогов в "
"модуле :mod:`threading`. Ярким примером этого является объект :class:"
"`~multiprocessing.pool.Pool`, который предлагает удобные средства "
"распараллеливания выполнения функции для нескольких входных значений, "
"распределения входных данных по процессам (параллелизм данных). В следующем "
"примере демонстрируется общепринятая практика определения таких функций в "
"модуле, чтобы дочерние процессы могли успешно импортировать этот модуль. Это "
"базовый пример параллелизма данных с использованием :class:`~multiprocessing."
"pool.Pool`, ::"

#: ../../library/multiprocessing.rst:43
msgid "will print to standard output ::"
msgstr "выведет на стандартный вывод::"

#: ../../library/multiprocessing.rst:50
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` предлагает интерфейс более "
"высокого уровня для передачи задач фоновому процессу без блокировки "
"выполнения вызывающего процесса. По сравнению с использованием интерфейса :"
"class:`~multiprocessing.pool.Pool` напрямую, API :mod:`concurrent.futures` "
"позволяет с большей легкостью отделить отправку работы в базовый пул "
"процессов от ожидания результатов."

#: ../../library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr "Класс :class:`Process` "

#: ../../library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"В :mod:`multiprocessing` процессы создаются путем создания объекта :class:"
"`Process` и последующего вызова его метода :meth:`~Process.start`. :class:"
"`Process` следует API :class:`threading.Thread`. Тривиальный пример "
"многопроцессной программы::"

#: ../../library/multiprocessing.rst:76
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"Чтобы показать идентификаторы отдельных процессов, приведем расширенный "
"пример:"

#: ../../library/multiprocessing.rst:97
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"Объяснение того, почему необходима часть ``if __name__ == '__main__'``, см. "
"в разделе :ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:103
msgid "Contexts and start methods"
msgstr "Контексты и методы запуска"

#: ../../library/multiprocessing.rst:107
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"В зависимости от платформы :mod:`multiprocessing` поддерживает три способа "
"запуска процесса. Эти *методы запуска*"

#: ../../library/multiprocessing.rst:118
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:111
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"Родительский процесс запускает новый процесс интерпретатора Python. Дочерний "
"процесс унаследует только те ресурсы, которые необходимы для запуска метода :"
"meth:`~Process.run` объекта процесса. В частности, не будут наследоваться "
"ненужные файловые дескрипторы и дескрипторы родительского процесса. Запуск "
"процесса с использованием этого метода происходит довольно медленно по "
"сравнению с использованием *fork* или *forkserver*."

#: ../../library/multiprocessing.rst:118
msgid "Available on Unix and Windows.  The default on Windows and macOS."
msgstr ""

#: ../../library/multiprocessing.rst:127
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:121
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"Родительский процесс использует :func:`os.fork` для разветвления "
"интерпретатора Python. Дочерний процесс, когда он начинается, фактически "
"идентичен родительскому процессу. Все ресурсы родительского процесса "
"наследуются дочерним процессом. Обратите внимание, что безопасное "
"разветвление многопоточного процесса проблематично."

#: ../../library/multiprocessing.rst:127
msgid "Available on Unix only.  The default on Unix."
msgstr ""

#: ../../library/multiprocessing.rst:138
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:130
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is started.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded so it is safe for it to "
"use :func:`os.fork`.  No unnecessary resources are inherited."
msgstr ""

#: ../../library/multiprocessing.rst:137
msgid ""
"Available on Unix platforms which support passing file descriptors over Unix "
"pipes."
msgstr ""

#: ../../library/multiprocessing.rst:140
msgid ""
"*spawn* added on all Unix platforms, and *forkserver* added for some Unix "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""

#: ../../library/multiprocessing.rst:148
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""
"В macOS метод запуска *spawn* теперь используется по умолчанию. Метод "
"запуска *fork* следует считать небезопасным, поскольку он может привести к "
"сбою подпроцесса, поскольку системные библиотеки macOS могут запускать "
"потоки. См. :issue:`33725`."

#: ../../library/multiprocessing.rst:152
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"В POSIX использование методов запуска *spawn* или *forkserver* также "
"запустит процесс *отслеживания ресурсов*, который отслеживает несвязанные "
"именованные системные ресурсы (такие как именованные семафоры или объекты :"
"class:`~multiprocessing.shared_memory.SharedMemory`), созданные процессы "
"программы. Когда все процессы завершатся, средство отслеживания ресурсов "
"отключает связь с любым оставшимся отслеживаемым объектом. Обычно их не "
"должно быть, но если процесс был завершен по сигналу, могут быть некоторые "
"«утечки» ресурсов. (Ни утекшие семафоры, ни сегменты общей памяти не будут "
"автоматически отключены до следующей перезагрузки. Это проблематично для "
"обоих объектов, поскольку система допускает только ограниченное количество "
"именованных семафоров, а сегменты общей памяти занимают некоторое "
"пространство в основной памяти.)"

#: ../../library/multiprocessing.rst:165
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"Чтобы выбрать метод запуска, вы используете :func:`set_start_method` в "
"предложении ``if __name__ == '__main__'`` основного модуля. Например::"

#: ../../library/multiprocessing.rst:182
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
":func:`set_start_method` не следует использовать в программе более одного "
"раза."

#: ../../library/multiprocessing.rst:185
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Альтернативно вы можете использовать :func:`get_context` для получения "
"объекта контекста. Объекты контекста имеют тот же API, что и модуль "
"многопроцессорности, и позволяют использовать несколько методов запуска в "
"одной программе. ::"

#: ../../library/multiprocessing.rst:203
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Обратите внимание, что объекты, относящиеся к одному контексту, могут быть "
"несовместимы с процессами другого контекста. В частности, блокировки, "
"созданные с использованием контекста *fork*, не могут быть переданы "
"процессам, запущенным с помощью методов запуска *spawn* или *forkserver*."

#: ../../library/multiprocessing.rst:208
msgid ""
"A library which wants to use a particular start method should probably use :"
"func:`get_context` to avoid interfering with the choice of the library user."
msgstr ""
"Библиотека, которая хочет использовать определенный метод запуска, вероятно, "
"должна использовать :func:`get_context`, чтобы не мешать выбору пользователя "
"библиотеки."

#: ../../library/multiprocessing.rst:214
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods cannot currently be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on Unix. The ``'fork'`` start method does "
"work."
msgstr ""

#: ../../library/multiprocessing.rst:221
msgid "Exchanging objects between processes"
msgstr "Обмен объектами между процессами"

#: ../../library/multiprocessing.rst:223
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
":mod:`multiprocessing` поддерживает два типа канала связи между процессами:"

#: ../../library/multiprocessing.rst:226
msgid "**Queues**"
msgstr "**Очереди**"

#: ../../library/multiprocessing.rst:228
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"Класс :class:`Queue` является почти клоном :class:`queue.Queue`. Например::"

#: ../../library/multiprocessing.rst:243
msgid "Queues are thread and process safe."
msgstr ""

#: ../../library/multiprocessing.rst:245
msgid "**Pipes**"
msgstr "**Трубы**"

#: ../../library/multiprocessing.rst:247
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"Функция :func:`Pipe` возвращает пару объектов соединения, соединенных "
"каналом, который по умолчанию является дуплексным (двусторонним). Например::"

#: ../../library/multiprocessing.rst:263
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"Два объекта соединения, возвращаемые :func:`Pipe`, представляют собой два "
"конца трубы. Каждый объект соединения имеет методы :meth:`~Connection.send` "
"и :meth:`~Connection.recv` (среди прочих). Обратите внимание, что данные в "
"канале могут быть повреждены, если два процесса (или потока) попытаются "
"прочитать или записать в *один и тот же* конец канала одновременно. Конечно, "
"нет риска повреждения процессов, использующих разные концы канала "
"одновременно."

#: ../../library/multiprocessing.rst:273
msgid "Synchronization between processes"
msgstr "Синхронизация между процессами"

#: ../../library/multiprocessing.rst:275
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` содержит эквиваленты всех примитивов синхронизации "
"из :mod:`threading`. Например, можно использовать блокировку, чтобы "
"гарантировать, что только один процесс одновременно выводит на стандартный "
"вывод:"

#: ../../library/multiprocessing.rst:294
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Без использования вывода блокировки из разных процессов можно все перепутать."

#: ../../library/multiprocessing.rst:299
msgid "Sharing state between processes"
msgstr "Совместное использование состояния между процессами"

#: ../../library/multiprocessing.rst:301
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Как упоминалось выше, при параллельном программировании обычно лучше "
"избегать использования общего состояния, насколько это возможно. Это "
"особенно актуально при использовании нескольких процессов."

#: ../../library/multiprocessing.rst:305
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"Однако, если вам действительно необходимо использовать некоторые общие "
"данные, то :mod:`multiprocessing` предоставляет несколько способов сделать "
"это."

#: ../../library/multiprocessing.rst:308
msgid "**Shared memory**"
msgstr "**Общая память**"

#: ../../library/multiprocessing.rst:310
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Данные могут храниться в общей карте памяти, используя :class:`Value` или :"
"class:`Array`. Например, следующий код:::"

#: ../../library/multiprocessing.rst:331 ../../library/multiprocessing.rst:377
msgid "will print ::"
msgstr "будет напечатано ::"

#: ../../library/multiprocessing.rst:336
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Аргументы ``'d'`` и ``'i'``, используемые при создании ``num`` и ``arr``, "
"являются кодами типа, используемыми модулем :mod:`array`: ``' d'`` указывает "
"на число с плавающей запятой двойной точности, а ``'i'`` указывает на целое "
"число со знаком. Эти общие объекты будут процессно- и потокобезопасными."

#: ../../library/multiprocessing.rst:341
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"Для большей гибкости в использовании общей памяти можно использовать модуль "
"multiprocessing.sharedctypes, который поддерживает создание произвольных "
"объектов ctypes, выделенных из общей памяти."

#: ../../library/multiprocessing.rst:345
msgid "**Server process**"
msgstr "**Серверный процесс**"

#: ../../library/multiprocessing.rst:347
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Объект менеджера, возвращаемый :func:`Manager`, управляет серверным "
"процессом, который содержит объекты Python, и позволяет другим процессам "
"манипулировать ими с помощью прокси."

#: ../../library/multiprocessing.rst:351
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""
"Менеджер, возвращаемый :func:`Manager`, будет поддерживать типы :class:"
"`list`, :class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:"
"`RLock` , :class:`Semaphore`, :class:`BoundedSemaphore`, :class:"
"`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, :class:"
"`Value` и :class:`Массив`. Например, ::"

#: ../../library/multiprocessing.rst:382
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Диспетчеры серверных процессов более гибки, чем использование объектов с "
"общей памятью, поскольку их можно настроить для поддержки произвольных типов "
"объектов. Кроме того, один и тот же менеджер может совместно использоваться "
"процессами на разных компьютерах в сети. Однако они медленнее, чем "
"использование общей памяти."

#: ../../library/multiprocessing.rst:389
msgid "Using a pool of workers"
msgstr "Использование пула работников"

#: ../../library/multiprocessing.rst:391
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"Класс :class:`~multiprocessing.pool.Pool` представляет пул рабочих "
"процессов. У него есть методы, которые позволяют перегружать задачи рабочим "
"процессам несколькими различными способами."

#: ../../library/multiprocessing.rst:395
msgid "For example::"
msgstr "Например::"

#: ../../library/multiprocessing.rst:439
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Обратите внимание, что методы пула должны использоваться только тем "
"процессом, который его создал."

#: ../../library/multiprocessing.rst:444
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"Функциональность этого пакета требует, чтобы дочерние элементы могли "
"импортировать модуль ``__main__``. Это описано в :ref:`мультипроцессорном "
"программировании`, однако здесь стоит указать на это. Это означает, что "
"некоторые примеры, такие как примеры :class:`multiprocessing.pool.Pool`, не "
"будут работать в интерактивном интерпретаторе. Например::"

#: ../../library/multiprocessing.rst:467
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Если вы попробуете это сделать, на самом деле будут выведены три полных "
"обратных трассировки, чередующиеся полуслучайным образом, и тогда вам, "
"возможно, придется каким-то образом остановить родительский процесс.)"

#: ../../library/multiprocessing.rst:473
msgid "Reference"
msgstr "Ссылка"

#: ../../library/multiprocessing.rst:475
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"Пакет :mod:`multiprocessing` в основном копирует API модуля :mod:`threading`."

#: ../../library/multiprocessing.rst:480
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` и исключения"

#: ../../library/multiprocessing.rst:485
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Объекты процесса представляют собой действие, выполняемое в отдельном "
"процессе. Класс :class:`Process` имеет эквиваленты всех методов :class:"
"`threading.Thread`."

#: ../../library/multiprocessing.rst:489
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""

#: ../../library/multiprocessing.rst:500
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"По умолчанию аргументы *target* не передаются. Аргумент *args*, который по "
"умолчанию имеет значение ``()``, может использоваться для указания списка "
"или кортежа аргументов, передаваемых в *target*."

#: ../../library/multiprocessing.rst:504
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""
"Если подкласс переопределяет конструктор, он должен убедиться, что он "
"вызывает конструктор базового класса (:meth:`Process.__init__`), прежде чем "
"делать что-либо еще с процессом."

#: ../../library/multiprocessing.rst:508
msgid "Added the *daemon* parameter."
msgstr "Добавлен параметр *daemon*."

#: ../../library/multiprocessing.rst:513
msgid "Method representing the process's activity."
msgstr "Метод, представляющий активность процесса."

#: ../../library/multiprocessing.rst:515
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Вы можете переопределить этот метод в подклассе. Стандартный метод :meth:"
"`run` вызывает вызываемый объект, передаваемый конструктору объекта в "
"качестве целевого аргумента, если таковой имеется, с последовательными "
"аргументами и аргументами ключевого слова, взятыми из аргументов *args* и "
"*kwargs* соответственно."

#: ../../library/multiprocessing.rst:520
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""
"Использование списка или кортежа в качестве аргумента *args*, передаваемого "
"в :class:`Process`, дает тот же эффект."

#: ../../library/multiprocessing.rst:523
msgid "Example::"
msgstr "Пример::"

#: ../../library/multiprocessing.rst:535
msgid "Start the process's activity."
msgstr "Запустите активность процесса."

#: ../../library/multiprocessing.rst:537
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Это должно быть вызвано не более одного раза для каждого объекта процесса. "
"Он организует вызов метода :meth:`run` объекта в отдельном процессе."

#: ../../library/multiprocessing.rst:542
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Если необязательный аргумент *timeout* равен None (по умолчанию), метод "
"блокируется до тех пор, пока процесс, чей метод :meth:`join` вызывается, не "
"завершится. Если *timeout* — положительное число, блокируется не более "
"*timeout* секунд. Обратите внимание, что метод возвращает None, если его "
"процесс завершается или время ожидания метода истекло. Проверьте :attr:"
"`exitcode` процесса, чтобы определить, завершился ли он."

#: ../../library/multiprocessing.rst:549
msgid "A process can be joined many times."
msgstr "К процессу можно присоединяться много раз."

#: ../../library/multiprocessing.rst:551
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"Процесс не может присоединиться сам к себе, поскольку это может привести к "
"тупику. Попытка присоединиться к процессу до его запуска является ошибкой."

#: ../../library/multiprocessing.rst:556
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"Имя процесса. Имя представляет собой строку, используемую только в целях "
"идентификации. Оно не имеет семантики. Одно и то же имя может быть присвоено "
"нескольким процессам."

#: ../../library/multiprocessing.rst:560
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"Первоначальное имя задается конструктором. Если конструктору не указано "
"явное имя, имя в форме 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`' "
"построен, где каждый N\\ :sub:`k` является N-м дочерним элементом своего "
"родителя."

#: ../../library/multiprocessing.rst:567
msgid "Return whether the process is alive."
msgstr "Возвращает, жив ли процесс."

#: ../../library/multiprocessing.rst:569
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Грубо говоря, объект процесса жив с момента возврата метода :meth:`start` до "
"тех пор, пока дочерний процесс не завершится."

#: ../../library/multiprocessing.rst:574
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"Флаг демона процесса, логическое значение. Это должно быть установлено до "
"вызова :meth:`start`."

#: ../../library/multiprocessing.rst:577
msgid "The initial value is inherited from the creating process."
msgstr "Начальное значение наследуется от процесса создания."

#: ../../library/multiprocessing.rst:579
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"Когда процесс завершается, он пытается завершить все свои демонические "
"дочерние процессы."

#: ../../library/multiprocessing.rst:582
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Обратите внимание, что демоническому процессу не разрешено создавать "
"дочерние процессы. В противном случае демонический процесс оставит своих "
"дочерних элементов сиротами, если он завершится при завершении родительского "
"процесса. Кроме того, это **не** демоны или службы Unix, это обычные "
"процессы, которые будут завершены (а не присоединены), если не-демонические "
"процессы завершатся."

#: ../../library/multiprocessing.rst:588
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"В дополнение к API :class:`threading.Thread`, объекты :class:`Process` также "
"поддерживают следующие атрибуты и методы:"

#: ../../library/multiprocessing.rst:593
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Верните идентификатор процесса. Прежде чем процесс будет запущен, это будет "
"``None``."

#: ../../library/multiprocessing.rst:598
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"Код выхода ребенка. Это будет ``None``, если процесс еще не завершился."

#: ../../library/multiprocessing.rst:601
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Если дочерний метод :meth:`run` вернулся нормально, код выхода будет равен "
"0. Если он завершился через :func:`sys.exit` с целочисленным аргументом *N*, "
"код выхода будет *N*."

#: ../../library/multiprocessing.rst:605
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Если дочерний процесс завершился из-за исключения, не перехваченного в :meth:"
"`run`, код выхода будет 1. Если он был завершен по сигналу *N*, код выхода "
"будет иметь отрицательное значение *-N*."

#: ../../library/multiprocessing.rst:611
msgid "The process's authentication key (a byte string)."
msgstr "Ключ аутентификации процесса (байтовая строка)."

#: ../../library/multiprocessing.rst:613
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"Когда :mod:`multiprocessing` инициализируется, основному процессу "
"назначается случайная строка с помощью :func:`os.urandom`."

#: ../../library/multiprocessing.rst:616
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"Когда создается объект :class:`Process`, он унаследует ключ аутентификации "
"своего родительского процесса, хотя это можно изменить, установив для :attr:"
"`authkey` другую байтовую строку."

#: ../../library/multiprocessing.rst:620
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "См. :ref:`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:624
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Числовой дескриптор системного объекта, который станет «готовым» после "
"завершения процесса."

#: ../../library/multiprocessing.rst:627
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join()` is "
"simpler."
msgstr ""

#: ../../library/multiprocessing.rst:631
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On Unix, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""

#: ../../library/multiprocessing.rst:639
msgid ""
"Terminate the process.  On POSIX this is done using the :py:const:`~signal."
"SIGTERM` signal; on Windows :c:func:`!TerminateProcess` is used.  Note that "
"exit handlers and finally clauses, etc., will not be executed."
msgstr ""
"Завершите процесс. В POSIX это делается с помощью сигнала :py:const:`~signal."
"SIGTERM`; в Windows используется :c:func:`!TerminateProcess`. Обратите "
"внимание, что обработчики выхода, предложенияfinally и т. д. не будут "
"выполнены."

#: ../../library/multiprocessing.rst:643
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Обратите внимание, что процессы-потомки этого процесса *не* будут завершены "
"— они просто станут осиротевшими."

#: ../../library/multiprocessing.rst:648
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Если этот метод используется, когда связанный процесс использует канал или "
"очередь, то канал или очередь могут быть повреждены и могут стать "
"непригодными для использования другим процессом. Аналогично, если процесс "
"получил блокировку или семафор и т. д., то его завершение может привести к "
"тупиковой ситуации других процессов."

#: ../../library/multiprocessing.rst:656
msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on Unix."
msgstr ""

#: ../../library/multiprocessing.rst:662
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Закройте объект :class:`Process`, освободив все связанные с ним ресурсы. :"
"exc:`ValueError` возникает, если базовый процесс все еще работает. После "
"успешного завершения :meth:`close` большинство других методов и атрибутов "
"объекта :class:`Process` вызовут :exc:`ValueError`."

#: ../../library/multiprocessing.rst:670
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Обратите внимание, что методы :meth:`start`, :meth:`join`, :meth:"
"`is_alive`, :meth:`terminate` и :attr:`exitcode` должны вызываться только "
"тем процессом, который создал объект процесса. ."

#: ../../library/multiprocessing.rst:674
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Пример использования некоторых методов :class:`Process`:"

#: ../../library/multiprocessing.rst:694
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "Базовый класс всех исключений :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:698
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""

#: ../../library/multiprocessing.rst:701
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Если ``e`` является экземпляром :exc:`BufferTooShort`, то ``e.args[0]`` "
"выдаст сообщение в виде байтовой строки."

#: ../../library/multiprocessing.rst:706
msgid "Raised when there is an authentication error."
msgstr "Возникает при ошибке аутентификации."

#: ../../library/multiprocessing.rst:710
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "Вызывается методами с таймаутом по истечении таймаута."

#: ../../library/multiprocessing.rst:713
msgid "Pipes and Queues"
msgstr "Каналы и очереди"

#: ../../library/multiprocessing.rst:715
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"При использовании нескольких процессов обычно используется передача "
"сообщений для связи между процессами и избегается использования каких-либо "
"примитивов синхронизации, таких как блокировки."

#: ../../library/multiprocessing.rst:719
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"Для передачи сообщений можно использовать :func:`Pipe` (для соединения между "
"двумя процессами) или очередь (которая позволяет использовать несколько "
"производителей и потребителей)."

#: ../../library/multiprocessing.rst:722
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Типы :class:`Queue`, :class:`SimpleQueue` и :class:`JoinableQueue` "
"представляют собой очереди с несколькими производителями и несколькими "
"потребителями :abbr:`FIFO (первым вошел, первым обслужен)`, смоделированные "
"по принципу: class:`queue.Queue` в стандартной библиотеке. Они отличаются "
"тем, что в :class:`Queue` отсутствуют методы :meth:`~queue.Queue.task_done` "
"и :meth:`~queue.Queue.join`, представленные в :class:`queue.Queue` в Python "
"2.5. сорт."

#: ../../library/multiprocessing.rst:729
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Если вы используете :class:`JoinableQueue`, вы **должны** вызывать :meth:"
"`JoinableQueue.task_done` для каждой задачи, удаленной из очереди, иначе "
"семафор, используемый для подсчета количества незавершенных задач, может в "
"конечном итоге переполниться, что вызовет ошибку исключение."

#: ../../library/multiprocessing.rst:734
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Обратите внимание, что общую очередь также можно создать с помощью объекта-"
"менеджера — см. :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:739
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
":mod:`multiprocessing` использует обычные исключения :exc:`queue.Empty` и :"
"exc:`queue.Full` для сигнализации таймаута. Они недоступны в пространстве "
"имен :mod:`multiprocessing`, поэтому вам необходимо импортировать их из :mod:"
"`queue`."

#: ../../library/multiprocessing.rst:746
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"Когда объект помещается в очередь, он фиксируется, а фоновый поток позже "
"сбрасывает маринованные данные в базовый канал. Это имеет некоторые "
"последствия, которые немного неожиданны, но не должны вызывать никаких "
"практических трудностей — если они вас действительно беспокоят, то вместо "
"этого вы можете использовать очередь, созданную с помощью :ref:`manager "
"<multiprocessing-managers>`."

#: ../../library/multiprocessing.rst:753
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"После помещения объекта в пустую очередь может возникнуть бесконечно малая "
"задержка, прежде чем метод очереди :meth:`~Queue.empty` вернет :const:"
"`False` и :meth:`~Queue.get_nowait` сможет вернуться без вызова :exc :`queue."
"Empty`."

#: ../../library/multiprocessing.rst:758
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Если несколько процессов ставят объекты в очередь, возможно, что объекты "
"будут получены на другом конце не по порядку. Однако объекты, поставленные в "
"очередь одним и тем же процессом, всегда будут находиться в ожидаемом "
"порядке относительно друг друга."

#: ../../library/multiprocessing.rst:765
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Если процесс завершается с помощью :meth:`Process.terminate` или :func:`os."
"kill`, когда он пытается использовать :class:`Queue`, то данные в очереди, "
"скорее всего, будут повреждены. Это может привести к тому, что любой другой "
"процесс получит исключение при попытке позже использовать очередь."

#: ../../library/multiprocessing.rst:772
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Как упоминалось выше, если дочерний процесс поместил элементы в очередь (и "
"он не использовал :meth:`JoinableQueue.cancel_join_thread <multiprocessing."
"Queue.cancel_join_thread>`), тогда этот процесс не завершится до тех пор, "
"пока все элементы в буфере не будут очищены. к трубе."

#: ../../library/multiprocessing.rst:777
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Это означает, что если вы попытаетесь присоединиться к этому процессу, вы "
"можете получить тупик, если не уверены, что все элементы, помещенные в "
"очередь, были использованы. Аналогично, если дочерний процесс не является "
"демоническим, то родительский процесс может зависнуть при выходе, когда он "
"пытается присоединиться ко всем своим недемоническим дочерним процессам."

#: ../../library/multiprocessing.rst:782
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Обратите внимание, что очередь, созданная с помощью менеджера, не имеет этой "
"проблемы. См. :ref:`многопроцессорное программирование`."

#: ../../library/multiprocessing.rst:785
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"Пример использования очередей для межпроцессного взаимодействия см. в :ref:"
"`multiprocessing-examples`."

#: ../../library/multiprocessing.rst:791
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Возвращает пару объектов :class:~multiprocessing.connection."
"Connection`(conn1, conn2)``, представляющих концы канала."

#: ../../library/multiprocessing.rst:795
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Если *duplex* имеет значение True (по умолчанию), то канал является "
"двунаправленным. Если *duplex* имеет значение «False», то канал является "
"однонаправленным: «conn1» может использоваться только для получения "
"сообщений, а «conn2» может использоваться только для отправки сообщений."

#: ../../library/multiprocessing.rst:803
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Возвращает общую очередь процесса, реализованную с использованием канала и "
"нескольких блокировок/семафоров. Когда процесс впервые помещает элемент в "
"очередь, запускается поток подачи, который передает объекты из буфера в "
"канал."

#: ../../library/multiprocessing.rst:807
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"Обычные исключения :exc:`queue.Empty` и :exc:`queue.Full` из модуля :mod:"
"`queue` стандартной библиотеки вызываются для сигнализации таймаута."

#: ../../library/multiprocessing.rst:810
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` реализует все методы :class:`queue.Queue`, за исключением :"
"meth:`~queue.Queue.task_done` и :meth:`~queue.Queue.join`."

#: ../../library/multiprocessing.rst:815
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Возвращает приблизительный размер очереди. Из-за семантики многопоточности/"
"многопроцессорности это число не является надежным."

#: ../../library/multiprocessing.rst:818
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"macOS where ``sem_getvalue()`` is not implemented."
msgstr ""

#: ../../library/multiprocessing.rst:823
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Верните True, если очередь пуста, и False в противном случае. Из-за "
"семантики многопоточности/многопроцессорности это ненадежно."

#: ../../library/multiprocessing.rst:828
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Верните True, если очередь заполнена, и False в противном случае. Из-за "
"семантики многопоточности/многопроцессорности это ненадежно."

#: ../../library/multiprocessing.rst:833
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Поместите объект в очередь. Если необязательный аргумент *block* имеет "
"значение «True» (по умолчанию), а *timeout* имеет значение «None» (по "
"умолчанию), блокируйте при необходимости до тех пор, пока не станет доступен "
"свободный слот. Если *timeout* является положительным числом, он блокирует "
"не более *timeout* секунд и вызывает исключение :exc:`queue.Full`, если в "
"течение этого времени не было свободного слота. В противном случае (*block* "
"имеет значение ``False``), поместите элемент в очередь, если свободный слот "
"сразу доступен, иначе вызовите исключение :exc:`queue.Full` (в этом случае "
"*timeout* игнорируется)."

#: ../../library/multiprocessing.rst:842
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Если очередь закрыта, вместо :exc:`AssertionError` возникает :exc:"
"`ValueError`."

#: ../../library/multiprocessing.rst:848
msgid "Equivalent to ``put(obj, False)``."
msgstr "Эквивалентно put(obj, False)``."

#: ../../library/multiprocessing.rst:852
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Удалить и вернуть элемент из очереди. Если необязательные аргументы *block* "
"имеют значение «True» (по умолчанию), а *timeout* имеет значение «None» (по "
"умолчанию), блокируйте при необходимости до тех пор, пока элемент не станет "
"доступен. Если *timeout* является положительным числом, он блокирует не "
"более *timeout* секунд и вызывает исключение :exc:`queue.Empty`, если в "
"течение этого времени ни один элемент не был доступен. В противном случае "
"(блок имеет значение ``False``), верните элемент, если он доступен "
"немедленно, иначе вызовите исключение :exc:`queue.Empty` (*timeout* в этом "
"случае игнорируется)."

#: ../../library/multiprocessing.rst:860
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""
"Если очередь закрыта, вместо :exc:`OSError` возникает :exc:`ValueError`."

#: ../../library/multiprocessing.rst:866
msgid "Equivalent to ``get(False)``."
msgstr "Эквивалент ``get(False)``."

#: ../../library/multiprocessing.rst:868
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` имеет несколько дополнительных методов, "
"которых нет в :class:`queue.Queue`. Эти методы обычно не нужны для большей "
"части кода:"

#: ../../library/multiprocessing.rst:874
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""
"Укажите, что текущий процесс больше не будет помещать данные в эту очередь. "
"Фоновый поток завершится, как только он сбросит все буферизованные данные в "
"канал. Это вызывается автоматически, когда очередь очищается от мусора."

#: ../../library/multiprocessing.rst:881
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Присоединяйтесь к фоновой теме. Это можно использовать только после вызова :"
"meth:`close`. Он блокируется до тех пор, пока фоновый поток не завершится, "
"гарантируя, что все данные в буфере будут сброшены в канал."

#: ../../library/multiprocessing.rst:885
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"По умолчанию, если процесс не является создателем очереди, то при выходе он "
"попытается присоединиться к фоновому потоку очереди. Процесс может вызвать :"
"meth:`cancel_join_thread`, чтобы :meth:`join_thread` ничего не делал."

#: ../../library/multiprocessing.rst:891
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Предотвратить блокировку :meth:`join_thread`. В частности, это предотвращает "
"автоматическое присоединение к фоновому потоку при выходе из процесса — см. :"
"meth:`join_thread`."

#: ../../library/multiprocessing.rst:895
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Лучшее имя для этого метода могло бы быть ``allow_exit_without_flush()``. "
"Это может привести к потере данных в очереди, и вам почти наверняка не "
"понадобится их использовать. На самом деле он существует только в том "
"случае, если вам нужно, чтобы текущий процесс завершился немедленно, не "
"дожидаясь сброса данных из очереди в базовый канал, и вас не волнуют "
"потерянные данные."

#: ../../library/multiprocessing.rst:904
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"Функциональность этого класса требует функционирующей реализации общего "
"семафора в операционной системе хоста. Без него функциональность этого "
"класса будет отключена, а попытки создать экземпляр :class:`Queue` приведут "
"к :exc:`ImportError`. Дополнительную информацию см. в :issue:`3770`. То же "
"самое справедливо для любого из специализированных типов очередей, "
"перечисленных ниже."

#: ../../library/multiprocessing.rst:913
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"Это упрощенный тип :class:`Queue`, очень близкий к заблокированному :class:"
"`Pipe`."

#: ../../library/multiprocessing.rst:917
msgid "Close the queue: release internal resources."
msgstr "Закройте очередь: освободите внутренние ресурсы."

#: ../../library/multiprocessing.rst:919
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"Очередь больше не должна использоваться после ее закрытия. Например, методы :"
"meth:`get`, :meth:`put` и :meth:`empty` больше нельзя вызывать."

#: ../../library/multiprocessing.rst:927
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Верните True, если очередь пуста, и False в противном случае."

#: ../../library/multiprocessing.rst:931
msgid "Remove and return an item from the queue."
msgstr "Удалить и вернуть элемент из очереди."

#: ../../library/multiprocessing.rst:935
msgid "Put *item* into the queue."
msgstr "Поместите *элемент* в очередь."

#: ../../library/multiprocessing.rst:940
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, подкласс :class:`Queue`, представляет собой очередь, "
"которая дополнительно имеет методы :meth:`task_done` и :meth:`join`."

#: ../../library/multiprocessing.rst:945
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Указывает, что ранее поставленная в очередь задача завершена. Используется "
"потребителями очереди. Для каждого :meth:`~Queue.get`, используемого для "
"получения задачи, последующий вызов :meth:`task_done` сообщает очереди, что "
"обработка задачи завершена."

#: ../../library/multiprocessing.rst:950
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Если :meth:`~queue.Queue.join` в данный момент блокируется, он возобновится, "
"когда все элементы будут обработаны (это означает, что вызов :meth:"
"`task_done` был получен для каждого элемента, который был :meth:`~ Queue."
"put` в очередь)."

#: ../../library/multiprocessing.rst:954
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Вызывает :exc:`ValueError`, если вызывается больше раз, чем было помещено в "
"очередь элементов."

#: ../../library/multiprocessing.rst:960
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""
"Блокировать до тех пор, пока все элементы в очереди не будут получены и "
"обработаны."

#: ../../library/multiprocessing.rst:962
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"Количество незавершенных задач увеличивается каждый раз, когда элемент "
"добавляется в очередь. Счетчик уменьшается всякий раз, когда потребитель "
"вызывает :meth:`task_done`, чтобы указать, что элемент был получен и вся "
"работа над ним завершена. Когда количество незавершенных задач падает до "
"нуля, :meth:`~queue.Queue.join` разблокируется."

#: ../../library/multiprocessing.rst:970
msgid "Miscellaneous"
msgstr "Разное"

#: ../../library/multiprocessing.rst:974
msgid "Return list of all live children of the current process."
msgstr "Возвращает список всех живых дочерних элементов текущего процесса."

#: ../../library/multiprocessing.rst:976
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Вызов этого имеет побочный эффект «присоединения» к любым процессам, которые "
"уже завершились."

#: ../../library/multiprocessing.rst:981
msgid "Return the number of CPUs in the system."
msgstr "Возвращает количество процессоров в системе."

#: ../../library/multiprocessing.rst:983
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with ``len(os."
"sched_getaffinity(0))``"
msgstr ""
"Это число не эквивалентно количеству процессоров, которые может использовать "
"текущий процесс. Количество доступных процессоров можно получить с помощью "
"``len(os.sched_getaffinity(0))``"

#: ../../library/multiprocessing.rst:987
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"Когда количество процессоров не может быть определено, возникает ошибка :exc:"
"`NotImplementedError`."

#: ../../library/multiprocessing.rst:991
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../../library/multiprocessing.rst:995
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "Верните объект :class:`Process`, соответствующий текущему процессу."

#: ../../library/multiprocessing.rst:997
msgid "An analogue of :func:`threading.current_thread`."
msgstr "Аналог :func:`threading.current_thread`."

#: ../../library/multiprocessing.rst:1001
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Верните объект :class:`Process`, соответствующий родительскому процессу :"
"func:`current_process`. Для основного процесса ``parent_process`` будет "
"``None``."

#: ../../library/multiprocessing.rst:1009
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Добавьте поддержку случаев, когда программа, использующая :mod:"
"`многопроцессорность`, была заморожена для создания исполняемого файла "
"Windows. (Протестировано с **py2exe**, **PyInstaller** и **cx_Freeze**.)"

#: ../../library/multiprocessing.rst:1013
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"Эту функцию необходимо вызывать сразу после строки ``if __name__ == "
"'__main__'`` основного модуля. Например::"

#: ../../library/multiprocessing.rst:1025
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Если строка ``freeze_support()`` опущена, то попытка запустить замороженный "
"исполняемый файл вызовет ошибку :exc:`RuntimeError`."

#: ../../library/multiprocessing.rst:1028
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run normally "
"by the Python interpreter on Windows (the program has not been frozen), then "
"``freeze_support()`` has no effect."
msgstr ""
"Вызов freeze_support() не имеет никакого эффекта при вызове в любой "
"операционной системе, кроме Windows. Кроме того, если модуль нормально "
"запускается интерпретатором Python в Windows (программа не была заморожена), "
"то функция freeze_support() не имеет никакого эффекта."

#: ../../library/multiprocessing.rst:1035
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being the "
"default."
msgstr ""

#: ../../library/multiprocessing.rst:1045
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Возвращает объект контекста, который имеет те же атрибуты, что и модуль :mod:"
"`multiprocessing`."

#: ../../library/multiprocessing.rst:1048
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:"
"`ValueError` is raised if the specified start method is not available."
msgstr ""

#: ../../library/multiprocessing.rst:1057
msgid "Return the name of start method used for starting processes."
msgstr "Возвращает имя метода запуска, используемого для запуска процессов."

#: ../../library/multiprocessing.rst:1059
msgid ""
"If the start method has not been fixed and *allow_none* is false, then the "
"start method is fixed to the default and the name is returned.  If the start "
"method has not been fixed and *allow_none* is true then ``None`` is returned."
msgstr ""
"Если метод start не был исправлен и *allow_none* имеет значение false, то "
"методу start присваивается значение по умолчанию и возвращается имя. Если "
"метод start не был исправлен и *allow_none* имеет значение true, то "
"возвращается None."

#: ../../library/multiprocessing.rst:1064
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows and macOS."
msgstr ""

#: ../../library/multiprocessing.rst:1072
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"В macOS метод запуска *spawn* теперь используется по умолчанию. Метод "
"запуска *fork* следует считать небезопасным, поскольку он может привести к "
"сбою подпроцесса. См. :issue:`33725`."

#: ../../library/multiprocessing.rst:1078
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Задайте путь интерпретатора Python, который будет использоваться при запуске "
"дочернего процесса. (По умолчанию используется :data:`sys.executable`). "
"Разработчикам, вероятно, придется сделать что-то вроде::"

#: ../../library/multiprocessing.rst:1084
msgid "before they can create child processes."
msgstr "прежде чем они смогут создавать дочерние процессы."

#: ../../library/multiprocessing.rst:1086
msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr ""

#: ../../library/multiprocessing.rst:1089
msgid "Accepts a :term:`path-like object`."
msgstr "Принимает :term:`объект, похожий на путь`."

#: ../../library/multiprocessing.rst:1094
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""
"Установите метод, который должен использоваться для запуска дочерних "
"процессов. Аргументом *method* может быть ``'fork'``, ``'spawn'`` или "
"``'forkserver'``. Вызывает :exc:`RuntimeError`, если метод запуска уже "
"установлен и *force* не имеет значения ``True``. Если *method* имеет "
"значение «None» и *force* имеет значение «True», то для метода запуска "
"устанавливается значение «None». Если *method* имеет значение None, а "
"*force* имеет значение False, тогда контекст устанавливается в контекст по "
"умолчанию."

#: ../../library/multiprocessing.rst:1101
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Обратите внимание, что его следует вызывать не более одного раза, и он "
"должен быть защищен внутри предложения ``if __name__ == '__main__'`` "
"основного модуля."

#: ../../library/multiprocessing.rst:1109
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
":mod:`multiprocessing` не содержит аналогов :func:`threading.active_count`, :"
"func:`threading.enumerate`, :func:`threading.settrace`, :func:`threading."
"setprofile`, :class:` threading.Timer` или :class:`threading.local`."

#: ../../library/multiprocessing.rst:1116
msgid "Connection Objects"
msgstr "Объекты соединения"

#: ../../library/multiprocessing.rst:1120
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Объекты соединения позволяют отправлять и получать поддающиеся выбору "
"объекты или строки. Их можно рассматривать как подключенные сокеты, "
"ориентированные на сообщения."

#: ../../library/multiprocessing.rst:1123
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Объекты соединения обычно создаются с помощью :func:`Pipe <multiprocessing."
"Pipe>` — см. также :ref:`multiprocessing-listeners-clients`."

#: ../../library/multiprocessing.rst:1131
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Отправьте объект на другой конец соединения, который следует прочитать с "
"помощью :meth:`recv`."

#: ../../library/multiprocessing.rst:1134
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"Объект должен быть пикабельным. Очень большие пикли (около 32 МБ+, хотя это "
"зависит от ОС) могут вызвать исключение :exc:`ValueError`."

#: ../../library/multiprocessing.rst:1139
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Верните объект, отправленный с другого конца соединения, используя :meth:"
"`send`. Блокирует до тех пор, пока не будет что получить. Вызывает :exc:"
"`EOFError`, если больше нечего принимать и другой конец закрыт."

#: ../../library/multiprocessing.rst:1146
msgid "Return the file descriptor or handle used by the connection."
msgstr "Возвращает дескриптор файла или дескриптор, используемый соединением."

#: ../../library/multiprocessing.rst:1150
msgid "Close the connection."
msgstr "Закройте соединение."

#: ../../library/multiprocessing.rst:1152
msgid "This is called automatically when the connection is garbage collected."
msgstr "Это вызывается автоматически, когда соединение очищается от мусора."

#: ../../library/multiprocessing.rst:1156
msgid "Return whether there is any data available to be read."
msgstr ""
"Возвращает сведения о том, есть ли какие-либо данные, доступные для чтения."

#: ../../library/multiprocessing.rst:1158
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Если *timeout* не указан, он вернется немедленно. Если *timeout* — это "
"число, оно определяет максимальное время блокировки в секундах. Если "
"*timeout* равен None, то используется бесконечный таймаут."

#: ../../library/multiprocessing.rst:1162
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Обратите внимание, что можно опросить несколько объектов соединения "
"одновременно, используя :func:`multiprocessing.connection.wait`."

#: ../../library/multiprocessing.rst:1167
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Отправляйте байтовые данные из объекта, подобного :term:`bytes`, как полное "
"сообщение."

#: ../../library/multiprocessing.rst:1169
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Если указано *offset*, данные считываются из этой позиции в *buffer*. Если "
"указан *size*, то из буфера будет прочитано столько байтов. Очень большие "
"буферы (около 32 МБ+, хотя это зависит от ОС) могут вызвать исключение :exc:"
"`ValueError`"

#: ../../library/multiprocessing.rst:1176
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Возвращает полное сообщение байтовых данных, отправленное с другого конца "
"соединения, в виде строки. Блокирует до тех пор, пока не будет что получить. "
"Вызывает :exc:`EOFError`, если больше нечего принимать и другой конец закрыт."

#: ../../library/multiprocessing.rst:1181
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Если указана *maxlength* и сообщение длиннее, чем *maxlength*, то возникает :"
"exc:`OSError` и соединение больше не будет доступно для чтения."

#: ../../library/multiprocessing.rst:1185
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Эта функция раньше вызывала :exc:`IOError`, который теперь является "
"псевдонимом :exc:`OSError`."

#: ../../library/multiprocessing.rst:1192
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Считайте в *буфер* полное сообщение байтовых данных, отправленное с другого "
"конца соединения, и верните количество байтов в сообщении. Блокирует до тех "
"пор, пока не будет что получить. Вызывает :exc:`EOFError`, если больше "
"нечего принимать и другой конец закрыт."

#: ../../library/multiprocessing.rst:1198
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* должен быть записываемым :term:`байтоподобным объектом`. Если "
"указано *offset*, сообщение будет записано в буфер с этой позиции. Смещение "
"должно быть неотрицательным целым числом, меньшим длины *buffer* (в байтах)."

#: ../../library/multiprocessing.rst:1203
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Если буфер слишком короткий, возникает исключение :exc:`BufferTooShort` и "
"полное сообщение доступно как ``e.args[0]``, где ``e`` — это экземпляр "
"исключения."

#: ../../library/multiprocessing.rst:1207
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Сами объекты соединения теперь можно передавать между процессами с помощью :"
"meth:`Connection.send` и :meth:`Connection.recv`."

#: ../../library/multiprocessing.rst:1211
msgid ""
"Connection objects also now support the context management protocol -- see :"
"ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Объекты соединения теперь также поддерживают протокол управления контекстом "
"— см. :ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` "
"возвращает объект соединения, а :meth:`~contextmanager.__exit__` вызывает :"
"meth:`close`."

#: ../../library/multiprocessing.rst:1215
msgid "For example:"
msgstr "Например:"

#: ../../library/multiprocessing.rst:1240
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"Метод :meth:`Connection.recv` автоматически отбирает полученные данные, что "
"может представлять угрозу безопасности, если вы не можете доверять процессу, "
"отправившему сообщение."

#: ../../library/multiprocessing.rst:1244
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Поэтому, если объект соединения не был создан с использованием :func:`Pipe`, "
"вам следует использовать методы :meth:`~Connection.recv` и :meth:"
"`~Connection.send` только после выполнения какой-либо аутентификации. См. :"
"ref:`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:1251
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Если процесс завершается во время попытки чтения или записи в канал, то "
"данные в канале, скорее всего, будут повреждены, поскольку может оказаться "
"невозможным определить, где проходят границы сообщения."

#: ../../library/multiprocessing.rst:1257
msgid "Synchronization primitives"
msgstr "Примитивы синхронизации"

#: ../../library/multiprocessing.rst:1261
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Обычно примитивы синхронизации не так необходимы в многопроцессной "
"программе, как в многопоточной программе. См. документацию по модулю :mod:"
"`threading`."

#: ../../library/multiprocessing.rst:1265
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Обратите внимание, что примитивы синхронизации также можно создавать с "
"помощью объекта-менеджера — см. :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:1270
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Объект-барьер: клон :class:`threading.Barrier`."

#: ../../library/multiprocessing.rst:1276
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Объект ограниченного семафора: близкий аналог :class:`threading."
"BoundedSemaphore`."

#: ../../library/multiprocessing.rst:1279
#: ../../library/multiprocessing.rst:1417
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"Существует единственное отличие от его близкого аналога: первый аргумент "
"метода acquire называется *block*, что соответствует :meth:`Lock.acquire`."

#: ../../library/multiprocessing.rst:1283
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"В macOS это неотличимо от :class:`Semaphore`, потому что ``sem_getvalue()`` "
"не реализован на этой платформе."

#: ../../library/multiprocessing.rst:1288
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "Условная переменная: псевдоним для :class:`threading.Condition`."

#: ../../library/multiprocessing.rst:1290
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Если указан *lock*, то это должен быть объект :class:`Lock` или :class:"
"`RLock` из :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:1293
#: ../../library/multiprocessing.rst:1842
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "Был добавлен метод :meth:`~threading.Condition.wait_for`."

#: ../../library/multiprocessing.rst:1298
msgid "A clone of :class:`threading.Event`."
msgstr "Клон :class:`threading.Event`."

#: ../../library/multiprocessing.rst:1303
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Нерекурсивный объект блокировки: близкий аналог :class:`threading.Lock`. Как "
"только процесс или поток получил блокировку, последующие попытки получить ее "
"от любого процесса или потока будут блокироваться до тех пор, пока она не "
"будет снята; любой процесс или поток может освободить его. Концепции и "
"поведение :class:`threading.Lock` применительно к потокам воспроизводятся "
"здесь, в :class:`multiprocessing.Lock`, применительно к процессам или "
"потокам, если не указано иное."

#: ../../library/multiprocessing.rst:1311
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Обратите внимание, что :class:`Lock` на самом деле является фабричной "
"функцией, которая возвращает экземпляр multiprocessing.synchronize.Lock``, "
"инициализированный контекстом по умолчанию."

#: ../../library/multiprocessing.rst:1315
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` поддерживает протокол :term:`контекстного менеджера` и поэтому "
"может использоваться в операторах :keyword:`with`."

#: ../../library/multiprocessing.rst:1320
#: ../../library/multiprocessing.rst:1371
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Приобретите блокировку"

#: ../../library/multiprocessing.rst:1322
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Если для аргумента *block* установлено значение «True» (по умолчанию), вызов "
"метода будет блокироваться до тех пор, пока блокировка не перейдет в "
"разблокированное состояние, а затем установит ее в состояние «заблокировано» "
"и вернет «True». Обратите внимание, что имя этого первого аргумента "
"отличается от имени в :meth:`threading.Lock.acquire`."

#: ../../library/multiprocessing.rst:1327
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Если для аргумента *block* установлено значение «False», вызов метода не "
"блокируется. Если замок в настоящее время находится в заблокированном "
"состоянии, верните ``False``; в противном случае установите блокировку в "
"заблокированное состояние и верните ``True``."

#: ../../library/multiprocessing.rst:1331
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"При вызове с положительным значением с плавающей запятой для *timeout* "
"блокируется не более чем на количество секунд, указанное в *timeout*, пока "
"блокировка не может быть получена. Вызовы с отрицательным значением "
"*timeout* эквивалентны *timeout*, равному нулю. Вызовы со значением "
"*timeout* равным None (по умолчанию) устанавливают бесконечный период "
"таймаута. Обратите внимание, что обработка отрицательных значений или "
"значений ``None`` для *timeout* отличается от поведения, реализованного в :"
"meth:`threading.Lock.acquire`. Аргумент *timeout* не имеет практического "
"значения, если аргумент *block* установлен в значение «False» и поэтому "
"игнорируется. Возвращает True, если блокировка была получена, или False, "
"если период ожидания истек."

#: ../../library/multiprocessing.rst:1346
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Снимите замок. Его можно вызвать из любого процесса или потока, а не только "
"из процесса или потока, который первоначально получил блокировку."

#: ../../library/multiprocessing.rst:1349
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"Поведение такое же, как и в :meth:`threading.Lock.release`, за исключением "
"того, что при вызове разблокированной блокировки возникает :exc:`ValueError`."

#: ../../library/multiprocessing.rst:1355
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Объект рекурсивной блокировки: близкий аналог :class:`threading.RLock`. "
"Рекурсивная блокировка должна быть снята процессом или потоком, который ее "
"захватил. Как только процесс или поток получил рекурсивную блокировку, тот "
"же процесс или поток может получить ее снова без блокировки; этот процесс "
"или поток должен освободить его один раз за каждый раз, когда он был получен."

#: ../../library/multiprocessing.rst:1361
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Обратите внимание, что :class:`RLock` на самом деле является фабричной "
"функцией, которая возвращает экземпляр multiprocessing.synchronize.RLock``, "
"инициализированный контекстом по умолчанию."

#: ../../library/multiprocessing.rst:1365
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` поддерживает протокол :term:`контекстного менеджера` и "
"поэтому может использоваться в операторах :keyword:`with`."

#: ../../library/multiprocessing.rst:1373
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"При вызове с аргументом *block*, установленным в True, блокируется до тех "
"пор, пока блокировка не перейдет в разблокированное состояние (не "
"принадлежит какому-либо процессу или потоку), если только блокировка уже не "
"принадлежит текущему процессу или потоку. Затем текущий процесс или поток "
"становится владельцем блокировки (если он еще не владеет ею), и уровень "
"рекурсии внутри блокировки увеличивается на единицу, в результате чего "
"возвращается значение ``True``. Обратите внимание, что в поведении этого "
"первого аргумента есть несколько отличий по сравнению с реализацией :meth:"
"`threading.RLock.acquire`, начиная с имени самого аргумента."

#: ../../library/multiprocessing.rst:1383
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"При вызове с аргументом *block*, установленным в значение False, не "
"блокировать. Если блокировка уже получена (и, следовательно, принадлежит) "
"другому процессу или потоку, текущий процесс или поток не становится "
"владельцем, и уровень рекурсии внутри блокировки не изменяется, что приводит "
"к возвращаемому значению ``False`` . Если блокировка находится в "
"разблокированном состоянии, текущий процесс или поток становится владельцем, "
"а уровень рекурсии увеличивается, что приводит к возвращаемому значению "
"``True``."

#: ../../library/multiprocessing.rst:1391
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"Использование и поведение аргумента *timeout* такие же, как и в :meth:`Lock."
"acquire`. Обратите внимание, что некоторые из этих вариантов поведения "
"*timeout* отличаются от поведения, реализованного в :meth:`threading.RLock."
"acquire`."

#: ../../library/multiprocessing.rst:1398
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Снимите блокировку, уменьшив уровень рекурсии. Если после декремента уровень "
"рекурсии равен нулю, сбросьте блокировку на разблокированную (не "
"принадлежащую какому-либо процессу или потоку), и если какие-либо другие "
"процессы или потоки заблокированы в ожидании разблокировки блокировки, "
"разрешите продолжить работу ровно одному из них. Если после уменьшения "
"уровень рекурсии все еще не равен нулю, блокировка остается заблокированной "
"и принадлежит вызывающему процессу или потоку."

#: ../../library/multiprocessing.rst:1406
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Вызывайте этот метод только в том случае, если вызывающий процесс или поток "
"владеет блокировкой. Ошибка :exc:`AssertionError` возникает, если этот метод "
"вызывается процессом или потоком, отличным от владельца, или если блокировка "
"находится в разблокированном (не принадлежащем владельцу) состоянии. "
"Обратите внимание, что тип исключения, возникающего в этой ситуации, "
"отличается от реализованного поведения в :meth:`threading.RLock.release`."

#: ../../library/multiprocessing.rst:1415
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "Объект-семафор: близкий аналог :class:`threading.Semaphore`."

#: ../../library/multiprocessing.rst:1422
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"В macOS функция ``sem_timedwait`` не поддерживается, поэтому вызов "
"``acquire()`` с таймаутом будет эмулировать поведение этой функции с "
"использованием спящего цикла."

#: ../../library/multiprocessing.rst:1427
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""

#: ../../library/multiprocessing.rst:1433
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""

#: ../../library/multiprocessing.rst:1438
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"Для некоторых функций этого пакета требуется работающая реализация общего "
"семафора в операционной системе хоста. Без него модуль :mod:`multiprocessing."
"synchronize` будет отключен, а попытки импортировать его приведут к ошибке :"
"exc:`ImportError`. Дополнительную информацию см. в :issue:`3770`."

#: ../../library/multiprocessing.rst:1446
msgid "Shared :mod:`ctypes` Objects"
msgstr "Общие объекты :mod:`ctypes` "

#: ../../library/multiprocessing.rst:1448
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"Можно создавать общие объекты, используя общую память, которая может быть "
"унаследована дочерними процессами."

#: ../../library/multiprocessing.rst:1453
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Возвращает объект :mod:`ctypes`, выделенный из общей памяти. По умолчанию "
"возвращаемое значение фактически является синхронизированной оболочкой "
"объекта. Доступ к самому объекту можно получить через атрибут *value* "
"объекта :class:`Value`."

#: ../../library/multiprocessing.rst:1457
#: ../../library/multiprocessing.rst:1544
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* определяет тип возвращаемого объекта: это либо тип "
"ctypes, либо односимвольный типкод, используемый модулем :mod:`array`. "
"*\\*args* передается конструктору типа."

#: ../../library/multiprocessing.rst:1461
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Если *lock* имеет значение True (по умолчанию), то создается новый объект "
"рекурсивной блокировки для синхронизации доступа к значению. Если *lock* "
"является объектом :class:`Lock` или :class:`RLock`, то он будет "
"использоваться для синхронизации доступа к значению. Если *lock* имеет "
"значение «False», то доступ к возвращаемому объекту не будет автоматически "
"защищен блокировкой, поэтому он не обязательно будет «безопасным для "
"процесса»."

#: ../../library/multiprocessing.rst:1468
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Операции типа ``+=``, которые включают в себя чтение и запись, не являются "
"атомарными. Так что, если, например, вы хотите атомарно увеличить общее "
"значение, недостаточно просто сделать::"

#: ../../library/multiprocessing.rst:1474
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Предполагая, что связанная блокировка является рекурсивной (по умолчанию), "
"вы можете вместо этого сделать::"

#: ../../library/multiprocessing.rst:1480
#: ../../library/multiprocessing.rst:1570
#: ../../library/multiprocessing.rst:1585
msgid "Note that *lock* is a keyword-only argument."
msgstr ""
"Обратите внимание, что *lock* — это аргумент, содержащий только ключевые "
"слова."

#: ../../library/multiprocessing.rst:1484
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Верните массив ctypes, выделенный из общей памяти. По умолчанию возвращаемое "
"значение фактически является синхронизированной оболочкой массива."

#: ../../library/multiprocessing.rst:1487
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* определяет тип элементов возвращаемого массива: это либо "
"тип ctypes, либо односимвольный типкод, используемый модулем :mod:`array`. "
"Если *size_or_initializer* является целым числом, то оно определяет длину "
"массива, и изначально массив будет обнулен. В противном случае "
"*size_or_initializer* — это последовательность, которая используется для "
"инициализации массива и длина которой определяет длину массива."

#: ../../library/multiprocessing.rst:1494
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Если *lock* имеет значение True (по умолчанию), то создается новый объект "
"блокировки для синхронизации доступа к значению. Если *lock* является "
"объектом :class:`Lock` или :class:`RLock`, то он будет использоваться для "
"синхронизации доступа к значению. Если *lock* имеет значение «False», то "
"доступ к возвращаемому объекту не будет автоматически защищен блокировкой, "
"поэтому он не обязательно будет «безопасным для процесса»."

#: ../../library/multiprocessing.rst:1501
msgid "Note that *lock* is a keyword only argument."
msgstr "Обратите внимание, что *lock* — это аргумент только с ключевым словом."

#: ../../library/multiprocessing.rst:1503
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Обратите внимание, что массив :data:`ctypes.c_char` имеет атрибуты *value* и "
"*raw*, которые позволяют использовать его для хранения и извлечения строк."

#: ../../library/multiprocessing.rst:1508
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr "Модуль :mod:`multiprocessing.sharedctypes`"

#: ../../library/multiprocessing.rst:1513
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"Модуль :mod:`multiprocessing.sharedctypes` предоставляет функции для "
"выделения объектов :mod:`ctypes` из общей памяти, которые могут быть "
"унаследованы дочерними процессами."

#: ../../library/multiprocessing.rst:1519
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Хотя указатель можно сохранить в общей памяти, помните, что он будет "
"относиться к местоположению в адресном пространстве конкретного процесса. "
"Однако вполне вероятно, что указатель будет недействительным в контексте "
"второго процесса, и попытка разыменовать указатель из второго процесса может "
"привести к сбою."

#: ../../library/multiprocessing.rst:1527
msgid "Return a ctypes array allocated from shared memory."
msgstr "Верните массив ctypes, выделенный из общей памяти."

#: ../../library/multiprocessing.rst:1529
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* определяет тип элементов возвращаемого массива: это либо "
"тип ctypes, либо односимвольный типкод, используемый модулем :mod:`array`. "
"Если *size_or_initializer* является целым числом, то оно определяет длину "
"массива, и изначально массив будет обнулен. В противном случае "
"*size_or_initializer* — это последовательность, которая используется для "
"инициализации массива и длина которой определяет длину массива."

#: ../../library/multiprocessing.rst:1536
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Обратите внимание, что установка и получение элемента потенциально не "
"являются атомарными — вместо этого используйте :func:`Array`, чтобы "
"убедиться, что доступ автоматически синхронизируется с использованием "
"блокировки."

#: ../../library/multiprocessing.rst:1542
msgid "Return a ctypes object allocated from shared memory."
msgstr "Возвращает объект ctypes, выделенный из общей памяти."

#: ../../library/multiprocessing.rst:1548
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Обратите внимание, что установка и получение значения потенциально не "
"атомарны — вместо этого используйте :func:`Value`, чтобы убедиться, что "
"доступ автоматически синхронизируется с использованием блокировки."

#: ../../library/multiprocessing.rst:1552
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Обратите внимание, что массив :data:`ctypes.c_char` имеет атрибуты ``value`` "
"и ``raw``, которые позволяют использовать его для хранения и извлечения "
"строк — см. документацию для :mod:`ctypes`."

#: ../../library/multiprocessing.rst:1558
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"То же, что и :func:`RawArray`, за исключением того, что в зависимости от "
"значения *lock* вместо необработанного массива ctypes может быть возвращена "
"безопасная для процесса оболочка синхронизации."

#: ../../library/multiprocessing.rst:1562
#: ../../library/multiprocessing.rst:1578
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Если *lock* имеет значение True (по умолчанию), то создается новый объект "
"блокировки для синхронизации доступа к значению. Если *lock* является "
"объектом :class:`~multiprocessing.Lock` или :class:`~multiprocessing.RLock`, "
"то он будет использоваться для синхронизации доступа к значению. Если *lock* "
"имеет значение «False», то доступ к возвращаемому объекту не будет "
"автоматически защищен блокировкой, поэтому он не обязательно будет "
"«безопасным для процесса»."

#: ../../library/multiprocessing.rst:1574
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"То же, что :func:`RawValue`, за исключением того, что в зависимости от "
"значения *lock* вместо необработанного объекта ctypes может быть возвращена "
"безопасная для процесса оболочка синхронизации."

#: ../../library/multiprocessing.rst:1589
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Возвращает объект ctypes, выделенный из общей памяти, который является "
"копией объекта ctypes *obj*."

#: ../../library/multiprocessing.rst:1594
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Возвращает безопасный для процесса объект-оболочку для объекта ctypes, "
"который использует *lock* для синхронизации доступа. Если *lock* имеет "
"значение None (по умолчанию), то объект :class:`multiprocessing.RLock` "
"создается автоматически."

#: ../../library/multiprocessing.rst:1598
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"Синхронизированная оболочка будет иметь два метода в дополнение к методам "
"объекта, который она обертывает: :meth:`get_obj` возвращает обернутый "
"объект, а :meth:`get_lock` возвращает объект блокировки, используемый для "
"синхронизации."

#: ../../library/multiprocessing.rst:1602
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Обратите внимание, что доступ к объекту ctypes через оболочку может быть "
"намного медленнее, чем доступ к необработанному объекту ctypes."

#: ../../library/multiprocessing.rst:1605
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr ""
"Синхронизированные объекты поддерживают протокол контекстного менеджера."

#: ../../library/multiprocessing.rst:1609
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"В таблице ниже сравнивается синтаксис создания общих объектов ctypes из "
"общей памяти с обычным синтаксисом ctypes. (В таблице MyStruct находится "
"некоторый подкласс :class:`ctypes.Structure`.)"

#: ../../library/multiprocessing.rst:1614
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1614
msgid "sharedctypes using type"
msgstr "общие типы с использованием типа"

#: ../../library/multiprocessing.rst:1614
msgid "sharedctypes using typecode"
msgstr "общие типы с использованием типового кода"

#: ../../library/multiprocessing.rst:1616
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1616
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1616
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1617
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1617
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1618
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1618
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1618
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1619
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1619
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1619
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1623
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"Ниже приведен пример, в котором несколько объектов ctypes изменяются "
"дочерним процессом:"

#: ../../library/multiprocessing.rst:1661
msgid "The results printed are ::"
msgstr "Напечатанные результаты::"

#: ../../library/multiprocessing.rst:1674
msgid "Managers"
msgstr "Менеджеры"

#: ../../library/multiprocessing.rst:1676
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Менеджеры предоставляют возможность создавать данные, которые могут "
"совместно использоваться различными процессами, в том числе совместно "
"использоваться по сети между процессами, работающими на разных машинах. "
"Объект-менеджер управляет серверным процессом, который управляет *общими "
"объектами*. Другие процессы могут получать доступ к общим объектам с помощью "
"прокси."

#: ../../library/multiprocessing.rst:1685
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Возвращает запущенный объект :class:`~multiprocessing.managers.SyncManager`, "
"который можно использовать для совместного использования объектов между "
"процессами. Возвращенный объект менеджера соответствует порожденному "
"дочернему процессу и имеет методы, которые будут создавать общие объекты и "
"возвращать соответствующие прокси."

#: ../../library/multiprocessing.rst:1693
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Процессы менеджера будут завершены, как только они будут очищены от мусора "
"или их родительский процесс завершится. Классы менеджеров определены в "
"модуле :mod:`multiprocessing.managers`:"

#: ../../library/multiprocessing.rst:1699
msgid "Create a BaseManager object."
msgstr "Создайте объект BaseManager."

#: ../../library/multiprocessing.rst:1701
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"После создания необходимо вызвать :meth:`start` или ``get_server()."
"serve_forever()``, чтобы убедиться, что объект менеджера ссылается на "
"запущенный процесс менеджера."

#: ../../library/multiprocessing.rst:1704
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*адрес* — это адрес, по которому процесс-менеджер прослушивает новые "
"соединения. Если *адрес* равен «Нет», то выбирается произвольный."

#: ../../library/multiprocessing.rst:1707
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* — ключ аутентификации, который будет использоваться для проверки "
"действительности входящих подключений к серверному процессу. Если *authkey* "
"имеет значение None, то используется current_process().authkey. В противном "
"случае используется *authkey*, который должен быть байтовой строкой."

#: ../../library/multiprocessing.rst:1712
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* должен быть ``'pickle'`` (используйте сериализацию :mod:"
"`pickle`) или ``'xmlrpclib'`` (используйте сериализацию :mod:`xmlrpc."
"client`)."

#: ../../library/multiprocessing.rst:1715
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). See the :"
"func:`get_context` function."
msgstr ""
"*ctx* — объект контекста или «Нет» (используйте текущий контекст). См. "
"функцию :func:`get_context`."

#: ../../library/multiprocessing.rst:1718
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* — это тайм-аут в секундах, используемый для ожидания "
"завершения процесса, используемого менеджером, в методе :meth:`shutdown`. "
"Если время выключения истекло, процесс завершается. Если время завершения "
"процесса также истекает, процесс завершается."

#: ../../library/multiprocessing.rst:1723
msgid "Added the *shutdown_timeout* parameter."
msgstr "Добавлен параметр *shutdown_timeout*."

#: ../../library/multiprocessing.rst:1728
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Запустите подпроцесс, чтобы запустить менеджер. Если *initializer* не "
"``None``, то подпроцесс при запуске вызовет ``initializer(*initargs)``."

#: ../../library/multiprocessing.rst:1733
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Возвращает объект :class:`Server`, который представляет собой фактический "
"сервер, находящийся под контролем Менеджера. Объект :class:`Server` "
"поддерживает метод :meth:`serve_forever`::"

#: ../../library/multiprocessing.rst:1742
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` дополнительно имеет атрибут :attr:`address`."

#: ../../library/multiprocessing.rst:1746
msgid "Connect a local manager object to a remote manager process::"
msgstr ""
"Подключите объект локального менеджера к процессу удаленного менеджера:"

#: ../../library/multiprocessing.rst:1754
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Остановите процесс, используемый менеджером. Это доступно только в том "
"случае, если для запуска серверного процесса использовался :meth:`start`."

#: ../../library/multiprocessing.rst:1757
msgid "This can be called multiple times."
msgstr "Это можно вызывать несколько раз."

#: ../../library/multiprocessing.rst:1761
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"Метод класса, который можно использовать для регистрации типа или "
"вызываемого класса менеджера."

#: ../../library/multiprocessing.rst:1764
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* — это «идентификатор типа», который используется для идентификации "
"определенного типа общего объекта. Это должна быть строка."

#: ../../library/multiprocessing.rst:1767
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* — это вызываемый объект, используемый для создания объектов для "
"этого идентификатора типа. Если экземпляр менеджера будет подключен к "
"серверу с использованием метода :meth:`connect` или если аргумент "
"*create_method* имеет значение ``False``, то его можно оставить как ``None``."

#: ../../library/multiprocessing.rst:1773
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* — это подкласс :class:`BaseProxy`, который используется для "
"создания прокси для общих объектов с этим *typeid*. Если «Нет», то прокси-"
"класс создается автоматически."

#: ../../library/multiprocessing.rst:1777
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*expose* используется для указания последовательности имен методов, к "
"которым прокси-серверам для этого typeid должен быть разрешен доступ с "
"помощью :meth:`BaseProxy._callmethod`. (Если *expose* имеет значение «None», "
"то вместо него используется :attr:`proxytype._expose_`, если он существует.) "
"В случае, когда открытый список не указан, все «публичные методы» общего "
"объекта будут доступны. . (Здесь «публичный метод» означает любой атрибут, "
"который имеет метод :meth:`~object.__call__` и имя которого не начинается с "
"``'_'``.)"

#: ../../library/multiprocessing.rst:1786
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* — это сопоставление, используемое для указания типа "
"возвращаемого значения тех открытых методов, которые должны возвращать "
"прокси. Он сопоставляет имена методов со строками typeid. (Если "
"*method_to_typeid* имеет значение ``None``, то вместо него используется :"
"attr:`proxytype._method_to_typeid_`, если он существует.) Если имя метода не "
"является ключом этого сопоставления или если сопоставление имеет значение "
"``None``, тогда объект, возвращаемый методом, будет скопирован по значению."

#: ../../library/multiprocessing.rst:1793
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* определяет, следует ли создавать метод с именем *typeid*, "
"который можно использовать для указания серверному процессу создать новый "
"общий объект и вернуть для него прокси. По умолчанию это ``True``."

#: ../../library/multiprocessing.rst:1797
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""
"Экземпляры :class:`BaseManager` также имеют одно свойство, доступное только "
"для чтения:"

#: ../../library/multiprocessing.rst:1801
msgid "The address used by the manager."
msgstr "Адрес, используемый менеджером."

#: ../../library/multiprocessing.rst:1803
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Объекты менеджера поддерживают протокол управления контекстом — см. :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` запускает серверный "
"процесс (если он еще не запущен), а затем возвращает объект менеджера. :meth:"
"`~contextmanager.__exit__` вызывает :meth:`shutdown`."

#: ../../library/multiprocessing.rst:1809
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"В предыдущих версиях :meth:`~contextmanager.__enter__` не запускал серверный "
"процесс менеджера, если он еще не был запущен."

#: ../../library/multiprocessing.rst:1814
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"Подкласс :class:`BaseManager`, который можно использовать для синхронизации "
"процессов. Объекты этого типа возвращаются функцией :func:`multiprocessing."
"Manager`."

#: ../../library/multiprocessing.rst:1818
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Его методы создают и возвращают multiprocessing-proxy_objects для ряда часто "
"используемых типов данных, которые необходимо синхронизировать между "
"процессами. В частности, это касается общих списков и словарей."

#: ../../library/multiprocessing.rst:1824
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"Создайте общий объект :class:`threading.Barrier` и верните для него прокси."

#: ../../library/multiprocessing.rst:1831
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Создайте общий объект :class:`threading.BoundedSemaphore` и верните для него "
"прокси."

#: ../../library/multiprocessing.rst:1836
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Создайте общий объект :class:`threading.Condition` и верните для него прокси."

#: ../../library/multiprocessing.rst:1839
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Если указан *lock*, то он должен быть прокси для объекта :class:`threading."
"Lock` или :class:`threading.RLock`."

#: ../../library/multiprocessing.rst:1847
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Создайте общий объект :class:`threading.Event` и верните для него прокси."

#: ../../library/multiprocessing.rst:1851
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Создайте общий объект :class:`threading.Lock` и верните для него прокси."

#: ../../library/multiprocessing.rst:1855
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "Создайте общий объект :class:`Namespace` и верните для него прокси."

#: ../../library/multiprocessing.rst:1859
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr "Создайте общий объект :class:`queue.Queue` и верните для него прокси."

#: ../../library/multiprocessing.rst:1863
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Создайте общий объект :class:`threading.RLock` и верните для него прокси."

#: ../../library/multiprocessing.rst:1867
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Создайте общий объект :class:`threading.Semaphore` и верните для него прокси."

#: ../../library/multiprocessing.rst:1872
msgid "Create an array and return a proxy for it."
msgstr "Создайте массив и верните для него прокси."

#: ../../library/multiprocessing.rst:1876
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Создайте объект с записываемым атрибутом value и верните для него прокси."

#: ../../library/multiprocessing.rst:1883
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "Создайте общий объект :class:`dict` и верните для него прокси."

#: ../../library/multiprocessing.rst:1888
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "Создайте общий объект :class:`list` и верните для него прокси."

#: ../../library/multiprocessing.rst:1890
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Общие объекты могут быть вложенными. Например, общий объект-контейнер, такой "
"как общий список, может содержать другие общие объекты, которые будут "
"управляться и синхронизироваться с помощью :class:`SyncManager`."

#: ../../library/multiprocessing.rst:1897
msgid "A type that can register with :class:`SyncManager`."
msgstr "Тип, который может регистрироваться с помощью :class:`SyncManager`."

#: ../../library/multiprocessing.rst:1899
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Объект пространства имен не имеет общедоступных методов, но имеет доступные "
"для записи атрибуты. Его представление показывает значения его атрибутов."

#: ../../library/multiprocessing.rst:1902
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"Однако при использовании прокси для объекта пространства имен атрибут, "
"начинающийся с ``'_'``, будет атрибутом прокси, а не атрибутом референта:"

#: ../../library/multiprocessing.rst:1918
msgid "Customized managers"
msgstr "Индивидуальные менеджеры"

#: ../../library/multiprocessing.rst:1920
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"Чтобы создать собственный менеджер, создается подкласс :class:`BaseManager` "
"и используется метод класса :meth:`~BaseManager.register` для регистрации "
"новых типов или вызываемых объектов в классе менеджера. Например::"

#: ../../library/multiprocessing.rst:1945
msgid "Using a remote manager"
msgstr "Использование удаленного менеджера"

#: ../../library/multiprocessing.rst:1947
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"Можно запустить сервер-менеджер на одной машине и позволить клиентам "
"использовать его с других машин (при условии, что соответствующие "
"брандмауэры это позволяют)."

#: ../../library/multiprocessing.rst:1950
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"Выполнение следующих команд создает сервер для одной общей очереди, к "
"которой могут получить доступ удаленные клиенты:"

#: ../../library/multiprocessing.rst:1962
msgid "One client can access the server as follows::"
msgstr "Один клиент может получить доступ к серверу следующим образом:"

#: ../../library/multiprocessing.rst:1972
msgid "Another client can also use it::"
msgstr "Другой клиент также может использовать его::"

#: ../../library/multiprocessing.rst:1983
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Локальные процессы также могут получить доступ к этой очереди, используя "
"приведенный выше код на клиенте для удаленного доступа к ней:"

#: ../../library/multiprocessing.rst:2008
msgid "Proxy Objects"
msgstr "Прокси-объекты"

#: ../../library/multiprocessing.rst:2010
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"Прокси — это объект, который *ссылается* на общий объект, который находится "
"(предположительно) в другом процессе. Общий объект называется *референтом* "
"прокси. Несколько прокси-объектов могут иметь один и тот же референт."

#: ../../library/multiprocessing.rst:2014
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Прокси-объект имеет методы, которые вызывают соответствующие методы его "
"референта (хотя не каждый метод референта обязательно будет доступен через "
"прокси). Таким образом, прокси-сервер можно использовать так же, как и его "
"референт:"

#: ../../library/multiprocessing.rst:2032
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Обратите внимание, что применение :func:`str` к прокси вернет представление "
"референта, тогда как применение :func:`repr` вернет представление прокси."

#: ../../library/multiprocessing.rst:2036
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"Важной особенностью прокси-объектов является то, что их можно выбирать, "
"поэтому их можно передавать между процессами. Таким образом, референт может "
"содержать :ref:`multiprocessing-proxy_objects`. Это позволяет вкладывать эти "
"управляемые списки, словари и другие объекты multiprocessing-proxy_objects:"

#: ../../library/multiprocessing.rst:2052
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""
"Аналогично, прокси-серверы dict и list могут быть вложены друг в друга:"

#: ../../library/multiprocessing.rst:2065
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Если стандартные (не прокси) объекты :class:`list` или :class:`dict` "
"содержатся в референте, изменения этих изменяемых значений не будут "
"распространяться через менеджер, поскольку прокси не имеет возможности "
"узнать, когда значения содержащиеся внутри, изменяются. Однако сохранение "
"значения в прокси-контейнере (которое вызывает ``__setitem__`` на прокси-"
"объекте) распространяется через менеджер, и поэтому для эффективного "
"изменения такого элемента можно переназначить измененное значение прокси-"
"контейнеру: :"

#: ../../library/multiprocessing.rst:2084
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Этот подход, возможно, менее удобен, чем использование вложенных "
"multiprocessing-proxy_objects для большинства случаев использования, но "
"также демонстрирует уровень контроля над синхронизацией."

#: ../../library/multiprocessing.rst:2090
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Типы прокси в :mod:`multiprocessing` не поддерживают сравнения по значению. "
"Так, например, мы имеем:"

#: ../../library/multiprocessing.rst:2098
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""
"Вместо этого при сравнении следует просто использовать копию референта."

#: ../../library/multiprocessing.rst:2102
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "Прокси-объекты являются экземплярами подклассов :class:`BaseProxy`."

#: ../../library/multiprocessing.rst:2106
msgid "Call and return the result of a method of the proxy's referent."
msgstr "Вызовите и верните результат метода референта прокси."

#: ../../library/multiprocessing.rst:2108
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr ""
"Если ``proxy`` — это прокси, референтом которого является ``obj``, тогда "
"выражение ::"

#: ../../library/multiprocessing.rst:2112
msgid "will evaluate the expression ::"
msgstr "оценит выражение::"

#: ../../library/multiprocessing.rst:2116
msgid "in the manager's process."
msgstr "в процессе работы менеджера."

#: ../../library/multiprocessing.rst:2118
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""
"Возвращаемое значение будет копией результата вызова или прокси-сервером для "
"нового общего объекта — см. документацию по аргументу *method_to_typeid* :"
"meth:`BaseManager.register`."

#: ../../library/multiprocessing.rst:2122
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Если в результате вызова возникает исключение, оно повторно возбуждается :"
"meth:`_callmethod`. Если в процессе менеджера возникает какое-то другое "
"исключение, оно преобразуется в исключение :exc:`RemoteError` и вызывается :"
"meth:`_callmethod`."

#: ../../library/multiprocessing.rst:2127
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Обратите внимание, в частности, что исключение будет вызвано, если "
"*имя_метода* не было *экспонировано*."

#: ../../library/multiprocessing.rst:2130
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Пример использования :meth:`_callmethod`:"

#: ../../library/multiprocessing.rst:2146
msgid "Return a copy of the referent."
msgstr "Верните копию референта."

#: ../../library/multiprocessing.rst:2148
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "Если референт не поддается выбору, это вызовет исключение."

#: ../../library/multiprocessing.rst:2152
msgid "Return a representation of the proxy object."
msgstr "Верните представление прокси-объекта."

#: ../../library/multiprocessing.rst:2156
msgid "Return the representation of the referent."
msgstr "Верните представление референта."

#: ../../library/multiprocessing.rst:2160
msgid "Cleanup"
msgstr "Очистка"

#: ../../library/multiprocessing.rst:2162
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Прокси-объект использует обратный вызов слабой ссылки, поэтому при сборке "
"мусора он отменяет регистрацию у менеджера, которому принадлежит его "
"референт."

#: ../../library/multiprocessing.rst:2165
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Общий объект удаляется из процесса менеджера, когда на него больше не "
"ссылаются прокси."

#: ../../library/multiprocessing.rst:2170
msgid "Process Pools"
msgstr "Пулы процессов"

#: ../../library/multiprocessing.rst:2175
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"Можно создать пул процессов, которые будут выполнять задачи, переданные ему "
"с помощью класса :class:`Pool`."

#: ../../library/multiprocessing.rst:2180
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Объект пула процессов, который управляет пулом рабочих процессов, которым "
"можно отправлять задания. Он поддерживает асинхронные результаты с "
"таймаутами и обратными вызовами и имеет реализацию параллельной карты."

#: ../../library/multiprocessing.rst:2184
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* — количество используемых рабочих процессов. Если *processes* "
"имеет значение None, то используется число, возвращаемое :func:`os."
"cpu_count`."

#: ../../library/multiprocessing.rst:2187
#: ../../library/multiprocessing.rst:2748
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Если *initializer* не ``None``, тогда каждый рабочий процесс будет вызывать "
"``initializer(*initargs)`` при запуске."

#: ../../library/multiprocessing.rst:2190
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* — это количество задач, которые рабочий процесс может "
"выполнить, прежде чем он завершит работу и будет заменен новым рабочим "
"процессом, чтобы освободить неиспользуемые ресурсы. По умолчанию "
"*maxtasksperchild* имеет значение None, что означает, что рабочие процессы "
"будут существовать до тех пор, пока пул."

#: ../../library/multiprocessing.rst:2195
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately."
msgstr ""
"*context* можно использовать для указания контекста, используемого для "
"запуска рабочих процессов. Обычно пул создается с помощью функции :func:"
"`multiprocessing.Pool` или метода :meth:`Pool` объекта контекста. В обоих "
"случаях *context* установлен соответствующим образом."

#: ../../library/multiprocessing.rst:2201
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "я "

#: ../../library/multiprocessing.rst:2205
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
"Объекты :class:`multiprocessing.pool` имеют внутренние ресурсы, которыми "
"необходимо правильно управлять (как и любым другим ресурсом), используя пул "
"в качестве контекстного менеджера или вызывая :meth:`close` и :meth:"
"`terminate` вручную. Невыполнение этого требования может привести к "
"зависанию процесса на финализации."

#: ../../library/multiprocessing.rst:2210
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"Обратите внимание, что **неправильно** полагаться на сборщик мусора для "
"уничтожения пула, поскольку CPython не гарантирует, что будет вызван "
"финализатор пула (дополнительную информацию см. в :meth:`object.__del__`)."

#: ../../library/multiprocessing.rst:2214
msgid "Added the *maxtasksperchild* parameter."
msgstr "Добавлен параметр *maxtasksperchild*."

#: ../../library/multiprocessing.rst:2217
msgid "Added the *context* parameter."
msgstr "Добавлен параметр *context*."

#: ../../library/multiprocessing.rst:2222
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Рабочие процессы внутри :class:`Pool` обычно живут в течение всего времени "
"рабочей очереди пула. В других системах (таких как Apache, mod_wsgi и т. д.) "
"частая схема освобождения ресурсов, принадлежащих воркерам, заключается в "
"том, чтобы позволить воркеру в пуле выполнить только заданный объем работы "
"перед выходом, очисткой и запуском нового процесса. для замены старого. "
"Аргумент *maxtasksperchild* в :class:`Pool` предоставляет эту возможность "
"конечному пользователю."

#: ../../library/multiprocessing.rst:2232
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Вызовите *func* с аргументами *args* и ключевыми словами *kwds*. Он "
"блокируется до тех пор, пока результат не будет готов. Учитывая эти блоки, :"
"meth:`apply_async` лучше подходит для параллельного выполнения работы. Кроме "
"того, *func* выполняется только в одном из рабочих процессов пула."

#: ../../library/multiprocessing.rst:2239
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Вариант метода :meth:`apply`, который возвращает объект :class:"
"`~multiprocessing.pool.AsyncResult`."

#: ../../library/multiprocessing.rst:2242
#: ../../library/multiprocessing.rst:2273
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Если указан *callback*, это должен быть вызываемый объект, принимающий один "
"аргумент. Когда результат становится готовым, к нему применяется *callback*, "
"то есть, если вызов не удался, и в этом случае вместо него применяется "
"*error_callback*."

#: ../../library/multiprocessing.rst:2247
#: ../../library/multiprocessing.rst:2278
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Если указан *error_callback*, это должен быть вызываемый объект, принимающий "
"один аргумент. Если целевая функция завершается с ошибкой, то вызывается "
"*error_callback* с экземпляром исключения."

#: ../../library/multiprocessing.rst:2251
#: ../../library/multiprocessing.rst:2282
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Обратные вызовы должны завершиться немедленно, поскольку в противном случае "
"поток, обрабатывающий результаты, будет заблокирован."

#: ../../library/multiprocessing.rst:2256
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
"Параллельный эквивалент встроенной функции :func:`map` (однако она "
"поддерживает только один *iterable* аргумент, о нескольких итерациях см. :"
"meth:`starmap`). Он блокируется до тех пор, пока результат не будет готов."

#: ../../library/multiprocessing.rst:2260
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"Этот метод разбивает итерируемый объект на несколько фрагментов, которые он "
"передает в пул процессов как отдельные задачи. (Приблизительный) размер этих "
"фрагментов можно указать, задав для параметра *chunksize* положительное "
"целое число."

#: ../../library/multiprocessing.rst:2264
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"Обратите внимание, что это может привести к интенсивному использованию "
"памяти для очень длинных итераций. Рассмотрите возможность использования :"
"meth:`imap` или :meth:`imap_unordered` с явной опцией *chunksize* для "
"большей эффективности."

#: ../../library/multiprocessing.rst:2270
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Вариант метода :meth:`.map`, который возвращает объект :class:"
"`~multiprocessing.pool.AsyncResult`."

#: ../../library/multiprocessing.rst:2287
msgid "A lazier version of :meth:`.map`."
msgstr "Более ленивая версия :meth:`.map`."

#: ../../library/multiprocessing.rst:2289
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"Аргумент *chunksize* аналогичен аргументу, используемому методом :meth:`."
"map`. Для очень длинных итераций использование большого значения *chunksize* "
"может выполнить задание **намного** быстрее, чем использование значения по "
"умолчанию ``1``."

#: ../../library/multiprocessing.rst:2294
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Также, если *chunksize* равен ``1``, то метод :meth:`!next` итератора, "
"возвращаемого методом :meth:`imap`, имеет необязательный параметр *timeout*: "
"``next(timeout)`` вызовет :exc:`multiprocessing.TimeoutError`, если "
"результат не может быть возвращен в течение *timeout* секунд."

#: ../../library/multiprocessing.rst:2301
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"То же, что и :meth:`imap`, за исключением того, что порядок результатов "
"возвращаемого итератора следует считать произвольным. (Только когда имеется "
"только один рабочий процесс, порядок гарантированно будет «правильным».)"

#: ../../library/multiprocessing.rst:2307
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"Подобно :meth:`~multiprocessing.pool.Pool.map`, за исключением того, что "
"элементы *iterable* должны быть итерируемыми объектами, которые "
"распаковываются как аргументы."

#: ../../library/multiprocessing.rst:2311
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Следовательно, *итерация* ``[(1,2), (3, 4)]`` приводит к ``[func(1,2), "
"func(3,4)]``."

#: ../../library/multiprocessing.rst:2318
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"Комбинация :meth:`starmap` и :meth:`map_async`, которая перебирает "
"*iterable* итераций и вызывает *func* с распакованными итерациями. "
"Возвращает объект результата."

#: ../../library/multiprocessing.rst:2326
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Предотвращает отправку дополнительных задач в пул. После выполнения всех "
"задач рабочие процессы завершатся."

#: ../../library/multiprocessing.rst:2331
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Немедленно останавливает рабочие процессы, не завершая невыполненную работу. "
"Когда объект пула будет очищен от мусора, немедленно будет вызван :meth:"
"`terminate`."

#: ../../library/multiprocessing.rst:2337
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Подождите, пока рабочие процессы завершатся. Перед использованием :meth:"
"`join` необходимо вызвать :meth:`close` или :meth:`terminate`."

#: ../../library/multiprocessing.rst:2340
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Объекты пула теперь поддерживают протокол управления контекстом — см. :ref:"
"`typecontextmanager`. :meth:`~contextmanager.__enter__` возвращает объект "
"пула, а :meth:`~contextmanager.__exit__` вызывает :meth:`terminate`."

#: ../../library/multiprocessing.rst:2348
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"Класс результата, возвращаемого :meth:`Pool.apply_async` и :meth:`Pool."
"map_async`."

#: ../../library/multiprocessing.rst:2353
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Верните результат, когда он прибудет. Если *timeout* не равен ``None`` и "
"результат не приходит в течение *timeout* секунд, то возникает :exc:"
"`multiprocessing.TimeoutError`. Если удаленный вызов вызвал исключение, то "
"это исключение будет повторно вызвано :meth:`get`."

#: ../../library/multiprocessing.rst:2360
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Подождите, пока результат не будет доступен или пока не пройдет *timeout* "
"секунд."

#: ../../library/multiprocessing.rst:2364
msgid "Return whether the call has completed."
msgstr "Возвращает информацию о том, завершился ли вызов."

#: ../../library/multiprocessing.rst:2368
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"Возвращает информацию о том, завершился ли вызов без возникновения "
"исключения. Поднимет :exc:`ValueError`, если результат не готов."

#: ../../library/multiprocessing.rst:2371
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Если результат не готов, вместо :exc:`AssertionError` выдается :exc:"
"`ValueError`."

#: ../../library/multiprocessing.rst:2375
msgid "The following example demonstrates the use of a pool::"
msgstr "Следующий пример демонстрирует использование пула::"

#: ../../library/multiprocessing.rst:2402
msgid "Listeners and Clients"
msgstr "Слушатели и клиенты"

#: ../../library/multiprocessing.rst:2407
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Обычно передача сообщений между процессами осуществляется с использованием "
"очередей или объектов :class:`~Connection`, возвращаемых :func:"
"`~multiprocessing.Pipe`."

#: ../../library/multiprocessing.rst:2411
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"Однако модуль :mod:`multiprocessing.connection` обеспечивает некоторую "
"дополнительную гибкость. По сути, он предоставляет высокоуровневый API-"
"интерфейс, ориентированный на сообщения, для работы с сокетами или "
"именованными каналами Windows. Он также поддерживает *дайджест-"
"аутентификацию* с использованием модуля :mod:`hmac` и одновременный опрос "
"нескольких соединений."

#: ../../library/multiprocessing.rst:2420
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Отправьте случайно сгенерированное сообщение на другой конец соединения и "
"дождитесь ответа."

#: ../../library/multiprocessing.rst:2423
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Если ответ соответствует дайджесту сообщения с использованием *authkey* в "
"качестве ключа, на другой конец соединения отправляется приветственное "
"сообщение. В противном случае возникает :exc:`~multiprocessing."
"AuthenticationError`."

#: ../../library/multiprocessing.rst:2429
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Получите сообщение, рассчитайте дайджест сообщения, используя *authkey* в "
"качестве ключа, а затем отправьте дайджест обратно."

#: ../../library/multiprocessing.rst:2432
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Если приветственное сообщение не получено, то возникает :exc:"
"`~multiprocessing.AuthenticationError`."

#: ../../library/multiprocessing.rst:2437
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Попытайтесь установить соединение с прослушивателем, использующим адрес "
"*адрес*, возвращая :class:`~Connection`."

#: ../../library/multiprocessing.rst:2440
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"Тип соединения определяется аргументом *семейство*, но обычно его можно "
"опустить, поскольку его обычно можно вывести из формата *адрес*. (См.:ref:"
"`мультипроцессорные форматы адресов`)"

#: ../../library/multiprocessing.rst:2444
#: ../../library/multiprocessing.rst:2479
msgid ""
"If *authkey* is given and not None, it should be a byte string and will be "
"used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""

#: ../../library/multiprocessing.rst:2452
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Обертка для связанного сокета или именованного канала Windows, который "
"«прослушивает» соединения."

#: ../../library/multiprocessing.rst:2455
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*адрес* — это адрес, который будет использоваться привязанным сокетом или "
"именованным каналом объекта-прослушивателя."

#: ../../library/multiprocessing.rst:2460
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Если используется адрес «0.0.0.0», этот адрес не будет подключаемой конечной "
"точкой в ​​Windows. Если вам требуется подключаемая конечная точка, вам "
"следует использовать «127.0.0.1»."

#: ../../library/multiprocessing.rst:2464
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*семейство* — это тип используемого сокета (или именованного канала). Это "
"может быть одна из строк ``'AF_INET'`` (для сокета TCP), ``'AF_UNIX'`` (для "
"доменного сокета Unix) или ``'AF_PIPE'`` (для именованного канала "
"Windows). . Из них гарантированно будет доступен только первый. Если "
"*family* имеет значение «None», то семья определяется из формата *address*. "
"Если *адрес* также имеет значение «Нет», то выбирается значение по "
"умолчанию. По умолчанию используется семейство, которое считается самым "
"быстрым из доступных. См. :ref:`многопроцессорные форматы адресов`. Обратите "
"внимание: если *family* — это ``'AF_UNIX'`` и адрес ``None``, то сокет будет "
"создан в частном временном каталоге, созданном с использованием :func:"
"`tempfile.mkstemp`."

#: ../../library/multiprocessing.rst:2475
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Если объект-прослушиватель использует сокет, то *backlog* (1 по умолчанию) "
"передается методу :meth:`~socket.socket.listen` сокета после его привязки."

#: ../../library/multiprocessing.rst:2487
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Примите соединение через связанный сокет или именованный канал объекта-"
"прослушивателя и верните объект :class:`~Connection`. Если попытка "
"аутентификации не удалась, то возникает :exc:`~multiprocessing."
"AuthenticationError`."

#: ../../library/multiprocessing.rst:2494
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Закройте привязанный сокет или именованный канал объекта прослушивателя. Это "
"вызывается автоматически, когда прослушиватель выполняет сбор мусора. Однако "
"желательно вызывать его явно."

#: ../../library/multiprocessing.rst:2498
msgid "Listener objects have the following read-only properties:"
msgstr ""
"Объекты прослушивателя имеют следующие свойства, доступные только для чтения:"

#: ../../library/multiprocessing.rst:2502
msgid "The address which is being used by the Listener object."
msgstr "Адрес, который используется объектом Listener."

#: ../../library/multiprocessing.rst:2506
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"Адрес, с которого пришло последнее принятое соединение. Если это недоступно, "
"то это «Нет»."

#: ../../library/multiprocessing.rst:2509
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Объекты прослушивателя теперь поддерживают протокол управления контекстом — "
"см. :ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` возвращает "
"объект прослушивателя, а :meth:`~contextmanager.__exit__` вызывает :meth:"
"`close`."

#: ../../library/multiprocessing.rst:2516
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Подождите, пока объект в *object_list* не будет готов. Возвращает список тех "
"объектов в *object_list*, которые готовы. Если *timeout* является числом с "
"плавающей запятой, то вызов блокируется не более чем на указанное количество "
"секунд. Если *timeout* имеет значение «None», то он будет заблокирован на "
"неограниченный период. Отрицательный тайм-аут эквивалентен нулевому тайм-"
"ауту."

#: ../../library/multiprocessing.rst:2522
msgid ""
"For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr ""

#: ../../library/multiprocessing.rst:2525
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "читаемый объект :class:`~multiprocessing.connection.Connection`;"

#: ../../library/multiprocessing.rst:2526
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "подключенный и читаемый объект :class:`socket.socket`; или"

#: ../../library/multiprocessing.rst:2527
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"атрибут :attr:`~multiprocessing.Process.sentinel` объекта :class:"
"`~multiprocessing.Process`."

#: ../../library/multiprocessing.rst:2530
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"Объект соединения или сокета готов, когда есть данные, доступные для чтения, "
"или когда другой конец закрыт."

#: ../../library/multiprocessing.rst:2533
msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""

#: ../../library/multiprocessing.rst:2539
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`~io.IOBase.fileno` method which returns a socket handle or pipe "
"handle.  (Note that pipe handles and socket handles are **not** waitable "
"handles.)"
msgstr ""
"**Windows**: элемент в *object_list* должен быть либо целочисленным "
"дескриптором, который является ожидаемым (согласно определению, "
"используемому в документации Win32-функции ``WaitForMultipleObjects()``), "
"либо это может быть объект с :meth:`~io.IOBase.fileno` метод, который "
"возвращает дескриптор сокета или дескриптор канала. (Обратите внимание, что "
"дескрипторы каналов и дескрипторы сокетов **не** являются дескрипторами "
"ожидания.)"

#: ../../library/multiprocessing.rst:2549
msgid "**Examples**"
msgstr "**Примеры**."

#: ../../library/multiprocessing.rst:2551
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"Следующий код сервера создает прослушиватель, который использует секретный "
"пароль в качестве ключа аутентификации. Затем он ожидает соединения и "
"отправляет некоторые данные клиенту:"

#: ../../library/multiprocessing.rst:2570
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""
"Следующий код подключается к серверу и получает с него некоторые данные:"

#: ../../library/multiprocessing.rst:2587
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"Следующий код использует :func:`~multiprocessing.connection.wait` для "
"ожидания сообщений от нескольких процессов одновременно::"

#: ../../library/multiprocessing.rst:2626
msgid "Address Formats"
msgstr "Форматы адресов"

#: ../../library/multiprocessing.rst:2628
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"Адрес ``'AF_INET'`` представляет собой кортеж вида ``(имя хоста, порт)``, "
"где *hostname* — это строка, а *port* — целое число."

#: ../../library/multiprocessing.rst:2631
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"Адрес ``'AF_UNIX'`` представляет собой строку, представляющую имя файла в "
"файловой системе."

#: ../../library/multiprocessing.rst:2634
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"Адрес ``'AF_PIPE'`` представляет собой строку вида :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`. Чтобы использовать :func:`Client` для "
"подключения к именованному каналу на удаленном компьютере с именем "
"*ServerName*, следует использовать адрес в форме :samp:`r'\\\\\\\\\\\\\\"
"\\{ServerName}\\\\pipe \\\\\\\\{PipeName}'` вместо этого."

#: ../../library/multiprocessing.rst:2639
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Обратите внимание, что любая строка, начинающаяся с двух обратных косых "
"черт, по умолчанию считается адресом AF_PIPE, а не адресом AF_UNIX."

#: ../../library/multiprocessing.rst:2646
msgid "Authentication keys"
msgstr "Ключи аутентификации"

#: ../../library/multiprocessing.rst:2648
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"При использовании :meth:`Connection.recv <Connection.recv>` полученные "
"данные автоматически деконфигурируются. К сожалению, извлечение данных из "
"ненадежного источника представляет собой угрозу безопасности. Поэтому :class:"
"`Listener` и :func:`Client` используют модуль :mod:`hmac` для обеспечения "
"дайджест-аутентификации."

#: ../../library/multiprocessing.rst:2654
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"Ключ аутентификации — это байтовая строка, которую можно рассматривать как "
"пароль: как только соединение установлено, оба конца потребуют "
"доказательства того, что другой знает ключ аутентификации. (Демонстрация "
"того, что оба конца используют один и тот же ключ, **не** предполагает "
"отправку ключа по соединению.)"

#: ../../library/multiprocessing.rst:2660
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Если запрашивается аутентификация, но ключ аутентификации не указан, то "
"используется возвращаемое значение ``current_process().authkey`` (см. :class:"
"`~multiprocessing.Process`). Это значение будет автоматически унаследовано "
"любым объектом :class:`~multiprocessing.Process`, созданным текущим "
"процессом. Это означает, что (по умолчанию) все процессы многопроцессной "
"программы будут использовать один ключ аутентификации, который можно "
"использовать при настройке соединений между собой."

#: ../../library/multiprocessing.rst:2668
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Подходящие ключи аутентификации также можно сгенерировать с помощью :func:"
"`os.urandom`."

#: ../../library/multiprocessing.rst:2672
msgid "Logging"
msgstr "Логирование"

#: ../../library/multiprocessing.rst:2674
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Доступна некоторая поддержка ведения журнала. Однако обратите внимание, что "
"пакет :mod:`logging` не использует общие блокировки процессов, поэтому (в "
"зависимости от типа обработчика) сообщения от разных процессов могут "
"перепутаться."

#: ../../library/multiprocessing.rst:2681
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Возвращает регистратор, используемый :mod:`multiprocessing`. При "
"необходимости будет создан новый."

#: ../../library/multiprocessing.rst:2684
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"При первом создании регистратор имеет уровень :const:`logging.NOTSET` и не "
"имеет обработчика по умолчанию. Сообщения, отправленные в этот регистратор, "
"по умолчанию не передаются в корневой регистратор."

#: ../../library/multiprocessing.rst:2688
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Обратите внимание, что в Windows дочерние процессы наследуют только уровень "
"журнала родительского процесса — любые другие настройки журнала не будут "
"унаследованы."

#: ../../library/multiprocessing.rst:2695
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"Эта функция выполняет вызов :func:`get_logger`, но в дополнение к возврату "
"регистратора, созданного get_logger, она добавляет обработчик, который "
"отправляет выходные данные в :data:`sys.stderr`, используя формат ``'[ %(имя "
"уровня)s / %(имяпроцесса)с ] %(сообщение)с '``. Вы можете изменить ``имя "
"уровня`` регистратора, передав аргумент ``level``."

#: ../../library/multiprocessing.rst:2701
msgid "Below is an example session with logging turned on::"
msgstr "Ниже приведен пример сеанса с включенным журналированием::"

#: ../../library/multiprocessing.rst:2716
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"Полную таблицу уровней журналирования можно найти в модуле :mod:`logging`."

#: ../../library/multiprocessing.rst:2720
msgid "The :mod:`multiprocessing.dummy` module"
msgstr "Модуль :mod:`multiprocessing.dummy`"

#: ../../library/multiprocessing.rst:2725
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` копирует API :mod:`multiprocessing`, но "
"является не более чем оболочкой модуля :mod:`threading`."

#: ../../library/multiprocessing.rst:2730
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"В частности, функция Pool, предоставляемая :mod:`multiprocessing.dummy`, "
"возвращает экземпляр :class:`ThreadPool`, который является подклассом :class:"
"`Pool`, который поддерживает все те же вызовы методов, но использует пул "
"рабочих потоков, а не рабочих процессов."

#: ../../library/multiprocessing.rst:2738
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"Объект пула потоков, который управляет пулом рабочих потоков, в которые "
"можно отправлять задания. Экземпляры :class:`ThreadPool` полностью "
"совместимы по интерфейсу с экземплярами :class:`Pool`, и их ресурсами также "
"необходимо правильно управлять, либо используя пул в качестве контекстного "
"менеджера, либо вызывая :meth:`~multiprocessing.pool. Pool.close` и :meth:"
"`~multiprocessing.pool.Pool.terminate` вручную."

#: ../../library/multiprocessing.rst:2745
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*процессы* — количество используемых рабочих потоков. Если *processes* имеет "
"значение None, то используется число, возвращаемое :func:`os.cpu_count`."

#: ../../library/multiprocessing.rst:2751
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""
"В отличие от :class:`Pool`, *maxtasksperchild* и *context* не могут быть "
"предоставлены."

#: ../../library/multiprocessing.rst:2755
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
":class:`ThreadPool` использует тот же интерфейс, что и :class:`Pool`, "
"который разработан на основе пула процессов и появился до появления модуля :"
"class:`concurrent.futures`. Таким образом, он наследует некоторые операции, "
"которые не имеют смысла для пула, поддерживаемого потоками, и имеет "
"собственный тип для представления состояния асинхронных заданий, :class:"
"`AsyncResult`, который не понимается никакими другими библиотеками."

#: ../../library/multiprocessing.rst:2762
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"Пользователям, как правило, следует предпочитать использовать :class:"
"`concurrent.futures.ThreadPoolExecutor`, который имеет более простой "
"интерфейс, изначально разработанный для потоков, и который возвращает "
"экземпляры :class:`concurrent.futures.Future`, совместимые со многими другие "
"библиотеки, включая :mod:`asyncio`."

#: ../../library/multiprocessing.rst:2772
msgid "Programming guidelines"
msgstr "Рекомендации по программированию"

#: ../../library/multiprocessing.rst:2774
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Существуют определенные рекомендации и идиомы, которых следует "
"придерживаться при использовании :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:2779
msgid "All start methods"
msgstr "Все методы запуска"

#: ../../library/multiprocessing.rst:2781
msgid "The following applies to all start methods."
msgstr "Следующее применимо ко всем методам запуска."

#: ../../library/multiprocessing.rst:2783
msgid "Avoid shared state"
msgstr "Избегайте общего состояния"

#: ../../library/multiprocessing.rst:2785
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"Насколько это возможно, следует стараться избегать перемещения больших "
"объемов данных между процессами."

#: ../../library/multiprocessing.rst:2788
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Вероятно, лучше придерживаться использования очередей или каналов для связи "
"между процессами, а не использовать примитивы синхронизации нижнего уровня."

#: ../../library/multiprocessing.rst:2792
msgid "Picklability"
msgstr "Маринуемость"

#: ../../library/multiprocessing.rst:2794
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "Убедитесь, что аргументы методов прокси можно выбрать."

#: ../../library/multiprocessing.rst:2796
msgid "Thread safety of proxies"
msgstr "Потокобезопасность прокси"

#: ../../library/multiprocessing.rst:2798
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"Не используйте прокси-объект из более чем одного потока, если вы не защитите "
"его блокировкой."

#: ../../library/multiprocessing.rst:2801
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Никогда не возникает проблем с использованием одного и того же прокси-"
"сервера разными процессами.)"

#: ../../library/multiprocessing.rst:2803
msgid "Joining zombie processes"
msgstr "Присоединение к процессам-зомби"

#: ../../library/multiprocessing.rst:2805
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie. "
"There should never be very many because each time a new process starts (or :"
"func:`~multiprocessing.active_children` is called) all completed processes "
"which have not yet been joined will be joined.  Also calling a finished "
"process's :meth:`Process.is_alive <multiprocessing.Process.is_alive>` will "
"join the process.  Even so it is probably good practice to explicitly join "
"all the processes that you start."
msgstr ""

#: ../../library/multiprocessing.rst:2813
msgid "Better to inherit than pickle/unpickle"
msgstr "Лучше наследовать, чем мариновать/расмариновать"

#: ../../library/multiprocessing.rst:2815
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"При использовании методов запуска *spawn* или *forkserver* многие типы из :"
"mod:`multiprocessing` должны быть доступны для выбора, чтобы дочерние "
"процессы могли их использовать. Однако обычно следует избегать отправки "
"общих объектов другим процессам с помощью каналов или очередей. Вместо этого "
"вам следует организовать программу так, чтобы процесс, которому необходим "
"доступ к общему ресурсу, созданному где-то еще, мог унаследовать его от "
"процесса-предка."

#: ../../library/multiprocessing.rst:2823
msgid "Avoid terminating processes"
msgstr "Избегайте завершения процессов"

#: ../../library/multiprocessing.rst:2825
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"Использование метода :meth:`Process.terminate <multiprocessing.Process."
"terminate>` для остановки процесса может привести к поломке или поломке "
"любых общих ресурсов (таких как блокировки, семафоры, каналы и очереди), "
"которые в настоящее время используются процессом. недоступен другим "
"процессам."

#: ../../library/multiprocessing.rst:2831
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Поэтому, вероятно, лучше рассмотреть возможность использования :meth:"
"`Process.terminate <multiprocessing.Process.terminate>` только для "
"процессов, которые никогда не используют какие-либо общие ресурсы."

#: ../../library/multiprocessing.rst:2835
msgid "Joining processes that use queues"
msgstr "Присоединение к процессам, использующим очереди"

#: ../../library/multiprocessing.rst:2837
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Имейте в виду, что процесс, поместивший элементы в очередь, будет ждать "
"перед завершением, пока все буферизованные элементы не будут переданы "
"«фидерным» потоком в базовый канал. (Дочерний процесс может вызвать метод "
"очереди :meth:`Queue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`, чтобы избежать такого поведения.)"

#: ../../library/multiprocessing.rst:2843
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Это означает, что всякий раз, когда вы используете очередь, вам необходимо "
"убедиться, что все элементы, помещенные в очередь, в конечном итоге будут "
"удалены до присоединения к процессу. В противном случае вы не можете быть "
"уверены, что процессы, поместившие элементы в очередь, завершатся. Помните "
"также, что недемонические процессы будут присоединены автоматически."

#: ../../library/multiprocessing.rst:2849
msgid "An example which will deadlock is the following::"
msgstr "Пример тупиковой ситуации следующий:"

#: ../../library/multiprocessing.rst:2863
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"Исправлением здесь было бы поменять местами последние две строки (или просто "
"удалить строку ``p.join()``)."

#: ../../library/multiprocessing.rst:2866
msgid "Explicitly pass resources to child processes"
msgstr "Явно передавать ресурсы дочерним процессам"

#: ../../library/multiprocessing.rst:2868
msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""

#: ../../library/multiprocessing.rst:2873
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Помимо обеспечения (потенциальной) совместимости кода с Windows и другими "
"методами запуска, это также гарантирует, что пока дочерний процесс все еще "
"активен, объект не будет собирать мусор в родительском процессе. Это может "
"быть важно, если какой-то ресурс освобождается при сборке мусора в "
"родительском процессе."

#: ../../library/multiprocessing.rst:2880
msgid "So for instance ::"
msgstr ""
"Так, например:::\n"
" "

#: ../../library/multiprocessing.rst:2892
msgid "should be rewritten as ::"
msgstr ""
"Так, например:::\n"
" "

#: ../../library/multiprocessing.rst:2904
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr "Остерегайтесь замены :data:`sys.stdin` на «файлоподобный объект»."

#: ../../library/multiprocessing.rst:2906
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing` изначально безоговорочно назывался::"

#: ../../library/multiprocessing.rst:2910
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""
"в методе :meth:`multiprocessing.Process._bootstrap` --- это приводило к "
"проблемам с процессами в процессах. Это было изменено на::"

#: ../../library/multiprocessing.rst:2916
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close()` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""

#: ../../library/multiprocessing.rst:2923
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""
"Если вы пишете файлоподобный объект и реализуете собственное кэширование, вы "
"можете сделать его безопасным для разветвлений, сохраняя pid при каждом "
"добавлении в кеш и удаляя кеш при изменении pid. Например::"

#: ../../library/multiprocessing.rst:2935
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""
"Для получения дополнительной информации см. :issue:`5155`, :issue:`5313` и :"
"issue:`5331`."

#: ../../library/multiprocessing.rst:2938
msgid "The *spawn* and *forkserver* start methods"
msgstr "Методы запуска *spawn* и *forkserver*"

#: ../../library/multiprocessing.rst:2940
msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr ""
"Существует несколько дополнительных ограничений, которые не применяются к "
"методу запуска *fork*."

#: ../../library/multiprocessing.rst:2943
msgid "More picklability"
msgstr "допусnимо использовать с pickle"

#: ../../library/multiprocessing.rst:2945
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. Also, "
"if you subclass :class:`~multiprocessing.Process` then make sure that "
"instances will be picklable when the :meth:`Process.start <multiprocessing."
"Process.start>` method is called."
msgstr ""
"Убедитесь, что все аргументы :meth:`Process.__init__` доступны для выбора. "
"Кроме того, если вы создаете подкласс :class:`~multiprocessing.Process`, "
"убедитесь, что экземпляры будут доступны для выбора при вызове метода :meth:"
"`Process.start <multiprocessing.Process.start>`."

#: ../../library/multiprocessing.rst:2950
msgid "Global variables"
msgstr "Глобальные переменные"

#: ../../library/multiprocessing.rst:2952
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Имейте в виду, что если код, запущенный в дочернем процессе, пытается "
"получить доступ к глобальной переменной, то значение, которое он видит (если "
"таковое имеется), может не совпадать со значением в родительском процессе в "
"момент запуска :meth:`Process.start. <multiprocessing.Process.start>` был "
"вызван."

#: ../../library/multiprocessing.rst:2957
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"Однако глобальные переменные, которые являются просто константами уровня "
"модуля, не вызывают проблем."

#: ../../library/multiprocessing.rst:2962
msgid "Safe importing of main module"
msgstr "Безопасный импорт основного модуля"

#: ../../library/multiprocessing.rst:2964
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr ""
"Убедитесь, что основной модуль может быть безопасно импортирован новым "
"интерпретатором Python, не вызывая непредвиденных побочных эффектов "
"(например, запуска нового процесса)."

#: ../../library/multiprocessing.rst:2968
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Например, использование метода запуска *spawn* или *forkserver* при запуске "
"следующего модуля приведет к ошибке :exc:`RuntimeError`::"

#: ../../library/multiprocessing.rst:2980
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"Вместо этого следует защитить «точку входа» программы, используя ``if "
"__name__ == '__main__':`` следующим образом:"

#: ../../library/multiprocessing.rst:2994
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(Строку ``freeze_support()`` можно опустить, если программа будет работать "
"нормально, а не зависать.)"

#: ../../library/multiprocessing.rst:2997
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Это позволяет вновь созданному интерпретатору Python безопасно импортировать "
"модуль, а затем запустить его функцию ``foo()``."

#: ../../library/multiprocessing.rst:3000
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Аналогичные ограничения применяются, если в основном модуле создан пул или "
"менеджер."

#: ../../library/multiprocessing.rst:3007
msgid "Examples"
msgstr "Примеры"

#: ../../library/multiprocessing.rst:3009
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""
"Демонстрация того, как создавать и использовать индивидуальные менеджеры и "
"прокси:"

#: ../../library/multiprocessing.rst:3015
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "Использование :class:`~multiprocessing.pool.Pool`:"

#: ../../library/multiprocessing.rst:3021
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Пример, показывающий, как использовать очереди для передачи задач коллекции "
"рабочих процессов и сбора результатов:"
