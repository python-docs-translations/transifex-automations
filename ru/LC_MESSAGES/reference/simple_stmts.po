# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "Простые утверждения"

#: ../../reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""
"Простое утверждение состоит из одной логической строки. Несколько простых "
"операторов могут находиться в одной строке, разделенной точкой с запятой. "
"Синтаксис простых операторов:"

#: ../../reference/simple_stmts.rst:37
msgid "Expression statements"
msgstr "Операторы выражения"

#: ../../reference/simple_stmts.rst:44
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""
"Операторы-выражения используются (в основном в интерактивном режиме) для "
"вычисления и записи значения или (обычно) для вызова процедуры (функция, "
"которая не возвращает значимого результата; в Python процедуры возвращают "
"значение None). Другие варианты использования выражений разрешены и иногда "
"полезны. Синтаксис оператора выражения:"

#: ../../reference/simple_stmts.rst:53
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""
"Оператор выражения оценивает список выражений (который может быть одним "
"выражением)."

#: ../../reference/simple_stmts.rst:65
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""
"В интерактивном режиме, если значение отличается от ``None``, оно "
"преобразуется в строку с помощью встроенной функции :func:`repr`, и "
"результирующая строка записывается в стандартный вывод в отдельной строке "
"(кроме случаев, когда результатом будет ``None``, так что вызовы процедур не "
"приводят к каким-либо выводам.)"

#: ../../reference/simple_stmts.rst:73
msgid "Assignment statements"
msgstr "Операторы присвоения"

#: ../../reference/simple_stmts.rst:83
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""
"Операторы присваивания используются для (повторной) привязки имен к "
"значениям и для изменения атрибутов или элементов изменяемых объектов:"

#: ../../reference/simple_stmts.rst:97
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""
"(Определения синтаксиса для *attributeref*, *subscription* и *slicing* см. в "
"разделе :ref:`primaries`.)"

#: ../../reference/simple_stmts.rst:100
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""
"Оператор присваивания оценивает список выражений (помните, что это может "
"быть одно выражение или список, разделенный запятыми, причем последний дает "
"кортеж) и присваивает один результирующий объект каждому из целевых списков "
"слева направо."

#: ../../reference/simple_stmts.rst:109
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""
"Присваивание определяется рекурсивно в зависимости от формы цели (списка). "
"Когда целевой объект является частью изменяемого объекта (ссылка на атрибут, "
"подписка или срез), изменяемый объект должен в конечном итоге выполнить "
"назначение и принять решение о его допустимости, а также может вызвать "
"исключение, если назначение неприемлемо. Правила, соблюдаемые различными "
"типами, и возникающие исключения приведены вместе с определением типов "
"объектов (см. раздел :ref:`types`)."

#: ../../reference/simple_stmts.rst:122
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""
"Присвоение объекта целевому списку, возможно заключенному в круглые или "
"квадратные скобки, рекурсивно определяется следующим образом."

#: ../../reference/simple_stmts.rst:125
msgid ""
"If the target list is a single target with no trailing comma, optionally in "
"parentheses, the object is assigned to that target."
msgstr ""
"Если список целей представляет собой одну цель без запятой в конце "
"(необязательно в круглых скобках), объект назначается этой цели."

#: ../../reference/simple_stmts.rst:128
msgid "Else:"
msgstr "Else:"

#: ../../reference/simple_stmts.rst:130
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be an iterable with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the iterable are assigned, from left to right, to the targets before the "
"starred target.  The final items of the iterable are assigned to the targets "
"after the starred target.  A list of the remaining items in the iterable is "
"then assigned to the starred target (the list can be empty)."
msgstr ""
"Если целевой список содержит одну цель с префиксом звездочки, называемую "
"«помеченной» целью: объект должен быть итерируемым, содержащим как минимум "
"столько элементов, сколько целей в целевом списке минус один. Первые "
"элементы итерации назначаются слева направо целям перед помеченной целью. "
"Последние элементы итерации назначаются целям после помеченной цели. Затем "
"список оставшихся элементов в итерации присваивается отмеченной цели (список "
"может быть пустым)."

#: ../../reference/simple_stmts.rst:138
msgid ""
"Else: The object must be an iterable with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""
"Иначе: объект должен быть итерируемым с тем же количеством элементов, что и "
"целевые объекты в целевом списке, и элементы назначаются слева направо "
"соответствующим целевым объектам."

#: ../../reference/simple_stmts.rst:142
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""
"Присвоение объекта одной цели рекурсивно определяется следующим образом."

#: ../../reference/simple_stmts.rst:144
msgid "If the target is an identifier (name):"
msgstr "Если целью является идентификатор (имя):"

#: ../../reference/simple_stmts.rst:146
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""
"Если имя не встречается в операторе :keyword:`global` или :keyword:"
"`nonlocal` в текущем блоке кода: имя привязано к объекту в текущем локальном "
"пространстве имен."

#: ../../reference/simple_stmts.rst:150
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"В противном случае: имя привязано к объекту в глобальном пространстве имен "
"или внешнем пространстве имен, определяемом :keyword:`nonlocal` "
"соответственно."

#: ../../reference/simple_stmts.rst:155
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""
"Имя восстанавливается, если оно уже было привязано. Это может привести к "
"тому, что счетчик ссылок для объекта, ранее привязанного к имени, достигнет "
"нуля, что приведет к освобождению объекта и вызову его деструктора (если он "
"есть)."

#: ../../reference/simple_stmts.rst:161
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""
"Если целью является ссылка на атрибут: оценивается основное выражение в "
"ссылке. Он должен дать объект с назначаемыми атрибутами; если это не так, "
"возникает :exc:`TypeError`. Затем этому объекту предлагается присвоить "
"назначенный объект данному атрибуту; если он не может выполнить назначение, "
"он вызывает исключение (обычно, но не обязательно :exc:`AttributeError`)."

#: ../../reference/simple_stmts.rst:170
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the right-hand side expression, "
"``a.x`` can access either an instance attribute or (if no instance attribute "
"exists) a class attribute.  The left-hand side target ``a.x`` is always set "
"as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if "
"the right-hand side expression refers to a class attribute, the left-hand "
"side creates a new instance attribute as the target of the assignment::"
msgstr ""
"Примечание. Если объект является экземпляром класса и ссылка на атрибут "
"встречается с обеих сторон оператора присваивания, выражение в правой части "
"``ax`` может получить доступ либо к атрибуту экземпляра, либо (если атрибут "
"экземпляра не существует) к классу. атрибут. Левая цель ``ax`` всегда "
"устанавливается как атрибут экземпляра, при необходимости его можно создать. "
"Таким образом, два вхождения ``ax`` не обязательно относятся к одному и тому "
"же атрибуту: если выражение в правой части относится к атрибуту класса, "
"левая часть создает новый атрибут экземпляра в качестве цели присваивания: :"

#: ../../reference/simple_stmts.rst:179
msgid ""
"class Cls:\n"
"    x = 3             # class variable\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"
msgstr ""
"class Cls:\n"
"    x = 3             # class variable\n"
"inst = Cls()\n"
"inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3"

#: ../../reference/simple_stmts.rst:184
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""
"Это описание не обязательно применимо к атрибутам дескриптора, таким как "
"свойства, созданные с помощью :func:`property`."

#: ../../reference/simple_stmts.rst:191
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"Если целью является подписка: оценивается основное выражение в ссылке. Он "
"должен возвращать либо изменяемый объект последовательности (например, "
"список), либо объект сопоставления (например, словарь). Затем оценивается "
"выражение индекса."

#: ../../reference/simple_stmts.rst:200
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""
"Если основным является изменяемый объект последовательности (например, "
"список), нижний индекс должен возвращать целое число. Если оно "
"отрицательное, к нему добавляется длина последовательности. Результирующее "
"значение должно быть неотрицательным целым числом, меньшим длины "
"последовательности, и последовательности предлагается назначить назначенный "
"объект своему элементу с этим индексом. Если индекс выходит за пределы "
"диапазона, возникает :exc:`IndexError` (присвоение индексной "
"последовательности не может добавлять новые элементы в список)."

#: ../../reference/simple_stmts.rst:211
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/value pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""
"Если первичным является объект сопоставления (например, словарь), нижний "
"индекс должен иметь тип, совместимый с типом ключа сопоставления, а затем "
"сопоставлению предлагается создать пару ключ/значение, которая сопоставляет "
"нижний индекс назначенному объекту. Это может либо заменить существующую "
"пару ключ/значение тем же значением ключа, либо вставить новую пару ключ/"
"значение (если ключа с таким же значением не существует)."

#: ../../reference/simple_stmts.rst:217
msgid ""
"For user-defined objects, the :meth:`~object.__setitem__` method is called "
"with appropriate arguments."
msgstr ""
"Для пользовательских объектов метод :meth:`~object.__setitem__` вызывается с "
"соответствующими аргументами."

#: ../../reference/simple_stmts.rst:222
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""
"Если целью является срез: оценивается основное выражение в ссылке. Он должен "
"давать изменяемый объект последовательности (например, список). Назначенный "
"объект должен быть объектом последовательности того же типа. Далее "
"оцениваются выражения нижней и верхней границы, насколько они присутствуют; "
"значения по умолчанию — ноль и длина последовательности. Границы должны "
"оцениваться как целые числа. Если какая-либо граница отрицательна, к ней "
"добавляется длина последовательности. Полученные границы обрезаются так, "
"чтобы они находились между нулем и длиной последовательности включительно. "
"Наконец, объекту последовательности предлагается заменить срез элементами "
"назначенной последовательности. Длина среза может отличаться от длины "
"назначенной последовательности, изменяя таким образом длину целевой "
"последовательности, если целевая последовательность это позволяет."

#: ../../reference/simple_stmts.rst:236
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"В текущей реализации синтаксис целевых объектов аналогичен синтаксису "
"выражений, а недопустимый синтаксис отклоняется на этапе генерации кода, что "
"приводит к менее подробным сообщениям об ошибках."

#: ../../reference/simple_stmts.rst:240
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultaneous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""
"Хотя определение присваивания подразумевает, что перекрытие между левой и "
"правой частями происходит «одновременно» (например, «a, b = b, a» меняет "
"местами две переменные), перекрытие *внутри* коллекции присвоенные "
"переменные располагаются слева направо, что иногда приводит к путанице. "
"Например, следующая программа печатает ``[0, 2]``::"

#: ../../reference/simple_stmts.rst:246
msgid ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i is updated, then x[i] is updated\n"
"print(x)"
msgstr ""
"x = [0, 1]\n"
"i = 0\n"
"i, x[i] = 1, 2         # i is updated, then x[i] is updated\n"
"print(x)"

#: ../../reference/simple_stmts.rst:254
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - Расширенная итеративная распаковка"

#: ../../reference/simple_stmts.rst:255
msgid "The specification for the ``*target`` feature."
msgstr "Спецификация функции ``*target``."

#: ../../reference/simple_stmts.rst:261
msgid "Augmented assignment statements"
msgstr "Расширенные операторы присваивания"

#: ../../reference/simple_stmts.rst:279
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""
"Расширенное присваивание — это комбинация в одном операторе бинарной "
"операции и оператора присваивания:"

#: ../../reference/simple_stmts.rst:288
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""
"(См. раздел :ref:`primaries` для определения синтаксиса последних трёх "
"символов.)"

#: ../../reference/simple_stmts.rst:291
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""
"Расширенное присваивание оценивает цель (которая, в отличие от обычных "
"операторов присваивания, не может быть распаковкой) и список выражений, "
"выполняет двоичную операцию, специфичную для типа присваивания, над двумя "
"операндами и присваивает результат исходной цели. Цель оценивается только "
"один раз."

#: ../../reference/simple_stmts.rst:296
msgid ""
"An augmented assignment statement like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""
"Оператор расширенного присваивания, например ``x += 1``, ​​можно переписать "
"как ``x = x + 1`` для достижения аналогичного, но не совсем равного эффекта. "
"В расширенной версии ``x`` вычисляется только один раз. Кроме того, когда "
"это возможно, фактическая операция выполняется *на месте*, что означает, что "
"вместо создания нового объекта и назначения его целевому объекту вместо "
"этого модифицируется старый объект."

#: ../../reference/simple_stmts.rst:302
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"В отличие от обычных заданий, расширенные задания оценивают левую часть "
"*перед* оценкой правой части. Например, ``a[i] += f(x)`` сначала ищет "
"``a[i]``, затем вычисляет ``f(x)`` и выполняет сложение, и, наконец, он "
"записывает результат обратно в ``a[i]``."

#: ../../reference/simple_stmts.rst:307
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""
"За исключением присвоения кортежам и нескольким целям в одном операторе, "
"присваивание, выполняемое расширенными операторами присваивания, "
"обрабатывается так же, как и обычные присваивания. Аналогично, за "
"исключением возможного поведения *на месте*, двоичная операция, выполняемая "
"расширенным присваиванием, такая же, как и обычные двоичные операции."

#: ../../reference/simple_stmts.rst:313
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"Для целей, которые являются ссылками на атрибуты, применяется то же :ref:"
"`предостережение относительно атрибутов класса и экземпляра <attr-target-"
"note>`, что и для обычных присвоений."

#: ../../reference/simple_stmts.rst:320
msgid "Annotated assignment statements"
msgstr "Аннотированные операторы присваивания"

#: ../../reference/simple_stmts.rst:327
msgid ""
":term:`Annotation <variable annotation>` assignment is the combination, in a "
"single statement, of a variable or attribute annotation and an optional "
"assignment statement:"
msgstr ""
":term:`Annotation <variable annotation>` Присваивание — это комбинация в "
"одном операторе аннотации переменной или атрибута и необязательного "
"оператора присваивания:"

#: ../../reference/simple_stmts.rst:334
msgid ""
"The difference from normal :ref:`assignment` is that only a single target is "
"allowed."
msgstr ""
"Отличие от обычного :ref:`assignment` заключается в том, что допускается "
"только одна цель."

#: ../../reference/simple_stmts.rst:336
msgid ""
"The assignment target is considered \"simple\" if it consists of a single "
"name that is not enclosed in parentheses. For simple assignment targets, if "
"in class or module scope, the annotations are evaluated and stored in a "
"special class or module attribute :attr:`__annotations__` that is a "
"dictionary mapping from variable names (mangled if private) to evaluated "
"annotations. This attribute is writable and is automatically created at the "
"start of class or module body execution, if annotations are found statically."
msgstr ""
"Цель назначения считается «простой», если она состоит из одного имени, не "
"заключенного в круглые скобки. Для целей простого назначения, если они "
"находятся в области класса или модуля, аннотации оцениваются и сохраняются в "
"специальном атрибуте класса или модуля :attr:`__annotations__`, который "
"представляет собой сопоставление словаря имен переменных (искаженных, если "
"они частные) с оцененными аннотациями. Этот атрибут доступен для записи и "
"автоматически создается в начале выполнения тела класса или модуля, если "
"аннотации находятся статически."

#: ../../reference/simple_stmts.rst:346
msgid ""
"If the assignment target is not simple (an attribute, subscript node, or "
"parenthesized name), the annotation is evaluated if in class or module "
"scope, but not stored."
msgstr ""
"Если цель назначения не является простой (атрибут, узел индекса или имя в "
"скобках), аннотация оценивается, если она находится в области класса или "
"модуля, но не сохраняется."

#: ../../reference/simple_stmts.rst:350
msgid ""
"If a name is annotated in a function scope, then this name is local for that "
"scope. Annotations are never evaluated and stored in function scopes."
msgstr ""
"Если имя аннотировано в области функции, то это имя является локальным для "
"этой области. Аннотации никогда не оцениваются и не сохраняются в областях "
"функций."

#: ../../reference/simple_stmts.rst:353
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If the "
"right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`~object."
"__setitem__` or :meth:`~object.__setattr__` call."
msgstr ""
"Если присутствует правая часть, аннотированное присвоение выполняет "
"фактическое назначение перед оценкой аннотаций (где применимо). Если правая "
"часть для целевого выражения отсутствует, интерпретатор оценивает цель, за "
"исключением последнего вызова :meth:`~object.__setitem__` или :meth:`~object."
"__setattr__`."

#: ../../reference/simple_stmts.rst:361
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Синтаксис аннотаций переменных"

#: ../../reference/simple_stmts.rst:362
msgid ""
"The proposal that added syntax for annotating the types of variables "
"(including class variables and instance variables), instead of expressing "
"them through comments."
msgstr ""
"Предложение, в котором добавлен синтаксис для аннотирования типов переменных "
"(включая переменные класса и переменные экземпляра) вместо выражения их "
"через комментарии."

#: ../../reference/simple_stmts.rst:366
msgid ":pep:`484` - Type hints"
msgstr ":pep:`484` - Подсказки по типу"

#: ../../reference/simple_stmts.rst:367
msgid ""
"The proposal that added the :mod:`typing` module to provide a standard "
"syntax for type annotations that can be used in static analysis tools and "
"IDEs."
msgstr ""
"Предложение, в котором добавлен модуль :mod:`typing` для обеспечения "
"стандартного синтаксиса аннотаций типов, которые можно использовать в "
"инструментах статического анализа и IDE."

#: ../../reference/simple_stmts.rst:371
msgid ""
"Now annotated assignments allow the same expressions in the right hand side "
"as regular assignments. Previously, some expressions (like un-parenthesized "
"tuple expressions) caused a syntax error."
msgstr ""
"Теперь аннотированные присваивания допускают те же выражения в правой части, "
"что и обычные присваивания. Ранее некоторые выражения (например, выражения "
"кортежа без скобок) вызывали синтаксическую ошибку."

#: ../../reference/simple_stmts.rst:380
msgid "The :keyword:`!assert` statement"
msgstr "Оператор :keyword:`!assert`"

#: ../../reference/simple_stmts.rst:387
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""
"Операторы Assert — это удобный способ вставки утверждений отладки в "
"программу:"

#: ../../reference/simple_stmts.rst:393
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "Простая форма ``assert Expression`` эквивалентна ::"

#: ../../reference/simple_stmts.rst:395
msgid ""
"if __debug__:\n"
"    if not expression: raise AssertionError"
msgstr ""
"if __debug__:\n"
"    if not expression: raise AssertionError"

#: ../../reference/simple_stmts.rst:398
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr "Расширенная форма ``assert выражение1, выражение2`` эквивалентна ::"

#: ../../reference/simple_stmts.rst:400
msgid ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"
msgstr ""
"if __debug__:\n"
"    if not expression1: raise AssertionError(expression2)"

#: ../../reference/simple_stmts.rst:407
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable ``__debug__`` is ``True`` under normal "
"circumstances, ``False`` when optimization is requested (command line "
"option :option:`-O`).  The current code generator emits no code for an :"
"keyword:`assert` statement when optimization is requested at compile time.  "
"Note that it is unnecessary to include the source code for the expression "
"that failed in the error message; it will be displayed as part of the stack "
"trace."
msgstr ""
"Эти эквивалентности предполагают, что :const:`__debug__` и :exc:"
"`AssertionError` относятся к встроенным переменным с такими именами. В "
"текущей реализации встроенная переменная ``__debug__`` имеет значение "
"``True`` при нормальных обстоятельствах и ``False``, когда запрашивается "
"оптимизация (опция командной строки :option:`-O`). Текущий генератор кода не "
"генерирует код для оператора :keyword:`assert`, когда оптимизация "
"запрашивается во время компиляции. Обратите внимание, что нет необходимости "
"включать исходный код выражения, которое не удалось найти в сообщении об "
"ошибке; он будет отображаться как часть трассировки стека."

#: ../../reference/simple_stmts.rst:416
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""
"Присвоения :const:`__debug__` незаконны. Значение встроенной переменной "
"определяется при запуске интерпретатора."

#: ../../reference/simple_stmts.rst:423
msgid "The :keyword:`!pass` statement"
msgstr "Оператор :keyword:`!pass`"

#: ../../reference/simple_stmts.rst:433
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` — это пустая операция --- при ее выполнении ничего не "
"происходит. Он полезен в качестве заполнителя, когда оператор требуется "
"синтаксически, но не требуется выполнять код, например::"

#: ../../reference/simple_stmts.rst:437
msgid ""
"def f(arg): pass    # a function that does nothing (yet)\n"
"\n"
"class C: pass       # a class with no methods (yet)"
msgstr ""
"def f(arg): pass    # a function that does nothing (yet)\n"
"\n"
"class C: pass       # a class with no methods (yet)"

#: ../../reference/simple_stmts.rst:445
msgid "The :keyword:`!del` statement"
msgstr "Инструкция :keyword:`!del`"

#: ../../reference/simple_stmts.rst:455
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""
"Удаление определяется рекурсивно, очень похоже на определение присваивания. "
"Вместо того, чтобы подробно описывать это, дадим несколько подсказок."

#: ../../reference/simple_stmts.rst:458
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "Удаление списка целей рекурсивно удаляет каждую цель слева направо."

#: ../../reference/simple_stmts.rst:464
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""
"Удаление имени удаляет привязку этого имени к локальному или глобальному "
"пространству имен, в зависимости от того, встречается ли имя в операторе :"
"keyword:`global` в том же блоке кода. Если имя не привязано, будет выдано "
"исключение :exc:`NameError`."

#: ../../reference/simple_stmts.rst:471
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""
"Удаление ссылок на атрибуты, подписок и срезов передается основному объекту; "
"удаление среза в общем случае эквивалентно присвоению пустого слайса нужного "
"типа (но даже это определяется объектом слайса)."

#: ../../reference/simple_stmts.rst:476
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""
"Раньше было запрещено удалять имя из локального пространства имен, если оно "
"встречается как свободная переменная во вложенном блоке."

#: ../../reference/simple_stmts.rst:484
msgid "The :keyword:`!return` statement"
msgstr "Оператор :keyword:`!return`"

#: ../../reference/simple_stmts.rst:494
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""
":keyword:`return` может встречаться только синтаксически вложенным в "
"определение функции, а не в определение вложенного класса."

#: ../../reference/simple_stmts.rst:497
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""
"Если список выражений присутствует, он оценивается, в противном случае "
"заменяется ``None``."

#: ../../reference/simple_stmts.rst:499
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""
":keyword:`return` оставляет текущий вызов функции со списком выражений (или "
"``None``) в качестве возвращаемого значения."

#: ../../reference/simple_stmts.rst:504
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the function."
msgstr ""
"Когда :keyword:`return` передает управление из оператора :keyword:`try` с "
"предложением :keyword:`finally`, это предложение :keyword:`!finally` "
"выполняется до фактического выхода из функции."

#: ../../reference/simple_stmts.rst:508
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""
"В функции-генераторе оператор :keyword:`return` указывает, что генератор "
"завершен, и вызывает вызов :exc:`StopIteration`. Возвращенное значение (если "
"есть) используется в качестве аргумента для создания :exc:`StopIteration` и "
"становится атрибутом :attr:`StopIteration.value`."

#: ../../reference/simple_stmts.rst:513
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` statement "
"indicates that the asynchronous generator is done and will cause :exc:"
"`StopAsyncIteration` to be raised.  A non-empty :keyword:`!return` statement "
"is a syntax error in an asynchronous generator function."
msgstr ""
"В функции асинхронного генератора пустой оператор :keyword:`return` "
"указывает, что асинхронный генератор завершен, и вызывает вызов :exc:"
"`StopAsyncIteration`. Непустой оператор :keyword:`!return` является "
"синтаксической ошибкой в ​​функции асинхронного генератора."

#: ../../reference/simple_stmts.rst:521
msgid "The :keyword:`!yield` statement"
msgstr "Оператор :keyword:`!yield`"

#: ../../reference/simple_stmts.rst:533
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The ``yield`` statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
"Оператор :keyword:`yield` семантически эквивалентен :ref:`выражению "
"доходности <yieldexpr>`. Оператор ``yield`` может использоваться для того, "
"чтобы опустить круглые скобки, которые в противном случае потребовались бы в "
"эквивалентном операторе выражения доходности. Например, операторы "
"доходности ::"

#: ../../reference/simple_stmts.rst:538
msgid ""
"yield <expr>\n"
"yield from <expr>"
msgstr ""
"yield <expr>\n"
"yield from <expr>"

#: ../../reference/simple_stmts.rst:541
msgid "are equivalent to the yield expression statements ::"
msgstr "эквивалентны операторам выражения доходности::"

#: ../../reference/simple_stmts.rst:543
msgid ""
"(yield <expr>)\n"
"(yield from <expr>)"
msgstr ""
"(yield <expr>)\n"
"(yield from <expr>)"

#: ../../reference/simple_stmts.rst:546
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using :keyword:`yield` in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""
"Выражения и операторы доходности используются только при определении "
"функции :term:`generator` и только в теле функции-генератора. Использование :"
"keyword:`yield` в определении функции достаточно, чтобы это определение "
"создало функцию-генератор вместо обычной функции."

#: ../../reference/simple_stmts.rst:551
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""
"Полную информацию о семантике :keyword:`yield` можно найти в разделе :ref:"
"`yieldexpr`."

#: ../../reference/simple_stmts.rst:557
msgid "The :keyword:`!raise` statement"
msgstr "Оператор :keyword:`!raise`"

#: ../../reference/simple_stmts.rst:568
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the exception that "
"is currently being handled, which is also known as the *active exception*. "
"If there isn't currently an active exception, a :exc:`RuntimeError` "
"exception is raised indicating that this is an error."
msgstr ""
"Если никаких выражений нет, :keyword:`raise` повторно вызывает исключение, "
"которое в данный момент обрабатывается, которое также известно как *активное "
"исключение*. Если в данный момент активного исключения нет, возникает "
"исключение :exc:`RuntimeError`, указывающее, что это ошибка."

#: ../../reference/simple_stmts.rst:573
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""
"В противном случае :keyword:`raise` оценивает первое выражение как объект "
"исключения. Это должен быть либо подкласс, либо экземпляр :class:"
"`BaseException`. Если это класс, экземпляр исключения будет получен при "
"необходимости путем создания экземпляра класса без аргументов."

#: ../../reference/simple_stmts.rst:578
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""
":dfn:`type` исключения — это класс экземпляра исключения, :dfn:`value` — это "
"сам экземпляр."

#: ../../reference/simple_stmts.rst:583
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`~BaseException.__traceback__` "
"attribute. You can create an exception and set your own traceback in one "
"step using the :meth:`~BaseException.with_traceback` exception method (which "
"returns the same exception instance, with its traceback set to its "
"argument), like so::"
msgstr ""
"Объект трассировки обычно создается автоматически при возникновении "
"исключения и прикрепляется к нему как атрибут :attr:`~BaseException."
"__traceback__`. Вы можете создать исключение и установить собственную "
"обратную трассировку за один шаг, используя метод исключения :meth:"
"`~BaseException.with_traceback` (который возвращает тот же экземпляр "
"исключения, с его обратной трассировкой, установленной в его аргумент), "
"например:"

#: ../../reference/simple_stmts.rst:589
msgid "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"
msgstr "raise Exception(\"foo occurred\").with_traceback(tracebackobj)"

#: ../../reference/simple_stmts.rst:595
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance. If the second "
"expression is an exception instance, it will be attached to the raised "
"exception as the :attr:`~BaseException.__cause__` attribute (which is "
"writable). If the expression is an exception class, the class will be "
"instantiated and the resulting exception instance will be attached to the "
"raised exception as the :attr:`!__cause__` attribute. If the raised "
"exception is not handled, both exceptions will be printed:"
msgstr ""
"Предложение from используется для цепочки исключений: если оно задано, "
"второе *выражение* должно быть другим классом или экземпляром исключения. "
"Если второе выражение является экземпляром исключения, оно будет прикреплено "
"к возникшему исключению как атрибут :attr:`~BaseException.__cause__` "
"(который доступен для записи). Если выражение является классом исключения, "
"будет создан экземпляр класса, и полученный экземпляр исключения будет "
"прикреплен к возникшему исключению как атрибут :attr:`!__cause__`. Если "
"возникшее исключение не обработано, будут напечатаны оба исключения:"

#: ../../reference/simple_stmts.rst:604
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except Exception as exc:\n"
"...     raise RuntimeError(\"Something bad happened\") from exc\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"The above exception was the direct cause of the following exception:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\") from exc\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:624
msgid ""
"A similar mechanism works implicitly if a new exception is raised when an "
"exception is already being handled.  An exception may be handled when an :"
"keyword:`except` or :keyword:`finally` clause, or a :keyword:`with` "
"statement, is used.  The previous exception is then attached as the new "
"exception's :attr:`~BaseException.__context__` attribute:"
msgstr ""
"Подобный механизм работает неявно, если новое исключение возникает, когда "
"исключение уже обрабатывается. Исключение может быть обработано при "
"использовании предложения :keyword:`Exception` или :keyword:`finally`, или "
"оператора :keyword:`with`. Предыдущее исключение затем присоединяется как "
"атрибут :attr:`~BaseException.__context__` нового исключения:"

#: ../../reference/simple_stmts.rst:630
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\")\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 2, in <module>\n"
"    print(1 / 0)\n"
"          ~~^~~\n"
"ZeroDivisionError: division by zero\n"
"\n"
"During handling of the above exception, another exception occurred:\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"    raise RuntimeError(\"Something bad happened\")\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:650
msgid ""
"Exception chaining can be explicitly suppressed by specifying :const:`None` "
"in the ``from`` clause:"
msgstr ""
"Цепочку исключений можно явно подавить, указав :const:`None` в предложении "
"``from``:"

#: ../../reference/simple_stmts.rst:653
msgid ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"
msgstr ""
">>> try:\n"
"...     print(1 / 0)\n"
"... except:\n"
"...     raise RuntimeError(\"Something bad happened\") from None\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 4, in <module>\n"
"RuntimeError: Something bad happened"

#: ../../reference/simple_stmts.rst:664
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""
"Дополнительную информацию об исключениях можно найти в разделе :ref:"
"`Exceptions`, а информацию об обработке исключений — в разделе :ref:`try`."

#: ../../reference/simple_stmts.rst:667
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr ":const:`None` теперь разрешено как ``Y`` в ``поднять X из Y``."

#: ../../reference/simple_stmts.rst:670
msgid ""
"Added the :attr:`~BaseException.__suppress_context__` attribute to suppress "
"automatic display of the exception context."
msgstr ""
"Добавлен атрибут :attr:`~BaseException.__suppress_context__` для подавления "
"автоматического отображения контекста исключения."

#: ../../reference/simple_stmts.rst:673
msgid ""
"If the traceback of the active exception is modified in an :keyword:`except` "
"clause, a subsequent ``raise`` statement re-raises the exception with the "
"modified traceback. Previously, the exception was re-raised with the "
"traceback it had when it was caught."
msgstr ""
"Если обратная трассировка активного исключения изменена в предложении :"
"keyword:`Exception`, последующий оператор ``raise`` повторно вызывает "
"исключение с измененной обратной трассировкой. Раньше исключение вызывалось "
"повторно с использованием трассировки, которая была у него при его "
"обнаружении."

#: ../../reference/simple_stmts.rst:682
msgid "The :keyword:`!break` statement"
msgstr "Оператор :keyword:`!break`"

#: ../../reference/simple_stmts.rst:693
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""
":keyword:`break` может встречаться только синтаксически вложенным в цикл :"
"keyword:`for` или :keyword:` while`, но не вложенным в определение функции "
"или класса внутри этого цикла."

#: ../../reference/simple_stmts.rst:700
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:`!"
"else` clause if the loop has one."
msgstr ""
"Он завершает ближайший охватывающий цикл, пропуская необязательное "
"предложение :keyword:`!else`, если оно есть в цикле."

#: ../../reference/simple_stmts.rst:703
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""
"Если цикл :keyword:`for` завершается с помощью :keyword:`break`, цель "
"управления циклом сохраняет свое текущее значение."

#: ../../reference/simple_stmts.rst:708
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`!finally` clause is executed "
"before really leaving the loop."
msgstr ""
"Когда :keyword:`break` передает управление из оператора :keyword:`try` с "
"предложением :keyword:`finally`, это предложение :keyword:`!finally` "
"выполняется до фактического выхода из цикла."

#: ../../reference/simple_stmts.rst:716
msgid "The :keyword:`!continue` statement"
msgstr "Оператор :keyword:`!continue`"

#: ../../reference/simple_stmts.rst:728
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"within that loop.  It continues with the next cycle of the nearest enclosing "
"loop."
msgstr ""
":keyword:`continue` может встречаться только синтаксически вложенным в цикл :"
"keyword:`for` или :keyword:` while`, но не вложенным в определение функции "
"или класса внутри этого цикла. Он продолжается со следующего цикла "
"ближайшего охватывающего цикла."

#: ../../reference/simple_stmts.rst:732
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`!finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
"Когда :keyword:`continue` передает управление оператору :keyword:`try` с "
"предложением :keyword:`finally`, это предложение :keyword:`!finally` "
"выполняется до реального запуска следующего цикла цикла."

#: ../../reference/simple_stmts.rst:741
msgid "The :keyword:`!import` statement"
msgstr "Оператор :keyword:`!import`"

#: ../../reference/simple_stmts.rst:762
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""
"Базовый оператор импорта (без предложения :keyword:`from`) выполняется в два "
"этапа:"

#: ../../reference/simple_stmts.rst:765
msgid "find a module, loading and initializing it if necessary"
msgstr "найти модуль, загрузив и инициализировав его при необходимости"

#: ../../reference/simple_stmts.rst:766
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""
"определите имя или имена в локальном пространстве имен для области, в "
"которой используется оператор :keyword:`import`."

#: ../../reference/simple_stmts.rst:769
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individual import statements."
msgstr ""
"Если оператор содержит несколько предложений (разделенных запятыми), два "
"шага выполняются отдельно для каждого предложения, как если бы предложения "
"были разделены на отдельные операторы импорта."

#: ../../reference/simple_stmts.rst:774
msgid ""
"The details of the first step, finding and loading modules, are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""
"Подробности первого шага, поиска и загрузки модулей, более подробно описаны "
"в разделе :ref:`import system <importsystem>`, где также описаны различные "
"типы пакетов и модулей, которые можно импортировать. как и все хуки, которые "
"можно использовать для настройки системы импорта. Обратите внимание, что "
"сбои на этом этапе могут указывать либо на то, что модуль не удалось найти, "
"либо на то, что произошла ошибка при инициализации модуля, которая включает "
"выполнение кода модуля."

#: ../../reference/simple_stmts.rst:782
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""
"Если запрошенный модуль успешно получен, он будет доступен в локальном "
"пространстве имен одним из трех способов:"

#: ../../reference/simple_stmts.rst:787
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Если за именем модуля следует :keyword:`!as`, то имя, следующее за :keyword:"
"`!as`, привязывается непосредственно к импортированному модулю."

#: ../../reference/simple_stmts.rst:789
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""
"Если другое имя не указано и импортируемый модуль является модулем верхнего "
"уровня, имя модуля привязывается к локальному пространству имен как ссылка "
"на импортируемый модуль."

#: ../../reference/simple_stmts.rst:792
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""
"Если импортируемый модуль *не* является модулем верхнего уровня, то имя "
"пакета верхнего уровня, содержащего модуль, привязывается к локальному "
"пространству имен как ссылка на пакет верхнего уровня. Доступ к "
"импортированному модулю должен осуществляться по его полному имени, а не "
"напрямую."

#: ../../reference/simple_stmts.rst:802
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr "Форма :keyword:`from` использует немного более сложный процесс:"

#: ../../reference/simple_stmts.rst:804
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""
"найти модуль, указанный в предложении :keyword:`from`, загрузив и "
"инициализировав его при необходимости;"

#: ../../reference/simple_stmts.rst:806
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""
"для каждого из идентификаторов, указанных в предложениях :keyword:`import`:"

#: ../../reference/simple_stmts.rst:808
msgid "check if the imported module has an attribute by that name"
msgstr "проверьте, имеет ли импортированный модуль атрибут с таким именем"

#: ../../reference/simple_stmts.rst:809
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""
"если нет, попытайтесь импортировать подмодуль с этим именем, а затем снова "
"проверьте импортированный модуль на наличие этого атрибута."

#: ../../reference/simple_stmts.rst:811
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "если атрибут не найден, возникает :exc:`ImportError`."

#: ../../reference/simple_stmts.rst:812
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`!as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""
"в противном случае ссылка на это значение сохраняется в локальном "
"пространстве имен с использованием имени в предложении :keyword:`!as`, если "
"оно присутствует, в противном случае используется имя атрибута."

#: ../../reference/simple_stmts.rst:816
msgid "Examples::"
msgstr "Примеры::"

#: ../../reference/simple_stmts.rst:818
msgid ""
"import foo                 # foo imported and bound locally\n"
"import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo "
"bound locally\n"
"import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as fbb\n"
"from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as baz\n"
"from foo import attr       # foo imported and foo.attr bound as attr"
msgstr ""
"import foo                 # foo imported and bound locally\n"
"import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo "
"bound locally\n"
"import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as fbb\n"
"from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar."
"baz bound as baz\n"
"from foo import attr       # foo imported and foo.attr bound as attr"

#: ../../reference/simple_stmts.rst:826
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""
"Если список идентификаторов заменяется звездочкой (``'*'``), все "
"общедоступные имена, определенные в модуле, привязываются к локальному "
"пространству имен для области, в которой встречается оператор :keyword:"
"`import`."

#: ../../reference/simple_stmts.rst:832
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""
"*Общественные имена*, определенные модулем, определяются путем проверки "
"пространства имен модуля на наличие переменной с именем ``__all__``; если "
"определено, это должна быть последовательность строк, которые являются "
"именами, определенными или импортированными этим модулем. Имена, указанные в "
"``__all__``, считаются общедоступными и должны существовать. Если "
"``__all__`` не определен, набор общедоступных имен включает все имена, "
"найденные в пространстве имен модуля, которые не начинаются с символа "
"подчеркивания (``'_'``). ``__all__`` должен содержать весь общедоступный "
"API. Он предназначен для предотвращения случайного экспорта элементов, "
"которые не являются частью API (например, библиотечных модулей, которые были "
"импортированы и использованы внутри модуля)."

#: ../../reference/simple_stmts.rst:842
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"Форма импорта с подстановочными знаками --- ``from Module import *`` --- "
"разрешена только на уровне модуля. Попытка использовать его в определениях "
"классов или функций вызовет ошибку :exc:`SyntaxError`."

#: ../../reference/simple_stmts.rst:849
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained in "
"the :ref:`relativeimports` section."
msgstr ""
"При указании модуля для импорта не обязательно указывать абсолютное имя "
"модуля. Когда модуль или пакет содержится в другом пакете, можно выполнить "
"относительный импорт в том же верхнем пакете без упоминания имени пакета. "
"Используя ведущие точки в указанном модуле или пакете после :keyword:`from`, "
"вы можете указать, насколько высоко нужно пройти по текущей иерархии "
"пакетов, не указывая точных имен. Одна точка в начале означает текущий "
"пакет, в котором существует модуль, выполняющий импорт. Две точки означают "
"повышение на один уровень упаковки. Три точки — это два уровня вверх и т. д. "
"Итак, если вы выполните ``from . import mod`` из модуля в пакете ``pkg``, "
"тогда вы в конечном итоге импортируете ``pkg.mod``. Если вы выполните "
"``from ..subpkg2 import mod`` из ``pkg.subpkg1``, вы импортируете ``pkg."
"subpkg2.mod``. Спецификация относительного импорта содержится в разделе :ref:"
"`relativeimports`."

#: ../../reference/simple_stmts.rst:863
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""
":func:`importlib.import_module` предназначен для поддержки приложений, "
"которые динамически определяют загружаемые модули."

#: ../../reference/simple_stmts.rst:866
msgid ""
"Raises an :ref:`auditing event <auditing>` ``import`` with arguments "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys."
"path_hooks``."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>` ``import`` с аргументами "
"``module``, ``filename``, ``sys.path``, ``sys.meta_path``, ``sys ."
"path_hooks``."

#: ../../reference/simple_stmts.rst:871
msgid "Future statements"
msgstr "Future statements"

#: ../../reference/simple_stmts.rst:877
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""
"Оператор :dfn:`future` — это директива компилятору о том, что конкретный "
"модуль должен быть скомпилирован с использованием синтаксиса или семантики, "
"которые будут доступны в указанной будущей версии Python, где эта функция "
"станет стандартной."

#: ../../reference/simple_stmts.rst:881
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""
"Заявление о будущем предназначено для облегчения перехода на будущие версии "
"Python, которые вносят в язык несовместимые изменения. Это позволяет "
"использовать новые функции для каждого модуля до выпуска, в котором эта "
"функция станет стандартной."

#: ../../reference/simple_stmts.rst:893
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""
"Оператор будущего должен появиться в верхней части модуля. Единственные "
"строки, которые могут появляться перед оператором Future:"

#: ../../reference/simple_stmts.rst:896
msgid "the module docstring (if any),"
msgstr "the module docstring (if any),"

#: ../../reference/simple_stmts.rst:897
msgid "comments,"
msgstr "Комментарии,"

#: ../../reference/simple_stmts.rst:898
msgid "blank lines, and"
msgstr "пустые строки и"

#: ../../reference/simple_stmts.rst:899
msgid "other future statements."
msgstr "другие future statements."

#: ../../reference/simple_stmts.rst:901
msgid ""
"The only feature that requires using the future statement is ``annotations`` "
"(see :pep:`563`)."
msgstr ""
"Единственная возможность, требующая использования оператора Future, — это "
"``аннотации`` (см. :pep:`563`)."

#: ../../reference/simple_stmts.rst:904
msgid ""
"All historical features enabled by the future statement are still recognized "
"by Python 3.  The list includes ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, "
"``print_function``, ``nested_scopes`` and ``with_statement``.  They are all "
"redundant because they are always enabled, and only kept for backwards "
"compatibility."
msgstr ""
"Все исторические функции, включенные оператором Future, по-прежнему "
"распознаются Python 3. В список входят ``absolute_import``, ``division``, "
"``generators``, ``generator_stop``, ``unicode_literals``, `` "
"print_function``, ``nested_scopes`` и ``with_statement``. Все они избыточны, "
"поскольку всегда включены и сохраняются только для обратной совместимости."

#: ../../reference/simple_stmts.rst:911
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""
"Оператор Future распознается и обрабатывается особым образом во время "
"компиляции: изменения в семантике основных конструкций часто реализуются "
"путем создания другого кода. Может даже случиться так, что новая функция "
"вводит новый несовместимый синтаксис (например, новое зарезервированное "
"слово), и в этом случае компилятору может потребоваться по-другому "
"проанализировать модуль. Такие решения нельзя откладывать до времени "
"выполнения."

#: ../../reference/simple_stmts.rst:918
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""
"Для любого данного выпуска компилятор знает, какие имена функций были "
"определены, и выдает ошибку во время компиляции, если оператор Future "
"содержит неизвестную ему функцию."

#: ../../reference/simple_stmts.rst:922
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""
"Семантика прямого выполнения такая же, как и для любого оператора импорта: "
"существует стандартный модуль :mod:`__future__`, описанный позже, и он будет "
"импортирован обычным способом во время выполнения оператора Future."

#: ../../reference/simple_stmts.rst:926
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""
"Интересная семантика времени выполнения зависит от конкретной функции, "
"включенной в операторе Future."

#: ../../reference/simple_stmts.rst:929
msgid "Note that there is nothing special about the statement::"
msgstr "Обратите внимание, что в операторе нет ничего особенного::"

#: ../../reference/simple_stmts.rst:931
msgid "import __future__ [as name]"
msgstr "import __future__ [as name]"

#: ../../reference/simple_stmts.rst:933
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""
"Это не будущее заявление; это обычный оператор импорта без каких-либо особых "
"семантических или синтаксических ограничений."

#: ../../reference/simple_stmts.rst:936
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`!M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""
"Код, скомпилированный вызовами встроенных функций :func:`exec` и :func:"
"`compile`, которые встречаются в модуле :mod:`!M`, содержащем оператор "
"будущего, по умолчанию будет использовать новый синтаксис или семантику. "
"связанное с будущим заявлением. Этим можно управлять с помощью "
"необязательных аргументов :func:`compile` --- подробности смотрите в "
"документации этой функции."

#: ../../reference/simple_stmts.rst:942
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"Будущее утверждение, введенное в командной строке интерактивного "
"переводчика, вступит в силу до конца сеанса переводчика. Если интерпретатор "
"запускается с опцией :option:`-i`, ему передается имя сценария для "
"выполнения и сценарий включает оператор будущего, он будет действовать в "
"интерактивном сеансе, начатом после выполнения сценария."

#: ../../reference/simple_stmts.rst:950
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - Назад в __будущее__"

#: ../../reference/simple_stmts.rst:951
msgid "The original proposal for the __future__ mechanism."
msgstr "Исходное предложение механизма __future__."

#: ../../reference/simple_stmts.rst:957
msgid "The :keyword:`!global` statement"
msgstr "Оператор :keyword:`!global`"

#: ../../reference/simple_stmts.rst:967
msgid ""
"The :keyword:`global` statement causes the listed identifiers to be "
"interpreted as globals. It would be impossible to assign to a global "
"variable without :keyword:`!global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
"Оператор :keyword:`global` заставляет перечисленные идентификаторы "
"интерпретироваться как глобальные. Было бы невозможно назначить глобальную "
"переменную без :keyword:`!global`, хотя свободные переменные могут ссылаться "
"на глобальные переменные, не будучи объявленными глобальными."

#: ../../reference/simple_stmts.rst:972
msgid ""
"The :keyword:`global` statement applies to the entire scope of a function or "
"class body. A :exc:`SyntaxError` is raised if a variable is used or assigned "
"to prior to its global declaration in the scope."
msgstr ""
"Оператор :keyword:`global` применяется ко всей области действия функции или "
"тела класса. Ошибка :exc:`SyntaxError` возникает, если переменная "
"используется или ей присваивается до ее глобального объявления в области "
"видимости."

#: ../../reference/simple_stmts.rst:981
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  It "
"applies only to code parsed at the same time as the :keyword:`!global` "
"statement. In particular, a :keyword:`!global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`!global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""
"**Примечание программиста:** :keyword:`global` — это директива "
"синтаксического анализатора. Это применимо только к коду, анализируемому "
"одновременно с оператором :keyword:`!global`. В частности, оператор :keyword:"
"`!global`, содержащийся в строке или объекте кода, передаваемом во "
"встроенную функцию :func:`exec`, не влияет на блок кода, *содержащий* вызов "
"функции, и код, содержащийся в таком на строку не влияют операторы :keyword:"
"`!global` в коде, содержащем вызов функции. То же самое относится и к "
"функциям :func:`eval` и :func:`compile`."

#: ../../reference/simple_stmts.rst:993
msgid "The :keyword:`!nonlocal` statement"
msgstr "Оператор :keyword:`!nonlocal`"

#: ../../reference/simple_stmts.rst:1001
msgid ""
"When the definition of a function or class is nested (enclosed) within the "
"definitions of other functions, its nonlocal scopes are the local scopes of "
"the enclosing functions. The :keyword:`nonlocal` statement causes the listed "
"identifiers to refer to names previously bound in nonlocal scopes. It allows "
"encapsulated code to rebind such nonlocal identifiers.  If a name is bound "
"in more than one nonlocal scope, the nearest binding is used. If a name is "
"not bound in any nonlocal scope, or if there is no nonlocal scope, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Когда определение функции или класса вложено (заключено) в определения "
"других функций, его нелокальные области видимости являются локальными "
"областями охватывающих функций. Оператор :keyword:`nonlocal` заставляет "
"перечисленные идентификаторы ссылаться на имена, ранее связанные в "
"нелокальных областях. Это позволяет инкапсулированному коду повторно "
"привязывать такие нелокальные идентификаторы. Если имя привязано к более чем "
"одной нелокальной области, используется ближайшая привязка. Если имя не "
"привязано ни к какой нелокальной области или если нелокальная область "
"отсутствует, выдается ошибка :exc:`SyntaxError`."

#: ../../reference/simple_stmts.rst:1010
msgid ""
"The :keyword:`nonlocal` statement applies to the entire scope of a function "
"or class body. A :exc:`SyntaxError` is raised if a variable is used or "
"assigned to prior to its nonlocal declaration in the scope."
msgstr ""
"Оператор :keyword:`nonlocal` применяется ко всей области действия функции "
"или тела класса. Ошибка :exc:`SyntaxError` возникает, если переменная "
"используется или ей присваивается до ее нелокального объявления в области "
"видимости."

#: ../../reference/simple_stmts.rst:1016
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - Доступ к именам во внешних областях"

#: ../../reference/simple_stmts.rst:1017
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr "Спецификация оператора :keyword:`nonlocal`."

#: ../../reference/simple_stmts.rst:1019
msgid ""
"**Programmer's note:** :keyword:`nonlocal` is a directive to the parser and "
"applies only to code parsed along with it.  See the note for the :keyword:"
"`global` statement."
msgstr ""
"**Примечание программиста:** :keyword:`nonlocal` — это директива "
"синтаксического анализатора, которая применяется только к коду, "
"анализируемому вместе с ним. См. примечание к оператору :keyword:`global`."

#: ../../reference/simple_stmts.rst:1027
msgid "The :keyword:`!type` statement"
msgstr "Оператор :keyword:`!type`"

#: ../../reference/simple_stmts.rst:1034
msgid ""
"The :keyword:`!type` statement declares a type alias, which is an instance "
"of :class:`typing.TypeAliasType`."
msgstr ""
"Оператор :keyword:`!type` объявляет псевдоним типа, который является "
"экземпляром :class:`typing.TypeAliasType`."

#: ../../reference/simple_stmts.rst:1037
msgid "For example, the following statement creates a type alias::"
msgstr "Например, следующий оператор создает псевдоним типа:"

#: ../../reference/simple_stmts.rst:1039
msgid "type Point = tuple[float, float]"
msgstr "type Point = tuple[float, float]"

#: ../../reference/simple_stmts.rst:1041
msgid "This code is roughly equivalent to::"
msgstr "Этот код примерно эквивалентен::"

#: ../../reference/simple_stmts.rst:1043
msgid ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"
msgstr ""
"annotation-def VALUE_OF_Point():\n"
"    return tuple[float, float]\n"
"Point = typing.TypeAliasType(\"Point\", VALUE_OF_Point())"

#: ../../reference/simple_stmts.rst:1047
msgid ""
"``annotation-def`` indicates an :ref:`annotation scope <annotation-scopes>`, "
"which behaves mostly like a function, but with several small differences."
msgstr ""
"``annotation-def`` указывает :ref:`область аннотации <annotation-scopes>`, "
"которая ведет себя в основном как функция, но с некоторыми небольшими "
"отличиями."

#: ../../reference/simple_stmts.rst:1050
msgid ""
"The value of the type alias is evaluated in the annotation scope. It is not "
"evaluated when the type alias is created, but only when the value is "
"accessed through the type alias's :attr:`!__value__` attribute (see :ref:"
"`lazy-evaluation`). This allows the type alias to refer to names that are "
"not yet defined."
msgstr ""
"Значение псевдонима типа оценивается в области аннотации. Оно не оценивается "
"при создании псевдонима типа, а только тогда, когда доступ к значению "
"осуществляется через атрибут :attr:`!__value__` псевдонима типа (см. :ref:"
"`lazy-evaluation`). Это позволяет псевдониму типа ссылаться на имена, "
"которые еще не определены."

#: ../../reference/simple_stmts.rst:1056
msgid ""
"Type aliases may be made generic by adding a :ref:`type parameter list <type-"
"params>` after the name. See :ref:`generic-type-aliases` for more."
msgstr ""
"Псевдонимы типов можно сделать универсальными, добавив список параметров "
"типа <type-params> после имени. Дополнительную информацию см. в разделе :ref:"
"`generic-type-aliases`."

#: ../../reference/simple_stmts.rst:1059
msgid ":keyword:`!type` is a :ref:`soft keyword <soft-keywords>`."
msgstr ":keyword:`!type` — это :ref:`мягкое ключевое слово <soft-keywords>`."

#: ../../reference/simple_stmts.rst:1065
msgid ":pep:`695` - Type Parameter Syntax"
msgstr ":pep:`695` - Синтаксис типа параметра"

#: ../../reference/simple_stmts.rst:1066
msgid ""
"Introduced the :keyword:`!type` statement and syntax for generic classes and "
"functions."
msgstr ""
"Представлен оператор :keyword:`!type` и синтаксис для универсальных классов "
"и функций."

#: ../../reference/simple_stmts.rst:8
msgid "simple"
msgstr "простой"

#: ../../reference/simple_stmts.rst:8 ../../reference/simple_stmts.rst:39
#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:263
#: ../../reference/simple_stmts.rst:322 ../../reference/simple_stmts.rst:382
#: ../../reference/simple_stmts.rst:425 ../../reference/simple_stmts.rst:447
#: ../../reference/simple_stmts.rst:460 ../../reference/simple_stmts.rst:486
#: ../../reference/simple_stmts.rst:523 ../../reference/simple_stmts.rst:559
#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:873
#: ../../reference/simple_stmts.rst:959 ../../reference/simple_stmts.rst:995
#: ../../reference/simple_stmts.rst:1029
msgid "statement"
msgstr "инструкция"

#: ../../reference/simple_stmts.rst:39 ../../reference/simple_stmts.rst:42
msgid "expression"
msgstr "выражение"

#: ../../reference/simple_stmts.rst:39 ../../reference/simple_stmts.rst:42
#: ../../reference/simple_stmts.rst:105 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:196 ../../reference/simple_stmts.rst:447
msgid "list"
msgstr "список"

#: ../../reference/simple_stmts.rst:56 ../../reference/simple_stmts.rst:976
msgid "built-in function"
msgstr "встроенная функция"

#: ../../reference/simple_stmts.rst:56
msgid "repr"
msgstr "repr"

#: ../../reference/simple_stmts.rst:56 ../../reference/simple_stmts.rst:75
#: ../../reference/simple_stmts.rst:187 ../../reference/simple_stmts.rst:196
#: ../../reference/simple_stmts.rst:207 ../../reference/simple_stmts.rst:581
msgid "object"
msgstr "объект"

#: ../../reference/simple_stmts.rst:56
msgid "None"
msgstr "None"

#: ../../reference/simple_stmts.rst:56
msgid "string"
msgstr "строка"

#: ../../reference/simple_stmts.rst:56
msgid "conversion"
msgstr "conversion"

#: ../../reference/simple_stmts.rst:56
msgid "output"
msgstr "вывод"

#: ../../reference/simple_stmts.rst:56
msgid "standard"
msgstr "стандартный"

#: ../../reference/simple_stmts.rst:56
msgid "writing"
msgstr "написание"

#: ../../reference/simple_stmts.rst:56
msgid "values"
msgstr "значения"

#: ../../reference/simple_stmts.rst:56
msgid "procedure"
msgstr "процедура"

#: ../../reference/simple_stmts.rst:56
msgid "call"
msgstr "call"

#: ../../reference/simple_stmts.rst:75
msgid "= (equals)"
msgstr "= (равно)"

#: ../../reference/simple_stmts.rst:75
msgid "assignment statement"
msgstr "оператор присваивания"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:159 ../../reference/simple_stmts.rst:187
#: ../../reference/simple_stmts.rst:220 ../../reference/simple_stmts.rst:263
#: ../../reference/simple_stmts.rst:322
msgid "assignment"
msgstr "присваивание"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:743
#: ../../reference/simple_stmts.rst:798 ../../reference/simple_stmts.rst:959
msgid "binding"
msgstr "binding"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:460
#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:798
#: ../../reference/simple_stmts.rst:959
msgid "name"
msgstr "имя"

#: ../../reference/simple_stmts.rst:75
msgid "rebinding"
msgstr "повторное связывание"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:187
msgid "mutable"
msgstr "изменяемый"

#: ../../reference/simple_stmts.rst:75 ../../reference/simple_stmts.rst:159
#: ../../reference/simple_stmts.rst:469
msgid "attribute"
msgstr "атрибут"

#: ../../reference/simple_stmts.rst:105 ../../reference/simple_stmts.rst:116
#: ../../reference/simple_stmts.rst:447 ../../reference/simple_stmts.rst:697
msgid "target"
msgstr "target"

#: ../../reference/simple_stmts.rst:116 ../../reference/simple_stmts.rst:382
#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:959
#: ../../reference/simple_stmts.rst:995
msgid ", (comma)"
msgstr ", (запятая)"

#: ../../reference/simple_stmts.rst:116
msgid "in target list"
msgstr "в списке целей"

#: ../../reference/simple_stmts.rst:116 ../../reference/simple_stmts.rst:824
msgid "* (asterisk)"
msgstr "* (звёздочка)"

#: ../../reference/simple_stmts.rst:116
msgid "in assignment target list"
msgstr "в целевом списке назначения"

#: ../../reference/simple_stmts.rst:116
msgid "[] (square brackets)"
msgstr "[] (квадратные скобки)"

#: ../../reference/simple_stmts.rst:116
msgid "() (parentheses)"
msgstr "() (parentheses)"

#: ../../reference/simple_stmts.rst:153
msgid "destructor"
msgstr "деструктор"

#: ../../reference/simple_stmts.rst:187
msgid "subscription"
msgstr "подписка"

#: ../../reference/simple_stmts.rst:196
msgid "sequence"
msgstr "последовательность"

#: ../../reference/simple_stmts.rst:207
msgid "mapping"
msgstr "сопоставление"

#: ../../reference/simple_stmts.rst:207
msgid "dictionary"
msgstr "словарь"

#: ../../reference/simple_stmts.rst:220
msgid "slicing"
msgstr "нарезка"

#: ../../reference/simple_stmts.rst:263
msgid "augmented"
msgstr "дополненный"

#: ../../reference/simple_stmts.rst:263
msgid "assignment, augmented"
msgstr "задание, дополненное"

#: ../../reference/simple_stmts.rst:263
msgid "+="
msgstr "+="

#: ../../reference/simple_stmts.rst:263
msgid "augmented assignment"
msgstr "расширенное задание"

#: ../../reference/simple_stmts.rst:263
msgid "-="
msgstr "-="

#: ../../reference/simple_stmts.rst:263
msgid "*="
msgstr "*="

#: ../../reference/simple_stmts.rst:263
msgid "/="
msgstr "/="

#: ../../reference/simple_stmts.rst:263
msgid "%="
msgstr "%="

#: ../../reference/simple_stmts.rst:263
msgid "&="
msgstr "&="

#: ../../reference/simple_stmts.rst:263
msgid "^="
msgstr "^="

#: ../../reference/simple_stmts.rst:263
msgid "|="
msgstr "|="

#: ../../reference/simple_stmts.rst:263
msgid "**="
msgstr "**="

#: ../../reference/simple_stmts.rst:263
msgid "//="
msgstr "//="

#: ../../reference/simple_stmts.rst:263
msgid ">>="
msgstr ">>="

#: ../../reference/simple_stmts.rst:263
msgid "<<="
msgstr "<<="

#: ../../reference/simple_stmts.rst:322
msgid "annotated"
msgstr "аннотированный"

#: ../../reference/simple_stmts.rst:322
msgid "assignment, annotated"
msgstr "задание с аннотацией"

#: ../../reference/simple_stmts.rst:322
msgid ": (colon)"
msgstr ": (двоеточие)"

#: ../../reference/simple_stmts.rst:322
msgid "annotated variable"
msgstr "аннотированная переменная"

#: ../../reference/simple_stmts.rst:382
msgid "assert"
msgstr "утверждать"

#: ../../reference/simple_stmts.rst:382
msgid "debugging"
msgstr "отладка"

#: ../../reference/simple_stmts.rst:382
msgid "assertions"
msgstr "утверждения"

#: ../../reference/simple_stmts.rst:382
msgid "expression list"
msgstr "expression list"

#: ../../reference/simple_stmts.rst:403
msgid "__debug__"
msgstr "__debug__"

#: ../../reference/simple_stmts.rst:403 ../../reference/simple_stmts.rst:523
#: ../../reference/simple_stmts.rst:559 ../../reference/simple_stmts.rst:591
#: ../../reference/simple_stmts.rst:743
msgid "exception"
msgstr "exception"

#: ../../reference/simple_stmts.rst:403
msgid "AssertionError"
msgstr "AssertionError"

#: ../../reference/simple_stmts.rst:425
msgid "pass"
msgstr "pass"

#: ../../reference/simple_stmts.rst:425
msgid "null"
msgstr "null"

#: ../../reference/simple_stmts.rst:425
msgid "operation"
msgstr "операция"

#: ../../reference/simple_stmts.rst:447
msgid "del"
msgstr "del"

#: ../../reference/simple_stmts.rst:447 ../../reference/simple_stmts.rst:469
msgid "deletion"
msgstr "удаление"

#: ../../reference/simple_stmts.rst:460 ../../reference/simple_stmts.rst:959
msgid "global"
msgstr "global"

#: ../../reference/simple_stmts.rst:460
msgid "unbinding"
msgstr "развязывание"

#: ../../reference/simple_stmts.rst:486
msgid "return"
msgstr "return"

#: ../../reference/simple_stmts.rst:486 ../../reference/simple_stmts.rst:523
msgid "function"
msgstr "функция"

#: ../../reference/simple_stmts.rst:486
msgid "definition"
msgstr "definition"

#: ../../reference/simple_stmts.rst:486
msgid "class"
msgstr "класс"

#: ../../reference/simple_stmts.rst:502 ../../reference/simple_stmts.rst:697
#: ../../reference/simple_stmts.rst:706 ../../reference/simple_stmts.rst:718
#: ../../reference/simple_stmts.rst:743
msgid "keyword"
msgstr "keyword"

#: ../../reference/simple_stmts.rst:502 ../../reference/simple_stmts.rst:706
#: ../../reference/simple_stmts.rst:718
msgid "finally"
msgstr "finally"

#: ../../reference/simple_stmts.rst:523
msgid "yield"
msgstr "yield"

#: ../../reference/simple_stmts.rst:523
msgid "generator"
msgstr "генератор"

#: ../../reference/simple_stmts.rst:523
msgid "iterator"
msgstr "итератор"

#: ../../reference/simple_stmts.rst:523
msgid "StopIteration"
msgstr "ОстановитьИтерацию"

#: ../../reference/simple_stmts.rst:559
msgid "raise"
msgstr "поднимает исключение "

#: ../../reference/simple_stmts.rst:559
msgid "raising"
msgstr "поднимает исключение"

#: ../../reference/simple_stmts.rst:559
msgid "__traceback__ (exception attribute)"
msgstr "__traceback__ (exception attribute)"

#: ../../reference/simple_stmts.rst:581
msgid "traceback"
msgstr "трассировка"

#: ../../reference/simple_stmts.rst:591
msgid "chaining"
msgstr "цепочка"

#: ../../reference/simple_stmts.rst:591
msgid "__cause__ (exception attribute)"
msgstr "__cause__ (exception attribute)"

#: ../../reference/simple_stmts.rst:591
msgid "__context__ (exception attribute)"
msgstr "__context__ (exception attribute)"

#: ../../reference/simple_stmts.rst:684
msgid "break"
msgstr "break"

#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
msgid "for"
msgstr "for"

#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
msgid "while"
msgstr "while"

#: ../../reference/simple_stmts.rst:684 ../../reference/simple_stmts.rst:718
msgid "loop"
msgstr "цикл"

#: ../../reference/simple_stmts.rst:697
msgid "else"
msgstr "else"

#: ../../reference/simple_stmts.rst:697
msgid "loop control"
msgstr "контур управления"

#: ../../reference/simple_stmts.rst:718
msgid "continue"
msgstr "continue"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:846
msgid "import"
msgstr "импорт"

#: ../../reference/simple_stmts.rst:743
msgid "module"
msgstr "модуль"

#: ../../reference/simple_stmts.rst:743
msgid "importing"
msgstr "импортирование"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:798
msgid "from"
msgstr "от"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:785
msgid "as"
msgstr "as"

#: ../../reference/simple_stmts.rst:743
msgid "ImportError"
msgstr "ImportError"

#: ../../reference/simple_stmts.rst:743 ../../reference/simple_stmts.rst:785
#: ../../reference/simple_stmts.rst:798 ../../reference/simple_stmts.rst:824
msgid "import statement"
msgstr "import statement"

#: ../../reference/simple_stmts.rst:830
msgid "__all__ (optional module attribute)"
msgstr "__all__ (optional module attribute)"

#: ../../reference/simple_stmts.rst:846
msgid "relative"
msgstr "относительно"

#: ../../reference/simple_stmts.rst:873
msgid "future"
msgstr "future"

#: ../../reference/simple_stmts.rst:873
msgid "__future__"
msgstr "__future__"

#: ../../reference/simple_stmts.rst:873
msgid "future statement"
msgstr "future statement"

#: ../../reference/simple_stmts.rst:959 ../../reference/simple_stmts.rst:995
msgid "identifier list"
msgstr "список идентификаторов"

#: ../../reference/simple_stmts.rst:976
msgid "exec"
msgstr "exec"

#: ../../reference/simple_stmts.rst:976
msgid "eval"
msgstr "eval"

#: ../../reference/simple_stmts.rst:976
msgid "compile"
msgstr "скомпилировать"

#: ../../reference/simple_stmts.rst:995
msgid "nonlocal"
msgstr "нелокальный"

#: ../../reference/simple_stmts.rst:1029
msgid "type"
msgstr "тип"
