# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-24 14:52+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Составные инструкции"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Составные операторы содержат (группы) других операторов; они каким-то "
"образом влияют или контролируют выполнение этих других операторов. Обычно "
"составные операторы занимают несколько строк, хотя в простых вариантах весь "
"составной оператор может содержаться в одной строке."

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Операторы :keyword:`if`, :keyword:` while` и :keyword:`for` реализуют "
"традиционные конструкции потока управления. :keyword:`try` определяет "
"обработчики исключений и/или код очистки для группы операторов, а оператор :"
"keyword:`with` позволяет выполнять код инициализации и финализации вокруг "
"блока кода. Определения функций и классов также являются синтаксически "
"составными операторами."

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Составное утверждение состоит из одного или нескольких предложений. "
"Предложение состоит из заголовка и «набора». Все заголовки предложений "
"конкретного составного оператора имеют один и тот же уровень отступов. "
"Каждый заголовок предложения начинается с уникального ключевого слова и "
"заканчивается двоеточием. Набор — это группа операторов, контролируемая "
"предложением. Набор может представлять собой один или несколько простых "
"операторов, разделенных точкой с запятой, в той же строке, что и заголовок, "
"следующий за двоеточием заголовка, или это может быть один или несколько "
"операторов с отступом в последующих строках. Только последняя форма набора "
"может содержать вложенные составные операторы; следующее является "
"незаконным, главным образом потому, что не будет ясно, к какому предложению :"
"keyword:`if` будет принадлежать следующее предложение :keyword:`else`::"

#: ../../reference/compound_stmts.rst:37
msgid "if test1: if test2: print(x)"
msgstr "if test1: if test2: print(x)"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Также обратите внимание, что в этом контексте точка с запятой связывается "
"сильнее, чем двоеточие, поэтому в следующем примере выполняются либо все "
"вызовы :func:`print`, либо ни один из них::"

#: ../../reference/compound_stmts.rst:43
msgid "if x < y < z: print(x); print(y); print(z)"
msgstr "if x < y < z: print(x); print(y); print(z)"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "Подведение итогов:"

#: ../../reference/compound_stmts.rst:69
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Обратите внимание, что операторы всегда заканчиваются на «NEWLINE», за "
"которым, возможно, следует «DEDENT». Также обратите внимание, что "
"необязательные предложения продолжения всегда начинаются с ключевого слова, "
"которое не может начинать оператор, поэтому нет никакой двусмысленности "
"(проблема «висячего :keyword:`else`' решается в Python, требуя, чтобы "
"вложенные операторы :keyword:`if` были с отступом)."

#: ../../reference/compound_stmts.rst:75
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"При форматировании грамматических правил в следующих разделах каждое "
"предложение для ясности помещается на отдельной строке."

#: ../../reference/compound_stmts.rst:84
msgid "The :keyword:`!if` statement"
msgstr "Оператор :keyword:`!if`"

#: ../../reference/compound_stmts.rst:92
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "Оператор :keyword:`if` используется для условного выполнения:"

#: ../../reference/compound_stmts.rst:99
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Он выбирает ровно один из наборов, оценивая выражения одно за другим, пока "
"одно из них не окажется истинным (определение истинного и ложного см. в "
"разделе :ref:`booleans`); затем этот набор выполняется (и никакая другая "
"часть оператора :keyword:`if` не выполняется и не оценивается). Если все "
"выражения ложны, выполняется набор предложения :keyword:`else`, если оно "
"присутствует."

#: ../../reference/compound_stmts.rst:109
msgid "The :keyword:`!while` statement"
msgstr "Оператор :keyword:`!while`"

#: ../../reference/compound_stmts.rst:117
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"Оператор :keyword:` while` используется для повторного выполнения, пока "
"выражение истинно:"

#: ../../reference/compound_stmts.rst:124
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"При этом выражение неоднократно проверяется и, если оно истинно, выполняется "
"первый набор; если выражение ложно (что может быть в первый раз), то "
"выполняется набор предложений :keyword:`!else`, если он присутствует, и цикл "
"завершается."

#: ../../reference/compound_stmts.rst:133
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"Оператор :keyword:`break`, выполняемый в первом наборе, завершает цикл без "
"выполнения набора предложений :keyword:`!else`. Оператор :keyword:"
"`continue`, выполняемый в первом наборе, пропускает остальную часть набора и "
"возвращается к проверке выражения."

#: ../../reference/compound_stmts.rst:142
msgid "The :keyword:`!for` statement"
msgstr "Оператор :keyword:`!for`"

#: ../../reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"Оператор :keyword:`for` используется для перебора элементов "
"последовательности (например, строки, кортежа или списка) или другого "
"итерируемого объекта:"

#: ../../reference/compound_stmts.rst:160
msgid ""
"The ``starred_list`` expression is evaluated once; it should yield an :term:"
"`iterable` object.  An :term:`iterator` is created for that iterable. The "
"first item provided by the iterator is then assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and the "
"suite is executed.  This repeats for each item provided by the iterator.  "
"When the iterator is exhausted, the suite in the :keyword:`!else` clause, if "
"present, is executed, and the loop terminates."
msgstr ""
"Выражение ``starred_list`` вычисляется один раз; он должен дать объект :term:"
"`iterable`. Для этой итерации создается :term:`итератор`. Затем первый "
"элемент, предоставленный итератором, назначается целевому списку с "
"использованием стандартных правил присвоения (см. :ref:`assignment`), и "
"пакет выполняется. Это повторяется для каждого элемента, предоставленного "
"итератором. Когда итератор исчерпан, выполняется набор в предложении :"
"keyword:`!else`, если он присутствует, и цикл завершается."

#: ../../reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"Оператор :keyword:`break`, выполняемый в первом наборе, завершает цикл без "
"выполнения набора предложений :keyword:`!else`. Оператор :keyword:"
"`continue`, выполняемый в первом наборе, пропускает остальную часть набора и "
"переходит к следующему элементу или с предложением :keyword:`!else`, если "
"следующего элемента нет."

#: ../../reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"Цикл for присваивает переменным в целевом списке. Это перезапишет все "
"предыдущие назначения этим переменным, включая те, которые были сделаны в "
"наборе цикла for::"

#: ../../reference/compound_stmts.rst:183
msgid ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"
msgstr ""
"for i in range(10):\n"
"    print(i)\n"
"    i = 5             # this will not affect the for-loop\n"
"                      # because i will be overwritten with the next\n"
"                      # index in the range"

#: ../../reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in type :func:`range` represents immutable arithmetic "
"sequences of integers. For instance, iterating ``range(3)`` successively "
"yields 0, 1, and then 2."
msgstr ""
"Имена в целевом списке не удаляются после завершения цикла, но если "
"последовательность пуста, они вообще не будут назначены циклом. Подсказка: "
"встроенный тип :func:`range` представляет неизменяемые арифметические "
"последовательности целых чисел. Например, последовательная итерация "
"``range(3)`` дает 0, 1, а затем 2."

#: ../../reference/compound_stmts.rst:198
msgid "Starred elements are now allowed in the expression list."
msgstr "Помеченные элементы теперь разрешены в списке выражений."

#: ../../reference/compound_stmts.rst:205
msgid "The :keyword:`!try` statement"
msgstr "Оператор :keyword:`!try`"

#: ../../reference/compound_stmts.rst:215
msgid ""
"The :keyword:`!try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"Оператор :keyword:`!try` определяет обработчики исключений и/или код очистки "
"для группы операторов:"

#: ../../reference/compound_stmts.rst:231
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Дополнительную информацию об исключениях можно найти в разделе :ref:"
"`Exceptions`, а информацию об использовании оператора :keyword:`raise` для "
"генерации исключений можно найти в разделе :ref:`raise`."

#: ../../reference/compound_stmts.rst:239
msgid ":keyword:`!except` clause"
msgstr ":keyword:`!except` clause"

#: ../../reference/compound_stmts.rst:241
msgid ""
"The :keyword:`!except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception handler "
"is executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started. This search inspects the :keyword:`!"
"except` clauses in turn until one is found that matches the exception. An "
"expression-less :keyword:`!except` clause, if present, must be last; it "
"matches any exception."
msgstr ""
"Предложения :keyword:`!Exception` определяют один или несколько обработчиков "
"исключений. Если в предложении :keyword:`try` не возникает исключения, "
"обработчик исключений не выполняется. Когда в наборе :keyword:`!try` "
"возникает исключение, запускается поиск обработчика исключения. Этот поиск "
"поочередно проверяет предложения :keyword:`!Exception`, пока не будет "
"найдено одно, соответствующее исключению. Предложение :keyword:`!Exception` "
"без выражения, если оно присутствует, должно быть последним; оно "
"соответствует любому исключению."

#: ../../reference/compound_stmts.rst:249
msgid ""
"For an :keyword:`!except` clause with an expression, the expression must "
"evaluate to an exception type or a tuple of exception types. The raised "
"exception matches an :keyword:`!except` clause whose expression evaluates to "
"the class or a :term:`non-virtual base class <abstract base class>` of the "
"exception object, or to a tuple that contains such a class."
msgstr "ключений. Вызванное исключение с"

#: ../../reference/compound_stmts.rst:255
msgid ""
"If no :keyword:`!except` clause matches the exception, the search for an "
"exception handler continues in the surrounding code and on the invocation "
"stack.  [#]_"
msgstr ""
"Если ни одно предложение :keyword:`!Exception` не соответствует исключению, "
"поиск обработчика исключения продолжается в окружающем коде и в стеке "
"вызовов. [#]_"

#: ../../reference/compound_stmts.rst:259
msgid ""
"If the evaluation of an expression in the header of an :keyword:`!except` "
"clause raises an exception, the original search for a handler is canceled "
"and a search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement raised "
"the exception)."
msgstr ""
"Если вычисление выражения в заголовке предложения :keyword:`!Exception` "
"вызывает исключение, первоначальный поиск обработчика отменяется и "
"начинается поиск нового исключения в окружающем коде и в стеке вызовов (он "
"рассматривается так, как будто весь оператор :keyword:`try` вызвал "
"исключение)."

#: ../../reference/compound_stmts.rst:267
msgid ""
"When a matching :keyword:`!except` clause is found, the exception is "
"assigned to the target specified after the :keyword:`!as` keyword in that :"
"keyword:`!except` clause, if present, and the :keyword:`!except` clause's "
"suite is executed. All :keyword:`!except` clauses must have an executable "
"block. When the end of this block is reached, execution continues normally "
"after the entire :keyword:`try` statement. (This means that if two nested "
"handlers exist for the same exception, and the exception occurs in the :"
"keyword:`!try` clause of the inner handler, the outer handler will not "
"handle the exception.)"
msgstr ""
"Когда найдено соответствующее предложение :keyword:`!Exception`, исключение "
"назначается цели, указанной после ключевого слова :keyword:`!as` в этом "
"предложении :keyword:`!Exception`, если оно присутствует, и :keyword :`!"
"кроме` набора предложений выполняется. Все предложения :keyword:`!кроме` "
"должны иметь исполняемый блок. Когда достигается конец этого блока, "
"выполнение продолжается в обычном режиме после всего оператора :keyword:"
"`try`. (Это означает, что если для одного и того же исключения существуют "
"два вложенных обработчика, и исключение возникает в предложении :keyword:`!"
"try` внутреннего обработчика, внешний обработчик не будет обрабатывать это "
"исключение.)"

#: ../../reference/compound_stmts.rst:278
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the :keyword:`!except` clause.  This is as if ::"
msgstr ""
"Если исключение было назначено с использованием ``as target``, оно очищается "
"в конце предложения :keyword:`!Exception`. Это как бы:::"

#: ../../reference/compound_stmts.rst:281
msgid ""
"except E as N:\n"
"    foo"
msgstr ""
"except E as N:\n"
"    foo"

#: ../../reference/compound_stmts.rst:284
msgid "was translated to ::"
msgstr "было переведено на::"

#: ../../reference/compound_stmts.rst:286
msgid ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"
msgstr ""
"except E as N:\n"
"    try:\n"
"        foo\n"
"    finally:\n"
"        del N"

#: ../../reference/compound_stmts.rst:292
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the :keyword:`!except` clause. Exceptions are cleared "
"because with the traceback attached to them, they form a reference cycle "
"with the stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"Это означает, что исключению необходимо присвоить другое имя, чтобы можно "
"было ссылаться на него после предложения :keyword:`!Exception`. Исключения "
"удаляются, поскольку с присоединенной к ним обратной трассировкой они "
"образуют ссылочный цикл с кадром стека, сохраняя все локальные значения в "
"этом кадре живыми до тех пор, пока не произойдет следующая сборка мусора."

#: ../../reference/compound_stmts.rst:302
msgid ""
"Before an :keyword:`!except` clause's suite is executed, the exception is "
"stored in the :mod:`sys` module, where it can be accessed from within the "
"body of the :keyword:`!except` clause by calling :func:`sys.exception`. When "
"leaving an exception handler, the exception stored in the :mod:`sys` module "
"is reset to its previous value::"
msgstr ""
"Перед выполнением набора предложений :keyword:`!Exception` исключение "
"сохраняется в модуле :mod:`sys`, где к нему можно получить доступ из тела "
"предложения :keyword:`!except`, вызвав: func:`sys.Exception`. При выходе из "
"обработчика исключений исключение, хранящееся в модуле :mod:`sys`, "
"сбрасывается до предыдущего значения::"

#: ../../reference/compound_stmts.rst:308
msgid ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"
msgstr ""
">>> print(sys.exception())\n"
"None\n"
">>> try:\n"
"...     raise TypeError\n"
"... except:\n"
"...     print(repr(sys.exception()))\n"
"...     try:\n"
"...          raise ValueError\n"
"...     except:\n"
"...         print(repr(sys.exception()))\n"
"...     print(repr(sys.exception()))\n"
"...\n"
"TypeError()\n"
"ValueError()\n"
"TypeError()\n"
">>> print(sys.exception())\n"
"None"

#: ../../reference/compound_stmts.rst:333
msgid ":keyword:`!except*` clause"
msgstr ":keyword:`!except*` clause"

#: ../../reference/compound_stmts.rst:335
msgid ""
"The :keyword:`!except*` clause(s) are used for handling :exc:"
"`ExceptionGroup`\\s. The exception type for matching is interpreted as in "
"the case of :keyword:`except`, but in the case of exception groups we can "
"have partial matches when the type matches some of the exceptions in the "
"group. This means that multiple :keyword:`!except*` clauses can execute, "
"each handling part of the exception group. Each clause executes at most once "
"and handles an exception group of all matching exceptions.  Each exception "
"in the group is handled by at most one :keyword:`!except*` clause, the first "
"that matches it. ::"
msgstr ""
"Предложения :keyword:`!кроме*` используются для обработки :exc:"
"`ExceptionGroup`\\s. Тип исключения для сопоставления интерпретируется так "
"же, как в случае с :keyword:`Exception`, но в случае групп исключений мы "
"можем иметь частичные совпадения, когда тип соответствует некоторым "
"исключениям в группе. Это означает, что может выполняться несколько "
"предложений :keyword:`!Exception*`, каждое из которых обрабатывает часть "
"группы исключений. Каждое предложение выполняется не более одного раза и "
"обрабатывает группу исключений, состоящую из всех соответствующих "
"исключений. Каждое исключение в группе обрабатывается не более чем одним "
"предложением :keyword:`!Exception*`, первым соответствующим ему. ::"

#: ../../reference/compound_stmts.rst:345
msgid ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"
msgstr ""
">>> try:\n"
"...     raise ExceptionGroup(\"eg\",\n"
"...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])\n"
"... except* TypeError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"... except* OSError as e:\n"
"...     print(f'caught {type(e)} with nested {e.exceptions}')\n"
"...\n"
"caught <class 'ExceptionGroup'> with nested (TypeError(2),)\n"
"caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))\n"
"  + Exception Group Traceback (most recent call last):\n"
"  |   File \"<stdin>\", line 2, in <module>\n"
"  | ExceptionGroup: eg\n"
"  +-+---------------- 1 ----------------\n"
"    | ValueError: 1\n"
"    +------------------------------------"

#: ../../reference/compound_stmts.rst:363
msgid ""
"Any remaining exceptions that were not handled by any :keyword:`!except*` "
"clause are re-raised at the end, along with all exceptions that were raised "
"from within the :keyword:`!except*` clauses. If this list contains more than "
"one exception to reraise, they are combined into an exception group."
msgstr ""
"Любые оставшиеся исключения, которые не были обработаны каким-либо "
"предложением :keyword:`!кроме*`, повторно вызываются в конце вместе со всеми "
"исключениями, которые были вызваны из предложений :keyword:`!кроме*`. Если "
"этот список содержит более одного исключения для повторного вызова, они "
"объединяются в группу исключений."

#: ../../reference/compound_stmts.rst:369
msgid ""
"If the raised exception is not an exception group and its type matches one "
"of the :keyword:`!except*` clauses, it is caught and wrapped by an exception "
"group with an empty message string. ::"
msgstr ""
"Если возникшее исключение не является группой исключений и его тип "
"соответствует одному из предложений :keyword:`!кроме*`, оно перехватывается "
"и обертывается группой исключений с пустой строкой сообщения. ::"

#: ../../reference/compound_stmts.rst:373
msgid ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"
msgstr ""
">>> try:\n"
"...     raise BlockingIOError\n"
"... except* BlockingIOError as e:\n"
"...     print(repr(e))\n"
"...\n"
"ExceptionGroup('', (BlockingIOError()))"

#: ../../reference/compound_stmts.rst:380
msgid ""
"An :keyword:`!except*` clause must have a matching expression; it cannot be "
"``except*:``. Furthermore, this expression cannot contain exception group "
"types, because that would have ambiguous semantics."
msgstr ""
"Предложение :keyword:`!кроме*` должно иметь соответствующее выражение; это "
"не может быть ``кроме*:``. Более того, это выражение не может содержать типы "
"групп исключений, поскольку это будет иметь неоднозначную семантику."

#: ../../reference/compound_stmts.rst:384
msgid ""
"It is not possible to mix :keyword:`except` and :keyword:`!except*` in the "
"same :keyword:`try`. :keyword:`break`, :keyword:`continue` and :keyword:"
"`return` cannot appear in an :keyword:`!except*` clause."
msgstr ""
"Невозможно смешивать :keyword:`кроме` и :keyword:`!кроме*` в одном и том же :"
"keyword:`try`. :keyword:`break`, :keyword:`continue` и :keyword:`return` не "
"могут появляться в предложении :keyword:`!кроме*`."

#: ../../reference/compound_stmts.rst:399
msgid ":keyword:`!else` clause"
msgstr ":keyword:`!else` предложение"

#: ../../reference/compound_stmts.rst:401
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"Необязательное предложение :keyword:`!else` выполняется, если поток "
"управления покидает набор :keyword:`try`, не было создано никаких исключений "
"и нет :keyword:`return`, :keyword:`continue` или :keyword. Оператор :`break` "
"был выполнен. Исключения в предложении :keyword:`!else` не обрабатываются "
"предыдущими предложениями :keyword:`Exception`."

#: ../../reference/compound_stmts.rst:413
msgid ":keyword:`!finally` clause"
msgstr ":keyword:`!finally` пункт"

#: ../../reference/compound_stmts.rst:415
msgid ""
"If :keyword:`!finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Если присутствует :keyword:`!finally`, он указывает обработчик «очистки». "
"Выполняется предложение :keyword:`try`, включая любые предложения :keyword:"
"`Exception` и :keyword:`else`. Если исключение возникает в каком-либо из "
"предложений и не обрабатывается, оно временно сохраняется. Предложение :"
"keyword:`!finally` выполняется. Если есть сохраненное исключение, оно "
"повторно вызывается в конце предложения :keyword:`!finally`. Если "
"предложение :keyword:`!finally` вызывает другое исключение, сохраненное "
"исключение устанавливается как контекст нового исключения. Если предложение :"
"keyword:`!finally` выполняет оператор :keyword:`return`, :keyword:`break` "
"или :keyword:`continue`, сохраненное исключение отбрасывается::"

#: ../../reference/compound_stmts.rst:425
msgid ""
">>> def f():\n"
"...     try:\n"
"...         1/0\n"
"...     finally:\n"
"...         return 42\n"
"...\n"
">>> f()\n"
"42"
msgstr ""
">>> def f():\n"
"...     try:\n"
"...         1/0\n"
"...     finally:\n"
"...         return 42\n"
"...\n"
">>> f()\n"
"42"

#: ../../reference/compound_stmts.rst:434
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`!finally` clause."
msgstr ""
"Информация об исключении недоступна программе во время выполнения "
"предложения :keyword:`!finally`."

#: ../../reference/compound_stmts.rst:442
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`!finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Когда оператор :keyword:`return`, :keyword:`break` или :keyword:`continue` "
"выполняется в наборе :keyword:`try` команды :keyword:`!try`...\\ :keyword: `!"
"finally`, предложение :keyword:`!finally` также выполняется «на выходе»."

#: ../../reference/compound_stmts.rst:446
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`!finally` clause always executes, "
"a :keyword:`!return` statement executed in the :keyword:`!finally` clause "
"will always be the last one executed::"
msgstr ""
"Возвращаемое значение функции определяется последним выполненным оператором :"
"keyword:`return`. Поскольку предложение :keyword:`!finally` выполняется "
"всегда, оператор :keyword:`!return`, выполняемый в предложении :keyword:`!"
"finally`, всегда будет выполняться последним::"

#: ../../reference/compound_stmts.rst:451
msgid ""
">>> def foo():\n"
"...     try:\n"
"...         return 'try'\n"
"...     finally:\n"
"...         return 'finally'\n"
"...\n"
">>> foo()\n"
"'finally'"
msgstr ""
">>> def foo():\n"
"...     try:\n"
"...         return 'try'\n"
"...     finally:\n"
"...         return 'finally'\n"
"...\n"
">>> foo()\n"
"'finally'"

#: ../../reference/compound_stmts.rst:460
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`!finally` clause due to a problem with the implementation."
msgstr ""
"До Python 3.8 оператор :keyword:`continue` был недопустимым в предложении :"
"keyword:`!finally` из-за проблем с реализацией."

#: ../../reference/compound_stmts.rst:469
msgid "The :keyword:`!with` statement"
msgstr "Оператор :keyword:`!with`"

#: ../../reference/compound_stmts.rst:478
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"Оператор :keyword:`with` используется для переноса выполнения блока с "
"помощью методов, определенных менеджером контекста (см. раздел :ref:`context-"
"managers`). Это позволяет инкапсулировать общие шаблоны использования :"
"keyword:`try`...\\ :keyword:`Exception`...\\ :keyword:`finally` для удобного "
"повторного использования."

#: ../../reference/compound_stmts.rst:488
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"Выполнение оператора :keyword:`with` с одним «элементом» происходит "
"следующим образом:"

#: ../../reference/compound_stmts.rst:490
msgid ""
"The context expression (the expression given in the :token:`~python-grammar:"
"with_item`) is evaluated to obtain a context manager."
msgstr ""
"Выражение контекста (выражение, указанное в :token:`~python-grammar:"
"with_item`) оценивается для получения менеджера контекста."

#: ../../reference/compound_stmts.rst:493
msgid ""
"The context manager's :meth:`~object.__enter__` is loaded for later use."
msgstr ""
":meth:`~object.__enter__` контекстного менеджера загружается для дальнейшего "
"использования."

#: ../../reference/compound_stmts.rst:495
msgid "The context manager's :meth:`~object.__exit__` is loaded for later use."
msgstr ""
":meth:`~object.__exit__` контекстного менеджера загружается для дальнейшего "
"использования."

#: ../../reference/compound_stmts.rst:497
msgid "The context manager's :meth:`~object.__enter__` method is invoked."
msgstr "Вызывается метод :meth:`~object.__enter__` контекстного менеджера."

#: ../../reference/compound_stmts.rst:499
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`~object.__enter__` is assigned to it."
msgstr ""
"Если цель была включена в оператор :keyword:`with`, ей присваивается "
"возвращаемое значение из :meth:`~object.__enter__`."

#: ../../reference/compound_stmts.rst:504
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`~object."
"__enter__` method returns without an error, then :meth:`~object.__exit__` "
"will always be called. Thus, if an error occurs during the assignment to the "
"target list, it will be treated the same as an error occurring within the "
"suite would be. See step 7 below."
msgstr ""
"Оператор :keyword:`with` гарантирует, что если метод :meth:`~object."
"__enter__` возвращается без ошибки, то :meth:`~object.__exit__` всегда будет "
"вызываться. Таким образом, если во время назначения целевому списку "
"произойдет ошибка, она будет обработана так же, как и ошибка, возникшая в "
"наборе. См. шаг 7 ниже."

#: ../../reference/compound_stmts.rst:510
msgid "The suite is executed."
msgstr "выполнено"

#: ../../reference/compound_stmts.rst:512
msgid ""
"The context manager's :meth:`~object.__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback are "
"passed as arguments to :meth:`~object.__exit__`. Otherwise, three :const:"
"`None` arguments are supplied."
msgstr ""
"Вызывается метод :meth:`~object.__exit__` контекстного менеджера. Если "
"исключение вызвало выход из пакета, его тип, значение и обратная трассировка "
"передаются в качестве аргументов в :meth:`~object.__exit__`. В противном "
"случае предоставляются три аргумента :const:`None`."

#: ../../reference/compound_stmts.rst:517
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`~object.__exit__` method was false, the exception is reraised.  If the "
"return value was true, the exception is suppressed, and execution continues "
"with the statement following the :keyword:`with` statement."
msgstr ""
"Если выход из пакета был выполнен из-за исключения и возвращаемое значение "
"метода :meth:`~object.__exit__` было ложным, исключение вызывается повторно. "
"Если возвращаемое значение было истинным, исключение подавляется, и "
"выполнение продолжается с оператора, следующего за оператором :keyword:"
"`with`."

#: ../../reference/compound_stmts.rst:522
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`~object.__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"Если выход из пакета был выполнен по какой-либо причине, кроме исключения, "
"возвращаемое значение из :meth:`~object.__exit__` игнорируется, и выполнение "
"продолжается в обычном месте для того типа выхода, который был выполнен."

#: ../../reference/compound_stmts.rst:526
#: ../../reference/compound_stmts.rst:1549
#: ../../reference/compound_stmts.rst:1590
msgid "The following code::"
msgstr "Следующий код::"

#: ../../reference/compound_stmts.rst:528
msgid ""
"with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"with EXPRESSION as TARGET:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:531
#: ../../reference/compound_stmts.rst:556
#: ../../reference/compound_stmts.rst:1595
msgid "is semantically equivalent to::"
msgstr "семантически эквивалентно::"

#: ../../reference/compound_stmts.rst:533
msgid ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"
msgstr ""
"manager = (EXPRESSION)\n"
"enter = type(manager).__enter__\n"
"exit = type(manager).__exit__\n"
"value = enter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not exit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        exit(manager, None, None, None)"

#: ../../reference/compound_stmts.rst:550
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"При наличии более чем одного элемента менеджеры контекста обрабатываются "
"так, как если бы несколько операторов :keyword:`with` были вложены::"

#: ../../reference/compound_stmts.rst:553
msgid ""
"with A() as a, B() as b:\n"
"    SUITE"
msgstr ""
"with A() as a, B() as b:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:558
msgid ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"
msgstr ""
"with A() as a:\n"
"    with B() as b:\n"
"        SUITE"

#: ../../reference/compound_stmts.rst:562
msgid ""
"You can also write multi-item context managers in multiple lines if the "
"items are surrounded by parentheses. For example::"
msgstr ""
"Вы также можете написать контекстные менеджеры с несколькими элементами в "
"несколько строк, если элементы заключены в круглые скобки. Например::"

#: ../../reference/compound_stmts.rst:565
msgid ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"
msgstr ""
"with (\n"
"    A() as a,\n"
"    B() as b,\n"
"):\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:571
msgid "Support for multiple context expressions."
msgstr "Поддержка нескольких выражений контекста."

#: ../../reference/compound_stmts.rst:574
msgid ""
"Support for using grouping parentheses to break the statement in multiple "
"lines."
msgstr ""
"Поддержка использования группирующих круглых скобок для разбиения оператора "
"на несколько строк."

#: ../../reference/compound_stmts.rst:579
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Оператор \"with\""

#: ../../reference/compound_stmts.rst:580
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Спецификация, предыстория и примеры оператора Python :keyword:`with`."

#: ../../reference/compound_stmts.rst:586
msgid "The :keyword:`!match` statement"
msgstr "Оператор :keyword:`!match`"

#: ../../reference/compound_stmts.rst:600
msgid "The match statement is used for pattern matching.  Syntax:"
msgstr "Оператор match используется для сопоставления с образцом. Синтаксис:"

#: ../../reference/compound_stmts.rst:609
msgid ""
"This section uses single quotes to denote :ref:`soft keywords <soft-"
"keywords>`."
msgstr ""
"В этом разделе для обозначения :ref:`мягких ключевых слов <soft-keywords>` "
"используются одинарные кавычки."

#: ../../reference/compound_stmts.rst:612
msgid ""
"Pattern matching takes a pattern as input (following ``case``) and a subject "
"value (following ``match``).  The pattern (which may contain subpatterns) is "
"matched against the subject value.  The outcomes are:"
msgstr ""
"Сопоставление с шаблоном принимает шаблон в качестве входных данных (после "
"``case``) и значение субъекта (после ``match``). Шаблон (который может "
"содержать подшаблоны) сопоставляется со значением субъекта. Результаты:"

#: ../../reference/compound_stmts.rst:616
msgid "A match success or failure (also termed a pattern success or failure)."
msgstr ""
"Успех или неудача матча (также называемый успехом или неудачей шаблона)."

#: ../../reference/compound_stmts.rst:618
msgid ""
"Possible binding of matched values to a name.  The prerequisites for this "
"are further discussed below."
msgstr ""
"Возможна привязка совпавших значений к имени. Предпосылки для этого будут "
"подробно рассмотрены ниже."

#: ../../reference/compound_stmts.rst:621
msgid ""
"The ``match`` and ``case`` keywords are :ref:`soft keywords <soft-keywords>`."
msgstr ""
"Ключевые слова ``match`` и ``case`` — это :ref:`softkeywords <soft-"
"keywords>`."

#: ../../reference/compound_stmts.rst:625
#: ../../reference/compound_stmts.rst:1182
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Соответствие структурному шаблону: Спецификация"

#: ../../reference/compound_stmts.rst:626
#: ../../reference/compound_stmts.rst:1183
msgid ":pep:`636` -- Structural Pattern Matching: Tutorial"
msgstr ":pep:`636` -- Сопоставление структурных шаблонов: Учебное пособие"

#: ../../reference/compound_stmts.rst:630
msgid "Overview"
msgstr "Обзор"

#: ../../reference/compound_stmts.rst:632
msgid "Here's an overview of the logical flow of a match statement:"
msgstr "Вот обзор логического потока оператора сопоставления:"

#: ../../reference/compound_stmts.rst:635
msgid ""
"The subject expression ``subject_expr`` is evaluated and a resulting subject "
"value obtained. If the subject expression contains a comma, a tuple is "
"constructed using :ref:`the standard rules <typesseq-tuple>`."
msgstr ""
"Выражение субъекта ``subject_expr`` оценивается и получается результирующее "
"значение субъекта. Если выражение субъекта содержит запятую, кортеж "
"создается с использованием :ref:`стандартных правил <typesseq-tuple>`."

#: ../../reference/compound_stmts.rst:639
msgid ""
"Each pattern in a ``case_block`` is attempted to match with the subject "
"value. The specific rules for success or failure are described below. The "
"match attempt can also bind some or all of the standalone names within the "
"pattern. The precise pattern binding rules vary per pattern type and are "
"specified below.  **Name bindings made during a successful pattern match "
"outlive the executed block and can be used after the match statement**."
msgstr ""
"Каждый шаблон в ``case_block`` пытается сопоставить со значением субъекта. "
"Конкретные правила успеха или неудачи описаны ниже. Попытка сопоставления "
"также может связать некоторые или все отдельные имена в шаблоне. Точные "
"правила привязки шаблонов различаются в зависимости от типа шаблона и "
"указаны ниже. **Привязки имен, созданные во время успешного сопоставления с "
"образцом, сохраняются после выполнения исполняемого блока и могут "
"использоваться после оператора сопоставления**."

#: ../../reference/compound_stmts.rst:648
msgid ""
"During failed pattern matches, some subpatterns may succeed.  Do not rely on "
"bindings being made for a failed match.  Conversely, do not rely on "
"variables remaining unchanged after a failed match.  The exact behavior is "
"dependent on implementation and may vary.  This is an intentional decision "
"made to allow different implementations to add optimizations."
msgstr ""
"Во время неудачных сопоставлений с шаблонами некоторые подшаблоны могут "
"оказаться успешными. Не полагайтесь на то, что привязки создаются для "
"неудачного совпадения. И наоборот, не полагайтесь на то, что переменные "
"останутся неизменными после неудачного сопоставления. Точное поведение "
"зависит от реализации и может варьироваться. Это намеренное решение, "
"принятое для того, чтобы позволить различным реализациям добавлять "
"оптимизации."

#: ../../reference/compound_stmts.rst:655
msgid ""
"If the pattern succeeds, the corresponding guard (if present) is evaluated. "
"In this case all name bindings are guaranteed to have happened."
msgstr ""
"Если шаблон успешен, оценивается соответствующий предохранитель (если он "
"присутствует). В этом случае все привязки имен гарантированно произойдут."

#: ../../reference/compound_stmts.rst:658
msgid ""
"If the guard evaluates as true or is missing, the ``block`` inside "
"``case_block`` is executed."
msgstr ""
"Если защита оценивается как истинная или отсутствует, выполняется ``блок'' "
"внутри ``case_block``."

#: ../../reference/compound_stmts.rst:661
msgid "Otherwise, the next ``case_block`` is attempted as described above."
msgstr ""
"В противном случае будет предпринята попытка следующего ``case_block``, как "
"описано выше."

#: ../../reference/compound_stmts.rst:663
msgid "If there are no further case blocks, the match statement is completed."
msgstr ""
"Если дополнительных блоков case нет, оператор сопоставления завершается."

#: ../../reference/compound_stmts.rst:667
msgid ""
"Users should generally never rely on a pattern being evaluated.  Depending "
"on implementation, the interpreter may cache values or use other "
"optimizations which skip repeated evaluations."
msgstr ""
"Обычно пользователям никогда не следует полагаться на оцениваемый шаблон. В "
"зависимости от реализации интерпретатор может кэшировать значения или "
"использовать другие оптимизации, которые пропускают повторные вычисления."

#: ../../reference/compound_stmts.rst:671
msgid "A sample match statement::"
msgstr "Пример заявления о совпадении:"

#: ../../reference/compound_stmts.rst:673
msgid ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"
msgstr ""
">>> flag = False\n"
">>> match (100, 200):\n"
"...    case (100, 300):  # Mismatch: 200 != 300\n"
"...        print('Case 1')\n"
"...    case (100, 200) if flag:  # Successful match, but guard fails\n"
"...        print('Case 2')\n"
"...    case (100, y):  # Matches and binds y to 200\n"
"...        print(f'Case 3, y: {y}')\n"
"...    case _:  # Pattern not attempted\n"
"...        print('Case 4, I match anything!')\n"
"...\n"
"Case 3, y: 200"

#: ../../reference/compound_stmts.rst:687
msgid ""
"In this case, ``if flag`` is a guard.  Read more about that in the next "
"section."
msgstr ""
"В этом случае ``if flag`` является охраной. Подробнее об этом читайте в "
"следующем разделе."

#: ../../reference/compound_stmts.rst:690
msgid "Guards"
msgstr "Охранники"

#: ../../reference/compound_stmts.rst:697
msgid ""
"A ``guard`` (which is part of the ``case``) must succeed for code inside the "
"``case`` block to execute.  It takes the form: :keyword:`if` followed by an "
"expression."
msgstr ""
"``Защитник`` (который является частью ``case``) должен быть успешным, чтобы "
"код внутри блока ``case`` выполнился. Он принимает форму: :keyword:`if`, за "
"которым следует выражение."

#: ../../reference/compound_stmts.rst:702
msgid "The logical flow of a ``case`` block with a ``guard`` follows:"
msgstr "Логическая последовательность блоков ``case`` с ``guard`` следующая:"

#: ../../reference/compound_stmts.rst:704
msgid ""
"Check that the pattern in the ``case`` block succeeded.  If the pattern "
"failed, the ``guard`` is not evaluated and the next ``case`` block is "
"checked."
msgstr ""
"Убедитесь, что шаблон в блоке ``case`` выполнен успешно. Если шаблон не "
"удался, то защита не оценивается и проверяется следующий блок случая."

#: ../../reference/compound_stmts.rst:708
msgid "If the pattern succeeded, evaluate the ``guard``."
msgstr "Если шаблон удался, оцените ``guard``."

#: ../../reference/compound_stmts.rst:710
msgid ""
"If the ``guard`` condition evaluates as true, the case block is selected."
msgstr "Если условие ``guard`` оценивается как истинное, выбирается блок case."

#: ../../reference/compound_stmts.rst:713
msgid ""
"If the ``guard`` condition evaluates as false, the case block is not "
"selected."
msgstr ""
"Если условие ``guard`` оценивается как ложное, блок case не выбирается."

#: ../../reference/compound_stmts.rst:716
msgid ""
"If the ``guard`` raises an exception during evaluation, the exception "
"bubbles up."
msgstr ""
"Если «защита» вызывает исключение во время оценки, исключение всплывает."

#: ../../reference/compound_stmts.rst:719
msgid ""
"Guards are allowed to have side effects as they are expressions.  Guard "
"evaluation must proceed from the first to the last case block, one at a "
"time, skipping case blocks whose pattern(s) don't all succeed. (I.e., guard "
"evaluation must happen in order.) Guard evaluation must stop once a case "
"block is selected."
msgstr ""
"Охранникам разрешено иметь побочные эффекты, поскольку они являются "
"выражениями. Оценка защиты должна идти от первого к последнему блоку Case, "
"по одному, пропуская блоки Case, в которых не все шаблоны являются "
"успешными. (То есть оценка защиты должна происходить по порядку.) Оценка "
"защиты должна прекратиться после выбора блока дела."

#: ../../reference/compound_stmts.rst:729
msgid "Irrefutable Case Blocks"
msgstr "Неопровержимые блоки кейсов"

#: ../../reference/compound_stmts.rst:733
msgid ""
"An irrefutable case block is a match-all case block.  A match statement may "
"have at most one irrefutable case block, and it must be last."
msgstr ""
"Неопровержимый блок кейсов — это блок кейсов, учитывающий все совпадения. "
"Оператор сопоставления может иметь не более одного неопровержимого блока "
"регистров, и он должен быть последним."

#: ../../reference/compound_stmts.rst:736
msgid ""
"A case block is considered irrefutable if it has no guard and its pattern is "
"irrefutable.  A pattern is considered irrefutable if we can prove from its "
"syntax alone that it will always succeed.  Only the following patterns are "
"irrefutable:"
msgstr ""
"Блок Case считается неопровержимым, если он не имеет защиты и его образец "
"неопровержим. Шаблон считается неопровержимым, если мы можем доказать, "
"исходя только из его синтаксиса, что он всегда будет успешным. "
"Неопровержимыми являются только следующие закономерности:"

#: ../../reference/compound_stmts.rst:741
msgid ":ref:`as-patterns` whose left-hand side is irrefutable"
msgstr ":ref:`as-patterns`, левая часть которого неопровержима"

#: ../../reference/compound_stmts.rst:743
msgid ":ref:`or-patterns` containing at least one irrefutable pattern"
msgstr ":ref:`or-patterns`, содержащий хотя бы один неопровержимый шаблон"

#: ../../reference/compound_stmts.rst:745
msgid ":ref:`capture-patterns`"
msgstr ":ref:`capture-patterns`"

#: ../../reference/compound_stmts.rst:747
msgid ":ref:`wildcard-patterns`"
msgstr ":ref:`wildcard-patterns`"

#: ../../reference/compound_stmts.rst:749
msgid "parenthesized irrefutable patterns"
msgstr "заключенные в скобки неопровержимые закономерности"

#: ../../reference/compound_stmts.rst:753
msgid "Patterns"
msgstr "Паттерны"

#: ../../reference/compound_stmts.rst:760
msgid "This section uses grammar notations beyond standard EBNF:"
msgstr ""
"В этом разделе используются грамматические обозначения, выходящие за рамки "
"стандартного EBNF:"

#: ../../reference/compound_stmts.rst:762
msgid "the notation ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``"
msgstr "обозначение ``SEP.RULE+`` является сокращением от ``RULE (SEP RULE)*``"

#: ../../reference/compound_stmts.rst:764
msgid "the notation ``!RULE`` is shorthand for a negative lookahead assertion"
msgstr ""
"обозначение ``!RULE`` является сокращением для утверждения отрицательного "
"просмотра вперед."

#: ../../reference/compound_stmts.rst:767
msgid "The top-level syntax for ``patterns`` is:"
msgstr "Синтаксис верхнего уровня для ``шаблонов``:"

#: ../../reference/compound_stmts.rst:781
msgid ""
"The descriptions below will include a description \"in simple terms\" of "
"what a pattern does for illustration purposes (credits to Raymond Hettinger "
"for a document that inspired most of the descriptions). Note that these "
"descriptions are purely for illustration purposes and **may not** reflect "
"the underlying implementation.  Furthermore, they do not cover all valid "
"forms."
msgstr ""
"Описания ниже будут включать в себя «простыми словами» описание того, что "
"делает шаблон, в целях иллюстрации (спасибо Рэймонду Хеттингеру за документ, "
"который вдохновил большинство описаний). Обратите внимание, что эти описания "
"предназначены исключительно для иллюстрации и **могут** не отражать базовую "
"реализацию. Кроме того, они не охватывают все действительные формы."

#: ../../reference/compound_stmts.rst:791
msgid "OR Patterns"
msgstr "OR Patterns"

#: ../../reference/compound_stmts.rst:793
msgid ""
"An OR pattern is two or more patterns separated by vertical bars ``|``.  "
"Syntax:"
msgstr ""
"Шаблон OR — это два или более шаблонов, разделенных вертикальными полосами "
"``|``. Синтаксис:"

#: ../../reference/compound_stmts.rst:799
msgid ""
"Only the final subpattern may be :ref:`irrefutable <irrefutable_case>`, and "
"each subpattern must bind the same set of names to avoid ambiguity."
msgstr ""
"Только последний подшаблон может быть :ref:`irrefutable <irrefutable_case>`, "
"и каждый подшаблон должен связывать один и тот же набор имен, чтобы избежать "
"двусмысленности."

#: ../../reference/compound_stmts.rst:802
msgid ""
"An OR pattern matches each of its subpatterns in turn to the subject value, "
"until one succeeds.  The OR pattern is then considered successful.  "
"Otherwise, if none of the subpatterns succeed, the OR pattern fails."
msgstr ""
"Шаблон OR сопоставляет каждый из своих подшаблонов по очереди со значением "
"субъекта, пока один из них не будет успешным. В этом случае шаблон ИЛИ "
"считается успешным. В противном случае, если ни один из подшаблонов не "
"удался, шаблон OR завершится неудачей."

#: ../../reference/compound_stmts.rst:806
msgid ""
"In simple terms, ``P1 | P2 | ...`` will try to match ``P1``, if it fails it "
"will try to match ``P2``, succeeding immediately if any succeeds, failing "
"otherwise."
msgstr ""
"Проще говоря, ``P1 | П2 | ...`` попытается сопоставить ``P1``, в случае "
"неудачи он попытается сопоставить ``P2``, с немедленным успехом, если какой-"
"либо из них окажется успешным, и неудачей в противном случае."

#: ../../reference/compound_stmts.rst:812
msgid "AS Patterns"
msgstr "AS Patterns"

#: ../../reference/compound_stmts.rst:814
msgid ""
"An AS pattern matches an OR pattern on the left of the :keyword:`as` keyword "
"against a subject.  Syntax:"
msgstr ""
"Шаблон AS соответствует шаблону OR слева от ключевого слова :keyword:`as`, "
"соответствующего теме. Синтаксис:"

#: ../../reference/compound_stmts.rst:820
msgid ""
"If the OR pattern fails, the AS pattern fails.  Otherwise, the AS pattern "
"binds the subject to the name on the right of the as keyword and succeeds. "
"``capture_pattern`` cannot be a ``_``."
msgstr ""
"Если шаблон OR не работает, шаблон AS не работает. В противном случае шаблон "
"AS привязывает субъект к имени справа от ключевого слова as и завершается "
"успешно. ``capture_pattern`` не может быть ``_``."

#: ../../reference/compound_stmts.rst:824
msgid ""
"In simple terms ``P as NAME`` will match with ``P``, and on success it will "
"set ``NAME = <subject>``."
msgstr ""
"Проще говоря, ``P as NAME`` будет соответствовать ``P``, и в случае успеха "
"будет установлено ``NAME = <subject>``."

#: ../../reference/compound_stmts.rst:831
msgid "Literal Patterns"
msgstr "Буквальные шаблоны"

#: ../../reference/compound_stmts.rst:833
msgid ""
"A literal pattern corresponds to most :ref:`literals <literals>` in Python.  "
"Syntax:"
msgstr ""
"Шаблон литерала соответствует большинству литералов <литералов>` в Python. "
"Синтаксис:"

#: ../../reference/compound_stmts.rst:846
msgid ""
"The rule ``strings`` and the token ``NUMBER`` are defined in the :doc:"
"`standard Python grammar <./grammar>`.  Triple-quoted strings are "
"supported.  Raw strings and byte strings are supported.  :ref:`f-strings` "
"are not supported."
msgstr ""
"Правило ``строки`` и токен ``NUMBER`` определены в :doc:`стандартной "
"грамматике Python <./grammar>`. Поддерживаются строки в тройных кавычках. "
"Поддерживаются необработанные строки и байтовые строки. :ref:`f-строки` не "
"поддерживаются."

#: ../../reference/compound_stmts.rst:851
msgid ""
"The forms ``signed_number '+' NUMBER`` and ``signed_number '-' NUMBER`` are "
"for expressing :ref:`complex numbers <imaginary>`; they require a real "
"number on the left and an imaginary number on the right. E.g. ``3 + 4j``."
msgstr ""
"Формы ``signed_number '+' NUMBER`` и ``signed_number '-' NUMBER`` "
"предназначены для выражения :ref:`комплексных чисел <мнимый>`; им требуется "
"действительное число слева и мнимое число справа. Например, ``3 + 4j``."

#: ../../reference/compound_stmts.rst:855
msgid ""
"In simple terms, ``LITERAL`` will succeed only if ``<subject> == LITERAL``. "
"For the singletons ``None``, ``True`` and ``False``, the :keyword:`is` "
"operator is used."
msgstr ""
"Проще говоря, ``LITERAL`` будет успешным, только если ``<subject> == "
"LITERAL``. Для синглтонов None, True и False используется оператор :keyword:"
"is."

#: ../../reference/compound_stmts.rst:861
msgid "Capture Patterns"
msgstr "Capture Patterns"

#: ../../reference/compound_stmts.rst:863
msgid "A capture pattern binds the subject value to a name. Syntax:"
msgstr "Шаблон захвата привязывает значение субъекта к имени. Синтаксис:"

#: ../../reference/compound_stmts.rst:869
msgid ""
"A single underscore ``_`` is not a capture pattern (this is what ``!'_'`` "
"expresses). It is instead treated as a :token:`~python-grammar:"
"wildcard_pattern`."
msgstr ""
"Одиночное подчеркивание ``_`` не является шаблоном захвата (это то, что "
"выражает ``!'_'``). Вместо этого он рассматривается как :token:`~python-"
"grammar:wildcard_pattern`."

#: ../../reference/compound_stmts.rst:873
msgid ""
"In a given pattern, a given name can only be bound once.  E.g. ``case x, "
"x: ...`` is invalid while ``case [x] | x: ...`` is allowed."
msgstr ""
"В данном шаблоне данное имя может быть связано только один раз. Например, "
"``case x, x: ...`` недействителен, а ``case [x] | x: ...`` разрешено."

#: ../../reference/compound_stmts.rst:876
msgid ""
"Capture patterns always succeed.  The binding follows scoping rules "
"established by the assignment expression operator in :pep:`572`; the name "
"becomes a local variable in the closest containing function scope unless "
"there's an applicable :keyword:`global` or :keyword:`nonlocal` statement."
msgstr ""
"Захват шаблонов всегда успешен. Привязка следует правилам области видимости, "
"установленным оператором выражения присваивания в :pep:`572`; имя становится "
"локальной переменной в ближайшей содержащейся области функции, если не "
"существует применимого оператора :keyword:`global` или :keyword:`nonlocal`."

#: ../../reference/compound_stmts.rst:881
msgid ""
"In simple terms ``NAME`` will always succeed and it will set ``NAME = "
"<subject>``."
msgstr ""
"Проще говоря, ``NAME`` всегда будет успешным и установит ``NAME = "
"<subject>``."

#: ../../reference/compound_stmts.rst:886
msgid "Wildcard Patterns"
msgstr "Шаблоны подстановочных знаков"

#: ../../reference/compound_stmts.rst:888
msgid ""
"A wildcard pattern always succeeds (matches anything) and binds no name.  "
"Syntax:"
msgstr ""
"Шаблон подстановочного знака всегда успешен (соответствует чему угодно) и не "
"связывает имя. Синтаксис:"

#: ../../reference/compound_stmts.rst:894
msgid ""
"``_`` is a :ref:`soft keyword <soft-keywords>` within any pattern, but only "
"within patterns.  It is an identifier, as usual, even within ``match`` "
"subject expressions, ``guard``\\ s, and ``case`` blocks."
msgstr ""
"``_`` является :ref:`мягким ключевым словом <soft-keywords>` в любом "
"шаблоне, но только внутри шаблонов. Как обычно, это идентификатор даже "
"внутри выражений субъекта ``match``, ``guard``\\ и блоков ``case``."

#: ../../reference/compound_stmts.rst:898
msgid "In simple terms, ``_`` will always succeed."
msgstr "Проще говоря, ``_`` всегда будет успешным."

#: ../../reference/compound_stmts.rst:903
msgid "Value Patterns"
msgstr "Шаблоны значений"

#: ../../reference/compound_stmts.rst:905
msgid "A value pattern represents a named value in Python. Syntax:"
msgstr "Шаблон значения представляет именованное значение в Python. Синтаксис:"

#: ../../reference/compound_stmts.rst:913
msgid ""
"The dotted name in the pattern is looked up using standard Python :ref:`name "
"resolution rules <resolve_names>`.  The pattern succeeds if the value found "
"compares equal to the subject value (using the ``==`` equality operator)."
msgstr ""
"Имя с точками в шаблоне ищется с использованием стандартных правил "
"разрешения имен Python <resolve_names>. Шаблон успешен, если найденное "
"значение сравнивается со значением субъекта (с использованием оператора "
"равенства ``==``)."

#: ../../reference/compound_stmts.rst:918
msgid ""
"In simple terms ``NAME1.NAME2`` will succeed only if ``<subject> == NAME1."
"NAME2``"
msgstr ""
"Проще говоря, ``ИМЯ1.ИМЯ2`` будет успешным, только если ``<субъект> == ИМЯ1."
"ИМЯ2``"

#: ../../reference/compound_stmts.rst:922
msgid ""
"If the same value occurs multiple times in the same match statement, the "
"interpreter may cache the first value found and reuse it rather than repeat "
"the same lookup.  This cache is strictly tied to a given execution of a "
"given match statement."
msgstr ""
"Если одно и то же значение встречается несколько раз в одном и том же "
"операторе сопоставления, интерпретатор может кэшировать первое найденное "
"значение и повторно использовать его, а не повторять один и тот же поиск. "
"Этот кеш строго привязан к данному выполнению данного оператора "
"сопоставления."

#: ../../reference/compound_stmts.rst:930
msgid "Group Patterns"
msgstr "Групповые шаблоны"

#: ../../reference/compound_stmts.rst:932
msgid ""
"A group pattern allows users to add parentheses around patterns to emphasize "
"the intended grouping.  Otherwise, it has no additional syntax. Syntax:"
msgstr ""
"Шаблон группы позволяет пользователям добавлять круглые скобки вокруг "
"шаблонов, чтобы подчеркнуть предполагаемую группировку. В противном случае у "
"него нет дополнительного синтаксиса. Синтаксис:"

#: ../../reference/compound_stmts.rst:939
msgid "In simple terms ``(P)`` has the same effect as ``P``."
msgstr "Проще говоря, ``(P)`` имеет тот же эффект, что и ``P``."

#: ../../reference/compound_stmts.rst:944
msgid "Sequence Patterns"
msgstr "Шаблоны последовательностей"

#: ../../reference/compound_stmts.rst:946
msgid ""
"A sequence pattern contains several subpatterns to be matched against "
"sequence elements. The syntax is similar to the unpacking of a list or tuple."
msgstr ""
"Шаблон последовательности содержит несколько подшаблонов, которые необходимо "
"сопоставить с элементами последовательности. Синтаксис аналогичен распаковке "
"списка или кортежа."

#: ../../reference/compound_stmts.rst:957
msgid ""
"There is no difference if parentheses  or square brackets are used for "
"sequence patterns (i.e. ``(...)`` vs ``[...]`` )."
msgstr ""
"Нет никакой разницы, используются ли круглые или квадратные скобки для "
"шаблонов последовательности (т. е. ``(...)`` или ``[...]`` )."

#: ../../reference/compound_stmts.rst:961
msgid ""
"A single pattern enclosed in parentheses without a trailing comma (e.g. ``(3 "
"| 4)``) is a :ref:`group pattern <group-patterns>`. While a single pattern "
"enclosed in square brackets (e.g. ``[3 | 4]``) is still a sequence pattern."
msgstr ""
"Одиночный шаблон, заключенный в круглые скобки без запятой в конце "
"(например, ``(3 | 4)``), является :ref:`групповым шаблоном <group-"
"patterns>`. Хотя один шаблон, заключенный в квадратные скобки (например, "
"``[3 | 4]``), по-прежнему является шаблоном последовательности."

#: ../../reference/compound_stmts.rst:966
msgid ""
"At most one star subpattern may be in a sequence pattern.  The star "
"subpattern may occur in any position. If no star subpattern is present, the "
"sequence pattern is a fixed-length sequence pattern; otherwise it is a "
"variable-length sequence pattern."
msgstr ""
"В шаблоне последовательности может присутствовать не более одного подшаблона "
"звезды. Звездчатый подшаблон может встречаться в любом положении. Если "
"звездчатый подшаблон отсутствует, шаблон последовательности представляет "
"собой шаблон последовательности фиксированной длины; в противном случае это "
"шаблон последовательности переменной длины."

#: ../../reference/compound_stmts.rst:971
msgid ""
"The following is the logical flow for matching a sequence pattern against a "
"subject value:"
msgstr ""
"Ниже приведен логический процесс сопоставления шаблона последовательности со "
"значением субъекта:"

#: ../../reference/compound_stmts.rst:974
msgid ""
"If the subject value is not a sequence [#]_, the sequence pattern fails."
msgstr ""
"Если значение субъекта не является последовательностью [#]_ , шаблон "
"последовательности не работает."

#: ../../reference/compound_stmts.rst:977
msgid ""
"If the subject value is an instance of ``str``, ``bytes`` or ``bytearray`` "
"the sequence pattern fails."
msgstr ""
"Если значение субъекта является экземпляром ``str``, ``bytes`` или "
"``bytearray``, шаблон последовательности не работает."

#: ../../reference/compound_stmts.rst:980
msgid ""
"The subsequent steps depend on whether the sequence pattern is fixed or "
"variable-length."
msgstr ""
"Последующие шаги зависят от того, является ли шаблон последовательности "
"фиксированной или переменной длины."

#: ../../reference/compound_stmts.rst:983
msgid "If the sequence pattern is fixed-length:"
msgstr "Если шаблон последовательности имеет фиксированную длину:"

#: ../../reference/compound_stmts.rst:985
msgid ""
"If the length of the subject sequence is not equal to the number of "
"subpatterns, the sequence pattern fails"
msgstr ""
"Если длина рассматриваемой последовательности не равна количеству "
"подшаблонов, шаблон последовательности не работает."

#: ../../reference/compound_stmts.rst:988
msgid ""
"Subpatterns in the sequence pattern are matched to their corresponding items "
"in the subject sequence from left to right.  Matching stops as soon as a "
"subpattern fails.  If all subpatterns succeed in matching their "
"corresponding item, the sequence pattern succeeds."
msgstr ""
"Подшаблоны в шаблоне последовательности сопоставляются с соответствующими им "
"элементами в предметной последовательности слева направо. Сопоставление "
"прекращается, как только подшаблон терпит неудачу. Если все подшаблоны "
"успешно сопоставляют соответствующий элемент, шаблон последовательности "
"успешен."

#: ../../reference/compound_stmts.rst:993
msgid "Otherwise, if the sequence pattern is variable-length:"
msgstr ""
"В противном случае, если шаблон последовательности имеет переменную длину:"

#: ../../reference/compound_stmts.rst:995
msgid ""
"If the length of the subject sequence is less than the number of non-star "
"subpatterns, the sequence pattern fails."
msgstr ""
"Если длина рассматриваемой последовательности меньше количества незвездных "
"подшаблонов, шаблон последовательности не работает."

#: ../../reference/compound_stmts.rst:998
msgid ""
"The leading non-star subpatterns are matched to their corresponding items as "
"for fixed-length sequences."
msgstr ""
"Ведущие незвездчатые подшаблоны сопоставляются с соответствующими им "
"элементами, как и для последовательностей фиксированной длины."

#: ../../reference/compound_stmts.rst:1001
msgid ""
"If the previous step succeeds, the star subpattern matches a list formed of "
"the remaining subject items, excluding the remaining items corresponding to "
"non-star subpatterns following the star subpattern."
msgstr ""
"Если предыдущий шаг успешен, подшаблон «звезда» соответствует списку, "
"сформированному из оставшихся предметных элементов, исключая оставшиеся "
"элементы, соответствующие подшаблонам без звездочки, следующим за "
"подшаблоном «звезда»."

#: ../../reference/compound_stmts.rst:1005
msgid ""
"Remaining non-star subpatterns are matched to their corresponding subject "
"items, as for a fixed-length sequence."
msgstr ""
"Остальные подшаблоны, не являющиеся звездочками, сопоставляются с "
"соответствующими предметными элементами, как и для последовательности "
"фиксированной длины."

#: ../../reference/compound_stmts.rst:1008
msgid ""
"The length of the subject sequence is obtained via :func:`len` (i.e. via "
"the :meth:`__len__` protocol).  This length may be cached by the interpreter "
"in a similar manner as :ref:`value patterns <value-patterns>`."
msgstr ""
"Длина рассматриваемой последовательности получается с помощью :func:`len` (т."
"е. с помощью протокола :meth:`__len__`). Эта длина может кэшироваться "
"интерпретатором аналогично шаблонам значений <value-patterns>."

#: ../../reference/compound_stmts.rst:1014
msgid ""
"In simple terms ``[P1, P2, P3,`` ... ``, P<N>]`` matches only if all the "
"following happens:"
msgstr ""
"Проще говоря, ``[P1, P2, P3,`` ... ``, P<N>]`` соответствует только в том "
"случае, если происходит все следующее:"

#: ../../reference/compound_stmts.rst:1017
msgid "check ``<subject>`` is a sequence"
msgstr "проверьте ``<subject>`` является последовательностью"

#: ../../reference/compound_stmts.rst:1018
msgid "``len(subject) == <N>``"
msgstr "``len(subject) == <N>``"

#: ../../reference/compound_stmts.rst:1019
msgid ""
"``P1`` matches ``<subject>[0]`` (note that this match can also bind names)"
msgstr ""
"``P1`` соответствует ``<subject>[0]`` (обратите внимание, что это совпадение "
"также может связывать имена)"

#: ../../reference/compound_stmts.rst:1020
msgid ""
"``P2`` matches ``<subject>[1]`` (note that this match can also bind names)"
msgstr ""
"``P2`` соответствует ``<subject>[1]`` (обратите внимание, что это совпадение "
"также может связывать имена)"

#: ../../reference/compound_stmts.rst:1021
msgid "... and so on for the corresponding pattern/element."
msgstr "... и так далее для соответствующего шаблона/элемента."

#: ../../reference/compound_stmts.rst:1026
msgid "Mapping Patterns"
msgstr "Сопоставление шаблонов"

#: ../../reference/compound_stmts.rst:1028
msgid ""
"A mapping pattern contains one or more key-value patterns.  The syntax is "
"similar to the construction of a dictionary. Syntax:"
msgstr ""
"Шаблон сопоставления содержит один или несколько шаблонов «ключ-значение». "
"Синтаксис аналогичен построению словаря. Синтаксис:"

#: ../../reference/compound_stmts.rst:1039
msgid ""
"At most one double star pattern may be in a mapping pattern.  The double "
"star pattern must be the last subpattern in the mapping pattern."
msgstr ""
"В шаблоне отображения может присутствовать не более одного шаблона двойной "
"звезды. Шаблон двойной звезды должен быть последним подшаблоном в шаблоне "
"сопоставления."

#: ../../reference/compound_stmts.rst:1042
msgid ""
"Duplicate keys in mapping patterns are disallowed. Duplicate literal keys "
"will raise a :exc:`SyntaxError`. Two keys that otherwise have the same value "
"will raise a :exc:`ValueError` at runtime."
msgstr ""
"Дублирование ключей в шаблонах сопоставления запрещено. Дублирующиеся "
"литеральные ключи вызовут ошибку :exc:`SyntaxError`. Два ключа, которые в "
"противном случае имеют одинаковое значение, вызовут ошибку :exc:`ValueError` "
"во время выполнения."

#: ../../reference/compound_stmts.rst:1046
msgid ""
"The following is the logical flow for matching a mapping pattern against a "
"subject value:"
msgstr ""
"Ниже приведен логический процесс сопоставления шаблона сопоставления со "
"значением субъекта:"

#: ../../reference/compound_stmts.rst:1049
msgid "If the subject value is not a mapping [#]_,the mapping pattern fails."
msgstr ""
"Если значение субъекта не является отображением [#]_ , шаблон сопоставления "
"не работает."

#: ../../reference/compound_stmts.rst:1051
msgid ""
"If every key given in the mapping pattern is present in the subject mapping, "
"and the pattern for each key matches the corresponding item of the subject "
"mapping, the mapping pattern succeeds."
msgstr ""
"Если каждый ключ, заданный в шаблоне сопоставления, присутствует в "
"сопоставлении субъектов, и шаблон для каждого ключа соответствует "
"соответствующему элементу сопоставления субъектов, шаблон сопоставления "
"успешен."

#: ../../reference/compound_stmts.rst:1055
msgid ""
"If duplicate keys are detected in the mapping pattern, the pattern is "
"considered invalid. A :exc:`SyntaxError` is raised for duplicate literal "
"values; or a :exc:`ValueError` for named keys of the same value."
msgstr ""
"Если в шаблоне сопоставления обнаружены повторяющиеся ключи, шаблон "
"считается недействительным. Ошибка :exc:`SyntaxError` возникает для "
"повторяющихся литеральных значений; или :exc:`ValueError` для именованных "
"ключей с тем же значением."

#: ../../reference/compound_stmts.rst:1059
msgid ""
"Key-value pairs are matched using the two-argument form of the mapping "
"subject's ``get()`` method.  Matched key-value pairs must already be present "
"in the mapping, and not created on-the-fly via :meth:`__missing__` or :meth:"
"`~object.__getitem__`."
msgstr ""
"Пары ключ-значение сопоставляются с использованием двухаргументной формы "
"метода get() объекта сопоставления. Соответствующие пары ключ-значение "
"должны уже присутствовать в сопоставлении, а не создаваться на лету с "
"помощью :meth:`__missing__` или :meth:`~object.__getitem__`."

#: ../../reference/compound_stmts.rst:1064
msgid ""
"In simple terms ``{KEY1: P1, KEY2: P2, ... }`` matches only if all the "
"following happens:"
msgstr ""
"Проще говоря, ``{KEY1: P1, KEY2: P2, ... }`` соответствует только в том "
"случае, если происходит все следующее:"

#: ../../reference/compound_stmts.rst:1067
msgid "check ``<subject>`` is a mapping"
msgstr "проверьте, что ``<subject>`` является сопоставлением"

#: ../../reference/compound_stmts.rst:1068
msgid "``KEY1 in <subject>``"
msgstr "``KEY1 in <subject>``"

#: ../../reference/compound_stmts.rst:1069
msgid "``P1`` matches ``<subject>[KEY1]``"
msgstr "``P1`` соответствует ``<subject>[KEY1]``"

#: ../../reference/compound_stmts.rst:1070
msgid "... and so on for the corresponding KEY/pattern pair."
msgstr "... и так далее для соответствующей пары КЛЮЧ/шаблон."

#: ../../reference/compound_stmts.rst:1076
msgid "Class Patterns"
msgstr "Шаблоны классов"

#: ../../reference/compound_stmts.rst:1078
msgid ""
"A class pattern represents a class and its positional and keyword arguments "
"(if any).  Syntax:"
msgstr ""
"Шаблон класса представляет класс и его позиционные и ключевые аргументы "
"(если таковые имеются). Синтаксис:"

#: ../../reference/compound_stmts.rst:1089
msgid "The same keyword should not be repeated in class patterns."
msgstr "Одно и то же ключевое слово не должно повторяться в шаблонах классов."

#: ../../reference/compound_stmts.rst:1091
msgid ""
"The following is the logical flow for matching a class pattern against a "
"subject value:"
msgstr ""
"Ниже приведен логический процесс сопоставления шаблона класса со значением "
"субъекта:"

#: ../../reference/compound_stmts.rst:1094
msgid ""
"If ``name_or_attr`` is not an instance of the builtin :class:`type` , raise :"
"exc:`TypeError`."
msgstr ""
"Если ``name_or_attr`` не является экземпляром встроенного :class:`type` , "
"поднимите :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1097
msgid ""
"If the subject value is not an instance of ``name_or_attr`` (tested via :"
"func:`isinstance`), the class pattern fails."
msgstr ""
"Если значение субъекта не является экземпляром ``name_or_attr`` (проверено с "
"помощью :func:`isinstance`), шаблон класса не работает."

#: ../../reference/compound_stmts.rst:1100
msgid ""
"If no pattern arguments are present, the pattern succeeds.  Otherwise, the "
"subsequent steps depend on whether keyword or positional argument patterns "
"are present."
msgstr ""
"Если аргументы шаблона отсутствуют, шаблон выполняется успешно. В противном "
"случае последующие шаги зависят от того, присутствуют ли шаблоны ключевых "
"слов или позиционных аргументов."

#: ../../reference/compound_stmts.rst:1104
msgid ""
"For a number of built-in types (specified below), a single positional "
"subpattern is accepted which will match the entire subject; for these types "
"keyword patterns also work as for other types."
msgstr ""
"Для ряда встроенных типов (указанных ниже) принимается единый позиционный "
"подшаблон, который будет соответствовать всему предмету; для этих типов "
"шаблоны ключевых слов работают так же, как и для других типов."

#: ../../reference/compound_stmts.rst:1108
msgid ""
"If only keyword patterns are present, they are processed as follows, one by "
"one:"
msgstr ""
"Если присутствуют только шаблоны ключевых слов, они обрабатываются один за "
"другим следующим образом:"

#: ../../reference/compound_stmts.rst:1111
msgid "I. The keyword is looked up as an attribute on the subject."
msgstr "I. Ключевое слово рассматривается как атрибут предмета."

#: ../../reference/compound_stmts.rst:1113
msgid ""
"If this raises an exception other than :exc:`AttributeError`, the exception "
"bubbles up."
msgstr ""
"Если это вызывает исключение, отличное от :exc:`AttributeError`, исключение "
"всплывает."

#: ../../reference/compound_stmts.rst:1116
msgid "If this raises :exc:`AttributeError`, the class pattern has failed."
msgstr "Если это вызывает :exc:`AttributeError`, шаблон класса не выполнен."

#: ../../reference/compound_stmts.rst:1118
msgid ""
"Else, the subpattern associated with the keyword pattern is matched against "
"the subject's attribute value.  If this fails, the class pattern fails; if "
"this succeeds, the match proceeds to the next keyword."
msgstr ""
"В противном случае подшаблон, связанный с шаблоном ключевого слова, "
"сопоставляется со значением атрибута субъекта. Если это не удается, шаблон "
"класса терпит неудачу; если это удается, сопоставление переходит к "
"следующему ключевому слову."

#: ../../reference/compound_stmts.rst:1123
msgid "II. If all keyword patterns succeed, the class pattern succeeds."
msgstr "II. Если все шаблоны ключевых слов успешны, шаблон класса успешен."

#: ../../reference/compound_stmts.rst:1125
msgid ""
"If any positional patterns are present, they are converted to keyword "
"patterns using the :data:`~object.__match_args__` attribute on the class "
"``name_or_attr`` before matching:"
msgstr ""
"Если присутствуют какие-либо позиционные шаблоны, они преобразуются в "
"шаблоны ключевых слов с использованием атрибута :data:`~object."
"__match_args__` в классе ``name_or_attr`` перед сопоставлением:"

#: ../../reference/compound_stmts.rst:1129
msgid ""
"I. The equivalent of ``getattr(cls, \"__match_args__\", ())`` is called."
msgstr "I. Вызывается эквивалент ``getattr(cls, \"__match_args__\", ())``."

#: ../../reference/compound_stmts.rst:1131
msgid "If this raises an exception, the exception bubbles up."
msgstr "Если это вызывает исключение, оно всплывает."

#: ../../reference/compound_stmts.rst:1133
msgid ""
"If the returned value is not a tuple, the conversion fails and :exc:"
"`TypeError` is raised."
msgstr ""
"Если возвращаемое значение не является кортежем, преобразование завершается "
"неудачей и возникает ошибка :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1136
msgid ""
"If there are more positional patterns than ``len(cls.__match_args__)``, :exc:"
"`TypeError` is raised."
msgstr ""
"Если позиционных шаблонов больше, чем ``len(cls.__match_args__)``, "
"возникает :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1139
msgid ""
"Otherwise, positional pattern ``i`` is converted to a keyword pattern using "
"``__match_args__[i]`` as the keyword.  ``__match_args__[i]`` must be a "
"string; if not :exc:`TypeError` is raised."
msgstr ""
"В противном случае позиционный шаблон ``i`` преобразуется в шаблон ключевого "
"слова с использованием ``__match_args__[i]`` в качестве ключевого слова. "
"``__match_args__[i]`` должен быть строкой; если нет, то возникает :exc:"
"`TypeError`."

#: ../../reference/compound_stmts.rst:1143
msgid "If there are duplicate keywords, :exc:`TypeError` is raised."
msgstr "Если есть повторяющиеся ключевые слова, возникает :exc:`TypeError`."

#: ../../reference/compound_stmts.rst:1145
msgid ":ref:`class-pattern-matching`"
msgstr ":ref:`class-pattern-matching`"

#: ../../reference/compound_stmts.rst:1147
msgid ""
"II. Once all positional patterns have been converted to keyword patterns,"
msgstr ""
"II. После того как все позиционные шаблоны будут преобразованы в шаблоны "
"ключевых слов,"

#: ../../reference/compound_stmts.rst:1148
msgid "the match proceeds as if there were only keyword patterns."
msgstr ""
"сопоставление происходит так, как если бы существовали только шаблоны "
"ключевых слов."

#: ../../reference/compound_stmts.rst:1150
msgid ""
"For the following built-in types the handling of positional subpatterns is "
"different:"
msgstr ""
"Для следующих встроенных типов обработка позиционных подшаблонов отличается:"

#: ../../reference/compound_stmts.rst:1153
msgid ":class:`bool`"
msgstr ":class:`bool`"

#: ../../reference/compound_stmts.rst:1154
msgid ":class:`bytearray`"
msgstr ":class:`bytearray`"

#: ../../reference/compound_stmts.rst:1155
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../reference/compound_stmts.rst:1156
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../reference/compound_stmts.rst:1157
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../reference/compound_stmts.rst:1158
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../reference/compound_stmts.rst:1159
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../reference/compound_stmts.rst:1160
#: ../../reference/compound_stmts.rst:1865
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../reference/compound_stmts.rst:1161
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../reference/compound_stmts.rst:1162
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../reference/compound_stmts.rst:1163
#: ../../reference/compound_stmts.rst:1868
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../reference/compound_stmts.rst:1165
msgid ""
"These classes accept a single positional argument, and the pattern there is "
"matched against the whole object rather than an attribute. For example "
"``int(0|1)`` matches the value ``0``, but not the value ``0.0``."
msgstr ""
"Эти классы принимают один позиционный аргумент, и шаблон сопоставляется со "
"всем объектом, а не с атрибутом. Например, ``int(0|1)`` соответствует "
"значению ``0``, но не соответствует значению ``0.0``."

#: ../../reference/compound_stmts.rst:1169
msgid ""
"In simple terms ``CLS(P1, attr=P2)`` matches only if the following happens:"
msgstr ""
"Проще говоря, ``CLS(P1, attr=P2)`` соответствует только в том случае, если "
"происходит следующее:"

#: ../../reference/compound_stmts.rst:1171
msgid "``isinstance(<subject>, CLS)``"
msgstr "``isinstance(<subject>, CLS)``"

#: ../../reference/compound_stmts.rst:1172
msgid "convert ``P1`` to a keyword pattern using ``CLS.__match_args__``"
msgstr ""
"преобразовать ``P1`` в шаблон ключевого слова, используя ``CLS."
"__match_args__``"

#: ../../reference/compound_stmts.rst:1173
msgid "For each keyword argument ``attr=P2``:"
msgstr "Для каждого аргумента ключевого слова ``attr=P2``:"

#: ../../reference/compound_stmts.rst:1175
msgid "``hasattr(<subject>, \"attr\")``"
msgstr "``hasattr(<subject>, \"attr\")``"

#: ../../reference/compound_stmts.rst:1176
msgid "``P2`` matches ``<subject>.attr``"
msgstr "``P2`` соответствует ``<subject>.attr``"

#: ../../reference/compound_stmts.rst:1178
msgid "... and so on for the corresponding keyword argument/pattern pair."
msgstr ""
"... и так далее для соответствующей пары аргумент/шаблон ключевого слова."

#: ../../reference/compound_stmts.rst:1193
msgid "Function definitions"
msgstr "Определения функций"

#: ../../reference/compound_stmts.rst:1208
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Определение функции определяет определяемый пользователем объект функции "
"(см. раздел :ref:`types`):"

#: ../../reference/compound_stmts.rst:1230
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Определение функции — это исполняемый оператор. Его выполнение связывает имя "
"функции в текущем локальном пространстве имен с объектом функции (оберткой "
"исполняемого кода функции). Этот объект функции содержит ссылку на текущее "
"глобальное пространство имен как глобальное пространство имен, которое будет "
"использоваться при вызове функции."

#: ../../reference/compound_stmts.rst:1236
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"Определение функции не выполняет тело функции; это выполняется только при "
"вызове функции. [#]_"

#: ../../reference/compound_stmts.rst:1242
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Определение функции может быть заключено в одно или несколько выражений :"
"term:`decorator`. Выражения декоратора оцениваются при определении функции в "
"области, содержащей определение функции. Результатом должен быть вызываемый "
"объект, который вызывается с объектом функции в качестве единственного "
"аргумента. Возвращаемое значение привязано к имени функции, а не к объекту "
"функции. Несколько декораторов применяются вложенным образом. Например, "
"следующий код:::"

#: ../../reference/compound_stmts.rst:1249
msgid ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"def func(): pass"

#: ../../reference/compound_stmts.rst:1253
#: ../../reference/compound_stmts.rst:1448
msgid "is roughly equivalent to ::"
msgstr "примерно эквивалентно::"

#: ../../reference/compound_stmts.rst:1255
msgid ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"
msgstr ""
"def func(): pass\n"
"func = f1(arg)(f2(func))"

#: ../../reference/compound_stmts.rst:1258
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"за исключением того, что исходная функция временно не привязана к имени func."

#: ../../reference/compound_stmts.rst:1260
msgid ""
"Functions may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Функции могут быть украшены любым допустимым :token:`~python-grammar:"
"assignment_expression`. Раньше грамматика была гораздо более строгой; "
"подробности см. в :pep:`614`."

#: ../../reference/compound_stmts.rst:1265
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets between the function's name and the opening parenthesis for its "
"parameter list. This indicates to static type checkers that the function is "
"generic. At runtime, the type parameters can be retrieved from the "
"function's :attr:`~function.__type_params__` attribute. See :ref:`generic-"
"functions` for more."
msgstr ""
"Список :ref:`параметров типа <type-params>` может быть указан в квадратных "
"скобках между именем функции и открывающей скобкой для ее списка параметров. "
"Это указывает средствам проверки статического типа, что функция является "
"универсальной. Во время выполнения параметры типа можно получить из "
"атрибута :attr:`~function.__type_params__` функции. Дополнительную "
"информацию см. в разделе :ref:`generic-functions`."

#: ../../reference/compound_stmts.rst:1272
#: ../../reference/compound_stmts.rst:1467
msgid "Type parameter lists are new in Python 3.12."
msgstr "Списки параметров типа появились в Python 3.12."

#: ../../reference/compound_stmts.rst:1280
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Когда один или несколько :term:`parameters <parameter>` имеют форму "
"*parameter* ``=`` *expression*, говорят, что функция имеет «значения "
"параметров по умолчанию». Для параметра со значением по умолчанию "
"соответствующий :term:`argument` может быть опущен при вызове, и в этом "
"случае заменяется значение параметра по умолчанию. Если параметр имеет "
"значение по умолчанию, все последующие параметры до «``*``» также должны "
"иметь значение по умолчанию — это синтаксическое ограничение, не выраженное "
"грамматикой."

#: ../../reference/compound_stmts.rst:1288
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter value is a mutable object, such as a "
"list or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default parameter value is in effect modified.  This "
"is generally not what was intended.  A way around this is to use ``None`` as "
"the default, and explicitly test for it in the body of the function, e.g.::"
msgstr ""
"**Значения параметров по умолчанию оцениваются слева направо при выполнении "
"определения функции.** Это означает, что выражение вычисляется один раз при "
"определении функции и что для каждого вызова используется одно и то же "
"«предварительно вычисленное» значение. . Это особенно важно понимать, когда "
"значение параметра по умолчанию является изменяемым объектом, таким как "
"список или словарь: если функция изменяет объект (например, добавляя элемент "
"в список), значение параметра по умолчанию фактически изменяется. Это вообще "
"не то, что было задумано. Чтобы обойти эту проблему, используйте None по "
"умолчанию и явно проверяйте его в теле функции, например::"

#: ../../reference/compound_stmts.rst:1298
msgid ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"
msgstr ""
"def whats_on_the_telly(penguin=None):\n"
"    if penguin is None:\n"
"        penguin = []\n"
"    penguin.append(\"property of the zoo\")\n"
"    return penguin"

#: ../../reference/compound_stmts.rst:1309
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"Семантика вызова функций более подробно описана в разделе :ref:`calls`. "
"Вызов функции всегда присваивает значения всем параметрам, упомянутым в "
"списке параметров, либо из позиционных аргументов, либо из аргументов "
"ключевого слова, либо из значений по умолчанию. Если присутствует форма "
"«``*identifier``», она инициализируется кортежем, получающим любые лишние "
"позиционные параметры, по умолчанию используется пустой кортеж. Если "
"присутствует форма «``**идентификатор``», она инициализируется новым "
"упорядоченным сопоставлением, получающим любые лишние аргументы ключевого "
"слова, по умолчанию используется новое пустое сопоставление того же типа. "
"Параметры после «``*``» или «``*identifier``» являются параметрами только "
"для ключевых слов и могут передаваться только в виде аргументов ключевого "
"слова. Параметры перед «``/``» являются только позиционными параметрами и "
"могут передаваться только как позиционные аргументы."

#: ../../reference/compound_stmts.rst:1321
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"Синтаксис параметра функции ``/`` может использоваться для указания только "
"позиционных параметров. Подробности смотрите в :pep:`570`."

#: ../../reference/compound_stmts.rst:1330
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``. "
"(As a special case, parameters of the form ``*identifier`` may have an "
"annotation \"``: *expression``\".) Functions may have \"return\" annotation "
"of the form \"``-> expression``\" after the parameter list.  These "
"annotations can be any valid Python expression.  The presence of annotations "
"does not change the semantics of a function.  The annotation values are "
"available as values of a dictionary keyed by the parameters' names in the :"
"attr:`__annotations__` attribute of the function object.  If the "
"``annotations`` import from :mod:`__future__` is used, annotations are "
"preserved as strings at runtime which enables postponed evaluation.  "
"Otherwise, they are evaluated when the function definition is executed.  In "
"this case annotations may be evaluated in a different order than they appear "
"in the source code."
msgstr ""
"Параметры могут иметь :term:`annotation <function annotation>` в форме \"``: "
"выражение``\" после имени параметра. Любой параметр может иметь аннотацию, "
"даже в форме ``*identifier`` или ``**identifier``. (В особом случае "
"параметры формы ``*identifier`` могут иметь аннотацию \"``: "
"*expression``\".) Функции могут иметь аннотацию \"возврата\" в форме \"``-"
">expression``\" после списка параметров. Эти аннотации могут быть любым "
"допустимым выражением Python. Наличие аннотаций не меняет семантику функции. "
"Значения аннотаций доступны как значения словаря, основанного на именах "
"параметров в атрибуте :attr:`__annotations__` объекта функции. Если "
"используется импорт ``аннотаций`` из :mod:`__future__`, аннотации "
"сохраняются в виде строк во время выполнения, что позволяет отложить оценку. "
"В противном случае они оцениваются при выполнении определения функции. В "
"этом случае аннотации могут оцениваться в другом порядке, чем они "
"представлены в исходном коде."

#: ../../reference/compound_stmts.rst:1344
msgid ""
"Parameters of the form \"``*identifier``\" may have an annotation \"``: "
"*expression``\". See :pep:`646`."
msgstr ""
"Параметры формы «``*идентификатор``» могут иметь аннотацию «``: "
"*expression``». См. :pep:`646`."

#: ../../reference/compound_stmts.rst:1350
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Также возможно создавать анонимные функции (функции, не привязанные к имени) "
"для немедленного использования в выражениях. При этом используются лямбда-"
"выражения, описанные в разделе :ref:`lambda`. Обратите внимание, что лямбда-"
"выражение — это просто сокращение для упрощенного определения функции; "
"функцию, определенную в операторе «:keyword:`def`», можно передать или "
"присвоить другому имени точно так же, как функцию, определенную лямбда-"
"выражением. Форма «:keyword:`!def`» на самом деле более мощная, поскольку "
"позволяет выполнять несколько операторов и аннотаций."

#: ../../reference/compound_stmts.rst:1358
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Примечание программиста:** Функции являются объектами первого класса. "
"Оператор «def», выполняемый внутри определения функции, определяет локальную "
"функцию, которая может быть возвращена или передана. Свободные переменные, "
"используемые во вложенной функции, могут иметь доступ к локальным переменным "
"функции, содержащей определение. Подробности смотрите в разделе :ref:"
"`nameing`."

#: ../../reference/compound_stmts.rst:1366
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Аннотации к функциям"

#: ../../reference/compound_stmts.rst:1367
msgid "The original specification for function annotations."
msgstr "Исходная спецификация аннотаций функций."

#: ../../reference/compound_stmts.rst:1369
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Тип подсказка"

#: ../../reference/compound_stmts.rst:1370
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "Определение стандартного значения аннотаций: подсказки типов."

#: ../../reference/compound_stmts.rst:1372
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Синтаксис аннотаций переменных"

#: ../../reference/compound_stmts.rst:1373
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables."
msgstr ""
"Возможность вводить объявления переменных-подсказок, включая переменные "
"класса и переменные экземпляра."

#: ../../reference/compound_stmts.rst:1376
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Отложенная оценка аннотаций"

#: ../../reference/compound_stmts.rst:1377
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Поддержка прямых ссылок внутри аннотаций за счет сохранения аннотаций в "
"строковой форме во время выполнения вместо быстрого вычисления."

#: ../../reference/compound_stmts.rst:1380
msgid ":pep:`318` - Decorators for Functions and Methods"
msgstr ":pep:`318` - Декораторы для функций и методов"

#: ../../reference/compound_stmts.rst:1381
msgid ""
"Function and method decorators were introduced. Class decorators were "
"introduced in :pep:`3129`."
msgstr ""
"Были представлены декораторы функций и методов. Декораторы классов были "
"представлены в :pep:`3129`."

#: ../../reference/compound_stmts.rst:1387
msgid "Class definitions"
msgstr "Определения классов"

#: ../../reference/compound_stmts.rst:1402
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "Определение класса определяет объект класса (см. раздел :ref:`types`):"

#: ../../reference/compound_stmts.rst:1409
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Определение класса — это исполняемый оператор. Список наследования обычно "
"представляет собой список базовых классов (см. :ref:`metaclasses` для более "
"продвинутого использования), поэтому каждый элемент в списке должен "
"оцениваться как объект класса, который допускает создание подклассов. Классы "
"без списка наследования по умолчанию наследуются от базового класса :class:"
"`object`; следовательно, ::"

#: ../../reference/compound_stmts.rst:1415
msgid ""
"class Foo:\n"
"    pass"
msgstr ""
"class Foo:\n"
"    pass"

#: ../../reference/compound_stmts.rst:1418
msgid "is equivalent to ::"
msgstr "эквивалентно::"

#: ../../reference/compound_stmts.rst:1420
msgid ""
"class Foo(object):\n"
"    pass"
msgstr ""
"class Foo(object):\n"
"    pass"

#: ../../reference/compound_stmts.rst:1423
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"Затем набор класса выполняется в новом фрейме выполнения (см. :ref:"
"`naming`), используя вновь созданное локальное пространство имен и исходное "
"глобальное пространство имен. (Обычно набор содержит в основном определения "
"функций.) Когда набор класса завершает выполнение, его кадр выполнения "
"отбрасывается, но его локальное пространство имен сохраняется. [#]_ Затем "
"создается объект класса с использованием списка наследования базовых классов "
"и сохраненного локального пространства имен для словаря атрибутов. Имя "
"класса привязано к этому объекту класса в исходном локальном пространстве "
"имен."

#: ../../reference/compound_stmts.rst:1432
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's :attr:`~type.__dict__`.  Note that this is reliable only "
"right after the class is created and only for classes that were defined "
"using the definition syntax."
msgstr ""
"Порядок определения атрибутов в теле класса сохраняется в :attr:`~type."
"__dict__` нового класса. Обратите внимание, что это надежно только сразу "
"после создания класса и только для классов, которые были определены с "
"использованием синтаксиса определения."

#: ../../reference/compound_stmts.rst:1437
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"Создание классов можно сильно настроить с помощью :ref:`metaclasses "
"<metaclasses>`."

#: ../../reference/compound_stmts.rst:1442
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""
"Классы также можно декорировать: так же, как и при декорировании функций::"

#: ../../reference/compound_stmts.rst:1444
msgid ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"
msgstr ""
"@f1(arg)\n"
"@f2\n"
"class Foo: pass"

#: ../../reference/compound_stmts.rst:1450
msgid ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"
msgstr ""
"class Foo: pass\n"
"Foo = f1(arg)(f2(Foo))"

#: ../../reference/compound_stmts.rst:1453
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Правила вычисления выражений декораторов такие же, как и для декораторов "
"функций. Результат затем привязывается к имени класса."

#: ../../reference/compound_stmts.rst:1456
msgid ""
"Classes may be decorated with any valid :token:`~python-grammar:"
"assignment_expression`. Previously, the grammar was much more restrictive; "
"see :pep:`614` for details."
msgstr ""
"Классы могут быть украшены любым допустимым :token:`~python-grammar:"
"assignment_expression`. Раньше грамматика была гораздо более строгой; "
"подробности см. в :pep:`614`."

#: ../../reference/compound_stmts.rst:1461
msgid ""
"A list of :ref:`type parameters <type-params>` may be given in square "
"brackets immediately after the class's name. This indicates to static type "
"checkers that the class is generic. At runtime, the type parameters can be "
"retrieved from the class's :attr:`~type.__type_params__` attribute. See :ref:"
"`generic-classes` for more."
msgstr ""
"Список :ref:`параметров типа <type-params>` может быть указан в квадратных "
"скобках сразу после имени класса. Это указывает средствам проверки "
"статического типа, что класс является универсальным. Во время выполнения "
"параметры типа можно получить из атрибута :attr:`~type.__type_params__` "
"класса. Дополнительную информацию см. в разделе :ref:`generic-classes`."

#: ../../reference/compound_stmts.rst:1470
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Примечание программиста:** Переменные, определенные в определении класса, "
"являются атрибутами класса; они разделяются экземплярами. Атрибуты "
"экземпляра могут быть установлены в методе с помощью ``self.name = value``. "
"Атрибуты класса и экземпляра доступны через обозначение «self.name», а "
"атрибут экземпляра скрывает атрибут класса с тем же именем при доступе таким "
"способом. Атрибуты класса можно использовать в качестве значений по "
"умолчанию для атрибутов экземпляра, но использование изменяемых значений "
"может привести к неожиданным результатам. :ref:`Descriptors <descriptors>` "
"можно использовать для создания переменных экземпляра с различными деталями "
"реализации."

#: ../../reference/compound_stmts.rst:1482
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метаклассы в Python 3000"

#: ../../reference/compound_stmts.rst:1483
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"Предложение, которое изменило объявление метаклассов на текущий синтаксис, а "
"также семантику построения классов с метаклассами."

#: ../../reference/compound_stmts.rst:1487
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Декораторы классов"

#: ../../reference/compound_stmts.rst:1488
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"Предложение по добавлению декораторов классов. Декораторы функций и методов "
"были представлены в :pep:`318`."

#: ../../reference/compound_stmts.rst:1495
msgid "Coroutines"
msgstr "Сопрограммы"

#: ../../reference/compound_stmts.rst:1503
msgid "Coroutine function definition"
msgstr "Определение функции сопрограммы"

#: ../../reference/compound_stmts.rst:1513
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`). :keyword:`await` expressions, :keyword:`async for` "
"and :keyword:`async with` can only be used in the body of a coroutine "
"function."
msgstr ""
"Выполнение сопрограмм Python можно приостановить и возобновить во многих "
"моментах (см. :term:`coroutine`). Выражения :keyword:`await`, :keyword:"
"`async for` и :keyword:`async with` можно использовать только в теле функции "
"сопрограммы."

#: ../../reference/compound_stmts.rst:1517
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."

#: ../../reference/compound_stmts.rst:1520
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Использование выражения \"yield from\" внутри тела сопрограммной функции "
"является синтаксической ошибкой."

#: ../../reference/compound_stmts.rst:1523
msgid "An example of a coroutine function::"
msgstr "Пример функции-сопрограммы::"

#: ../../reference/compound_stmts.rst:1525
msgid ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"
msgstr ""
"async def func(param1, param2):\n"
"    do_stuff()\n"
"    await some_coroutine()"

#: ../../reference/compound_stmts.rst:1529
msgid ""
"``await`` and ``async`` are now keywords; previously they were only treated "
"as such inside the body of a coroutine function."
msgstr ""
"``await`` и ``async`` теперь являются ключевыми словами; ранее они "
"рассматривались как таковые только внутри тела функции сопрограммы."

#: ../../reference/compound_stmts.rst:1537
msgid "The :keyword:`!async for` statement"
msgstr "Оператор :keyword:`!async for`"

#: ../../reference/compound_stmts.rst:1542
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`asynchronous iterable` предоставляет метод ``__aiter__``, который "
"напрямую возвращает :term:`асинхронный итератор`, который может вызывать "
"асинхронный код в своем методе ``__anext__``."

#: ../../reference/compound_stmts.rst:1546
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"Оператор ``async for`` позволяет удобно перебирать асинхронные итерации."

#: ../../reference/compound_stmts.rst:1551
msgid ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"async for TARGET in ITER:\n"
"    SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1556
msgid "Is semantically equivalent to::"
msgstr "Семантически эквивалентен::"

#: ../../reference/compound_stmts.rst:1558
msgid ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"
msgstr ""
"iter = (ITER)\n"
"iter = type(iter).__aiter__(iter)\n"
"running = True\n"
"\n"
"while running:\n"
"    try:\n"
"        TARGET = await type(iter).__anext__(iter)\n"
"    except StopAsyncIteration:\n"
"        running = False\n"
"    else:\n"
"        SUITE\n"
"else:\n"
"    SUITE2"

#: ../../reference/compound_stmts.rst:1572
msgid ""
"See also :meth:`~object.__aiter__` and :meth:`~object.__anext__` for details."
msgstr ""
"Подробности смотрите также в :meth:`~object.__aiter__` и :meth:`~object."
"__anext__`."

#: ../../reference/compound_stmts.rst:1574
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Использование оператора async for вне тела функции сопрограммы является "
"синтаксической ошибкой."

#: ../../reference/compound_stmts.rst:1582
msgid "The :keyword:`!async with` statement"
msgstr "Оператор :keyword:`!async with`"

#: ../../reference/compound_stmts.rst:1587
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`асинхронный контекстный менеджер` — это :term:`контекстный менеджер`, "
"который может приостанавливать выполнение в своих методах *enter* и *exit*."

#: ../../reference/compound_stmts.rst:1592
msgid ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"
msgstr ""
"async with EXPRESSION as TARGET:\n"
"    SUITE"

#: ../../reference/compound_stmts.rst:1597
msgid ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"
msgstr ""
"manager = (EXPRESSION)\n"
"aenter = type(manager).__aenter__\n"
"aexit = type(manager).__aexit__\n"
"value = await aenter(manager)\n"
"hit_except = False\n"
"\n"
"try:\n"
"    TARGET = value\n"
"    SUITE\n"
"except:\n"
"    hit_except = True\n"
"    if not await aexit(manager, *sys.exc_info()):\n"
"        raise\n"
"finally:\n"
"    if not hit_except:\n"
"        await aexit(manager, None, None, None)"

#: ../../reference/compound_stmts.rst:1614
msgid ""
"See also :meth:`~object.__aenter__` and :meth:`~object.__aexit__` for "
"details."
msgstr ""
"Подробности смотрите также в :meth:`~object.__aenter__` и :meth:`~object."
"__aexit__`."

#: ../../reference/compound_stmts.rst:1616
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Использование оператора async with вне тела функции сопрограммы является "
"синтаксической ошибкой."

#: ../../reference/compound_stmts.rst:1621
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Сопрограммы с синтаксисом async и await"

#: ../../reference/compound_stmts.rst:1622
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"Предложение, которое сделало сопрограммы отдельной концепцией в Python и "
"добавило вспомогательный синтаксис."

#: ../../reference/compound_stmts.rst:1628
msgid "Type parameter lists"
msgstr "Списки параметров типа"

#: ../../reference/compound_stmts.rst:1642
msgid ""
":ref:`Functions <def>` (including :ref:`coroutines <async def>`), :ref:"
"`classes <class>` and :ref:`type aliases <type>` may contain a type "
"parameter list::"
msgstr ""
":ref:`Функции <def>` (включая :ref:`coroutines <async def>`), :ref:`classes "
"<class>` и :ref:`type aliases <type>` могут содержать список параметров "
"типа: :"

#: ../../reference/compound_stmts.rst:1646
msgid ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"
msgstr ""
"def max[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"async def amax[T](args: list[T]) -> T:\n"
"    ...\n"
"\n"
"class Bag[T]:\n"
"    def __iter__(self) -> Iterator[T]:\n"
"        ...\n"
"\n"
"    def add(self, arg: T) -> None:\n"
"        ...\n"
"\n"
"type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1661
msgid ""
"Semantically, this indicates that the function, class, or type alias is "
"generic over a type variable. This information is primarily used by static "
"type checkers, and at runtime, generic objects behave much like their non-"
"generic counterparts."
msgstr ""
"Семантически это указывает на то, что функция, класс или псевдоним типа "
"являются универсальными для переменной типа. Эта информация в основном "
"используется средствами проверки статических типов, и во время выполнения "
"универсальные объекты ведут себя так же, как их неуниверсальные аналоги."

#: ../../reference/compound_stmts.rst:1666
msgid ""
"Type parameters are declared in square brackets (``[]``) immediately after "
"the name of the function, class, or type alias. The type parameters are "
"accessible within the scope of the generic object, but not elsewhere. Thus, "
"after a declaration ``def func[T](): pass``, the name ``T`` is not available "
"in the module scope. Below, the semantics of generic objects are described "
"with more precision. The scope of type parameters is modeled with a special "
"function (technically, an :ref:`annotation scope <annotation-scopes>`) that "
"wraps the creation of the generic object."
msgstr ""
"Параметры типа объявляются в квадратных скобках (``[]``) сразу после имени "
"функции, класса или псевдонима типа. Параметры типа доступны в пределах "
"универсального объекта, но не где-либо еще. Таким образом, после объявления "
"``def func[T](): pass`` имя ``T`` недоступно в области видимости модуля. "
"Ниже семантика родовых объектов описана более точно. Область действия "
"параметров типа моделируется с помощью специальной функции (технически это :"
"ref:`область аннотации <annotation-scopes>`), которая завершает создание "
"универсального объекта."

#: ../../reference/compound_stmts.rst:1675
msgid ""
"Generic functions, classes, and type aliases have a :attr:`~definition."
"__type_params__` attribute listing their type parameters."
msgstr ""
"Универсальные функции, классы и псевдонимы типов имеют атрибут :attr:"
"`~definition.__type_params__`, в котором перечислены их параметры типа."

#: ../../reference/compound_stmts.rst:1678
msgid "Type parameters come in three kinds:"
msgstr "Параметры типа бывают трех видов:"

#: ../../reference/compound_stmts.rst:1680
msgid ""
":data:`typing.TypeVar`, introduced by a plain name (e.g., ``T``). "
"Semantically, this represents a single type to a type checker."
msgstr ""
":data:`typing.TypeVar`, представленный простым именем (например, ``T``). "
"Семантически это представляет один тип для средства проверки типов."

#: ../../reference/compound_stmts.rst:1682
msgid ""
":data:`typing.TypeVarTuple`, introduced by a name prefixed with a single "
"asterisk (e.g., ``*Ts``). Semantically, this stands for a tuple of any "
"number of types."
msgstr ""
":data:`typing.TypeVarTuple`, представленный именем с префиксом одной "
"звездочки (например, ``*Ts``). Семантически это означает кортеж любого "
"количества типов."

#: ../../reference/compound_stmts.rst:1685
msgid ""
":data:`typing.ParamSpec`, introduced by a name prefixed with two asterisks "
"(e.g., ``**P``). Semantically, this stands for the parameters of a callable."
msgstr ""
":data:`typing.ParamSpec`, представленный именем с префиксом двух звездочек "
"(например, ``**P``). Семантически это означает параметры вызываемого объекта."

#: ../../reference/compound_stmts.rst:1688
msgid ""
":data:`typing.TypeVar` declarations can define *bounds* and *constraints* "
"with a colon (``:``) followed by an expression. A single expression after "
"the colon indicates a bound (e.g. ``T: int``). Semantically, this means that "
"the :data:`!typing.TypeVar` can only represent types that are a subtype of "
"this bound. A parenthesized tuple of expressions after the colon indicates a "
"set of constraints (e.g. ``T: (str, bytes)``). Each member of the tuple "
"should be a type (again, this is not enforced at runtime). Constrained type "
"variables can only take on one of the types in the list of constraints."
msgstr ""
"Объявления :data:`typing.TypeVar` могут определять *bounds* и *constraints* "
"с помощью двоеточия (``:``), за которым следует выражение. Одиночное "
"выражение после двоеточия указывает на границу (например, ``T: int``). "
"Семантически это означает, что :data:`!typing.TypeVar` может представлять "
"только типы, которые являются подтипом этой границы. Кортеж выражений в "
"скобках после двоеточия указывает на набор ограничений (например, ``T: (str, "
"bytes)``). Каждый член кортежа должен быть типом (опять же, это не "
"обязательно во время выполнения). Переменные ограниченного типа могут "
"принимать только один из типов в списке ограничений."

#: ../../reference/compound_stmts.rst:1697
msgid ""
"For :data:`!typing.TypeVar`\\ s declared using the type parameter list "
"syntax, the bound and constraints are not evaluated when the generic object "
"is created, but only when the value is explicitly accessed through the "
"attributes ``__bound__`` and ``__constraints__``. To accomplish this, the "
"bounds or constraints are evaluated in a separate :ref:`annotation scope "
"<annotation-scopes>`."
msgstr ""
"Для :data:`!typing.TypeVar`\\, объявленных с использованием синтаксиса "
"списка параметров типа, привязка и ограничения не оцениваются при создании "
"универсального объекта, а только тогда, когда к значению осуществляется "
"явный доступ через атрибуты ``__bound__`` и ``__constraints__``. Для этого "
"границы или ограничения оцениваются в отдельной области аннотации "
"<annotation-scopes>`."

#: ../../reference/compound_stmts.rst:1703
msgid ""
":data:`typing.TypeVarTuple`\\ s and :data:`typing.ParamSpec`\\ s cannot have "
"bounds or constraints."
msgstr ""
":data:`typing.TypeVarTuple`\\ и :data:`typing.ParamSpec`\\ s не могут иметь "
"границ или ограничений."

#: ../../reference/compound_stmts.rst:1706
msgid ""
"The following example indicates the full set of allowed type parameter "
"declarations::"
msgstr ""
"В следующем примере показан полный набор разрешенных объявлений параметров "
"типа:"

#: ../../reference/compound_stmts.rst:1708
msgid ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple,\n"
"   **SimpleParamSpec,\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithBound,\n"
"   c: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *d: SimpleTypeVarTuple,\n"
"): ..."
msgstr ""
"def overly_generic[\n"
"   SimpleTypeVar,\n"
"   TypeVarWithBound: int,\n"
"   TypeVarWithConstraints: (str, bytes),\n"
"   *SimpleTypeVarTuple,\n"
"   **SimpleParamSpec,\n"
"](\n"
"   a: SimpleTypeVar,\n"
"   b: TypeVarWithBound,\n"
"   c: Callable[SimpleParamSpec, TypeVarWithConstraints],\n"
"   *d: SimpleTypeVarTuple,\n"
"): ..."

#: ../../reference/compound_stmts.rst:1724
msgid "Generic functions"
msgstr "Общие функции"

#: ../../reference/compound_stmts.rst:1726
msgid "Generic functions are declared as follows::"
msgstr "Общие функции объявляются следующим образом:"

#: ../../reference/compound_stmts.rst:1728
msgid "def func[T](arg: T): ..."
msgstr "def func[T](arg: T): ..."

#: ../../reference/compound_stmts.rst:1730
#: ../../reference/compound_stmts.rst:1790
msgid "This syntax is equivalent to::"
msgstr "Общие функции объявляются следующим образом:"

#: ../../reference/compound_stmts.rst:1732
msgid ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_func():\n"
"    T = typing.TypeVar(\"T\")\n"
"    def func(arg: T): ...\n"
"    func.__type_params__ = (T,)\n"
"    return func\n"
"func = TYPE_PARAMS_OF_func()"

#: ../../reference/compound_stmts.rst:1739
msgid ""
"Here ``annotation-def`` indicates an :ref:`annotation scope <annotation-"
"scopes>`, which is not actually bound to any name at runtime. (One other "
"liberty is taken in the translation: the syntax does not go through "
"attribute access on the :mod:`typing` module, but creates an instance of :"
"data:`typing.TypeVar` directly.)"
msgstr ""
"Здесь ``annotation-def`` указывает область аннотации <annotation-scopes>`, "
"которая фактически не привязана ни к какому имени во время выполнения. (При "
"переводе использована еще одна вольность: синтаксис не использует доступ к "
"атрибутам в модуле :mod:`typing`, а создает экземпляр :data:`typing.TypeVar` "
"напрямую.)"

#: ../../reference/compound_stmts.rst:1745
msgid ""
"The annotations of generic functions are evaluated within the annotation "
"scope used for declaring the type parameters, but the function's defaults "
"and decorators are not."
msgstr ""
"Аннотации универсальных функций оцениваются в области аннотаций, "
"используемой для объявления параметров типа, но значения по умолчанию и "
"декораторы функции — нет."

#: ../../reference/compound_stmts.rst:1749
msgid ""
"The following example illustrates the scoping rules for these cases, as well "
"as for additional flavors of type parameters::"
msgstr ""
"Следующий пример иллюстрирует правила области действия для этих случаев, а "
"также для дополнительных разновидностей параметров типа:"

#: ../../reference/compound_stmts.rst:1752
msgid ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."
msgstr ""
"@decorator\n"
"def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):\n"
"    ..."

#: ../../reference/compound_stmts.rst:1756
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the :class:"
"`~typing.TypeVar` bound, this is equivalent to::"
msgstr ""
"За исключением :ref:`ленивой оценки <lazy-evaluation>` привязки :class:"
"`~typing.TypeVar`, это эквивалентно::"

#: ../../reference/compound_stmts.rst:1759
msgid ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"
msgstr ""
"DEFAULT_OF_arg = some_default\n"
"\n"
"annotation-def TYPE_PARAMS_OF_func():\n"
"\n"
"    annotation-def BOUND_OF_T():\n"
"        return int\n"
"    # In reality, BOUND_OF_T() is evaluated only on demand.\n"
"    T = typing.TypeVar(\"T\", bound=BOUND_OF_T())\n"
"\n"
"    Ts = typing.TypeVarTuple(\"Ts\")\n"
"    P = typing.ParamSpec(\"P\")\n"
"\n"
"    def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):\n"
"        ...\n"
"\n"
"    func.__type_params__ = (T, Ts, P)\n"
"    return func\n"
"func = decorator(TYPE_PARAMS_OF_func())"

#: ../../reference/compound_stmts.rst:1778
msgid ""
"The capitalized names like ``DEFAULT_OF_arg`` are not actually bound at "
"runtime."
msgstr ""
"Имена с заглавной буквы, такие как DEFAULT_OF_arg, фактически не "
"привязываются во время выполнения."

#: ../../reference/compound_stmts.rst:1784
msgid "Generic classes"
msgstr "Общие классы"

#: ../../reference/compound_stmts.rst:1786
msgid "Generic classes are declared as follows::"
msgstr "Общие классы объявляются следующим образом:"

#: ../../reference/compound_stmts.rst:1788
msgid "class Bag[T]: ..."
msgstr "class Bag[T]: ..."

#: ../../reference/compound_stmts.rst:1792
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(typing.Generic[T]):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = TYPE_PARAMS_OF_Bag()"

#: ../../reference/compound_stmts.rst:1800
msgid ""
"Here again ``annotation-def`` (not a real keyword) indicates an :ref:"
"`annotation scope <annotation-scopes>`, and the name ``TYPE_PARAMS_OF_Bag`` "
"is not actually bound at runtime."
msgstr ""
"Здесь снова ``annotation-def`` (не настоящее ключевое слово) указывает :ref:"
"`область аннотации <annotation-scopes>`, а имя ``TYPE_PARAMS_OF_Bag`` "
"фактически не привязано во время выполнения."

#: ../../reference/compound_stmts.rst:1804
msgid ""
"Generic classes implicitly inherit from :data:`typing.Generic`. The base "
"classes and keyword arguments of generic classes are evaluated within the "
"type scope for the type parameters, and decorators are evaluated outside "
"that scope. This is illustrated by this example::"
msgstr ""
"Универсальные классы неявно наследуются от :data:`typing.Generic`. Базовые "
"классы и аргументы ключевых слов универсальных классов оцениваются в области "
"типа для параметров типа, а декораторы оцениваются за пределами этой "
"области. Это иллюстрируется этим примером:"

#: ../../reference/compound_stmts.rst:1810
msgid ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."
msgstr ""
"@decorator\n"
"class Bag(Base[T], arg=T): ..."

#: ../../reference/compound_stmts.rst:1813
msgid "This is equivalent to::"
msgstr "Это эквивалентно::"

#: ../../reference/compound_stmts.rst:1815
msgid ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"
msgstr ""
"annotation-def TYPE_PARAMS_OF_Bag():\n"
"    T = typing.TypeVar(\"T\")\n"
"    class Bag(Base[T], typing.Generic[T], arg=T):\n"
"        __type_params__ = (T,)\n"
"        ...\n"
"    return Bag\n"
"Bag = decorator(TYPE_PARAMS_OF_Bag())"

#: ../../reference/compound_stmts.rst:1826
msgid "Generic type aliases"
msgstr "Псевдонимы общих типов"

#: ../../reference/compound_stmts.rst:1828
msgid ""
"The :keyword:`type` statement can also be used to create a generic type "
"alias::"
msgstr ""
"Оператор :keyword:`type` также можно использовать для создания псевдонима "
"универсального типа::"

#: ../../reference/compound_stmts.rst:1830
msgid "type ListOrSet[T] = list[T] | set[T]"
msgstr "type ListOrSet[T] = list[T] | set[T]"

#: ../../reference/compound_stmts.rst:1832
msgid ""
"Except for the :ref:`lazy evaluation <lazy-evaluation>` of the value, this "
"is equivalent to::"
msgstr ""
"За исключением :ref:`ленивой оценки <lazy-evaluation>` значения, это "
"эквивалентно::"

#: ../../reference/compound_stmts.rst:1835
msgid ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"
msgstr ""
"annotation-def TYPE_PARAMS_OF_ListOrSet():\n"
"    T = typing.TypeVar(\"T\")\n"
"\n"
"    annotation-def VALUE_OF_ListOrSet():\n"
"        return list[T] | set[T]\n"
"    # In reality, the value is lazily evaluated\n"
"    return typing.TypeAliasType(\"ListOrSet\", VALUE_OF_ListOrSet(), "
"type_params=(T,))\n"
"ListOrSet = TYPE_PARAMS_OF_ListOrSet()"

#: ../../reference/compound_stmts.rst:1844
msgid ""
"Here, ``annotation-def`` (not a real keyword) indicates an :ref:`annotation "
"scope <annotation-scopes>`. The capitalized names like "
"``TYPE_PARAMS_OF_ListOrSet`` are not actually bound at runtime."
msgstr ""
"Здесь ``annotation-def`` (не настоящее ключевое слово) указывает :ref:"
"`область аннотации <annotation-scopes>`. Имена с заглавной буквы, такие как "
"TYPE_PARAMS_OF_ListOrSet, фактически не привязываются во время выполнения."

#: ../../reference/compound_stmts.rst:1849
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/compound_stmts.rst:1850
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"Исключение распространяется на стек вызовов, если только не существует "
"предложения :keyword:`finally`, которое вызывает другое исключение. Это "
"новое исключение приводит к потере старого."

#: ../../reference/compound_stmts.rst:1854
msgid "In pattern matching, a sequence is defined as one of the following:"
msgstr ""
"При сопоставлении с образцом последовательность определяется как одно из "
"следующих:"

#: ../../reference/compound_stmts.rst:1856
msgid "a class that inherits from :class:`collections.abc.Sequence`"
msgstr "класс, который наследуется от :class:`collections.abc.Sequence`"

#: ../../reference/compound_stmts.rst:1857
msgid ""
"a Python class that has been registered as :class:`collections.abc.Sequence`"
msgstr "класс Python, зарегистрированный как :class:`collections.abc.Sequence`"

#: ../../reference/compound_stmts.rst:1858
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit set"
msgstr ""
"встроенный класс, у которого установлен бит (CPython) :c:macro:"
"`Py_TPFLAGS_SEQUENCE`"

#: ../../reference/compound_stmts.rst:1859
#: ../../reference/compound_stmts.rst:1878
msgid "a class that inherits from any of the above"
msgstr "класс, который наследуется от любого из вышеперечисленных"

#: ../../reference/compound_stmts.rst:1861
msgid "The following standard library classes are sequences:"
msgstr "Следующие классы стандартной библиотеки являются последовательностями:"

#: ../../reference/compound_stmts.rst:1863
msgid ":class:`array.array`"
msgstr ":class:`array.array`"

#: ../../reference/compound_stmts.rst:1864
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../reference/compound_stmts.rst:1866
msgid ":class:`memoryview`"
msgstr ":class:`memoryview`"

#: ../../reference/compound_stmts.rst:1867
msgid ":class:`range`"
msgstr ":class:`range`"

#: ../../reference/compound_stmts.rst:1870
msgid ""
"Subject values of type ``str``, ``bytes``, and ``bytearray`` do not match "
"sequence patterns."
msgstr ""
"Значения субъектов типа ``str``, ``bytes`` и ``bytearray`` не соответствуют "
"шаблонам последовательностей."

#: ../../reference/compound_stmts.rst:1873
msgid "In pattern matching, a mapping is defined as one of the following:"
msgstr ""
"При сопоставлении с образцом сопоставление определяется как одно из "
"следующих:"

#: ../../reference/compound_stmts.rst:1875
msgid "a class that inherits from :class:`collections.abc.Mapping`"
msgstr "класс, который наследуется от :class:`collections.abc.Mapping`"

#: ../../reference/compound_stmts.rst:1876
msgid ""
"a Python class that has been registered as :class:`collections.abc.Mapping`"
msgstr "класс Python, зарегистрированный как :class:`collections.abc.Mapping`"

#: ../../reference/compound_stmts.rst:1877
msgid ""
"a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set"
msgstr ""
"встроенный класс, у которого установлен бит (CPython) :c:macro:"
"`Py_TPFLAGS_MAPPING`"

#: ../../reference/compound_stmts.rst:1880
msgid ""
"The standard library classes :class:`dict` and :class:`types."
"MappingProxyType` are mappings."
msgstr ""
"Классы стандартной библиотеки :class:`dict` и :class:`types."
"MappingProxyType` являются сопоставлениями."

#: ../../reference/compound_stmts.rst:1883
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's :attr:`~function.__doc__` attribute and "
"therefore the function's :term:`docstring`."
msgstr ""
"Строковый литерал, появляющийся в качестве первого оператора в теле функции, "
"преобразуется в атрибут :attr:`~function.__doc__` и, следовательно, в :term:"
"`docstring` функции."

#: ../../reference/compound_stmts.rst:1887
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's :attr:`~type.__doc__` item and therefore "
"the class's :term:`docstring`."
msgstr ""
"Строковый литерал, появляющийся в качестве первого оператора в теле класса, "
"преобразуется в элемент :attr:`~type.__doc__` пространства имен и, "
"следовательно, в :term:`docstring` класса."

#: ../../reference/compound_stmts.rst:7
msgid "compound"
msgstr "соединение"

#: ../../reference/compound_stmts.rst:7 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
#: ../../reference/compound_stmts.rst:1499
#: ../../reference/compound_stmts.rst:1533
#: ../../reference/compound_stmts.rst:1578
msgid "statement"
msgstr "инструкция"

#: ../../reference/compound_stmts.rst:21
msgid "clause"
msgstr "clause"

#: ../../reference/compound_stmts.rst:21
msgid "suite"
msgstr "suite"

#: ../../reference/compound_stmts.rst:21
msgid "; (semicolon)"
msgstr "; (точка с запятой)"

#: ../../reference/compound_stmts.rst:64
msgid "NEWLINE token"
msgstr "NEWLINE token"

#: ../../reference/compound_stmts.rst:64
msgid "DEDENT token"
msgstr "DEDENT token"

#: ../../reference/compound_stmts.rst:64
msgid "dangling"
msgstr "dangling"

#: ../../reference/compound_stmts.rst:64 ../../reference/compound_stmts.rst:86
#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:390
msgid "else"
msgstr "else"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:588
msgid "if"
msgstr "if"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:327
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:408
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1509
msgid "keyword"
msgstr "keyword"

#: ../../reference/compound_stmts.rst:86
msgid "elif"
msgstr "elif"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1325
#: ../../reference/compound_stmts.rst:1389
msgid ": (colon)"
msgstr ": (двоеточие)"

#: ../../reference/compound_stmts.rst:86 ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "compound statement"
msgstr "составное заявление"

#: ../../reference/compound_stmts.rst:111
msgid "while"
msgstr "while"

#: ../../reference/compound_stmts.rst:111
#: ../../reference/compound_stmts.rst:144
msgid "loop"
msgstr "цикл"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
msgid "break"
msgstr "break"

#: ../../reference/compound_stmts.rst:129
#: ../../reference/compound_stmts.rst:169
#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
msgid "continue"
msgstr "continue"

#: ../../reference/compound_stmts.rst:144
msgid "for"
msgstr "for"

#: ../../reference/compound_stmts.rst:144
msgid "in"
msgstr "in"

#: ../../reference/compound_stmts.rst:144
msgid "target"
msgstr "target"

#: ../../reference/compound_stmts.rst:144
msgid "list"
msgstr "список"

#: ../../reference/compound_stmts.rst:144
#: ../../reference/compound_stmts.rst:298
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "object"
msgstr "объект"

#: ../../reference/compound_stmts.rst:144
msgid "sequence"
msgstr "последовательность"

#: ../../reference/compound_stmts.rst:190
msgid "built-in function"
msgstr "встроенная функция"

#: ../../reference/compound_stmts.rst:190
msgid "range"
msgstr "range"

#: ../../reference/compound_stmts.rst:207
msgid "try"
msgstr "try"

#: ../../reference/compound_stmts.rst:207
msgid "except"
msgstr "except"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:408
msgid "finally"
msgstr "finally"

#: ../../reference/compound_stmts.rst:207
#: ../../reference/compound_stmts.rst:265
#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:588
msgid "as"
msgstr "as"

#: ../../reference/compound_stmts.rst:265
msgid "except clause"
msgstr "except clause"

#: ../../reference/compound_stmts.rst:298
msgid "module"
msgstr "модуль"

#: ../../reference/compound_stmts.rst:298
msgid "sys"
msgstr "sys"

#: ../../reference/compound_stmts.rst:298
msgid "traceback"
msgstr "трассировка"

#: ../../reference/compound_stmts.rst:327
msgid "except_star"
msgstr "except_star"

#: ../../reference/compound_stmts.rst:390
#: ../../reference/compound_stmts.rst:437
msgid "return"
msgstr "return"

#: ../../reference/compound_stmts.rst:471
msgid "with"
msgstr "with"

#: ../../reference/compound_stmts.rst:471
msgid "with statement"
msgstr "with statement"

#: ../../reference/compound_stmts.rst:471
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid ", (comma)"
msgstr ", (запятая)"

#: ../../reference/compound_stmts.rst:588
msgid "match"
msgstr "match"

#: ../../reference/compound_stmts.rst:588
msgid "case"
msgstr "case"

#: ../../reference/compound_stmts.rst:588
msgid "pattern matching"
msgstr "pattern matching"

#: ../../reference/compound_stmts.rst:588
msgid "match statement"
msgstr "match statement"

#: ../../reference/compound_stmts.rst:692
msgid "guard"
msgstr "guard"

#: ../../reference/compound_stmts.rst:731
msgid "irrefutable case block"
msgstr "irrefutable case block"

#: ../../reference/compound_stmts.rst:731
msgid "case block"
msgstr "case block"

#: ../../reference/compound_stmts.rst:755
msgid "! patterns"
msgstr "! patterns"

#: ../../reference/compound_stmts.rst:755
msgid "AS pattern, OR pattern, capture pattern, wildcard pattern"
msgstr "AS pattern, OR pattern, capture pattern, wildcard pattern"

#: ../../reference/compound_stmts.rst:1186
#: ../../reference/compound_stmts.rst:1275
msgid "parameter"
msgstr "параметр"

#: ../../reference/compound_stmts.rst:1186
#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1239
#: ../../reference/compound_stmts.rst:1275
#: ../../reference/compound_stmts.rst:1304
msgid "function definition"
msgstr "function definition"

#: ../../reference/compound_stmts.rst:1195
msgid "def"
msgstr "def"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1325
msgid "function"
msgstr "функция"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "definition"
msgstr "definition"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "name"
msgstr "имя"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "binding"
msgstr "binding"

#: ../../reference/compound_stmts.rst:1195
msgid "user-defined function"
msgstr "определяемые пользователем функция"

#: ../../reference/compound_stmts.rst:1195
#: ../../reference/compound_stmts.rst:1389
msgid "() (parentheses)"
msgstr "() (parentheses)"

#: ../../reference/compound_stmts.rst:1195
msgid "parameter list"
msgstr "parameter list"

#: ../../reference/compound_stmts.rst:1239
#: ../../reference/compound_stmts.rst:1439
msgid "@ (at)"
msgstr "@ (at)"

#: ../../reference/compound_stmts.rst:1275
msgid "default"
msgstr "значение по умолчанию"

#: ../../reference/compound_stmts.rst:1275
msgid "value"
msgstr "значение"

#: ../../reference/compound_stmts.rst:1275
msgid "argument"
msgstr "аргумент"

#: ../../reference/compound_stmts.rst:1275
msgid "= (equals)"
msgstr "= (равно)"

#: ../../reference/compound_stmts.rst:1304
msgid "/ (slash)"
msgstr "/ (косая черта)"

#: ../../reference/compound_stmts.rst:1304
msgid "* (asterisk)"
msgstr "* (звёздочка)"

#: ../../reference/compound_stmts.rst:1304
msgid "**"
msgstr "**"

#: ../../reference/compound_stmts.rst:1325
msgid "annotations"
msgstr "аннотации"

#: ../../reference/compound_stmts.rst:1325
msgid "->"
msgstr "->"

#: ../../reference/compound_stmts.rst:1325
msgid "function annotations"
msgstr "function annotations"

#: ../../reference/compound_stmts.rst:1348
msgid "lambda"
msgstr "лямбда"

#: ../../reference/compound_stmts.rst:1348
msgid "expression"
msgstr "выражение"

#: ../../reference/compound_stmts.rst:1389
msgid "class"
msgstr "класс"

#: ../../reference/compound_stmts.rst:1389
msgid "execution"
msgstr "execution"

#: ../../reference/compound_stmts.rst:1389
msgid "frame"
msgstr "фрейм"

#: ../../reference/compound_stmts.rst:1389
msgid "inheritance"
msgstr "inheritance"

#: ../../reference/compound_stmts.rst:1389
msgid "docstring"
msgstr "строка документации"

#: ../../reference/compound_stmts.rst:1389
#: ../../reference/compound_stmts.rst:1439
msgid "class definition"
msgstr "class definition"

#: ../../reference/compound_stmts.rst:1389
msgid "expression list"
msgstr "expression list"

#: ../../reference/compound_stmts.rst:1499
msgid "async def"
msgstr "async def"

#: ../../reference/compound_stmts.rst:1509
msgid "async"
msgstr "async"

#: ../../reference/compound_stmts.rst:1509
msgid "await"
msgstr "await"

#: ../../reference/compound_stmts.rst:1533
msgid "async for"
msgstr "async for"

#: ../../reference/compound_stmts.rst:1578
msgid "async with"
msgstr "async with"

#: ../../reference/compound_stmts.rst:1632
msgid "type parameters"
msgstr "type parameters"
