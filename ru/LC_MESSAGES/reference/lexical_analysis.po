# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 15:26+0000\n"
"PO-Revision-Date: 2023-05-24 02:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Лексический анализ"

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Программа Python читается *парсером*. Входными данными для синтаксического "
"анализатора является поток *токенов*, сгенерированный *лексическим "
"анализатором*. В этой главе описано, как лексический анализатор разбивает "
"файл на токены."

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python читает текст программы как кодовые точки Unicode; кодировка исходного "
"файла может быть задана в объявлении кодировки и по умолчанию используется "
"UTF-8, подробности см. в :pep:`3120`. Если исходный файл не может быть "
"декодирован, выдается ошибка :exc:`SyntaxError`."

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Линейная структура"

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Программа Python разделена на несколько *логических строк*."

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Логические линии"

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"Конец логической строки обозначается маркером NEWLINE. Операторы не могут "
"пересекать границы логических строк, за исключением случаев, когда NEWLINE "
"разрешен синтаксисом (например, между операторами в составных операторах). "
"Логическая линия создается из одной или нескольких *физических линий* в "
"соответствии с явными или неявными правилами *соединения линий*."

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Физические линии"

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Физическая строка — это последовательность символов, заканчивающаяся "
"последовательностью конца строки. В исходных файлах и строках можно "
"использовать любую стандартную последовательность завершения строки "
"платформы: форму Unix с использованием ASCII LF (перевод строки), форму "
"Windows с использованием последовательности ASCII CR LF (возврат с "
"последующим переводом строки) или старую форму Macintosh с использованием "
"символ ASCII CR (возврат). Все эти формы можно использовать одинаково, "
"независимо от платформы. Конец ввода также служит неявным ограничителем "
"последней физической строки."

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"При встраивании Python строки исходного кода должны передаваться в API "
"Python с использованием стандартных соглашений C для символов новой строки "
"(символ ``\\n``, представляющий ASCII LF, является признаком конца строки)."

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Комментарии"

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Комментарий начинается с символа решетки (``#``), который не является частью "
"строкового литерала, и заканчивается в конце физической строки. Комментарий "
"означает конец логической строки, если не вызываются неявные правила "
"объединения строк. Комментарии игнорируются синтаксисом."

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Объявления кодирования"

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Если комментарий в первой или второй строке скрипта Python соответствует "
"регулярному выражению ``coding[=:]\\s*([-\\w.]+)``, этот комментарий "
"обрабатывается как объявление кодировки; первая группа этого выражения "
"называет кодировку файла исходного кода. Объявление кодировки должно "
"располагаться на отдельной строке. Если это вторая строка, первая строка "
"также должна быть строкой только для комментариев. Рекомендуемые формы "
"выражения кодировки:::"

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "который также признается GNU Emacs, и ::"

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "который признан VIM Брэма Муленаара."

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  If the "
"implicit or explicit encoding of a file is UTF-8, an initial UTF-8 byte-"
"order mark (b'\\xef\\xbb\\xbf') is ignored rather than being a syntax error."
msgstr ""
"Если объявление кодировки не найдено, кодировкой по умолчанию является "
"UTF-8. Если неявная или явная кодировка файла — UTF-8, начальная метка "
"порядка байтов UTF-8 (b'\\xef\\xbb\\xbf') игнорируется, а не является "
"синтаксической ошибкой."

#: ../../reference/lexical_analysis.rst:103
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"Если кодировка объявлена, имя кодировки должно распознаваться Python (см. :"
"ref:`standard-encodings`). Кодировка используется для всего лексического "
"анализа, включая строковые литералы, комментарии и идентификаторы."

#: ../../reference/lexical_analysis.rst:112
msgid "Explicit line joining"
msgstr "Явное соединение строк"

#: ../../reference/lexical_analysis.rst:116
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Две или более физические строки могут быть объединены в логические строки с "
"использованием символов обратной косой черты (``\\``) следующим образом: "
"когда физическая строка заканчивается обратной косой чертой, которая не "
"является частью строкового литерала или комментария, она объединяется с "
"помощью следующего формирование одной логической строки, удаление обратной "
"косой черты и следующего за ней символа конца строки. Например::"

#: ../../reference/lexical_analysis.rst:127
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Строка, заканчивающаяся обратной косой чертой, не может содержать "
"комментарий. Обратная косая черта не продолжает комментарий. Обратная косая "
"черта не продолжает токен, за исключением строковых литералов (т. е. токены, "
"отличные от строковых литералов, не могут быть разделены на физические "
"строки с помощью обратной косой черты). Обратная косая черта недопустима в "
"любом месте строки за пределами строкового литерала."

#: ../../reference/lexical_analysis.rst:137
msgid "Implicit line joining"
msgstr "Неявное соединение строк"

#: ../../reference/lexical_analysis.rst:139
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Выражения в круглых, квадратных или фигурных скобках можно разделить на "
"несколько физических строк без использования обратной косой черты. Например::"

#: ../../reference/lexical_analysis.rst:147
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Неявно продолженные строки могут содержать комментарии. Отступ строк "
"продолжения не важен. Допускаются пустые строки продолжения. Между строками "
"неявного продолжения нет токена NEWLINE. Неявно продолжающиеся строки также "
"могут встречаться в строках, заключенных в тройные кавычки (см. ниже); в "
"этом случае они не могут нести комментарии."

#: ../../reference/lexical_analysis.rst:157
msgid "Blank lines"
msgstr "Пустые строки"

#: ../../reference/lexical_analysis.rst:161
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Логическая строка, содержащая только пробелы, табуляции, переводы страниц и, "
"возможно, комментарий, игнорируется (т. е. токен NEWLINE не генерируется). "
"Во время интерактивного ввода операторов обработка пустой строки может "
"отличаться в зависимости от реализации цикла чтения-оценки-печати. В "
"стандартном интерактивном интерпретаторе полностью пустая логическая строка "
"(т.е. не содержащая даже пробелов или комментариев) завершает многострочный "
"оператор."

#: ../../reference/lexical_analysis.rst:172
msgid "Indentation"
msgstr "Отступ"

#: ../../reference/lexical_analysis.rst:176
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Ведущие пробелы (пробелы и табуляции) в начале логической строки "
"используются для вычисления уровня отступа строки, который, в свою очередь, "
"используется для определения группировки операторов."

#: ../../reference/lexical_analysis.rst:180
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Табуляция заменяется (слева направо) на от одного до восьми пробелов, так "
"что общее количество символов до замены включительно кратно восьми (это то "
"же самое правило, которое используется в Unix). Общее количество пробелов, "
"предшествующих первому непустому символу, определяет отступ строки. Отступ "
"нельзя разделить на несколько физических строк с помощью обратной косой "
"черты; пробелы до первой обратной косой черты определяют отступ."

#: ../../reference/lexical_analysis.rst:188
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"Отступы отклоняются как непоследовательные, если в исходном файле табуляция "
"и пробелы смешаны таким образом, что значение зависит от значения табуляции "
"в пробелах; В этом случае возникает :exc:`TabError`."

#: ../../reference/lexical_analysis.rst:192
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Примечание о межплатформенной совместимости:** из-за особенностей "
"текстовых редакторов на платформах, отличных от UNIX, неразумно использовать "
"сочетание пробелов и табуляции для отступов в одном исходном файле. Также "
"следует отметить, что разные платформы могут явно ограничивать максимальный "
"уровень отступов."

#: ../../reference/lexical_analysis.rst:197
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Символ перевода страницы может присутствовать в начале строки; он будет "
"игнорироваться при расчете отступов, приведенном выше. Символы перевода "
"страницы, встречающиеся в других местах начального пробела, имеют "
"неопределенный эффект (например, они могут сбросить счетчик пробелов на "
"ноль)."

#: ../../reference/lexical_analysis.rst:204
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Уровни отступов последовательных строк используются для создания токенов "
"INDENT и DEDENT с использованием стека следующим образом."

#: ../../reference/lexical_analysis.rst:207
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Прежде чем будет прочитана первая строка файла, в стек помещается один ноль; "
"это больше никогда не будет снято. Числа, помещенные в стек, всегда будут "
"строго увеличиваться снизу вверх. В начале каждой логической строки уровень "
"отступа строки сравнивается с вершиной стека. Если оно равно, ничего не "
"происходит. Если он больше, он помещается в стек и генерируется один токен "
"INDENT. Если оно меньше, оно *должно* быть одним из чисел, встречающихся в "
"стеке; все числа в стеке, которые больше, извлекаются, и для каждого "
"извлеченного числа генерируется токен DEDENT. В конце файла генерируется "
"токен DEDENT для каждого оставшегося в стеке числа, большего нуля."

#: ../../reference/lexical_analysis.rst:218
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Вот пример правильно (хотя и сбивчиво) фрагмента кода Python с отступами:"

#: ../../reference/lexical_analysis.rst:233
msgid "The following example shows various indentation errors::"
msgstr "В следующем примере показаны различные ошибки отступов:"

#: ../../reference/lexical_analysis.rst:243
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(На самом деле синтаксический анализатор обнаруживает первые три ошибки; "
"лексический анализатор находит только последнюю ошибку --- отступ ``return "
"r`` не соответствует уровню, извлеченному из стека.)"

#: ../../reference/lexical_analysis.rst:251
msgid "Whitespace between tokens"
msgstr "Пробелы между токенами"

#: ../../reference/lexical_analysis.rst:253
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"За исключением начала логической строки или строковых литералов, пробелы, "
"символы табуляции и перевода страницы могут использоваться взаимозаменяемо "
"для разделения токенов. Пробелы необходимы между двумя токенами только в том "
"случае, если их объединение иначе можно было бы интерпретировать как другой "
"токен (например, ab — это один токен, а ab — два токена)."

#: ../../reference/lexical_analysis.rst:263
msgid "Other tokens"
msgstr "Другие токены"

#: ../../reference/lexical_analysis.rst:265
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Помимо NEWLINE, INDENT и DEDENT, существуют следующие категории токенов: "
"*идентификаторы*, *ключевые слова*, *литералы*, *операторы* и *разделители*. "
"Пробельные символы (кроме ограничителей строк, обсуждавшихся ранее) не "
"являются токенами, а служат для их разделения. Там, где существует "
"неоднозначность, токен содержит максимально длинную строку, которая образует "
"допустимый токен при чтении слева направо."

#: ../../reference/lexical_analysis.rst:275
msgid "Identifiers and keywords"
msgstr "Идентификаторы и ключевые слова"

#: ../../reference/lexical_analysis.rst:279
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Идентификаторы (также называемые *именами*) описываются следующими "
"лексическими определениями."

#: ../../reference/lexical_analysis.rst:282
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"Синтаксис идентификаторов в Python основан на стандартном приложении Unicode "
"UAX-31 с доработками и изменениями, как определено ниже; дополнительную "
"информацию см. также в :pep:`3131`."

#: ../../reference/lexical_analysis.rst:286
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"В диапазоне ASCII (U+0001..U+007F) допустимые символы для идентификаторов "
"такие же, как и в Python 2.x: прописные и строчные буквы от «A» до «Z», "
"подчеркивание « `_`` и, за исключением первого символа, цифры от ``0`` до "
"``9``."

#: ../../reference/lexical_analysis.rst:291
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 вводит дополнительные символы за пределами диапазона ASCII (см. :"
"pep:`3131`). Для этих символов в классификации используется версия базы "
"данных символов Юникода, включенная в модуль :mod:`unicodedata`."

#: ../../reference/lexical_analysis.rst:295
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "Идентификаторы не ограничены по длине. Случай знаменательный."

#: ../../reference/lexical_analysis.rst:304
msgid "The Unicode category codes mentioned above stand for:"
msgstr "Упомянутые выше коды категорий Unicode означают:"

#: ../../reference/lexical_analysis.rst:306
msgid "*Lu* - uppercase letters"
msgstr "*Лу* - заглавные буквы"

#: ../../reference/lexical_analysis.rst:307
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - строчные буквы"

#: ../../reference/lexical_analysis.rst:308
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - заглавные буквы"

#: ../../reference/lexical_analysis.rst:309
msgid "*Lm* - modifier letters"
msgstr "*Lm* - буквы-модификаторы"

#: ../../reference/lexical_analysis.rst:310
msgid "*Lo* - other letters"
msgstr "*Lo* - другие буквы"

#: ../../reference/lexical_analysis.rst:311
msgid "*Nl* - letter numbers"
msgstr "*Nl* - номера букв"

#: ../../reference/lexical_analysis.rst:312
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - непромежуточные знаки "

#: ../../reference/lexical_analysis.rst:313
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - знаки объединения интервалов"

#: ../../reference/lexical_analysis.rst:314
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - десятичные числа"

#: ../../reference/lexical_analysis.rst:315
msgid "*Pc* - connector punctuations"
msgstr "*Pc* — знаки препинания разъема"

#: ../../reference/lexical_analysis.rst:316
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/14.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: ../../reference/lexical_analysis.rst:319
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - аналогично"

#: ../../reference/lexical_analysis.rst:321
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Все идентификаторы при разборе преобразуются в нормальную форму NFKC; "
"сравнение идентификаторов основано на NFKC."

#: ../../reference/lexical_analysis.rst:324
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 14.0.0 can be found at https://www.unicode.org/Public/14.0.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:332
msgid "Keywords"
msgstr "Ключевые слова"

#: ../../reference/lexical_analysis.rst:338
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Следующие идентификаторы используются как зарезервированные слова или "
"*ключевые слова* языка и не могут использоваться как обычные идентификаторы. "
"Их нужно писать именно так, как написано здесь:"

#: ../../reference/lexical_analysis.rst:356
msgid "Soft Keywords"
msgstr "Мягкие ключевые слова"

#: ../../reference/lexical_analysis.rst:362
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case`` and ``_`` can "
"syntactically act as keywords in contexts related to the pattern matching "
"statement, but this distinction is done at the parser level, not when "
"tokenizing."
msgstr ""

#: ../../reference/lexical_analysis.rst:368
msgid ""
"As soft keywords, their use with pattern matching is possible while still "
"preserving compatibility with existing code that uses ``match``, ``case`` "
"and ``_`` as identifier names."
msgstr ""

#: ../../reference/lexical_analysis.rst:379
msgid "Reserved classes of identifiers"
msgstr "Зарезервированные классы идентификаторов"

#: ../../reference/lexical_analysis.rst:381
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Определенные классы идентификаторов (кроме ключевых слов) имеют особое "
"значение. Эти классы идентифицируются по шаблонам начальных и конечных "
"символов подчеркивания:"

#: ../../reference/lexical_analysis.rst:386
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:386
msgid "Not imported by ``from module import *``."
msgstr "Не импортируется из ``from module import *``."

#: ../../reference/lexical_analysis.rst:407
msgid "``_``"
msgstr "``_``"

#: ../../reference/lexical_analysis.rst:389
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"В шаблоне ``case`` в операторе :keyword:`match` ``_`` представляет собой :"
"ref:`мягкое ключевое слово <soft-keywords>`, которое обозначает :ref:"
"`wildcard <wildcard-patterns> `."

#: ../../reference/lexical_analysis.rst:393
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"Отдельно интерактивный интерпретатор делает результат последней оценки "
"доступным в переменной ``_``. (Он хранится в модуле :mod:`builtins` вместе "
"со встроенными функциями, такими как ``print``.)"

#: ../../reference/lexical_analysis.rst:398
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""
"В других местах ``_`` является обычным идентификатором. Его часто используют "
"для обозначения «специальных» элементов, но он не является чем-то особенным "
"для самого Python."

#: ../../reference/lexical_analysis.rst:403
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Имя ``_`` часто используется в сочетании с интернационализацией; обратитесь "
"к документации модуля :mod:`gettext` для получения дополнительной информации "
"об этом соглашении."

#: ../../reference/lexical_analysis.rst:407
msgid "It is also commonly used for unused variables."
msgstr "Он также часто используется для неиспользуемых переменных."

#: ../../reference/lexical_analysis.rst:415
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:410
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Определенные системой имена, неофициально известные как имена «dunder». Эти "
"имена определяются интерпретатором и его реализацией (включая стандартную "
"библиотеку). Текущие системные имена обсуждаются в разделе :ref:"
"`specialnames` и других местах. Скорее всего, больше будет определено в "
"будущих версиях Python. *Любое* использование имен ``__*__`` в любом "
"контексте, которое не соответствует явно задокументированному использованию, "
"может быть нарушено без предупреждения."

#: ../../reference/lexical_analysis.rst:422
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:418
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Частные имена классов. Имена в этой категории, когда они используются в "
"контексте определения класса, переписываются в искаженной форме, чтобы "
"избежать конфликтов имен между «частными» атрибутами базового и производных "
"классов. См. раздел :ref:`атом-идентификаторы`."

#: ../../reference/lexical_analysis.rst:427
msgid "Literals"
msgstr "Литералы"

#: ../../reference/lexical_analysis.rst:431
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Литералы — это обозначения постоянных значений некоторых встроенных типов."

#: ../../reference/lexical_analysis.rst:442
msgid "String and Bytes literals"
msgstr "Строковые и байтовые литералы"

#: ../../reference/lexical_analysis.rst:444
msgid "String literals are described by the following lexical definitions:"
msgstr "Строковые литералы описываются следующими лексическими определениями:"

#: ../../reference/lexical_analysis.rst:469
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section :ref:"
"`encodings`."
msgstr ""
"Одно синтаксическое ограничение, не указанное в этих продуктах, заключается "
"в том, что пробелы не допускаются между :token:`~python-grammar:"
"stringprefix` или :token:`~python-grammar:bytesprefix` и остальной частью "
"литерала. Исходный набор символов определяется объявлением кодировки; это "
"UTF-8, если в исходном файле не указано объявление кодировки; см. раздел :"
"ref:`кодировки`."

#: ../../reference/lexical_analysis.rst:479
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""

#: ../../reference/lexical_analysis.rst:490
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Байтовые литералы всегда имеют префикс ``'b'`` или ``'B'``; они создают "
"экземпляр типа :class:`bytes` вместо типа :class:`str`. Они могут содержать "
"только символы ASCII; байты с числовым значением 128 или больше должны быть "
"выражены с помощью escape-символов."

#: ../../reference/lexical_analysis.rst:499
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""

#: ../../reference/lexical_analysis.rst:506
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"Префикс ``'rb'`` для литералов необработанных байтов был добавлен как "
"синоним ``'br'``."

#: ../../reference/lexical_analysis.rst:510
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"Поддержка устаревшего литерала Unicode («u'value») была вновь введена для "
"упрощения обслуживания двойных кодовых баз Python 2.x и 3.x. См. :pep:`414` "
"для получения дополнительной информации."

#: ../../reference/lexical_analysis.rst:518
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"Строковый литерал с префиксом ``'f'`` или ``'F'`` является :dfn:"
"`форматированным строковым литералом`; см. :ref:`f-strings`. ``'f'`` можно "
"комбинировать с ``'r'``, но не с ``'b'`` или ``'u'``, поэтому возможны "
"необработанные форматированные строки, но форматированные байтовые литералы "
"нет."

#: ../../reference/lexical_analysis.rst:523
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"В литералах с тройными кавычками разрешены (и сохраняются) неэкранированные "
"символы новой строки и кавычки, за исключением того, что три "
"неэкранированные кавычки подряд завершают литерал. («Кавычка» — это символ, "
"используемый для открытия литерала, т. е. либо ``'``, либо ``'``.)"

#: ../../reference/lexical_analysis.rst:545
msgid "Escape sequences"
msgstr "Escape-последовательности"

#: ../../reference/lexical_analysis.rst:547
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"Если не присутствует префикс ``'r'`` или ``'R'``, escape-последовательности "
"в строковых и байтовых литералах интерпретируются в соответствии с "
"правилами, аналогичными тем, которые используются в стандарте C. "
"Распознаваемые escape-последовательности:"

#: ../../reference/lexical_analysis.rst:552
#: ../../reference/lexical_analysis.rst:585
msgid "Escape Sequence"
msgstr "Escape-последовательность"

#: ../../reference/lexical_analysis.rst:552
#: ../../reference/lexical_analysis.rst:585
msgid "Meaning"
msgstr "Значение"

#: ../../reference/lexical_analysis.rst:552
#: ../../reference/lexical_analysis.rst:585
msgid "Notes"
msgstr "Примечания"

#: ../../reference/lexical_analysis.rst:554
msgid "``\\``\\ <newline>"
msgstr "``\\``\\ <newline>"

#: ../../reference/lexical_analysis.rst:554
msgid "Backslash and newline ignored"
msgstr "Обратная косая черта и новая строка игнорируются"

#: ../../reference/lexical_analysis.rst:554
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:556
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:556
msgid "Backslash (``\\``)"
msgstr "Обратный слэш (``\\``)"

#: ../../reference/lexical_analysis.rst:558
msgid "``\\'``"
msgstr "``\\'``"

#: ../../reference/lexical_analysis.rst:558
msgid "Single quote (``'``)"
msgstr "Одиночная кавычка (``'``)"

#: ../../reference/lexical_analysis.rst:560
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:560
msgid "Double quote (``\"``)"
msgstr "Двойная кавычка (``\"``)"

#: ../../reference/lexical_analysis.rst:562
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:562
msgid "ASCII Bell (BEL)"
msgstr "ASCII Bell (BEL)"

#: ../../reference/lexical_analysis.rst:564
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:564
msgid "ASCII Backspace (BS)"
msgstr "ASCII Backspace (BS)"

#: ../../reference/lexical_analysis.rst:566
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:566
msgid "ASCII Formfeed (FF)"
msgstr "Подача форм в формате ASCII (FF)"

#: ../../reference/lexical_analysis.rst:568
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:568
msgid "ASCII Linefeed (LF)"
msgstr "ASCII Linefeed (LF)"

#: ../../reference/lexical_analysis.rst:570
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:570
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII Carriage Return (CR)"

#: ../../reference/lexical_analysis.rst:572
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:572
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII Horizontal Tab (TAB)"

#: ../../reference/lexical_analysis.rst:574
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:574
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII Vertical Tab (VT)"

#: ../../reference/lexical_analysis.rst:576
msgid ":samp:`\\\\\\\\{ooo}`"
msgstr ":samp:`\\\\\\\\{ooo}`"

#: ../../reference/lexical_analysis.rst:576
msgid "Character with octal value *ooo*"
msgstr "Символ восьмеричного значения *ооо*"

#: ../../reference/lexical_analysis.rst:576
msgid "(2,4)"
msgstr "(2,4)"

#: ../../reference/lexical_analysis.rst:579
msgid ":samp:`\\\\x{hh}`"
msgstr ":samp:`\\\\x{hh}`"

#: ../../reference/lexical_analysis.rst:579
msgid "Character with hex value *hh*"
msgstr "Символ с шестнадцатеричным значением *чч*"

#: ../../reference/lexical_analysis.rst:579
msgid "(3,4)"
msgstr "(3,4)"

#: ../../reference/lexical_analysis.rst:582
msgid "Escape sequences only recognized in string literals are:"
msgstr ""
"Escape-последовательности, распознаваемые только в строковых литералах:"

#: ../../reference/lexical_analysis.rst:587
msgid ":samp:`\\\\N\\\\{{name}\\\\}`"
msgstr ":samp:`\\\\N\\\\{{name}\\\\}`"

#: ../../reference/lexical_analysis.rst:587
msgid "Character named *name* in the Unicode database"
msgstr "Символ с именем *имя* в базе данных Юникода"

#: ../../reference/lexical_analysis.rst:587
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:590
msgid ":samp:`\\\\u{xxxx}`"
msgstr ":samp:`\\\\u{xxxx}`"

#: ../../reference/lexical_analysis.rst:590
msgid "Character with 16-bit hex value *xxxx*"
msgstr "Символ с 16-битным шестнадцатеричным значением *xxxx*"

#: ../../reference/lexical_analysis.rst:590
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:593
msgid ":samp:`\\\\U{xxxxxxxx}`"
msgstr ":samp:`\\\\U{xxxxxxxx}`"

#: ../../reference/lexical_analysis.rst:593
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "Символ с 32-битным шестнадцатеричным значением *xxxxxxxxxx*"

#: ../../reference/lexical_analysis.rst:593
msgid "\\(7)"
msgstr "\\(7)"

#: ../../reference/lexical_analysis.rst:597
msgid "Notes:"
msgstr "Примечания:"

#: ../../reference/lexical_analysis.rst:600
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""
"В конце строки можно добавить обратную косую черту, чтобы игнорировать новую "
"строку:"

#: ../../reference/lexical_analysis.rst:606
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""
"Того же результата можно добиться, используя :ref:`строки в тройных кавычках "
"<strings>` или круглые скобки и :ref:`конкатенацию строковых литералов "
"<string-concatenation>`."

#: ../../reference/lexical_analysis.rst:611
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "Как и в стандарте C, допускается до трех восьмеричных цифр."

#: ../../reference/lexical_analysis.rst:613
msgid ""
"Octal escapes with value larger than ``0o377`` produce a :exc:"
"`DeprecationWarning`. In a future Python version they will be a :exc:"
"`SyntaxWarning` and eventually a :exc:`SyntaxError`."
msgstr ""

#: ../../reference/lexical_analysis.rst:619
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"В отличие от стандарта C, здесь требуется ровно две шестнадцатеричные цифры."

#: ../../reference/lexical_analysis.rst:622
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"В литерале байтов шестнадцатеричные и восьмеричные escape-символы обозначают "
"байт с заданным значением. В строковом литерале эти escape-символы "
"обозначают символ Юникода с заданным значением."

#: ../../reference/lexical_analysis.rst:627
msgid "Support for name aliases [#]_ has been added."
msgstr "Поддержка псевдонимов имен [#]_ был добавлен."

#: ../../reference/lexical_analysis.rst:631
msgid "Exactly four hex digits are required."
msgstr "Требуется ровно четыре шестнадцатеричные цифры."

#: ../../reference/lexical_analysis.rst:634
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"Таким образом можно закодировать любой символ Юникода. Требуется ровно "
"восемь шестнадцатеричных цифр."

#: ../../reference/lexical_analysis.rst:640
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"В отличие от стандарта C, все нераспознанные escape-последовательности "
"остаются в строке неизмененными, т.е. *обратная косая черта остается в "
"результате*. (Такое поведение полезно при отладке: если escape-"
"последовательность введена с ошибкой, результирующий вывод легче распознать "
"как поврежденный.) Также важно отметить, что escape-последовательности, "
"распознаваемые только в строковых литералах, попадают в категорию "
"нераспознанных escape-последовательностей для байтов. литералы."

#: ../../reference/lexical_analysis.rst:647
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""

#: ../../reference/lexical_analysis.rst:652
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Даже в необработанном литерале кавычки можно экранировать обратной косой "
"чертой, но в результате обратная косая черта останется; например, ``r\"\\"
"\"\"`` является допустимым строковым литералом, состоящим из двух символов: "
"обратной косой черты и двойной кавычки; ``r\"\\\"`` не является допустимым "
"строковым литералом (даже необработанная строка не может заканчиваться в "
"нечетном количестве обратных косых черт). В частности, *необработанный "
"литерал не может заканчиваться одной обратной косой чертой* (поскольку "
"обратная косая черта будет экранировать следующий символ кавычки). Обратите "
"также внимание, что одиночная обратная косая черта, за которой следует "
"символ новой строки, интерпретируется как эти два символа. часть литерала, "
"*не* как продолжение строки."

#: ../../reference/lexical_analysis.rst:665
msgid "String literal concatenation"
msgstr "Объединение строковых литералов"

#: ../../reference/lexical_analysis.rst:667
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Допускаются несколько смежных строковых или байтовых литералов (разделенных "
"пробелами), возможно, с использованием разных соглашений о кавычках, и их "
"значение такое же, как и их объединение. Таким образом, ``\"hello\" "
"'world'`` эквивалентен ``\"helloworld\"``. Эту функцию можно использовать "
"для уменьшения количества необходимых обратных косых черт, для удобного "
"разделения длинных строк на длинные строки или даже для добавления "
"комментариев к частям строк, например:"

#: ../../reference/lexical_analysis.rst:678
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"Обратите внимание, что эта функция определена на синтаксическом уровне, но "
"реализуется во время компиляции. Оператор «+» необходимо использовать для "
"объединения строковых выражений во время выполнения. Также обратите "
"внимание, что при конкатенации литералов могут использоваться разные стили "
"кавычек для каждого компонента (даже смешивание необработанных строк и строк "
"в тройных кавычках), а форматированные строковые литералы могут быть "
"объединены с простыми строковыми литералами."

#: ../../reference/lexical_analysis.rst:701
msgid "f-strings"
msgstr "f-strings"

#: ../../reference/lexical_analysis.rst:705
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
":dfn:`форматированный строковый литерал` или :dfn:`f-string` — это строковый "
"литерал с префиксом ``'f'`` или ``'F'``. Эти строки могут содержать поля "
"замены, которые представляют собой выражения, разделенные фигурными скобками "
"``{}``. В то время как другие строковые литералы всегда имеют постоянное "
"значение, форматированные строки на самом деле являются выражениями, "
"вычисляемыми во время выполнения."

#: ../../reference/lexical_analysis.rst:711
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"Escape-последовательности декодируются так же, как и обычные строковые "
"литералы (кроме случаев, когда литерал также помечен как необработанная "
"строка). После декодирования грамматика содержимого строки будет следующей:"

#: ../../reference/lexical_analysis.rst:725
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"Части строки за пределами фигурных скобок обрабатываются буквально, за "
"исключением того, что любые двойные фигурные скобки ``'{{'`` или ``'}}'`` "
"заменяются соответствующей одинарной фигурной скобкой. Одиночная открывающая "
"фигурная скобка ``'{'`` отмечает поле замены, которое начинается с выражения "
"Python. Чтобы отобразить как текст выражения, так и его значение после "
"вычисления (полезно при отладке), после выражения можно добавить знак "
"равенства ``'='``. После этого может следовать поле преобразования, "
"представляемое восклицательным знаком ``'!'``. Также может быть добавлен "
"спецификатор формата, обозначаемый двоеточием ``':'``. Поле замены "
"заканчивается закрывающей фигурной скобкой ``'}'``."

#: ../../reference/lexical_analysis.rst:735
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""

#: ../../reference/lexical_analysis.rst:744
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"До Python 3.7 выражение :keyword:`await` и выражения, содержащие "
"предложение :keyword:`async for`, были недопустимы в выражениях в "
"форматированных строковых литералах из-за проблем с реализацией."

#: ../../reference/lexical_analysis.rst:749
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"Если указан знак равенства ``'='``, выходные данные будут содержать текст "
"выражения, ``'='`` и вычисленное значение. Пробелы после открывающей скобки "
"``'{'``, внутри выражения и после ``'='`` все сохраняются в выводе. По "
"умолчанию ``'='`` приводит к предоставлению :func:`repr` выражения, если не "
"указан формат. Когда указан формат, по умолчанию используется :func:`str` "
"выражения, если не объявлено преобразование ``'!r'``."

#: ../../reference/lexical_analysis.rst:757
msgid "The equal sign ``'='``."
msgstr "Знак равенства ``'='``."

#: ../../reference/lexical_analysis.rst:760
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Если указано преобразование, результат вычисления выражения преобразуется "
"перед форматированием. Преобразование ``'!s'`` вызывает :func:`str` для "
"результата, ``'!r'`` вызывает :func:`repr`, а ``'!a'`` вызывает :func:` "
"ascii`."

#: ../../reference/lexical_analysis.rst:764
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`~object.__format__` method of the "
"expression or conversion result.  An empty string is passed when the format "
"specifier is omitted.  The formatted result is then included in the final "
"value of the whole string."
msgstr ""
"Затем результат форматируется с использованием протокола :func:`format`. "
"Спецификатор формата передается методу :meth:`~object.__format__` выражения "
"или результата преобразования. Пустая строка передается, если спецификатор "
"формата опущен. Отформатированный результат затем включается в окончательное "
"значение всей строки."

#: ../../reference/lexical_analysis.rst:770
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""
"Спецификаторы формата верхнего уровня могут включать вложенные поля замены. "
"Эти вложенные поля могут включать в себя собственные поля преобразования и :"
"ref:`описатели формата <formatspec>`, но не могут включать более глубоко "
"вложенные поля замены. Мини-язык спецификатора формата <formatspec>` "
"аналогичен тому, который используется в методе :meth:`str.format`."

#: ../../reference/lexical_analysis.rst:776
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Отформатированные строковые литералы можно объединять, но поля замены нельзя "
"разделить на литералы."

#: ../../reference/lexical_analysis.rst:779
msgid "Some examples of formatted string literals::"
msgstr "Некоторые примеры форматированных строковых литералов:"

#: ../../reference/lexical_analysis.rst:811
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""

#: ../../reference/lexical_analysis.rst:818
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr ""

#: ../../reference/lexical_analysis.rst:823
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""

#: ../../reference/lexical_analysis.rst:830
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Отформатированные строковые литералы нельзя использовать в качестве строк "
"документации, даже если они не содержат выражений."

#: ../../reference/lexical_analysis.rst:841
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"См. также :pep:`498` о предложении, в котором добавлены литералы "
"форматированной строки, и :meth:`str.format`, который использует "
"соответствующий механизм форматирования строк."

#: ../../reference/lexical_analysis.rst:848
msgid "Numeric literals"
msgstr "Числовые литералы"

#: ../../reference/lexical_analysis.rst:854
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""

#: ../../reference/lexical_analysis.rst:858
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Обратите внимание, что числовые литералы не содержат знака; фраза типа "
"``-1`` на самом деле является выражением, состоящим из унарного оператора ``-"
"``' и литерала ``1``."

#: ../../reference/lexical_analysis.rst:872
msgid "Integer literals"
msgstr "Целочисленные литералы"

#: ../../reference/lexical_analysis.rst:874
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""
"Целочисленные литералы описываются следующими лексическими определениями:"

#: ../../reference/lexical_analysis.rst:888
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"Нет ограничений на длину целочисленных литералов, за исключением того, что "
"может храниться в доступной памяти."

#: ../../reference/lexical_analysis.rst:891
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"Символы подчеркивания игнорируются при определении числового значения "
"литерала. Их можно использовать для группировки цифр для улучшения "
"читаемости. Одно подчеркивание может встречаться между цифрами и после "
"базовых спецификаторов, таких как ``0x``."

#: ../../reference/lexical_analysis.rst:895
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Обратите внимание, что ведущие нули в ненулевом десятичном числе не "
"допускаются. Это сделано для устранения неоднозначности с восьмеричными "
"литералами в стиле C, которые Python использовал до версии 3.0."

#: ../../reference/lexical_analysis.rst:899
msgid "Some examples of integer literals::"
msgstr "Некоторые примеры целочисленных литералов::"

#: ../../reference/lexical_analysis.rst:905
#: ../../reference/lexical_analysis.rst:937
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "Символы подчеркивания теперь разрешены для группировки в литералах."

#: ../../reference/lexical_analysis.rst:916
msgid "Floating point literals"
msgstr "Литералы с плавающей точкой"

#: ../../reference/lexical_analysis.rst:918
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""

#: ../../reference/lexical_analysis.rst:928
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""

#: ../../reference/lexical_analysis.rst:933
msgid "Some examples of floating point literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:946
msgid "Imaginary literals"
msgstr "Воображаемые литералы"

#: ../../reference/lexical_analysis.rst:948
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "Мнимые литералы описываются следующими лексическими определениями:"

#: ../../reference/lexical_analysis.rst:953
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""

#: ../../reference/lexical_analysis.rst:965
msgid "Operators"
msgstr "Операторы"

#: ../../reference/lexical_analysis.rst:969
msgid "The following tokens are operators:"
msgstr "The following tokens are operators:"

#: ../../reference/lexical_analysis.rst:982
msgid "Delimiters"
msgstr "Delimiters"

#: ../../reference/lexical_analysis.rst:986
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Следующие токены служат разделителями в грамматике:"

#: ../../reference/lexical_analysis.rst:995
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"Точка также может встречаться в литералах с плавающей запятой и воображаемых "
"литералах. Последовательность трех периодов имеет особое значение как "
"литерал с многоточием. Вторая половина списка — расширенные операторы "
"присваивания — лексически служат разделителями, но также выполняют операции."

#: ../../reference/lexical_analysis.rst:1000
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Следующие печатные символы ASCII имеют особое значение как часть других "
"токенов или иным образом важны для лексического анализатора:"

#: ../../reference/lexical_analysis.rst:1007
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Следующие печатные символы ASCII не используются в Python. Их появление вне "
"строковых литералов и комментариев является безусловной ошибкой:"

#: ../../reference/lexical_analysis.rst:1016
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/lexical_analysis.rst:1017
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:8
msgid "lexical analysis"
msgstr "лексический анализ"

#: ../../reference/lexical_analysis.rst:8
msgid "parser"
msgstr "парсер"

#: ../../reference/lexical_analysis.rst:8
msgid "token"
msgstr "token (жетон)"

#: ../../reference/lexical_analysis.rst:25
msgid "line structure"
msgstr "линейная структура"

#: ../../reference/lexical_analysis.rst:35
msgid "logical line"
msgstr "строка логики"

#: ../../reference/lexical_analysis.rst:35
#: ../../reference/lexical_analysis.rst:114
#: ../../reference/lexical_analysis.rst:527
msgid "physical line"
msgstr "физическая линия"

#: ../../reference/lexical_analysis.rst:35
#: ../../reference/lexical_analysis.rst:114
msgid "line joining"
msgstr "соединение линий"

#: ../../reference/lexical_analysis.rst:35
msgid "NEWLINE token"
msgstr "NEWLINE token"

#: ../../reference/lexical_analysis.rst:67
msgid "comment"
msgstr "комментарий"

#: ../../reference/lexical_analysis.rst:67
msgid "hash character"
msgstr "хэш-символ"

#: ../../reference/lexical_analysis.rst:67
#: ../../reference/lexical_analysis.rst:81
msgid "# (hash)"
msgstr "# (hash)"

#: ../../reference/lexical_analysis.rst:81
msgid "source character set"
msgstr "исходный набор символов"

#: ../../reference/lexical_analysis.rst:81
msgid "encoding declarations (source file)"
msgstr "объявления кодирования (исходный файл)"

#: ../../reference/lexical_analysis.rst:81
msgid "source encoding declaration"
msgstr "объявление исходной кодировки"

#: ../../reference/lexical_analysis.rst:114
msgid "line continuation"
msgstr "продолжение строки"

#: ../../reference/lexical_analysis.rst:114
msgid "backslash character"
msgstr "символ обратной косой черты"

#: ../../reference/lexical_analysis.rst:159
msgid "blank line"
msgstr "пустая строка"

#: ../../reference/lexical_analysis.rst:174
msgid "indentation"
msgstr "отступ"

#: ../../reference/lexical_analysis.rst:174
msgid "leading whitespace"
msgstr "ведущие пробелы"

#: ../../reference/lexical_analysis.rst:174
msgid "space"
msgstr "space"

#: ../../reference/lexical_analysis.rst:174
msgid "tab"
msgstr "tab"

#: ../../reference/lexical_analysis.rst:174
msgid "grouping"
msgstr "группировка"

#: ../../reference/lexical_analysis.rst:174
msgid "statement grouping"
msgstr "группировка операторов"

#: ../../reference/lexical_analysis.rst:202
msgid "INDENT token"
msgstr "токен отступа"

#: ../../reference/lexical_analysis.rst:202
msgid "DEDENT token"
msgstr "DEDENT token"

#: ../../reference/lexical_analysis.rst:277
msgid "identifier"
msgstr "идентификатор"

#: ../../reference/lexical_analysis.rst:277
msgid "name"
msgstr "имя"

#: ../../reference/lexical_analysis.rst:334
#: ../../reference/lexical_analysis.rst:358
msgid "keyword"
msgstr "keyword"

#: ../../reference/lexical_analysis.rst:334
msgid "reserved word"
msgstr "зарезервированное слово"

#: ../../reference/lexical_analysis.rst:358
msgid "soft keyword"
msgstr "мягкое ключевое слово"

#: ../../reference/lexical_analysis.rst:373
msgid "_, identifiers"
msgstr "_, identifiers"

#: ../../reference/lexical_analysis.rst:373
msgid "__, identifiers"
msgstr "__, identifiers"

#: ../../reference/lexical_analysis.rst:429
msgid "literal"
msgstr "literal"

#: ../../reference/lexical_analysis.rst:429
msgid "constant"
msgstr "constant"

#: ../../reference/lexical_analysis.rst:434
#: ../../reference/lexical_analysis.rst:475
msgid "string literal"
msgstr "строковый литерал"

#: ../../reference/lexical_analysis.rst:434
#: ../../reference/lexical_analysis.rst:486
msgid "bytes literal"
msgstr "байтовый литерал"

#: ../../reference/lexical_analysis.rst:434
msgid "ASCII"
msgstr "ASCII"

#: ../../reference/lexical_analysis.rst:434
msgid "' (single quote)"
msgstr "' (одинарная кавычка)"

#: ../../reference/lexical_analysis.rst:434
msgid "\" (double quote)"
msgstr "\"(двойная кавычка)"

#: ../../reference/lexical_analysis.rst:434
msgid "u'"
msgstr "u'"

#: ../../reference/lexical_analysis.rst:434
msgid "u\""
msgstr "u\""

#: ../../reference/lexical_analysis.rst:475
msgid "triple-quoted string"
msgstr "строка в тройных кавычках"

#: ../../reference/lexical_analysis.rst:475
msgid "Unicode Consortium"
msgstr "Консорциум Юникод"

#: ../../reference/lexical_analysis.rst:475
msgid "raw string"
msgstr "необработанная строка"

#: ../../reference/lexical_analysis.rst:475
msgid "\"\"\""
msgstr "\"\"\""

#: ../../reference/lexical_analysis.rst:475
msgid "'''"
msgstr "'''"

#: ../../reference/lexical_analysis.rst:486
msgid "b'"
msgstr "b'"

#: ../../reference/lexical_analysis.rst:486
msgid "b\""
msgstr "b\""

#: ../../reference/lexical_analysis.rst:495
msgid "r'"
msgstr "r'"

#: ../../reference/lexical_analysis.rst:495
msgid "raw string literal"
msgstr "необработанный строковый литерал"

#: ../../reference/lexical_analysis.rst:495
msgid "r\""
msgstr "r\""

#: ../../reference/lexical_analysis.rst:514
msgid "f'"
msgstr "f'"

#: ../../reference/lexical_analysis.rst:514
#: ../../reference/lexical_analysis.rst:685
msgid "formatted string literal"
msgstr "форматированный строковый литерал"

#: ../../reference/lexical_analysis.rst:514
msgid "f\""
msgstr "f\""

#: ../../reference/lexical_analysis.rst:527
msgid "escape sequence"
msgstr "escape-последовательность"

#: ../../reference/lexical_analysis.rst:527
msgid "Standard C"
msgstr "Стандарт С"

#: ../../reference/lexical_analysis.rst:527
msgid "C"
msgstr "C"

#: ../../reference/lexical_analysis.rst:527
msgid "\\ (backslash)"
msgstr "\\ (обратная косая черта)"

#: ../../reference/lexical_analysis.rst:527
msgid "\\\\"
msgstr "\\\\"

#: ../../reference/lexical_analysis.rst:527
msgid "\\a"
msgstr "\\a"

#: ../../reference/lexical_analysis.rst:527
msgid "\\b"
msgstr "\\b"

#: ../../reference/lexical_analysis.rst:527
msgid "\\f"
msgstr "\\f"

#: ../../reference/lexical_analysis.rst:527
msgid "\\n"
msgstr "\\n"

#: ../../reference/lexical_analysis.rst:527
msgid "\\r"
msgstr "\\r"

#: ../../reference/lexical_analysis.rst:527
msgid "\\t"
msgstr "\\t"

#: ../../reference/lexical_analysis.rst:527
msgid "\\v"
msgstr "\\v"

#: ../../reference/lexical_analysis.rst:527
msgid "\\x"
msgstr "\\x"

#: ../../reference/lexical_analysis.rst:527
msgid "\\u"
msgstr "\\u"

#: ../../reference/lexical_analysis.rst:527
msgid "\\U"
msgstr "\\U"

#: ../../reference/lexical_analysis.rst:638
msgid "unrecognized escape sequence"
msgstr "нераспознанная escape-последовательность"

#: ../../reference/lexical_analysis.rst:685
msgid "interpolated string literal"
msgstr "интерполированный строковый литерал"

#: ../../reference/lexical_analysis.rst:685
msgid "string"
msgstr "строка"

#: ../../reference/lexical_analysis.rst:685
msgid "formatted literal"
msgstr "форматированный литерал"

#: ../../reference/lexical_analysis.rst:685
msgid "interpolated literal"
msgstr "интерполированный литерал"

#: ../../reference/lexical_analysis.rst:685
msgid "f-string"
msgstr "f-строка"

#: ../../reference/lexical_analysis.rst:685
msgid "fstring"
msgstr "f-строка"

#: ../../reference/lexical_analysis.rst:685
msgid "{} (curly brackets)"
msgstr "{} (фигурные скобки)"

#: ../../reference/lexical_analysis.rst:685
msgid "in formatted string literal"
msgstr "в форматированном строковом литерале"

#: ../../reference/lexical_analysis.rst:685
msgid "! (exclamation)"
msgstr "! (восклицание)"

#: ../../reference/lexical_analysis.rst:685
msgid ": (colon)"
msgstr ": (двоеточие)"

#: ../../reference/lexical_analysis.rst:685
msgid "= (equals)"
msgstr "= (равно)"

#: ../../reference/lexical_analysis.rst:685
msgid "for help in debugging using string literals"
msgstr "за помощь в отладке с использованием строковых литералов"

#: ../../reference/lexical_analysis.rst:850
msgid "number"
msgstr "число"

#: ../../reference/lexical_analysis.rst:850
msgid "numeric literal"
msgstr "числовой литерал"

#: ../../reference/lexical_analysis.rst:850
#: ../../reference/lexical_analysis.rst:863
msgid "integer literal"
msgstr "целочисленный литерал"

#: ../../reference/lexical_analysis.rst:850
msgid "floating point literal"
msgstr ""

#: ../../reference/lexical_analysis.rst:850
msgid "hexadecimal literal"
msgstr "шестнадцатеричный литерал"

#: ../../reference/lexical_analysis.rst:850
msgid "octal literal"
msgstr "восьмеричный литерал"

#: ../../reference/lexical_analysis.rst:850
msgid "binary literal"
msgstr "двоичный литерал"

#: ../../reference/lexical_analysis.rst:850
msgid "decimal literal"
msgstr "десятичный литерал"

#: ../../reference/lexical_analysis.rst:850
msgid "imaginary literal"
msgstr "воображаемый literal"

#: ../../reference/lexical_analysis.rst:850
msgid "complex literal"
msgstr "сложный литерал"

#: ../../reference/lexical_analysis.rst:863
msgid "0b"
msgstr "0b"

#: ../../reference/lexical_analysis.rst:863
msgid "0o"
msgstr "0o"

#: ../../reference/lexical_analysis.rst:863
msgid "0x"
msgstr "0x"

#: ../../reference/lexical_analysis.rst:863
#: ../../reference/lexical_analysis.rst:909
msgid "_ (underscore)"
msgstr "_ (подчеркивание)"

#: ../../reference/lexical_analysis.rst:863
#: ../../reference/lexical_analysis.rst:909
#: ../../reference/lexical_analysis.rst:941
msgid "in numeric literal"
msgstr "в числовом литерале"

#: ../../reference/lexical_analysis.rst:909
msgid ". (dot)"
msgstr ". (точка)"

#: ../../reference/lexical_analysis.rst:909
msgid "e"
msgstr "e"

#: ../../reference/lexical_analysis.rst:941
msgid "j"
msgstr "j"

#: ../../reference/lexical_analysis.rst:967
msgid "operators"
msgstr "операторы"

#: ../../reference/lexical_analysis.rst:984
msgid "delimiters"
msgstr "разделители"
