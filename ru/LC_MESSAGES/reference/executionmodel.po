# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-01 14:16+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr "Модель исполнения."

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "Структура программы."

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Программа Python состоит из блоков кода. :dfn:`block` — это фрагмент текста "
"программы Python, который выполняется как единое целое. Ниже приведены "
"блоки: модуль, тело функции и определение класса. Каждая команда, введенная "
"в интерактивном режиме, представляет собой блок. Файл сценария (файл, "
"передаваемый интерпретатору в качестве стандартного ввода или указанный в "
"качестве аргумента командной строки интерпретатора) представляет собой блок "
"кода. Команда сценария (команда, указанная в командной строке интерпретатора "
"с опцией :option:`-c`) представляет собой блок кода. Модуль, запускаемый как "
"скрипт верхнего уровня (как модуль ``__main__``) из командной строки с "
"использованием аргумента :option:`-m`, также является блоком кода. Строковый "
"аргумент, передаваемый встроенным функциям :func:`eval` и :func:`exec`, "
"представляет собой блок кода."

#: ../../reference/executionmodel.rst:33
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Блок кода выполняется в :dfn:`кадре исполнения<кадр исполнения>`. Кадр "
"содержит служебную информацию (использующуюся для отладки), и определяет, "
"где и как продолжается выполнение после завершения выполнения блока кода."

#: ../../reference/executionmodel.rst:40
msgid "Naming and binding"
msgstr "Именование и связывание."

#: ../../reference/executionmodel.rst:49
msgid "Binding of names"
msgstr "Связывание имён."

#: ../../reference/executionmodel.rst:55
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:'Имена' указывают на объекты. Имена вводятся операциями связывания "
"имени."

#: ../../reference/executionmodel.rst:59
msgid "The following constructs bind names:"
msgstr "Следующие конструкции связывают имена:"

#: ../../reference/executionmodel.rst:61
msgid "formal parameters to functions,"
msgstr "формальные параметры функций,"

#: ../../reference/executionmodel.rst:62
msgid "class definitions,"
msgstr "определения классов,"

#: ../../reference/executionmodel.rst:63
msgid "function definitions,"
msgstr "определения функций,"

#: ../../reference/executionmodel.rst:64
msgid "assignment expressions,"
msgstr "выражения присваивания,"

#: ../../reference/executionmodel.rst:65
msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ""
":ref:`targets <assignment>`, которые являются идентификаторами, если "
"встречаются в присваивании:"

#: ../../reference/executionmodel.rst:68
msgid ":keyword:`for` loop header,"
msgstr ":keyword:`for` заголовок цикла,"

#: ../../reference/executionmodel.rst:69
msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"после :keyword:`!as` в операторе :keyword:`with`, в предложении :keyword:"
"`Exception`, в предложении :keyword:`Exception* <Exception_star>` или в "
"шаблоне as при сопоставлении структурных шаблонов,"

#: ../../reference/executionmodel.rst:71
msgid "in a capture pattern in structural pattern matching"
msgstr "в шаблоне захвата при сопоставлении структурных шаблонов"

#: ../../reference/executionmodel.rst:73
msgid ":keyword:`import` statements."
msgstr ":keyword:`import` statements."

#: ../../reference/executionmodel.rst:74
msgid ":keyword:`type` statements."
msgstr ":keyword:`type` statements."

#: ../../reference/executionmodel.rst:75
msgid ":ref:`type parameter lists <type-params>`."
msgstr ":ref:`списки параметров типа <type-params>`."

#: ../../reference/executionmodel.rst:77
msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"Оператор :keyword:`!import` в форме ``from ... import *`` связывает все "
"имена, определенные в импортируемом модуле, за исключением тех, которые "
"начинаются с подчеркивания. Эту форму можно использовать только на уровне "
"модуля."

#: ../../reference/executionmodel.rst:81
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Цель назначения для инструкции \":keyword:`del`\" также считается получившей "
"назначение (хотя в действительности смысл в снятии связи с этого имени) ."

#: ../../reference/executionmodel.rst:84
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Любое назначение или импорт действует только в пределах блока класса, "
"функции или модуля (он является самым высокоуровневым блоком кода) ."

#: ../../reference/executionmodel.rst:89
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :term:`free variable`."
msgstr ""
"Если имя привязано к блоку, оно является локальной переменной этого блока, "
"если только оно не объявлено как :keyword:`nonlocal` или :keyword:`global`. "
"Если имя привязано на уровне модуля, это глобальная переменная. (Переменные "
"блока кода модуля являются локальными и глобальными.) Если переменная "
"используется в блоке кода, но не определена там, это :term:`свободная "
"переменная`."

#: ../../reference/executionmodel.rst:95
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Каждое появление имени в тексте программы указывает на то, что назначено "
"этому имени в данном самом внутреннем функциональном блоке."

#: ../../reference/executionmodel.rst:101
msgid "Resolution of names"
msgstr "Нахождение значения имени."

#: ../../reference/executionmodel.rst:105
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`Область видимости<область видимости>` определяет видимость имени "
"внутри блока. Если локальная переменная определена в блоке, то ее область "
"видимости включает этот блок. Если это определение происходит в блоке "
"функции, то ее область видимости распространяется на любые блоки, "
"содержащиеся в данном блоке функции, если только содержащийся блок не вводит "
"своё назначение данному имени."

#: ../../reference/executionmodel.rst:113
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"Если имя упоминается в блоке кода, то его значение ищется последовательно "
"переходя от одной области видимости к следующей непосредственно объемлющей "
"до первой содержащей определение данного имени. Множество всех таких "
"областей видимости, используемых блоком кода - называется :dfn:"
"`окружение<окружением>` данного блока."

#: ../../reference/executionmodel.rst:121
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Когда имя вообще не найдено - вызывается исключение \":exc:`NameError`\" . "
"Если текущая область видимости образована функцией и если искомое имя "
"указывает на локальную переменную, до связывания которой исполнение функции "
"ещё не дошло - вызывается исключение \":exc:`UnboundLocalError`\" , которое "
"является подклассом для \":exc:`NameError`\" ."

#: ../../reference/executionmodel.rst:127
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"Если операция привязки имени происходит где-нибудь внутри блока кода, все "
"использования имени внутри блока рассматриваются как ссылки на текущий блок. "
"Это может привести к ошибкам, если имя используется внутри блока до его "
"привязки. Это правило тонкое. В Python отсутствуют объявления, и он "
"позволяет выполнять операции привязки имен в любом месте блока кода. "
"Локальные переменные блока кода можно определить путем сканирования всего "
"текста блока на предмет операций привязки имени. Примеры см. в разделе часто "
"задаваемых вопросов по UnboundLocalError <faq-unboundlocalerror>."

#: ../../reference/executionmodel.rst:136
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched next. If the names are also "
"not found in the builtins namespace, new variables are created in the global "
"namespace. The global statement must precede all uses of the listed names."
msgstr ""
"Если оператор :keyword:`global` встречается внутри блока, все использования "
"имен, указанных в операторе, относятся к привязкам этих имен в пространстве "
"имен верхнего уровня. Имена разрешаются в пространстве имен верхнего уровня "
"путем поиска в глобальном пространстве имен, т. е. пространстве имен модуля, "
"содержащего блок кода, и пространстве имен встроенных модулей, пространстве "
"имен модуля :mod:`builtins`. Сначала выполняется поиск в глобальном "
"пространстве имен. Если имена там не найдены, следующий поиск осуществляется "
"во встроенном пространстве имен. Если имена также не найдены во встроенном "
"пространстве имен, новые переменные создаются в глобальном пространстве "
"имен. Глобальный оператор должен предшествовать любому использованию "
"перечисленных имен."

#: ../../reference/executionmodel.rst:146
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"Инструкция \":keyword:`global`\" остаётся в силе в тех же рамках, в каких "
"действует связывание имени, произведённое в том же блоке. Если не связанная "
"в данном блоке переменная (\"свободная\") упоминается в любом месте этого же "
"блока в инструкции \":keyword:`global`\" , то эта переменная сразу считается "
"глобальной."

#: ../../reference/executionmodel.rst:152
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope. :ref:`Type parameters <type-params>` cannot be "
"rebound with the :keyword:`!nonlocal` statement."
msgstr ""
"Оператор :keyword:`nonlocal` заставляет соответствующие имена ссылаться на "
"ранее связанные переменные в ближайшей области охватывающей функции. :exc:"
"`SyntaxError` возникает во время компиляции, если данное имя не существует "
"ни в одной области охватывающей функции. :ref:`Параметры типа <type-params>` "
"не могут быть повторно привязаны с помощью оператора :keyword:`!nonlocal`."

#: ../../reference/executionmodel.rst:160
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"Пространство имён для модуля автоматически создаётся, когда модуль в первый "
"раз импортируется. Главный модуль скрипта всегда называется \":mod:"
"`__main__`\" ."

#: ../../reference/executionmodel.rst:163
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods. This includes comprehensions and generator "
"expressions, but it does not include :ref:`annotation scopes <annotation-"
"scopes>`, which have access to their enclosing class scopes. This means that "
"the following will fail::"
msgstr ""
"Блоки определения классов и аргументы :func:`exec` и :func:`eval` являются "
"особыми в контексте разрешения имен. Определение класса — это исполняемый "
"оператор, который может использовать и определять имена. Эти ссылки следуют "
"обычным правилам разрешения имен, за исключением того, что несвязанные "
"локальные переменные ищутся в глобальном пространстве имен. Пространство "
"имен определения класса становится словарем атрибутов класса. Область имен, "
"определенных в блоке классов, ограничена блоком классов; оно не "
"распространяется на блоки кода методов. Это включает в себя понимания и "
"выражения-генераторы, но не включает :ref:`области аннотаций <annotation-"
"scopes>`, которые имеют доступ к областям своих включающих классов. Это "
"означает, что следующее не удастся:"

#: ../../reference/executionmodel.rst:176
msgid ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"
msgstr ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"

#: ../../reference/executionmodel.rst:180
msgid "However, the following will succeed::"
msgstr "Тем не менее, следующее будет успешным:"

#: ../../reference/executionmodel.rst:182
msgid ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"
msgstr ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"

#: ../../reference/executionmodel.rst:191
msgid "Annotation scopes"
msgstr "Области аннотаций"

#: ../../reference/executionmodel.rst:193
msgid ""
":term:`Annotations <annotation>`, :ref:`type parameter lists <type-params>` "
"and :keyword:`type` statements introduce *annotation scopes*, which behave "
"mostly like function scopes, but with some exceptions discussed below."
msgstr ""

#: ../../reference/executionmodel.rst:198
msgid "Annotation scopes are used in the following contexts:"
msgstr "Области аннотаций используются в следующих контекстах:"

#: ../../reference/executionmodel.rst:200
msgid ":term:`Function annotations <function annotation>`."
msgstr ""

#: ../../reference/executionmodel.rst:201
msgid ":term:`Variable annotations <variable annotation>`."
msgstr ""

#: ../../reference/executionmodel.rst:202
msgid ""
"Type parameter lists for :ref:`generic type aliases <generic-type-aliases>`."
msgstr ""
"Списки параметров типа для :ref:`псевдонимов общего типа <generic-type-"
"aliases>`."

#: ../../reference/executionmodel.rst:203
msgid ""
"Type parameter lists for :ref:`generic functions <generic-functions>`. A "
"generic function's annotations are executed within the annotation scope, but "
"its defaults and decorators are not."
msgstr ""
"Введите списки параметров для :ref:`generic function <generic-functions>`. "
"Аннотации универсальной функции выполняются в области аннотации, а ее "
"значения по умолчанию и декораторы — нет."

#: ../../reference/executionmodel.rst:206
msgid ""
"Type parameter lists for :ref:`generic classes <generic-classes>`. A generic "
"class's base classes and keyword arguments are executed within the "
"annotation scope, but its decorators are not."
msgstr ""
"Списки параметров типа для :ref:`универсальных классов <generic-classes>`. "
"Базовые классы и ключевые аргументы универсального класса выполняются в "
"области аннотации, а его декораторы — нет."

#: ../../reference/executionmodel.rst:209
msgid ""
"The bounds, constraints, and default values for type parameters (:ref:"
"`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"Границы, ограничения и значения по умолчанию для параметров типа (:ref:"
"`лениво оцениваемые <lazy-evaluation>`)."

#: ../../reference/executionmodel.rst:211
msgid "The value of type aliases (:ref:`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"Значение псевдонимов типов (:ref:`лениво оцениваемое <lazy-evaluation>`)."

#: ../../reference/executionmodel.rst:213
msgid "Annotation scopes differ from function scopes in the following ways:"
msgstr "Области аннотаций отличаются от областей функций следующим образом:"

#: ../../reference/executionmodel.rst:215
msgid ""
"Annotation scopes have access to their enclosing class namespace. If an "
"annotation scope is immediately within a class scope, or within another "
"annotation scope that is immediately within a class scope, the code in the "
"annotation scope can use names defined in the class scope as if it were "
"executed directly within the class body. This contrasts with regular "
"functions defined within classes, which cannot access names defined in the "
"class scope."
msgstr ""
"Области аннотаций имеют доступ к пространству имен включающего их класса. "
"Если область аннотации находится непосредственно в области класса или внутри "
"другой области аннотации, которая находится непосредственно в области "
"класса, код в области аннотации может использовать имена, определенные в "
"области класса, как если бы он выполнялся непосредственно внутри тела "
"класса. Это контрастирует с обычными функциями, определенными внутри "
"классов, которые не могут получить доступ к именам, определенным в области "
"действия класса."

#: ../../reference/executionmodel.rst:221
msgid ""
"Expressions in annotation scopes cannot contain :keyword:`yield`, ``yield "
"from``, :keyword:`await`, or :token:`:= <python-grammar:"
"assignment_expression>` expressions. (These expressions are allowed in other "
"scopes contained within the annotation scope.)"
msgstr ""
"Выражения в областях аннотаций не могут содержать выражения :keyword:"
"`yield`, ``yield from``, :keyword:`await` или :token:`:= <python-grammar:"
"assignment_expression>`. (Эти выражения разрешены в других областях, "
"содержащихся в области аннотации.)"

#: ../../reference/executionmodel.rst:225
msgid ""
"Names defined in annotation scopes cannot be rebound with :keyword:"
"`nonlocal` statements in inner scopes. This includes only type parameters, "
"as no other syntactic elements that can appear within annotation scopes can "
"introduce new names."
msgstr ""
"Имена, определенные в областях аннотаций, не могут быть повторно связаны с "
"операторами :keyword:`nonlocal` во внутренних областях. Сюда входят только "
"параметры типа, поскольку никакие другие синтаксические элементы, которые "
"могут появляться в областях аннотаций, не могут вводить новые имена."

#: ../../reference/executionmodel.rst:228
msgid ""
"While annotation scopes have an internal name, that name is not reflected in "
"the :term:`qualified name` of objects defined within the scope. Instead, "
"the :attr:`~definition.__qualname__` of such objects is as if the object "
"were defined in the enclosing scope."
msgstr ""
"Хотя области аннотаций имеют внутреннее имя, это имя не отражается в :term:"
"`полном имени` объектов, определенных в этой области. Вместо этого :attr:"
"`~definition.__qualname__` таких объектов выглядит так, как если бы объект "
"был определен во внешней области видимости."

#: ../../reference/executionmodel.rst:233
msgid "Annotation scopes were introduced in Python 3.12 as part of :pep:`695`."
msgstr ""
"Области аннотаций были представлены в Python 3.12 как часть :pep:`695`."

#: ../../reference/executionmodel.rst:236
msgid ""
"Annotation scopes are also used for type parameter defaults, as introduced "
"by :pep:`696`."
msgstr ""
"Области аннотаций также используются для значений параметров типа по "
"умолчанию, как это представлено в :pep:`696`."

#: ../../reference/executionmodel.rst:240
msgid ""
"Annotation scopes are now also used for annotations, as specified in :pep:"
"`649` and :pep:`749`."
msgstr ""

#: ../../reference/executionmodel.rst:247
msgid "Lazy evaluation"
msgstr "Ленивая оценка"

#: ../../reference/executionmodel.rst:249
msgid ""
"Most annotation scopes are *lazily evaluated*. This includes annotations, "
"the values of type aliases created through the :keyword:`type` statement, "
"and the bounds, constraints, and default values of type variables created "
"through the :ref:`type parameter syntax <type-params>`. This means that they "
"are not evaluated when the type alias or type variable is created, or when "
"the object carrying annotations is created. Instead, they are only evaluated "
"when necessary, for example when the ``__value__`` attribute on a type alias "
"is accessed."
msgstr ""

#: ../../reference/executionmodel.rst:258
msgid "Example:"
msgstr "Пример:"

#: ../../reference/executionmodel.rst:260
msgid ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"
msgstr ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"

#: ../../reference/executionmodel.rst:274
msgid ""
"Here the exception is raised only when the ``__value__`` attribute of the "
"type alias or the ``__bound__`` attribute of the type variable is accessed."
msgstr ""
"Здесь исключение возникает только при доступе к атрибуту ``__value__`` "
"псевдонима типа или атрибуту ``__bound__`` переменной типа."

#: ../../reference/executionmodel.rst:278
msgid ""
"This behavior is primarily useful for references to types that have not yet "
"been defined when the type alias or type variable is created. For example, "
"lazy evaluation enables creation of mutually recursive type aliases::"
msgstr ""
"Такое поведение в первую очередь полезно для ссылок на типы, которые еще не "
"были определены при создании псевдонима типа или переменной типа. Например, "
"ленивые вычисления позволяют создавать псевдонимы взаимно рекурсивных типов:"

#: ../../reference/executionmodel.rst:282
msgid ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"
msgstr ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"

#: ../../reference/executionmodel.rst:288
msgid ""
"Lazily evaluated values are evaluated in :ref:`annotation scope <annotation-"
"scopes>`, which means that names that appear inside the lazily evaluated "
"value are looked up as if they were used in the immediately enclosing scope."
msgstr ""
"Лениво вычисляемые значения оцениваются в :ref:`области аннотации "
"<annotation-scopes>`, что означает, что имена, которые появляются внутри "
"лениво вычисляемого значения, просматриваются так, как если бы они "
"использовались в непосредственно охватывающей области."

#: ../../reference/executionmodel.rst:297
msgid "Builtins and restricted execution"
msgstr "Встроенные методы и запрещенное исполнение"

#: ../../reference/executionmodel.rst:303
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"Пользователи не должны влазить в \"``__builtins__``\" - его содержание - это "
"исключительно особенности реализации. Пользователи, желающие переопределить "
"значения в этом встроенном пространстве имён должны импортировать модуль \":"
"mod:`builtins`\" и модифицировать соответственно его атрибуты."

#: ../../reference/executionmodel.rst:308
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"Пространство имен встроенных функций, связанное с выполнением блока кода, "
"фактически находится путем поиска имени ``__builtins__`` в его глобальном "
"пространстве имен; это должен быть словарь или модуль (в последнем случае "
"используется словарь модуля). По умолчанию в модуле :mod:`__main__` "
"``__builtins__`` является встроенным модулем :mod:`builtins`; в любом другом "
"модуле ``__builtins__`` является псевдонимом словаря самого модуля :mod:"
"`builtins`."

#: ../../reference/executionmodel.rst:320
msgid "Interaction with dynamic features"
msgstr "Взаимодействие с динамическими свойствами."

#: ../../reference/executionmodel.rst:322
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"Поиск значения имени несвязанной переменной происходит во время исполнения, "
"а не компиляции. Это значит, что следующий код напечатает 42 ::"

#: ../../reference/executionmodel.rst:325
msgid ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"
msgstr ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"

#: ../../reference/executionmodel.rst:333
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"Функции \":func:`eval`\" и \":func:`exec`\" не имеют доступа ко всему "
"окружению для интерпретации имён. Значения имён могут искаться в локальной и "
"в глобальной областях имён относительно места вызова. Свободные переменные "
"не ищутся в области имён одним уровнем выше, за исключением глобальной. (Это "
"ограничение происходит от того, что код, исполняемый этими инструкциями не "
"доступен во время компиляции данного модуля.) Функции \":func:`exec`\" и \":"
"func:`eval`\" имеют необязательные аргументы для переопределения глобальной "
"и локальной областей имён. Если задан только один аргумент, то он "
"используется для обеих областей."

#: ../../reference/executionmodel.rst:347
msgid "Exceptions"
msgstr "Исключения"

#: ../../reference/executionmodel.rst:358
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"Исключения являются средством прерывания нормального хода исполнения кода "
"для обработки ошибок или других исключительных ситуаций. Исключение "
"*возникает* в месте, где обнаружена ошибка; оно может быть *обработано* в "
"текущем блоке кода или в любом блоке кода, в котором прямо или косвенно "
"вызван тот блок кода, в котором возникла ошибка."

#: ../../reference/executionmodel.rst:364
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Интерпретатор Питона исполняет исключение, когда обнаруживает ошибку "
"исполнения (например деление на ноль) . Программа на Питоне также может явно "
"вызывать исключение инструкцией \":keyword:`raise`\" . Обработчики "
"исключений задаются инструкцией \":keyword:`try` ... :keyword:`except`\" . "
"Отдел \":keyword:`finally`\" этой инструкции может быть использован для "
"задания кода, который исполняется независимо от того, произошло ли "
"исключение в соответствующем блоке \":keyword:`try` ... :keyword:"
"`except`\" ( и который не является функцией, получающей в качестве аргумента "
"идентификатор ошибки, и не является собственно обработчиком ошибки) ."

#: ../../reference/executionmodel.rst:374
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Питон использует ограничительную модель обработки ошибок: обработчик "
"исключения может проанализировать ситуацию и продолжить исполнение за "
"пределами блока \":keyword:`try` ... :keyword:`except`\" , но не может "
"исправить причину ошибки и всё-таки выполнить сбойную операцию (не считая "
"того, чтобы вызвать весь проблемный фрагмент с самого начала) ."

#: ../../reference/executionmodel.rst:381
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"Когда исключение вообще не обрабатывается, интерпретатор прекращает "
"выполнение программы или возвращается к интерактивному основному циклу. В "
"любом случае он печатает обратную трассировку стека, за исключением случаев, "
"когда исключением является :exc:`SystemExit`."

#: ../../reference/executionmodel.rst:385
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"Исключения идентифицируются экземплярами класса. Предложение :keyword:"
"`Exception` выбирается в зависимости от класса экземпляра: оно должно "
"ссылаться на класс экземпляра или на его :term:`невиртуальный базовый класс "
"<абстрактный базовый класс>`. Экземпляр может быть получен обработчиком и "
"содержать дополнительную информацию об исключительном состоянии."

#: ../../reference/executionmodel.rst:393
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"Сообщения о исключениях не являются частью API Питона. Их содержание может "
"меняться от одной версии Питона к другой без предупреждения и код, который "
"будет запускаться на разных версиях интерпретатора не должен полагаться на "
"них."

#: ../../reference/executionmodel.rst:397
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Также, смотрите описание инструкции \" :keyword:`try`\" в разделе :ref:`try` "
"и инструкции \":keyword:`raise`\" в разделе :ref:`raise`."

#: ../../reference/executionmodel.rst:404
msgid "Runtime Components"
msgstr ""

#: ../../reference/executionmodel.rst:407
msgid "General Computing Model"
msgstr ""

#: ../../reference/executionmodel.rst:409
msgid ""
"Python's execution model does not operate in a vacuum.  It runs on a host "
"machine and through that host's runtime environment, including its operating "
"system (OS), if there is one.  When a program runs, the conceptual layers of "
"how it runs on the host look something like this:"
msgstr ""

#: ../../reference/executionmodel.rst:415
#: ../../reference/executionmodel.rst:474
msgid "**host machine**"
msgstr ""

#: ../../reference/executionmodel.rst:416
#: ../../reference/executionmodel.rst:475
msgid "**process** (global resources)"
msgstr ""

#: ../../reference/executionmodel.rst:417
msgid "**thread** (runs machine code)"
msgstr ""

#: ../../reference/executionmodel.rst:419
msgid ""
"Each process represents a program running on the host.  Think of each "
"process itself as the data part of its program.  Think of the process' "
"threads as the execution part of the program.  This distinction will be "
"important to understand the conceptual Python runtime."
msgstr ""

#: ../../reference/executionmodel.rst:424
msgid ""
"The process, as the data part, is the execution context in which the program "
"runs.  It mostly consists of the set of resources assigned to the program by "
"the host, including memory, signals, file handles, sockets, and environment "
"variables."
msgstr ""

#: ../../reference/executionmodel.rst:429
msgid ""
"Processes are isolated and independent from one another.  (The same is true "
"for hosts.)  The host manages the process' access to its assigned resources, "
"in addition to coordinating between processes."
msgstr ""

#: ../../reference/executionmodel.rst:433
msgid ""
"Each thread represents the actual execution of the program's machine code, "
"running relative to the resources assigned to the program's process.  It's "
"strictly up to the host how and when that execution takes place."
msgstr ""

#: ../../reference/executionmodel.rst:438
msgid ""
"From the point of view of Python, a program always starts with exactly one "
"thread.  However, the program may grow to run in multiple simultaneous "
"threads.  Not all hosts support multiple threads per process, but most do.  "
"Unlike processes, threads in a process are not isolated and independent from "
"one another.  Specifically, all threads in a process share all of the "
"process' resources."
msgstr ""

#: ../../reference/executionmodel.rst:445
msgid ""
"The fundamental point of threads is that each one does *run* independently, "
"at the same time as the others.  That may be only conceptually at the same "
"time (\"concurrently\") or physically (\"in parallel\").  Either way, the "
"threads effectively run at a non-synchronized rate."
msgstr ""

#: ../../reference/executionmodel.rst:453
msgid ""
"That non-synchronized rate means none of the process' memory is guaranteed "
"to stay consistent for the code running in any given thread.  Thus multi-"
"threaded programs must take care to coordinate access to intentionally "
"shared resources.  Likewise, they must take care to be absolutely diligent "
"about not accessing any *other* resources in multiple threads; otherwise two "
"threads running at the same time might accidentally interfere with each "
"other's use of some shared data.  All this is true for both Python programs "
"and the Python runtime."
msgstr ""

#: ../../reference/executionmodel.rst:463
msgid ""
"The cost of this broad, unstructured requirement is the tradeoff for the "
"kind of raw concurrency that threads provide.  The alternative to the "
"required discipline generally means dealing with non-deterministic bugs and "
"data corruption."
msgstr ""

#: ../../reference/executionmodel.rst:469
msgid "Python Runtime Model"
msgstr ""

#: ../../reference/executionmodel.rst:471
msgid ""
"The same conceptual layers apply to each Python program, with some extra "
"data layers specific to Python:"
msgstr ""

#: ../../reference/executionmodel.rst:476
msgid "Python global runtime (*state*)"
msgstr ""

#: ../../reference/executionmodel.rst:477
msgid "Python interpreter (*state*)"
msgstr ""

#: ../../reference/executionmodel.rst:478
msgid "**thread** (runs Python bytecode and \"C-API\")"
msgstr ""

#: ../../reference/executionmodel.rst:479
msgid "Python thread *state*"
msgstr ""

#: ../../reference/executionmodel.rst:481
msgid ""
"At the conceptual level: when a Python program starts, it looks exactly like "
"that diagram, with one of each.  The runtime may grow to include multiple "
"interpreters, and each interpreter may grow to include multiple thread "
"states."
msgstr ""

#: ../../reference/executionmodel.rst:488
msgid ""
"A Python implementation won't necessarily implement the runtime layers "
"distinctly or even concretely.  The only exception is places where distinct "
"layers are directly specified or exposed to users, like through the :mod:"
"`threading` module."
msgstr ""

#: ../../reference/executionmodel.rst:495
msgid ""
"The initial interpreter is typically called the \"main\" interpreter. Some "
"Python implementations, like CPython, assign special roles to the main "
"interpreter."
msgstr ""

#: ../../reference/executionmodel.rst:499
msgid ""
"Likewise, the host thread where the runtime was initialized is known as the "
"\"main\" thread.  It may be different from the process' initial thread, "
"though they are often the same.  In some cases \"main thread\" may be even "
"more specific and refer to the initial thread state. A Python runtime might "
"assign specific responsibilities to the main thread, such as handling "
"signals."
msgstr ""

#: ../../reference/executionmodel.rst:506
msgid ""
"As a whole, the Python runtime consists of the global runtime state, "
"interpreters, and thread states.  The runtime ensures all that state stays "
"consistent over its lifetime, particularly when used with multiple host "
"threads."
msgstr ""

#: ../../reference/executionmodel.rst:511
msgid ""
"The global runtime, at the conceptual level, is just a set of interpreters.  "
"While those interpreters are otherwise isolated and independent from one "
"another, they may share some data or other resources.  The runtime is "
"responsible for managing these global resources safely.  The actual nature "
"and management of these resources is implementation-specific.  Ultimately, "
"the external utility of the global runtime is limited to managing "
"interpreters."
msgstr ""

#: ../../reference/executionmodel.rst:519
msgid ""
"In contrast, an \"interpreter\" is conceptually what we would normally think "
"of as the (full-featured) \"Python runtime\".  When machine code executing "
"in a host thread interacts with the Python runtime, it calls into Python in "
"the context of a specific interpreter."
msgstr ""

#: ../../reference/executionmodel.rst:526
msgid ""
"The term \"interpreter\" here is not the same as the \"bytecode "
"interpreter\", which is what regularly runs in threads, executing compiled "
"Python code."
msgstr ""

#: ../../reference/executionmodel.rst:530
msgid ""
"In an ideal world, \"Python runtime\" would refer to what we currently call "
"\"interpreter\".  However, it's been called \"interpreter\" at least since "
"introduced in 1997 (`CPython:a027efa5b`_)."
msgstr ""

#: ../../reference/executionmodel.rst:536
msgid ""
"Each interpreter completely encapsulates all of the non-process-global, non-"
"thread-specific state needed for the Python runtime to work. Notably, the "
"interpreter's state persists between uses.  It includes fundamental data "
"like :data:`sys.modules`.  The runtime ensures multiple threads using the "
"same interpreter will safely share it between them."
msgstr ""

#: ../../reference/executionmodel.rst:543
msgid ""
"A Python implementation may support using multiple interpreters at the same "
"time in the same process.  They are independent and isolated from one "
"another.  For example, each interpreter has its own :data:`sys.modules`."
msgstr ""

#: ../../reference/executionmodel.rst:548
msgid ""
"For thread-specific runtime state, each interpreter has a set of thread "
"states, which it manages, in the same way the global runtime contains a set "
"of interpreters.  It can have thread states for as many host threads as it "
"needs.  It may even have multiple thread states for the same host thread, "
"though that isn't as common."
msgstr ""

#: ../../reference/executionmodel.rst:554
msgid ""
"Each thread state, conceptually, has all the thread-specific runtime data an "
"interpreter needs to operate in one host thread.  The thread state includes "
"the current raised exception and the thread's Python call stack.  It may "
"include other thread-specific resources."
msgstr ""

#: ../../reference/executionmodel.rst:561
msgid ""
"The term \"Python thread\" can sometimes refer to a thread state, but "
"normally it means a thread created using the :mod:`threading` module."
msgstr ""

#: ../../reference/executionmodel.rst:564
msgid ""
"Each thread state, over its lifetime, is always tied to exactly one "
"interpreter and exactly one host thread.  It will only ever be used in that "
"thread and with that interpreter."
msgstr ""

#: ../../reference/executionmodel.rst:568
msgid ""
"Multiple thread states may be tied to the same host thread, whether for "
"different interpreters or even the same interpreter.  However, for any given "
"host thread, only one of the thread states tied to it can be used by the "
"thread at a time."
msgstr ""

#: ../../reference/executionmodel.rst:573
msgid ""
"Thread states are isolated and independent from one another and don't share "
"any data, except for possibly sharing an interpreter and objects or other "
"resources belonging to that interpreter."
msgstr ""

#: ../../reference/executionmodel.rst:577
msgid ""
"Once a program is running, new Python threads can be created using the :mod:"
"`threading` module (on platforms and Python implementations that support "
"threads).  Additional processes can be created using the :mod:`os`, :mod:"
"`subprocess`, and :mod:`multiprocessing` modules. Interpreters can be "
"created and used with the :mod:`~concurrent.interpreters` module.  "
"Coroutines (async) can be run using :mod:`asyncio` in each interpreter, "
"typically only in a single thread (often the main thread)."
msgstr ""

#: ../../reference/executionmodel.rst:588
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/executionmodel.rst:589
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"Это ограничение происходит от того, что код, исполняемый этими инструкциями "
"не доступен во время компиляции данного модуля."

#: ../../reference/executionmodel.rst:8
msgid "execution model"
msgstr "модель исполнения"

#: ../../reference/executionmodel.rst:8
msgid "code"
msgstr "код"

#: ../../reference/executionmodel.rst:8 ../../reference/executionmodel.rst:17
msgid "block"
msgstr "блокировать"

#: ../../reference/executionmodel.rst:31 ../../reference/executionmodel.rst:299
msgid "execution"
msgstr "execution"

#: ../../reference/executionmodel.rst:31
msgid "frame"
msgstr "фрейм"

#: ../../reference/executionmodel.rst:42
msgid "namespace"
msgstr "пространство имён"

#: ../../reference/executionmodel.rst:42 ../../reference/executionmodel.rst:103
msgid "scope"
msgstr "scope"

#: ../../reference/executionmodel.rst:51
msgid "name"
msgstr "имя"

#: ../../reference/executionmodel.rst:51
msgid "binding"
msgstr "binding"

#: ../../reference/executionmodel.rst:57
msgid "from"
msgstr "от"

#: ../../reference/executionmodel.rst:57
msgid "import statement"
msgstr "import statement"

#: ../../reference/executionmodel.rst:87
msgid "free"
msgstr "free"

#: ../../reference/executionmodel.rst:87
msgid "variable"
msgstr "переменная"

#: ../../reference/executionmodel.rst:111
msgid "environment"
msgstr "environment"

#: ../../reference/executionmodel.rst:117
msgid "NameError (built-in exception)"
msgstr "NameError (встроенное исключение)"

#: ../../reference/executionmodel.rst:117
msgid "UnboundLocalError"
msgstr "UnboundLocalError"

#: ../../reference/executionmodel.rst:158
msgid "module"
msgstr "модуль"

#: ../../reference/executionmodel.rst:158
msgid "__main__"
msgstr "__main__"

#: ../../reference/executionmodel.rst:299
msgid "restricted"
msgstr "ограниченный"

#: ../../reference/executionmodel.rst:349
msgid "exception"
msgstr "exception"

#: ../../reference/executionmodel.rst:351
msgid "raise an exception"
msgstr "вызвать исключение"

#: ../../reference/executionmodel.rst:351
msgid "handle an exception"
msgstr "обрабатывать исключение"

#: ../../reference/executionmodel.rst:351
msgid "exception handler"
msgstr "обработчик исключений"

#: ../../reference/executionmodel.rst:351
msgid "errors"
msgstr "ошибки"

#: ../../reference/executionmodel.rst:351
msgid "error handling"
msgstr "обработка ошибок"

#: ../../reference/executionmodel.rst:372
msgid "termination model"
msgstr "модель завершения"

#: ../../reference/executionmodel.rst:379
msgid "SystemExit (built-in exception)"
msgstr "SystemExit (встроенное исключение)"
