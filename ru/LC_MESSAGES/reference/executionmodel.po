# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr "Модель исполнения."

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "Структура программы."

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Программа Python состоит из блоков кода. :dfn:`block` — это фрагмент текста "
"программы Python, который выполняется как единое целое. Ниже приведены "
"блоки: модуль, тело функции и определение класса. Каждая команда, введенная "
"в интерактивном режиме, представляет собой блок. Файл сценария (файл, "
"передаваемый интерпретатору в качестве стандартного ввода или указанный в "
"качестве аргумента командной строки интерпретатора) представляет собой блок "
"кода. Команда сценария (команда, указанная в командной строке интерпретатора "
"с опцией :option:`-c`) представляет собой блок кода. Модуль, запускаемый как "
"скрипт верхнего уровня (как модуль ``__main__``) из командной строки с "
"использованием аргумента :option:`-m`, также является блоком кода. Строковый "
"аргумент, передаваемый встроенным функциям :func:`eval` и :func:`exec`, "
"представляет собой блок кода."

#: ../../reference/executionmodel.rst:33
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Блок кода выполняется в :dfn:`кадре исполнения<кадр исполнения>`. Кадр "
"содержит служебную информацию (использующуюся для отладки), и определяет, "
"где и как продолжается выполнение после завершения выполнения блока кода."

#: ../../reference/executionmodel.rst:40
msgid "Naming and binding"
msgstr "Именование и связывание."

#: ../../reference/executionmodel.rst:49
msgid "Binding of names"
msgstr "Связывание имён."

#: ../../reference/executionmodel.rst:55
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:'Имена' указывают на объекты. Имена вводятся операциями связывания "
"имени."

#: ../../reference/executionmodel.rst:59
msgid "The following constructs bind names:"
msgstr "Следующие конструкции связывают имена:"

#: ../../reference/executionmodel.rst:61
msgid "formal parameters to functions,"
msgstr "формальные параметры функций,"

#: ../../reference/executionmodel.rst:62
msgid "class definitions,"
msgstr "определения классов,"

#: ../../reference/executionmodel.rst:63
msgid "function definitions,"
msgstr "определения функций,"

#: ../../reference/executionmodel.rst:64
msgid "assignment expressions,"
msgstr "выражения присваивания,"

#: ../../reference/executionmodel.rst:65
msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ""
":ref:`targets <assignment>`, которые являются идентификаторами, если "
"встречаются в присваивании:"

#: ../../reference/executionmodel.rst:68
msgid ":keyword:`for` loop header,"
msgstr ":keyword:`for` заголовок цикла,"

#: ../../reference/executionmodel.rst:69
msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"после :keyword:`!as` в операторе :keyword:`with`, в предложении :keyword:"
"`Exception`, в предложении :keyword:`Exception* <Exception_star>` или в "
"шаблоне as при сопоставлении структурных шаблонов,"

#: ../../reference/executionmodel.rst:71
msgid "in a capture pattern in structural pattern matching"
msgstr "в шаблоне захвата при сопоставлении структурных шаблонов"

#: ../../reference/executionmodel.rst:73
msgid ":keyword:`import` statements."
msgstr ":keyword:`import` statements."

#: ../../reference/executionmodel.rst:75
msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"Оператор :keyword:`!import` в форме ``from ... import *`` связывает все "
"имена, определенные в импортируемом модуле, за исключением тех, которые "
"начинаются с подчеркивания. Эту форму можно использовать только на уровне "
"модуля."

#: ../../reference/executionmodel.rst:79
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Цель назначения для инструкции \":keyword:`del`\" также считается получившей "
"назначение (хотя в действительности смысл в снятии связи с этого имени) ."

#: ../../reference/executionmodel.rst:82
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Любое назначение или импорт действует только в пределах блока класса, "
"функции или модуля (он является самым высокоуровневым блоком кода) ."

#: ../../reference/executionmodel.rst:87
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :dfn:`free variable`."
msgstr ""
"Если имя было назначено в блоке , то оно является локальной переменной этого "
"блока, если не объявлено как не локальное (:keyword:`nonlocal`) или "
"глобальное (:keyword:`global`) . Если имя назначено на уровне модуля - оно "
"является глобальной переменной. (Переменные в блоке кода модуля являются с "
"разных точек зрения и локальными и глобальными.) Если переменная "
"используется в блоке кода но не определена непосредственно в нём (но "
"определена в окружении), то она является \":dfn:`свободной "
"переменной<свободная переменная>`\" ."

#: ../../reference/executionmodel.rst:93
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Каждое появление имени в тексте программы указывает на то, что назначено "
"этому имени в данном самом внутреннем функциональном блоке."

#: ../../reference/executionmodel.rst:99
msgid "Resolution of names"
msgstr "Нахождение значения имени."

#: ../../reference/executionmodel.rst:103
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`Область видимости<область видимости>` определяет видимость имени "
"внутри блока. Если локальная переменная определена в блоке, то ее область "
"видимости включает этот блок. Если это определение происходит в блоке "
"функции, то ее область видимости распространяется на любые блоки, "
"содержащиеся в данном блоке функции, если только содержащийся блок не вводит "
"своё назначение данному имени."

#: ../../reference/executionmodel.rst:111
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"Если имя упоминается в блоке кода, то его значение ищется последовательно "
"переходя от одной области видимости к следующей непосредственно объемлющей "
"до первой содержащей определение данного имени. Множество всех таких "
"областей видимости, используемых блоком кода - называется :dfn:"
"`окружение<окружением>` данного блока."

#: ../../reference/executionmodel.rst:119
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Когда имя вообще не найдено - вызывается исключение \":exc:`NameError`\" . "
"Если текущая область видимости образована функцией и если искомое имя "
"указывает на локальную переменную, до связывания которой исполнение функции "
"ещё не дошло - вызывается исключение \":exc:`UnboundLocalError`\" , которое "
"является подклассом для \":exc:`NameError`\" ."

#: ../../reference/executionmodel.rst:125
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"Если операция привязки имени происходит где-нибудь внутри блока кода, все "
"использования имени внутри блока рассматриваются как ссылки на текущий блок. "
"Это может привести к ошибкам, если имя используется внутри блока до его "
"привязки. Это правило тонкое. В Python отсутствуют объявления, и он "
"позволяет выполнять операции привязки имен в любом месте блока кода. "
"Локальные переменные блока кода можно определить путем сканирования всего "
"текста блока на предмет операций привязки имени. Примеры см. в разделе часто "
"задаваемых вопросов по UnboundLocalError <faq-unboundlocalerror>."

#: ../../reference/executionmodel.rst:134
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched.  The :keyword:`!global` "
"statement must precede all uses of the listed names."
msgstr ""

#: ../../reference/executionmodel.rst:143
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"Инструкция \":keyword:`global`\" остаётся в силе в тех же рамках, в каких "
"действует связывание имени, произведённое в том же блоке. Если не связанная "
"в данном блоке переменная (\"свободная\") упоминается в любом месте этого же "
"блока в инструкции \":keyword:`global`\" , то эта переменная сразу считается "
"глобальной."

#: ../../reference/executionmodel.rst:149
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope."
msgstr ""

#: ../../reference/executionmodel.rst:156
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"Пространство имён для модуля автоматически создаётся, когда модуль в первый "
"раз импортируется. Главный модуль скрипта всегда называется \":mod:"
"`__main__`\" ."

#: ../../reference/executionmodel.rst:159
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods -- this includes comprehensions and generator "
"expressions since they are implemented using a function scope.  This means "
"that the following will fail::"
msgstr ""

#: ../../reference/executionmodel.rst:177
msgid "Builtins and restricted execution"
msgstr "Встроенные методы и запрещенное исполнение"

#: ../../reference/executionmodel.rst:183
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"Пользователи не должны влазить в \"``__builtins__``\" - его содержание - это "
"исключительно особенности реализации. Пользователи, желающие переопределить "
"значения в этом встроенном пространстве имён должны импортировать модуль \":"
"mod:`builtins`\" и модифицировать соответственно его атрибуты."

#: ../../reference/executionmodel.rst:188
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"Пространство имен встроенных функций, связанное с выполнением блока кода, "
"фактически находится путем поиска имени ``__builtins__`` в его глобальном "
"пространстве имен; это должен быть словарь или модуль (в последнем случае "
"используется словарь модуля). По умолчанию в модуле :mod:`__main__` "
"``__builtins__`` является встроенным модулем :mod:`builtins`; в любом другом "
"модуле ``__builtins__`` является псевдонимом словаря самого модуля :mod:"
"`builtins`."

#: ../../reference/executionmodel.rst:200
msgid "Interaction with dynamic features"
msgstr "Взаимодействие с динамическими свойствами."

#: ../../reference/executionmodel.rst:202
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"Поиск значения имени несвязанной переменной происходит во время исполнения, "
"а не компиляции. Это значит, что следующий код напечатает 42 ::"

#: ../../reference/executionmodel.rst:213
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"Функции \":func:`eval`\" и \":func:`exec`\" не имеют доступа ко всему "
"окружению для интерпретации имён. Значения имён могут искаться в локальной и "
"в глобальной областях имён относительно места вызова. Свободные переменные "
"не ищутся в области имён одним уровнем выше, за исключением глобальной. (Это "
"ограничение происходит от того, что код, исполняемый этими инструкциями не "
"доступен во время компиляции данного модуля.) Функции \":func:`exec`\" и \":"
"func:`eval`\" имеют необязательные аргументы для переопределения глобальной "
"и локальной областей имён. Если задан только один аргумент, то он "
"используется для обеих областей."

#: ../../reference/executionmodel.rst:224
msgid "Exceptions"
msgstr "Исключения"

#: ../../reference/executionmodel.rst:235
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"Исключения являются средством прерывания нормального хода исполнения кода "
"для обработки ошибок или других исключительных ситуаций. Исключение "
"*возникает* в месте, где обнаружена ошибка; оно может быть *обработано* в "
"текущем блоке кода или в любом блоке кода, в котором прямо или косвенно "
"вызван тот блок кода, в котором возникла ошибка."

#: ../../reference/executionmodel.rst:241
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Интерпретатор Питона исполняет исключение, когда обнаруживает ошибку "
"исполнения (например деление на ноль) . Программа на Питоне также может явно "
"вызывать исключение инструкцией \":keyword:`raise`\" . Обработчики "
"исключений задаются инструкцией \":keyword:`try` ... :keyword:`except`\" . "
"Отдел \":keyword:`finally`\" этой инструкции может быть использован для "
"задания кода, который исполняется независимо от того, произошло ли "
"исключение в соответствующем блоке \":keyword:`try` ... :keyword:"
"`except`\" ( и который не является функцией, получающей в качестве аргумента "
"идентификатор ошибки, и не является собственно обработчиком ошибки) ."

#: ../../reference/executionmodel.rst:251
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Питон использует ограничительную модель обработки ошибок: обработчик "
"исключения может проанализировать ситуацию и продолжить исполнение за "
"пределами блока \":keyword:`try` ... :keyword:`except`\" , но не может "
"исправить причину ошибки и всё-таки выполнить сбойную операцию (не считая "
"того, чтобы вызвать весь проблемный фрагмент с самого начала) ."

#: ../../reference/executionmodel.rst:258
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"Когда исключение вообще не обрабатывается, интерпретатор прекращает "
"выполнение программы или возвращается к интерактивному основному циклу. В "
"любом случае он печатает обратную трассировку стека, за исключением случаев, "
"когда исключением является :exc:`SystemExit`."

#: ../../reference/executionmodel.rst:262
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"Исключения идентифицируются экземплярами класса. Предложение :keyword:"
"`Exception` выбирается в зависимости от класса экземпляра: оно должно "
"ссылаться на класс экземпляра или на его :term:`невиртуальный базовый класс "
"<абстрактный базовый класс>`. Экземпляр может быть получен обработчиком и "
"содержать дополнительную информацию об исключительном состоянии."

#: ../../reference/executionmodel.rst:270
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"Сообщения о исключениях не являются частью API Питона. Их содержание может "
"меняться от одной версии Питона к другой без предупреждения и код, который "
"будет запускаться на разных версиях интерпретатора не должен полагаться на "
"них."

#: ../../reference/executionmodel.rst:274
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Также, смотрите описание инструкции \" :keyword:`try`\" в разделе :ref:`try` "
"и инструкции \":keyword:`raise`\" в разделе :ref:`raise`."

#: ../../reference/executionmodel.rst:279
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/executionmodel.rst:280
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"Это ограничение происходит от того, что код, исполняемый этими инструкциями "
"не доступен во время компиляции данного модуля."

#: ../../reference/executionmodel.rst:8
msgid "execution model"
msgstr "модель исполнения"

#: ../../reference/executionmodel.rst:8
msgid "code"
msgstr "код"

#: ../../reference/executionmodel.rst:8 ../../reference/executionmodel.rst:17
msgid "block"
msgstr "блокировать"

#: ../../reference/executionmodel.rst:31 ../../reference/executionmodel.rst:179
msgid "execution"
msgstr "execution"

#: ../../reference/executionmodel.rst:31
msgid "frame"
msgstr "фрейм"

#: ../../reference/executionmodel.rst:42
msgid "namespace"
msgstr "пространство имён"

#: ../../reference/executionmodel.rst:42 ../../reference/executionmodel.rst:101
msgid "scope"
msgstr "scope"

#: ../../reference/executionmodel.rst:51
msgid "name"
msgstr "имя"

#: ../../reference/executionmodel.rst:51
msgid "binding"
msgstr "binding"

#: ../../reference/executionmodel.rst:57
msgid "from"
msgstr "от"

#: ../../reference/executionmodel.rst:57
msgid "import statement"
msgstr "import statement"

#: ../../reference/executionmodel.rst:85
msgid "free"
msgstr "free"

#: ../../reference/executionmodel.rst:85
msgid "variable"
msgstr "переменная"

#: ../../reference/executionmodel.rst:109
msgid "environment"
msgstr "environment"

#: ../../reference/executionmodel.rst:115
msgid "NameError (built-in exception)"
msgstr "NameError (встроенное исключение)"

#: ../../reference/executionmodel.rst:115
msgid "UnboundLocalError"
msgstr "UnboundLocalError"

#: ../../reference/executionmodel.rst:154
msgid "module"
msgstr "модуль"

#: ../../reference/executionmodel.rst:154
msgid "__main__"
msgstr "__main__"

#: ../../reference/executionmodel.rst:179
msgid "restricted"
msgstr "ограниченный"

#: ../../reference/executionmodel.rst:226
msgid "exception"
msgstr "exception"

#: ../../reference/executionmodel.rst:228
msgid "raise an exception"
msgstr "вызвать исключение"

#: ../../reference/executionmodel.rst:228
msgid "handle an exception"
msgstr "обрабатывать исключение"

#: ../../reference/executionmodel.rst:228
msgid "exception handler"
msgstr "обработчик исключений"

#: ../../reference/executionmodel.rst:228
msgid "errors"
msgstr "ошибки"

#: ../../reference/executionmodel.rst:228
msgid "error handling"
msgstr "обработка ошибок"

#: ../../reference/executionmodel.rst:249
msgid "termination model"
msgstr "модель завершения"

#: ../../reference/executionmodel.rst:256
msgid "SystemExit (built-in exception)"
msgstr "SystemExit (встроенное исключение)"
