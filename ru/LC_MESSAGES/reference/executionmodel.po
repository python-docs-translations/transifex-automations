# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr "Модель исполнения."

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "Структура программы."

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Программа Python состоит из блоков кода. :dfn:`block` — это фрагмент текста "
"программы Python, который выполняется как единое целое. Ниже приведены "
"блоки: модуль, тело функции и определение класса. Каждая команда, введенная "
"в интерактивном режиме, представляет собой блок. Файл сценария (файл, "
"передаваемый интерпретатору в качестве стандартного ввода или указанный в "
"качестве аргумента командной строки интерпретатора) представляет собой блок "
"кода. Команда сценария (команда, указанная в командной строке интерпретатора "
"с опцией :option:`-c`) представляет собой блок кода. Модуль, запускаемый как "
"скрипт верхнего уровня (как модуль ``__main__``) из командной строки с "
"использованием аргумента :option:`-m`, также является блоком кода. Строковый "
"аргумент, передаваемый встроенным функциям :func:`eval` и :func:`exec`, "
"представляет собой блок кода."

#: ../../reference/executionmodel.rst:33
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Блок кода выполняется в :dfn:`кадре исполнения<кадр исполнения>`. Кадр "
"содержит служебную информацию (использующуюся для отладки), и определяет, "
"где и как продолжается выполнение после завершения выполнения блока кода."

#: ../../reference/executionmodel.rst:40
msgid "Naming and binding"
msgstr "Именование и связывание."

#: ../../reference/executionmodel.rst:49
msgid "Binding of names"
msgstr "Связывание имён."

#: ../../reference/executionmodel.rst:55
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:'Имена' указывают на объекты. Имена вводятся операциями связывания "
"имени."

#: ../../reference/executionmodel.rst:59
msgid "The following constructs bind names:"
msgstr "Следующие конструкции связывают имена:"

#: ../../reference/executionmodel.rst:61
msgid "formal parameters to functions,"
msgstr "формальные параметры функций,"

#: ../../reference/executionmodel.rst:62
msgid "class definitions,"
msgstr "определения классов,"

#: ../../reference/executionmodel.rst:63
msgid "function definitions,"
msgstr "определения функций,"

#: ../../reference/executionmodel.rst:64
msgid "assignment expressions,"
msgstr "выражения присваивания,"

#: ../../reference/executionmodel.rst:65
msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ""
":ref:`targets <assignment>`, которые являются идентификаторами, если "
"встречаются в присваивании:"

#: ../../reference/executionmodel.rst:68
msgid ":keyword:`for` loop header,"
msgstr ":keyword:`for` заголовок цикла,"

#: ../../reference/executionmodel.rst:69
msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"после :keyword:`!as` в операторе :keyword:`with`, в предложении :keyword:"
"`Exception`, в предложении :keyword:`Exception* <Exception_star>` или в "
"шаблоне as при сопоставлении структурных шаблонов,"

#: ../../reference/executionmodel.rst:71
msgid "in a capture pattern in structural pattern matching"
msgstr "в шаблоне захвата при сопоставлении структурных шаблонов"

#: ../../reference/executionmodel.rst:73
msgid ":keyword:`import` statements."
msgstr ":keyword:`import` statements."

#: ../../reference/executionmodel.rst:74
msgid ":keyword:`type` statements."
msgstr ":keyword:`type` statements."

#: ../../reference/executionmodel.rst:75
msgid ":ref:`type parameter lists <type-params>`."
msgstr ":ref:`списки параметров типа <type-params>`."

#: ../../reference/executionmodel.rst:77
msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"Оператор :keyword:`!import` в форме ``from ... import *`` связывает все "
"имена, определенные в импортируемом модуле, за исключением тех, которые "
"начинаются с подчеркивания. Эту форму можно использовать только на уровне "
"модуля."

#: ../../reference/executionmodel.rst:81
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Цель назначения для инструкции \":keyword:`del`\" также считается получившей "
"назначение (хотя в действительности смысл в снятии связи с этого имени) ."

#: ../../reference/executionmodel.rst:84
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Любое назначение или импорт действует только в пределах блока класса, "
"функции или модуля (он является самым высокоуровневым блоком кода) ."

#: ../../reference/executionmodel.rst:89
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :dfn:`free variable`."
msgstr ""
"Если имя было назначено в блоке , то оно является локальной переменной этого "
"блока, если не объявлено как не локальное (:keyword:`nonlocal`) или "
"глобальное (:keyword:`global`) . Если имя назначено на уровне модуля - оно "
"является глобальной переменной. (Переменные в блоке кода модуля являются с "
"разных точек зрения и локальными и глобальными.) Если переменная "
"используется в блоке кода но не определена непосредственно в нём (но "
"определена в окружении), то она является \":dfn:`свободной "
"переменной<свободная переменная>`\" ."

#: ../../reference/executionmodel.rst:95
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Каждое появление имени в тексте программы указывает на то, что назначено "
"этому имени в данном самом внутреннем функциональном блоке."

#: ../../reference/executionmodel.rst:101
msgid "Resolution of names"
msgstr "Нахождение значения имени."

#: ../../reference/executionmodel.rst:105
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`Область видимости<область видимости>` определяет видимость имени "
"внутри блока. Если локальная переменная определена в блоке, то ее область "
"видимости включает этот блок. Если это определение происходит в блоке "
"функции, то ее область видимости распространяется на любые блоки, "
"содержащиеся в данном блоке функции, если только содержащийся блок не вводит "
"своё назначение данному имени."

#: ../../reference/executionmodel.rst:113
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"Если имя упоминается в блоке кода, то его значение ищется последовательно "
"переходя от одной области видимости к следующей непосредственно объемлющей "
"до первой содержащей определение данного имени. Множество всех таких "
"областей видимости, используемых блоком кода - называется :dfn:"
"`окружение<окружением>` данного блока."

#: ../../reference/executionmodel.rst:121
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Когда имя вообще не найдено - вызывается исключение \":exc:`NameError`\" . "
"Если текущая область видимости образована функцией и если искомое имя "
"указывает на локальную переменную, до связывания которой исполнение функции "
"ещё не дошло - вызывается исключение \":exc:`UnboundLocalError`\" , которое "
"является подклассом для \":exc:`NameError`\" ."

#: ../../reference/executionmodel.rst:127
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"Если операция привязки имени происходит где-нибудь внутри блока кода, все "
"использования имени внутри блока рассматриваются как ссылки на текущий блок. "
"Это может привести к ошибкам, если имя используется внутри блока до его "
"привязки. Это правило тонкое. В Python отсутствуют объявления, и он "
"позволяет выполнять операции привязки имен в любом месте блока кода. "
"Локальные переменные блока кода можно определить путем сканирования всего "
"текста блока на предмет операций привязки имени. Примеры см. в разделе часто "
"задаваемых вопросов по UnboundLocalError <faq-unboundlocalerror>."

#: ../../reference/executionmodel.rst:136
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched next. If the names are also "
"not found in the builtins namespace, new variables are created in the global "
"namespace. The global statement must precede all uses of the listed names."
msgstr ""
"Если оператор :keyword:`global` встречается внутри блока, все использования "
"имен, указанных в операторе, относятся к привязкам этих имен в пространстве "
"имен верхнего уровня. Имена разрешаются в пространстве имен верхнего уровня "
"путем поиска в глобальном пространстве имен, т. е. пространстве имен модуля, "
"содержащего блок кода, и пространстве имен встроенных модулей, пространстве "
"имен модуля :mod:`builtins`. Сначала выполняется поиск в глобальном "
"пространстве имен. Если имена там не найдены, следующий поиск осуществляется "
"во встроенном пространстве имен. Если имена также не найдены во встроенном "
"пространстве имен, новые переменные создаются в глобальном пространстве "
"имен. Глобальный оператор должен предшествовать любому использованию "
"перечисленных имен."

#: ../../reference/executionmodel.rst:146
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"Инструкция \":keyword:`global`\" остаётся в силе в тех же рамках, в каких "
"действует связывание имени, произведённое в том же блоке. Если не связанная "
"в данном блоке переменная (\"свободная\") упоминается в любом месте этого же "
"блока в инструкции \":keyword:`global`\" , то эта переменная сразу считается "
"глобальной."

#: ../../reference/executionmodel.rst:152
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope. :ref:`Type parameters <type-params>` cannot be "
"rebound with the :keyword:`!nonlocal` statement."
msgstr ""
"Оператор :keyword:`nonlocal` заставляет соответствующие имена ссылаться на "
"ранее связанные переменные в ближайшей области охватывающей функции. :exc:"
"`SyntaxError` возникает во время компиляции, если данное имя не существует "
"ни в одной области охватывающей функции. :ref:`Параметры типа <type-params>` "
"не могут быть повторно привязаны с помощью оператора :keyword:`!nonlocal`."

#: ../../reference/executionmodel.rst:160
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"Пространство имён для модуля автоматически создаётся, когда модуль в первый "
"раз импортируется. Главный модуль скрипта всегда называется \":mod:"
"`__main__`\" ."

#: ../../reference/executionmodel.rst:163
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods. This includes comprehensions and generator "
"expressions, but it does not include :ref:`annotation scopes <annotation-"
"scopes>`, which have access to their enclosing class scopes. This means that "
"the following will fail::"
msgstr ""
"Блоки определения классов и аргументы :func:`exec` и :func:`eval` являются "
"особыми в контексте разрешения имен. Определение класса — это исполняемый "
"оператор, который может использовать и определять имена. Эти ссылки следуют "
"обычным правилам разрешения имен, за исключением того, что несвязанные "
"локальные переменные ищутся в глобальном пространстве имен. Пространство "
"имен определения класса становится словарем атрибутов класса. Область имен, "
"определенных в блоке классов, ограничена блоком классов; оно не "
"распространяется на блоки кода методов. Это включает в себя понимания и "
"выражения-генераторы, но не включает :ref:`области аннотаций <annotation-"
"scopes>`, которые имеют доступ к областям своих включающих классов. Это "
"означает, что следующее не удастся:"

#: ../../reference/executionmodel.rst:176
msgid ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"
msgstr ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"

#: ../../reference/executionmodel.rst:180
msgid "However, the following will succeed::"
msgstr "Тем не менее, следующее будет успешным:"

#: ../../reference/executionmodel.rst:182
msgid ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"
msgstr ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"

#: ../../reference/executionmodel.rst:191
msgid "Annotation scopes"
msgstr "Области аннотаций"

#: ../../reference/executionmodel.rst:193
msgid ""
":ref:`Type parameter lists <type-params>` and :keyword:`type` statements "
"introduce *annotation scopes*, which behave mostly like function scopes, but "
"with some exceptions discussed below. :term:`Annotations <annotation>` "
"currently do not use annotation scopes, but they are expected to use "
"annotation scopes in Python 3.13 when :pep:`649` is implemented."
msgstr ""
":ref:`Списки параметров типа <type-params>` и :keyword:`type` операторы "
"вводят *области аннотаций*, которые ведут себя в основном как области "
"функций, но с некоторыми исключениями, обсуждаемыми ниже. :term:`Аннотации "
"<annotation>` в настоящее время не используют области аннотаций, но "
"ожидается, что они будут использовать области аннотаций в Python 3.13, когда "
"будет реализован :pep:`649`."

#: ../../reference/executionmodel.rst:199
msgid "Annotation scopes are used in the following contexts:"
msgstr "Области аннотаций используются в следующих контекстах:"

#: ../../reference/executionmodel.rst:201
msgid ""
"Type parameter lists for :ref:`generic type aliases <generic-type-aliases>`."
msgstr ""
"Списки параметров типа для :ref:`псевдонимов общего типа <generic-type-"
"aliases>`."

#: ../../reference/executionmodel.rst:202
msgid ""
"Type parameter lists for :ref:`generic functions <generic-functions>`. A "
"generic function's annotations are executed within the annotation scope, but "
"its defaults and decorators are not."
msgstr ""
"Введите списки параметров для :ref:`generic function <generic-functions>`. "
"Аннотации универсальной функции выполняются в области аннотации, а ее "
"значения по умолчанию и декораторы — нет."

#: ../../reference/executionmodel.rst:205
msgid ""
"Type parameter lists for :ref:`generic classes <generic-classes>`. A generic "
"class's base classes and keyword arguments are executed within the "
"annotation scope, but its decorators are not."
msgstr ""
"Списки параметров типа для :ref:`универсальных классов <generic-classes>`. "
"Базовые классы и ключевые аргументы универсального класса выполняются в "
"области аннотации, а его декораторы — нет."

#: ../../reference/executionmodel.rst:208
msgid ""
"The bounds and constraints for type variables (:ref:`lazily evaluated <lazy-"
"evaluation>`)."
msgstr ""
"Границы и ограничения для переменных типа (:ref:`лениво оцениваемые <lazy-"
"evaluation>`)."

#: ../../reference/executionmodel.rst:210
msgid "The value of type aliases (:ref:`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"Значение псевдонимов типов (:ref:`лениво оцениваемое <lazy-evaluation>`)."

#: ../../reference/executionmodel.rst:212
msgid "Annotation scopes differ from function scopes in the following ways:"
msgstr "Области аннотаций отличаются от областей функций следующим образом:"

#: ../../reference/executionmodel.rst:214
msgid ""
"Annotation scopes have access to their enclosing class namespace. If an "
"annotation scope is immediately within a class scope, or within another "
"annotation scope that is immediately within a class scope, the code in the "
"annotation scope can use names defined in the class scope as if it were "
"executed directly within the class body. This contrasts with regular "
"functions defined within classes, which cannot access names defined in the "
"class scope."
msgstr ""
"Области аннотаций имеют доступ к пространству имен включающего их класса. "
"Если область аннотации находится непосредственно в области класса или внутри "
"другой области аннотации, которая находится непосредственно в области "
"класса, код в области аннотации может использовать имена, определенные в "
"области класса, как если бы он выполнялся непосредственно внутри тела "
"класса. Это контрастирует с обычными функциями, определенными внутри "
"классов, которые не могут получить доступ к именам, определенным в области "
"действия класса."

#: ../../reference/executionmodel.rst:220
msgid ""
"Expressions in annotation scopes cannot contain :keyword:`yield`, ``yield "
"from``, :keyword:`await`, or :token:`:= <python-grammar:"
"assignment_expression>` expressions. (These expressions are allowed in other "
"scopes contained within the annotation scope.)"
msgstr ""
"Выражения в областях аннотаций не могут содержать выражения :keyword:"
"`yield`, ``yield from``, :keyword:`await` или :token:`:= <python-grammar:"
"assignment_expression>`. (Эти выражения разрешены в других областях, "
"содержащихся в области аннотации.)"

#: ../../reference/executionmodel.rst:224
msgid ""
"Names defined in annotation scopes cannot be rebound with :keyword:"
"`nonlocal` statements in inner scopes. This includes only type parameters, "
"as no other syntactic elements that can appear within annotation scopes can "
"introduce new names."
msgstr ""
"Имена, определенные в областях аннотаций, не могут быть повторно связаны с "
"операторами :keyword:`nonlocal` во внутренних областях. Сюда входят только "
"параметры типа, поскольку никакие другие синтаксические элементы, которые "
"могут появляться в областях аннотаций, не могут вводить новые имена."

#: ../../reference/executionmodel.rst:227
msgid ""
"While annotation scopes have an internal name, that name is not reflected in "
"the :term:`qualified name` of objects defined within the scope. Instead, "
"the :attr:`~definition.__qualname__` of such objects is as if the object "
"were defined in the enclosing scope."
msgstr ""
"Хотя области аннотаций имеют внутреннее имя, это имя не отражается в :term:"
"`полном имени` объектов, определенных в этой области. Вместо этого :attr:"
"`~definition.__qualname__` таких объектов выглядит так, как если бы объект "
"был определен во внешней области видимости."

#: ../../reference/executionmodel.rst:232
msgid "Annotation scopes were introduced in Python 3.12 as part of :pep:`695`."
msgstr ""
"Области аннотаций были представлены в Python 3.12 как часть :pep:`695`."

#: ../../reference/executionmodel.rst:238
msgid "Lazy evaluation"
msgstr "Ленивая оценка"

#: ../../reference/executionmodel.rst:240
msgid ""
"The values of type aliases created through the :keyword:`type` statement are "
"*lazily evaluated*. The same applies to the bounds and constraints of type "
"variables created through the :ref:`type parameter syntax <type-params>`. "
"This means that they are not evaluated when the type alias or type variable "
"is created. Instead, they are only evaluated when doing so is necessary to "
"resolve an attribute access."
msgstr ""
"Значения псевдонимов типов, созданных с помощью оператора :keyword:`type`, "
"оцениваются *лениво*. То же самое относится к границам и ограничениям "
"переменных типа, созданных с помощью :ref:`синтаксиса параметра типа <type-"
"params>`. Это означает, что они не оцениваются при создании псевдонима типа "
"или переменной типа. Вместо этого они оцениваются только тогда, когда это "
"необходимо для разрешения доступа к атрибуту."

#: ../../reference/executionmodel.rst:247
msgid "Example:"
msgstr "Пример:"

#: ../../reference/executionmodel.rst:249
msgid ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"
msgstr ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"

#: ../../reference/executionmodel.rst:263
msgid ""
"Here the exception is raised only when the ``__value__`` attribute of the "
"type alias or the ``__bound__`` attribute of the type variable is accessed."
msgstr ""
"Здесь исключение возникает только при доступе к атрибуту ``__value__`` "
"псевдонима типа или атрибуту ``__bound__`` переменной типа."

#: ../../reference/executionmodel.rst:267
msgid ""
"This behavior is primarily useful for references to types that have not yet "
"been defined when the type alias or type variable is created. For example, "
"lazy evaluation enables creation of mutually recursive type aliases::"
msgstr ""
"Такое поведение в первую очередь полезно для ссылок на типы, которые еще не "
"были определены при создании псевдонима типа или переменной типа. Например, "
"ленивые вычисления позволяют создавать псевдонимы взаимно рекурсивных типов:"

#: ../../reference/executionmodel.rst:271
msgid ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"
msgstr ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"

#: ../../reference/executionmodel.rst:277
msgid ""
"Lazily evaluated values are evaluated in :ref:`annotation scope <annotation-"
"scopes>`, which means that names that appear inside the lazily evaluated "
"value are looked up as if they were used in the immediately enclosing scope."
msgstr ""
"Лениво вычисляемые значения оцениваются в :ref:`области аннотации "
"<annotation-scopes>`, что означает, что имена, которые появляются внутри "
"лениво вычисляемого значения, просматриваются так, как если бы они "
"использовались в непосредственно охватывающей области."

#: ../../reference/executionmodel.rst:286
msgid "Builtins and restricted execution"
msgstr "Встроенные методы и запрещенное исполнение"

#: ../../reference/executionmodel.rst:292
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"Пользователи не должны влазить в \"``__builtins__``\" - его содержание - это "
"исключительно особенности реализации. Пользователи, желающие переопределить "
"значения в этом встроенном пространстве имён должны импортировать модуль \":"
"mod:`builtins`\" и модифицировать соответственно его атрибуты."

#: ../../reference/executionmodel.rst:297
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"Пространство имен встроенных функций, связанное с выполнением блока кода, "
"фактически находится путем поиска имени ``__builtins__`` в его глобальном "
"пространстве имен; это должен быть словарь или модуль (в последнем случае "
"используется словарь модуля). По умолчанию в модуле :mod:`__main__` "
"``__builtins__`` является встроенным модулем :mod:`builtins`; в любом другом "
"модуле ``__builtins__`` является псевдонимом словаря самого модуля :mod:"
"`builtins`."

#: ../../reference/executionmodel.rst:309
msgid "Interaction with dynamic features"
msgstr "Взаимодействие с динамическими свойствами."

#: ../../reference/executionmodel.rst:311
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"Поиск значения имени несвязанной переменной происходит во время исполнения, "
"а не компиляции. Это значит, что следующий код напечатает 42 ::"

#: ../../reference/executionmodel.rst:314
msgid ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"
msgstr ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"

#: ../../reference/executionmodel.rst:322
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"Функции \":func:`eval`\" и \":func:`exec`\" не имеют доступа ко всему "
"окружению для интерпретации имён. Значения имён могут искаться в локальной и "
"в глобальной областях имён относительно места вызова. Свободные переменные "
"не ищутся в области имён одним уровнем выше, за исключением глобальной. (Это "
"ограничение происходит от того, что код, исполняемый этими инструкциями не "
"доступен во время компиляции данного модуля.) Функции \":func:`exec`\" и \":"
"func:`eval`\" имеют необязательные аргументы для переопределения глобальной "
"и локальной областей имён. Если задан только один аргумент, то он "
"используется для обеих областей."

#: ../../reference/executionmodel.rst:333
msgid "Exceptions"
msgstr "Исключения"

#: ../../reference/executionmodel.rst:344
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"Исключения являются средством прерывания нормального хода исполнения кода "
"для обработки ошибок или других исключительных ситуаций. Исключение "
"*возникает* в месте, где обнаружена ошибка; оно может быть *обработано* в "
"текущем блоке кода или в любом блоке кода, в котором прямо или косвенно "
"вызван тот блок кода, в котором возникла ошибка."

#: ../../reference/executionmodel.rst:350
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Интерпретатор Питона исполняет исключение, когда обнаруживает ошибку "
"исполнения (например деление на ноль) . Программа на Питоне также может явно "
"вызывать исключение инструкцией \":keyword:`raise`\" . Обработчики "
"исключений задаются инструкцией \":keyword:`try` ... :keyword:`except`\" . "
"Отдел \":keyword:`finally`\" этой инструкции может быть использован для "
"задания кода, который исполняется независимо от того, произошло ли "
"исключение в соответствующем блоке \":keyword:`try` ... :keyword:"
"`except`\" ( и который не является функцией, получающей в качестве аргумента "
"идентификатор ошибки, и не является собственно обработчиком ошибки) ."

#: ../../reference/executionmodel.rst:360
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Питон использует ограничительную модель обработки ошибок: обработчик "
"исключения может проанализировать ситуацию и продолжить исполнение за "
"пределами блока \":keyword:`try` ... :keyword:`except`\" , но не может "
"исправить причину ошибки и всё-таки выполнить сбойную операцию (не считая "
"того, чтобы вызвать весь проблемный фрагмент с самого начала) ."

#: ../../reference/executionmodel.rst:367
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"Когда исключение вообще не обрабатывается, интерпретатор прекращает "
"выполнение программы или возвращается к интерактивному основному циклу. В "
"любом случае он печатает обратную трассировку стека, за исключением случаев, "
"когда исключением является :exc:`SystemExit`."

#: ../../reference/executionmodel.rst:371
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"Исключения идентифицируются экземплярами класса. Предложение :keyword:"
"`Exception` выбирается в зависимости от класса экземпляра: оно должно "
"ссылаться на класс экземпляра или на его :term:`невиртуальный базовый класс "
"<абстрактный базовый класс>`. Экземпляр может быть получен обработчиком и "
"содержать дополнительную информацию об исключительном состоянии."

#: ../../reference/executionmodel.rst:379
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"Сообщения о исключениях не являются частью API Питона. Их содержание может "
"меняться от одной версии Питона к другой без предупреждения и код, который "
"будет запускаться на разных версиях интерпретатора не должен полагаться на "
"них."

#: ../../reference/executionmodel.rst:383
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Также, смотрите описание инструкции \" :keyword:`try`\" в разделе :ref:`try` "
"и инструкции \":keyword:`raise`\" в разделе :ref:`raise`."

#: ../../reference/executionmodel.rst:388
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/executionmodel.rst:389
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"Это ограничение происходит от того, что код, исполняемый этими инструкциями "
"не доступен во время компиляции данного модуля."

#: ../../reference/executionmodel.rst:8
msgid "execution model"
msgstr "модель исполнения"

#: ../../reference/executionmodel.rst:8
msgid "code"
msgstr "код"

#: ../../reference/executionmodel.rst:8 ../../reference/executionmodel.rst:17
msgid "block"
msgstr "блокировать"

#: ../../reference/executionmodel.rst:31 ../../reference/executionmodel.rst:288
msgid "execution"
msgstr "execution"

#: ../../reference/executionmodel.rst:31
msgid "frame"
msgstr "фрейм"

#: ../../reference/executionmodel.rst:42
msgid "namespace"
msgstr "пространство имён"

#: ../../reference/executionmodel.rst:42 ../../reference/executionmodel.rst:103
msgid "scope"
msgstr "scope"

#: ../../reference/executionmodel.rst:51
msgid "name"
msgstr "имя"

#: ../../reference/executionmodel.rst:51
msgid "binding"
msgstr "binding"

#: ../../reference/executionmodel.rst:57
msgid "from"
msgstr "от"

#: ../../reference/executionmodel.rst:57
msgid "import statement"
msgstr "import statement"

#: ../../reference/executionmodel.rst:87
msgid "free"
msgstr "free"

#: ../../reference/executionmodel.rst:87
msgid "variable"
msgstr "переменная"

#: ../../reference/executionmodel.rst:111
msgid "environment"
msgstr "environment"

#: ../../reference/executionmodel.rst:117
msgid "NameError (built-in exception)"
msgstr "NameError (встроенное исключение)"

#: ../../reference/executionmodel.rst:117
msgid "UnboundLocalError"
msgstr "UnboundLocalError"

#: ../../reference/executionmodel.rst:158
msgid "module"
msgstr "модуль"

#: ../../reference/executionmodel.rst:158
msgid "__main__"
msgstr "__main__"

#: ../../reference/executionmodel.rst:288
msgid "restricted"
msgstr "ограниченный"

#: ../../reference/executionmodel.rst:335
msgid "exception"
msgstr "exception"

#: ../../reference/executionmodel.rst:337
msgid "raise an exception"
msgstr "вызвать исключение"

#: ../../reference/executionmodel.rst:337
msgid "handle an exception"
msgstr "обрабатывать исключение"

#: ../../reference/executionmodel.rst:337
msgid "exception handler"
msgstr "обработчик исключений"

#: ../../reference/executionmodel.rst:337
msgid "errors"
msgstr "ошибки"

#: ../../reference/executionmodel.rst:337
msgid "error handling"
msgstr "обработка ошибок"

#: ../../reference/executionmodel.rst:358
msgid "termination model"
msgstr "модель завершения"

#: ../../reference/executionmodel.rst:365
msgid "SystemExit (built-in exception)"
msgstr "SystemExit (встроенное исключение)"
