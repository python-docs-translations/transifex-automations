# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# Dmitry Luschan, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-23 14:16+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: Dmitry Luschan, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/introduction.rst:6
msgid "Introduction"
msgstr "Введение"

#: ../../reference/introduction.rst:8
msgid ""
"This reference manual describes the Python programming language. It is not "
"intended as a tutorial."
msgstr ""
"Это справочное руководство описывает язык программирования Python. Оно не "
"предназначено для использования в качестве учебного пособия."

#: ../../reference/introduction.rst:11
msgid ""
"While I am trying to be as precise as possible, I chose to use English "
"rather than formal specifications for everything except syntax and lexical "
"analysis. This should make the document more understandable to the average "
"reader, but will leave room for ambiguities. Consequently, if you were "
"coming from Mars and tried to re-implement Python from this document alone, "
"you might have to guess things and in fact you would probably end up "
"implementing quite a different language. On the other hand, if you are using "
"Python and wonder what the precise rules about a particular area of the "
"language are, you should definitely be able to find them here. If you would "
"like to see a more formal definition of the language, maybe you could "
"volunteer your time --- or invent a cloning machine :-)."
msgstr ""
"Хотя я стараюсь быть максимально точным, я решил использовать описание на "
"естественном языке, а не формальные спецификации, для всего, кроме "
"синтаксиса и лексического анализа. Это должно сделать документ более "
"понятным для среднего читателя, но оставит пространство для "
"неоднозначностей. Следовательно, если бы вы прибыли с Марса и попытались "
"заново реализовать Python, опираясь только на этот документ, вам пришлось бы "
"многое угадывать, и в итоге вы, вероятно, реализовали бы совсем другой язык. "
"С другой стороны, если вы используете Python и задаётесь вопросом, каковы "
"точные правила в какой-то конкретной области языка, вы определённо сможете "
"найти их здесь. Если же вы хотели бы увидеть более формальное определение "
"языка, возможно, вы могли бы пожертвовать своим временем — или изобрести "
"машину для клонирования :-)."

#: ../../reference/introduction.rst:23
msgid ""
"It is dangerous to add too many implementation details to a language "
"reference document --- the implementation may change, and other "
"implementations of the same language may work differently.  On the other "
"hand, CPython is the one Python implementation in widespread use (although "
"alternate implementations continue to gain support), and its particular "
"quirks are sometimes worth being mentioned, especially where the "
"implementation imposes additional limitations. Therefore, you'll find short "
"\"implementation notes\" sprinkled throughout the text."
msgstr ""
"Опасно добавлять слишком много деталей реализации в справочник по языку — "
"реализация может измениться, и другие реализации того же языка могут "
"работать иначе. С другой стороны, CPython является одной реализацией Python, "
"находящейся в широком использовании (хотя альтернативные реализации "
"продолжают получать поддержку), и её конкретные особенности иногда "
"заслуживают упоминания, особенно там, где реализация накладывает "
"дополнительные ограничения. Поэтому по всему тексту вы найдёте короткие "
"«примечания по реализации»."

#: ../../reference/introduction.rst:32
msgid ""
"Every Python implementation comes with a number of built-in and standard "
"modules.  These are documented in :ref:`library-index`.  A few built-in "
"modules are mentioned when they interact in a significant way with the "
"language definition."
msgstr ""
"Каждая реализация Python поставляется с рядом встроенных и стандартных "
"модулей. Они документированы в :ref:`library-index`. Некоторые встроенные "
"модули упоминаются тогда, когда они существенно взаимодействуют с "
"определением языка."

#: ../../reference/introduction.rst:41
msgid "Alternate Implementations"
msgstr "Альтернативные реализации"

#: ../../reference/introduction.rst:43
msgid ""
"Though there is one Python implementation which is by far the most popular, "
"there are some alternate implementations which are of particular interest to "
"different audiences."
msgstr ""
"Хотя существует одна реализация Python, которая безусловно наиболее "
"популярна, существуют и альтернативные реализации, представляющие особый "
"интерес для разных аудиторий."

#: ../../reference/introduction.rst:47
msgid "Known implementations include:"
msgstr "Известные реализации включают:"

#: ../../reference/introduction.rst:49
msgid "CPython"
msgstr "CPython"

#: ../../reference/introduction.rst:50
msgid ""
"This is the original and most-maintained implementation of Python, written "
"in C. New language features generally appear here first."
msgstr ""
"Это оригинальная и самая поддеживаемая реализация Python, написанная на C. "
"Новые возможности языка обычно появляются здесь в первую очередь."

#: ../../reference/introduction.rst:53
msgid "Jython"
msgstr "Jython"

#: ../../reference/introduction.rst:54
msgid ""
"Python implemented in Java.  This implementation can be used as a scripting "
"language for Java applications, or can be used to create applications using "
"the Java class libraries.  It is also often used to create tests for Java "
"libraries. More information can be found at `the Jython website <https://www."
"jython.org/>`_."
msgstr ""
"Python, реализованный на Java. Эта реализация может использоваться в "
"качестве скриптового языка для приложений Java или для создания приложений с "
"использованием библиотек классов Java. Она также часто используется для "
"создания тестов для библиотек Java. Более подробная информация доступна на "
"`сайте Jython <https://www.jython.org/>`_."

#: ../../reference/introduction.rst:59
msgid "Python for .NET"
msgstr "Python для .NET"

#: ../../reference/introduction.rst:60
msgid ""
"This implementation actually uses the CPython implementation, but is a "
"managed .NET application and makes .NET libraries available.  It was created "
"by Brian Lloyd.  For more information, see the `Python for .NET home page "
"<https://pythonnet.github.io/>`_."
msgstr ""
"Эта реализация фактически использует CPython, но является управляемым "
"приложением .NET и делает доступными библиотеки .NET. Она была создана "
"Брайаном Ллойдом. Для дополнительной информации см. `главную страницу Python "
"для .NET <https://pythonnet.github.io/>`_."

#: ../../reference/introduction.rst:65
msgid "IronPython"
msgstr "IronPython"

#: ../../reference/introduction.rst:66
msgid ""
"An alternate Python for .NET.  Unlike Python.NET, this is a complete Python "
"implementation that generates IL, and compiles Python code directly to .NET "
"assemblies.  It was created by Jim Hugunin, the original creator of Jython.  "
"For more information, see `the IronPython website <https://ironpython.net/"
">`_."
msgstr ""
"Альтернативная реализация Python для .NET. В отличие от Python.NET, это "
"полноценная реализация Python, которая генерирует IL и компилирует код "
"Python непосредственно в сборки .NET. Она была создана Джимом Хьюгинином, "
"первоначальным создателем Jython. Дополнительную информацию можно найти на "
"`сайте IronPython <https://ironpython.net/>`_."

#: ../../reference/introduction.rst:71
msgid "PyPy"
msgstr "PyPy"

#: ../../reference/introduction.rst:72
msgid ""
"An implementation of Python written completely in Python. It supports "
"several advanced features not found in other implementations like stackless "
"support and a Just in Time compiler. One of the goals of the project is to "
"encourage experimentation with the language itself by making it easier to "
"modify the interpreter (since it is written in Python).  Additional "
"information is available on `the PyPy project's home page <https://pypy.org/"
">`_."
msgstr ""
"Реализация Python, полностью написанная на Python. Она поддерживает "
"несколько продвинутых возможностей, отсутствующих в других реализациях, "
"таких как поддержка работы без стека и компилятор Just in Time. Одна из "
"целей проекта — поощрять эксперименты с самим языком, облегчая модификацию "
"интерпретатора (поскольку он написан на Python). Дополнительная информация "
"доступна на `главной странице проекта PyPy <https://pypy.org/>`_."

#: ../../reference/introduction.rst:79
msgid ""
"Each of these implementations varies in some way from the language as "
"documented in this manual, or introduces specific information beyond what's "
"covered in the standard Python documentation.  Please refer to the "
"implementation-specific documentation to determine what else you need to "
"know about the specific implementation you're using."
msgstr ""
"Каждая из этих реализаций в той или иной степени отличается от языка, "
"описанного в этом справочном руководстве, или вводит специфическую "
"информацию, выходящую за рамки стандартной документации Python. Пожалуйста, "
"обращайтесь к документации конкретной реализации, чтобы узнать, что ещё "
"необходимо учитывать при работе с выбранной реализацией."

#: ../../reference/introduction.rst:89
msgid "Notation"
msgstr "Нотация"

#: ../../reference/introduction.rst:93
msgid ""
"The descriptions of lexical analysis and syntax use a grammar notation that "
"is a mixture of `EBNF <https://en.wikipedia.org/wiki/"
"Extended_Backus%E2%80%93Naur_form>`_ and `PEG <https://en.wikipedia.org/wiki/"
"Parsing_expression_grammar>`_. For example:"
msgstr ""
"Описание лексического анализа и синтаксиса использует нотацию грамматики, "
"которая представляет собой смесь `EBNF <https://en.wikipedia.org/wiki/"
"Extended_Backus%E2%80%93Naur_form>`_ и `PEG <https://en.wikipedia.org/wiki/"
"Parsing_expression_grammar>`_. Например:"

#: ../../reference/introduction.rst:106
msgid ""
"In this example, the first line says that a ``name`` is a ``letter`` "
"followed by a sequence of zero or more ``letter``\\ s, ``digit``\\ s, and "
"underscores. A ``letter`` in turn is any of the single characters ``'a'`` "
"through ``'z'`` and ``A`` through ``Z``; a ``digit`` is a single character "
"from ``0`` to ``9``."
msgstr ""
"В этом примере первая строка говорит, что ``name`` — это ``letter``, за "
"которой следует последовательность из нуля или более ``letter``, ``digit`` и "
"подчёркиваний. В свою очередь, ``letter`` — это любой одиночный символ от "
"``'a'`` до ``'z'`` или от ``A`` до ``Z``; а ``digit`` — это одиночный символ "
"от ``0`` до ``9``."

#: ../../reference/introduction.rst:112
msgid ""
"Each rule begins with a name (which identifies the rule that's being "
"defined) followed by a colon, ``:``. The definition to the right of the "
"colon uses the following syntax elements:"
msgstr ""
"Каждое правило начинается с имени (которое идентифицирует определяемое "
"правило), за которым следует двоеточие, ``:``. Определение справа от "
"двоеточия использует следующие синтаксические элементы:"

#: ../../reference/introduction.rst:116
msgid ""
"``name``: A name refers to another rule. Where possible, it is a link to the "
"rule's definition."
msgstr ""
"``name``: Имя ссылается на другое правило. По возможности, это ссылка на "
"определение правила."

#: ../../reference/introduction.rst:119
msgid ""
"``TOKEN``: An uppercase name refers to a :term:`token`. For the purposes of "
"grammar definitions, tokens are the same as rules."
msgstr ""
"``TOKEN``: Заглавное имя ссылается на :term:`токен`. Для целей определения "
"грамматики токены эквивалентны правилам."

#: ../../reference/introduction.rst:122
msgid ""
"``\"text\"``, ``'text'``: Text in single or double quotes must match "
"literally (without the quotes). The type of quote is chosen according to the "
"meaning of ``text``:"
msgstr ""
"``\"text\"``, ``'text'``: Текст в одинарных или двойных кавычках должен "
"совпадение буквально (без кавычек). Тип кавычка выбирается в зависимости от "
"значения ``text``:"

#: ../../reference/introduction.rst:126
msgid "``'if'``: A name in single quotes denotes a :ref:`keyword <keywords>`."
msgstr ""
"``'if'``: Имя в одинарных кавычках обозначает :ref:`ключевое слово "
"<keywords>` ."

#: ../../reference/introduction.rst:127
msgid ""
"``\"case\"``: A name in double quotes denotes a :ref:`soft-keyword <soft-"
"keywords>`."
msgstr ""
"``\"case\"``: Имя в двойных кавычках обозначает :ref:`мягкое ключевое слово "
"<soft-keywords>` ."

#: ../../reference/introduction.rst:129
msgid ""
"``'@'``: A non-letter symbol in single quotes denotes an :py:data:`~token."
"OP` token, that is, a :ref:`delimiter <delimiters>` or :ref:`operator "
"<operators>`."
msgstr ""
"``'@'``: Символ, не являющийся буквой, в одинарных кавычках обозначает :py:"
"data:`~token.OP` токен, то есть :ref:`разделитель <delimiters>` или :ref:"
"`оператор <operators>`."

#: ../../reference/introduction.rst:133
msgid ""
"``e1 e2``: Items separated only by whitespace denote a sequence. Here, "
"``e1`` must be followed by ``e2``."
msgstr ""
"``e1 e2``: Элементы, разделённые только пробелами, обозначают "
"последовательность. Здесь за ``e1`` должен следовать ``e2``."

#: ../../reference/introduction.rst:135
msgid ""
"``e1 | e2``: A vertical bar is used to separate alternatives. It denotes "
"PEG's \"ordered choice\": if ``e1`` matches, ``e2`` is not considered. In "
"traditional PEG grammars, this is written as a slash, ``/``, rather than a "
"vertical bar. See :pep:`617` for more background and details."
msgstr ""
"``e1 | e2``: Вертикальная черта используется для разделения альтернатив. Она "
"обозначает «упорядоченный выбор» PEG: если ``e1`` совпадает, то ``e2`` не "
"рассматривается. В традиционных PEG-грамматиках это записывается как слэш, "
"``/``, а не вертикальная черта. См. :pep:`617` для более подробного "
"объяснения и деталей."

#: ../../reference/introduction.rst:141
msgid "``e*``: A star means zero or more repetitions of the preceding item."
msgstr ""
"``e*``: Звёздочка означает ноль или более повторений предыдущего элемента."

#: ../../reference/introduction.rst:142
msgid "``e+``: Likewise, a plus means one or more repetitions."
msgstr "``e+``: Аналогично, плюс означает одно или несколько повторений."

#: ../../reference/introduction.rst:143
msgid ""
"``[e]``: A phrase enclosed in square brackets means zero or one occurrences. "
"In other words, the enclosed phrase is optional."
msgstr ""
"``[e]``: Фраза в квадратных скобках означает ноль или одно вхождение. "
"Другими словами, заключённая фраза является необязательной."

#: ../../reference/introduction.rst:145
msgid ""
"``e?``: A question mark has exactly the same meaning as square brackets: the "
"preceding item is optional."
msgstr ""
"``e?``: Вопросительный знак имеет точно такой же смысл, как квадратные "
"скобки: предыдущий элемент необязателен."

#: ../../reference/introduction.rst:147
msgid "``(e)``: Parentheses are used for grouping."
msgstr "``(e)``: Скобки используются для группировки."

#: ../../reference/introduction.rst:149
msgid ""
"The following notation is only used in :ref:`lexical definitions <notation-"
"lexical-vs-syntactic>`."
msgstr ""
"Следующая нотация используется только в :ref:`лексических определениях "
"<notation-lexical-vs-syntactic>`."

#: ../../reference/introduction.rst:152
msgid ""
"``\"a\"...\"z\"``: Two literal characters separated by three dots mean a "
"choice of any single character in the given (inclusive) range of ASCII "
"characters."
msgstr ""
"``\"a\"...\"z\"``: Два буквальных символа, разделённые тремя точками, "
"означают выбор любого одиночного символа в указанном (включительно) "
"диапазоне ASCII."

#: ../../reference/introduction.rst:154
msgid ""
"``<...>``: A phrase between angular brackets gives an informal description "
"of the matched symbol (for example, ``<any ASCII character except \"\\"
"\">``), or an abbreviation that is defined in nearby text (for example, "
"``<Lu>``)."
msgstr ""
"``<...>``: Фраза в угловых скобках даёт неформальное описание совпадающего "
"символа (например, ``<any ASCII character except \"\\\">``) или сокращение, "
"которое определено в соседнем тексте (например, ``<Lu>``)."

#: ../../reference/introduction.rst:160
msgid ""
"Some definitions also use *lookaheads*, which indicate that an element must "
"(or must not) match at a given position, but without consuming any input:"
msgstr ""
"В некоторых определениях также используются *lookahead*-ы, которые "
"указывают, что элемент должен (или не должен) совпадать в заданной позиции, "
"но без потребления входных данных:"

#: ../../reference/introduction.rst:163
msgid "``&e``: a positive lookahead (that is, ``e`` is required to match)"
msgstr "``&e``: позитивный lookahead (т.е. ``e`` требуется для совпадения)"

#: ../../reference/introduction.rst:164
msgid ""
"``!e``: a negative lookahead (that is, ``e`` is required *not* to match)"
msgstr ""
"``!e``: негативный lookahead (т.е. ``e`` должен *отсутствовать* для "
"совпадения)"

#: ../../reference/introduction.rst:166
msgid ""
"The unary operators (``*``, ``+``, ``?``) bind as tightly as possible; the "
"vertical bar (``|``) binds most loosely."
msgstr ""
"Унарные операторы (``*``, ``+``, ``?``) применяются только к ближайшему "
"элементу; а вертикальная черта (``|``) — к максимально возможному числу "
"элементов."

#: ../../reference/introduction.rst:169
msgid "White space is only meaningful to separate tokens."
msgstr "Пробел имеет значение только для разделения токенов."

#: ../../reference/introduction.rst:171
msgid ""
"Rules are normally contained on a single line, but rules that are too long "
"may be wrapped:"
msgstr ""
"Обычно правила помещаются на одной строке, но слишком длинные правила могут "
"быть перенесены:"

#: ../../reference/introduction.rst:180
msgid ""
"Alternatively, rules may be formatted with the first line ending at the "
"colon, and each alternative beginning with a vertical bar on a new line. For "
"example:"
msgstr ""
"В качестве альтернативы правила могут быть оформлены так, что первая строка "
"заканчивается двоеточием, а каждая альтернатива начинается с вертикальной "
"черты на новой строке. Например:"

#: ../../reference/introduction.rst:195
msgid "This does *not* mean that there is an empty first alternative."
msgstr "Это *не* означает, что существует пустая первая альтернатива."

#: ../../reference/introduction.rst:202
msgid "Lexical and Syntactic definitions"
msgstr "Лексические и синтаксические определения"

#: ../../reference/introduction.rst:204
msgid ""
"There is some difference between *lexical* and *syntactic* analysis: the :"
"term:`lexical analyzer` operates on the individual characters of the input "
"source, while the *parser* (syntactic analyzer) operates on the stream of :"
"term:`tokens <token>` generated by the lexical analysis. However, in some "
"cases the exact boundary between the two phases is a CPython implementation "
"detail."
msgstr ""
"Существует некоторое различие между *лексическим* и *синтаксическим* "
"анализом: :term:`лексический анализатор` работает с отдельными символами "
"исходного кода, в то время как *парсер* (синтаксический анализатор) работает "
"с потоком :term:`токенов <token>`, сгенерированных лексическим анализатором. "
"Однако в некоторых случаях точная граница между этими двумя этапами является "
"деталью реализации CPython."

#: ../../reference/introduction.rst:211
msgid ""
"The practical difference between the two is that in *lexical* definitions, "
"all whitespace is significant. The lexical analyzer :ref:`discards "
"<whitespace>` all whitespace that is not converted to tokens like :data:"
"`token.INDENT` or :data:`~token.NEWLINE`. *Syntactic* definitions then use "
"these tokens, rather than source characters."
msgstr ""
"Практическое различие между ними заключается в том, что в *лексических* "
"определениях все пробельные символы являются значимыми. Лексический "
"анализатор :ref:`отбрасывает <whitespace>` все пробельные символы, которые "
"не преобразуются в токены, такие как :data:`token.INDENT` или :data:`~token."
"NEWLINE`. *Синтаксические* определения затем используют эти токены, а не "
"исходные символы."

#: ../../reference/introduction.rst:217
msgid ""
"This documentation uses the same BNF grammar for both styles of definitions. "
"All uses of BNF in the next chapter (:ref:`lexical`) are lexical "
"definitions; uses in subsequent chapters are syntactic definitions."
msgstr ""
"В этой документации для обоих типов определений используется одна и та же "
"грамматика BNF. Все использования BNF в следующей главе (:ref:`lexical`) "
"являются лексическими определениями; а использования в последующих главах — "
"синтаксическими."

#: ../../reference/introduction.rst:91
msgid "BNF"
msgstr "BNF"

#: ../../reference/introduction.rst:91
msgid "grammar"
msgstr "грамматика"

#: ../../reference/introduction.rst:91
msgid "syntax"
msgstr "синтаксис"

#: ../../reference/introduction.rst:91
msgid "notation"
msgstr "нотация"

#: ../../reference/introduction.rst:197
msgid "lexical definitions"
msgstr "лексические определения"
