# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 14:56+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "Выражения"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "В этой главе объясняется значение элементов выражений в Python."

#: ../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**Примечания по синтаксису.** В этой и последующих главах расширенная "
"нотация BNF будет использоваться для описания синтаксиса, а не лексического "
"анализа. Когда (один из вариантов) синтаксическое правило имеет форму"

#: ../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"и никакая семантика не задана, семантика этой формы ``name`` такая же, как и "
"для ``othername``."

#: ../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "Арифметические преобразования"

#: ../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"Когда в описании арифметического оператора ниже используется фраза «числовые "
"аргументы преобразуются в общий тип», это означает, что реализация оператора "
"для встроенных типов работает следующим образом:"

#: ../../reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""
"Если один из аргументов является комплексным числом, другой преобразуется в "
"комплексное;"

#: ../../reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating-point number, the other is "
"converted to floating point;"
msgstr ""
"в противном случае, если один из аргументов является числом с плавающей "
"запятой, другой преобразуется в число с плавающей запятой;"

#: ../../reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""
"в противном случае оба должны быть целыми числами, и преобразование не "
"требуется."

#: ../../reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Для определенных операторов применяются некоторые дополнительные правила "
"(например, строка в качестве левого аргумента оператора «%»). Расширения "
"должны определять собственное поведение преобразования."

#: ../../reference/expressions.rst:49
msgid "Atoms"
msgstr "Атомы"

#: ../../reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Атомы — это самые основные элементы выражений. Простейшие атомы — это "
"идентификаторы или литералы. Формы, заключенные в круглые скобки или "
"фигурные скобки, также синтаксически классифицируются как атомы. Синтаксис "
"атомов:"

#: ../../reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "Идентификаторы (Имена)"

#: ../../reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"Идентификатор, встречающийся в виде атома, является именем. См. раздел :ref:"
"`identifiers` для лексического определения и раздел :ref:`naming` для "
"документации по именованию и привязке."

#: ../../reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"Когда имя привязано к объекту, вычисление атома дает этот объект. Когда имя "
"не привязано, попытка его оценки вызывает исключение :exc:`NameError`."

#: ../../reference/expressions.rst:87
msgid "Private name mangling"
msgstr "Искажение частного имени"

#: ../../reference/expressions.rst:89
msgid ""
"When an identifier that textually occurs in a class definition begins with "
"two or more underscore characters and does not end in two or more "
"underscores, it is considered a :dfn:`private name` of that class."
msgstr ""
"Если идентификатор, который текстуально встречается в определении класса, "
"начинается с двух или более символов подчеркивания и не заканчивается двумя "
"или более символами подчеркивания, он считается :dfn:`частным именем` этого "
"класса."

#: ../../reference/expressions.rst:95
msgid "The :ref:`class specifications <class>`."
msgstr ":ref:`Спецификации класса <class>`."

#: ../../reference/expressions.rst:97
msgid ""
"More precisely, private names are transformed to a longer form before code "
"is generated for them.  If the transformed name is longer than 255 "
"characters, implementation-defined truncation may happen."
msgstr ""
"Точнее, частные имена преобразуются в более длинную форму перед созданием "
"для них кода. Если преобразованное имя длиннее 255 символов, может произойти "
"усечение, определяемое реализацией."

#: ../../reference/expressions.rst:101
msgid ""
"The transformation is independent of the syntactical context in which the "
"identifier is used but only the following private identifiers are mangled:"
msgstr ""
"Преобразование не зависит от синтаксического контекста, в котором "
"используется идентификатор, но искажаются только следующие частные "
"идентификаторы:"

#: ../../reference/expressions.rst:104
msgid ""
"Any name used as the name of a variable that is assigned or read or any name "
"of an attribute being accessed."
msgstr ""
"Любое имя, используемое в качестве имени переменной, которая назначается или "
"читается, или любое имя атрибута, к которому осуществляется доступ."

#: ../../reference/expressions.rst:107
msgid ""
"The :attr:`~definition.__name__` attribute of nested functions, classes, and "
"type aliases is however not mangled."
msgstr ""
"Однако атрибут :attr:`~definition.__name__` вложенных функций, классов и "
"псевдонимов типов не искажается."

#: ../../reference/expressions.rst:110
msgid ""
"The name of imported modules, e.g., ``__spam`` in ``import __spam``. If the "
"module is part of a package (i.e., its name contains a dot), the name is "
"*not* mangled, e.g., the ``__foo`` in ``import __foo.bar`` is not mangled."
msgstr ""
"Имя импортируемых модулей, например, ``__spam`` в ``import __spam``. Если "
"модуль является частью пакета (т.е. его имя содержит точку), имя *не* "
"искажено, например, ``__foo`` в ``import __foo.bar`` не искажено."

#: ../../reference/expressions.rst:115
msgid ""
"The name of an imported member, e.g., ``__f`` in ``from spam import __f``."
msgstr ""
"Имя импортированного члена, например ``__f`` в ``from spam import __f``."

#: ../../reference/expressions.rst:117
msgid "The transformation rule is defined as follows:"
msgstr "Правило преобразования определяется следующим образом:"

#: ../../reference/expressions.rst:119
msgid ""
"The class name, with leading underscores removed and a single leading "
"underscore inserted, is inserted in front of the identifier, e.g., the "
"identifier ``__spam`` occurring in a class named ``Foo``, ``_Foo`` or "
"``__Foo`` is transformed to ``_Foo__spam``."
msgstr ""
"Имя класса без начального подчеркивания и вставленного одного начального "
"подчеркивания вставляется перед идентификатором, например, идентификатор "
"``__spam``, встречающийся в классе с именем ``Foo``, ``_Foo`` или `` "
"`__Foo`` преобразуется в ``_Foo__spam``."

#: ../../reference/expressions.rst:124
msgid ""
"If the class name consists only of underscores, the transformation is the "
"identity, e.g., the identifier ``__spam`` occurring in a class named ``_`` "
"or ``__`` is left as is."
msgstr ""
"Если имя класса состоит только из символов подчеркивания, преобразование "
"является идентификатором, например, идентификатор ``__spam``, встречающийся "
"в классе с именем ``_`` или ``__``, остается как есть."

#: ../../reference/expressions.rst:131
msgid "Literals"
msgstr "Литералы"

#: ../../reference/expressions.rst:135
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Python поддерживает строковые и байтовые литералы, а также различные "
"числовые литералы:"

#: ../../reference/expressions.rst:141
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating-point number, complex number) with the given value.  The "
"value may be approximated in the case of floating-point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"Оценка литерала дает объект заданного типа (строка, байты, целое число, "
"число с плавающей запятой, комплексное число) с заданным значением. Значение "
"может быть аппроксимировано в случае литералов с плавающей запятой и мнимых "
"(комплексных) литералов. Подробности смотрите в разделе :ref:`literals`."

#: ../../reference/expressions.rst:150
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Все литералы соответствуют неизменяемым типам данных, поэтому идентичность "
"объекта менее важна, чем его значение. Множественные вычисления литералов с "
"одним и тем же значением (либо одно и то же вхождение в тексте программы, "
"либо другое вхождение) могут привести к получению одного и того же объекта "
"или другого объекта с тем же значением."

#: ../../reference/expressions.rst:160
msgid "Parenthesized forms"
msgstr "Формы в скобках"

#: ../../reference/expressions.rst:166
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""
"Форма в скобках — это необязательный список выражений, заключенный в круглые "
"скобки:"

#: ../../reference/expressions.rst:171
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"Список выражений в скобках дает все, что дает этот список выражений: если "
"список содержит хотя бы одну запятую, он дает кортеж; в противном случае оно "
"возвращает единственное выражение, составляющее список выражений."

#: ../../reference/expressions.rst:177
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Пустая пара круглых скобок дает пустой объект кортежа. Поскольку кортежи "
"неизменяемы, применяются те же правила, что и для литералов (т. е. два "
"вхождения пустого кортежа могут давать или не давать один и тот же объект)."

#: ../../reference/expressions.rst:185
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma.  The exception is the empty tuple, for which parentheses *are* "
"required --- allowing unparenthesized \"nothing\" in expressions would cause "
"ambiguities and allow common typos to pass uncaught."
msgstr ""
"Обратите внимание, что кортежи формируются не с помощью круглых скобок, а с "
"помощью запятой. Исключением является пустой кортеж, для которого "
"*обязательны* круглые скобки --- разрешение \"ничего\" без скобок в "
"выражениях приведет к двусмысленности и позволит не обнаружить обычные "
"опечатки."

#: ../../reference/expressions.rst:194
msgid "Displays for lists, sets and dictionaries"
msgstr "Отображение списков, наборов и словарей"

#: ../../reference/expressions.rst:198
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Для построения списка, набора или словаря Python предоставляет специальный "
"синтаксис, называемый «дисплеями», каждый из которых имеет два варианта:"

#: ../../reference/expressions.rst:201
msgid "either the container contents are listed explicitly, or"
msgstr "либо содержимое контейнера указано явно, либо"

#: ../../reference/expressions.rst:203
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"они вычисляются с помощью набора инструкций цикла и фильтрации, называемых :"
"dfn:`comprehension`."

#: ../../reference/expressions.rst:211
msgid "Common syntax elements for comprehensions are:"
msgstr "Общие синтаксические элементы для понимания:"

#: ../../reference/expressions.rst:219
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"Понимание состоит из одного выражения, за которым следует как минимум одно "
"предложение :keyword:`!for` и ноль или более предложений :keyword:`!for` "
"или :keyword:`!if`. В этом случае элементами нового контейнера будут "
"элементы, которые будут созданы путем рассмотрения каждого из предложений :"
"keyword:`!for` или :keyword:`!if` в блоке, вложенных слева направо, и "
"вычисления выражения. для создания элемента каждый раз при достижении самого "
"внутреннего блока."

#: ../../reference/expressions.rst:226
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"Однако, помимо итерируемого выражения в крайнем левом предложении :keyword:`!"
"for`, понимание выполняется в отдельной неявно вложенной области видимости. "
"Это гарантирует, что имена, назначенные в целевом списке, не «просачатся» в "
"окружающую область."

#: ../../reference/expressions.rst:230
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"Итерируемое выражение в крайнем левом предложении :keyword:`!for` "
"вычисляется непосредственно в охватывающей области, а затем передается в "
"качестве аргумента в неявно вложенную область. Последующие предложения :"
"keyword:`!for` и любое условие фильтра в крайнем левом предложении :keyword:"
"`!for` не могут быть оценены во внешней области, поскольку они могут "
"зависеть от значений, полученных из самой левой итерации. Например: ``[x*y "
"для x в диапазоне(10) для y в диапазоне(x, x+10)]``."

#: ../../reference/expressions.rst:237
msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"Чтобы гарантировать, что в результате понимания всегда будет контейнер "
"соответствующего типа, выражения «yield» и «yield from» запрещены в неявно "
"вложенной области видимости."

#: ../../reference/expressions.rst:244
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions."
msgstr ""
"Начиная с Python 3.6, в функции :keyword:`async def` предложение :keyword:`!"
"async for` может использоваться для перебора :term:`асинхронного итератора`. "
"Понимание в функции :keyword:`!async def` может состоять из предложения :"
"keyword:`!for` или :keyword:`!async for`, следующего за ведущим выражением, "
"и может содержать дополнительные :keyword:`!for` или :keyword:`!async for`, "
"а также может использовать выражения :keyword:`await`."

#: ../../reference/expressions.rst:251
msgid ""
"If a comprehension contains :keyword:`!async for` clauses, or if it "
"contains :keyword:`!await` expressions or other asynchronous comprehensions "
"anywhere except the iterable expression in the leftmost :keyword:`!for` "
"clause, it is called an :dfn:`asynchronous comprehension`. An asynchronous "
"comprehension may suspend the execution of the coroutine function in which "
"it appears. See also :pep:`530`."
msgstr ""
"Если понимание содержит предложения :keyword:`!async for` или если оно "
"содержит выражения :keyword:`!await` или другие асинхронные понимания где "
"угодно, кроме итерируемого выражения в крайнем левом предложении :keyword:`!"
"for`, оно вызывается :dfn:`асинхронное понимание`. Асинхронное понимание "
"может приостановить выполнение функции сопрограммы, в которой оно "
"появляется. См. также :pep:`530`."

#: ../../reference/expressions.rst:258
msgid "Asynchronous comprehensions were introduced."
msgstr "Были введены асинхронные понимания."

#: ../../reference/expressions.rst:261 ../../reference/expressions.rst:439
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr "``yield`` и ``yield from`` запрещены в неявно вложенной области."

#: ../../reference/expressions.rst:264
msgid ""
"Asynchronous comprehensions are now allowed inside comprehensions in "
"asynchronous functions. Outer comprehensions implicitly become asynchronous."
msgstr ""
"Асинхронное понимание теперь разрешено внутри понимания в асинхронных "
"функциях. Внешнее понимание неявно становится асинхронным."

#: ../../reference/expressions.rst:273
msgid "List displays"
msgstr "Отображение списка"

#: ../../reference/expressions.rst:283
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"Отображение списка — это, возможно, пустая серия выражений, заключенная в "
"квадратные скобки:"

#: ../../reference/expressions.rst:289
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Отображение списка дает новый объект списка, содержимое которого "
"определяется либо списком выражений, либо пониманием. Когда предоставляется "
"список выражений, разделенных запятыми, его элементы оцениваются слева "
"направо и помещаются в объект списка в этом порядке. Когда предоставляется "
"понимание, список создается из элементов, полученных в результате понимания."

#: ../../reference/expressions.rst:299
msgid "Set displays"
msgstr "Установить дисплеи"

#: ../../reference/expressions.rst:308
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"Отображение набора обозначается фигурными скобками и отличается от "
"отображения словаря отсутствием двоеточий, разделяющих ключи и значения:"

#: ../../reference/expressions.rst:314
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Отображение набора дает новый изменяемый объект набора, содержимое которого "
"задается либо последовательностью выражений, либо пониманием. Когда "
"предоставляется список выражений, разделенных запятыми, его элементы "
"оцениваются слева направо и добавляются к заданному объекту. Когда "
"предоставляется понимание, набор создается из элементов, полученных в "
"результате понимания."

#: ../../reference/expressions.rst:320
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"Пустой набор не может быть создан с помощью ``{}``; этот литерал создает "
"пустой словарь."

#: ../../reference/expressions.rst:327
msgid "Dictionary displays"
msgstr "Отображение словаря"

#: ../../reference/expressions.rst:338
msgid ""
"A dictionary display is a possibly empty series of dict items (key/value "
"pairs) enclosed in curly braces:"
msgstr ""
"Отображение словаря — это, возможно, пустая серия элементов dict (пары ключ/"
"значение), заключенная в фигурные скобки:"

#: ../../reference/expressions.rst:347
msgid "A dictionary display yields a new dictionary object."
msgstr "Отображение словаря дает новый объект словаря."

#: ../../reference/expressions.rst:349
msgid ""
"If a comma-separated sequence of dict items is given, they are evaluated "
"from left to right to define the entries of the dictionary: each key object "
"is used as a key into the dictionary to store the corresponding value.  This "
"means that you can specify the same key multiple times in the dict item "
"list, and the final dictionary's value for that key will be the last one "
"given."
msgstr ""
"Если указана последовательность элементов dict, разделенная запятыми, они "
"оцениваются слева направо для определения записей словаря: каждый ключевой "
"объект используется в качестве ключа в словаре для хранения соответствующего "
"значения. Это означает, что вы можете указать один и тот же ключ несколько "
"раз в списке элементов dict, и окончательное значение словаря для этого "
"ключа будет последним заданным."

#: ../../reference/expressions.rst:359
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier dict items "
"and earlier dictionary unpackings."
msgstr ""
"Двойная звездочка ``**`` обозначает :dfn:`распаковку словаря`. Его операнд "
"должен быть :term:`mapping`. Каждый элемент сопоставления добавляется в "
"новый словарь. Более поздние значения заменяют значения, уже установленные "
"более ранними элементами dict и более ранними распаковками словаря."

#: ../../reference/expressions.rst:364
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr "Распаковка в словарные дисплеи, первоначально предложенная :pep:`448`."

#: ../../reference/expressions.rst:367
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"Для понимания dict, в отличие от понимания списков и наборов, требуются два "
"выражения, разделенные двоеточием, за которым следуют обычные предложения "
"«for» и «if». При запуске понимания полученные элементы ключа и значения "
"вставляются в новый словарь в том порядке, в котором они создаются."

#: ../../reference/expressions.rst:375
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last value (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Ограничения на типы значений ключей перечислены ранее в разделе :ref:"
"`types`. (Подводя итог, можно сказать, что тип ключа должен быть :term:"
"`hashable`, что исключает все изменяемые объекты.) Конфликты между "
"повторяющимися ключами не обнаруживаются; последнее значение (крайнее правое "
"по тексту на дисплее), сохраненное для данного значения ключа, имеет "
"преимущественную силу."

#: ../../reference/expressions.rst:381
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"До Python 3.8 в понимании dict порядок оценки ключа и значения не был четко "
"определен. В CPython значение оценивалось перед ключом. Начиная с версии "
"3.8, ключ оценивается перед значением, как предлагает :pep:`572`."

#: ../../reference/expressions.rst:391
msgid "Generator expressions"
msgstr "Выражения-генераторы"

#: ../../reference/expressions.rst:398
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"Выражение генератора — это компактное обозначение генератора в круглых "
"скобках:"

#: ../../reference/expressions.rst:403
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Выражение генератора дает новый объект-генератор. Его синтаксис такой же, "
"как и для понятий, за исключением того, что он заключен в круглые скобки, а "
"не в скобки или фигурные скобки."

#: ../../reference/expressions.rst:407
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, so that an error "
"produced by it will be emitted at the point where the generator expression "
"is defined, rather than at the point where the first value is retrieved. "
"Subsequent :keyword:`!for` clauses and any filter condition in the leftmost :"
"keyword:`!for` clause cannot be evaluated in the enclosing scope as they may "
"depend on the values obtained from the leftmost iterable. For example: "
"``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"Переменные, используемые в выражении генератора, оцениваются лениво, когда "
"для объекта генератора вызывается метод :meth:`~generator.__next__` (так же, "
"как и обычные генераторы). Однако итерируемое выражение в крайнем левом "
"предложении :keyword:`!for` вычисляется немедленно, поэтому ошибка, "
"создаваемая им, будет выдана в той точке, где определено выражение-"
"генератор, а не в той точке, где первое значение получено. Последующие "
"предложения :keyword:`!for` и любое условие фильтра в крайнем левом "
"предложении :keyword:`!for` не могут быть оценены во внешней области, "
"поскольку они могут зависеть от значений, полученных из самой левой "
"итерации. Например: ``(x*y для x в диапазоне(10) для y в диапазоне(x, "
"x+10))``."

#: ../../reference/expressions.rst:418
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"Круглые скобки можно опустить при вызовах только с одним аргументом. "
"Подробности смотрите в разделе :ref:`calls`."

#: ../../reference/expressions.rst:421
msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"Чтобы избежать вмешательства в ожидаемую работу самого выражения генератора, "
"выражения «yield» и «yield from» запрещены в неявно определенном генераторе."

#: ../../reference/expressions.rst:425
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Если выражение генератора содержит либо предложения :keyword:`!async for`, "
"либо выражения :keyword:`await`, оно называется :dfn:`выражением "
"асинхронного генератора`. Выражение асинхронного генератора возвращает новый "
"объект асинхронного генератора, который является асинхронным итератором "
"(см. :ref:`async-iterators`)."

#: ../../reference/expressions.rst:431
msgid "Asynchronous generator expressions were introduced."
msgstr "Были представлены выражения асинхронного генератора."

#: ../../reference/expressions.rst:434
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"До Python 3.7 выражения асинхронного генератора могли появляться только в "
"сопрограммах :keyword:`async def`. Начиная с версии 3.7 любая функция может "
"использовать выражения асинхронного генератора."

#: ../../reference/expressions.rst:446
msgid "Yield expressions"
msgstr "Получаемые выражения"

#: ../../reference/expressions.rst:459
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"Выражение доходности используется при определении функции :term:`generator` "
"или :term:`асинхронного генератора` и поэтому может использоваться только в "
"теле определения функции. Использование выражения доходности в теле функции "
"делает эту функцию функцией-генератором, а использование его в теле функции :"
"keyword:`async def` делает эту функцию-сопрограмму асинхронной функцией-"
"генератором. Например::"

#: ../../reference/expressions.rst:466
msgid ""
"def gen():  # defines a generator function\n"
"    yield 123\n"
"\n"
"async def agen(): # defines an asynchronous generator function\n"
"    yield 123"
msgstr ""
"def gen():  # defines a generator function\n"
"    yield 123\n"
"\n"
"async def agen(): # defines an asynchronous generator function\n"
"    yield 123"

#: ../../reference/expressions.rst:472
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"Из-за побочных эффектов на содержащуюся область видимости выражения «yield» "
"не допускаются как часть неявно определенных областей видимости, "
"используемых для реализации понятий и выражений-генераторов."

#: ../../reference/expressions.rst:476
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Выражения доходности запрещены в неявно вложенных областях, используемых для "
"реализации понятий и выражений генератора."

#: ../../reference/expressions.rst:480
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"Функции генератора описаны ниже, а функции асинхронного генератора описаны "
"отдельно в разделе :ref:`asynchronous-generator-functions`."

#: ../../reference/expressions.rst:484
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"yield_list` to the generator's caller, or ``None`` if :token:`~python-"
"grammar:yield_list` is omitted. By suspended, we mean that all local state "
"is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""
"Когда вызывается функция-генератор, она возвращает итератор, известный как "
"генератор. Затем этот генератор контролирует выполнение функции генератора. "
"Выполнение начинается при вызове одного из методов генератора. В этот момент "
"выполнение переходит к первому выражению доходности, где оно снова "
"приостанавливается, возвращая значение :token:`~python-grammar:yield_list` "
"вызывающей стороне генератора или ``None``, если :token:` ~python-grammar:"
"yield_list` опущен. Под приостановкой мы подразумеваем, что сохраняется все "
"локальное состояние, включая текущие привязки локальных переменных, "
"указатель инструкций, внутренний стек оценок и состояние любой обработки "
"исключений. Когда выполнение возобновляется путем вызова одного из методов "
"генератора, функция может действовать точно так, как если бы выражение "
"доходности было просто еще одним внешним вызовом. Значение выражения "
"доходности после возобновления зависит от метода, который возобновил "
"выполнение. Если используется :meth:`~generator.__next__` (обычно через :"
"keyword:`for` или встроенную функцию :func:`next`), то результатом будет :"
"const:`None`. В противном случае, если используется :meth:`~generator.send`, "
"результатом будет значение, переданное этому методу."

#: ../../reference/expressions.rst:504
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Все это делает функции-генераторы очень похожими на сопрограммы; они выдают "
"несколько раз, имеют более одной точки входа, и их выполнение может быть "
"приостановлено. Единственное отличие состоит в том, что функция-генератор не "
"может контролировать, где должно продолжиться выполнение после завершения; "
"управление всегда передается вызывающей стороне генератора."

#: ../../reference/expressions.rst:510
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"Выражения доходности разрешены в любом месте конструкции :keyword:`try`. "
"Если генератор не возобновится до его завершения (по достижении нулевого "
"счетчика ссылок или при сборке мусора), будет вызван метод :meth:`~generator."
"close` генератора-итератора, разрешающий любые ожидающие :keyword:`finally "
"`предложения для выполнения."

#: ../../reference/expressions.rst:519
msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"Когда используется «yield from <expr>», предоставленное выражение должно "
"быть итерируемым. Значения, полученные в результате итерации этого "
"итерируемого объекта, передаются непосредственно вызывающей стороне методов "
"текущего генератора. Любые значения, переданные с помощью :meth:`~generator."
"send`, и любые исключения, переданные с помощью :meth:`~generator.throw`, "
"передаются базовому итератору, если у него есть соответствующие методы. Если "
"это не так, то :meth:`~generator.send` вызовет :exc:`AttributeError` или :"
"exc:`TypeError`, а :meth:`~generator.throw` просто вызовет переданное "
"исключение. немедленно."

#: ../../reference/expressions.rst:528
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"Когда базовый итератор завершен, атрибут :attr:`~StopIteration.value` "
"поднятого экземпляра :exc:`StopIteration` становится значением выражения "
"доходности. Его можно установить либо явно при вызове :exc:`StopIteration`, "
"либо автоматически, когда подитератор является генератором (путем возврата "
"значения из подгенератора)."

#: ../../reference/expressions.rst:534
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"Добавлен ``yield from <expr>`` для делегирования потока управления "
"субитератору."

#: ../../reference/expressions.rst:537
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Круглые скобки можно опустить, если выражение доходности является "
"единственным выражением в правой части оператора присваивания."

#: ../../reference/expressions.rst:542
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Простые генераторы"

#: ../../reference/expressions.rst:543
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"Предложение по добавлению генераторов и оператора :keyword:`yield` в Python."

#: ../../reference/expressions.rst:545
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ""
"Предложение по добавлению генераторов и оператора :keyword:`yield` в Python."

#: ../../reference/expressions.rst:546
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"Предложение улучшить API и синтаксис генераторов, сделав их пригодными для "
"использования в качестве простых сопрограмм."

#: ../../reference/expressions.rst:549
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - Синтаксис делегирования подгенератору"

#: ../../reference/expressions.rst:550
msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr ""
"Предложение ввести синтаксис :token:`~python-grammar:yield_from`, упрощающий "
"делегирование подгенераторам."

#: ../../reference/expressions.rst:553
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - Асинхронные генераторы"

#: ../../reference/expressions.rst:554
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"Предложение, которое расширило :pep:`492` за счет добавления возможностей "
"генератора к сопрограммным функциям."

#: ../../reference/expressions.rst:561
msgid "Generator-iterator methods"
msgstr "Методы генератора-итератора"

#: ../../reference/expressions.rst:563
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"В этом подразделе описываются методы итератора-генератора. Их можно "
"использовать для управления выполнением функции генератора."

#: ../../reference/expressions.rst:566
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Обратите внимание, что вызов любого из приведенных ниже методов генератора, "
"когда генератор уже выполняется, вызывает исключение :exc:`ValueError`."

#: ../../reference/expressions.rst:574
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:yield_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""
"Начинает выполнение функции-генератора или возобновляет его с момента "
"последнего выполненного выражения доходности. Когда функция генератора "
"возобновляется с помощью метода :meth:`~generator.__next__`, текущее "
"выражение доходности всегда оценивается как :const:`None`. Затем выполнение "
"продолжается до следующего выражения доходности, где генератор снова "
"приостанавливается, и значение :token:`~python-grammar:yield_list` "
"возвращается вызывающей стороне :meth:`__next__`. Если генератор завершает "
"работу, не выдав другого значения, возникает исключение :exc:`StopIteration`."

#: ../../reference/expressions.rst:583
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Этот метод обычно вызывается неявно, например, с помощью цикла :keyword:"
"`for` или встроенной функции :func:`next`."

#: ../../reference/expressions.rst:589
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Возобновляет выполнение и «отправляет» значение в функцию-генератор. "
"Аргумент *value* становится результатом текущего выражения доходности. "
"Метод :meth:`send` возвращает следующее значение, полученное генератором, "
"или вызывает :exc:`StopIteration`, если генератор завершает работу, не выдав "
"другого значения. Когда :meth:`send` вызывается для запуска генератора, его "
"необходимо вызывать с :const:`None` в качестве аргумента, поскольку не "
"существует выражения доходности, которое могло бы получить значение."

#: ../../reference/expressions.rst:601
msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"Вызывает исключение в момент приостановки работы генератора и возвращает "
"следующее значение, полученное функцией генератора. Если генератор завершает "
"работу, не выдав другого значения, возникает исключение :exc:"
"`StopIteration`. Если функция-генератор не перехватывает переданное "
"исключение или вызывает другое исключение, то это исключение "
"распространяется на вызывающую сторону."

#: ../../reference/expressions.rst:607
msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr ""
"Обычно это вызывается с одним экземпляром исключения, аналогично тому, как "
"используется ключевое слово :keyword:`raise`."

#: ../../reference/expressions.rst:610
msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""
"Однако для обратной совместимости поддерживается вторая подпись, следуя "
"соглашению старых версий Python. Аргумент *type* должен быть классом "
"исключения, а *value* должен быть экземпляром исключения. Если *значение* не "
"указано, вызывается конструктор *type* для получения экземпляра. Если указан "
"*traceback*, он устанавливается для исключения, в противном случае любой "
"существующий атрибут :attr:`~BaseException.__traceback__`, хранящийся в "
"*value*, может быть очищен."

#: ../../reference/expressions.rst:621 ../../reference/expressions.rst:798
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"Вторая подпись \\(type\\[, value\\[, trace\\]\\]\\ устарела и может быть "
"удалена в будущей версии Python."

#: ../../reference/expressions.rst:629
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  :meth:`close` does nothing if the generator "
"has already exited due to an exception or normal exit."
msgstr ""
"Вызывает :exc:`GeneratorExit` в момент, когда функция генератора была "
"приостановлена. Если функция-генератор затем корректно завершает работу, уже "
"закрыта или вызывает :exc:`GeneratorExit` (не перехватывая исключение), "
"close возвращается к вызывающей стороне. Если генератор выдает значение, "
"возникает ошибка :exc:`RuntimeError`. Если генератор вызывает какое-либо "
"другое исключение, оно передается вызывающей стороне. :meth:`close` ничего "
"не делает, если генератор уже завершил работу из-за исключения или обычного "
"выхода."

#: ../../reference/expressions.rst:640
msgid "Examples"
msgstr "Примеры"

#: ../../reference/expressions.rst:642
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Вот простой пример, демонстрирующий поведение генераторов и функций-"
"генераторов:"

#: ../../reference/expressions.rst:645
msgid ""
">>> def echo(value=None):\n"
"...     print(\"Execution starts when 'next()' is called for the first time."
"\")\n"
"...     try:\n"
"...         while True:\n"
"...             try:\n"
"...                 value = (yield value)\n"
"...             except Exception as e:\n"
"...                 value = e\n"
"...     finally:\n"
"...         print(\"Don't forget to clean up when 'close()' is called.\")\n"
"...\n"
">>> generator = echo(1)\n"
">>> print(next(generator))\n"
"Execution starts when 'next()' is called for the first time.\n"
"1\n"
">>> print(next(generator))\n"
"None\n"
">>> print(generator.send(2))\n"
"2\n"
">>> generator.throw(TypeError, \"spam\")\n"
"TypeError('spam',)\n"
">>> generator.close()\n"
"Don't forget to clean up when 'close()' is called."
msgstr ""
">>> def echo(value=None):\n"
"...     print(\"Execution starts when 'next()' is called for the first time."
"\")\n"
"...     try:\n"
"...         while True:\n"
"...             try:\n"
"...                 value = (yield value)\n"
"...             except Exception as e:\n"
"...                 value = e\n"
"...     finally:\n"
"...         print(\"Don't forget to clean up when 'close()' is called.\")\n"
"...\n"
">>> generator = echo(1)\n"
">>> print(next(generator))\n"
"Execution starts when 'next()' is called for the first time.\n"
"1\n"
">>> print(next(generator))\n"
"None\n"
">>> print(generator.send(2))\n"
"2\n"
">>> generator.throw(TypeError, \"spam\")\n"
"TypeError('spam',)\n"
">>> generator.close()\n"
"Don't forget to clean up when 'close()' is called."

#: ../../reference/expressions.rst:669
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"Примеры использования «yield from» см. в разделе :ref:`pep-380` в разделе "
"«Что нового в Python»."

#: ../../reference/expressions.rst:675
msgid "Asynchronous generator functions"
msgstr "Функции асинхронного генератора"

#: ../../reference/expressions.rst:677
msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"Присутствие выражения доходности в функции или методе, определенном с "
"помощью :keyword:`async def`, дополнительно определяет функцию как :term:"
"`асинхронный генератор`."

#: ../../reference/expressions.rst:681
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"Когда вызывается функция асинхронного генератора, она возвращает асинхронный "
"итератор, известный как объект асинхронного генератора. Затем этот объект "
"управляет выполнением функции генератора. Объект асинхронного генератора "
"обычно используется в операторе :keyword:`async for` в сопрограммной функции "
"аналогично тому, как объект-генератор будет использоваться в операторе :"
"keyword:`for`."

#: ../../reference/expressions.rst:688
msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"yield_list` to the awaiting coroutine. As with a generator, suspension means "
"that all local state is retained, including the current bindings of local "
"variables, the instruction pointer, the internal evaluation stack, and the "
"state of any exception handling. When the execution is resumed by awaiting "
"on the next object returned by the asynchronous generator's methods, the "
"function can proceed exactly as if the yield expression were just another "
"external call. The value of the yield expression after resuming depends on "
"the method which resumed the execution.  If :meth:`~agen.__anext__` is used "
"then the result is :const:`None`. Otherwise, if :meth:`~agen.asend` is used, "
"then the result will be the value passed in to that method."
msgstr ""
"Вызов одного из методов асинхронного генератора возвращает объект :term:"
"`awaitable`, и выполнение начинается, когда этот объект ожидается. В этот "
"момент выполнение переходит к первому выражению доходности, где оно снова "
"приостанавливается, возвращая значение :token:`~python-grammar:yield_list` "
"ожидающей сопрограмме. Как и в случае с генератором, приостановка означает, "
"что сохраняется все локальное состояние, включая текущие привязки локальных "
"переменных, указатель инструкций, внутренний стек вычислений и состояние "
"любой обработки исключений. Когда выполнение возобновляется путем ожидания "
"следующего объекта, возвращаемого методами асинхронного генератора, функция "
"может действовать точно так, как если бы выражение доходности было просто "
"еще одним внешним вызовом. Значение выражения доходности после возобновления "
"зависит от метода, который возобновил выполнение. Если используется :meth:"
"`~agen.__anext__`, то результатом будет :const:`None`. В противном случае, "
"если используется :meth:`~agen.asend`, результатом будет значение, "
"переданное этому методу."

#: ../../reference/expressions.rst:703
msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"Если асинхронный генератор завершает работу досрочно из-за :keyword:`break`, "
"отмены вызывающей задачи или других исключений, код асинхронной очистки "
"генератора запустится и, возможно, вызовет исключения или получит доступ к "
"переменным контекста в неожиданном контексте - возможно, после время жизни "
"задач, это зависит, или во время завершения цикла событий, когда вызывается "
"ловушка сбора мусора асинхронного генератора. Чтобы предотвратить это, "
"вызывающая сторона должна явно закрыть асинхронный генератор, вызвав метод :"
"meth:`~agen.aclose`, чтобы завершить работу генератора и в конечном итоге "
"отсоединить его от цикла событий."

#: ../../reference/expressions.rst:713
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"В функции асинхронного генератора выражения доходности разрешены в любом "
"месте конструкции :keyword:`try`. Однако если асинхронный генератор не "
"возобновляется до его завершения (по достижении нулевого счетчика ссылок или "
"при сборке мусора), то выражение доходности внутри конструкции :keyword:`!"
"try` может привести к сбою выполнения в ожидании: ключевое слово: "
"предложения `finally`. В этом случае цикл событий или планировщик, "
"запускающий асинхронный генератор, несет ответственность за вызов метода :"
"meth:`~agen.aclose` асинхронного генератора-итератора и запуск "
"результирующего объекта сопрограммы, тем самым разрешая любые ожидающие :"
"keyword:` !finally` предложения для выполнения."

#: ../../reference/expressions.rst:724
msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"Чтобы обеспечить финализацию после завершения цикла событий, цикл событий "
"должен определить функцию *finalizer*, которая принимает асинхронный "
"генератор-итератор и предположительно вызывает :meth:`~agen.aclose` и "
"выполняет сопрограмму. Этот *финализатор* можно зарегистрировать, вызвав :"
"func:`sys.set_asyncgen_hooks`. При первой итерации асинхронный генератор-"
"итератор сохранит зарегистрированный *финализатор*, который будет вызываться "
"при финализации. Справочный пример метода *finalizer* см. в реализации "
"asyncio.Loop.shutdown_asyncgens в :source:`Lib/asyncio/base_events.py`."

#: ../../reference/expressions.rst:733
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"Выражение ``yield from <expr>`` является синтаксической ошибкой при "
"использовании в функции асинхронного генератора."

#: ../../reference/expressions.rst:740
msgid "Asynchronous generator-iterator methods"
msgstr "Методы асинхронного генератора-итератора"

#: ../../reference/expressions.rst:742
msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"В этом подразделе описаны методы итератора асинхронного генератора, которые "
"используются для управления выполнением функции-генератора."

#: ../../reference/expressions.rst:751
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:yield_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""
"Возвращает ожидаемый объект, который при запуске запускает выполнение "
"асинхронного генератора или возобновляет его с момента последнего "
"выполненного выражения доходности. Когда функция асинхронного генератора "
"возобновляется с помощью метода :meth:`~agen.__anext__`, текущее выражение "
"доходности всегда оценивается как :const:`None` в возвращаемом ожидаемом "
"объекте, который при запуске продолжится до следующего выражения доходности. "
"Значение :token:`~python-grammar:yield_list` выражения доходности является "
"значением исключения :exc:`StopIteration`, вызванного завершающей "
"сопрограммой. Если асинхронный генератор завершает работу, не выдав другого "
"значения, вместо этого awaitable вызывает исключение :exc:"
"`StopAsyncIteration`, сигнализирующее о завершении асинхронной итерации."

#: ../../reference/expressions.rst:763
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""
"Этот метод обычно вызывается неявно с помощью цикла :keyword:`async for`."

#: ../../reference/expressions.rst:769
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"Возвращает ожидаемый объект, который при запуске возобновляет выполнение "
"асинхронного генератора. Как и в случае с методом :meth:`~generator.send` "
"для генератора, он «отправляет» значение в функцию асинхронного генератора, "
"и аргумент *value* становится результатом текущего выражения доходности. "
"Ожидаемый объект, возвращаемый методом :meth:`asend`, вернет следующее "
"значение, полученное генератором, как значение поднятого :exc:"
"`StopIteration`, или вызовет :exc:`StopAsyncIteration`, если асинхронный "
"генератор завершает работу, не выдав другого ценить. Когда :meth:`asend` "
"вызывается для запуска асинхронного генератора, его необходимо вызывать с :"
"const:`None` в качестве аргумента, поскольку не существует выражения "
"доходности, которое могло бы получить значение."

#: ../../reference/expressions.rst:786
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Возвращает ожидаемый объект, который вызывает исключение типа ``type`` в "
"момент, когда работа асинхронного генератора была приостановлена, и "
"возвращает следующее значение, полученное функцией-генератором, в качестве "
"значения вызванного исключения :exc:`StopIteration`. Если асинхронный "
"генератор завершает работу, не выдав другого значения, ожидаемое событие "
"вызывает исключение :exc:`StopAsyncIteration`. Если функция-генератор не "
"перехватывает переданное исключение или вызывает другое исключение, то при "
"запуске ожидаемого объекта это исключение распространяется на вызывающую "
"сторону ожидаемого объекта."

#: ../../reference/expressions.rst:807
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Возвращает ожидаемый объект, который при запуске вызовет :exc:"
"`GeneratorExit` в функцию асинхронного генератора в точке, где она была "
"приостановлена. Если асинхронная функция-генератор затем корректно завершает "
"работу, уже закрыта или вызывает :exc:`GeneratorExit` (не перехватывая "
"исключение), то возвращаемый ожидаемый объект вызовет исключение :exc:"
"`StopIteration`. Любые дальнейшие ожидаемые объекты, возвращаемые "
"последующими вызовами асинхронного генератора, вызовут исключение :exc:"
"`StopAsyncIteration`. Если асинхронный генератор выдает значение, ожидаемый "
"объект вызывает :exc:`RuntimeError`. Если асинхронный генератор вызывает "
"какое-либо другое исключение, оно передается вызывающему объекту awaitable. "
"Если асинхронный генератор уже завершил работу из-за исключения или обычного "
"выхода, то дальнейшие вызовы :meth:`aclose` вернут ожидаемый объект, который "
"ничего не делает."

#: ../../reference/expressions.rst:823
msgid "Primaries"
msgstr "праймериз"

#: ../../reference/expressions.rst:827
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Первичные элементы представляют собой наиболее тесно связанные операции "
"языка. Их синтаксис:"

#: ../../reference/expressions.rst:837
msgid "Attribute references"
msgstr "Ссылки на атрибуты"

#: ../../reference/expressions.rst:843
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""
"Ссылка на атрибут представляет собой основной атрибут, за которым следует "
"точка и имя:"

#: ../../reference/expressions.rst:853
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier. The type and value produced is "
"determined by the object.  Multiple evaluations of the same attribute "
"reference may yield different objects."
msgstr ""
"Первичный объект должен оценивать объект типа, который поддерживает ссылки "
"на атрибуты, что и делает большинство объектов. Затем этому объекту "
"предлагается создать атрибут, имя которого является идентификатором. Тип и "
"производимое значение определяются объектом. Множественные оценки одной и "
"той же ссылки на атрибут могут дать разные объекты."

#: ../../reference/expressions.rst:859
msgid ""
"This production can be customized by overriding the :meth:`~object."
"__getattribute__` method or the :meth:`~object.__getattr__` method.  The :"
"meth:`!__getattribute__` method is called first and either returns a value "
"or raises :exc:`AttributeError` if the attribute is not available."
msgstr ""
"Это производство можно настроить, переопределив метод :meth:`~object."
"__getattribute__` или метод :meth:`~object.__getattr__`. Метод :meth:`!"
"__getattribute__` вызывается первым и либо возвращает значение, либо выдает :"
"exc:`AttributeError`, если атрибут недоступен."

#: ../../reference/expressions.rst:865
msgid ""
"If an :exc:`AttributeError` is raised and the object has a :meth:`!"
"__getattr__` method, that method is called as a fallback."
msgstr ""
"Если возникает :exc:`AttributeError` и у объекта есть метод :meth:`!"
"__getattr__`, этот метод вызывается как резервный."

#: ../../reference/expressions.rst:871
msgid "Subscriptions"
msgstr "Подписки"

#: ../../reference/expressions.rst:886
msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"Подписка на экземпляр класса контейнера <sequence-types> обычно выбирает "
"элемент из контейнера. Подписка на :term:`generic class <generic type>` "
"обычно возвращает объект :ref:`GenericAlias ​​<types-genericalias>`."

#: ../../reference/expressions.rst:894
msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr ""
"Когда объект индексируется, интерпретатор оценивает основной объект и список "
"выражений."

#: ../../reference/expressions.rst:897
msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"Первичный объект должен оценить объект, поддерживающий подписку. Объект "
"может поддерживать подписку посредством определения одного или обоих из :"
"meth:`~object.__getitem__` и :meth:`~object.__class_getitem__`. Когда "
"основной индекс подписан, вычисленный результат списка выражений будет "
"передан одному из этих методов. Более подробную информацию о том, когда "
"вызывается __class_getitem__ вместо __getitem__, смотрите :ref:`classgetitem-"
"versus-getitem`."

#: ../../reference/expressions.rst:904
msgid ""
"If the expression list contains at least one comma, or if any of the "
"expressions are starred, the expression list will evaluate to a :class:"
"`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr ""
"Если список выражений содержит хотя бы одну запятую или если какое-либо из "
"выражений отмечено звездочкой, то результатом списка выражений будет :class:"
"`tuple`, содержащий элементы списка выражений. В противном случае список "
"выражений будет оценивать значение единственного члена списка."

#: ../../reference/expressions.rst:909
msgid "Expressions in an expression list may be starred. See :pep:`646`."
msgstr ""
"Выражения в списке выражений могут быть помечены звездочкой. См. :pep:`646`."

#: ../../reference/expressions.rst:912
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr ""
"Для встроенных объектов существует два типа объектов, которые поддерживают "
"подписку через :meth:`~object.__getitem__`:"

#: ../../reference/expressions.rst:915
msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"Отображения. Если основным является :term:`mapping`, список выражений должен "
"оценивать объект, значение которого является одним из ключей сопоставления, "
"а подписка выбирает значение в сопоставлении, соответствующее этому ключу. "
"Примером встроенного класса сопоставления является класс :class:`dict`."

#: ../../reference/expressions.rst:919
msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"Последовательности. Если первичным является :term:`sequence`, список "
"выражений должен оцениваться как :class:`int` или :class:`slice` (как "
"описано в следующем разделе). Примеры встроенных классов последовательностей "
"включают классы :class:`str`, :class:`list` и :class:`tuple`."

#: ../../reference/expressions.rst:924
msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`~object."
"__getitem__` method, subclasses overriding this method will need to "
"explicitly add that support."
msgstr ""
"Формальный синтаксис не предусматривает специальных условий для "
"отрицательных индексов в :term:`sequences <sequence>`. Однако все встроенные "
"последовательности предоставляют метод :meth:`~object.__getitem__`, который "
"интерпретирует отрицательные индексы, добавляя длину последовательности к "
"индексу, так что, например, ``x[-1]`` выбирает последний элемент ``x``. "
"Результирующее значение должно быть неотрицательным целым числом, меньшим, "
"чем количество элементов в последовательности, и подписка выбирает элемент, "
"индекс которого равен этому значению (считая с нуля). Поскольку поддержка "
"отрицательных индексов и срезов осуществляется в методе объекта :meth:"
"`~object.__getitem__`, подклассы, переопределяющие этот метод, должны будут "
"явно добавить эту поддержку."

#: ../../reference/expressions.rst:938
msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ""
":class:`string <str>` — это особый вид последовательности, элементами "
"которой являются *символы*. Символ — это не отдельный тип данных, а строка, "
"состоящая ровно из одного символа."

#: ../../reference/expressions.rst:946
msgid "Slicings"
msgstr "Нарезки"

#: ../../reference/expressions.rst:960
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Срез выбирает диапазон элементов в объекте последовательности (например, "
"строку, кортеж или список). Срезы могут использоваться как выражения или как "
"цели в операторах присваивания или :keyword:`del`. Синтаксис нарезки:"

#: ../../reference/expressions.rst:973
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Здесь есть двусмысленность в формальном синтаксисе: все, что выглядит как "
"список выражений, также выглядит как список срезов, поэтому любую подписку "
"можно интерпретировать как срез. Вместо дальнейшего усложнения синтаксиса "
"это устраняется определением того, что в этом случае интерпретация как "
"подписка имеет приоритет над интерпретацией как срез (это тот случай, если "
"список срезов не содержит подходящего среза)."

#: ../../reference/expressions.rst:985
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`~object.__getitem__` method as normal subscription) with a "
"key that is constructed from the slice list, as follows.  If the slice list "
"contains at least one comma, the key is a tuple containing the conversion of "
"the slice items; otherwise, the conversion of the lone slice item is the "
"key.  The conversion of a slice item that is an expression is that "
"expression.  The conversion of a proper slice is a slice object (see "
"section :ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :"
"attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for "
"missing expressions."
msgstr ""
"Семантика нарезки следующая. Первичный объект индексируется (с "
"использованием того же метода :meth:`~object.__getitem__`, что и при обычной "
"подписке) с помощью ключа, который создается из списка срезов, как показано "
"ниже. Если список срезов содержит хотя бы одну запятую, ключ представляет "
"собой кортеж, содержащий преобразование элементов срезов; в противном случае "
"ключевым моментом является преобразование единственного элемента среза. "
"Преобразование элемента среза, являющегося выражением, и есть это выражение. "
"Преобразование правильного среза представляет собой объект среза (см. "
"раздел :ref:`types`), чьи :attr:`~slice.start`, :attr:`~slice.stop` и :attr:"
"`~slice.step` Атрибуты — это значения выражений, заданных как нижняя "
"граница, верхняя граница и шаг соответственно, с заменой «Нет» для "
"отсутствующих выражений."

#: ../../reference/expressions.rst:1009
msgid "Calls"
msgstr "Звонки"

#: ../../reference/expressions.rst:1011
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Вызов вызывает вызываемый объект (например, :term:`function`) с возможно "
"пустой серией :term:`arguments <argument>`:"

#: ../../reference/expressions.rst:1028
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Необязательная завершающая запятая может присутствовать после позиционных и "
"ключевых аргументов, но не влияет на семантику."

#: ../../reference/expressions.rst:1034
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`~object.__call__` method "
"are callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"Первичный объект должен возвращать вызываемый объект (определяемые "
"пользователем функции, встроенные функции, методы встроенных объектов, "
"объекты классов, методы экземпляров классов и все объекты, имеющие метод :"
"meth:`~object.__call__`, являются возможность вызова). Все выражения "
"аргументов оцениваются перед попыткой вызова. Пожалуйста, обратитесь к "
"разделу :ref:`function` для ознакомления с синтаксисом формальных списков :"
"term:`parameter`."

#: ../../reference/expressions.rst:1042
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the argument is placed in the slot, filling it (even if the expression is "
"``None``, it fills the slot).  When all arguments have been processed, the "
"slots that are still unfilled are filled with the corresponding default "
"value from the function definition.  (Default values are calculated, once, "
"when the function is defined; thus, a mutable object such as a list or "
"dictionary used as default value will be shared by all calls that don't "
"specify an argument value for the corresponding slot; this should usually be "
"avoided.)  If there are any unfilled slots for which no default value is "
"specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of "
"filled slots is used as the argument list for the call."
msgstr ""
"Если аргументы ключевого слова присутствуют, они сначала преобразуются в "
"позиционные аргументы следующим образом. Сначала для формальных параметров "
"создается список незаполненных слотов. Если имеется N позиционных "
"аргументов, они помещаются в первые N слотов. Далее для каждого ключевого "
"аргумента идентификатор используется для определения соответствующего слота "
"(если идентификатор совпадает с именем первого формального параметра, "
"используется первый слот и т. д.). Если слот уже заполнен, возникает "
"исключение :exc:`TypeError`. В противном случае аргумент помещается в слот, "
"заполняя его (даже если выражение имеет значение «None», оно заполняет "
"слот). Когда все аргументы обработаны, незаполненные слоты заполняются "
"соответствующим значением по умолчанию из определения функции. (Значения по "
"умолчанию вычисляются один раз при определении функции; таким образом, "
"изменяемый объект, такой как список или словарь, используемый в качестве "
"значения по умолчанию, будет использоваться всеми вызовами, которые не "
"указывают значение аргумента для соответствующего слота; это должно обычно "
"этого следует избегать.) Если есть незаполненные слоты, для которых не "
"указано значение по умолчанию, возникает исключение :exc:`TypeError`. В "
"противном случае список заполненных слотов используется в качестве списка "
"аргументов вызова."

#: ../../reference/expressions.rst:1062
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"Реализация может предоставлять встроенные функции, чьи позиционные параметры "
"не имеют имен, даже если они «именованы» для целей документации и поэтому не "
"могут быть переданы по ключевому слову. В CPython это относится к функциям, "
"реализованным на C, которые используют :c:func:`PyArg_ParseTuple` для "
"анализа своих аргументов."

#: ../../reference/expressions.rst:1068
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"Если позиционных аргументов больше, чем слотов формальных параметров, "
"возникает исключение :exc:`TypeError`, если только не присутствует "
"формальный параметр, использующий синтаксис ``*identifier``; в этом случае "
"этот формальный параметр получает кортеж, содержащий лишние позиционные "
"аргументы (или пустой кортеж, если лишних позиционных аргументов не было)."

#: ../../reference/expressions.rst:1074
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Если какой-либо аргумент ключевого слова не соответствует имени формального "
"параметра, возникает исключение :exc:`TypeError`, если только не "
"присутствует формальный параметр, использующий синтаксис ``**identifier``; в "
"этом случае этот формальный параметр получает словарь, содержащий лишние "
"аргументы ключевых слов (с использованием ключевых слов в качестве ключей и "
"значений аргументов в качестве соответствующих значений), или (новый) пустой "
"словарь, если не было лишних аргументов ключевых слов."

#: ../../reference/expressions.rst:1085
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Если в вызове функции встречается синтаксис ``*expression``, ``выражение`` "
"должно иметь результат :term:`iterable`. Элементы этих итераций "
"обрабатываются так, как если бы они были дополнительными позиционными "
"аргументами. Для вызова ``f(x1, x2, *y, x3, x4)``, если *y* оценивается как "
"последовательность *y1*, ..., *yM*, это эквивалентно вызову с M+ 4 "
"позиционных аргумента *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."

#: ../../reference/expressions.rst:1092
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"Следствием этого является то, что хотя синтаксис ``*выражения`` может "
"появляться *после* явных аргументов ключевого слова, он обрабатывается "
"*перед* аргументами ключевого слова (и любыми аргументами ``**выражения`` - "
"см. ниже). Так::"

#: ../../reference/expressions.rst:1096
msgid ""
">>> def f(a, b):\n"
"...     print(a, b)\n"
"...\n"
">>> f(b=1, *(2,))\n"
"2 1\n"
">>> f(a=1, *(2,))\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: f() got multiple values for keyword argument 'a'\n"
">>> f(1, *(2,))\n"
"1 2"
msgstr ""
">>> def f(a, b):\n"
"...     print(a, b)\n"
"...\n"
">>> f(b=1, *(2,))\n"
"2 1\n"
">>> f(a=1, *(2,))\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: f() got multiple values for keyword argument 'a'\n"
">>> f(1, *(2,))\n"
"1 2"

#: ../../reference/expressions.rst:1108
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not often arise."
msgstr ""
"Использование в одном вызове как аргументов ключевого слова, так и "
"синтаксиса ``*expression`` является необычным, поэтому на практике такая "
"путаница возникает нечасто."

#: ../../reference/expressions.rst:1114
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""
"Если в вызове функции появляется синтаксис ``**выражение``, ``выражение`` "
"должно иметь значение :term:`mapping`, содержимое которого рассматривается "
"как дополнительные аргументы ключевого слова. Если параметру, "
"соответствующему ключу, уже присвоено значение (явным аргументом ключевого "
"слова или другой распаковкой), возникает исключение :exc:`TypeError`."

#: ../../reference/expressions.rst:1120
msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""
"Когда используется ``**expression``, каждый ключ в этом сопоставлении должен "
"быть строкой. Каждое значение сопоставления присваивается первому "
"формальному параметру, подходящему для назначения ключевого слова, имя "
"которого равно ключу. Ключ не обязательно должен быть идентификатором Python "
"(например, ``\"max-temp °F\"`` допустим, хотя он не будет соответствовать "
"никакому формальному параметру, который мог бы быть объявлен). Если "
"совпадения с формальным параметром нет, пара ключ-значение собирается "
"параметром ``**``, если он есть или нет, возникает исключение :exc:"
"`TypeError`."

#: ../../reference/expressions.rst:1130
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Формальные параметры, использующие синтаксис ``*identifier`` или "
"``**identifier``, не могут использоваться в качестве позиционных слотов "
"аргументов или в качестве имен аргументов ключевого слова."

#: ../../reference/expressions.rst:1133
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"Вызовы функций допускают любое количество распаковок ``*`` и ``**``, "
"позиционные аргументы могут следовать за итерируемыми распаковками (``*``), "
"а аргументы ключевых слов могут следовать за распаковками по словарю "
"(``**``). Первоначально предложено :pep:`448`."

#: ../../reference/expressions.rst:1139
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Вызов всегда возвращает какое-то значение, возможно, None, если только он не "
"вызывает исключение. Способ вычисления этого значения зависит от типа "
"вызываемого объекта."

#: ../../reference/expressions.rst:1143
msgid "If it is---"
msgstr "Если это так..."

#: ../../reference/expressions.rst:1145
msgid "a user-defined function:"
msgstr "определяемая пользователем функция:"

#: ../../reference/expressions.rst:1152
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call.  If execution reaches the end of the code block "
"without executing a :keyword:`return` statement, the return value is "
"``None``."
msgstr ""
"Блок кода функции выполняется с передачей ему списка аргументов. Первое, что "
"сделает блок кода, — это привяжет формальные параметры к аргументам; это "
"описано в разделе :ref:`function`. Когда блок кода выполняет оператор :"
"keyword:`return`, он определяет возвращаемое значение вызова функции. Если "
"выполнение достигает конца блока кода без выполнения оператора :keyword:"
"`return`, возвращаемым значением будет ``None``."

#: ../../reference/expressions.rst:1159
msgid "a built-in function or method:"
msgstr "встроенная функция или метод:"

#: ../../reference/expressions.rst:1170
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"Результат зависит от переводчика; см. :ref:`built-in-funcs` для описания "
"встроенных функций и методов."

#: ../../reference/expressions.rst:1173
msgid "a class object:"
msgstr "объект класса:"

#: ../../reference/expressions.rst:1178
msgid "A new instance of that class is returned."
msgstr "Возвращается новый экземпляр этого класса."

#: ../../reference/expressions.rst:1180
msgid "a class instance method:"
msgstr "метод экземпляра класса:"

#: ../../reference/expressions.rst:1186
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"Вызывается соответствующая определяемая пользователем функция со списком "
"аргументов, который на один длиннее списка аргументов вызова: экземпляр "
"становится первым аргументом."

#: ../../reference/expressions.rst:1190
msgid "a class instance:"
msgstr "экземпляр класса:"

#: ../../reference/expressions.rst:1195
msgid ""
"The class must define a :meth:`~object.__call__` method; the effect is then "
"the same as if that method was called."
msgstr ""
"Класс должен определить метод :meth:`~object.__call__`; тогда эффект будет "
"таким же, как если бы этот метод был вызван."

#: ../../reference/expressions.rst:1203 ../../reference/expressions.rst:2001
msgid "Await expression"
msgstr "Ожидание выражения"

#: ../../reference/expressions.rst:1205
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Приостановить выполнение :term:`coroutine` для :term:`awaitable` объекта. "
"Может использоваться только внутри функции сопрограммы."

#: ../../reference/expressions.rst:1217
msgid "The power operator"
msgstr "Энергетический оператор"

#: ../../reference/expressions.rst:1223
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"Оператор степени связывается сильнее, чем унарные операторы слева от него; "
"он связывается менее жестко, чем унарные операторы справа. Синтаксис:"

#: ../../reference/expressions.rst:1229
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Таким образом, в последовательности степенных и унарных операторов без "
"скобок операторы вычисляются справа налево (это не ограничивает порядок "
"вычисления операндов): ``-1**2`` приводит к ``-1`` ."

#: ../../reference/expressions.rst:1233
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"Оператор степени имеет ту же семантику, что и встроенная функция :func:"
"`pow`, при вызове с двумя аргументами: он возвращает левый аргумент, "
"возведенный в степень правого аргумента. Числовые аргументы сначала "
"преобразуются в общий тип, и результат имеет этот тип."

#: ../../reference/expressions.rst:1238
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"Для операндов типа int результат имеет тот же тип, что и операнды, если "
"только второй аргумент не отрицательный; в этом случае все аргументы "
"преобразуются в число с плавающей запятой и выдается результат с плавающей "
"запятой. Например, ``10**2`` возвращает ``100``, а ``10**-2`` возвращает "
"``0,01``."

#: ../../reference/expressions.rst:1243
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Возведение ``0.0`` в отрицательную степень приводит к ошибке :exc:"
"`ZeroDivisionError`. Возведение отрицательного числа в дробную степень "
"приводит к получению :class:`комплексного` числа. (В более ранних версиях "
"возникала ошибка :exc:`ValueError`.)"

#: ../../reference/expressions.rst:1247
msgid ""
"This operation can be customized using the special :meth:`~object.__pow__` "
"and :meth:`~object.__rpow__` methods."
msgstr ""
"Эту операцию можно настроить с помощью специальных методов :meth:`~object."
"__pow__` и :meth:`~object.__rpow__`."

#: ../../reference/expressions.rst:1253
msgid "Unary arithmetic and bitwise operations"
msgstr "Унарная арифметика и побитовые операции"

#: ../../reference/expressions.rst:1259
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Все унарные арифметические и побитовые операции имеют одинаковый приоритет:"

#: ../../reference/expressions.rst:1270
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`~object.__neg__` "
"special method."
msgstr ""
"Унарный оператор ``-`` (минус) дает отрицание своего числового аргумента; "
"операцию можно переопределить с помощью специального метода :meth:`~object."
"__neg__`."

#: ../../reference/expressions.rst:1278
msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`~object.__pos__` special method."
msgstr ""
"Унарный оператор ``+`` (плюс) возвращает свой числовой аргумент без "
"изменений; операцию можно переопределить с помощью специального метода :meth:"
"`~object.__pos__`."

#: ../../reference/expressions.rst:1285
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`~object.__invert__` special method."
msgstr ""
"Унарный оператор ``~`` (инвертирование) производит побитовую инверсию своего "
"целочисленного аргумента. Побитовая инверсия ``x`` определяется как ``-"
"(x+1)``. Это применимо только к целым числам или к пользовательским "
"объектам, которые переопределяют специальный метод :meth:`~object."
"__invert__`."

#: ../../reference/expressions.rst:1294
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"Во всех трех случаях, если аргумент не имеет правильного типа, возникает "
"исключение :exc:`TypeError`."

#: ../../reference/expressions.rst:1301
msgid "Binary arithmetic operations"
msgstr "Двоичные арифметические операции"

#: ../../reference/expressions.rst:1305
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"Операции двоичной арифметики имеют обычные уровни приоритета. Обратите "
"внимание, что некоторые из этих операций также применимы к определенным "
"нечисловым типам. Помимо оператора степени, существует только два уровня: "
"один для мультипликативных операторов и один для аддитивных операторов:"

#: ../../reference/expressions.rst:1320
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"Оператор ``*`` (умножения) возвращает произведение своих аргументов. Оба "
"аргумента должны быть числами, либо один аргумент должен быть целым числом, "
"а другой — последовательностью. В первом случае числа преобразуются к общему "
"типу, а затем перемножаются. В последнем случае выполняется повторение "
"последовательности; отрицательный коэффициент повторения дает пустую "
"последовательность."

#: ../../reference/expressions.rst:1326
msgid ""
"This operation can be customized using the special :meth:`~object.__mul__` "
"and :meth:`~object.__rmul__` methods."
msgstr ""
"Эту операцию можно настроить с помощью специальных методов :meth:`~object."
"__mul__` и :meth:`~object.__rmul__`."

#: ../../reference/expressions.rst:1333
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"Оператор ``@`` (at) предназначен для использования для умножения матриц. Ни "
"один встроенный тип Python не реализует этот оператор."

#: ../../reference/expressions.rst:1336
msgid ""
"This operation can be customized using the special :meth:`~object."
"__matmul__` and :meth:`~object.__rmatmul__` methods."
msgstr ""
"Эту операцию можно настроить с помощью специальных методов :meth:`~object."
"__matmul__` и :meth:`~object.__rmatmul__`."

#: ../../reference/expressions.rst:1347
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Операторы ``/`` (деление) и ``//`` (деление этажей) возвращают частное своих "
"аргументов. Числовые аргументы сначала преобразуются в общий тип. Деление "
"целых чисел дает число с плавающей запятой, а деление целых чисел на пол "
"дает целое число; Результатом является математическое деление с применением "
"к результату функции «пол». Деление на ноль вызывает исключение :exc:"
"`ZeroDivisionError`."

#: ../../reference/expressions.rst:1354
msgid ""
"The division operation can be customized using the special :meth:`~object."
"__truediv__` and :meth:`~object.__rtruediv__` methods. The floor division "
"operation can be customized using the special :meth:`~object.__floordiv__` "
"and :meth:`~object.__rfloordiv__` methods."
msgstr ""
"Операцию деления можно настроить с помощью специальных методов :meth:"
"`~object.__truediv__` и :meth:`~object.__rtruediv__`. Операцию разделения "
"этажей можно настроить с помощью специальных методов :meth:`~object."
"__floordiv__` и :meth:`~object.__rfloordiv__`."

#: ../../reference/expressions.rst:1363
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating-point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"Оператор ``%`` (по модулю) возвращает остаток от деления первого аргумента "
"на второй. Числовые аргументы сначала преобразуются в общий тип. Нулевой "
"правый аргумент вызывает исключение :exc:`ZeroDivisionError`. Аргументы "
"могут быть числами с плавающей запятой, например, ``3.14%0.7`` равно "
"``0.34`` (так как ``3.14`` равно ``4*0.7 + 0.34``.) Оператор по модулю "
"всегда дает результат. с тем же знаком, что и его второй операнд (или ноль); "
"абсолютное значение результата строго меньше абсолютного значения второго "
"операнда [#]_ ."

#: ../../reference/expressions.rst:1372
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Операторы деления этажей и по модулю связаны следующим тождеством: ``x == "
"(x//y)*y + (x%y)``. Деление этажей и модуль также связаны со встроенной "
"функцией :func:`divmod`: ``divmod(x, y) == (x//y, x%y)``. [#]_ ."

#: ../../reference/expressions.rst:1377
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"Помимо выполнения операции по модулю над числами, оператор ``%`` также "
"перегружается строковыми объектами для выполнения форматирования строк в "
"старом стиле (также известного как интерполяция). Синтаксис форматирования "
"строк описан в Справочнике библиотеки Python, раздел :ref:`old-string-"
"formatting`."

#: ../../reference/expressions.rst:1382
msgid ""
"The *modulo* operation can be customized using the special :meth:`~object."
"__mod__` and :meth:`~object.__rmod__` methods."
msgstr ""
"Операцию *modulo* можно настроить с помощью специальных методов :meth:"
"`~object.__mod__` и :meth:`~object.__rmod__`."

#: ../../reference/expressions.rst:1385
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating-point number using the :func:`abs` function if appropriate."
msgstr ""
"Оператор нижнего деления, оператор по модулю и функция :func:`divmod` не "
"определены для комплексных чисел. Вместо этого преобразуйте число в число с "
"плавающей запятой, используя функцию :func:`abs`, если это необходимо."

#: ../../reference/expressions.rst:1394
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""
"Оператор ``+`` (сложение) возвращает сумму своих аргументов. Оба аргумента "
"должны быть числами или последовательностями одного типа. В первом случае "
"числа преобразуются к общему типу, а затем складываются. В последнем случае "
"последовательности объединяются."

#: ../../reference/expressions.rst:1399
msgid ""
"This operation can be customized using the special :meth:`~object.__add__` "
"and :meth:`~object.__radd__` methods."
msgstr ""
"Эту операцию можно настроить с помощью специальных методов :meth:`~object."
"__add__` и :meth:`~object.__radd__`."

#: ../../reference/expressions.rst:1407
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""
"Оператор ``-`` (вычитание) возвращает разницу своих аргументов. Числовые "
"аргументы сначала преобразуются в общий тип."

#: ../../reference/expressions.rst:1410
msgid ""
"This operation can be customized using the special :meth:`~object.__sub__` "
"and :meth:`~object.__rsub__` methods."
msgstr ""
"Эту операцию можно настроить с помощью специальных методов :meth:`~object."
"__sub__` и :meth:`~object.__rsub__`."

#: ../../reference/expressions.rst:1417
msgid "Shifting operations"
msgstr "Shifting operations"

#: ../../reference/expressions.rst:1424
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"Операции сдвига имеют более низкий приоритет, чем арифметические операции:"

#: ../../reference/expressions.rst:1429
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Эти операторы принимают целые числа в качестве аргументов. Они сдвигают "
"первый аргумент влево или вправо на количество бит, заданное вторым "
"аргументом."

#: ../../reference/expressions.rst:1432
msgid ""
"The left shift operation can be customized using the special :meth:`~object."
"__lshift__` and :meth:`~object.__rlshift__` methods. The right shift "
"operation can be customized using the special :meth:`~object.__rshift__` "
"and :meth:`~object.__rrshift__` methods."
msgstr ""
"Операцию сдвига влево можно настроить с помощью специальных методов :meth:"
"`~object.__lshift__` и :meth:`~object.__rlshift__`. Операцию сдвига вправо "
"можно настроить с помощью специальных методов :meth:`~object.__rshift__` и :"
"meth:`~object.__rrshift__`."

#: ../../reference/expressions.rst:1439
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"Сдвиг вправо на *n* бит определяется как деление нижнего уровня на ``pow(2,"
"n)``. Сдвиг влево на *n* бит определяется как умножение на ``pow(2,n)``."

#: ../../reference/expressions.rst:1446
msgid "Binary bitwise operations"
msgstr "Двоичные побитовые операции"

#: ../../reference/expressions.rst:1450
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "Каждая из трех побитовых операций имеет разный уровень приоритета:"

#: ../../reference/expressions.rst:1461
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`~object."
"__and__` or :meth:`~object.__rand__` special methods."
msgstr ""
"Оператор ``&`` выдает поразрядное И своих аргументов, которые должны быть "
"целыми числами или один из них должен быть пользовательским объектом, "
"переопределяющим специальные методы :meth:`~object.__and__` или :meth:"
"`~object.__rand__` ."

#: ../../reference/expressions.rst:1470
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`~object.__xor__` or :meth:`~object.__rxor__` special methods."
msgstr ""
"Оператор ``^`` выдает побитовое исключающее ИЛИ (исключающее ИЛИ) своих "
"аргументов, которые должны быть целыми числами или один из них должен быть "
"пользовательским объектом, переопределяющим :meth:`~object.__xor__` или :"
"meth:`~object. __rxor__` специальные методы."

#: ../../reference/expressions.rst:1479
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`~object.__or__` or :meth:`~object.__ror__` special methods."
msgstr ""
"Оператор ``|`` выдает поразрядное (включающее) ИЛИ своих аргументов, которые "
"должны быть целыми числами или один из них должен быть пользовательским "
"объектом, переопределяющим :meth:`~object.__or__` или :meth:`~object.__ror__ "
"`специальные методы."

#: ../../reference/expressions.rst:1487
msgid "Comparisons"
msgstr "Сравнения"

#: ../../reference/expressions.rst:1499
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"В отличие от C, все операции сравнения в Python имеют одинаковый приоритет, "
"который ниже, чем у любой арифметической, сдвиговой или побитовой операции. "
"Также в отличие от C, выражения типа ``a < b < c`` имеют общепринятую в "
"математике интерпретацию:"

#: ../../reference/expressions.rst:1509
msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"Сравнения дают логические значения: ``True`` или ``False``. "
"Пользовательские :dfn:`методы расширенного сравнения` могут возвращать "
"нелогические значения. В этом случае Python вызовет :func:`bool` для такого "
"значения в логическом контексте."

#: ../../reference/expressions.rst:1515
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Сравнения могут быть объединены в произвольную цепочку, например, ``x < y <= "
"z`` эквивалентно ``x < y и y <= z``, за исключением того, что ``y`` "
"вычисляется только один раз (но в обоих случаях ``z`` вообще не оценивается, "
"если ``x < y`` оказывается ложным)."

#: ../../reference/expressions.rst:1519
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Формально, если *a*, *b*, *c*, ..., *y*, *z* являются выражениями, а *op1*, "
"*op2*, ..., *opN* — операторами сравнения, то ` `a op1 b op2 c ... y opN z`` "
"эквивалентно ``a op1 b и b op2 c и ... y opN z``, за исключением того, что "
"каждое выражение вычисляется не более одного раза."

#: ../../reference/expressions.rst:1524
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Обратите внимание, что ``a op1 b op2 c`` не подразумевает какого-либо "
"сравнения между *a* и *c*, так что, например, ``x < y > z`` совершенно "
"законно (хотя, возможно, и не совсем корректно). )."

#: ../../reference/expressions.rst:1531
msgid "Value comparisons"
msgstr "Сравнение значений"

#: ../../reference/expressions.rst:1533
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Операторы ``<``, ``>``, ``==``, ``>=``, ``<=`` и ``!=`` сравнивают значения "
"двух объектов. Объекты не обязательно должны быть одного типа."

#: ../../reference/expressions.rst:1536
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"В главе :ref:`objects` говорится, что объекты имеют значение (помимо типа и "
"идентификатора). Значение объекта — довольно абстрактное понятие в Python: "
"например, не существует канонического метода доступа к значению объекта. "
"Кроме того, не требуется, чтобы значение объекта было создано определенным "
"образом, например, состоящим из всех его атрибутов данных. Операторы "
"сравнения реализуют особое представление о значении объекта. Их можно "
"рассматривать как определение значения объекта косвенно, посредством "
"реализации сравнения."

#: ../../reference/expressions.rst:1545
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`~object.__lt__`, described in :ref:`customization`."
msgstr ""
"Поскольку все типы являются (прямыми или косвенными) подтипами :class:"
"`object`, они наследуют поведение сравнения по умолчанию от :class:`object`. "
"Типы могут настраивать свое поведение сравнения, реализуя :dfn:`богатые "
"методы сравнения`, такие как :meth:`~object.__lt__`, описанные в :ref:"
"`customization`."

#: ../../reference/expressions.rst:1551
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"Поведение по умолчанию для сравнения на равенство (``==`` и ``!=``) основано "
"на идентичности объектов. Следовательно, сравнение экземпляров с одинаковыми "
"идентификаторами на равенство приводит к равенству, а сравнение экземпляров "
"с разными идентификаторами на равенство приводит к неравенству. Мотивацией "
"такого поведения по умолчанию является желание, чтобы все объекты были "
"рефлексивными (т.е. ``x есть y`` подразумевает ``x == y``)."

#: ../../reference/expressions.rst:1558
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"Сравнение порядка по умолчанию (``<``, ``>``, ``<=`` и ``>=`` не "
"предусмотрено; попытка вызывает :exc:`TypeError`. Мотивацией такого "
"поведения по умолчанию является отсутствие инварианта, аналогичного "
"инварианту равенства."

#: ../../reference/expressions.rst:1562
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"Поведение сравнения на равенство по умолчанию, когда экземпляры с разными "
"идентификаторами всегда неравны, может противоречить тем типам, которые "
"потребуются для разумного определения значения объекта и равенства на основе "
"значений. Таким типам потребуется настроить поведение сравнения, и на самом "
"деле это уже сделано во многих встроенных типах."

#: ../../reference/expressions.rst:1568
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"В следующем списке описано поведение сравнения наиболее важных встроенных "
"типов."

#: ../../reference/expressions.rst:1571
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Числа встроенных числовых типов (:ref:`typesnumeric`) и типов стандартной "
"библиотеки :class:`fractions.Fraction` и :class:`decimal.Decimal` можно "
"сравнивать внутри и между их типами с ограничением что комплексные числа не "
"поддерживают сравнение порядков. В пределах задействованных типов они "
"сравнивают математически (алгоритмически) корректно без потери точности."

#: ../../reference/expressions.rst:1578
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Нечисловые значения ``float('NaN')`` и ``decimal.Decimal('NaN')`` являются "
"особенными. Любое упорядоченное сравнение числа со значением, не являющимся "
"числом, является ложным. Противоречивым выводом является то, что нечисловые "
"значения не равны сами себе. Например, если ``x = float('NaN')``, ``3 < x``, "
"``x < 3`` и ``x == x`` все являются ложными, а ``x ! = x`` верно. Такое "
"поведение соответствует стандарту IEEE 754."

#: ../../reference/expressions.rst:1585
msgid ""
"``None`` and :data:`NotImplemented` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` и :data:`NotImplemented` являются одиночными. :PEP:`8` советует, "
"что сравнения одиночных элементов всегда следует выполнять с помощью ``is`` "
"или ``is not``, а не операторов равенства."

#: ../../reference/expressions.rst:1589
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Двоичные последовательности (экземпляры :class:`bytes` или :class:"
"`bytearray`) можно сравнивать внутри и между их типами. Они сравниваются "
"лексикографически, используя числовые значения своих элементов."

#: ../../reference/expressions.rst:1593
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Строки (экземпляры :class:`str`) сравниваются лексикографически с "
"использованием числовых кодовых точек Юникода (результат встроенной функции :"
"func:`ord`) их символов. [#]_"

#: ../../reference/expressions.rst:1597
msgid "Strings and binary sequences cannot be directly compared."
msgstr "Строки и двоичные последовательности нельзя сравнивать напрямую."

#: ../../reference/expressions.rst:1599
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Последовательности (экземпляры :class:`tuple`, :class:`list` или :class:"
"`range`) можно сравнивать только внутри каждого из их типов, с тем "
"ограничением, что диапазоны не поддерживают сравнение порядка. Сравнение на "
"равенство между этими типами приводит к неравенству, а сравнение порядка "
"между этими типами вызывает ошибку :exc:`TypeError`."

#: ../../reference/expressions.rst:1605
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"Последовательности сравниваются лексикографически, используя сравнение "
"соответствующих элементов. Встроенные контейнеры обычно предполагают, что "
"идентичные объекты равны сами себе. Это позволяет им обходить проверки на "
"равенство идентичных объектов, чтобы повысить производительность и сохранить "
"свои внутренние инварианты."

#: ../../reference/expressions.rst:1610
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"Лексикографическое сравнение встроенных коллекций работает следующим образом:"

#: ../../reference/expressions.rst:1612
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"Чтобы две коллекции считались равными, они должны быть одного типа, иметь "
"одинаковую длину, и каждая пара соответствующих элементов должна "
"сравниваться одинаково (например, ``[1,2] == (1,2)`` false, потому что тип "
"не тот)."

#: ../../reference/expressions.rst:1617
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"Коллекции, поддерживающие сравнение порядка, упорядочиваются так же, как их "
"первые неравные элементы (например, ``[1,2,x] <= [1,2,y]`` имеет то же "
"значение, что и ``x <= y` `). Если соответствующий элемент не существует, "
"сначала упорядочивается более короткая коллекция (например, ``[1,2] < "
"[1,2,3]`` истинно)."

#: ../../reference/expressions.rst:1623
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"Отображения (экземпляры :class:`dict`) сравниваются равными тогда и только "
"тогда, когда они имеют равные пары ``(ключ, значение)``. Сравнение ключей и "
"значений на равенство обеспечивает рефлексивность."

#: ../../reference/expressions.rst:1627
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Сравнение порядков (``<``, ``>``, ``<=`` и ``>=``) вызывает :exc:`TypeError`."

#: ../../reference/expressions.rst:1629
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Наборы (экземпляры :class:`set` или :class:`frozenset`) можно сравнивать "
"внутри и между их типами."

#: ../../reference/expressions.rst:1632
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"Они определяют операторы сравнения порядков, означающие тесты подмножества и "
"надмножества. Эти отношения не определяют общий порядок (например, два "
"множества ``{1,2}`` и ``{2,3}`` не равны, не являются подмножествами друг "
"друга или надмножествами друг друга). Соответственно, наборы не являются "
"подходящими аргументами для функций, которые зависят от общего порядка "
"(например, :func:`min`, :func:`max` и :func:`sorted` дают неопределенные "
"результаты, учитывая список наборов в качестве входных данных). ."

#: ../../reference/expressions.rst:1640
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "Сравнение множеств усиливает рефлексивность его элементов."

#: ../../reference/expressions.rst:1642
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"В большинстве других встроенных типов методы сравнения не реализованы, "
"поэтому они наследуют поведение сравнения по умолчанию."

#: ../../reference/expressions.rst:1645
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"Пользовательские классы, которые настраивают поведение сравнения, должны по "
"возможности следовать некоторым правилам согласованности:"

#: ../../reference/expressions.rst:1648
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"Сравнение равенства должно быть рефлексивным. Другими словами, идентичные "
"объекты должны сравниваться равными:"

#: ../../reference/expressions.rst:1651
msgid "``x is y`` implies ``x == y``"
msgstr "``x есть y`` подразумевает ``x == y``"

#: ../../reference/expressions.rst:1653
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"Сравнение должно быть симметричным. Другими словами, следующие выражения "
"должны иметь одинаковый результат:"

#: ../../reference/expressions.rst:1656
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` и ``y == x``"

#: ../../reference/expressions.rst:1658
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` и ``y != x``"

#: ../../reference/expressions.rst:1660
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` и ``y > x``"

#: ../../reference/expressions.rst:1662
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` и ``y >= x``"

#: ../../reference/expressions.rst:1664
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"Сравнение должно быть транзитивным. Следующие (неполные) примеры "
"иллюстрируют это:"

#: ../../reference/expressions.rst:1667
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y и y > z`` подразумевает ``x > z``"

#: ../../reference/expressions.rst:1669
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y и y <= z`` подразумевает ``x < z``"

#: ../../reference/expressions.rst:1671
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"Обратное сравнение должно привести к логическому отрицанию. Другими словами, "
"следующие выражения должны иметь одинаковый результат:"

#: ../../reference/expressions.rst:1674
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` and ``not x != y``"

#: ../../reference/expressions.rst:1676
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` and ``not x >= y``  (для полного порядка) "

#: ../../reference/expressions.rst:1678
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` and ``not x <= y``  (для общего порядка) "

#: ../../reference/expressions.rst:1680
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"Последние два выражения применимы к полностью упорядоченным коллекциям "
"(например, к последовательностям, но не к наборам или отображениям). См. "
"также декоратор :func:`~functools.total_ordering`."

#: ../../reference/expressions.rst:1684
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"Результат :func:`hash` должен соответствовать равенству. Равные объекты "
"должны либо иметь одинаковое значение хэш-функции, либо быть помечены как "
"нехешируемые."

#: ../../reference/expressions.rst:1688
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"Python не обеспечивает соблюдение этих правил согласованности. Фактически, "
"нечисловые значения являются примером несоблюдения этих правил."

#: ../../reference/expressions.rst:1697
msgid "Membership test operations"
msgstr "Операции проверки членства"

#: ../../reference/expressions.rst:1699
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Операторы :keyword:`in` и :keyword:`not in` проверяют членство. ``x in s`` "
"оценивается как ``True``, если *x* является членом *s*, и ``False`` в "
"противном случае. ``x not in s`` возвращает отрицание ``x in s``. Все "
"встроенные последовательности и типы наборов поддерживают это, а также "
"словарь, для которого :keyword:`!in` проверяет, есть ли в словаре заданный "
"ключ. Для таких типов контейнеров, как список, кортеж, набор, Frozeset, dict "
"или Collections.deque, выражение ``x в y`` эквивалентно ``any(x is e или x "
"== e for e in y)` `."

#: ../../reference/expressions.rst:1707
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"Для типов строк и байтов ``x в y`` имеет значение ``True`` тогда и только "
"тогда, когда *x* является подстрокой *y*. Эквивалентный тест: ``y.find(x) != "
"-1``. Пустые строки всегда считаются подстрокой любой другой строки, поэтому "
"``\"\" в \"abc\"`` вернет ``True``."

#: ../../reference/expressions.rst:1712
msgid ""
"For user-defined classes which define the :meth:`~object.__contains__` "
"method, ``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true "
"value, and ``False`` otherwise."
msgstr ""
"Для пользовательских классов, которые определяют метод :meth:`~object."
"__contains__`, ``x in y`` возвращает ``True``, если ``y.__contains__(x)`` "
"возвращает истинное значение, а `` «Ложь» в противном случае."

#: ../../reference/expressions.rst:1716
msgid ""
"For user-defined classes which do not define :meth:`~object.__contains__` "
"but do define :meth:`~object.__iter__`, ``x in y`` is ``True`` if some value "
"``z``, for which the expression ``x is z or x == z`` is true, is produced "
"while iterating over ``y``. If an exception is raised during the iteration, "
"it is as if :keyword:`in` raised that exception."
msgstr ""
"Для пользовательских классов, которые не определяют :meth:`~object."
"__contains__`, но определяют :meth:`~object.__iter__`, ``x в y`` имеет "
"значение ``True``, если какое-то значение ``z ``, для которого истинно "
"выражение ``x is z или x == z``, создается при итерации по ``y``. Если во "
"время итерации возникает исключение, это как если бы :keyword:`in` вызвал "
"это исключение."

#: ../../reference/expressions.rst:1722
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`~object.__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x is y[i] or x == y[i]``, and no "
"lower integer index raises the :exc:`IndexError` exception.  (If any other "
"exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Наконец, пробуется протокол итерации старого стиля: если класс определяет :"
"meth:`~object.__getitem__`, ``x в y`` имеет значение ``True`` тогда и только "
"тогда, когда существует неотрицательный целочисленный индекс. *i* такое, что "
"``x равно y[i] или x == y[i]``, и никакой младший целочисленный индекс не "
"вызывает исключение :exc:`IndexError`. (Если возникает какое-либо другое "
"исключение, это равносильно тому, как если бы :keyword:`in` вызвал это "
"исключение)."

#: ../../reference/expressions.rst:1734
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"Оператор :keyword:`not in` имеет обратное значение истинности :keyword:`in`."

#: ../../reference/expressions.rst:1747
msgid "Identity comparisons"
msgstr "Сравнение идентичностей"

#: ../../reference/expressions.rst:1749
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Операторы :keyword:`is` и :keyword:`is not` проверяют идентичность объекта: "
"``x is y`` истинно тогда и только тогда, когда *x* и *y* являются одним и "
"тем же объектом. Идентичность объекта определяется с помощью функции :meth:"
"`id`. ``x не y`` дает обратное значение истинности. [#]_"

#: ../../reference/expressions.rst:1761
msgid "Boolean operations"
msgstr "Булевы операции"

#: ../../reference/expressions.rst:1772
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`~object."
"__bool__` method."
msgstr ""
"В контексте логических операций, а также когда выражения используются "
"операторами потока управления, следующие значения интерпретируются как "
"ложные: ``False``, ``None``, числовой ноль всех типов, а также пустые строки "
"и контейнеры ( включая строки, кортежи, списки, словари, наборы и "
"замороженные наборы). Все остальные значения интерпретируются как истинные. "
"Пользовательские объекты могут настраивать свое значение истинности, "
"предоставляя метод :meth:`~object.__bool__`."

#: ../../reference/expressions.rst:1781
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"Оператор :keyword:`not` возвращает ``True``, если его аргумент ложный, и "
"``False`` в противном случае."

#: ../../reference/expressions.rst:1786
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Выражение ``x and y`` сначала оценивает *x*; если *x* имеет значение false, "
"возвращается его значение; в противном случае оценивается *y* и возвращается "
"результирующее значение."

#: ../../reference/expressions.rst:1791
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Выражение ``x или y`` сначала оценивает *x*; если *x* истинно, возвращается "
"его значение; в противном случае оценивается *y* и возвращается "
"результирующее значение."

#: ../../reference/expressions.rst:1794
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Обратите внимание, что ни :keyword:`and`, ни :keyword:`or` не ограничивают "
"возвращаемое значение и тип как ``False`` и ``True``, а скорее возвращают "
"последний вычисленный аргумент. Иногда это полезно, например, если ``s`` "
"является строкой, которую следует заменить значением по умолчанию, если оно "
"пусто, выражение ``s или 'foo'`` дает желаемое значение. Поскольку :keyword:"
"`not` должен создавать новое значение, он возвращает логическое значение "
"независимо от типа своего аргумента (например, ``not 'foo'`` выдает "
"``False``, а не ``'' ``.)"

#: ../../reference/expressions.rst:1810
msgid "Assignment expressions"
msgstr "Выражения присваивания"

#: ../../reference/expressions.rst:1815
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"Выражение присваивания (иногда называемое «именованным выражением» или "
"«моржом») присваивает :token:`~python-grammar:expression` :token:`~python-"
"grammar:identifier`, а также возвращает значение :token:`~python-grammar:"
"expression`."

#: ../../reference/expressions.rst:1820
msgid "One common use case is when handling matched regular expressions:"
msgstr ""
"Один из распространенных случаев использования — обработка совпадающих "
"регулярных выражений:"

#: ../../reference/expressions.rst:1822
msgid ""
"if matching := pattern.search(data):\n"
"    do_something(matching)"
msgstr ""
"if matching := pattern.search(data):\n"
"    do_something(matching)"

#: ../../reference/expressions.rst:1827
msgid "Or, when processing a file stream in chunks:"
msgstr "Или при обработке файлового потока частями:"

#: ../../reference/expressions.rst:1829
msgid ""
"while chunk := file.read(9000):\n"
"    process(chunk)"
msgstr ""
"while chunk := file.read(9000):\n"
"    process(chunk)"

#: ../../reference/expressions.rst:1834
msgid ""
"Assignment expressions must be surrounded by parentheses when used as "
"expression statements and when used as sub-expressions in slicing, "
"conditional, lambda, keyword-argument, and comprehension-if expressions and "
"in ``assert``, ``with``, and ``assignment`` statements. In all other places "
"where they can be used, parentheses are not required, including in ``if`` "
"and ``while`` statements."
msgstr ""
"Выражения присваивания должны быть заключены в круглые скобки при "
"использовании в качестве операторов выражения и при использовании в качестве "
"подвыражений в выражениях среза, условных, лямбда-выражениях, выражениях с "
"ключевым словом-аргументом и понимании-если, а также в выражениях "
"``assert``, ``with`` и операторы ``назначения``. Во всех остальных местах, "
"где их можно использовать, круглые скобки не требуются, в том числе в "
"операторах if и while."

#: ../../reference/expressions.rst:1842
msgid "See :pep:`572` for more details about assignment expressions."
msgstr ""
"См. :pep:`572` для получения более подробной информации о выражениях "
"присваивания."

#: ../../reference/expressions.rst:1849
msgid "Conditional expressions"
msgstr "Условные выражения"

#: ../../reference/expressions.rst:1861
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Условные выражения (иногда называемые «тройными операторами») имеют самый "
"низкий приоритет из всех операций Python."

#: ../../reference/expressions.rst:1864
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"Выражение ``x if C else y`` сначала оценивает условие *C*, а не *x*. Если "
"*C* истинно, вычисляется *x* и возвращается его значение; в противном случае "
"оценивается *y* и возвращается его значение."

#: ../../reference/expressions.rst:1868
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""
"См. :pep:`308` для получения более подробной информации об условных "
"выражениях."

#: ../../reference/expressions.rst:1875
msgid "Lambdas"
msgstr "Лямбды"

#: ../../reference/expressions.rst:1886
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Лямбда-выражения (иногда называемые лямбда-формами) используются для "
"создания анонимных функций. Выражение ``лямбда-параметры: выражение`` "
"возвращает объект функции. Безымянный объект ведет себя как объект функции, "
"определенный с помощью:"

#: ../../reference/expressions.rst:1890
msgid ""
"def <lambda>(parameters):\n"
"    return expression"
msgstr ""
"def <lambda>(parameters):\n"
"    return expression"

#: ../../reference/expressions.rst:1895
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"См. раздел :ref:`function` для ознакомления с синтаксисом списков "
"параметров. Обратите внимание, что функции, созданные с помощью лямбда-"
"выражений, не могут содержать операторы или аннотации."

#: ../../reference/expressions.rst:1903
msgid "Expression lists"
msgstr "Списки выражений"

#: ../../reference/expressions.rst:1919
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"За исключением случаев, когда отображается часть списка или набора, список "
"выражений, содержащий хотя бы одну запятую, дает кортеж. Длина кортежа равна "
"количеству выражений в списке. Выражения вычисляются слева направо."

#: ../../reference/expressions.rst:1928
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"Звездочка ``*`` обозначает :dfn:`итеративную распаковку`. Его операнд должен "
"быть :term:`iterable`. Итерация расширяется до последовательности элементов, "
"которые включаются в новый кортеж, список или набор на месте распаковки."

#: ../../reference/expressions.rst:1933
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"Итеративная распаковка в списках выражений, первоначально предложенная :pep:"
"`448`."

#: ../../reference/expressions.rst:1936
msgid "Any item in an expression list may be starred. See :pep:`646`."
msgstr ""
"Любой элемент в списке выражений может быть помечен звездочкой. См. :pep:"
"`646`."

#: ../../reference/expressions.rst:1941
msgid ""
"A trailing comma is required only to create a one-item tuple, such as ``1,"
"``; it is optional in all other cases. A single expression without a "
"trailing comma doesn't create a tuple, but rather yields the value of that "
"expression. (To create an empty tuple, use an empty pair of parentheses: "
"``()``.)"
msgstr ""
"Завершающая запятая требуется только для создания кортежа из одного "
"элемента, например ``1,``; во всех остальных случаях это необязательно. "
"Единственное выражение без завершающей запятой не создает кортеж, а скорее "
"возвращает значение этого выражения. (Чтобы создать пустой кортеж, "
"используйте пустую пару круглых скобок: ``()``.)"

#: ../../reference/expressions.rst:1952
msgid "Evaluation order"
msgstr "Порядок оценки"

#: ../../reference/expressions.rst:1956
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python оценивает выражения слева направо. Обратите внимание, что при оценке "
"присваивания правая часть оценивается раньше левой."

#: ../../reference/expressions.rst:1959
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"В следующих строках выражения будут вычисляться в арифметическом порядке их "
"суффиксов:"

#: ../../reference/expressions.rst:1962
msgid ""
"expr1, expr2, expr3, expr4\n"
"(expr1, expr2, expr3, expr4)\n"
"{expr1: expr2, expr3: expr4}\n"
"expr1 + expr2 * (expr3 - expr4)\n"
"expr1(expr2, expr3, *expr4, **expr5)\n"
"expr3, expr4 = expr1, expr2"
msgstr ""
"expr1, expr2, expr3, expr4\n"
"(expr1, expr2, expr3, expr4)\n"
"{expr1: expr2, expr3: expr4}\n"
"expr1 + expr2 * (expr3 - expr4)\n"
"expr1(expr2, expr3, *expr4, **expr5)\n"
"expr3, expr4 = expr1, expr2"

#: ../../reference/expressions.rst:1973
msgid "Operator precedence"
msgstr "Приоритет оператора"

#: ../../reference/expressions.rst:1978
msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation and conditional expressions, which "
"group from right to left)."
msgstr ""
"В следующей таблице приведены приоритеты операторов в Python: от наивысшего "
"приоритета (наибольшая привязка) до наименьшего приоритета (наименьшая "
"привязка). Операторы в одном поле имеют одинаковый приоритет. Если синтаксис "
"не указан явно, операторы являются двоичными. Операторы в одной группе "
"блоков слева направо (за исключением возведения в степень и условных "
"выражений, которые группируются справа налево)."

#: ../../reference/expressions.rst:1984
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Обратите внимание, что сравнения, тесты на членство и тесты на идентичность "
"имеют одинаковый приоритет и имеют функцию цепочки слева направо, как "
"описано в разделе :ref:`сравнения`."

#: ../../reference/expressions.rst:1990
msgid "Operator"
msgstr "Оператор"

#: ../../reference/expressions.rst:1990
msgid "Description"
msgstr "Описание"

#: ../../reference/expressions.rst:1992
msgid "``(expressions...)``,"
msgstr "``(expressions...)``,"

#: ../../reference/expressions.rst:1994
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[выражения...]``, ``{ключ: значение...}``, ``{выражения...}``"

#: ../../reference/expressions.rst:1992
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Привязка или выражение в скобках, отображение списка, отображение словаря, "
"отображение набора"

#: ../../reference/expressions.rst:1998
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:1998
msgid "Subscription, slicing, call, attribute reference"
msgstr "Подписка, нарезка, вызов, ссылка на атрибут"

#: ../../reference/expressions.rst:2001
msgid ":keyword:`await x <await>`"
msgstr ":keyword:`await x <await>`"

#: ../../reference/expressions.rst:2003
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:2003
msgid "Exponentiation [#]_"
msgstr "Возведение в степень [#]_"

#: ../../reference/expressions.rst:2005
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:2005
msgid "Positive, negative, bitwise NOT"
msgstr "Положительное, отрицательное, побитовое НЕ"

#: ../../reference/expressions.rst:2007
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:2007
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""
"Умножение, умножение матрицы, деление, деление нижнего уровня, остаток [#]_"

#: ../../reference/expressions.rst:2011
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:2011
msgid "Addition and subtraction"
msgstr "Сложение и вычитание"

#: ../../reference/expressions.rst:2013
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:2013
msgid "Shifts"
msgstr "Shifts"

#: ../../reference/expressions.rst:2015
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:2015
msgid "Bitwise AND"
msgstr "Побитовое И"

#: ../../reference/expressions.rst:2017
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:2017
msgid "Bitwise XOR"
msgstr "Логическое исключающее ИЛИ"

#: ../../reference/expressions.rst:2019
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:2019
msgid "Bitwise OR"
msgstr "Побитовое ИЛИ"

#: ../../reference/expressions.rst:2021
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../../reference/expressions.rst:2021
msgid "Comparisons, including membership tests and identity tests"
msgstr "Сравнения, включая тесты на членство и тесты на идентичность"

#: ../../reference/expressions.rst:2025
msgid ":keyword:`not x <not>`"
msgstr ":keyword:`not x <not>`"

#: ../../reference/expressions.rst:2025
msgid "Boolean NOT"
msgstr "Логическое НЕ"

#: ../../reference/expressions.rst:2027
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:2027
msgid "Boolean AND"
msgstr "Логическое И"

#: ../../reference/expressions.rst:2029
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:2029
msgid "Boolean OR"
msgstr "Логическое ИЛИ"

#: ../../reference/expressions.rst:2031
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: ../../reference/expressions.rst:2031
msgid "Conditional expression"
msgstr "Условное выражение"

#: ../../reference/expressions.rst:2033
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:2033
msgid "Lambda expression"
msgstr "Лямбда-выражение"

#: ../../reference/expressions.rst:2035
msgid "``:=``"
msgstr "``:=``"

#: ../../reference/expressions.rst:2035
msgid "Assignment expression"
msgstr "Выражение присваивания"

#: ../../reference/expressions.rst:2040
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/expressions.rst:2041
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Хотя ``abs(x%y) < abs(y)`` является верным математически, для чисел с "
"плавающей запятой это может быть неверно в числовом отношении из-за "
"округления. Например, если предположить, что платформа, на которой число с "
"плавающей запятой Python представляет собой число двойной точности IEEE 754, "
"для того, чтобы ``-1e-100 % 1e100`` имел тот же знак, что и ``1e100``, "
"вычисленный результат будет `` `-1e-100 + 1e100``, что численно точно равно "
"``1e100``. Функция :func:`math.fmod` вместо этого возвращает результат, знак "
"которого соответствует знаку первого аргумента, и поэтому в этом случае "
"возвращает ``-1e-100``. Какой подход является более подходящим, зависит от "
"приложения."

#: ../../reference/expressions.rst:2050
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Если x очень близок к точному целому числу, кратному y, возможно, что ``x//"
"y`` будет на единицу больше, чем ``(xx%y)//y`` из-за округления. В таких "
"случаях Python возвращает последний результат, чтобы сохранить то, что "
"``divmod(x,y)[0] * y + x % y`` будет очень близко к ``x``."

#: ../../reference/expressions.rst:2055
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Стандарт Unicode различает :dfn:`кодовые точки` (например, U+0041) и :dfn:"
"`абстрактные символы` (например, «ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА A»). Хотя "
"большинство абстрактных символов в Юникоде представлены только с помощью "
"одной кодовой точки, существует ряд абстрактных символов, которые, кроме "
"того, могут быть представлены с использованием последовательности, состоящей "
"из более чем одной кодовой точки. Например, абстрактный символ «ЛАТИНСКАЯ "
"ЗАГЛАВНАЯ БУКВА C С СЕДИЛЬЕЙ» может быть представлен как одиночный :dfn:"
"`предварительно составленный символ` в кодовой позиции U+00C7 или как "
"последовательность :dfn:`базового символа` в кодовой позиции. U+0043 "
"(ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА C), за которой следует :dfn:`объединяющий символ` "
"в позиции кода U+0327 (КОМБИНИРОВАНИЕ СЕДИЛЬЯ)."

#: ../../reference/expressions.rst:2066
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Операторы сравнения строк сравниваются на уровне кодовых точек Юникода. Это "
"может быть нелогично для людей. Например, ``\"\\u00C7\" == "
"\"\\u0043\\u0327\"`` имеет значение ``False``, хотя обе строки представляют "
"один и тот же абстрактный символ \"ЛАТИНСКАЯ ЗАГЛАВНАЯ БУКВА C С СЕДИЛЬЕЙ\"."

#: ../../reference/expressions.rst:2071
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Чтобы сравнить строки на уровне абстрактных символов (то есть интуитивно "
"понятным для человека способом), используйте :func:`unicodedata.normalize`."

#: ../../reference/expressions.rst:2074
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"Из-за автоматической сборки мусора, свободных списков и динамической природы "
"дескрипторов вы можете заметить необычное поведение при некоторых "
"использованиях оператора :keyword:`is`, например, при сравнении между "
"методами экземпляра или константами. Проверьте их документацию для получения "
"дополнительной информации."

#: ../../reference/expressions.rst:2079
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"Оператор степени ``**`` связывается менее жестко, чем арифметический или "
"побитовый унарный оператор справа, то есть ``2**-1`` равен ``0,5``."

#: ../../reference/expressions.rst:2082
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"Оператор ``%`` также используется для форматирования строк; применяется тот "
"же приоритет."

#: ../../reference/expressions.rst:8 ../../reference/expressions.rst:393
#: ../../reference/expressions.rst:448 ../../reference/expressions.rst:1763
#: ../../reference/expressions.rst:1851 ../../reference/expressions.rst:1877
#: ../../reference/expressions.rst:1905
msgid "expression"
msgstr "выражение"

#: ../../reference/expressions.rst:8
msgid "BNF"
msgstr "BNF"

#: ../../reference/expressions.rst:28 ../../reference/expressions.rst:1255
#: ../../reference/expressions.rst:1303
msgid "arithmetic"
msgstr "арифметическме"

#: ../../reference/expressions.rst:28
msgid "conversion"
msgstr "conversion"

#: ../../reference/expressions.rst:51
msgid "atom"
msgstr "атом"

#: ../../reference/expressions.rst:68 ../../reference/expressions.rst:82
msgid "name"
msgstr "имя"

#: ../../reference/expressions.rst:68
msgid "identifier"
msgstr "идентификатор"

#: ../../reference/expressions.rst:74 ../../reference/expressions.rst:569
#: ../../reference/expressions.rst:624 ../../reference/expressions.rst:746
#: ../../reference/expressions.rst:801 ../../reference/expressions.rst:848
#: ../../reference/expressions.rst:1292 ../../reference/expressions.rst:1341
#: ../../reference/expressions.rst:1437
msgid "exception"
msgstr "exception"

#: ../../reference/expressions.rst:74
msgid "NameError"
msgstr "NameError"

#: ../../reference/expressions.rst:82
msgid "mangling"
msgstr "mangling"

#: ../../reference/expressions.rst:82
msgid "private"
msgstr "private"

#: ../../reference/expressions.rst:82
msgid "names"
msgstr "имена"

#: ../../reference/expressions.rst:133
msgid "literal"
msgstr "literal"

#: ../../reference/expressions.rst:146 ../../reference/expressions.rst:372
msgid "immutable"
msgstr "неизменяемый"

#: ../../reference/expressions.rst:146
msgid "data"
msgstr "данные"

#: ../../reference/expressions.rst:146
msgid "type"
msgstr "тип"

#: ../../reference/expressions.rst:146 ../../reference/expressions.rst:275
#: ../../reference/expressions.rst:301 ../../reference/expressions.rst:329
#: ../../reference/expressions.rst:372 ../../reference/expressions.rst:393
#: ../../reference/expressions.rst:557 ../../reference/expressions.rst:736
#: ../../reference/expressions.rst:848 ../../reference/expressions.rst:877
#: ../../reference/expressions.rst:954 ../../reference/expressions.rst:998
#: ../../reference/expressions.rst:1146 ../../reference/expressions.rst:1160
#: ../../reference/expressions.rst:1174 ../../reference/expressions.rst:1181
#: ../../reference/expressions.rst:1728 ../../reference/expressions.rst:1917
msgid "object"
msgstr "объект"

#: ../../reference/expressions.rst:162
msgid "parenthesized form"
msgstr "форма в скобках"

#: ../../reference/expressions.rst:162 ../../reference/expressions.rst:393
#: ../../reference/expressions.rst:998
msgid "() (parentheses)"
msgstr "() (parentheses)"

#: ../../reference/expressions.rst:162
msgid "tuple display"
msgstr "отображение кортежа"

#: ../../reference/expressions.rst:175 ../../reference/expressions.rst:275
msgid "empty"
msgstr "empty"

#: ../../reference/expressions.rst:175 ../../reference/expressions.rst:877
#: ../../reference/expressions.rst:954 ../../reference/expressions.rst:1917
msgid "tuple"
msgstr "кортеж"

#: ../../reference/expressions.rst:181 ../../reference/expressions.rst:1939
msgid "comma"
msgstr "запятая"

#: ../../reference/expressions.rst:181 ../../reference/expressions.rst:275
#: ../../reference/expressions.rst:301 ../../reference/expressions.rst:329
#: ../../reference/expressions.rst:948 ../../reference/expressions.rst:998
#: ../../reference/expressions.rst:1905
msgid ", (comma)"
msgstr ", (запятая)"

#: ../../reference/expressions.rst:196 ../../reference/expressions.rst:275
#: ../../reference/expressions.rst:301 ../../reference/expressions.rst:329
msgid "comprehensions"
msgstr "comprehensions"

#: ../../reference/expressions.rst:206
msgid "for"
msgstr "for"

#: ../../reference/expressions.rst:206 ../../reference/expressions.rst:241
msgid "in comprehensions"
msgstr "in comprehensions"

#: ../../reference/expressions.rst:206 ../../reference/expressions.rst:1851
msgid "if"
msgstr "if"

#: ../../reference/expressions.rst:206
msgid "async for"
msgstr "async for"

#: ../../reference/expressions.rst:241 ../../reference/expressions.rst:1199
msgid "await"
msgstr "await"

#: ../../reference/expressions.rst:275 ../../reference/expressions.rst:848
#: ../../reference/expressions.rst:877 ../../reference/expressions.rst:954
#: ../../reference/expressions.rst:1905
msgid "list"
msgstr "список"

#: ../../reference/expressions.rst:275 ../../reference/expressions.rst:301
#: ../../reference/expressions.rst:329
msgid "display"
msgstr "отображать"

#: ../../reference/expressions.rst:275 ../../reference/expressions.rst:873
msgid "[] (square brackets)"
msgstr "[] (квадратные скобки)"

#: ../../reference/expressions.rst:275
msgid "list expression"
msgstr "list expression"

#: ../../reference/expressions.rst:275 ../../reference/expressions.rst:301
#: ../../reference/expressions.rst:1905
msgid "expression list"
msgstr "expression list"

#: ../../reference/expressions.rst:301
msgid "set"
msgstr "установить"

#: ../../reference/expressions.rst:301 ../../reference/expressions.rst:329
msgid "{} (curly brackets)"
msgstr "{} (фигурные скобки)"

#: ../../reference/expressions.rst:301
msgid "set expression"
msgstr "set expression"

#: ../../reference/expressions.rst:329 ../../reference/expressions.rst:355
#: ../../reference/expressions.rst:877
msgid "dictionary"
msgstr "словарь"

#: ../../reference/expressions.rst:329
msgid "key"
msgstr "key"

#: ../../reference/expressions.rst:329
msgid "value"
msgstr "значение"

#: ../../reference/expressions.rst:329
msgid "key/value pair"
msgstr "пара ключ/значение"

#: ../../reference/expressions.rst:329
msgid "dictionary expression"
msgstr "словарное выражение"

#: ../../reference/expressions.rst:329 ../../reference/expressions.rst:948
#: ../../reference/expressions.rst:1877
msgid ": (colon)"
msgstr ": (двоеточие)"

#: ../../reference/expressions.rst:329
msgid "in dictionary expressions"
msgstr "в словарных выражениях"

#: ../../reference/expressions.rst:329 ../../reference/expressions.rst:355
msgid "in dictionary displays"
msgstr "in dictionary displays"

#: ../../reference/expressions.rst:355 ../../reference/expressions.rst:1081
#: ../../reference/expressions.rst:1924
msgid "unpacking"
msgstr "распаковка"

#: ../../reference/expressions.rst:355 ../../reference/expressions.rst:1111
#: ../../reference/expressions.rst:1219
msgid "**"
msgstr "**"

#: ../../reference/expressions.rst:372
msgid "hashable"
msgstr "хэшируемый"

#: ../../reference/expressions.rst:393 ../../reference/expressions.rst:448
#: ../../reference/expressions.rst:557
msgid "generator"
msgstr "генератор"

#: ../../reference/expressions.rst:393
msgid "generator expression"
msgstr "генерирующее выражение"

#: ../../reference/expressions.rst:448 ../../reference/expressions.rst:1199
msgid "keyword"
msgstr "keyword"

#: ../../reference/expressions.rst:448 ../../reference/expressions.rst:637
msgid "yield"
msgstr "yield"

#: ../../reference/expressions.rst:448 ../../reference/expressions.rst:516
msgid "from"
msgstr "от"

#: ../../reference/expressions.rst:448 ../../reference/expressions.rst:1146
#: ../../reference/expressions.rst:1160 ../../reference/expressions.rst:1877
msgid "function"
msgstr "функция"

#: ../../reference/expressions.rst:502
msgid "coroutine"
msgstr "корутина"

#: ../../reference/expressions.rst:516
msgid "yield from expression"
msgstr "yield from expression"

#: ../../reference/expressions.rst:569
msgid "StopIteration"
msgstr "ОстановитьИтерацию"

#: ../../reference/expressions.rst:624 ../../reference/expressions.rst:801
msgid "GeneratorExit"
msgstr "GeneratorExit"

#: ../../reference/expressions.rst:637
msgid "examples"
msgstr "примеры"

#: ../../reference/expressions.rst:736
msgid "asynchronous-generator"
msgstr "асинхронный генератор"

#: ../../reference/expressions.rst:746
msgid "StopAsyncIteration"
msgstr "StopAsyncIteration"

#: ../../reference/expressions.rst:825
msgid "primary"
msgstr "primary"

#: ../../reference/expressions.rst:839
msgid "attribute"
msgstr "атрибут"

#: ../../reference/expressions.rst:839
msgid "reference"
msgstr "reference"

#: ../../reference/expressions.rst:839
msgid ". (dot)"
msgstr ". (точка)"

#: ../../reference/expressions.rst:839
msgid "attribute reference"
msgstr "attribute reference"

#: ../../reference/expressions.rst:848
msgid "AttributeError"
msgstr "AttributeError"

#: ../../reference/expressions.rst:848
msgid "module"
msgstr "модуль"

#: ../../reference/expressions.rst:873
msgid "subscription"
msgstr "подписка"

#: ../../reference/expressions.rst:877 ../../reference/expressions.rst:954
#: ../../reference/expressions.rst:1728
msgid "sequence"
msgstr "последовательность"

#: ../../reference/expressions.rst:877
msgid "mapping"
msgstr "сопоставление"

#: ../../reference/expressions.rst:877 ../../reference/expressions.rst:934
#: ../../reference/expressions.rst:954
msgid "string"
msgstr "строка"

#: ../../reference/expressions.rst:877 ../../reference/expressions.rst:934
msgid "item"
msgstr "item"

#: ../../reference/expressions.rst:934
msgid "character"
msgstr "character"

#: ../../reference/expressions.rst:948
msgid "slicing"
msgstr "нарезка"

#: ../../reference/expressions.rst:948
msgid "slice"
msgstr "срез"

#: ../../reference/expressions.rst:980
msgid "start (slice object attribute)"
msgstr "start (slice object attribute)"

#: ../../reference/expressions.rst:980
msgid "stop (slice object attribute)"
msgstr "stop (slice object attribute)"

#: ../../reference/expressions.rst:980
msgid "step (slice object attribute)"
msgstr "step (slice object attribute)"

#: ../../reference/expressions.rst:998
msgid "callable"
msgstr "вызываемый объект"

#: ../../reference/expressions.rst:998 ../../reference/expressions.rst:1146
#: ../../reference/expressions.rst:1160 ../../reference/expressions.rst:1174
#: ../../reference/expressions.rst:1181 ../../reference/expressions.rst:1191
msgid "call"
msgstr "call"

#: ../../reference/expressions.rst:998
msgid "argument"
msgstr "аргумент"

#: ../../reference/expressions.rst:998 ../../reference/expressions.rst:1031
msgid "call semantics"
msgstr "семантика вызова"

#: ../../reference/expressions.rst:998
msgid "argument list"
msgstr "список аргументов"

#: ../../reference/expressions.rst:998
msgid "= (equals)"
msgstr "= (равно)"

#: ../../reference/expressions.rst:998 ../../reference/expressions.rst:1081
#: ../../reference/expressions.rst:1111
msgid "in function calls"
msgstr "в вызовах функций"

#: ../../reference/expressions.rst:1031
msgid "parameter"
msgstr "параметр"

#: ../../reference/expressions.rst:1081 ../../reference/expressions.rst:1316
#: ../../reference/expressions.rst:1924
msgid "* (asterisk)"
msgstr "* (звёздочка)"

#: ../../reference/expressions.rst:1146
msgid "user-defined"
msgstr "user-defined"

#: ../../reference/expressions.rst:1146
msgid "user-defined function"
msgstr "определяемые пользователем функция"

#: ../../reference/expressions.rst:1160
msgid "built-in function"
msgstr "встроенная функция"

#: ../../reference/expressions.rst:1160
msgid "method"
msgstr "метод"

#: ../../reference/expressions.rst:1160
msgid "built-in method"
msgstr "встроенный метод"

#: ../../reference/expressions.rst:1174
msgid "class"
msgstr "класс"

#: ../../reference/expressions.rst:1174
msgid "class object"
msgstr "class object"

#: ../../reference/expressions.rst:1181
msgid "class instance"
msgstr "экземпляр класса"

#: ../../reference/expressions.rst:1181 ../../reference/expressions.rst:1191
msgid "instance"
msgstr "instance"

#: ../../reference/expressions.rst:1191
msgid "__call__() (object method)"
msgstr "__call__() (object method)"

#: ../../reference/expressions.rst:1219
msgid "power"
msgstr "power"

#: ../../reference/expressions.rst:1219 ../../reference/expressions.rst:1255
#: ../../reference/expressions.rst:1303 ../../reference/expressions.rst:1419
#: ../../reference/expressions.rst:1448 ../../reference/expressions.rst:1763
msgid "operation"
msgstr "операция"

#: ../../reference/expressions.rst:1219 ../../reference/expressions.rst:1264
#: ../../reference/expressions.rst:1273 ../../reference/expressions.rst:1281
#: ../../reference/expressions.rst:1316 ../../reference/expressions.rst:1329
#: ../../reference/expressions.rst:1341 ../../reference/expressions.rst:1359
#: ../../reference/expressions.rst:1389 ../../reference/expressions.rst:1402
#: ../../reference/expressions.rst:1419 ../../reference/expressions.rst:1457
#: ../../reference/expressions.rst:1465 ../../reference/expressions.rst:1474
#: ../../reference/expressions.rst:1489 ../../reference/expressions.rst:1728
#: ../../reference/expressions.rst:1737 ../../reference/expressions.rst:1779
#: ../../reference/expressions.rst:1784 ../../reference/expressions.rst:1789
#: ../../reference/expressions.rst:1851 ../../reference/expressions.rst:1975
msgid "operator"
msgstr "оператор"

#: ../../reference/expressions.rst:1255
msgid "unary"
msgstr "unary"

#: ../../reference/expressions.rst:1255 ../../reference/expressions.rst:1448
#: ../../reference/expressions.rst:1457 ../../reference/expressions.rst:1465
#: ../../reference/expressions.rst:1474
msgid "bitwise"
msgstr "побитовый"

#: ../../reference/expressions.rst:1264
msgid "negation"
msgstr "negation"

#: ../../reference/expressions.rst:1264
msgid "minus"
msgstr "minus"

#: ../../reference/expressions.rst:1264 ../../reference/expressions.rst:1402
msgid "- (minus)"
msgstr "- (минус)"

#: ../../reference/expressions.rst:1264 ../../reference/expressions.rst:1273
msgid "unary operator"
msgstr "унарный оператор"

#: ../../reference/expressions.rst:1273
msgid "plus"
msgstr "plus"

#: ../../reference/expressions.rst:1273 ../../reference/expressions.rst:1389
msgid "+ (plus)"
msgstr "+ (плюс)"

#: ../../reference/expressions.rst:1281
msgid "inversion"
msgstr "inversion"

#: ../../reference/expressions.rst:1281
msgid "~ (tilde)"
msgstr "~ (тильда)"

#: ../../reference/expressions.rst:1292
msgid "TypeError"
msgstr "TypeError"

#: ../../reference/expressions.rst:1303 ../../reference/expressions.rst:1448
msgid "binary"
msgstr "бинарные"

#: ../../reference/expressions.rst:1316
msgid "multiplication"
msgstr "multiplication"

#: ../../reference/expressions.rst:1329
msgid "matrix multiplication"
msgstr "matrix multiplication"

#: ../../reference/expressions.rst:1329
msgid "@ (at)"
msgstr "@ (at)"

#: ../../reference/expressions.rst:1341
msgid "ZeroDivisionError"
msgstr "ZeroDivisionError"

#: ../../reference/expressions.rst:1341
msgid "division"
msgstr "деление"

#: ../../reference/expressions.rst:1341
msgid "/ (slash)"
msgstr "/ (косая черта)"

#: ../../reference/expressions.rst:1341
msgid "//"
msgstr "//"

#: ../../reference/expressions.rst:1359
msgid "modulo"
msgstr "modulo"

#: ../../reference/expressions.rst:1359
msgid "% (percent)"
msgstr "% (процент)"

#: ../../reference/expressions.rst:1389
msgid "addition"
msgstr "addition"

#: ../../reference/expressions.rst:1389 ../../reference/expressions.rst:1402
msgid "binary operator"
msgstr "бинарный оператор"

#: ../../reference/expressions.rst:1402
msgid "subtraction"
msgstr "subtraction"

#: ../../reference/expressions.rst:1419
msgid "shifting"
msgstr "смещение "

#: ../../reference/expressions.rst:1419
msgid "<<"
msgstr "<<"

#: ../../reference/expressions.rst:1419
msgid ">>"
msgstr ">>"

#: ../../reference/expressions.rst:1437
msgid "ValueError"
msgstr "ValueError"

#: ../../reference/expressions.rst:1457 ../../reference/expressions.rst:1784
msgid "and"
msgstr "and"

#: ../../reference/expressions.rst:1457
msgid "& (ampersand)"
msgstr "& (амперсанд)"

#: ../../reference/expressions.rst:1465
msgid "xor"
msgstr "xor"

#: ../../reference/expressions.rst:1465
msgid "exclusive"
msgstr "exclusive"

#: ../../reference/expressions.rst:1465 ../../reference/expressions.rst:1474
#: ../../reference/expressions.rst:1789
msgid "or"
msgstr "or"

#: ../../reference/expressions.rst:1465
msgid "^ (caret)"
msgstr "^ (caret)"

#: ../../reference/expressions.rst:1474
msgid "inclusive"
msgstr "inclusive"

#: ../../reference/expressions.rst:1474
msgid "| (vertical bar)"
msgstr "| (вертикальная полоса)"

#: ../../reference/expressions.rst:1489
msgid "comparison"
msgstr "сравнение"

#: ../../reference/expressions.rst:1489
msgid "C"
msgstr "C"

#: ../../reference/expressions.rst:1489
msgid "language"
msgstr "язык"

#: ../../reference/expressions.rst:1489
msgid "< (less)"
msgstr "< (меньше)"

#: ../../reference/expressions.rst:1489
msgid "> (greater)"
msgstr "> (больше)"

#: ../../reference/expressions.rst:1489
msgid "<="
msgstr "<="

#: ../../reference/expressions.rst:1489
msgid ">="
msgstr ">="

#: ../../reference/expressions.rst:1489
msgid "=="
msgstr "=="

#: ../../reference/expressions.rst:1489
msgid "!="
msgstr "!="

#: ../../reference/expressions.rst:1513
msgid "chaining"
msgstr "цепочка"

#: ../../reference/expressions.rst:1513
msgid "comparisons"
msgstr "сравнения"

#: ../../reference/expressions.rst:1728
msgid "in"
msgstr "in"

#: ../../reference/expressions.rst:1728
msgid "not in"
msgstr "not in"

#: ../../reference/expressions.rst:1728
msgid "membership"
msgstr "membership"

#: ../../reference/expressions.rst:1728 ../../reference/expressions.rst:1737
msgid "test"
msgstr "test"

#: ../../reference/expressions.rst:1737
msgid "is"
msgstr "is"

#: ../../reference/expressions.rst:1737
msgid "is not"
msgstr "is not"

#: ../../reference/expressions.rst:1737
msgid "identity"
msgstr "identity"

#: ../../reference/expressions.rst:1763
msgid "Conditional"
msgstr "Conditional"

#: ../../reference/expressions.rst:1763
msgid "Boolean"
msgstr "Логический тип"

#: ../../reference/expressions.rst:1779
msgid "not"
msgstr "not"

#: ../../reference/expressions.rst:1803
msgid ":= (colon equals)"
msgstr ":= (colon equals)"

#: ../../reference/expressions.rst:1803
msgid "assignment expression"
msgstr "выражение присваивания"

#: ../../reference/expressions.rst:1803
msgid "walrus operator"
msgstr "walrus operator"

#: ../../reference/expressions.rst:1803
msgid "named expression"
msgstr "named expression"

#: ../../reference/expressions.rst:1851
msgid "conditional"
msgstr "conditional"

#: ../../reference/expressions.rst:1851
msgid "ternary"
msgstr "ternary"

#: ../../reference/expressions.rst:1851
msgid "conditional expression"
msgstr "conditional expression"

#: ../../reference/expressions.rst:1851
msgid "else"
msgstr "else"

#: ../../reference/expressions.rst:1877
msgid "lambda"
msgstr "лямбда"

#: ../../reference/expressions.rst:1877
msgid "form"
msgstr "form"

#: ../../reference/expressions.rst:1877
msgid "anonymous"
msgstr "anonymous"

#: ../../reference/expressions.rst:1877
msgid "lambda expression"
msgstr "lambda expression"

#: ../../reference/expressions.rst:1924
msgid "iterable"
msgstr "итерируемый объект"

#: ../../reference/expressions.rst:1924
msgid "in expression lists"
msgstr "in expression lists"

#: ../../reference/expressions.rst:1939
msgid "trailing"
msgstr "trailing"

#: ../../reference/expressions.rst:1954
msgid "evaluation"
msgstr "evaluation"

#: ../../reference/expressions.rst:1954
msgid "order"
msgstr "order"

#: ../../reference/expressions.rst:1975
msgid "precedence"
msgstr "precedence"
