# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "Модель данных"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "Объекты, значения и типы данных"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer\", code is also represented by objects.)"
msgstr ""
":dfn:`Объекты` — это абстракция данных в Python. Все данные в программе "
"Python представлены объектами или отношениями между объектами. (В некотором "
"смысле, в соответствии с моделью фон Неймана «компьютера с хранимой "
"программой», код также представлен объектами.)"

#: ../../reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The :keyword:`is` operator compares the identity of two "
"objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"Каждый объект имеет идентификатор, тип и значение. *Идентичность* объекта "
"никогда не меняется после его создания; вы можете думать об этом как об "
"адресе объекта в памяти. Оператор :keyword:`is` сравнивает идентичность двух "
"объектов; функция :func:`id` возвращает целое число, представляющее его "
"идентификатор."

#: ../../reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr ""
"В CPython, ``id(x)`` это адрес объекта ``x`` в памяти, где он хранится."

#: ../../reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"Тип объекта определяет операции, которые объект поддерживает (например, "
"\"Имеет ли он длину?\") и также определяет возможные значения для объекта "
"этого типа. Функция :func:`type` возвращает тип объекта (который сам также "
"является объектом). Также как и его идентификатор, :dfn:`type` объекта "
"является неизменяемым. [#]_"

#: ../../reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"Значение *value* некоторых объектов может изменяться. Объекты, чьи значения "
"могут изменяться, называются изменяемыми *mutable*; объекты, чьи значения не "
"меняются с момента, как объекты были созданы, называются неизменяемые "
"*immutable*. (Значение неизменяемого контейнера объектов, который содержит "
"ссылки на изменяемые объекты может изменяться, когда значения последних "
"изменились; однако контейнер все еще считается неизменяемым, потому что "
"коллекция объектов, которую он содержит, не может быть изменена. Таким "
"образом, неизменяемость это не строго тоже самое, что и неизменяемое "
"значение, это более тонкое понятие.) Изменяемость объекта определяется его "
"типом; к примеру, числа, строки и кортежи - неизменяемые, в то время как "
"словари и списки - изменяемые."

#: ../../reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Объекты никогда явно не удаляются; однако, когда они перестают "
"использоваться, они могут быть собраны как мусор. Реализация позволяет "
"отсрочить сбор мусора или совсем его пропустить - это вопрос качества "
"реализации, как осуществляется сбор мусора, до тех пор, пока не останется "
"объектов, которые все еще используются."

#: ../../reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"CPython в настоящее время использует референсно-счетную схему (по желанию), "
"задерживающую выявление циклически связанного мусора, которая собирает "
"большинство объектов сразу, как они становятся неиспользуемыми, но это не "
"гарантирует сбор мусора, содержащего циклические ссылки. Смотри документацию "
"к  модулю :mod:`gc` для информации о контроле над сбором мусора с "
"циклическими ссылками. Другие реализации действуют иначе и CPython может "
"измениться. Не нужно дожидаться немедленного завершения объекта, когда он "
"становится недоступен (поэтому следует всегда в явном виде закрывать файлы)."

#: ../../reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a :keyword:`try`...\\ :keyword:`except` statement "
"may keep objects alive."
msgstr ""
"Обратите внимание, что использование средств трассировки или отладки "
"реализации может поддерживать работоспособность объектов, которые обычно "
"можно собирать. Также обратите внимание, что перехват исключения с помощью "
"оператора :keyword:`try`...\\ :keyword:`Exception` может сохранить объекты "
"живыми."

#: ../../reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`!close` method. Programs are strongly recommended "
"to explicitly close such objects.  The :keyword:`try`...\\ :keyword:"
"`finally` statement and the :keyword:`with` statement provide convenient "
"ways to do this."
msgstr ""
"Некоторые объекты содержат ссылки на «внешние» ресурсы, такие как открытые "
"файлы или окна. Понятно, что эти ресурсы освобождаются при сборке мусора, но "
"поскольку сбор мусора не гарантирован, такие объекты также предоставляют "
"явный способ освобождения внешнего ресурса, обычно метод :meth:`!close`. "
"Программам настоятельно рекомендуется явно закрывать такие объекты. "
"Оператор :keyword:`try`...\\ :keyword:`finally` и оператор :keyword:`with` "
"предоставляют удобные способы сделать это."

#: ../../reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Некоторые объекты содержат ссылки на другие объекты; они называются "
"контейнеры *containers*. Примеры контейнеров это кортежи, списки и словари. "
"Ссылки являются частью значения контейнера. В большинстве случаев, когда мы "
"говорим о значении контейнера, мы подразумеваем значения - не идентификаторы "
"содержащихся объектов; однако, когда мы говорим о изменяемости контейнера, "
"подразумеваются только идентификаторы содержащихся в данный момент объектов. "
"Так, если неизменяемый контейнер (как кортеж) содержит ссылки на изменяемый "
"объект, его значение изменяется, если этот изменяемый объект изменился."

#: ../../reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed. For example, after ``a = 1; b = 1``, *a* and *b* may or may not "
"refer to the same object with the value one, depending on the "
"implementation. This is because :class:`int` is an immutable type, so the "
"reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be "
"aware of when making use of object identity tests. However, after ``c = []; "
"d = []``, *c* and *d* are guaranteed to refer to two different, unique, "
"newly created empty lists. (Note that ``e = f = []`` assigns the *same* "
"object to both *e* and *f*.)"
msgstr ""
"Типы влияют практически на все аспекты поведения объектов. В некотором "
"смысле это влияет даже на важность идентичности объекта: для неизменяемых "
"типов операции, вычисляющие новые значения, могут фактически возвращать "
"ссылку на любой существующий объект с тем же типом и значением, тогда как "
"для изменяемых объектов это не допускается. Например, после ``a = 1; b = "
"1``, ​​*a* и *b* могут ссылаться или не ссылаться на один и тот же объект со "
"значением один, в зависимости от реализации. Это связано с тем, что :class:"
"`int` является неизменяемым типом, поэтому ссылку на ``1`` можно "
"использовать повторно. Такое поведение зависит от используемой реализации, "
"поэтому на него не следует полагаться, но об этом следует помнить при "
"использовании тестов идентификации объектов. Однако после ``c = []; d = "
"[]``, *c* и *d* гарантированно относятся к двум разным, уникальным, вновь "
"созданным пустым спискам. (Обратите внимание, что ``e = f = []`` присваивает "
"*один и тот же* объект как *e*, так и *f*.)"

#: ../../reference/datamodel.rst:124
msgid "The standard type hierarchy"
msgstr "Стандартная иерархия типов"

#: ../../reference/datamodel.rst:133
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Ниже приведен список типов, встроенных в Python. Модули расширения "
"(написанные на C, Java или других языках, в зависимости от реализации) могут "
"определять дополнительные типы. Будущие версии Python могут добавлять типы в "
"иерархию типов (например, рациональные числа, эффективно хранимые массивы "
"целых чисел и т. д.), хотя вместо этого такие дополнения часто будут "
"предоставляться через стандартную библиотеку."

#: ../../reference/datamodel.rst:144
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Некоторые из приведенных ниже описаний типов содержат абзац со списком "
"«специальных атрибутов». Это атрибуты, которые обеспечивают доступ к "
"реализации и не предназначены для общего использования. Их определение может "
"измениться в будущем."

#: ../../reference/datamodel.rst:150 ../../reference/datamodel.rst:152
msgid "None"
msgstr "None"

#: ../../reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Этот тип имеет одно значение. Существует один объект с этим значением. "
"Доступ к этому объекту осуществляется через встроенное имя None. Он "
"используется для обозначения отсутствия значения во многих ситуациях, "
"например, оно возвращается из функций, которые ничего явно не возвращают. "
"Его истинностное значение ложно."

#: ../../reference/datamodel.rst:161 ../../reference/datamodel.rst:163
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../../reference/datamodel.rst:165
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"Этот тип имеет одно значение. Существует один объект с этим значением. "
"Доступ к этому объекту осуществляется через встроенное имя :data:"
"`NotImplemented`. Числовые методы и методы расширенного сравнения должны "
"возвращать это значение, если они не реализуют операцию для предоставленных "
"операндов. (Затем интерпретатор попытается выполнить отраженную операцию или "
"какой-либо другой запасной вариант, в зависимости от оператора.) Ее не "
"следует оценивать в логическом контексте."

#: ../../reference/datamodel.rst:172
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "Подробнее см. :ref:`реализация-арифметических-операций`."

#: ../../reference/datamodel.rst:176
msgid ""
"Evaluating :data:`NotImplemented` in a boolean context is deprecated. While "
"it currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It "
"will raise a :exc:`TypeError` in a future version of Python."
msgstr ""
"Вычисление :data:`NotImplemented` в логическом контексте устарело. Хотя в "
"настоящее время оно оценивается как истинное, оно выдает :exc:"
"`DeprecationWarning`. В будущей версии Python это вызовет ошибку :exc:"
"`TypeError`."

#: ../../reference/datamodel.rst:183 ../../reference/datamodel.rst:184
msgid "Ellipsis"
msgstr "Эллипсис"

#: ../../reference/datamodel.rst:188
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Этот тип имеет одно значение. Существует один объект с этим значением. "
"Доступ к этому объекту осуществляется через литерал ``...`` или встроенное "
"имя ``Многоточие``. Его истинностное значение истинно."

#: ../../reference/datamodel.rst:194
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:198
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Они создаются числовыми литералами и возвращаются в качестве результатов "
"арифметическими операторами и встроенными арифметическими функциями. "
"Числовые объекты неизменяемы; однажды созданная их ценность никогда не "
"меняется. Числа Python, конечно, тесно связаны с математическими числами, но "
"с учетом ограничений числового представления в компьютерах."

#: ../../reference/datamodel.rst:204
msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
"Строковые представления числовых классов, вычисляемые с помощью :meth:"
"`~object.__repr__` и :meth:`~object.__str__`, имеют следующие свойства:"

#: ../../reference/datamodel.rst:208
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"Это допустимые числовые литералы, которые при передаче конструктору класса "
"создают объект, имеющий исходное числовое значение."

#: ../../reference/datamodel.rst:212
msgid "The representation is in base 10, when possible."
msgstr "Представление, если это возможно, осуществляется по основанию 10."

#: ../../reference/datamodel.rst:214
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""
"Ведущие нули, за исключением, возможно, одного нуля перед десятичной "
"запятой, не отображаются."

#: ../../reference/datamodel.rst:217
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""
"Конечные нули, за исключением, возможно, одного нуля после десятичной точки, "
"не отображаются."

#: ../../reference/datamodel.rst:220
msgid "A sign is shown only when the number is negative."
msgstr "Знак отображается только в том случае, если число отрицательное."

#: ../../reference/datamodel.rst:222
msgid ""
"Python distinguishes between integers, floating-point numbers, and complex "
"numbers:"
msgstr ""
"Python различает целые числа, числа с плавающей запятой и комплексные числа:"

#: ../../reference/datamodel.rst:227
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../../reference/datamodel.rst:231
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Они представляют собой элементы из математического набора целых чисел "
"(положительных и отрицательных)."

#: ../../reference/datamodel.rst:237
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"Правила целочисленного представления призваны дать наиболее осмысленную "
"интерпретацию операций сдвига и маски, включающих отрицательные целые числа."

#: ../../reference/datamodel.rst:240
msgid "There are two types of integers:"
msgstr "Существует два типа целых чисел:"

#: ../../reference/datamodel.rst:242
msgid "Integers (:class:`int`)"
msgstr "Целые числа (:class:`int`)"

#: ../../reference/datamodel.rst:243
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Они представляют числа в неограниченном диапазоне, зависящие только от "
"доступной (виртуальной) памяти. Для операций сдвига и маски предполагается "
"двоичное представление, а отрицательные числа представляются в варианте "
"дополнения до 2, что создает иллюзию бесконечной строки знаковых битов, "
"простирающейся влево."

#: ../../reference/datamodel.rst:249
msgid "Booleans (:class:`bool`)"
msgstr "Булевы (:class:`bool`)"

#: ../../reference/datamodel.rst:255
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"Они представляют значения истинности False и True. Два объекта, "
"представляющие значения «False» и «True», являются единственными логическими "
"объектами. Тип Boolean является подтипом целочисленного типа, и логические "
"значения ведут себя как значения 0 и 1 соответственно почти во всех "
"контекстах, за исключением того, что при преобразовании в строку строки "
"``\"False\"`` или `` `\"True\"`` возвращаются соответственно."

#: ../../reference/datamodel.rst:263
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:271
msgid ""
"These represent machine-level double precision floating-point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating-point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating-point numbers."
msgstr ""
"Они представляют собой числа двойной точности с плавающей запятой машинного "
"уровня. Вы находитесь во власти базовой машинной архитектуры (и реализации C "
"или Java) в отношении принятого диапазона и обработки переполнения. Python "
"не поддерживает числа одинарной точности с плавающей запятой; экономия в "
"использовании процессора и памяти, которая обычно является причиной их "
"использования, затмевается накладными расходами на использование объектов в "
"Python, поэтому нет смысла усложнять язык двумя видами чисел с плавающей "
"запятой."

#: ../../reference/datamodel.rst:281
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:287
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating-point numbers.  The same caveats apply as for floating-point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Они представляют собой комплексные числа в виде пары чисел с плавающей "
"запятой двойной точности машинного уровня. Применяются те же "
"предостережения, что и для чисел с плавающей запятой. Действительные и "
"мнимые части комплексного числа z можно получить с помощью атрибутов «z."
"real» и «z.imag», доступных только для чтения."

#: ../../reference/datamodel.rst:294
msgid "Sequences"
msgstr "Последовательности"

#: ../../reference/datamodel.rst:303
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some "
"sequences, including built-in sequences, interpret negative subscripts by "
"adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, the "
"second to last item of sequence a with length ``n``."
msgstr ""
"Они представляют собой конечные упорядоченные множества, индексированные "
"неотрицательными числами. Встроенная функция :func:`len` возвращает "
"количество элементов последовательности. Когда длина последовательности "
"равна *n*, набор индексов содержит числа 0, 1, ..., *n*-1. Элемент *i* "
"последовательности *a* выбирается с помощью ``a[i]``. Некоторые "
"последовательности, включая встроенные, интерпретируют отрицательные индексы "
"путем добавления длины последовательности. Например, ``a[-2]`` равен "
"``a[n-2]``, предпоследнему элементу последовательности a длины ``n``."

#: ../../reference/datamodel.rst:313
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type. The comment above about negative indexes also "
"applies to negative slice positions."
msgstr ""
"Последовательности также поддерживают нарезку: ``a[i:j]`` выбирает все "
"элементы с индексом *k*, такие что *i* ``<=`` *k* ``<`` *j*. При "
"использовании в качестве выражения срез представляет собой "
"последовательность одного и того же типа. Комментарий выше об отрицательных "
"индексах также применим к отрицательным позициям среза."

#: ../../reference/datamodel.rst:318
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Некоторые последовательности также поддерживают «расширенное нарезку» с "
"третьим параметром «шага»: ``a[i:j:k]`` выбирает все элементы *a* с индексом "
"*x*, где ``x = i + n*k ``, *n* ``>=`` ``0`` и *i* ``<=`` *x* ``<`` *j*."

#: ../../reference/datamodel.rst:322
msgid "Sequences are distinguished according to their mutability:"
msgstr "Последовательности различают по их мутабельности:"

#: ../../reference/datamodel.rst:326
msgid "Immutable sequences"
msgstr "Неизменяемые последовательности"

#: ../../reference/datamodel.rst:332
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Объект неизменяемого типа последовательности не может измениться после его "
"создания. (Если объект содержит ссылки на другие объекты, эти другие объекты "
"могут быть изменяемыми и могут быть изменены; однако коллекция объектов, на "
"которые непосредственно ссылается неизменяемый объект, не может измениться.)"

#: ../../reference/datamodel.rst:337
msgid "The following types are immutable sequences:"
msgstr "Следующие типы являются неизменяемыми последовательностями:"

#: ../../reference/datamodel.rst:342
msgid "Strings"
msgstr "Строки"

#: ../../reference/datamodel.rst:350
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"Строка — это последовательность значений, представляющих кодовые точки "
"Юникода. Все кодовые точки в диапазоне ``U+0000 - U+10FFFF`` могут быть "
"представлены в виде строки. В Python нет типа :c:expr:`char`; вместо этого "
"каждая кодовая точка в строке представлена ​​как строковый объект длиной "
"``1``. Встроенная функция :func:`ord` преобразует кодовую точку из ее "
"строковой формы в целое число в диапазоне ``0 - 10FFFF``; :func:`chr` "
"преобразует целое число в диапазоне ``0 - 10FFFF`` в строковый объект "
"соответствующей длины ``1``. :meth:`str.encode` можно использовать для "
"преобразования :class:`str` в :class:`bytes` с использованием заданной "
"текстовой кодировки, а :meth:`bytes.decode` можно использовать для "
"достижения противоположного."

#: ../../reference/datamodel.rst:362
msgid "Tuples"
msgstr "Кортежи"

#: ../../reference/datamodel.rst:368
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Элементами кортежа являются произвольные объекты Python. Кортежи из двух или "
"более элементов формируются списками выражений, разделенных запятыми. Кортеж "
"из одного элемента («одиночный элемент») может быть сформирован путем "
"добавления запятой к выражению (выражение само по себе не создает кортеж, "
"поскольку для группировки выражений необходимо использовать круглые скобки). "
"Пустой кортеж может быть образован пустой парой круглых скобок."

#: ../../reference/datamodel.rst:375
msgid "Bytes"
msgstr "Байты"

#: ../../reference/datamodel.rst:378
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to create "
"bytes objects.  Also, bytes objects can be decoded to strings via the :meth:"
"`~bytes.decode` method."
msgstr ""
"Объект bytes представляет собой неизменяемый массив. Элементы представляют "
"собой 8-битные байты, представленные целыми числами в диапазоне 0 <= x < "
"256. Байтовые литералы (например, ``b'abc'``) и встроенный конструктор :func:"
"`bytes` могут использоваться для создавать байтовые объекты. Кроме того, "
"байтовые объекты можно декодировать в строки с помощью метода :meth:`~bytes."
"decode`."

#: ../../reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr "Изменяемые последовательности"

#: ../../reference/datamodel.rst:395
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"Изменяемые последовательности можно изменить после их создания. Нотации "
"подписки и нарезки могут использоваться в качестве цели операторов "
"присваивания и :keyword:`del` (удаления)."

#: ../../reference/datamodel.rst:403
msgid ""
"The :mod:`collections` and :mod:`array` module provide additional examples "
"of mutable sequence types."
msgstr ""
"Модуль :mod:`collections` и :mod:`array` предоставляет дополнительные "
"примеры изменяемых типов последовательностей."

#: ../../reference/datamodel.rst:406
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""
"В настоящее время существует два внутренних типа изменяемых "
"последовательностей:"

#: ../../reference/datamodel.rst:408
msgid "Lists"
msgstr "Списки"

#: ../../reference/datamodel.rst:411
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Элементы списка — это произвольные объекты Python. Списки формируются путем "
"помещения списка выражений, разделенных запятыми, в квадратные скобки. "
"(Обратите внимание, что для формирования списков длиной 0 или 1 не требуется "
"никаких особых случаев.)"

#: ../../reference/datamodel.rst:415
msgid "Byte Arrays"
msgstr "Массивы байтов"

#: ../../reference/datamodel.rst:418
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Объект bytearray представляет собой изменяемый массив. Они создаются "
"встроенным конструктором :func:`bytearray`. Помимо того, что байтовые "
"массивы изменяемы (и, следовательно, не хешируются), в остальном они "
"предоставляют тот же интерфейс и функциональность, что и неизменяемые "
"объекты :class:`bytes`."

#: ../../reference/datamodel.rst:425
msgid "Set types"
msgstr "Типы наборов"

#: ../../reference/datamodel.rst:431
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Они представляют собой неупорядоченные конечные наборы уникальных "
"неизменяемых объектов. По существу, они не могут быть проиндексированы каким-"
"либо индексом. Однако их можно перебирать, а встроенная функция :func:`len` "
"возвращает количество элементов в наборе. Обычно наборы используются для "
"быстрой проверки членства, удаления дубликатов из последовательности и "
"выполнения математических операций, таких как пересечение, объединение, "
"разность и симметричная разность."

#: ../../reference/datamodel.rst:438
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"Для элементов набора применяются те же правила неизменности, что и для "
"ключей словаря. Обратите внимание, что числовые типы подчиняются обычным "
"правилам числового сравнения: если два числа сравниваются равными (например, "
"``1`` и ``1.0``), только одно из них может содержаться в наборе."

#: ../../reference/datamodel.rst:443
msgid "There are currently two intrinsic set types:"
msgstr "В настоящее время существует два внутренних типа множеств:"

#: ../../reference/datamodel.rst:446
msgid "Sets"
msgstr "Множества"

#: ../../reference/datamodel.rst:449
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""
"Они представляют собой изменяемый набор. Они создаются встроенным "
"конструктором :func:`set` и впоследствии могут быть изменены несколькими "
"методами, например :meth:`~set.add`."

#: ../../reference/datamodel.rst:454
msgid "Frozen sets"
msgstr "Замороженные наборы"

#: ../../reference/datamodel.rst:457
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Они представляют собой неизменяемый набор. Они создаются встроенным "
"конструктором :func:`frozenset`. Поскольку замороженный набор является "
"неизменяемым и :term:`хешируемым`, его можно снова использовать как элемент "
"другого набора или как ключ словаря."

#: ../../reference/datamodel.rst:464
msgid "Mappings"
msgstr "Сопоставления"

#: ../../reference/datamodel.rst:471
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Они представляют собой конечные наборы объектов, индексированных "
"произвольными наборами индексов. Обозначение индекса ``a[k]`` выбирает "
"элемент, индексированный ``k``, из отображения ``a``; это можно использовать "
"в выражениях и в качестве цели присваивания или операторов :keyword:`del`. "
"Встроенная функция :func:`len` возвращает количество элементов в "
"сопоставлении."

#: ../../reference/datamodel.rst:477
msgid "There is currently a single intrinsic mapping type:"
msgstr ""
"В настоящее время существует единственный внутренний тип сопоставления:"

#: ../../reference/datamodel.rst:481
msgid "Dictionaries"
msgstr "Словари"

#: ../../reference/datamodel.rst:485
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Они представляют собой конечные наборы объектов, индексированных почти "
"произвольными значениями. Единственными типами значений, неприемлемыми в "
"качестве ключей, являются значения, содержащие списки, словари или другие "
"изменяемые типы, которые сравниваются по значению, а не по идентификатору "
"объекта, причина в том, что эффективная реализация словарей требует, чтобы "
"хеш-значение ключа оставалось постоянным. Числовые типы, используемые для "
"ключей, подчиняются обычным правилам числового сравнения: если два числа "
"сравниваются равными (например, ``1`` и ``1.0``), то их можно использовать "
"как взаимозаменяемые для индексации одной и той же словарной статьи."

#: ../../reference/datamodel.rst:494
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Словари сохраняют порядок вставки, а это означает, что ключи будут "
"создаваться в том же порядке, в котором они были последовательно добавлены в "
"словарь. Замена существующего ключа не меняет порядок, однако удаление ключа "
"и его повторная вставка добавит его в конец, а не сохранит старое место."

#: ../../reference/datamodel.rst:499
msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Словари изменяемы; они могут быть созданы с помощью нотации ``{}`` (см. "
"раздел :ref:`dict`)."

#: ../../reference/datamodel.rst:506
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Модули расширения :mod:`dbm.ndbm` и :mod:`dbm.gnu` предоставляют "
"дополнительные примеры типов сопоставления, как и модуль :mod:`collections`."

#: ../../reference/datamodel.rst:510
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Словари не сохраняли порядок вставки в версиях Python до 3.6. В CPython 3.6 "
"порядок вставки был сохранен, но в то время это считалось деталью "
"реализации, а не гарантией языка."

#: ../../reference/datamodel.rst:517
msgid "Callable types"
msgstr "Вызываемые типы"

#: ../../reference/datamodel.rst:525
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""
"Это типы, к которым может применяться операция вызова функции (см. раздел :"
"ref:`calls`):"

#: ../../reference/datamodel.rst:532
msgid "User-defined functions"
msgstr "Пользовательские функции"

#: ../../reference/datamodel.rst:539
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Пользовательский объект функции создается путем определения функции (см. "
"раздел :ref:`function`). Его следует вызывать со списком аргументов, "
"содержащим то же количество элементов, что и список формальных параметров "
"функции."

#: ../../reference/datamodel.rst:545 ../../reference/datamodel.rst:1367
#: ../../reference/datamodel.rst:1562
msgid "Special read-only attributes"
msgstr "Специальные атрибуты, доступные только для чтения"

#: ../../reference/datamodel.rst:555 ../../reference/datamodel.rst:589
#: ../../reference/datamodel.rst:1156
msgid "Attribute"
msgstr "Атрибут"

#: ../../reference/datamodel.rst:556 ../../reference/datamodel.rst:590
#: ../../reference/datamodel.rst:1157
msgid "Meaning"
msgstr "Значение"

#: ../../reference/datamodel.rst:559
msgid ""
"A reference to the :class:`dictionary <dict>` that holds the function's :ref:"
"`global variables <naming>` -- the global namespace of the module in which "
"the function was defined."
msgstr ""
"Ссылка на :class:`словарь <dict>`, который содержит :ref:`глобальные "
"переменные <naming>` функции — глобальное пространство имен модуля, в "
"котором функция была определена."

#: ../../reference/datamodel.rst:564
msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the "
"function's free variables."
msgstr ""
"``None`` или :class:`tuple` ячеек, содержащих привязки для свободных "
"переменных функции."

#: ../../reference/datamodel.rst:567
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Объект ячейки имеет атрибут «cell_contents». Это можно использовать для "
"получения значения ячейки, а также для установки значения."

#: ../../reference/datamodel.rst:571 ../../reference/datamodel.rst:1599
msgid "Special writable attributes"
msgstr "Специальные записываемые атрибуты"

#: ../../reference/datamodel.rst:584
msgid "Most of these attributes check the type of the assigned value:"
msgstr "Большинство этих атрибутов проверяют тип присвоенного значения:"

#: ../../reference/datamodel.rst:593
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr "Строка документации функции или «Нет», если она недоступна."

#: ../../reference/datamodel.rst:596
msgid ""
"The function's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""
"Имя функции. См. также: :attr:`__name__ атрибуты <definition.__name__>`."

#: ../../reference/datamodel.rst:600
msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."

#: ../../reference/datamodel.rst:606
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"Имя модуля, в котором была определена функция, или «Нет», если оно "
"недоступно."

#: ../../reference/datamodel.rst:610
msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a default "
"value."
msgstr ""
":class:`tuple`, содержащий значения :term:`parameter` по умолчанию для тех "
"параметров, которые имеют значения по умолчанию, или ``None``, если ни один "
"параметр не имеет значения по умолчанию."

#: ../../reference/datamodel.rst:615
msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr ""
"Объект кода <code-objects>`, представляющий тело скомпилированной функции."

#: ../../reference/datamodel.rst:619
msgid ""
"The namespace supporting arbitrary function attributes. See also: :attr:"
"`__dict__ attributes <object.__dict__>`."
msgstr ""
"Пространство имен, поддерживающее произвольные атрибуты функции. См. также: :"
"attr:`__dict__ атрибуты <object.__dict__>`."

#: ../../reference/datamodel.rst:623
msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See also: :ref:"
"`annotations-howto`."
msgstr ""
":class:`словарь <dict>`, содержащий аннотации :term:`parameters "
"<parameter>`. Ключами словаря являются имена параметров и return для "
"аннотации возврата, если она предусмотрена. См. также: :ref:`annotations-"
"howto`."

#: ../../reference/datamodel.rst:630
msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-only :term:"
"`parameters <parameter>`."
msgstr ""
":class:`dictionary <dict>`, содержащий значения по умолчанию для :term:"
"`parameters <parameter>` только для ключевых слов."

#: ../../reference/datamodel.rst:634
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic function <generic-functions>`."
msgstr ""
":class:`tuple`, содержащий :ref:`параметры типа <type-params>` :ref:"
"`универсальной функции <generic-functions>`."

#: ../../reference/datamodel.rst:639
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes."
msgstr ""
"Объекты-функции также поддерживают получение и установку произвольных "
"атрибутов, которые можно использовать, например, для прикрепления метаданных "
"к функциям. Для получения и установки таких атрибутов используется обычная "
"точечная нотация атрибутов."

#: ../../reference/datamodel.rst:645
msgid ""
"CPython's current implementation only supports function attributes on user-"
"defined functions. Function attributes on :ref:`built-in functions <builtin-"
"functions>` may be supported in the future."
msgstr ""
"Текущая реализация CPython поддерживает только атрибуты функций для "
"пользовательских функций. Атрибуты функций во встроенных функциях <builtin-"
"functions> могут поддерживаться в будущем."

#: ../../reference/datamodel.rst:650
msgid ""
"Additional information about a function's definition can be retrieved from "
"its :ref:`code object <code-objects>` (accessible via the :attr:`~function."
"__code__` attribute)."
msgstr ""
"Дополнительную информацию об определении функции можно получить из ее :ref:"
"`объекта кода <code-objects>` (доступного через атрибут :attr:`~function."
"__code__`)."

#: ../../reference/datamodel.rst:658
msgid "Instance methods"
msgstr "Методы экземпляра"

#: ../../reference/datamodel.rst:665
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Объект метода экземпляра объединяет класс, экземпляр класса и любой "
"вызываемый объект (обычно определяемую пользователем функцию)."

#: ../../reference/datamodel.rst:675 ../../reference/datamodel.rst:1690
msgid "Special read-only attributes:"
msgstr "Специальные атрибуты, доступные только для чтения:"

#: ../../reference/datamodel.rst:680
msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr "Относится к объекту экземпляра класса, к которому привязан метод."

#: ../../reference/datamodel.rst:684
msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr ""
"Относится к исходному :ref:`функциональному объекту <user-defined-funcs>`"

#: ../../reference/datamodel.rst:687
msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ <function."
"__doc__>`). A :class:`string <str>` if the original function had a "
"docstring, else ``None``."
msgstr ""
"Документация метода (аналогично :attr:`method.__func__.__doc__ <function."
"__doc__>`). A :class:`string <str>`, если исходная функция имела строку "
"документации, иначе ``None``."

#: ../../reference/datamodel.rst:693
msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ <function."
"__name__>`)"
msgstr ""
"Имя метода (то же самое, что :attr:`method.__func__.__name__ <function."
"__name__>`)"

#: ../../reference/datamodel.rst:697
msgid ""
"The name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""
"Имя модуля, в котором был определен метод, или «Нет», если он недоступен."

#: ../../reference/datamodel.rst:700
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr ""
"Методы также поддерживают доступ (но не установку) к произвольным атрибутам "
"функции базового :ref:`функционального объекта <user-defined-funcs>`."

#: ../../reference/datamodel.rst:703
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined :ref:`function object <user-defined-funcs>` or a :class:"
"`classmethod` object."
msgstr ""
"Объекты пользовательских методов могут быть созданы при получении атрибута "
"класса (возможно, через экземпляр этого класса), если этот атрибут является "
"определяемым пользователем :ref:`функциональным объектом <user-defined-"
"funcs>` или : class:`classmethod` объект."

#: ../../reference/datamodel.rst:710
msgid ""
"When an instance method object is created by retrieving a user-defined :ref:"
"`function object <user-defined-funcs>` from a class via one of its "
"instances, its :attr:`~method.__self__` attribute is the instance, and the "
"method object is said to be *bound*.  The new method's :attr:`~method."
"__func__` attribute is the original function object."
msgstr ""
"Когда объект метода экземпляра создается путем извлечения определяемого "
"пользователем объекта функции <user-defined-funcs>` из класса через один из "
"его экземпляров, его атрибут :attr:`~method.__self__` является "
"экземпляром. , а объект метода называется *связанным*. Атрибут :attr:"
"`~method.__func__` нового метода является исходным объектом функции."

#: ../../reference/datamodel.rst:716
msgid ""
"When an instance method object is created by retrieving a :class:"
"`classmethod` object from a class or instance, its :attr:`~method.__self__` "
"attribute is the class itself, and its :attr:`~method.__func__` attribute is "
"the function object underlying the class method."
msgstr ""
"Когда объект метода экземпляра создается путем извлечения объекта :class:"
"`classmethod` из класса или экземпляра, его атрибут :attr:`~method.__self__` "
"является самим классом, а его :attr:`~method.__func__` Атрибут — это объект "
"функции, лежащий в основе метода класса."

#: ../../reference/datamodel.rst:721
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`~method.__func__`) is called, inserting the class instance (:attr:`~method."
"__self__`) in front of the argument list.  For instance, when :class:`!C` is "
"a class which contains a definition for a function :meth:`!f`, and ``x`` is "
"an instance of :class:`!C`, calling ``x.f(1)`` is equivalent to calling ``C."
"f(x, 1)``."
msgstr ""
"Когда вызывается объект метода экземпляра, вызывается базовая функция (:attr:"
"`~method.__func__`), вставляя экземпляр класса (:attr:`~method.__self__`) "
"перед списком аргументов. Например, когда :class:`!C` является классом, "
"который содержит определение функции :meth:`!f`, а ``x`` является "
"экземпляром :class:`!C`, вызов `` xf(1)`` эквивалентен вызову ``Cf(x, 1)``."

#: ../../reference/datamodel.rst:728
msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or ``C."
"f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying "
"function."
msgstr ""
"Когда объект метода экземпляра является производным от объекта :class:"
"`classmethod`, \"экземпляр класса\", хранящийся в :attr:`~method.__self__`, "
"фактически будет самим классом, так что вызов либо ``xf(1) `` или ``Cf(1)`` "
"эквивалентны вызову ``f(C,1)``, где ``f`` — это базовая функция."

#: ../../reference/datamodel.rst:733
msgid ""
"It is important to note that user-defined functions which are attributes of "
"a class instance are not converted to bound methods; this *only* happens "
"when the function is an attribute of the class."
msgstr ""
"Важно отметить, что определяемые пользователем функции, являющиеся "
"атрибутами экземпляра класса, не преобразуются в связанные методы; это "
"*только* происходит, когда функция является атрибутом класса."

#: ../../reference/datamodel.rst:740
msgid "Generator functions"
msgstr "Функции генератора"

#: ../../reference/datamodel.rst:746
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's :meth:`iterator."
"__next__` method will cause the function to execute until it provides a "
"value using the :keyword:`!yield` statement.  When the function executes a :"
"keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of "
"values to be returned."
msgstr ""
"Функция или метод, использующий оператор :keyword:`yield` (см. раздел :ref:"
"`yield`), называется :dfn:`функцией-генератором`. Такая функция при вызове "
"всегда возвращает объект :term:`iterator`, который можно использовать для "
"выполнения тела функции: вызов метода :meth:`iterator.__next__` итератора "
"приведет к выполнению функции до тех пор, пока она не предоставит значение с "
"помощью оператора :keyword:`!yield`. Когда функция выполняет оператор :"
"keyword:`return` или выходит из конца, возникает исключение :exc:"
"`StopIteration`, и итератор достигает конца набора возвращаемых значений."

#: ../../reference/datamodel.rst:758
msgid "Coroutine functions"
msgstr "Функции сопрограммы"

#: ../../reference/datamodel.rst:763
msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
"Функция или метод, определенный с помощью :keyword:`async def`, называется :"
"dfn:`сопрограммной функцией`. Такая функция при вызове возвращает объект :"
"term:`coroutine`. Он может содержать выражения :keyword:`await`, а также "
"операторы :keyword:`async with` и :keyword:`async for`. См. также раздел :"
"ref:`coroutine-objects`."

#: ../../reference/datamodel.rst:771
msgid "Asynchronous generator functions"
msgstr "Функции асинхронного генератора"

#: ../../reference/datamodel.rst:777
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"Функция или метод, определенный с помощью :keyword:`async def` и "
"использующий оператор :keyword:`yield`, называется :dfn:`асинхронной "
"функцией-генератором`. Такая функция при вызове возвращает объект :term:"
"`асинхронный итератор`, который можно использовать в операторе :keyword:"
"`async for` для выполнения тела функции."

#: ../../reference/datamodel.rst:783
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ <object."
"__anext__>` method will return an :term:`awaitable` which when awaited will "
"execute until it provides a value using the :keyword:`yield` expression.  "
"When the function executes an empty :keyword:`return` statement or falls off "
"the end, a :exc:`StopAsyncIteration` exception is raised and the "
"asynchronous iterator will have reached the end of the set of values to be "
"yielded."
msgstr ""
"Вызов метода :meth:`aiterator.__anext__ <object.__anext__>` асинхронного "
"итератора вернет :term:`awaitable`, который при ожидании будет выполняться "
"до тех пор, пока не предоставит значение, используя выражение :keyword:"
"`yield`. Когда функция выполняет пустой оператор :keyword:`return` или "
"выходит за пределы конца, возникает исключение :exc:`StopAsyncIteration`, и "
"асинхронный итератор достигает конца набора возвращаемых значений."

#: ../../reference/datamodel.rst:796
msgid "Built-in functions"
msgstr "Встроенные функции"

#: ../../reference/datamodel.rst:803
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""
"Встроенный объект функции — это оболочка функции C. Примерами встроенных "
"функций являются :func:`len` и :func:`math.sin` (:mod:`math` — стандартный "
"встроенный модуль). Количество и тип аргументов определяются функцией C. "
"Специальные атрибуты, доступные только для чтения:"

#: ../../reference/datamodel.rst:808
msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr ""
":attr:`!__doc__` — это строка документации функции или ``None``, если она "
"недоступна. См. :attr:`function.__doc__`."

#: ../../reference/datamodel.rst:810
msgid ""
":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ":attr:`!__name__` — имя функции. См. :attr:`function.__name__`."

#: ../../reference/datamodel.rst:811
msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ""
"Для :attr:`!__self__` установлено значение ``None`` (но см. следующий пункт)."

#: ../../reference/datamodel.rst:812
msgid ""
":attr:`!__module__` is the name of the module the function was defined in or "
"``None`` if unavailable. See :attr:`function.__module__`."
msgstr ""
":attr:`!__module__` — это имя модуля, в котором была определена функция, или "
"``None``, если он недоступен. См. :attr:`function.__module__`."

#: ../../reference/datamodel.rst:820
msgid "Built-in methods"
msgstr "Встроенные методы"

#: ../../reference/datamodel.rst:827
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`!__self__` is set to the object denoted by *alist*. (The attribute has "
"the same semantics as it does with :attr:`other instance methods <method."
"__self__>`.)"
msgstr ""
"На самом деле это другая маскировка встроенной функции, на этот раз "
"содержащая объект, передаваемый функции C в качестве неявного "
"дополнительного аргумента. Примером встроенного метода является ``alist."
"append()``, предполагая, что *alist* является объектом списка. В этом случае "
"специальный атрибут только для чтения :attr:`!__self__` устанавливается для "
"объекта, обозначенного *alist*. (Атрибут имеет ту же семантику, что и :attr:"
"`другие методы экземпляра <method.__self__>`.)"

#: ../../reference/datamodel.rst:836
msgid "Classes"
msgstr "Классы"

#: ../../reference/datamodel.rst:838
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to :"
"meth:`!__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""
"Классы можно вызывать. Эти объекты обычно действуют как фабрики для создания "
"новых экземпляров самих себя, но возможны варианты для типов классов, "
"которые переопределяют :meth:`~object.__new__`. Аргументы вызова передаются "
"в :meth:`!__new__` и, в типичном случае, в :meth:`~object.__init__` для "
"инициализации нового экземпляра."

#: ../../reference/datamodel.rst:846
msgid "Class Instances"
msgstr "Экземпляры классов"

#: ../../reference/datamodel.rst:848
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`~object.__call__` method in their class."
msgstr ""
"Экземпляры произвольных классов можно сделать вызываемыми, определив в их "
"классе метод :meth:`~object.__call__`."

#: ../../reference/datamodel.rst:855
msgid "Modules"
msgstr "Модули"

#: ../../reference/datamodel.rst:861
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a :class:`dictionary <dict>` object (this is the "
"dictionary referenced by the :attr:`~function.__globals__` attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m."
"__dict__[\"x\"]``. A module object does not contain the code object used to "
"initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr ""
"Модули являются базовой организационной единицей кода Python и создаются "
"системой :ref:`import system <importsystem>`, вызываемой либо оператором :"
"keyword:`import`, либо вызовом таких функций, как :func:`importlib. "
"import_module` и встроенный :func:`__import__`. Объект модуля имеет "
"пространство имен, реализованное объектом :class:`dictionary <dict>` (это "
"словарь, на который ссылается атрибут :attr:`~function.__globals__` функций, "
"определенных в модуле). Ссылки на атрибуты преобразуются в поиск в этом "
"словаре, например, ``mx`` эквивалентно ``m.__dict__[\"x\"]``. Объект модуля "
"не содержит объект кода, используемый для инициализации модуля (поскольку он "
"не нужен после завершения инициализации)."

#: ../../reference/datamodel.rst:874
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"Присвоение атрибута обновляет словарь пространства имен модуля, например, "
"``mx = 1`` эквивалентно ``m.__dict__[\"x\"] = 1``."

#: ../../reference/datamodel.rst:892
msgid "Import-related attributes on module objects"
msgstr "Атрибуты, связанные с импортом, в объектах модуля"

#: ../../reference/datamodel.rst:894
msgid ""
"Module objects have the following attributes that relate to the :ref:`import "
"system <importsystem>`. When a module is created using the machinery "
"associated with the import system, these attributes are filled in based on "
"the module's :term:`spec <module spec>`, before the :term:`loader` executes "
"and loads the module."
msgstr ""
"Объекты модуля имеют следующие атрибуты, относящиеся к :ref:`системе импорта "
"<importsystem>`. Когда модуль создается с использованием механизма, "
"связанного с системой импорта, эти атрибуты заполняются на основе :term:"
"`spec <module spec>` перед тем, как :term:`loader` выполнит и загрузит "
"модуль."

#: ../../reference/datamodel.rst:900
msgid ""
"To create a module dynamically rather than using the import system, it's "
"recommended to use :func:`importlib.util.module_from_spec`, which will set "
"the various import-controlled attributes to appropriate values. It's also "
"possible to use the :class:`types.ModuleType` constructor to create modules "
"directly, but this technique is more error-prone, as most attributes must be "
"manually set on the module object after it has been created when using this "
"approach."
msgstr ""
"Чтобы создать модуль динамически, а не использовать систему импорта, "
"рекомендуется использовать :func:`importlib.util.module_from_spec`, который "
"установит соответствующие значения для различных атрибутов, управляемых "
"импортом. Также возможно использовать конструктор :class:`types.ModuleType` "
"для непосредственного создания модулей, но этот метод более подвержен "
"ошибкам, поскольку при использовании этого подхода большинство атрибутов "
"необходимо устанавливать вручную для объекта модуля после его создания."

#: ../../reference/datamodel.rst:910
msgid ""
"With the exception of :attr:`~module.__name__`, it is **strongly** "
"recommended that you rely on :attr:`~module.__spec__` and its attributes "
"instead of any of the other individual attributes listed in this subsection. "
"Note that updating an attribute on :attr:`!__spec__` will not update the "
"corresponding attribute on the module itself:"
msgstr ""
"За исключением :attr:`~module.__name__`, **настоятельно** рекомендуется "
"полагаться на :attr:`~module.__spec__` и его атрибуты вместо любых других "
"отдельных атрибутов, перечисленных в этом подразделе. . Обратите внимание, "
"что обновление атрибута в :attr:`!__spec__` не приведет к обновлению "
"соответствующего атрибута в самом модуле:"

#: ../../reference/datamodel.rst:916
msgid ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"
msgstr ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"

#: ../../reference/datamodel.rst:930
msgid ""
"The name used to uniquely identify the module in the import system. For a "
"directly executed module, this will be set to ``\"__main__\"``."
msgstr ""
"Имя, используемое для уникальной идентификации модуля в системе импорта. Для "
"непосредственно выполняемого модуля будет установлено значение "
"``\"__main__\"``."

#: ../../reference/datamodel.rst:933
msgid ""
"This attribute must be set to the fully qualified name of the module. It is "
"expected to match the value of :attr:`module.__spec__.name <importlib."
"machinery.ModuleSpec.name>`."
msgstr ""
"В этом атрибуте должно быть установлено полное имя модуля. Ожидается, что "
"оно будет соответствовать значению :attr:`module.__spec__.name <importlib."
"machinery.ModuleSpec.name>`."

#: ../../reference/datamodel.rst:939
msgid "A record of the module's import-system-related state."
msgstr "Запись состояния модуля, связанного с системой импорта."

#: ../../reference/datamodel.rst:941
msgid ""
"Set to the :class:`module spec <importlib.machinery.ModuleSpec>` that was "
"used when importing the module. See :ref:`module-specs` for more details."
msgstr ""
"Установите :class:`спецификацию модуля <importlib.machinery.ModuleSpec>`, "
"которая использовалась при импорте модуля. Дополнительную информацию см. в :"
"ref:`module-specs`."

#: ../../reference/datamodel.rst:948
msgid "The :term:`package` a module belongs to."
msgstr ":term:`package`, которому принадлежит модуль."

#: ../../reference/datamodel.rst:950
msgid ""
"If the module is top-level (that is, not a part of any specific package) "
"then the attribute should be set to ``''`` (the empty string). Otherwise, it "
"should be set to the name of the module's package (which can be equal to :"
"attr:`module.__name__` if the module itself is a package). See :pep:`366` "
"for further details."
msgstr ""
"Если модуль является модулем верхнего уровня (то есть не является частью "
"какого-либо конкретного пакета), тогда для атрибута должно быть установлено "
"значение ``''`` (пустая строка). В противном случае ему должно быть "
"присвоено имя пакета модуля (которое может быть равно :attr:`module."
"__name__`, если сам модуль является пакетом). Дополнительную информацию "
"смотрите в :pep:`366`."

#: ../../reference/datamodel.rst:956
msgid ""
"This attribute is used instead of :attr:`~module.__name__` to calculate "
"explicit relative imports for main modules. It defaults to ``None`` for "
"modules created dynamically using the :class:`types.ModuleType` constructor; "
"use :func:`importlib.util.module_from_spec` instead to ensure the attribute "
"is set to a :class:`str`."
msgstr ""
"Этот атрибут используется вместо :attr:`~module.__name__` для расчета явного "
"относительного импорта для основных модулей. По умолчанию для модулей, "
"созданных динамически с использованием конструктора :class:`types."
"ModuleType`, установлено значение ``None``; вместо этого используйте :func:"
"`importlib.util.module_from_spec`, чтобы убедиться, что для атрибута "
"установлено значение :class:`str`."

#: ../../reference/datamodel.rst:962
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` instead of :attr:`!module."
"__package__`. :attr:`__package__` is now only used as a fallback if :attr:`!"
"__spec__.parent` is not set, and this fallback path is deprecated."
msgstr ""
"**настоятельно** рекомендуется использовать :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` вместо :attr:`!module."
"__package__`. :attr:`__package__` теперь используется как резервный вариант "
"только в том случае, если :attr:`!__spec__.parent` не установлен, и этот "
"резервный путь устарел."

#: ../../reference/datamodel.rst:968 ../../reference/datamodel.rst:1005
msgid ""
"This attribute now defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor. Previously the attribute "
"was optional."
msgstr ""
"По умолчанию этот атрибут теперь имеет значение None для модулей, созданных "
"динамически с использованием конструктора :class:`types.ModuleType`. Раньше "
"атрибут был необязательным."

#: ../../reference/datamodel.rst:973
msgid ""
"The value of :attr:`!__package__` is expected to be the same as :attr:"
"`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. :attr:"
"`__package__` is now only used as a fallback during import resolution if :"
"attr:`!__spec__.parent` is not defined."
msgstr ""
"Ожидается, что значение :attr:`!__package__` будет таким же, как и :attr:"
"`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. :attr:"
"`__package__` теперь используется как запасной вариант при разрешении "
"импорта, только если :attr:`!__spec__.parent` не определен."

#: ../../reference/datamodel.rst:979
msgid ""
":exc:`ImportWarning` is raised if an import resolution falls back to :attr:`!"
"__package__` instead of :attr:`__spec__.parent <importlib.machinery."
"ModuleSpec.parent>`."
msgstr ""
":exc:`ImportWarning` возникает, если разрешение импорта возвращается к :attr:"
"`!__package__` вместо :attr:`__spec__.parent <importlib.machinery.ModuleSpec."
"parent>`."

#: ../../reference/datamodel.rst:984
msgid ""
"Raise :exc:`DeprecationWarning` instead of :exc:`ImportWarning` when falling "
"back to :attr:`!__package__` during import resolution."
msgstr ""
"Поднимите :exc:`DeprecationWarning` вместо :exc:`ImportWarning` при возврате "
"к :attr:`!__package__` во время разрешения импорта."

#: ../../reference/datamodel.rst:990
msgid ""
"The :term:`loader` object that the import machinery used to load the module."
msgstr ""
"Объект :term:`loader`, который механизм импорта использовал для загрузки "
"модуля."

#: ../../reference/datamodel.rst:992
msgid ""
"This attribute is mostly useful for introspection, but can be used for "
"additional loader-specific functionality, for example getting data "
"associated with a loader."
msgstr ""
"Этот атрибут в основном полезен для самоанализа, но может использоваться для "
"дополнительных функций, специфичных для загрузчика, например для получения "
"данных, связанных с загрузчиком."

#: ../../reference/datamodel.rst:996
msgid ""
":attr:`!__loader__` defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor; use :func:`importlib.util."
"module_from_spec` instead to ensure the attribute is set to a :term:`loader` "
"object."
msgstr ""
":attr:`!__loader__` по умолчанию имеет значение ``None`` для модулей, "
"созданных динамически с использованием конструктора :class:`types."
"ModuleType`; вместо этого используйте :func:`importlib.util."
"module_from_spec`, чтобы гарантировать, что атрибут установлен на объект :"
"term:`loader`."

#: ../../reference/datamodel.rst:1001
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` instead of :attr:`!module."
"__loader__`."
msgstr ""
"**настоятельно** рекомендуется использовать :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` вместо :attr:`!module.__loader__`."

#: ../../reference/datamodel.rst:1010
msgid ""
"Setting :attr:`!__loader__` on a module while failing to set :attr:`!"
"__spec__.loader` is deprecated. In Python 3.16, :attr:`!__loader__` will "
"cease to be set or taken into consideration by the import system or the "
"standard library."
msgstr ""
"Установка :attr:`!__loader__` в модуле без установки :attr:`!__spec__."
"loader` считается устаревшей. В Python 3.16 :attr:`!__loader__` перестанет "
"устанавливаться или учитываться системой импорта или стандартной библиотекой."

#: ../../reference/datamodel.rst:1018
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"where the package's submodules will be found. Non-package modules should not "
"have a :attr:`!__path__` attribute. See :ref:`package-path-rules` for more "
"details."
msgstr ""
"(Возможно, пустая) :term:`последовательность` строк, перечисляющих места, "
"где будут найдены подмодули пакета. Модули, не являющиеся пакетами, не "
"должны иметь атрибута :attr:`!__path__`. Дополнительную информацию см. в "
"разделе :ref:`package-path-rules`."

#: ../../reference/datamodel.rst:1023
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__."
"submodule_search_locations <importlib.machinery.ModuleSpec."
"submodule_search_locations>` instead of :attr:`!module.__path__`."
msgstr ""
"**настоятельно** рекомендуется использовать :attr:`module.__spec__."
"submodule_search_locations <importlib.machinery.ModuleSpec."
"submodule_search_locations>` вместо :attr:`!module.__path__`."

#: ../../reference/datamodel.rst:1030
msgid ""
":attr:`!__file__` and :attr:`!__cached__` are both optional attributes that "
"may or may not be set. Both attributes should be a :class:`str` when they "
"are available."
msgstr ""
":attr:`!__file__` и :attr:`!__cached__` являются необязательными атрибутами, "
"которые могут быть установлены или не установлены. Оба атрибута должны быть :"
"class:`str`, если они доступны."

#: ../../reference/datamodel.rst:1034
msgid ""
":attr:`!__file__` indicates the pathname of the file from which the module "
"was loaded (if loaded from a file), or the pathname of the shared library "
"file for extension modules loaded dynamically from a shared library. It "
"might be missing for certain types of modules, such as C modules that are "
"statically linked into the interpreter, and the :ref:`import system "
"<importsystem>` may opt to leave it unset if it has no semantic meaning (for "
"example, a module loaded from a database)."
msgstr ""
":attr:`!__file__` указывает путь к файлу, из которого был загружен модуль "
"(если загружен из файла), или путь к файлу общей библиотеки для модулей "
"расширения, загружаемых динамически из общей библиотеки. Он может "
"отсутствовать для определенных типов модулей, таких как модули C, которые "
"статически связаны с интерпретатором, и :ref:`система импорта "
"<importsystem>` может оставить его неустановленным, если он не имеет "
"семантического значения (например, модуль, загруженный из базы данных)."

#: ../../reference/datamodel.rst:1042
msgid ""
"If :attr:`!__file__` is set then the :attr:`!__cached__` attribute might "
"also be set,  which is the path to any compiled version of the code (for "
"example, a byte-compiled file). The file does not need to exist to set this "
"attribute; the path can simply point to where the compiled file *would* "
"exist (see :pep:`3147`)."
msgstr ""
"Если установлен :attr:`!__file__`, то также может быть установлен атрибут :"
"attr:`!__cached__`, который является путем к любой скомпилированной версии "
"кода (например, скомпилированному побайтно файлу). Для установки этого "
"атрибута файл не обязательно должен существовать; путь может просто "
"указывать на то место, где *будет* существовать скомпилированный файл (см. :"
"pep:`3147`)."

#: ../../reference/datamodel.rst:1048
msgid ""
"Note that :attr:`!__cached__` may be set even if :attr:`!__file__` is not "
"set.  However, that scenario is quite atypical.  Ultimately, the :term:"
"`loader` is what makes use of the module spec provided by the :term:`finder` "
"(from which :attr:`!__file__` and :attr:`!__cached__` are derived).  So if a "
"loader can load from a cached module but otherwise does not load from a "
"file, that atypical scenario may be appropriate."
msgstr ""
"Обратите внимание, что :attr:`!__cached__` может быть установлен, даже если :"
"attr:`!__file__` не установлен. Однако этот сценарий весьма нетипичен. В "
"конечном счете, :term:`loader` — это то, что использует спецификацию модуля, "
"предоставленную :term:`finder` (из которого получены :attr:`!__file__` и :"
"attr:`!__cached__`). Поэтому, если загрузчик может загружаться из "
"кэшированного модуля, но не загружается из файла, этот нетипичный сценарий "
"может быть подходящим."

#: ../../reference/datamodel.rst:1055
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` instead of :attr:`!module."
"__cached__`."
msgstr ""
"**настоятельно** рекомендуется использовать :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` вместо :attr:`!module.__cached__`."

#: ../../reference/datamodel.rst:1060
msgid "Other writable attributes on module objects"
msgstr "Другие записываемые атрибуты объектов модуля."

#: ../../reference/datamodel.rst:1062
msgid ""
"As well as the import-related attributes listed above, module objects also "
"have the following writable attributes:"
msgstr ""
"Помимо перечисленных выше атрибутов, связанных с импортом, объекты модулей "
"также имеют следующие записываемые атрибуты:"

#: ../../reference/datamodel.rst:1067
msgid ""
"The module's documentation string, or ``None`` if unavailable. See also: :"
"attr:`__doc__ attributes <definition.__doc__>`."
msgstr ""
"Строка документации модуля или «Нет», если она недоступна. См. также: :attr:"
"`__doc__ атрибуты <definition.__doc__>`."

#: ../../reference/datamodel.rst:1072
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"Словарь, содержащий :term:`аннотации переменных <аннотации переменных>`, "
"собранные во время выполнения тела модуля. Рекомендации по работе с :attr:"
"`__annotations__` см. в :ref:`annotations-howto`."

#: ../../reference/datamodel.rst:1078
msgid "Module dictionaries"
msgstr "Словари модулей"

#: ../../reference/datamodel.rst:1080
msgid "Module objects also have the following special read-only attribute:"
msgstr ""
"Объекты модуля также имеют следующий специальный атрибут только для чтения:"

#: ../../reference/datamodel.rst:1085
msgid ""
"The module's namespace as a dictionary object. Uniquely among the attributes "
"listed here, :attr:`!__dict__` cannot be accessed as a global variable from "
"within a module; it can only be accessed as an attribute on module objects."
msgstr ""
"Пространство имен модуля как объект словаря. Единственным среди "
"перечисленных здесь атрибутов является то, что :attr:`!__dict__` не может "
"быть доступен как глобальная переменная изнутри модуля; доступ к нему "
"возможен только как атрибут объектов модуля."

#: ../../reference/datamodel.rst:1091
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"Из-за того, как CPython очищает словари модулей, словарь модуля будет "
"очищен, когда модуль выйдет из области видимости, даже если в словаре все "
"еще есть живые ссылки. Чтобы избежать этого, скопируйте словарь или "
"сохраните модуль, используя его словарь напрямую."

#: ../../reference/datamodel.rst:1100
msgid "Custom classes"
msgstr "Пользовательские классы"

#: ../../reference/datamodel.rst:1102
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found at :ref:`python_2.3_mro`."
msgstr ""
"Пользовательские типы классов обычно создаются определениями классов (см. "
"раздел :ref:`class`). Класс имеет пространство имен, реализованное объектом "
"словаря. Ссылки на атрибуты класса преобразуются в поиск в этом словаре, "
"например, ``Cx`` преобразуется в ``C.__dict__[\"x\"]`` (хотя существует ряд "
"перехватчиков, которые позволяют использовать другие способы поиска "
"атрибутов). . Если имя атрибута там не найдено, поиск атрибута продолжается "
"в базовых классах. В этом поиске базовых классов используется порядок "
"разрешения методов C3, который работает корректно даже при наличии "
"«ромбовидных» структур наследования, где существует несколько путей "
"наследования, ведущих к общему предку. Дополнительные сведения о C3 MRO, "
"используемом Python, можно найти по адресу :ref:`python_2.3_mro`."

#: ../../reference/datamodel.rst:1123
msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`~method.__self__` attribute is :class:`!C`. When it would yield a :"
"class:`staticmethod` object, it is transformed into the object wrapped by "
"the static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""
"Когда ссылка на атрибут класса (скажем, для класса :class:`!C`) дает объект "
"метода класса, она преобразуется в объект метода экземпляра, атрибут :attr:"
"`~method.__self__` равен :class:`! С`. Когда он дает объект :class:"
"`staticmethod`, он преобразуется в объект, обернутый объектом статического "
"метода. См. раздел :ref:`дескрипторы`, чтобы узнать, как атрибуты, "
"полученные из класса, могут отличаться от тех, которые фактически содержатся "
"в его :attr:`~object.__dict__`."

#: ../../reference/datamodel.rst:1134
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"Присвоение атрибутов класса обновляет словарь класса, а не словарь базового "
"класса."

#: ../../reference/datamodel.rst:1139
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Объект класса можно вызвать (см. выше) для получения экземпляра класса (см. "
"ниже)."

#: ../../reference/datamodel.rst:1142 ../../reference/datamodel.rst:1273
msgid "Special attributes"
msgstr "Специальные атрибуты"

#: ../../reference/datamodel.rst:1160
msgid ""
"The class's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""
"Имя класса. См. также: :attr:`__name__ атрибуты <definition.__name__>`."

#: ../../reference/datamodel.rst:1164
msgid ""
"The class's :term:`qualified name`. See also: :attr:`__qualname__ attributes "
"<definition.__qualname__>`."
msgstr ""
":term:`полное имя` класса. См. также: :attr:`__qualname__ атрибуты "
"<definition.__qualname__>`."

#: ../../reference/datamodel.rst:1168
msgid "The name of the module in which the class was defined."
msgstr "Имя модуля, в котором был определен класс."

#: ../../reference/datamodel.rst:1171
msgid ""
"A :class:`mapping proxy <types.MappingProxyType>` providing a read-only view "
"of the class's namespace. See also: :attr:`__dict__ attributes <object."
"__dict__>`."
msgstr ""
":class:`прокси-сервер <types.MappingProxyType>`, обеспечивающий доступное "
"только для чтения представление пространства имен класса. См. также: :attr:"
"`__dict__ атрибуты <object.__dict__>`."

#: ../../reference/datamodel.rst:1176
msgid ""
"A :class:`tuple` containing the class's bases. In most cases, for a class "
"defined as ``class X(A, B, C)``, ``X.__bases__`` will be exactly equal to "
"``(A, B, C)``."
msgstr ""
":class:`tuple`, содержащий основы класса. В большинстве случаев для класса, "
"определенного как ``class X(A, B, C)``, ``X.__bases__`` будет точно равен "
"``(A, B, C)``."

#: ../../reference/datamodel.rst:1181
msgid ""
"The class's documentation string, or ``None`` if undefined. Not inherited by "
"subclasses."
msgstr ""
"Строка документации класса или None, если не определено. Не наследуется "
"подклассами."

#: ../../reference/datamodel.rst:1185
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution. For best practices on working with :"
"attr:`!__annotations__`, please see :ref:`annotations-howto`."
msgstr ""
"Словарь, содержащий :term:`аннотации переменных <аннотации переменных>`, "
"собранные во время выполнения тела класса. Рекомендации по работе с :attr:`!"
"__annotations__` см. в :ref:`annotations-howto`."

#: ../../reference/datamodel.rst:1192
msgid ""
"Accessing the :attr:`!__annotations__` attribute of a class object directly "
"may yield incorrect results in the presence of metaclasses. In addition, the "
"attribute may not exist for some classes. Use :func:`inspect."
"get_annotations` to retrieve class annotations safely."
msgstr ""
"Прямой доступ к атрибуту :attr:`!__annotations__` объекта класса может "
"привести к неверным результатам при наличии метаклассов. Кроме того, для "
"некоторых классов атрибут может отсутствовать. Используйте :func:`inspect."
"get_annotations` для безопасного получения аннотаций классов."

#: ../../reference/datamodel.rst:1199
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic class <generic-classes>`."
msgstr ""
":class:`tuple`, содержащий :ref:`параметры типа <type-params>` :ref:`generic "
"class <generic-classes>`."

#: ../../reference/datamodel.rst:1205
msgid ""
"The :class:`tuple` of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""
":class:`tuple` классов, которые учитываются при поиске базовых классов во "
"время разрешения метода."

#: ../../reference/datamodel.rst:1210
msgid "Special methods"
msgstr "Специальные методы"

#: ../../reference/datamodel.rst:1212
msgid ""
"In addition to the special attributes described above, all Python classes "
"also have the following two methods available:"
msgstr ""
"В дополнение к специальным атрибутам, описанным выше, все классы Python "
"также имеют следующие два метода:"

#: ../../reference/datamodel.rst:1217
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~type.__mro__`."
msgstr ""
"Этот метод может быть переопределен метаклассом, чтобы настроить порядок "
"разрешения методов для его экземпляров. Он вызывается при создании "
"экземпляра класса, а его результат сохраняется в :attr:`~type.__mro__`."

#: ../../reference/datamodel.rst:1223
msgid ""
"Each class keeps a list of weak references to its immediate subclasses. This "
"method returns a list of all those references still alive. The list is in "
"definition order. Example:"
msgstr ""
"Каждый класс хранит список слабых ссылок на свои непосредственные подклассы. "
"Этот метод возвращает список всех живых ссылок. Список приведен в порядке "
"определения. Пример:"

#: ../../reference/datamodel.rst:1227
msgid ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"
msgstr ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"

#: ../../reference/datamodel.rst:1235
msgid "Class instances"
msgstr "Экземпляры классов"

#: ../../reference/datamodel.rst:1243
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`~method.__self__` attribute is the instance.  "
"Static method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`~object."
"__getattr__` method, that is called to satisfy the lookup."
msgstr ""
"Экземпляр класса создается путем вызова объекта класса (см. выше). Экземпляр "
"класса имеет пространство имен, реализованное в виде словаря, который "
"является первым местом, в котором осуществляется поиск ссылок на атрибуты. "
"Если атрибут там не найден, а класс экземпляра имеет атрибут с таким именем, "
"поиск продолжается по атрибутам класса. Если обнаружен атрибут класса, "
"который является определяемым пользователем объектом функции, он "
"преобразуется в объект метода экземпляра, атрибут :attr:`~method.__self__` "
"которого является экземпляром. Объекты статического метода и метода класса "
"также преобразуются; см. выше в разделе «Классы». См. раздел :ref:"
"`дескрипторы`, чтобы узнать, как атрибуты класса, полученные через его "
"экземпляры, могут отличаться от объектов, фактически хранящихся в :attr:"
"`~object.__dict__` класса. Если атрибут класса не найден и класс объекта "
"имеет метод :meth:`~object.__getattr__`, который вызывается для выполнения "
"поиска."

#: ../../reference/datamodel.rst:1259
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or :"
"meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"При назначении и удалении атрибутов обновляется словарь экземпляра, а не "
"словарь класса. Если класс имеет метод :meth:`~object.__setattr__` или :meth:"
"`~object.__delattr__`, он вызывается вместо непосредственного обновления "
"словаря экземпляра."

#: ../../reference/datamodel.rst:1269
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"Экземпляры классов могут притворяться числами, последовательностями или "
"отображениями, если у них есть методы с определенными специальными именами. "
"См. раздел :ref:`специальные имена`."

#: ../../reference/datamodel.rst:1281
msgid "The class to which a class instance belongs."
msgstr "Класс, которому принадлежит экземпляр класса."

#: ../../reference/datamodel.rst:1285
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes. Not all instances have a :attr:`!__dict__` attribute; see the "
"section on :ref:`slots` for more details."
msgstr ""
"Словарь или другой объект сопоставления, используемый для хранения атрибутов "
"объекта (доступных для записи). Не все экземпляры имеют атрибут :attr:`!"
"__dict__`; более подробную информацию см. в разделе «слоты»."

#: ../../reference/datamodel.rst:1291
msgid "I/O objects (also known as file objects)"
msgstr "Объекты ввода-вывода (также известные как файловые объекты)"

#: ../../reference/datamodel.rst:1306
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
":term:`файловый объект` представляет собой открытый файл. Для создания "
"файловых объектов доступны различные ярлыки: встроенная функция :func:"
"`open`, а также :func:`os.popen`, :func:`os.fdopen` и :meth:`~socket. метод "
"socket.makefile` для объектов сокета (и, возможно, с помощью других функций "
"или методов, предоставляемых модулями расширения)."

#: ../../reference/datamodel.rst:1312
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Объекты sys.stdin, sys.stdout и sys.stderr инициализируются файловыми "
"объектами, соответствующими стандартному потоку ввода, вывода и ошибок "
"интерпретатора; все они открыты в текстовом режиме и поэтому следуют "
"интерфейсу, определенному абстрактным классом :class:`io.TextIOBase`."

#: ../../reference/datamodel.rst:1320
msgid "Internal types"
msgstr "Внутренние типы"

#: ../../reference/datamodel.rst:1326
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Несколько типов, используемых интерпретатором внутри, доступны пользователю. "
"Их определения могут измениться в будущих версиях интерпретатора, но они "
"упомянуты здесь для полноты картины."

#: ../../reference/datamodel.rst:1334
msgid "Code objects"
msgstr "Объекты кода"

#: ../../reference/datamodel.rst:1338
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"Объекты кода представляют собой *байт-компилированный* исполняемый код "
"Python или :term:`bytecode`. Разница между объектом кода и объектом функции "
"заключается в том, что объект функции содержит явную ссылку на глобальные "
"переменные функции (модуль, в котором он был определен), тогда как объект "
"кода не содержит контекста; также значения аргументов по умолчанию хранятся "
"в объекте функции, а не в объекте кода (поскольку они представляют значения, "
"рассчитанные во время выполнения). В отличие от объектов-функций, объекты "
"кода неизменяемы и не содержат ссылок (прямых или косвенных) на изменяемые "
"объекты."

#: ../../reference/datamodel.rst:1372
msgid "The function name"
msgstr "Имя функции"

#: ../../reference/datamodel.rst:1375
msgid "The fully qualified function name"
msgstr "Полное имя функции"

#: ../../reference/datamodel.rst:1380
msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""
"Общее количество позиционных :term:`parameters <parameter>` (включая только "
"позиционные параметры и параметры со значениями по умолчанию), которые имеет "
"функция."

#: ../../reference/datamodel.rst:1385
msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"Количество :term:`параметров <parameter>` (включая аргументы со значениями "
"по умолчанию), которые имеет функция."

#: ../../reference/datamodel.rst:1389
msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"Количество :term:`параметров <параметр>`, содержащих только ключевые слова "
"(включая аргументы со значениями по умолчанию), которые имеет функция."

#: ../../reference/datamodel.rst:1393
msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""
"Количество :ref:`локальных переменных <именование>`, используемых функцией "
"(включая параметры)"

#: ../../reference/datamodel.rst:1397
msgid ""
"A :class:`tuple` containing the names of the local variables in the function "
"(starting with the parameter names)"
msgstr ""
":class:`tuple`, содержащий имена локальных переменных в функции (начиная с "
"имен параметров)"

#: ../../reference/datamodel.rst:1401
msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced by nested functions inside the function"
msgstr ""
":class:`tuple`, содержащий имена :ref:`локальных переменных <naming>`, на "
"которые ссылаются вложенные функции внутри функции."

#: ../../reference/datamodel.rst:1405
msgid "A :class:`tuple` containing the names of free variables in the function"
msgstr ":class:`tuple`, содержащий имена свободных переменных в функции."

#: ../../reference/datamodel.rst:1408
msgid ""
"A string representing the sequence of :term:`bytecode` instructions in the "
"function"
msgstr ""
"Строка, представляющая последовательность инструкций :term:`bytecode` в "
"функции."

#: ../../reference/datamodel.rst:1412
msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in the "
"function"
msgstr ""
":class:`tuple`, содержащий литералы, используемые :term:`bytecode` в функции."

#: ../../reference/datamodel.rst:1416
msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the "
"function"
msgstr ""
":class:`tuple`, содержащий имена, используемые :term:`bytecode` в функции."

#: ../../reference/datamodel.rst:1420
msgid "The name of the file from which the code was compiled"
msgstr "Имя файла, из которого был скомпилирован код"

#: ../../reference/datamodel.rst:1423
msgid "The line number of the first line of the function"
msgstr "Номер первой строки функции"

#: ../../reference/datamodel.rst:1426
msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line numbers. "
"For details, see the source code of the interpreter."
msgstr ""
"Строка, кодирующая сопоставление смещений :term:`bytecode` с номерами строк. "
"Подробности смотрите в исходном коде интерпретатора."

#: ../../reference/datamodel.rst:1429
msgid ""
"This attribute of code objects is deprecated, and may be removed in Python "
"3.15."
msgstr "Этот атрибут объектов кода устарел и может быть удален в Python 3.15."

#: ../../reference/datamodel.rst:1434
msgid "The required stack size of the code object"
msgstr "Требуемый размер стека объекта кода"

#: ../../reference/datamodel.rst:1437
msgid ""
"An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr ""
":class:`integer <int>`, кодирующий несколько флагов для интерпретатора."

#: ../../reference/datamodel.rst:1442
msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit "
"``0x04`` is set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. See :ref:"
"`inspect-module-co-flags` for details on the semantics of each flags that "
"might be present."
msgstr ""
"Следующие биты флагов определены для :attr:`~codeobject.co_flags`: бит "
"``0x04`` устанавливается, если функция использует синтаксис ``*arguments`` "
"для принятия произвольного количества позиционных аргументов; бит ``0x08`` "
"устанавливается, если функция использует синтаксис ``**keywords`` для приема "
"произвольных аргументов ключевого слова; бит ``0x20`` устанавливается, если "
"функция является генератором. См. :ref:`inspect-module-co-flags` для "
"получения подробной информации о семантике каждого флага, который может "
"присутствовать."

#: ../../reference/datamodel.rst:1450
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`~codeobject.co_flags` to indicate whether a code object was "
"compiled with a particular feature enabled: bit ``0x2000`` is set if the "
"function was compiled with future division enabled; bits ``0x10`` and "
"``0x1000`` were used in earlier versions of Python."
msgstr ""
"Объявления будущих функций (``из __future__ import Division``) также "
"используют биты в :attr:`~codeobject.co_flags`, чтобы указать, был ли объект "
"кода скомпилирован с определенной включенной функцией: бит ``0x2000`` "
"устанавливается, если функция скомпилирована с включенным будущим делением; "
"биты ``0x10`` и ``0x1000`` использовались в более ранних версиях Python."

#: ../../reference/datamodel.rst:1456
msgid ""
"Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ""
"Остальные биты в :attr:`~codeobject.co_flags` зарезервированы для "
"внутреннего использования."

#: ../../reference/datamodel.rst:1460
msgid ""
"If a code object represents a function, the first item in :attr:`~codeobject."
"co_consts` is the documentation string of the function, or ``None`` if "
"undefined."
msgstr ""
"Если объект кода представляет функцию, первый элемент в :attr:`~codeobject."
"co_consts` — это строка документации функции или ``None``, если она не "
"определена."

#: ../../reference/datamodel.rst:1465
msgid "Methods on code objects"
msgstr "Методы объектов кода"

#: ../../reference/datamodel.rst:1469
msgid ""
"Returns an iterable over the source code positions of each :term:`bytecode` "
"instruction in the code object."
msgstr ""
"Возвращает итерацию по позициям исходного кода каждой инструкции :term:"
"`bytecode` в объекте кода."

#: ../../reference/datamodel.rst:1472
msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to the "
"position of the source code that compiled to the *i-th* code unit. Column "
"information is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""
"Итератор возвращает :class:`tuple`\\s, содержащий ``(start_line, end_line, "
"start_column, end_column)``. *i-й* кортеж соответствует позиции исходного "
"кода, скомпилированного в *i-й* кодовый блок. Информация столбца "
"представляет собой смещения байтов utf-8 с индексом 0 в заданной исходной "
"строке."

#: ../../reference/datamodel.rst:1478
msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr ""
"Эта позиционная информация может отсутствовать. Неисчерпывающий список "
"случаев, когда это может произойти:"

#: ../../reference/datamodel.rst:1481
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr "Запуск интерпретатора с помощью :option:`-X``no_debug_ranges``."

#: ../../reference/datamodel.rst:1482
msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""
"Загрузка файла pyc, скомпилированного с использованием :option:`-X` "
"``no_debug_ranges``."

#: ../../reference/datamodel.rst:1483
msgid "Position tuples corresponding to artificial instructions."
msgstr "Позиционируйте кортежи, соответствующие искусственным инструкциям."

#: ../../reference/datamodel.rst:1484
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""
"Номера строк и столбцов, которые невозможно представить из-за ограничений "
"реализации."

#: ../../reference/datamodel.rst:1487
msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""
"В этом случае некоторые или все элементы кортежа могут быть :const:`None`."

#: ../../reference/datamodel.rst:1493
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""
"Эта функция требует сохранения позиций столбцов в объектах кода, что может "
"привести к небольшому увеличению использования диска скомпилированными "
"файлами Python или использования памяти интерпретатора. Чтобы избежать "
"хранения дополнительной информации и/или деактивировать печать "
"дополнительной информации трассировки, можно использовать флаг командной "
"строки :option:`-X` ``no_debug_ranges`` или переменную среды :envvar:"
"`PYTHONNODEBUGRANGES`."

#: ../../reference/datamodel.rst:1502
msgid ""
"Returns an iterator that yields information about successive ranges of :term:"
"`bytecode`\\s. Each item yielded is a ``(start, end, lineno)`` :class:"
"`tuple`:"
msgstr ""
"Возвращает итератор, который возвращает информацию о последовательных "
"диапазонах :term:`bytecode`\\s. Каждый полученный элемент представляет собой "
"``(start, end, lineno)`` :class:`tuple`:"

#: ../../reference/datamodel.rst:1506
msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the start "
"of the :term:`bytecode` range"
msgstr ""
"``start`` (:class:`int`) представляет смещение (включительно) начала "
"диапазона :term:`bytecode`"

#: ../../reference/datamodel.rst:1508
msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of "
"the :term:`bytecode` range"
msgstr ""
"``end`` (:class:`int`) представляет собой смещение (исключающее) конца "
"диапазона :term:`bytecode`."

#: ../../reference/datamodel.rst:1510
msgid ""
"``lineno`` is an :class:`int` representing the line number of the :term:"
"`bytecode` range, or ``None`` if the bytecodes in the given range have no "
"line number"
msgstr ""
"``lineno`` представляет собой :class:`int`, представляющий номер строки "
"диапазона :term:`bytecode`, или ``None``, если байт-коды в данном диапазоне "
"не имеют номера строки."

#: ../../reference/datamodel.rst:1514
msgid "The items yielded will have the following properties:"
msgstr "Полученные элементы будут иметь следующие свойства:"

#: ../../reference/datamodel.rst:1516
msgid "The first range yielded will have a ``start`` of 0."
msgstr "Первый полученный диапазон будет иметь начало, равное 0."

#: ../../reference/datamodel.rst:1517
msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That is, "
"for any pair of :class:`tuple`\\s, the ``start`` of the second will be equal "
"to the ``end`` of the first."
msgstr ""
"Диапазоны ``(начало, конец)`` будут неубывающими и последовательными. То "
"есть для любой пары :class:`tuple`\\s ``начало`` второго будет равно "
"``концу`` первого."

#: ../../reference/datamodel.rst:1520
msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr "Никакой диапазон не будет обратным: ``end >= start`` для всех троек."

#: ../../reference/datamodel.rst:1521
msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of the :"
"term:`bytecode`."
msgstr ""
"Последний полученный :class:`tuple` будет иметь ``end``, равный размеру :"
"term:`bytecode`."

#: ../../reference/datamodel.rst:1524
msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges "
"are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""
"Допускаются диапазоны нулевой ширины, где ``start == end``. Диапазоны "
"нулевой ширины используются для строк, которые присутствуют в исходном коде, "
"но были удалены компилятором :term:`bytecode`."

#: ../../reference/datamodel.rst:1532
msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ":pep:`626` - Точные номера строк для отладки и других инструментов."

#: ../../reference/datamodel.rst:1533
msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr "PEP, который представил метод :meth:`!co_lines`."

#: ../../reference/datamodel.rst:1537
msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr "Верните копию объекта кода с новыми значениями для указанных полей."

#: ../../reference/datamodel.rst:1545
msgid "Frame objects"
msgstr "Объекты рамок"

#: ../../reference/datamodel.rst:1549
msgid ""
"Frame objects represent execution frames.  They may occur in :ref:`traceback "
"objects <traceback-objects>`, and are also passed to registered trace "
"functions."
msgstr ""
"Объекты фреймов представляют собой фреймы выполнения. Они могут встречаться "
"в :ref:`traceback-объектах <traceback-objects>`, а также передаются "
"зарегистрированным функциям трассировки."

#: ../../reference/datamodel.rst:1567
msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if this "
"is the bottom stack frame"
msgstr ""
"Указывает на предыдущий кадр стека (в сторону вызывающего объекта) или "
"«Нет», если это нижний кадр стека."

#: ../../reference/datamodel.rst:1571
msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"Объект кода <code-objects>` выполняется в этом кадре. Доступ к этому "
"атрибуту вызывает событие аудита <auditing>``object.__getattr__`` с "
"аргументами ``obj`` и ``\"f_code\"``."

#: ../../reference/datamodel.rst:1576
msgid ""
"The dictionary used by the frame to look up :ref:`local variables <naming>`"
msgstr ""
"Словарь, используемый фреймом для поиска :ref:`локальных переменных "
"<именование>`"

#: ../../reference/datamodel.rst:1580
msgid ""
"The dictionary used by the frame to look up :ref:`global variables <naming>`"
msgstr ""
"Словарь, используемый фреймом для поиска :ref:`глобальных переменных "
"<именование>`"

#: ../../reference/datamodel.rst:1584
msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) names "
"<naming>`"
msgstr ""
"Словарь, используемый фреймом для поиска встроенных (внутренних) имен "
"<naming>`"

#: ../../reference/datamodel.rst:1588
msgid ""
"The \"precise instruction\" of the frame object (this is an index into the :"
"term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""
"«Точная инструкция» объекта кадра (это индекс в строке :term:`bytecode` "
"объекта :ref:`code <code-objects>`)"

#: ../../reference/datamodel.rst:1604
msgid ""
"If not ``None``, this is a function called for various events during code "
"execution (this is used by debuggers). Normally an event is triggered for "
"each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""
"Если не ``None``, это функция, вызываемая для различных событий во время "
"выполнения кода (это используется отладчиками). Обычно событие запускается "
"для каждой новой строки исходного кода (см. :attr:`~frame.f_trace_lines`)."

#: ../../reference/datamodel.rst:1609
msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing event "
"for each source line."
msgstr ""
"Установите для этого атрибута значение :const:`False`, чтобы отключить "
"запуск события трассировки для каждой исходной строки."

#: ../../reference/datamodel.rst:1613
msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being traced."
msgstr ""
"Установите для этого атрибута значение :const:`True`, чтобы разрешить "
"запрашивание событий для каждого кода операции. Обратите внимание, что это "
"может привести к неопределенному поведению интерпретатора, если исключения, "
"вызванные функцией трассировки, переходят в отслеживаемую функцию."

#: ../../reference/datamodel.rst:1619
msgid ""
"The current line number of the frame -- writing to this from within a trace "
"function jumps to the given line (only for the bottom-most frame).  A "
"debugger can implement a Jump command (aka Set Next Statement) by writing to "
"this attribute."
msgstr ""
"Текущий номер строки кадра — запись в него изнутри функции трассировки "
"переходит на заданную строку (только для самого нижнего кадра). Отладчик "
"может реализовать команду перехода (также известную как Set Next Statement), "
"записывая в этот атрибут."

#: ../../reference/datamodel.rst:1625
msgid "Frame object methods"
msgstr "Методы объекта фрейма"

#: ../../reference/datamodel.rst:1627
msgid "Frame objects support one method:"
msgstr "Объекты фреймов поддерживают один метод:"

#: ../../reference/datamodel.rst:1631
msgid ""
"This method clears all references to :ref:`local variables <naming>` held by "
"the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving frame "
"objects (for example when catching an :ref:`exception <bltin-exceptions>` "
"and storing its :ref:`traceback <traceback-objects>` for later use)."
msgstr ""
"Этот метод удаляет все ссылки на :ref:`локальные переменные <naming>`, "
"хранящиеся во фрейме. Кроме того, если кадр принадлежал :term:`генератору`, "
"генератор финализируется. Это помогает разорвать циклы ссылок, включающие "
"объекты фрейма (например, при перехвате :ref:`исключения <bltin-Exceptions>` "
"и сохранении :ref:`traceback <traceback-objects>` для дальнейшего "
"использования)."

#: ../../reference/datamodel.rst:1637
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr ":exc:`RuntimeError` возникает, если кадр в данный момент выполняется."

#: ../../reference/datamodel.rst:1645
msgid "Traceback objects"
msgstr "Объекты обратной трассировки"

#: ../../reference/datamodel.rst:1658
msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception occurs, "
"and may also be explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Объекты Traceback представляют собой трассировку стека исключения <tut-"
"errors>`. Объект трассировки создается неявно при возникновении исключения, "
"а также может быть создан явно путем вызова :class:`types.TracebackType`."

#: ../../reference/datamodel.rst:1663
msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr "Объекты Traceback теперь можно явно создавать из кода Python."

#: ../../reference/datamodel.rst:1666
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by :func:"
"`sys.exc_info`, and as the :attr:`~BaseException.__traceback__` attribute of "
"the caught exception."
msgstr ""
"Для неявно созданных обратных трассировок, когда поиск обработчика "
"исключений разворачивает стек выполнения, на каждом уровне размотки объект "
"трассировки вставляется перед текущей обратной трассировкой. При входе в "
"обработчик исключений трассировка стека становится доступной программе. (См. "
"раздел :ref:`try`.) Он доступен как третий элемент кортежа, возвращаемого :"
"func:`sys.exc_info`, и как атрибут :attr:`~BaseException.__traceback__` "
"перехваченного исключения."

#: ../../reference/datamodel.rst:1675
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as :data:`sys."
"last_traceback`."
msgstr ""
"Когда программа не содержит подходящего обработчика, трассировка стека "
"записывается (в хорошем формате) в стандартный поток ошибок; если "
"интерпретатор интерактивный, он также доступен пользователю как :data:`sys."
"last_traceback`."

#: ../../reference/datamodel.rst:1680
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the :attr:`~traceback.tb_next` attributes should be linked "
"to form a full stack trace."
msgstr ""
"Для явно созданных обратных трассировок создатель трассировки должен "
"определить, как атрибуты :attr:`~traceback.tb_next` должны быть связаны для "
"формирования полной трассировки стека."

#: ../../reference/datamodel.rst:1695
msgid ""
"Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr "Указывает на выполнение :ref:`frame <frame-objects>` текущего уровня."

#: ../../reference/datamodel.rst:1698
msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"Доступ к этому атрибуту вызывает событие аудита <auditing>``object."
"__getattr__`` с аргументами ``obj`` и ``\"tb_frame\"``."

#: ../../reference/datamodel.rst:1703
msgid "Gives the line number where the exception occurred"
msgstr "Дает номер строки, в которой произошло исключение"

#: ../../reference/datamodel.rst:1706
msgid "Indicates the \"precise instruction\"."
msgstr "Указывает на «точную инструкцию»."

#: ../../reference/datamodel.rst:1708
msgid ""
"The line number and last instruction in the traceback may differ from the "
"line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""
"Номер строки и последняя инструкция в обратной трассировке могут отличаться "
"от номера строки ее :ref:`frame object <frame-objects>`, если исключение "
"произошло в операторе :keyword:`try` без совпадения, кроме предложения или "
"с :keyword:`наконец`."

#: ../../reference/datamodel.rst:1719
msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level."
msgstr ""
"Специальный записываемый атрибут :attr:`!tb_next` указывает следующий "
"уровень трассировки стека (в направлении кадра, в котором произошло "
"исключение) или ``None``, если следующего уровня нет."

#: ../../reference/datamodel.rst:1723
msgid "This attribute is now writable"
msgstr "Этот атрибут теперь доступен для записи"

#: ../../reference/datamodel.rst:1728
msgid "Slice objects"
msgstr "Объекты среза"

#: ../../reference/datamodel.rst:1732
msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Объекты срезов используются для представления срезов для методов :meth:"
"`~object.__getitem__`. Они также создаются встроенной функцией :func:`slice`."

#: ../../reference/datamodel.rst:1741
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Специальные атрибуты, доступные только для чтения: :attr:`~slice.start` — "
"нижняя граница; :attr:`~slice.stop` — верхняя граница; :attr:`~slice.step` — "
"значение шага; каждый из них имеет значение None, если опущен. Эти атрибуты "
"могут иметь любой тип."

#: ../../reference/datamodel.rst:1745
msgid "Slice objects support one method:"
msgstr "Объекты среза поддерживают один метод:"

#: ../../reference/datamodel.rst:1749
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Этот метод принимает один целочисленный аргумент *длина* и вычисляет "
"информацию о срезе, который объект среза будет описывать, если применить его "
"к последовательности элементов *длины*. Он возвращает кортеж из трех целых "
"чисел; соответственно, это индексы *start* и *stop* и *шаг* или длина шага "
"среза. Отсутствующие или выходящие за пределы индексы обрабатываются "
"способом, соответствующим обычным срезам."

#: ../../reference/datamodel.rst:1758
msgid "Static method objects"
msgstr "Объекты статического метода"

#: ../../reference/datamodel.rst:1760
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Объекты статических методов позволяют предотвратить преобразование объектов-"
"функций в объекты-методы, описанные выше. Объект статического метода — это "
"оболочка любого другого объекта, обычно определяемого пользователем объекта "
"метода. Когда объект статического метода извлекается из класса или "
"экземпляра класса, фактически возвращаемый объект является обернутым "
"объектом, который не подлежит никакому дальнейшему преобразованию. Объекты "
"статических методов также являются вызываемыми. Объекты статических методов "
"создаются встроенным конструктором :func:`staticmethod`."

#: ../../reference/datamodel.rst:1770
msgid "Class method objects"
msgstr "Объекты метода класса"

#: ../../reference/datamodel.rst:1772
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under :ref:`\"instance methods\" <instance-"
"methods>`. Class method objects are created by the built-in :func:"
"`classmethod` constructor."
msgstr ""
"Объект метода класса, как и объект статического метода, является оболочкой "
"другого объекта, которая изменяет способ извлечения этого объекта из классов "
"и экземпляров классов. Поведение объектов метода класса при таком извлечении "
"описано выше в разделе :ref:`\"методы экземпляра\" <instance-methods>`. "
"Объекты метода класса создаются встроенным конструктором :func:`classmethod`."

#: ../../reference/datamodel.rst:1782
msgid "Special method names"
msgstr "Названия специальных методов"

#: ../../reference/datamodel.rst:1788
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`~object.__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"Класс может реализовывать определенные операции, вызываемые специальным "
"синтаксисом (например, арифметические операции или индексирование и "
"нарезку), определяя методы со специальными именами. Это подход Python к "
"перегрузке операторов, позволяющий классам определять свое собственное "
"поведение по отношению к операторам языка. Например, если класс определяет "
"метод с именем :meth:`~object.__getitem__`, а ``x`` является экземпляром "
"этого класса, то ``x[i]`` примерно эквивалентен ``type( x).__getitem__(x, "
"i)``. За исключением случаев, когда указано иное, попытки выполнить операцию "
"вызывают исключение, когда не определен соответствующий метод (обычно :exc:"
"`AttributeError` или :exc:`TypeError`)."

#: ../../reference/datamodel.rst:1799
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`~object."
"__iter__` to ``None``, the class is not iterable, so calling :func:`iter` on "
"its instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`~object.__getitem__`). [#]_"
msgstr ""
"Установка специального метода в значение None означает, что соответствующая "
"операция недоступна. Например, если класс устанавливает для :meth:`~object."
"__iter__` значение ``None``, класс не является итерируемым, поэтому вызов :"
"func:`iter` для его экземпляров вызовет ошибку :exc:`TypeError` ( не "
"возвращаясь к :meth:`~object.__getitem__`). [#]_"

#: ../../reference/datamodel.rst:1805
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""
"При реализации класса, который эмулирует любой встроенный тип, важно, чтобы "
"эмуляция реализовывалась только в той степени, в которой это имеет смысл для "
"моделируемого объекта. Например, некоторые последовательности могут хорошо "
"работать с извлечением отдельных элементов, но извлечение среза может не "
"иметь смысла. (Одним из примеров является интерфейс :class:`~xml.dom."
"NodeList` в объектной модели документа W3C.)"

#: ../../reference/datamodel.rst:1816
msgid "Basic customization"
msgstr "Базовая настройка"

#: ../../reference/datamodel.rst:1822
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Вызывается для создания нового экземпляра класса *cls*. :meth:`__new__` — "
"это статический метод (специальный, поэтому вам не нужно объявлять его как "
"таковой), который принимает класс, экземпляр которого был запрошен, в "
"качестве первого аргумента. Остальные аргументы передаются в выражение "
"конструктора объекта (вызов класса). Возвращаемое значение :meth:`__new__` "
"должно быть экземпляром нового объекта (обычно экземпляром *cls*)."

#: ../../reference/datamodel.rst:1829
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""
"Типичные реализации создают новый экземпляр класса, вызывая метод :meth:"
"`__new__` суперкласса, используя ``super().__new__(cls[, ...])`` с "
"соответствующими аргументами, а затем изменяя вновь созданный экземпляр как "
"необходимо, прежде чем вернуть его."

#: ../../reference/datamodel.rst:1834
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"Если :meth:`__new__` вызывается во время создания объекта и возвращает "
"экземпляр *cls*, то метод :meth:`__init__` нового экземпляра будет вызван "
"как ``__init__(self[, ...])` `, где *self* — новый экземпляр, а остальные "
"аргументы такие же, как были переданы конструктору объекта."

#: ../../reference/datamodel.rst:1839
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Если :meth:`__new__` не возвращает экземпляр *cls*, то метод :meth:"
"`__init__` нового экземпляра не будет вызван."

#: ../../reference/datamodel.rst:1842
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` предназначен главным образом для того, чтобы позволить "
"подклассам неизменяемых типов (таких как int, str или tuple) настраивать "
"создание экземпляров. Его также часто переопределяют в пользовательских "
"метаклассах, чтобы настроить создание классов."

#: ../../reference/datamodel.rst:1851
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Вызывается после создания экземпляра (с помощью :meth:`__new__`), но до "
"того, как он будет возвращен вызывающему объекту. Аргументы — это те, "
"которые передаются в выражение конструктора класса. Если базовый класс имеет "
"метод :meth:`__init__`, метод :meth:`__init__` производного класса, если "
"таковой имеется, должен явно вызывать его, чтобы гарантировать правильную "
"инициализацию части экземпляра базового класса; например: ``super()."
"__init__([args...])``."

#: ../../reference/datamodel.rst:1858
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Поскольку :meth:`__new__` и :meth:`__init__` работают вместе при создании "
"объектов (:meth:`__new__` для его создания и :meth:`__init__` для его "
"настройки), нет не``None`` значение может быть возвращено :meth:`__init__`; "
"это приведет к возникновению ошибки :exc:`TypeError` во время выполнения."

#: ../../reference/datamodel.rst:1871
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"Вызывается, когда экземпляр собирается быть уничтожен. Это также называется "
"финализатором или (неправильно) деструктором. Если базовый класс имеет "
"метод :meth:`__del__`, метод :meth:`__del__` производного класса, если "
"таковой имеется, должен явно вызвать его, чтобы гарантировать правильное "
"удаление части экземпляра базового класса."

#: ../../reference/datamodel.rst:1877
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
"Для метода :meth:`__del__` возможно (хотя и не рекомендуется!) отложить "
"уничтожение экземпляра, создав на него новую ссылку. Это называется объект "
"*воскрешение*. От реализации зависит, будет ли :meth:`__del__` вызываться во "
"второй раз, когда воскресший объект вот-вот будет уничтожен; текущая "
"реализация :term:`CPython` вызывает его только один раз."

#: ../../reference/datamodel.rst:1884
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be called "
"when an object is garbage collected."
msgstr ""
"Не гарантируется, что методы :meth:`__del__` будут вызываться для объектов, "
"которые все еще существуют на момент выхода интерпретатора. :class:`weakref."
"finalize` предоставляет простой способ зарегистрировать функцию очистки, "
"которая будет вызываться при сборке мусора."

#: ../../reference/datamodel.rst:1891
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` не вызывает напрямую ``x.__del__()`` --- первый уменьшает счетчик "
"ссылок для ``x`` на единицу, а второй вызывается только тогда, когда ``x`` "
"счетчик ссылок достигает нуля."

#: ../../reference/datamodel.rst:1896
msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A "
"common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""
"Ссылочный цикл может предотвратить обнуление счетчика ссылок объекта. В этом "
"случае цикл позже будет обнаружен и удален :term:`циклическим сборщиком "
"мусора <сборка мусора>`. Распространенной причиной ссылочных циклов является "
"обнаружение исключения в локальной переменной. Затем локальные переменные "
"кадра ссылаются на исключение, которое ссылается на собственную обратную "
"трассировку, которая ссылается на локальные переменные всех кадров, попавших "
"в обратную трассировку."

#: ../../reference/datamodel.rst:1906
msgid "Documentation for the :mod:`gc` module."
msgstr "Документация для модуля :mod:`gc`."

#: ../../reference/datamodel.rst:1910
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"Из-за ненадежных обстоятельств, при которых вызываются методы :meth:"
"`__del__`, исключения, возникающие во время их выполнения, игнорируются, и "
"вместо этого выводится предупреждение в ``sys.stderr``. В частности:"

#: ../../reference/datamodel.rst:1914
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` может быть вызван при выполнении произвольного кода, в том "
"числе из любого произвольного потока. Если :meth:`__del__` необходимо "
"заблокировать или вызвать любой другой блокирующий ресурс, это может "
"привести к взаимоблокировке, поскольку ресурс уже может быть занят кодом, "
"который прерывается для выполнения :meth:`__del__`."

#: ../../reference/datamodel.rst:1920
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` может быть вызван при выполнении произвольного кода, в том "
"числе из любого произвольного потока. Если :meth:`__del__` необходимо "
"заблокировать или вызвать любой другой блокирующий ресурс, это может "
"привести к взаимоблокировке, поскольку ресурс уже может быть занят кодом, "
"который прерывается для выполнения :meth:`__del__`."

#: ../../reference/datamodel.rst:1935
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
"Вызывается встроенной функцией :func:`repr` для вычисления «официального» "
"строкового представления объекта. Если это вообще возможно, это должно "
"выглядеть как допустимое выражение Python, которое можно было бы "
"использовать для воссоздания объекта с тем же значением (при наличии "
"подходящей среды). Если это невозможно, должна быть возвращена строка вида "
"``<...некоторое полезное описание...>``. Возвращаемое значение должно быть "
"строковым объектом. Если класс определяет :meth:`__repr__`, но не :meth:"
"`__str__`, то :meth:`__repr__` также используется, когда требуется "
"«неформальное» строковое представление экземпляров этого класса."

#: ../../reference/datamodel.rst:1944
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous. A default implementation "
"is provided by the :class:`object` class itself."
msgstr ""
"Обычно это используется для отладки, поэтому важно, чтобы представление было "
"информативным и однозначным. Реализация по умолчанию предоставляется самим "
"классом :class:`object`."

#: ../../reference/datamodel.rst:1956
msgid ""
"Called by :func:`str(object) <str>`, the default :meth:`__format__` "
"implementation, and the built-in function :func:`print`, to compute the "
"\"informal\" or nicely printable string representation of an object.  The "
"return value must be a :ref:`str <textseq>` object."
msgstr ""
"Вызывается :func:`str(object) <str>`, реализацией по умолчанию :meth:"
"`__format__` и встроенной функцией :func:`print` для вычисления "
"\"неформального\" или удобного для печати строкового представления объект. "
"Возвращаемое значение должно быть объектом :ref:`str <textseq>`."

#: ../../reference/datamodel.rst:1961
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Этот метод отличается от :meth:`object.__repr__` тем, что не ожидается, что :"
"meth:`__str__` вернет допустимое выражение Python: можно использовать более "
"удобное или краткое представление."

#: ../../reference/datamodel.rst:1965
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"Реализация по умолчанию, определенная встроенным типом :class:`object`, "
"вызывает :meth:`object.__repr__`."

#: ../../reference/datamodel.rst:1975
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object. The :class:"
"`object` class itself does not provide this method."
msgstr ""
"Вызывается :ref:`bytes <func-bytes>` для вычисления представления объекта в "
"виде строки байтов. Это должно вернуть объект :class:`bytes`. Сам класс :"
"class:`object` не предоставляет этот метод."

#: ../../reference/datamodel.rst:1987
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"Вызывается встроенной функцией :func:`format` и, как следствие, оценкой :ref:"
"`форматированных строковых литералов <f-strings>` и методом :meth:`str."
"format` для создания \"форматированного \"строковое представление объекта. "
"Аргумент *format_spec* представляет собой строку, содержащую описание "
"желаемых параметров форматирования. Интерпретация аргумента *format_spec* "
"зависит от типа, реализующего :meth:`__format__`, однако большинство классов "
"либо делегируют форматирование одному из встроенных типов, либо используют "
"аналогичный синтаксис параметров форматирования."

#: ../../reference/datamodel.rst:1997
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"См. :ref:`formatspec` для описания стандартного синтаксиса форматирования."

#: ../../reference/datamodel.rst:1999
msgid "The return value must be a string object."
msgstr "Возвращаемое значение должно быть строковым объектом."

#: ../../reference/datamodel.rst:2001
msgid ""
"The default implementation by the :class:`object` class should be given an "
"empty *format_spec* string. It delegates to :meth:`__str__`."
msgstr ""
"Реализация по умолчанию класса :class:`object` должна содержать пустую "
"строку *format_spec*. Он делегирует :meth:`__str__`."

#: ../../reference/datamodel.rst:2004
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"Сам метод __format__ объекта ``object`` вызывает :exc:`TypeError`, если ему "
"передана любая непустая строка."

#: ../../reference/datamodel.rst:2008
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` теперь эквивалентен ``str(x)``, а не "
"``format(str(x), '')``."

#: ../../reference/datamodel.rst:2024
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"Это так называемые методы «богатого сравнения». Соответствие между символами "
"операторов и именами методов следующее: ``x<y`` вызывает ``x.__lt__(y)``, "
"``x<=y`` вызывает ``x.__le__(y)`` , ``x==y`` вызывает ``x.__eq__(y)``, ``x!"
"=y`` вызывает ``x.__ne__(y)``, ``x>y`` вызывает `` `x.__gt__(y)``, а "
"``x>=y`` вызывает ``x.__ge__(y)``."

#: ../../reference/datamodel.rst:2030
msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"Метод расширенного сравнения может вернуть синглтон :data:`NotImplemented`, "
"если он не реализует операцию для данной пары аргументов. По соглашению, "
"«False» и «True» возвращаются для успешного сравнения. Однако эти методы "
"могут возвращать любое значение, поэтому, если оператор сравнения "
"используется в логическом контексте (например, в условии оператора if), "
"Python вызовет :func:`bool` для значения, чтобы определить является ли "
"результат истинным или ложным."

#: ../../reference/datamodel.rst:2037
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning :"
"data:`NotImplemented` in the case of a false comparison: ``True if x is y "
"else NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is :data:`!NotImplemented`.  There "
"are no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""
"По умолчанию ``object`` реализует :meth:`__eq__`, используя ``is``, "
"возвращая :data:`NotImplemented` в случае ложного сравнения: ``True if x is "
"y else NotImplemented``. Для :meth:`__ne__` по умолчанию он делегирует :meth:"
"`__eq__` и инвертирует результат, если только он не является :data:`!"
"NotImplemented`. Между операторами сравнения или реализациями по умолчанию "
"нет других подразумеваемых отношений; например, истинность ``(x<y или "
"x==y)`` не подразумевает ``x<=y``. Чтобы автоматически генерировать операции "
"упорядочивания из одной корневой операции, см. :func:`functools."
"total_ordering`."

#: ../../reference/datamodel.rst:2046
msgid ""
"By default, the :class:`object` class provides implementations consistent "
"with :ref:`expressions-value-comparisons`: equality compares according to "
"object identity, and order comparisons raise :exc:`TypeError`. Each default "
"method may generate these results directly, but may also return :data:"
"`NotImplemented`."
msgstr ""
"По умолчанию класс :class:`object` предоставляет реализации, совместимые с :"
"ref:`expressions-value-comparisons`: сравнение на равенство выполняется в "
"соответствии с идентичностью объекта, а сравнения порядка вызывают :exc:"
"`TypeError`. Каждый метод по умолчанию может генерировать эти результаты "
"напрямую, но также может возвращать :data:`NotImplemented`."

#: ../../reference/datamodel.rst:2052
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"См. параграф :meth:`__hash__` для некоторых важных замечаний по созданию :"
"term:`hashable` объектов, которые поддерживают пользовательские операции "
"сравнения и могут использоваться в качестве ключей словаря."

#: ../../reference/datamodel.rst:2056
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and the right operand's type is a direct or indirect "
"subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""
"Не существует версий этих методов с замененными аргументами (их следует "
"использовать, когда левый аргумент не поддерживает операцию, а правый "
"аргумент поддерживает); скорее, :meth:`__lt__` и :meth:`__gt__` являются "
"отражением друг друга, :meth:`__le__` и :meth:`__ge__` являются отражением "
"друг друга, а :meth:`__eq__` и :meth:` __ne__` — их собственное отражение. "
"Если операнды имеют разные типы и тип правого операнда является прямым или "
"косвенным подклассом типа левого операнда, отраженный метод правого операнда "
"имеет приоритет, в противном случае приоритет имеет метод левого операнда. "
"Виртуальное подклассирование не рассматривается."

#: ../../reference/datamodel.rst:2067
msgid ""
"When no appropriate method returns any value other than :data:"
"`NotImplemented`, the ``==`` and ``!=`` operators will fall back to ``is`` "
"and ``is not``, respectively."
msgstr ""
"Если ни один подходящий метод не возвращает никакого значения, кроме :data:"
"`NotImplemented`, операторы ``==`` и ``!=`` возвращаются к значениям ``is`` "
"и ``is not`` соответственно."

#: ../../reference/datamodel.rst:2076
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  The ``__hash__()`` method should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"Вызывается встроенной функцией :func:`hash` и для операций с членами "
"хешированных коллекций, включая :class:`set`, :class:`frozenset` и :class:"
"`dict`. Метод ``__hash__()`` должен возвращать целое число. Единственное "
"необходимое свойство — это то, что объекты, которые сравниваются равными, "
"имеют одинаковое значение хеш-функции; рекомендуется смешивать хеш-значения "
"компонентов объекта, которые также играют роль в сравнении объектов, "
"упаковывая их в кортеж и хешируя кортеж. Пример::"

#: ../../reference/datamodel.rst:2084
msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"

#: ../../reference/datamodel.rst:2089
msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` усекает значение, возвращаемое пользовательским методом :meth:"
"`__hash__` объекта, до размера :c:type:`Py_ssize_t`. Обычно это 8 байт в 64-"
"битных сборках и 4 байта в 32-битных сборках. Если :meth:`__hash__` объекта "
"должен взаимодействовать со сборками разного битового размера, обязательно "
"проверьте ширину во всех поддерживаемых сборках. Самый простой способ "
"сделать это — использовать ``python -c \"import sys; print(sys.hash_info."
"width)\"``."

#: ../../reference/datamodel.rst:2097
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of :term:`hashable` collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the "
"wrong hash bucket)."
msgstr ""
"Если класс не определяет метод :meth:`__eq__`, он также не должен определять "
"операцию :meth:`__hash__`; если он определяет :meth:`__eq__`, но не :meth:"
"`__hash__`, его экземпляры нельзя будет использовать в качестве элементов в "
"хешируемых коллекциях. Если класс определяет изменяемые объекты и реализует "
"метод :meth:`__eq__`, он не должен реализовывать :meth:`__hash__`, поскольку "
"реализация коллекций :term:`hashable` требует, чтобы хэш-значение ключа было "
"неизменяемым (если хэш-значение объекта изменится, он окажется в "
"неправильном хеш-ведре)."

#: ../../reference/datamodel.rst:2106
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default (inherited from the :class:`object` class); with them, all objects "
"compare unequal (except with themselves) and ``x.__hash__()`` returns an "
"appropriate value such that ``x == y`` implies both that ``x is y`` and "
"``hash(x) == hash(y)``."
msgstr ""
"Пользовательские классы по умолчанию имеют методы :meth:`__eq__` и :meth:"
"`__hash__` (наследованные от класса :class:`object`); с ними все объекты "
"сравниваются неравными (кроме самих себя), и ``x.__hash__()`` возвращает "
"подходящее значение, такое, что ``x == y`` подразумевает и то, что ``x есть "
"y``, и ``хэш (x) == хэш(y)``."

#: ../../reference/datamodel.rst:2111
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"Класс, который переопределяет :meth:`__eq__` и не определяет :meth:"
"`__hash__`, для своего :meth:`__hash__` будет неявно установлено значение "
"``None``. Когда метод :meth:`__hash__` класса имеет значение ``None``, "
"экземпляры класса вызовут соответствующую ошибку :exc:`TypeError`, когда "
"программа попытается получить их хеш-значение, а также будут правильно "
"идентифицированы как нехешируется при проверке isinstance(obj, Collections."
"abc.Hashable)``."

#: ../../reference/datamodel.rst:2118
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Если класс, который переопределяет :meth:`__eq__`, должен сохранить "
"реализацию :meth:`__hash__` из родительского класса, интерпретатору "
"необходимо сообщить об этом явно, установив ``__hash__ = <ParentClass>."
"__hash__``."

#: ../../reference/datamodel.rst:2122
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Если класс, который не переопределяет :meth:`__eq__`, желает подавить "
"поддержку хеширования, он должен включить ``__hash__ = None`` в определение "
"класса. Класс, который определяет свой собственный :meth:`__hash__`, который "
"явно вызывает :exc:`TypeError`, будет неправильно идентифицирован как "
"хэшируемый при вызове ``isinstance(obj, Collections.abc.Hashable)``."

#: ../../reference/datamodel.rst:2131
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"По умолчанию значения :meth:`__hash__` объектов str и bytes «приправлены» "
"непредсказуемым случайным значением. Хотя они остаются постоянными в рамках "
"отдельного процесса Python, их невозможно предсказать при повторных вызовах "
"Python."

#: ../../reference/datamodel.rst:2136
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See http://ocert.org/"
"advisories/ocert-2011-003.html for details."
msgstr ""
"Это предназначено для обеспечения защиты от отказа в обслуживании, "
"вызванного тщательно выбранными входными данными, которые используют "
"наихудшую производительность вставки dict, сложность *O*\\ (*n*\\ :sup:`2`). "
"Подробности см. на http://ocert.org/advisories/ocert-2011-003.html."

#: ../../reference/datamodel.rst:2141
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Изменение значений хеш-функции влияет на порядок итерации наборов. Python "
"никогда не давал гарантий относительно такого порядка (и он обычно "
"варьируется между 32-битными и 64-битными сборками)."

#: ../../reference/datamodel.rst:2145
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "См. также :envvar:`PYTHONHASHSEED`."

#: ../../reference/datamodel.rst:2147
msgid "Hash randomization is enabled by default."
msgstr "Рандомизация хеша включена по умолчанию."

#: ../../reference/datamodel.rst:2155
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`~object.__len__` is called, if it is defined, and the object "
"is considered true if its result is nonzero.  If a class defines neither :"
"meth:`!__len__` nor :meth:`!__bool__` (which is true of the :class:`object` "
"class itself), all its instances are considered true."
msgstr ""
"Вызывается для реализации проверки истинности и встроенной операции bool(); "
"должен возвращать ``False`` или ``True``. Когда этот метод не определен, "
"вызывается :meth:`~object.__len__`, если он определен, и объект считается "
"истинным, если его результат ненулевой. Если класс не определяет ни :meth:`!"
"__len__`, ни :meth:`!__bool__` (что верно для самого класса :class:"
"`object`), все его экземпляры считаются истинными."

#: ../../reference/datamodel.rst:2166
msgid "Customizing attribute access"
msgstr "Настройка доступа к атрибутам"

#: ../../reference/datamodel.rst:2168
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Следующие методы могут быть определены для настройки значения доступа к "
"атрибуту (использование, присвоение или удаление ``x.name``) для экземпляров "
"класса."

#: ../../reference/datamodel.rst:2176
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. The :class:"
"`object` class itself does not provide this method."
msgstr ""
"Вызывается, когда доступ к атрибуту по умолчанию завершается с ошибкой :exc:"
"`AttributeError` (либо :meth:`__getattribute__` вызывает :exc:"
"`AttributeError`, поскольку *name* не является атрибутом экземпляра или "
"атрибутом в дереве классов для `` self`` или :meth:`__get__` свойства *name* "
"вызывает :exc:`AttributeError`). Этот метод должен либо вернуть "
"(вычисленное) значение атрибута, либо вызвать исключение :exc:"
"`AttributeError`. Сам класс :class:`object` не предоставляет этот метод."

#: ../../reference/datamodel.rst:2184
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"Обратите внимание: если атрибут найден с помощью обычного механизма, :meth:"
"`__getattr__` не вызывается. (Это намеренная асимметрия между :meth:"
"`__getattr__` и :meth:`__setattr__`.) Это сделано как из соображений "
"эффективности, так и потому, что в противном случае :meth:`__getattr__` не "
"имел бы возможности получить доступ к другим атрибутам экземпляра. Обратите "
"внимание, что, по крайней мере, для переменных экземпляра, вы можете "
"имитировать полный контроль, не вставляя никаких значений в словарь "
"атрибутов экземпляра (а вместо этого вставляя их в другой объект). См. "
"метод :meth:`__getattribute__` ниже, чтобы узнать, как получить полный "
"контроль над доступом к атрибутам."

#: ../../reference/datamodel.rst:2197
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Вызывается безоговорочно для реализации доступа к атрибутам экземпляров "
"класса. Если класс также определяет :meth:`__getattr__`, последний не будет "
"вызываться, пока :meth:`__getattribute__` не вызовет его явно или не "
"вызовет :exc:`AttributeError`. Этот метод должен возвращать (вычисленное) "
"значение атрибута или вызывать исключение :exc:`AttributeError`. Чтобы "
"избежать бесконечной рекурсии в этом методе, его реализация должна всегда "
"вызывать метод базового класса с тем же именем для доступа к любым "
"необходимым атрибутам, например, ``object.__getattribute__(self, name)``."

#: ../../reference/datamodel.rst:2208
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""
"Этот метод по-прежнему можно обойти при поиске специальных методов в "
"результате неявного вызова через синтаксис языка или встроенные функции "
"<builtin-functions>. См. :ref:`специальный поиск`."

#: ../../reference/datamodel.rst:2213 ../../reference/datamodel.rst:2215
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Для доступа к определенным конфиденциальным атрибутам вызывает событие "
"аудита <auditing>``object.__getattr__`` с аргументами ``obj`` и ``name``."

#: ../../reference/datamodel.rst:2222
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Вызывается при попытке назначения атрибута. Это вызывается вместо обычного "
"механизма (т.е. сохранения значения в словаре экземпляра). *имя* — имя "
"атрибута, *значение* — значение, которое ему будет присвоено."

#: ../../reference/datamodel.rst:2226
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
"Если :meth:`__setattr__` хочет присвоить атрибут экземпляра, он должен "
"вызвать метод базового класса с тем же именем, например, ``object."
"__setattr__(self, name, value)``."

#: ../../reference/datamodel.rst:2230 ../../reference/datamodel.rst:2232
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"Для определенных назначений конфиденциальных атрибутов вызывает событие "
"аудита <auditing>``object.__setattr__`` с аргументами ``obj``, ``name``, "
"``value``."

#: ../../reference/datamodel.rst:2239
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Аналогично :meth:`__setattr__`, но для удаления атрибута вместо присвоения. "
"Это следует реализовать только в том случае, если ``del obj.name`` имеет "
"смысл для объекта."

#: ../../reference/datamodel.rst:2242 ../../reference/datamodel.rst:2244
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"При удалении некоторых конфиденциальных атрибутов вызывает событие аудита "
"<auditing>``object.__delattr__`` с аргументами ``obj`` и ``name``."

#: ../../reference/datamodel.rst:2251
msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts it."
msgstr ""
"Вызывается, когда для объекта вызывается :func:`dir`. Итерируемый объект "
"должен быть возвращен. :func:`dir` преобразует возвращаемый итерируемый "
"объект в список и сортирует его."

#: ../../reference/datamodel.rst:2256
msgid "Customizing module attribute access"
msgstr "Настройка доступа к атрибутам модуля"

#: ../../reference/datamodel.rst:2263
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"Специальные имена ``__getattr__`` и ``__dir__`` также можно использовать для "
"настройки доступа к атрибутам модуля. Функция ``__getattr__`` на уровне "
"модуля должна принимать один аргумент, который является именем атрибута, и "
"возвращать вычисленное значение или вызывать ошибку :exc:`AttributeError`. "
"Если атрибут не найден в объекте модуля посредством обычного поиска, т.е. :"
"meth:`object.__getattribute__`, то ``__getattr__`` ищется в модуле "
"``__dict__`` перед выдачей :exc:`AttributeError` . Если он найден, он "
"вызывается с именем атрибута и возвращается результат."

#: ../../reference/datamodel.rst:2272
msgid ""
"The ``__dir__`` function should accept no arguments, and return an iterable "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"Функция ``__dir__`` не должна принимать аргументов и возвращать итерацию "
"строк, представляющих имена, доступные в модуле. Если эта функция "
"присутствует, она переопределяет стандартный поиск по :func:`dir` в модуле."

#: ../../reference/datamodel.rst:2276
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"Для более детальной настройки поведения модуля (установки атрибутов, свойств "
"и т. д.) можно установить атрибут ``__class__`` объекта модуля в подкласс :"
"class:`types.ModuleType`. Например::"

#: ../../reference/datamodel.rst:2280
msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"

#: ../../reference/datamodel.rst:2294
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"Определение модуля ``__getattr__`` и установка модуля ``__class__`` влияют "
"только на поиск, выполненный с использованием синтаксиса доступа к атрибутам "
"- прямой доступ к глобальным переменным модуля (либо с помощью кода внутри "
"модуля, либо через ссылку на словарь глобальных переменных модуля) "
"невозможен. незатронутый."

#: ../../reference/datamodel.rst:2299
msgid "``__class__`` module attribute is now writable."
msgstr "Атрибут модуля ``__class__`` теперь доступен для записи."

#: ../../reference/datamodel.rst:2302
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "Атрибуты модуля ``__getattr__`` и ``__dir__``."

#: ../../reference/datamodel.rst:2307
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - Модуль __getattr__ и __dir__"

#: ../../reference/datamodel.rst:2308
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Описывает функции ``__getattr__`` и ``__dir__`` в модулях."

#: ../../reference/datamodel.rst:2314
msgid "Implementing Descriptors"
msgstr "Реализация дескрипторов"

#: ../../reference/datamodel.rst:2316
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`.  The :class:`object` class itself "
"does not implement any of these protocols."
msgstr ""
"Следующие методы применяются только тогда, когда экземпляр класса, "
"содержащий метод (так называемый класс *дескриптора*), появляется в классе "
"*владельца* (дескриптор должен находиться либо в словаре классов владельца, "
"либо в словаре классов для одного из его родители). В приведенных ниже "
"примерах «атрибут» относится к атрибуту, имя которого является ключом "
"свойства в классе владельца :attr:`~object.__dict__`. Сам класс :class:"
"`object` не реализует ни один из этих протоколов."

#: ../../reference/datamodel.rst:2326
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Вызывается для получения атрибута класса-владельца (доступ к атрибуту "
"класса) или экземпляра этого класса (доступ к атрибуту экземпляра). "
"Необязательный аргумент *owner* — это класс владельца, а *instance* — это "
"экземпляр, через который был осуществлен доступ к атрибуту, или ``None``, "
"когда доступ к атрибуту осуществляется через *owner*."

#: ../../reference/datamodel.rst:2332
msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr ""
"Этот метод должен возвращать вычисленное значение атрибута или вызывать "
"исключение :exc:`AttributeError`."

#: ../../reference/datamodel.rst:2335
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
":PEP:`252` указывает, что :meth:`__get__` можно вызвать с одним или двумя "
"аргументами. Собственные встроенные дескрипторы Python поддерживают эту "
"спецификацию; однако вполне вероятно, что некоторые сторонние инструменты "
"имеют дескрипторы, которым требуются оба аргумента. Собственная реализация "
"Python :meth:`__getattribute__` всегда передает оба аргумента, независимо от "
"того, требуются они или нет."

#: ../../reference/datamodel.rst:2344
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Вызывается для установки атрибута экземпляра *instance* класса владельца в "
"новое значение *value*."

#: ../../reference/datamodel.rst:2347
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Обратите внимание: добавление :meth:`__set__` или :meth:`__delete__` меняет "
"тип дескриптора на «дескриптор данных». Дополнительную информацию смотрите в "
"разделе :ref:`descriptor-invocacy`."

#: ../../reference/datamodel.rst:2353
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Вызывается для удаления атрибута в экземпляре *экземпляра* класса владельца."

#: ../../reference/datamodel.rst:2355
msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` attribute "
"present:"
msgstr ""
"Экземпляры дескрипторов также могут иметь атрибут :attr:`!__objclass__`:"

#: ../../reference/datamodel.rst:2360
msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"Атрибут :attr:`!__objclass__` интерпретируется модулем :mod:`inspect` как "
"определяющий класс, в котором был определен этот объект (соответствующая "
"установка может помочь в самоанализе атрибутов динамического класса во время "
"выполнения). Для вызываемых объектов это может указывать на то, что "
"экземпляр данного типа (или подкласса) ожидается или требуется в качестве "
"первого позиционного аргумента (например, CPython устанавливает этот атрибут "
"для несвязанных методов, реализованных на C)."

#: ../../reference/datamodel.rst:2371
msgid "Invoking Descriptors"
msgstr "Вызов дескрипторов"

#: ../../reference/datamodel.rst:2373
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and :meth:"
"`~object.__delete__`. If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr ""
"В общем, дескриптор — это атрибут объекта с «поведением привязки», доступ к "
"атрибуту которого переопределен методами протокола дескриптора: :meth:"
"`~object.__get__`, :meth:`~object.__set__` и :meth:`~object.__delete__`. "
"Если какой-либо из этих методов определен для объекта, он называется "
"дескриптором."

#: ../../reference/datamodel.rst:2379
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"Поведение по умолчанию для доступа к атрибуту — получение, установка или "
"удаление атрибута из словаря объекта. Например, ``ax`` имеет цепочку поиска, "
"начинающуюся с ``a.__dict__['x']``, затем ``type(a).__dict__['x']`` и "
"продолжающуюся через базовые классы. типа ``type(a)``, исключая метаклассы."

#: ../../reference/datamodel.rst:2384
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"Однако если искомое значение является объектом, определяющим один из методов "
"дескриптора, то Python может переопределить поведение по умолчанию и вместо "
"этого вызвать метод дескриптора. Где это происходит в цепочке приоритетов, "
"зависит от того, какие методы дескриптора были определены и как они были "
"вызваны."

#: ../../reference/datamodel.rst:2389
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"Отправной точкой для вызова дескриптора является привязка ax. Способ сборки "
"аргументов зависит от ``a``:"

#: ../../reference/datamodel.rst:2392
msgid "Direct Call"
msgstr "Прямой вызов"

#: ../../reference/datamodel.rst:2393
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"Самый простой и наименее распространенный вызов — это когда пользовательский "
"код напрямую вызывает метод дескриптора: ``x.__get__(a)``."

#: ../../reference/datamodel.rst:2396
msgid "Instance Binding"
msgstr "Привязка экземпляра"

#: ../../reference/datamodel.rst:2397
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"При привязке к экземпляру объекта ``ax`` преобразуется в вызов: ``type(a)."
"__dict__['x'].__get__(a, type(a))``."

#: ../../reference/datamodel.rst:2400
msgid "Class Binding"
msgstr "Привязка класса"

#: ../../reference/datamodel.rst:2401
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"При привязке к классу ``Ax`` преобразуется в вызов: ``A.__dict__['x']."
"__get__(None, A)``."

#: ../../reference/datamodel.rst:2404
msgid "Super Binding"
msgstr "Супер связывание"

#: ../../reference/datamodel.rst:2405
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns ``B.__dict__['x']."
"__get__(a, A)``.  If not a descriptor, ``x`` is returned unchanged."
msgstr ""
"Поиск с точкой, такой как ``super(A, a).x``, ищет в ``a.__class__.__mro__`` "
"базовый класс ``B``, следующий за ``A``, а затем возвращает ``B."
"__dict__' ['x'].__get__(a, A)``. Если это не дескриптор, ``x`` возвращается "
"без изменений."

#: ../../reference/datamodel.rst:2442
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and :meth:"
"`~object.__delete__`.  If it does not define :meth:`!__get__`, then "
"accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  Normally, "
"data descriptors define both :meth:`!__get__` and :meth:`!__set__`, while "
"non-data descriptors have just the :meth:`!__get__` method.  Data "
"descriptors with :meth:`!__get__` and :meth:`!__set__` (and/or :meth:`!"
"__delete__`) defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"Например, привязка экземпляров приоритет вызова дескриптора зависит от того, "
"какие методы дескриптора определены. Дескриптор может определять любую "
"комбинацию :meth:`~object.__get__`, :meth:`~object.__set__` и :meth:`~object."
"__delete__`. Если он не определяет :meth:`!__get__`, то доступ к атрибуту "
"вернет сам объект дескриптора, если в словаре экземпляра объекта нет "
"значения. Если дескриптор определяет :meth:`!__set__` и/или :meth:`!"
"__delete__`, это дескриптор данных; если он не определяет ни того, ни "
"другого, это дескриптор, не являющийся данными. Обычно дескрипторы данных "
"определяют как :meth:`!__get__`, так и :meth:`!__set__`, в то время как "
"дескрипторы, не являющиеся данными, имеют только метод :meth:`!__get__`. "
"Дескрипторы данных с определенными :meth:`!__get__` и :meth:`!__set__` (и/"
"или :meth:`!__delete__`) всегда переопределяют переопределение в словаре "
"экземпляра. Напротив, дескрипторы, не являющиеся данными, могут быть "
"переопределены экземплярами."

#: ../../reference/datamodel.rst:2457
msgid ""
"Python methods (including those decorated with :func:`@staticmethod "
"<staticmethod>` and :func:`@classmethod <classmethod>`) are implemented as "
"non-data descriptors.  Accordingly, instances can redefine and override "
"methods.  This allows individual instances to acquire behaviors that differ "
"from other instances of the same class."
msgstr ""
"Методы Python (включая те, которые украшены :func:`@staticmethod "
"<staticmethod>` и :func:`@classmethod <classmethod>`) реализованы как "
"дескрипторы, не относящиеся к данным. Соответственно, экземпляры могут "
"переопределять и переопределять методы. Это позволяет отдельным экземплярам "
"приобретать поведение, отличное от поведения других экземпляров того же "
"класса."

#: ../../reference/datamodel.rst:2463
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"Функция :func:`property` реализована как дескриптор данных. Соответственно, "
"экземпляры не могут переопределить поведение свойства."

#: ../../reference/datamodel.rst:2470
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:2472
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* позволяют нам явно объявлять элементы данных (например, "
"свойства) и запрещать создание :attr:`~object.__dict__` и *__weakref__* "
"(если они явно не объявлены в *__slots__* или не доступны в родительском "
"элементе)."

#: ../../reference/datamodel.rst:2476
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
"Пространство, сэкономленное при использовании :attr:`~object.__dict__`, "
"может быть значительным. Скорость поиска атрибутов также может быть "
"значительно улучшена."

#: ../../reference/datamodel.rst:2481
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of :attr:"
"`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"Этой переменной класса можно присвоить строку, итерацию или "
"последовательность строк с именами переменных, используемыми экземплярами. "
"*__slots__* резервирует место для объявленных переменных и предотвращает "
"автоматическое создание :attr:`~object.__dict__` и *__weakref__* для каждого "
"экземпляра."

#: ../../reference/datamodel.rst:2490
msgid "Notes on using *__slots__*:"
msgstr "Примечания по использованию *__slots__*:"

#: ../../reference/datamodel.rst:2492
msgid ""
"When inheriting from a class without *__slots__*, the :attr:`~object."
"__dict__` and *__weakref__* attribute of the instances will always be "
"accessible."
msgstr ""
"При наследовании от класса без *__slots__* атрибуты экземпляров :attr:"
"`~object.__dict__` и *__weakref__* всегда будут доступны."

#: ../../reference/datamodel.rst:2496
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"Без переменной :attr:`~object.__dict__` экземплярам нельзя назначить новые "
"переменные, не перечисленные в определении *__slots__*. Попытки назначить "
"имя переменной, не указанной в списке, вызывают ошибку :exc:"
"`AttributeError`. Если требуется динамическое присвоение новых переменных, "
"добавьте ``'__dict__'`` к последовательности строк в объявлении *__slots__*."

#: ../../reference/datamodel.rst:2503
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Без переменной *__weakref__* для каждого экземпляра классы, определяющие "
"*__slots__*, не поддерживают :mod:`слабые ссылки <weakref>` на свои "
"экземпляры. Если необходима поддержка слабых ссылок, добавьте "
"``'__weakref__'`` к последовательности строк в объявлении *__slots__*."

#: ../../reference/datamodel.rst:2509
msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"*__slots__* реализуются на уровне класса путем создания :ref:`дескрипторов "
"<дескрипторы>` для каждого имени переменной. В результате атрибуты класса "
"нельзя использовать для установки значений по умолчанию для переменных "
"экземпляра, определенных *__slots__*; в противном случае атрибут класса "
"перезапишет назначение дескриптора."

#: ../../reference/datamodel.rst:2515
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, instances of a child subclass will get a :attr:`~object.__dict__` "
"and *__weakref__* unless the subclass also defines *__slots__* (which should "
"only contain names of any *additional* slots)."
msgstr ""
"Действие объявления *__slots__* не ограничивается классом, в котором оно "
"определено. *__slots__*, объявленные в родителях, доступны в дочерних "
"классах. Однако экземпляры дочернего подкласса получат :attr:`~object."
"__dict__` и *__weakref__*, если только подкласс также не определяет "
"*__slots__* (который должен содержать только имена любых *дополнительных* "
"слотов)."

#: ../../reference/datamodel.rst:2521
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Если класс определяет слот, также определенный в базовом классе, переменная "
"экземпляра, определенная слотом базового класса, недоступна (кроме случаев "
"получения ее дескриптора непосредственно из базового класса). Это делает "
"смысл программы неопределенным. В будущем может быть добавлена ​​проверка, "
"предотвращающая это."

#: ../../reference/datamodel.rst:2526
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and :class:"
"`tuple`."
msgstr ""
":exc:`TypeError` будет вызываться, если для класса, производного от :c:"
"member:`\"variable-length\" встроенного типа <PyTypeObject.tp_itemsize>`, "
"например :class:`int, определены непустые *__slots__* `, :class:`bytes` и :"
"class:`tuple`."

#: ../../reference/datamodel.rst:2531
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr "Любой нестроковый :term:`iterable` может быть присвоен *__slots__*."

#: ../../reference/datamodel.rst:2533
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised by :"
"func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"Если для назначения *__slots__* используется :class:`dictionary <dict>`, в "
"качестве имен слотов будут использоваться ключи словаря. Значения словаря "
"можно использовать для предоставления строк документации для каждого "
"атрибута, которые будут распознаваться :func:`inspect.getdoc` и отображаться "
"в выводе :func:`help`."

#: ../../reference/datamodel.rst:2538
msgid ""
":attr:`~object.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""
":attr:`~object.__class__` назначение работает, только если оба класса имеют "
"одинаковые *__slots__*."

#: ../../reference/datamodel.rst:2541
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
":ref:`Множественное наследование <tut-multiple>` с несколькими родительскими "
"классами с слотами может использоваться, но только одному родителю разрешено "
"иметь атрибуты, созданные слотами (другие базы должны иметь пустые макеты "
"слотов) - нарушения вызывают :exc:` ТипОшибка`."

#: ../../reference/datamodel.rst:2547
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"Если :term:`итератор` используется для *__slots__*, то :term:`дескриптор` "
"создается для каждого значения итератора. Однако атрибут *__slots__* будет "
"пустым итератором."

#: ../../reference/datamodel.rst:2555
msgid "Customizing class creation"
msgstr "Настройка создания классов"

#: ../../reference/datamodel.rst:2557
msgid ""
"Whenever a class inherits from another class, :meth:`~object."
"__init_subclass__` is called on the parent class. This way, it is possible "
"to write classes which change the behavior of subclasses. This is closely "
"related to class decorators, but where class decorators only affect the "
"specific class they're applied to, ``__init_subclass__`` solely applies to "
"future subclasses of the class defining the method."
msgstr ""
"Всякий раз, когда класс наследует от другого класса, в родительском классе "
"вызывается :meth:`~object.__init_subclass__`. Таким образом, можно писать "
"классы, которые изменяют поведение подклассов. Это тесно связано с "
"декораторами классов, но если декораторы классов влияют только на конкретный "
"класс, к которому они применяются, ``__init_subclass__`` применяется "
"исключительно к будущим подклассам класса, определяющего метод."

#: ../../reference/datamodel.rst:2566
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Этот метод вызывается всякий раз, когда содержащий его класс является "
"подклассом. *cls* — это новый подкласс. Если этот метод определен как "
"обычный метод экземпляра, он неявно преобразуется в метод класса."

#: ../../reference/datamodel.rst:2570
msgid ""
"Keyword arguments which are given to a new class are passed to the parent "
"class's ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"Аргументы ключевого слова, которые передаются новому классу, передаются в "
"``__init_subclass__`` родительского класса. Для совместимости с другими "
"классами, использующими ``__init_subclass__``, следует удалить необходимые "
"аргументы ключевого слова и передать остальные базовому классу, как в:"

#: ../../reference/datamodel.rst:2576
msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"

#: ../../reference/datamodel.rst:2584
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"Реализация по умолчанию ``object.__init_subclass__`` ничего не делает, но "
"вызывает ошибку, если она вызывается с какими-либо аргументами."

#: ../../reference/datamodel.rst:2589
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"Подсказка метакласса ``metaclass`` используется остальной частью механизма "
"типов и никогда не передается реализациям ``__init_subclass__``. Фактический "
"метакласс (а не явная подсказка) доступен как ``type(cls)``."

#: ../../reference/datamodel.rst:2597
msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""
"Когда класс создается, :meth:`type.__new__` сканирует переменные класса и "
"выполняет обратные вызовы к переменным, имеющим крючок :meth:`~object."
"__set_name__`."

#: ../../reference/datamodel.rst:2602
msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"Автоматически вызывается во время создания класса-владельца *owner*. Объекту "
"присвоено *name* в этом классе::"

#: ../../reference/datamodel.rst:2605
msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"

#: ../../reference/datamodel.rst:2608
msgid ""
"If the class variable is assigned after the class is created, :meth:"
"`__set_name__` will not be called automatically. If needed, :meth:"
"`__set_name__` can be called directly::"
msgstr ""
"Если переменная класса назначена после создания класса, :meth:`__set_name__` "
"не будет вызываться автоматически. При необходимости :meth:`__set_name__` "
"можно вызвать напрямую::"

#: ../../reference/datamodel.rst:2612
msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"

#: ../../reference/datamodel.rst:2619
msgid "See :ref:`class-object-creation` for more details."
msgstr "Подробнее см. :ref:`class-object-creation`."

#: ../../reference/datamodel.rst:2627
msgid "Metaclasses"
msgstr "Метаклассы"

#: ../../reference/datamodel.rst:2634
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"По умолчанию классы создаются с использованием :func:`type`. Тело класса "
"выполняется в новом пространстве имен, а имя класса локально привязывается к "
"результату ``type(name, bases, namespace)``."

#: ../../reference/datamodel.rst:2638
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"Процесс создания класса можно настроить, передав аргумент ключевого слова "
"``metaclass`` в строке определения класса или унаследовав его от "
"существующего класса, который включает такой аргумент. В следующем примере и "
"MyClass, и MySubclass являются экземплярами Meta::"

#: ../../reference/datamodel.rst:2643
msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"

#: ../../reference/datamodel.rst:2652
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Любые другие аргументы ключевого слова, указанные в определении класса, "
"передаются всем операциям метакласса, описанным ниже."

#: ../../reference/datamodel.rst:2655
msgid "When a class definition is executed, the following steps occur:"
msgstr "При выполнении определения класса происходят следующие шаги:"

#: ../../reference/datamodel.rst:2657
msgid "MRO entries are resolved;"
msgstr "Записи MRO разрешены;"

#: ../../reference/datamodel.rst:2658
msgid "the appropriate metaclass is determined;"
msgstr "определяется соответствующий метакласс;"

#: ../../reference/datamodel.rst:2659
msgid "the class namespace is prepared;"
msgstr "пространство имен класса подготовлено;"

#: ../../reference/datamodel.rst:2660
msgid "the class body is executed;"
msgstr "тело класса выполняется;"

#: ../../reference/datamodel.rst:2661
msgid "the class object is created."
msgstr "создается объект класса."

#: ../../reference/datamodel.rst:2665
msgid "Resolving MRO entries"
msgstr "Разрешение ввода данных MRO"

#: ../../reference/datamodel.rst:2669
msgid ""
"If a base that appears in a class definition is not an instance of :class:"
"`type`, then an :meth:`!__mro_entries__` method is searched on the base. If "
"an :meth:`!__mro_entries__` method is found, the base is substituted with "
"the result of a call to :meth:`!__mro_entries__` when creating the class. "
"The method is called with the original bases tuple passed to the *bases* "
"parameter, and must return a tuple of classes that will be used instead of "
"the base. The returned tuple may be empty: in these cases, the original base "
"is ignored."
msgstr ""
"Если база, которая появляется в определении класса, не является экземпляром :"
"class:`type`, то по базе ищется метод :meth:`!__mro_entries__`. Если найден "
"метод :meth:`!__mro_entries__`, база заменяется результатом вызова :meth:`!"
"__mro_entries__` при создании класса. Метод вызывается с исходным кортежем "
"баз, переданным в параметр *bases*, и должен возвращать кортеж классов, "
"которые будут использоваться вместо базы. Возвращенный кортеж может быть "
"пустым: в этих случаях исходная база игнорируется."

#: ../../reference/datamodel.rst:2680
msgid ":func:`types.resolve_bases`"
msgstr ":func:`types.resolve_bases`"

#: ../../reference/datamodel.rst:2681
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr ""
"Динамически разрешать базы, которые не являются экземплярами :class:`type`."

#: ../../reference/datamodel.rst:2683
msgid ":func:`types.get_original_bases`"
msgstr ":func:`types.get_original_bases`"

#: ../../reference/datamodel.rst:2684
msgid ""
"Retrieve a class's \"original bases\" prior to modifications by :meth:"
"`~object.__mro_entries__`."
msgstr ""
"Получите «исходные основы» класса до внесения изменений с помощью :meth:"
"`~object.__mro_entries__`."

#: ../../reference/datamodel.rst:2687
msgid ":pep:`560`"
msgstr ":pep:`560`"

#: ../../reference/datamodel.rst:2688
msgid "Core support for typing module and generic types."
msgstr "Базовая поддержка модуля типизации и универсальных типов."

#: ../../reference/datamodel.rst:2692
msgid "Determining the appropriate metaclass"
msgstr "Определение соответствующего метакласса"

#: ../../reference/datamodel.rst:2696
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr ""
"Соответствующий метакласс для определения класса определяется следующим "
"образом:"

#: ../../reference/datamodel.rst:2698
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"если не указаны ни базы, ни явный метакласс, то используется :func:`type`;"

#: ../../reference/datamodel.rst:2699
msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr ""
"если указан явный метакласс и он *не* является экземпляром :func:`type`, то "
"он используется непосредственно как метакласс;"

#: ../../reference/datamodel.rst:2701
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"если экземпляр :func:`type` задан как явный метакласс или определены базы, "
"то используется наиболее производный метакласс."

#: ../../reference/datamodel.rst:2704
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"Самый производный метакласс выбирается из явно указанного метакласса (если "
"таковой имеется) и метаклассов (т.е. ``type(cls)``) всех указанных базовых "
"классов. Наиболее производным метаклассом является тот, который является "
"подтипом *всех* этих метаклассов-кандидатов. Если ни один из метаклассов-"
"кандидатов не соответствует этому критерию, то определение класса завершится "
"с ошибкой TypeError."

#: ../../reference/datamodel.rst:2714
msgid "Preparing the class namespace"
msgstr "Подготовка пространства имен класса"

#: ../../reference/datamodel.rst:2719
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"После того как соответствующий метакласс определен, подготавливается "
"пространство имен класса. Если метакласс имеет атрибут ``__prepare__``, он "
"называется ``namespace = метакласс.__prepare__(name, bases, **kwds)`` (где "
"дополнительные аргументы ключевого слова, если таковые имеются, берутся из "
"определения класса) . Метод ``__prepare__`` должен быть реализован как :func:"
"`classmethod <classmethod>`. Пространство имен, возвращаемое "
"``__prepare__``, передается в ``__new__``, но когда создается конечный "
"объект класса, пространство имен копируется в новый ``dict``."

#: ../../reference/datamodel.rst:2728
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Если метакласс не имеет атрибута ``__prepare__``, то пространство имен "
"класса инициализируется как пустое упорядоченное отображение."

#: ../../reference/datamodel.rst:2733
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метаклассы в Python 3000"

#: ../../reference/datamodel.rst:2734
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Представлен хук пространства имен ``__prepare__``."

#: ../../reference/datamodel.rst:2738
msgid "Executing the class body"
msgstr "Выполнение тела класса"

#: ../../reference/datamodel.rst:2743
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"Тело класса выполняется (приблизительно) как ``exec(body, globals(), "
"namespace)``. Ключевое отличие от обычного вызова :func:`exec` заключается в "
"том, что лексическая область видимости позволяет телу класса (включая любые "
"методы) ссылаться на имена из текущей и внешней областей видимости, когда "
"определение класса происходит внутри функции."

#: ../../reference/datamodel.rst:2749
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"Однако даже если определение класса происходит внутри функции, методы, "
"определенные внутри класса, по-прежнему не могут видеть имена, определенные "
"в области видимости класса. Доступ к переменным класса должен осуществляться "
"через первый параметр экземпляра или методов класса или через неявную ссылку "
"с лексической областью ``__class__``, описанную в следующем разделе."

#: ../../reference/datamodel.rst:2758
msgid "Creating the class object"
msgstr "Создание объекта класса"

#: ../../reference/datamodel.rst:2765
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"После того, как пространство имен класса заполнено путем выполнения тела "
"класса, объект класса создается путем вызова ``metaclass(name, bases, "
"namespace, **kwds)`` (дополнительные ключевые слова, передаваемые здесь, "
"такие же, как те, которые передаются в `` `__prepare__``)."

#: ../../reference/datamodel.rst:2770
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"Именно на этот объект класса будет ссылаться форма :func:`super` с нулевым "
"аргументом. ``__class__`` — это неявная ссылка на замыкание, создаваемая "
"компилятором, если какие-либо методы в теле класса ссылаются либо на "
"``__class__``, либо на ``super``. Это позволяет форме :func:`super` с "
"нулевым аргументом правильно идентифицировать определяемый класс на основе "
"лексической области видимости, в то время как класс или экземпляр, который "
"использовался для выполнения текущего вызова, идентифицируется на основе "
"первого аргумента, переданного методу."

#: ../../reference/datamodel.rst:2780
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"В CPython 3.6 и более поздних версиях ячейка __class__ передается метаклассу "
"как запись __classcell__ в пространстве имен класса. Если он присутствует, "
"он должен быть передан до вызова ``type.__new__``, чтобы класс был правильно "
"инициализирован. Если этого не сделать, в Python 3.8 возникнет ошибка :exc:"
"`RuntimeError`."

#: ../../reference/datamodel.rst:2786
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"При использовании метакласса по умолчанию :class:`type` или любого "
"метакласса, который в конечном итоге вызывает ``type.__new__``, после "
"создания объекта класса вызываются следующие дополнительные шаги настройки:"

#: ../../reference/datamodel.rst:2790
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"Метод ``type.__new__`` собирает все атрибуты в пространстве имен класса, "
"которые определяют метод :meth:`~object.__set_name__`;"

#: ../../reference/datamodel.rst:2792
msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"Эти методы ``__set_name__`` вызываются с указанием определяемого класса и "
"присвоенного имени этого конкретного атрибута;"

#: ../../reference/datamodel.rst:2794
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ""
"Эти методы ``__set_name__`` вызываются с указанием определяемого класса и "
"присвоенного имени этого конкретного атрибута;"

#: ../../reference/datamodel.rst:2797
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"После создания объекта класса он передается декораторам класса, включенным в "
"определение класса (если таковые имеются), и полученный объект привязывается "
"в локальном пространстве имен как определенный класс."

#: ../../reference/datamodel.rst:2801
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~type.__dict__` attribute of the class object."
msgstr ""
"Когда новый класс создается с помощью ``type.__new__``, объект, указанный в "
"качестве параметра пространства имен, копируется в новое упорядоченное "
"отображение, а исходный объект удаляется. Новая копия помещается в прокси-"
"сервер, доступный только для чтения, который становится атрибутом :attr:"
"`~type.__dict__` объекта класса."

#: ../../reference/datamodel.rst:2808
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - Новый супер"

#: ../../reference/datamodel.rst:2809
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "Описывает неявную ссылку закрытия ``__class__``."

#: ../../reference/datamodel.rst:2813
msgid "Uses for metaclasses"
msgstr "Использование метаклассов"

#: ../../reference/datamodel.rst:2815
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"Потенциальные возможности использования метаклассов безграничны. Некоторые "
"идеи, которые были исследованы, включают перечисление, ведение журнала, "
"проверку интерфейса, автоматическое делегирование, автоматическое создание "
"свойств, прокси, платформы и автоматическую блокировку/синхронизацию "
"ресурсов."

#: ../../reference/datamodel.rst:2822
msgid "Customizing instance and subclass checks"
msgstr "Настройка проверок экземпляров и подклассов"

#: ../../reference/datamodel.rst:2824
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Следующие методы используются для переопределения поведения по умолчанию "
"встроенных функций :func:`isinstance` и :func:`issubclass`."

#: ../../reference/datamodel.rst:2827
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"В частности, метакласс :class:`abc.ABCMeta` реализует эти методы, чтобы "
"разрешить добавление абстрактных базовых классов (ABC) в качестве "
"«виртуальных базовых классов» к любому классу или типу (включая встроенные "
"типы), включая другие. Азбука."

#: ../../reference/datamodel.rst:2834
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Возвращайте true, если *instance* следует считать (прямым или косвенным) "
"экземпляром *class*. Если определено, вызывается для реализации "
"isinstance(instance, class)``."

#: ../../reference/datamodel.rst:2841
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"Возвращайте true, если *subclass* следует считать (прямым или косвенным) "
"подклассом *class*. Если определено, вызывается для реализации "
"issubclass(subclass, class)``."

#: ../../reference/datamodel.rst:2846
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Обратите внимание, что эти методы ищутся по типу (метаклассу) класса. Их "
"нельзя определить как методы класса в реальном классе. Это соответствует "
"поиску специальных методов, вызываемых экземплярами, только в этом случае "
"экземпляр сам по себе является классом."

#: ../../reference/datamodel.rst:2853
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Знакомство с абстрактными базовыми классами"

#: ../../reference/datamodel.rst:2854
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~type.__instancecheck__` and :meth:"
"`~type.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"Включает спецификацию для настройки поведения :func:`isinstance` и :func:"
"`issubclass` посредством :meth:`~type.__instancecheck__` и :meth:`~type."
"__subclasscheck__`, с мотивацией для этой функциональности в контексте "
"добавления Абстрактные базовые классы (см. модуль :mod:`abc`) для языка."

#: ../../reference/datamodel.rst:2862
msgid "Emulating generic types"
msgstr "Эмуляция универсальных типов"

#: ../../reference/datamodel.rst:2864
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"При использовании :term:`type annotations<annotation>` часто бывает полезно "
"*параметризировать* :term:`generic type`, используя нотацию Python в "
"квадратных скобках. Например, аннотация ``list[int]`` может использоваться "
"для обозначения :class:`list`, в котором все элементы имеют тип :class:`int`."

#: ../../reference/datamodel.rst:2871
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Тип подсказка"

#: ../../reference/datamodel.rst:2872
msgid "Introducing Python's framework for type annotations"
msgstr "Знакомство с инфраструктурой Python для аннотаций типов"

#: ../../reference/datamodel.rst:2874
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Generic Alias Types<types-genericalias>`"

#: ../../reference/datamodel.rst:2875
msgid "Documentation for objects representing parameterized generic classes"
msgstr ""
"Документация для объектов, представляющих параметризованные универсальные "
"классы"

#: ../../reference/datamodel.rst:2877
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`определяемые пользователем дженерики<user-defined-"
"generics>` и :class:`typing.Generic`"

#: ../../reference/datamodel.rst:2878
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."

#: ../../reference/datamodel.rst:2881
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""
"Класс *обычно* может быть параметризован только в том случае, если он "
"определяет специальный метод класса ``__class_getitem__()``."

#: ../../reference/datamodel.rst:2886
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Возвращает объект, представляющий специализацию универсального класса по "
"аргументам типа, найденным в *key*."

#: ../../reference/datamodel.rst:2889
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with :func:"
"`@classmethod<classmethod>` when it is defined."
msgstr ""
"При определении в классе ``__class_getitem__()`` автоматически становится "
"методом класса. Таким образом, нет необходимости украшать его :func:"
"`@classmethod<classmethod>` при его определении."

#: ../../reference/datamodel.rst:2895
msgid "The purpose of *__class_getitem__*"
msgstr "Цель *__class_getitem__*"

#: ../../reference/datamodel.rst:2897
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""
"Цель :meth:`~object.__class_getitem__` — разрешить параметризацию во время "
"выполнения универсальных классов стандартной библиотеки, чтобы легче "
"применять :term:`typehints<typehint>` к этим классам."

#: ../../reference/datamodel.rst:2901
msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already implements :meth:`~object."
"__class_getitem__`, or inherit from :class:`typing.Generic`, which has its "
"own implementation of ``__class_getitem__()``."
msgstr ""
"Чтобы реализовать пользовательские универсальные классы, которые можно "
"параметризовать во время выполнения и понять с помощью статических средств "
"проверки типов, пользователи должны либо наследовать от класса стандартной "
"библиотеки, который уже реализует :meth:`~object.__class_getitem__`, либо "
"наследовать от :class:`typing. Generic, который имеет собственную реализацию "
"__class_getitem__()."

#: ../../reference/datamodel.rst:2907
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
"Пользовательские реализации :meth:`~object.__class_getitem__` для классов, "
"определенных вне стандартной библиотеки, могут быть не поняты сторонними "
"средствами проверки типов, такими как mypy. Использование "
"``__class_getitem__()`` в любом классе для целей, отличных от подсказки "
"типа, не рекомендуется."

#: ../../reference/datamodel.rst:2917
msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* versus *__getitem__*"

#: ../../reference/datamodel.rst:2919
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"Обычно :ref:`subscription<subscriptions>` объекта, использующего квадратные "
"скобки, вызывает метод экземпляра :meth:`~object.__getitem__`, определенный "
"в классе объекта. Однако, если подписываемый объект сам является классом, "
"вместо этого может быть вызван метод класса :meth:`~object."
"__class_getitem__`. ``__class_getitem__()`` должен возвращать объект :ref:"
"`GenericAlias<types-genericalias>`, если он правильно определен."

#: ../../reference/datamodel.rst:2926
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether :meth:"
"`~object.__getitem__` or :meth:`~object.__class_getitem__` should be called::"
msgstr ""
"Представленный с помощью :term:`expression` ``obj[x]``, интерпретатор Python "
"следует примерно следующему процессу, чтобы решить, следует ли использовать :"
"meth:`~object.__getitem__` или :meth:`~object.__class_getitem__` называться::"

#: ../../reference/datamodel.rst:2931
msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"

#: ../../reference/datamodel.rst:2954
msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not define :"
"meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``, "
"``dict[str, float]`` and ``tuple[str, bytes]`` all result in :meth:`~object."
"__class_getitem__` being called::"
msgstr ""
"В Python все классы сами являются экземплярами других классов. Класс класса "
"известен как :term:`метакласс` этого класса, и большинство классов имеют "
"класс :class:`type` в качестве метакласса. :class:`type` не определяет :meth:"
"`~object.__getitem__`, а это означает, что такие выражения, как "
"``list[int]``, ``dict[str, float]`` и ``tuple[str, bytes]`` все приводит к "
"вызову :meth:`~object.__class_getitem__`::"

#: ../../reference/datamodel.rst:2961
msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"

#: ../../reference/datamodel.rst:2973
msgid ""
"However, if a class has a custom metaclass that defines :meth:`~object."
"__getitem__`, subscribing the class may result in different behaviour. An "
"example of this can be found in the :mod:`enum` module::"
msgstr ""
"Однако если класс имеет собственный метакласс, определяющий :meth:`~object."
"__getitem__`, подписка на класс может привести к другому поведению. Пример "
"этого можно найти в модуле :mod:`enum`::"

#: ../../reference/datamodel.rst:2977
msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"

#: ../../reference/datamodel.rst:2996
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ":pep:`560` - Базовая поддержка модуля ввода и универсальных типов."

#: ../../reference/datamodel.rst:2997
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a :ref:"
"`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""
"Представляем :meth:`~object.__class_getitem__` и поясняем, когда :ref:"
"`subscription<subscriptions>` приводит к вызову ``__class_getitem__()`` "
"вместо :meth:`~object.__getitem__`"

#: ../../reference/datamodel.rst:3005
msgid "Emulating callable objects"
msgstr "Эмуляция вызываемых объектов"

#: ../../reference/datamodel.rst:3012
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``. The :class:`object` class itself does not provide this method."
msgstr ""
"Вызывается, когда экземпляр «вызывается» как функция; если этот метод "
"определен, ``x(arg1, arg2, ...)`` примерно переводится как ``type(x)."
"__call__(x, arg1, ...)``. Сам класс :class:`object` не предоставляет этот "
"метод."

#: ../../reference/datamodel.rst:3020
msgid "Emulating container types"
msgstr "Эмуляция типов контейнеров"

#: ../../reference/datamodel.rst:3022
msgid ""
"The following methods can be defined to implement container objects. None of "
"them are provided by the :class:`object` class itself. Containers usually "
"are :term:`sequences <sequence>` (such as :class:`lists <list>` or :class:"
"`tuples <tuple>`) or :term:`mappings <mapping>` (like :term:`dictionaries "
"<dictionary>`), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or :"
"class:`slice` objects, which define a range of items.  It is also "
"recommended that mappings provide the methods :meth:`!keys`, :meth:`!"
"values`, :meth:`!items`, :meth:`!get`, :meth:`!clear`, :meth:`!setdefault`, :"
"meth:`!pop`, :meth:`!popitem`, :meth:`!copy`, and :meth:`!update` behaving "
"similar to those for Python's standard :class:`dictionary <dict>` objects.  "
"The :mod:`collections.abc` module provides a :class:`~collections.abc."
"MutableMapping` :term:`abstract base class` to help create those methods "
"from a base set of :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`!keys`. Mutable "
"sequences should provide methods :meth:`!append`, :meth:`!count`, :meth:`!"
"index`, :meth:`!extend`, :meth:`!insert`, :meth:`!pop`, :meth:`!remove`, :"
"meth:`!reverse` and :meth:`!sort`, like Python standard :class:`list` "
"objects. Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:`~object."
"__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` and :meth:"
"`~object.__imul__` described below; they should not define other numerical "
"operators.  It is recommended that both mappings and sequences implement "
"the :meth:`~object.__contains__` method to allow efficient use of the ``in`` "
"operator; for mappings, ``in`` should search the mapping's keys; for "
"sequences, it should search through the values.  It is further recommended "
"that both mappings and sequences implement the :meth:`~object.__iter__` "
"method to allow efficient iteration through the container; for mappings, :"
"meth:`!__iter__` should iterate through the object's keys; for sequences, it "
"should iterate through the values."
msgstr ""
"Для реализации объектов-контейнеров можно определить следующие методы. Ни "
"один из них не предоставляется самим классом :class:`object`. Контейнерами "
"обычно являются :term:`sequences <sequence>` (например, :class:`lists "
"<list>` или :class:`tuples <tuple>`) или :term:`mappings <mapping>` "
"(например, :term: `dictionaries <dictionary>`), но может представлять и "
"другие контейнеры. Первый набор методов используется либо для эмуляции "
"последовательности, либо для эмуляции отображения; разница в том, что для "
"последовательности допустимыми ключами должны быть целые числа *k*, для "
"которых ``0 <= k < N``, где *N* – длина последовательности, или объекты :"
"class:`slice`, которые определяют диапазон элементов. Также рекомендуется, "
"чтобы сопоставления предоставляли методы :meth:`!keys`, :meth:`!values`, :"
"meth:`!items`, :meth:`!get`, :meth:`!clear`, : meth:`!setdefault`, :meth:`!"
"pop`, :meth:`!popitem`, :meth:`!copy` и :meth:`!update` ведут себя "
"аналогично стандартному :class:` Python. словарь <dict>` объекты. Модуль :"
"mod:`collections.abc` предоставляет :class:`~collections.abc."
"MutableMapping` :term:`абстрактный базовый класс`, который помогает "
"создавать эти методы из базового набора :meth:`~object.__getitem__` , :meth:"
"`~object.__setitem__`, :meth:`~object.__delitem__` и :meth:`!keys`. "
"Изменяемые последовательности должны предоставлять методы :meth:`!append`, :"
"meth:`!count`, :meth:`!index`, :meth:`!extend`, :meth:`!insert`, :meth:`! "
"pop`, :meth:`!remove`, :meth:`!reverse` и :meth:`!sort`, как стандартные "
"объекты Python :class:`list`. Наконец, типы последовательностей должны "
"реализовывать сложение (то есть конкатенацию) и умножение (то есть "
"повторение) путем определения методов :meth:`~object.__add__`, :meth:"
"`~object.__radd__`, :meth:`~object.__iadd__` , :meth:`~object.__mul__`, :"
"meth:`~object.__rmul__` и :meth:`~object.__imul__`, описанные ниже; они не "
"должны определять другие числовые операторы. Рекомендуется, чтобы и "
"отображения, и последовательности реализовывали метод :meth:`~object."
"__contains__`, чтобы обеспечить эффективное использование оператора ``in``; "
"для сопоставлений ``in`` должен искать ключи сопоставления; для "
"последовательностей он должен искать значения. Кроме того, рекомендуется, "
"чтобы и отображения, и последовательности реализовывали метод :meth:`~object."
"__iter__`, чтобы обеспечить эффективную итерацию по контейнеру; для "
"сопоставлений :meth:`!__iter__` должен перебирать ключи объекта; для "
"последовательностей он должен перебирать значения."

#: ../../reference/datamodel.rst:3064
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`~object.__bool__` method and whose :meth:`!__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""
"Вызывается для реализации встроенной функции :func:`len`. Должен возвращать "
"длину объекта, целое число ``>=`` 0. Кроме того, объект, который не "
"определяет метод :meth:`~object.__bool__` и чей метод :meth:`!__len__` "
"возвращает ноль. считается ложным в логическом контексте."

#: ../../reference/datamodel.rst:3071
msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If the "
"length is larger than :data:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`~object.__bool__` method."
msgstr ""
"В CPython длина должна быть не более :data:`sys.maxsize`. Если длина "
"превышает :data:`!sys.maxsize`, некоторые функции (например, :func:`len`) "
"могут вызвать :exc:`OverflowError`. Чтобы предотвратить возникновение :exc:`!"
"OverflowError` при проверке значения истинности, объект должен определить "
"метод :meth:`~object.__bool__`."

#: ../../reference/datamodel.rst:3080
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :data:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""
"Вызывается для реализации :func:`operator.length_hint`. Должен возвращать "
"предполагаемую длину объекта (которая может быть больше или меньше "
"фактической длины). Длина должна быть целым числом ``>=`` 0. Возвращаемое "
"значение также может быть :data:`NotImplemented`, что обрабатывается так же, "
"как если бы метод ``__length_hint__`` вообще не существовал. Этот метод "
"является чисто оптимизацией и никогда не требуется для корректности."

#: ../../reference/datamodel.rst:3094
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""
"Нарезка производится исключительно следующими тремя методами. Вызов типа:::"

#: ../../reference/datamodel.rst:3096
msgid "a[1:2] = b"
msgstr "a[1:2] = b"

#: ../../reference/datamodel.rst:3098
msgid "is translated to ::"
msgstr "переводится на::"

#: ../../reference/datamodel.rst:3100
msgid "a[slice(1, 2, None)] = b"
msgstr "a[slice(1, 2, None)] = b"

#: ../../reference/datamodel.rst:3102
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr ""
"и так далее. Отсутствующие элементы фрагмента всегда заполняются значением "
"«Нет»."

#: ../../reference/datamodel.rst:3107
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers. Optionally, they may support :class:"
"`slice` objects as well.  Negative index support is also optional. If *key* "
"is of an inappropriate type, :exc:`TypeError` may be raised; if *key* is a "
"value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For :"
"term:`mapping` types, if *key* is missing (not in the container), :exc:"
"`KeyError` should be raised."
msgstr ""
"Вызывается для реализации оценки ``self[key]``. Для типов :term:`sequence` "
"принимаемые ключи должны быть целыми числами. При желании они также могут "
"поддерживать объекты :class:`slice`. Поддержка отрицательного индекса также "
"не является обязательной. Если *key* имеет неподходящий тип, может "
"возникнуть :exc:`TypeError`; если *key* является значением вне набора "
"индексов для последовательности (после любой специальной интерпретации "
"отрицательных значений), должно быть вызвано :exc:`IndexError`. Для типов :"
"term:`mapping`, если *key* отсутствует (не в контейнере), должно быть "
"вызвано :exc:`KeyError`."

#: ../../reference/datamodel.rst:3119
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
"Циклы :keyword:`for` ожидают, что для недопустимых индексов будет выдана "
"ошибка :exc:`IndexError`, чтобы обеспечить правильное обнаружение конца "
"последовательности."

#: ../../reference/datamodel.rst:3124
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method :"
"meth:`~object.__class_getitem__` may be called instead of ``__getitem__()``. "
"See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"При :ref:`subscripting<subscriptions>` *классе* вместо ``__getitem__()`` "
"может быть вызван специальный метод класса :meth:`~object."
"__class_getitem__`. Подробнее см. :ref:`classgetitem-versus-getitem`."

#: ../../reference/datamodel.rst:3132
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Вызывается для реализации присвоения ``self[key]``. То же примечание, что и "
"для :meth:`__getitem__`. Это следует реализовывать только для сопоставлений, "
"если объекты поддерживают изменения значений ключей или если можно добавлять "
"новые ключи, или для последовательностей, если элементы можно заменять. Для "
"неправильных значений *key* должны быть созданы те же исключения, что и для "
"метода :meth:`__getitem__`."

#: ../../reference/datamodel.rst:3141
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"Вызывается для реализации удаления ``self[key]``. То же примечание, что и "
"для :meth:`__getitem__`. Это следует реализовывать только для сопоставлений, "
"если объекты поддерживают удаление ключей, или для последовательностей, если "
"элементы можно удалять из последовательности. Для неправильных значений "
"*key* должны быть созданы те же исключения, что и для метода :meth:"
"`__getitem__`."

#: ../../reference/datamodel.rst:3150
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"Вызывается :class:`dict`\\ .\\ :meth:`__getitem__` для реализации "
"``self[key]`` для подклассов dict, когда ключ отсутствует в словаре."

#: ../../reference/datamodel.rst:3156
msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"Этот метод вызывается, когда для контейнера требуется :term:`итератор`. Этот "
"метод должен возвращать новый объект-итератор, который может перебирать все "
"объекты в контейнере. Для сопоставлений он должен перебирать ключи "
"контейнера."

#: ../../reference/datamodel.rst:3164
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Вызывается (если присутствует) встроенной функцией :func:`reversed` для "
"реализации обратной итерации. Он должен вернуть новый объект-итератор, "
"который перебирает все объекты в контейнере в обратном порядке."

#: ../../reference/datamodel.rst:3168
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
"Если метод :meth:`__reversed__` не указан, встроенная функция :func:"
"`reversed` вернется к использованию протокола последовательности (:meth:"
"`__len__` и :meth:`__getitem__`). Объекты, поддерживающие протокол "
"последовательности, должны предоставлять :meth:`__reversed__` только в том "
"случае, если они могут обеспечить более эффективную реализацию, чем та, "
"которая предоставляется :func:`reversed`."

#: ../../reference/datamodel.rst:3175
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Операторы проверки членства (:keyword:`in` и :keyword:`not in`) обычно "
"реализуются как итерация через контейнер. Однако объекты-контейнеры могут "
"предоставить следующий специальный метод с более эффективной реализацией, "
"которая также не требует, чтобы объект был итерируемым."

#: ../../reference/datamodel.rst:3182
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Вызывается для реализации операторов проверки членства. Должен возвращать "
"true, если *item* находится в *self*, в противном случае — false. Для "
"объектов сопоставления следует учитывать ключи сопоставления, а не значения "
"или пары ключ-элемент."

#: ../../reference/datamodel.rst:3186
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"Для объектов, которые не определяют :meth:`__contains__`, тест членства "
"сначала пытается выполнить итерацию через :meth:`__iter__`, затем старый "
"протокол итерации последовательности через :meth:`__getitem__`, см. :ref:"
"`этот раздел в ссылка на язык <membership-test-details>`."

#: ../../reference/datamodel.rst:3195
msgid "Emulating numeric types"
msgstr "Эмуляция числовых типов"

#: ../../reference/datamodel.rst:3197
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Следующие методы могут быть определены для эмуляции числовых объектов. "
"Методы, соответствующие операциям, которые не поддерживаются конкретным "
"типом чисел (например, побитовые операции для нецелых чисел), следует "
"оставить неопределенными."

#: ../../reference/datamodel.rst:3223
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to "
"evaluate the expression ``x + y``, where *x* is an instance of a class that "
"has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is called.  The :"
"meth:`__divmod__` method should be the equivalent to using :meth:"
"`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:"
"`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an "
"optional third argument if the ternary version of the built-in :func:`pow` "
"function is to be supported."
msgstr ""
"Эти методы вызываются для реализации двоичных арифметических операций "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, `` %``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^`` , ``|``). Например, чтобы "
"вычислить выражение ``x + y``, где *x* — это экземпляр класса, который имеет "
"метод :meth:`__add__`, ``type(x).__add__(x, y)` ` называется. Метод :meth:"
"`__divmod__` должен быть эквивалентен использованию :meth:`__floordiv__` и :"
"meth:`__mod__`; это не должно быть связано с :meth:`__truediv__`. Обратите "
"внимание, что :meth:`__pow__` должен быть определен так, чтобы принимать "
"необязательный третий аргумент, если должна поддерживаться троичная версия "
"встроенной функции :func:`pow`."

#: ../../reference/datamodel.rst:3234
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr ""
"Если один из этих методов не поддерживает операцию с предоставленными "
"аргументами, он должен вернуть :data:`NotImplemented`."

#: ../../reference/datamodel.rst:3257
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the left operand does not "
"support the corresponding operation [#]_ and the operands are of different "
"types. [#]_ For instance, to evaluate the expression ``x - y``, where *y* is "
"an instance of a class that has an :meth:`__rsub__` method, ``type(y)."
"__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` returns :data:"
"`NotImplemented`."
msgstr ""
"Эти методы вызываются для реализации двоичных арифметических операций "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, `` %``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^`` , ``|``) с отраженными "
"(поменянными местами) операндами. Эти функции вызываются только в том "
"случае, если левый операнд не поддерживает соответствующую операцию. [#]_ и "
"операнды имеют разные типы. [#]_ Например, чтобы вычислить выражение ``x - "
"y``, где *y* — это экземпляр класса, который имеет метод :meth:`__rsub__`, "
"``type(y).__rsub__(y, x)` ` вызывается, если ``type(x).__sub__(x, y)`` "
"возвращает :data:`NotImplemented`."

#: ../../reference/datamodel.rst:3269
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"Обратите внимание, что тернарная :func:`pow` не будет пытаться вызвать :meth:"
"`__rpow__` (правила приведения стали бы слишком сложными)."

#: ../../reference/datamodel.rst:3274
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Если тип правого операнда является подклассом типа левого операнда и этот "
"подкласс предоставляет другую реализацию отраженного метода для операции, "
"этот метод будет вызываться перед неотраженным методом левого операнда. "
"Такое поведение позволяет подклассам переопределять операции своих предков."

#: ../../reference/datamodel.rst:3295
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, or "
"if that method returns :data:`NotImplemented`, the augmented assignment "
"falls back to the normal methods.  For instance, if *x* is an instance of a "
"class with an :meth:`__iadd__` method, ``x += y`` is equivalent to ``x = x."
"__iadd__(y)`` . If :meth:`__iadd__` does not exist, or if ``x.__iadd__(y)`` "
"returns :data:`!NotImplemented`, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of the "
"data model."
msgstr ""
"Эти методы вызываются для реализации расширенных арифметических присваиваний "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``// =``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ` `|=``). Эти методы должны попытаться выполнить "
"операцию на месте (модифицируя *self*) и вернуть результат (который может "
"быть, но не обязательно, *self*). Если конкретный метод не определен или "
"если этот метод возвращает :data:`NotImplemented`, расширенное назначение "
"возвращается к обычным методам. Например, если *x* является экземпляром "
"класса с методом :meth:`__iadd__`, ``x += y`` эквивалентно ``x = x."
"__iadd__(y)`` . Если :meth:`__iadd__` не существует или если ``x."
"__iadd__(y)`` возвращает :data:`!NotImplemented`, ``x.__add__(y)`` и ``y."
"__radd__(x )`` рассматриваются так же, как и при вычислении ``x + y``. В "
"определенных ситуациях расширенное присваивание может привести к неожиданным "
"ошибкам (см. :ref:`faq-augmented-assignment-tuple-error`), но такое "
"поведение на самом деле является частью модели данных."

#: ../../reference/datamodel.rst:3318
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"Вызывается для реализации унарных арифметических операций (``-``, ``+``, :"
"func:`abs` и ``~``)."

#: ../../reference/datamodel.rst:3331
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Вызывается для реализации встроенных функций :func:`complex`, :func:`int` и :"
"func:`float`. Должен возвращать значение соответствующего типа."

#: ../../reference/datamodel.rst:3338
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Вызывается для реализации :func:`operator.index`, а также всякий раз, когда "
"Python необходимо преобразовать числовой объект без потерь в целочисленный "
"объект (например, при нарезке или во встроенных :func:`bin`, :func:`hex ` и :"
"func:`oct` функции). Наличие этого метода указывает на то, что числовой "
"объект имеет целочисленный тип. Должно возвращать целое число."

#: ../../reference/datamodel.rst:3344
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Если :meth:`__int__`, :meth:`__float__` и :meth:`__complex__` не определены, "
"то соответствующие встроенные функции :func:`int`, :func:`float` и :func:"
"`complex` вернитесь к :meth:`__index__`."

#: ../../reference/datamodel.rst:3356
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Вызывается для реализации встроенных функций :func:`round` и :mod:`math`, "
"функций :func:`~math.trunc`, :func:`~math.floor` и :func:`~math.ceil `. Если "
"в :meth:`!__round__` не передано *ndigits*, все эти методы должны возвращать "
"значение объекта, усеченное до :class:`~numbers.Integral` (обычно :class:"
"`int`)."

#: ../../reference/datamodel.rst:3362
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""
"Встроенная функция :func:`int` возвращается к :meth:`__trunc__`, если ни :"
"meth:`__int__`, ни :meth:`__index__` не определены."

#: ../../reference/datamodel.rst:3365
msgid "The delegation of :func:`int` to :meth:`__trunc__` is deprecated."
msgstr "Делегирование :func:`int` в :meth:`__trunc__` устарело."

#: ../../reference/datamodel.rst:3372
msgid "With Statement Context Managers"
msgstr "С менеджерами контекста операторов"

#: ../../reference/datamodel.rst:3374
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
":dfn:`контекстный менеджер` — это объект, который определяет контекст "
"времени выполнения, который должен быть установлен при выполнении оператора :"
"keyword:`with`. Менеджер контекста обрабатывает вход и выход из желаемого "
"контекста времени выполнения для выполнения блока кода. Менеджеры контекста "
"обычно вызываются с помощью оператора :keyword:`!with` (описанного в "
"разделе :ref:`with`), но их также можно использовать путем прямого вызова их "
"методов."

#: ../../reference/datamodel.rst:3385
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Типичное использование контекстных менеджеров включает сохранение и "
"восстановление различных видов глобального состояния, блокировку и "
"разблокировку ресурсов, закрытие открытых файлов и т. д."

#: ../../reference/datamodel.rst:3388
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`. "
"The :class:`object` class itself does not provide the context manager "
"methods."
msgstr ""
"Для получения дополнительной информации о менеджерах контекста см. :ref:"
"`typecontextmanager`. Сам класс :class:`object` не предоставляет методов "
"менеджера контекста."

#: ../../reference/datamodel.rst:3394
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Введите контекст времени выполнения, связанный с этим объектом. Оператор :"
"keyword:`with` свяжет возвращаемое значение этого метода с целью(ями), "
"указанными в предложении :keyword:`!as` оператора, если таковые имеются."

#: ../../reference/datamodel.rst:3401
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Выйдите из контекста времени выполнения, связанного с этим объектом. "
"Параметры описывают исключение, вызвавшее выход из контекста. Если выход из "
"контекста был выполнен без исключения, все три аргумента будут иметь "
"значение :const:`None`."

#: ../../reference/datamodel.rst:3405
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Если предоставлено исключение, и метод желает подавить исключение (т. е. "
"предотвратить его распространение), он должен вернуть истинное значение. В "
"противном случае исключение будет обработано обычным образом при выходе из "
"этого метода."

#: ../../reference/datamodel.rst:3409
msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
"Обратите внимание, что методы :meth:`~object.__exit__` не должны повторно "
"вызывать переданное исключение; это ответственность звонящего."

#: ../../reference/datamodel.rst:3415
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - Оператор \"with\""

#: ../../reference/datamodel.rst:3416
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Спецификация, предыстория и примеры оператора Python :keyword:`with`."

#: ../../reference/datamodel.rst:3423
msgid "Customizing positional arguments in class pattern matching"
msgstr "Настройка позиционных аргументов при сопоставлении шаблонов классов"

#: ../../reference/datamodel.rst:3425
msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""
"При использовании имени класса в шаблоне позиционные аргументы в шаблоне не "
"допускаются по умолчанию, т.е. ``case MyClass(x, y)`` обычно недействителен "
"без специальной поддержки в ``MyClass``. Чтобы иметь возможность "
"использовать такой шаблон, классу необходимо определить атрибут "
"*__match_args__*."

#: ../../reference/datamodel.rst:3432
msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"Этой переменной класса можно присвоить кортеж строк. Когда этот класс "
"используется в шаблоне класса с позиционными аргументами, каждый позиционный "
"аргумент будет преобразован в аргумент ключевого слова, используя "
"соответствующее значение в *__match_args__* в качестве ключевого слова. "
"Отсутствие этого атрибута эквивалентно установке для него значения ``()``."

#: ../../reference/datamodel.rst:3438
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a :"
"exc:`TypeError`."
msgstr ""
"Например, если ``MyClass.__match_args__`` равен ``(\"left\", \"center\", "
"\"right\")``, это означает, что ``case MyClass(x, y)`` эквивалентен ``case "
"MyClass (слева=x, центр=y)``. Обратите внимание, что количество аргументов в "
"шаблоне должно быть меньше или равно количеству элементов в "
"*__match_args__*; если оно больше, попытка сопоставления с образцом вызовет "
"ошибку :exc:`TypeError`."

#: ../../reference/datamodel.rst:3448
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - Сопоставление структурных шаблонов"

#: ../../reference/datamodel.rst:3449
msgid "The specification for the Python ``match`` statement."
msgstr "Спецификация оператора Python match."

#: ../../reference/datamodel.rst:3455
msgid "Emulating buffer types"
msgstr "Эмуляция типов буферов"

#: ../../reference/datamodel.rst:3457
msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python objects "
"to expose efficient access to a low-level memory array. This protocol is "
"implemented by builtin types such as :class:`bytes` and :class:`memoryview`, "
"and third-party libraries may define additional buffer types."
msgstr ""
":ref:`буферный протокол <bufferobjects>` предоставляет объектам Python "
"возможность предоставлять эффективный доступ к массиву памяти низкого "
"уровня. Этот протокол реализуется встроенными типами, такими как :class:"
"`bytes` и :class:`memoryview`, а сторонние библиотеки могут определять "
"дополнительные типы буферов."

#: ../../reference/datamodel.rst:3462
msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""
"Хотя типы буферов обычно реализуются на языке C, протокол также можно "
"реализовать на Python."

#: ../../reference/datamodel.rst:3467
msgid ""
"Called when a buffer is requested from *self* (for example, by the :class:"
"`memoryview` constructor). The *flags* argument is an integer representing "
"the kind of buffer requested, affecting for example whether the returned "
"buffer is read-only or writable. :class:`inspect.BufferFlags` provides a "
"convenient way to interpret the flags. The method must return a :class:"
"`memoryview` object."
msgstr ""
"Вызывается, когда буфер запрашивается у *self* (например, конструктором :"
"class:`memoryview`). Аргумент *flags* представляет собой целое число, "
"представляющее тип запрошенного буфера, влияющее, например, на то, доступен "
"ли возвращаемый буфер только для чтения или для записи. :class:`inspect."
"BufferFlags` предоставляет удобный способ интерпретации флагов. Метод должен "
"возвращать объект :class:`memoryview`."

#: ../../reference/datamodel.rst:3476
msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is a :class:"
"`memoryview` object that was previously returned by :meth:`~object."
"__buffer__`. The method must release any resources associated with the "
"buffer. This method should return ``None``. Buffer objects that do not need "
"to perform any cleanup are not required to implement this method."
msgstr ""
"Вызывается, когда буфер больше не нужен. Аргумент *buffer* представляет "
"собой объект :class:`memoryview`, который ранее был возвращен :meth:`~object."
"__buffer__`. Метод должен освободить все ресурсы, связанные с буфером. Этот "
"метод должен возвращать None. Для реализации этого метода не требуются "
"объекты буфера, которым не требуется выполнять очистку."

#: ../../reference/datamodel.rst:3487
msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ":pep:`688` - Делаем буферный протокол доступным в Python"

#: ../../reference/datamodel.rst:3488
msgid ""
"Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr "Представляет методы Python ``__buffer__`` и ``__release_buffer__``."

#: ../../reference/datamodel.rst:3490
msgid ":class:`collections.abc.Buffer`"
msgstr ":class:`collections.abc.Buffer`"

#: ../../reference/datamodel.rst:3491
msgid "ABC for buffer types."
msgstr "ABC для типов буферов."

#: ../../reference/datamodel.rst:3496
msgid "Special method lookup"
msgstr "Поиск специального метода"

#: ../../reference/datamodel.rst:3498
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"Для пользовательских классов неявные вызовы специальных методов "
"гарантированно будут работать правильно, только если они определены в типе "
"объекта, а не в словаре экземпляра объекта. Такое поведение является "
"причиной того, что следующий код вызывает исключение:"

#: ../../reference/datamodel.rst:3503
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"

#: ../../reference/datamodel.rst:3513
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"Причиной такого поведения является ряд специальных методов, таких как :meth:"
"`~object.__hash__` и :meth:`~object.__repr__`, которые реализуются всеми "
"объектами, включая объекты типов. Если бы неявный поиск этих методов "
"использовал обычный процесс поиска, они бы завершились ошибкой при вызове "
"самого объекта типа::"

#: ../../reference/datamodel.rst:3520
msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"

#: ../../reference/datamodel.rst:3527
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"Неправильная попытка вызвать несвязанный метод класса таким способом иногда "
"называется «путаницей метаклассов», и ее можно избежать, игнорируя экземпляр "
"при поиске специальных методов:"

#: ../../reference/datamodel.rst:3531
msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"

#: ../../reference/datamodel.rst:3536
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"Помимо обхода любых атрибутов экземпляра в интересах корректности, неявный "
"поиск специального метода обычно также обходит метод :meth:`~object."
"__getattribute__` даже метакласса объекта::"

#: ../../reference/datamodel.rst:3540
msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"

#: ../../reference/datamodel.rst:3562
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"Обход механизма :meth:`~object.__getattribute__` таким образом предоставляет "
"значительные возможности для оптимизации скорости внутри интерпретатора за "
"счет некоторой гибкости в обработке специальных методов (специальный метод "
"*должен* быть установлен для объекта класса себя, чтобы интерпретатор "
"последовательно вызывал его)."

#: ../../reference/datamodel.rst:3573
msgid "Coroutines"
msgstr "Сопрограммы"

#: ../../reference/datamodel.rst:3577
msgid "Awaitable Objects"
msgstr "Ожидаемые объекты"

#: ../../reference/datamodel.rst:3579
msgid ""
"An :term:`awaitable` object generally implements an :meth:`~object."
"__await__` method. :term:`Coroutine objects <coroutine>` returned from :"
"keyword:`async def` functions are awaitable."
msgstr ""
"Объект :term:`awaitable` обычно реализует метод :meth:`~object.__await__`. :"
"term:`Сопрограммные объекты <coroutine>`, возвращаемые из :keyword:`async "
"def`, ожидаются."

#: ../../reference/datamodel.rst:3585
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not implement :"
"meth:`~object.__await__`."
msgstr ""
"Объекты :term:`generator iterator`, возвращаемые из генераторов, украшенных :"
"func:`types.coroutine`, также являются ожидаемыми, но они не реализуют :meth:"
"`~object.__await__`."

#: ../../reference/datamodel.rst:3591
msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression. The :class:"
"`object` class itself is not awaitable and does not provide this method."
msgstr ""
"Должен возвращать :term:`итератор`. Должен использоваться для реализации "
"объектов :term:`awaitable`. Например, :class:`asyncio.Future` реализует этот "
"метод для совместимости с выражением :keyword:`await`. Сам класс :class:"
"`object` не является ожидаемым и не предоставляет этот метод."

#: ../../reference/datamodel.rst:3599
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework (e."
"g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""
"Язык не накладывает никаких ограничений на тип или значение объектов, "
"возвращаемых итератором, возвращаемым ``__await__``, поскольку это "
"специфично для реализации структуры асинхронного выполнения (например, :mod:"
"`asyncio`), которая будет управлять объектом :term:`awaitable`."

#: ../../reference/datamodel.rst:3607
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ""
":pep:`492` для получения дополнительной информации об ожидаемых объектах."

#: ../../reference/datamodel.rst:3613
msgid "Coroutine Objects"
msgstr "Объекты сопрограммы"

#: ../../reference/datamodel.rst:3615
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's :"
"attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines "
"should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
":term:`Объекты сопрограммы <coroutine>` — это :term:`awaitable` объекты. "
"Выполнением сопрограммы можно управлять, вызывая :meth:`~object.__await__` и "
"перебирая результат. Когда сопрограмма завершает выполнение и возвращается, "
"итератор вызывает :exc:`StopIteration`, а атрибут :attr:`~StopIteration."
"value` исключения сохраняет возвращаемое значение. Если сопрограмма вызывает "
"исключение, оно распространяется итератором. Сопрограммы не должны напрямую "
"вызывать необработанные исключения :exc:`StopIteration`."

#: ../../reference/datamodel.rst:3623
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"Сопрограммы также имеют методы, перечисленные ниже, которые аналогичны "
"методам генераторов (см. :ref:`generator-methods`). Однако, в отличие от "
"генераторов, сопрограммы не поддерживают итерацию напрямую."

#: ../../reference/datamodel.rst:3627
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "Ожидание сопрограммы более одного раза является ошибкой RuntimeError."

#: ../../reference/datamodel.rst:3633
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`~object."
"__await__`.  If *value* is not ``None``, this method delegates to the :meth:"
"`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`!__await__` return "
"value, described above."
msgstr ""
"Запускает или возобновляет выполнение сопрограммы. Если *value* равно "
"``None``, это эквивалентно перемещению итератора, возвращаемого :meth:"
"`~object.__await__`. Если *value* не ``None``, этот метод делегирует метод :"
"meth:`~generator.send` итератора, который вызвал приостановку сопрограммы. "
"Результат (возвращаемое значение, :exc:`StopIteration` или другое "
"исключение) такой же, как при переборе возвращаемого значения :meth:`!"
"__await__`, описанного выше."

#: ../../reference/datamodel.rst:3644
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`~object.__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"Вызывает указанное исключение в сопрограмме. Этот метод делегирует метод :"
"meth:`~generator.throw` итератора, который вызвал приостановку сопрограммы, "
"если у него есть такой метод. В противном случае исключение возникает в "
"точке приостановки. Результат (возвращаемое значение, :exc:`StopIteration` "
"или другое исключение) тот же, что и при переборе возвращаемого значения :"
"meth:`~object.__await__`, описанного выше. Если исключение не "
"перехватывается сопрограммой, оно передается обратно вызывающей стороне."

#: ../../reference/datamodel.rst:3655
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"Вторая подпись \\(type\\[, value\\[, trace\\]\\]\\ устарела и может быть "
"удалена в будущей версии Python."

#: ../../reference/datamodel.rst:3660
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"Заставляет сопрограмму очищаться и завершать работу. Если сопрограмма "
"приостановлена, этот метод сначала делегирует метод :meth:`~generator.close` "
"итератора, который вызвал приостановку сопрограммы, если у него есть такой "
"метод. Затем он вызывает :exc:`GeneratorExit` в точке приостановки, "
"заставляя сопрограмму немедленно очиститься. Наконец, сопрограмма помечается "
"как завершившая выполнение, даже если она никогда не запускалась."

#: ../../reference/datamodel.rst:3668
msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"Объекты сопрограммы автоматически закрываются с использованием описанного "
"выше процесса, когда они собираются быть уничтожены."

#: ../../reference/datamodel.rst:3674
msgid "Asynchronous Iterators"
msgstr "Асинхронные итераторы"

#: ../../reference/datamodel.rst:3676
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"*асинхронный итератор* может вызывать асинхронный код в своем методе "
"``__anext__``."

#: ../../reference/datamodel.rst:3679
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""
"Асинхронные итераторы можно использовать в операторе :keyword:`async for`."

#: ../../reference/datamodel.rst:3681 ../../reference/datamodel.rst:3730
msgid "The :class:`object` class itself does not provide these methods."
msgstr "Сам класс :class:`object` не предоставляет этих методов."

#: ../../reference/datamodel.rst:3686
msgid "Must return an *asynchronous iterator* object."
msgstr "Должен возвращать объект *асинхронный итератор*."

#: ../../reference/datamodel.rst:3690
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Должен возвращать *ожидаемое*, приводящее к следующему значению итератора. "
"Должен вызывать ошибку :exc:`StopAsyncIteration` после завершения итерации."

#: ../../reference/datamodel.rst:3693
msgid "An example of an asynchronous iterable object::"
msgstr "Пример асинхронного итерируемого объекта::"

#: ../../reference/datamodel.rst:3695
msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"

#: ../../reference/datamodel.rst:3710
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"До Python 3.7 :meth:`~object.__aiter__` мог возвращать *awaitable*, который "
"разрешался бы в :term:`асинхронный итератор <асинхронный итератор>`."

#: ../../reference/datamodel.rst:3715
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a :exc:"
"`TypeError` error."
msgstr ""
"Начиная с Python 3.7, :meth:`~object.__aiter__` должен возвращать "
"асинхронный объект-итератор. Возврат чего-либо еще приведет к ошибке :exc:"
"`TypeError`."

#: ../../reference/datamodel.rst:3723
msgid "Asynchronous Context Managers"
msgstr "Асинхронные контекстные менеджеры"

#: ../../reference/datamodel.rst:3725
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*Асинхронный контекстный менеджер* — это *контекстный менеджер*, который "
"может приостанавливать выполнение своих методов ``__aenter__`` и "
"``__aexit__``."

#: ../../reference/datamodel.rst:3728
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Асинхронные менеджеры контекста можно использовать в операторе :keyword:"
"`async with`."

#: ../../reference/datamodel.rst:3734
msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Семантически похож на :meth:`~object.__enter__`, с той лишь разницей, что он "
"должен возвращать *ожидаемый*."

#: ../../reference/datamodel.rst:3739
msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Семантически похож на :meth:`~object.__exit__`, с той лишь разницей, что он "
"должен возвращать *awaitable*."

#: ../../reference/datamodel.rst:3742
msgid "An example of an asynchronous context manager class::"
msgstr "Пример класса асинхронного контекстного менеджера::"

#: ../../reference/datamodel.rst:3744
msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"

#: ../../reference/datamodel.rst:3755
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/datamodel.rst:3756
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"В некоторых случаях *возможно* изменить тип объекта при определенных "
"контролируемых условиях. Однако, как правило, это не очень хорошая идея, "
"поскольку при неправильном обращении она может привести к очень странному "
"поведению."

#: ../../reference/datamodel.rst:3760
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, and :meth:`~object.__contains__` methods have special "
"handling for this; others will still raise a :exc:`TypeError`, but may do so "
"by relying on the behavior that ``None`` is not callable."
msgstr ""
"Методы :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__` и :meth:`~object.__contains__` имеют для этого специальную "
"обработку; другие по-прежнему будут вызывать :exc:`TypeError`, но могут "
"делать это, полагаясь на поведение, согласно которому ``None`` не может быть "
"вызван."

#: ../../reference/datamodel.rst:3766
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns :data:`NotImplemented`.  Do not set the method to ``None`` if "
"you want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"«Не поддерживает» здесь означает, что у класса нет такого метода, или метод "
"возвращает :data:`NotImplemented`. Не устанавливайте для метода значение "
"None, если вы хотите принудительно использовать отраженный метод правого "
"операнда — вместо этого это будет иметь противоположный эффект, "
"заключающийся в явной *блокировке* такого резервного варианта."

#: ../../reference/datamodel.rst:3772
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not called."
msgstr ""
"Для операндов одного и того же типа предполагается, что если неотражаемый "
"метод, например :meth:`~object.__add__`, завершается неудачно, то вся "
"операция не поддерживается, поэтому отраженный метод не вызывается. ."

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:152
#: ../../reference/datamodel.rst:163 ../../reference/datamodel.rst:184
#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:229
#: ../../reference/datamodel.rst:250 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:328 ../../reference/datamodel.rst:363
#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:409
#: ../../reference/datamodel.rst:427 ../../reference/datamodel.rst:447
#: ../../reference/datamodel.rst:455 ../../reference/datamodel.rst:466
#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:519
#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:660
#: ../../reference/datamodel.rst:798 ../../reference/datamodel.rst:822
#: ../../reference/datamodel.rst:857 ../../reference/datamodel.rst:1114
#: ../../reference/datamodel.rst:1237 ../../reference/datamodel.rst:1264
#: ../../reference/datamodel.rst:1336 ../../reference/datamodel.rst:1440
#: ../../reference/datamodel.rst:1547 ../../reference/datamodel.rst:1647
#: ../../reference/datamodel.rst:2072 ../../reference/datamodel.rst:3090
msgid "object"
msgstr "объект"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:126
msgid "data"
msgstr "данные"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:296
#: ../../reference/datamodel.rst:343 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:798
#: ../../reference/datamodel.rst:1293 ../../reference/datamodel.rst:1730
#: ../../reference/datamodel.rst:1973 ../../reference/datamodel.rst:1979
#: ../../reference/datamodel.rst:2072 ../../reference/datamodel.rst:2629
#: ../../reference/datamodel.rst:3060 ../../reference/datamodel.rst:3218
#: ../../reference/datamodel.rst:3253 ../../reference/datamodel.rst:3267
#: ../../reference/datamodel.rst:3316 ../../reference/datamodel.rst:3326
#: ../../reference/datamodel.rst:3354
msgid "built-in function"
msgstr "встроенная функция"

#: ../../reference/datamodel.rst:23
msgid "id"
msgstr "id"

#: ../../reference/datamodel.rst:23 ../../reference/datamodel.rst:126
#: ../../reference/datamodel.rst:2629
msgid "type"
msgstr "тип"

#: ../../reference/datamodel.rst:23
msgid "identity of an object"
msgstr "идентичность объекта"

#: ../../reference/datamodel.rst:23
msgid "value of an object"
msgstr "стоимость объекта"

#: ../../reference/datamodel.rst:23
msgid "type of an object"
msgstr "тип объекта"

#: ../../reference/datamodel.rst:23
msgid "mutable object"
msgstr "изменяемый объект"

#: ../../reference/datamodel.rst:23
msgid "immutable object"
msgstr "неизменяемый объект"

#: ../../reference/datamodel.rst:60
msgid "garbage collection"
msgstr "сбор мусора"

#: ../../reference/datamodel.rst:60
msgid "reference counting"
msgstr "подсчет ссылок"

#: ../../reference/datamodel.rst:60
msgid "unreachable object"
msgstr "недостижимый объект"

#: ../../reference/datamodel.rst:95 ../../reference/datamodel.rst:1114
msgid "container"
msgstr "контейнер"

#: ../../reference/datamodel.rst:126
msgid "hierarchy"
msgstr "иерархия"

#: ../../reference/datamodel.rst:126
msgid "extension"
msgstr "расширение"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:400
#: ../../reference/datamodel.rst:401 ../../reference/datamodel.rst:502
#: ../../reference/datamodel.rst:857 ../../reference/datamodel.rst:877
#: ../../reference/datamodel.rst:1293
msgid "module"
msgstr "модуль"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:798
msgid "C"
msgstr "C"

#: ../../reference/datamodel.rst:126 ../../reference/datamodel.rst:265
#: ../../reference/datamodel.rst:798
msgid "language"
msgstr "язык"

#: ../../reference/datamodel.rst:139 ../../reference/datamodel.rst:1114
#: ../../reference/datamodel.rst:1132 ../../reference/datamodel.rst:1237
#: ../../reference/datamodel.rst:1257
msgid "attribute"
msgstr "атрибут"

#: ../../reference/datamodel.rst:139
msgid "special"
msgstr "особенный"

#: ../../reference/datamodel.rst:139
msgid "generic"
msgstr "универсальный"

#: ../../reference/datamodel.rst:184
msgid "..."
msgstr "..."

#: ../../reference/datamodel.rst:184
msgid "ellipsis literal"
msgstr "ellipsis literal"

#: ../../reference/datamodel.rst:196 ../../reference/datamodel.rst:1264
msgid "numeric"
msgstr "числовой"

#: ../../reference/datamodel.rst:229 ../../reference/datamodel.rst:235
#: ../../reference/datamodel.rst:343
msgid "integer"
msgstr "целое число"

#: ../../reference/datamodel.rst:235
msgid "representation"
msgstr "представительство"

#: ../../reference/datamodel.rst:250
msgid "Boolean"
msgstr "Логический тип"

#: ../../reference/datamodel.rst:250
msgid "False"
msgstr "Ложь"

#: ../../reference/datamodel.rst:250
msgid "True"
msgstr "Истина"

#: ../../reference/datamodel.rst:265
msgid "floating-point"
msgstr "плавающая точка"

#: ../../reference/datamodel.rst:265 ../../reference/datamodel.rst:283
msgid "number"
msgstr "число"

#: ../../reference/datamodel.rst:265
msgid "Java"
msgstr "Java"

#: ../../reference/datamodel.rst:283 ../../reference/datamodel.rst:3326
msgid "complex"
msgstr "комплексные"

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:427
#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:3060
msgid "len"
msgstr "len"

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:1264
msgid "sequence"
msgstr "последовательность"

#: ../../reference/datamodel.rst:296
msgid "index operation"
msgstr "индексная операция"

#: ../../reference/datamodel.rst:296
msgid "item selection"
msgstr "выбор элемента"

#: ../../reference/datamodel.rst:296 ../../reference/datamodel.rst:388
#: ../../reference/datamodel.rst:466
msgid "subscription"
msgstr "подписка"

#: ../../reference/datamodel.rst:311 ../../reference/datamodel.rst:388
msgid "slicing"
msgstr "нарезка"

#: ../../reference/datamodel.rst:328
msgid "immutable sequence"
msgstr "неизменяемая последовательность"

#: ../../reference/datamodel.rst:328
msgid "immutable"
msgstr "неизменяемый"

#: ../../reference/datamodel.rst:339 ../../reference/datamodel.rst:1948
#: ../../reference/datamodel.rst:1979
msgid "string"
msgstr "строка"

#: ../../reference/datamodel.rst:339
msgid "immutable sequences"
msgstr "неизменяемые последовательности"

#: ../../reference/datamodel.rst:343
msgid "chr"
msgstr "chr"

#: ../../reference/datamodel.rst:343
msgid "ord"
msgstr "ord"

#: ../../reference/datamodel.rst:343
msgid "character"
msgstr "character"

#: ../../reference/datamodel.rst:343
msgid "Unicode"
msgstr "Юникод"

#: ../../reference/datamodel.rst:363
msgid "tuple"
msgstr "кортеж"

#: ../../reference/datamodel.rst:363
msgid "singleton"
msgstr "singleton"

#: ../../reference/datamodel.rst:363
msgid "empty"
msgstr "empty"

#: ../../reference/datamodel.rst:376 ../../reference/datamodel.rst:1973
msgid "bytes"
msgstr "байт"

#: ../../reference/datamodel.rst:376
msgid "byte"
msgstr "byte"

#: ../../reference/datamodel.rst:388
msgid "mutable sequence"
msgstr "изменяемая последовательность"

#: ../../reference/datamodel.rst:388
msgid "mutable"
msgstr "изменяемый"

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:1132
#: ../../reference/datamodel.rst:1257
msgid "assignment"
msgstr "присваивание"

#: ../../reference/datamodel.rst:388 ../../reference/datamodel.rst:857
#: ../../reference/datamodel.rst:1684 ../../reference/datamodel.rst:1866
#: ../../reference/datamodel.rst:3381
msgid "statement"
msgstr "инструкция"

#: ../../reference/datamodel.rst:400
msgid "array"
msgstr "array"

#: ../../reference/datamodel.rst:401
msgid "collections"
msgstr "коллекции"

#: ../../reference/datamodel.rst:409
msgid "list"
msgstr "список"

#: ../../reference/datamodel.rst:416
msgid "bytearray"
msgstr "байтовый массив"

#: ../../reference/datamodel.rst:427
msgid "set type"
msgstr "set type"

#: ../../reference/datamodel.rst:447
msgid "set"
msgstr "установить"

#: ../../reference/datamodel.rst:455
msgid "frozenset"
msgstr "frozenset"

#: ../../reference/datamodel.rst:466 ../../reference/datamodel.rst:1264
msgid "mapping"
msgstr "сопоставление"

#: ../../reference/datamodel.rst:483 ../../reference/datamodel.rst:1114
#: ../../reference/datamodel.rst:2072
msgid "dictionary"
msgstr "словарь"

#: ../../reference/datamodel.rst:502
msgid "dbm.ndbm"
msgstr "dbm.ndbm"

#: ../../reference/datamodel.rst:502
msgid "dbm.gnu"
msgstr "dbm.gnu"

#: ../../reference/datamodel.rst:519
msgid "callable"
msgstr "вызываемый объект"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:534
#: ../../reference/datamodel.rst:742 ../../reference/datamodel.rst:760
#: ../../reference/datamodel.rst:773 ../../reference/datamodel.rst:798
msgid "function"
msgstr "функция"

#: ../../reference/datamodel.rst:519 ../../reference/datamodel.rst:1114
#: ../../reference/datamodel.rst:1137 ../../reference/datamodel.rst:3010
msgid "call"
msgstr "call"

#: ../../reference/datamodel.rst:519
msgid "invocation"
msgstr "invocation"

#: ../../reference/datamodel.rst:519
msgid "argument"
msgstr "аргумент"

#: ../../reference/datamodel.rst:534 ../../reference/datamodel.rst:660
msgid "user-defined"
msgstr "user-defined"

#: ../../reference/datamodel.rst:534
msgid "user-defined function"
msgstr "определяемые пользователем функция"

#: ../../reference/datamodel.rst:547
msgid "__closure__ (function attribute)"
msgstr "__closure__ (function attribute)"

#: ../../reference/datamodel.rst:547
msgid "__globals__ (function attribute)"
msgstr "__globals__ (function attribute)"

#: ../../reference/datamodel.rst:547
msgid "global"
msgstr "global"

#: ../../reference/datamodel.rst:547 ../../reference/datamodel.rst:877
msgid "namespace"
msgstr "пространство имён"

#: ../../reference/datamodel.rst:573
msgid "__doc__ (function attribute)"
msgstr "__doc__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__name__ (function attribute)"
msgstr "__name__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__module__ (function attribute)"
msgstr "__module__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__dict__ (function attribute)"
msgstr "__dict__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__defaults__ (function attribute)"
msgstr "__defaults__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__code__ (function attribute)"
msgstr "__code__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__annotations__ (function attribute)"
msgstr "__annotations__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__kwdefaults__ (function attribute)"
msgstr "__kwdefaults__ (function attribute)"

#: ../../reference/datamodel.rst:573
msgid "__type_params__ (function attribute)"
msgstr "__type_params__ (function attribute)"

#: ../../reference/datamodel.rst:660 ../../reference/datamodel.rst:822
msgid "method"
msgstr "метод"

#: ../../reference/datamodel.rst:660
msgid "user-defined method"
msgstr "user-defined method"

#: ../../reference/datamodel.rst:668
msgid "__func__ (method attribute)"
msgstr "__func__ (method attribute)"

#: ../../reference/datamodel.rst:668
msgid "__self__ (method attribute)"
msgstr "__self__ (method attribute)"

#: ../../reference/datamodel.rst:668
msgid "__doc__ (method attribute)"
msgstr "__doc__ (method attribute)"

#: ../../reference/datamodel.rst:668
msgid "__name__ (method attribute)"
msgstr "__name__ (method attribute)"

#: ../../reference/datamodel.rst:668
msgid "__module__ (method attribute)"
msgstr "__module__ (method attribute)"

#: ../../reference/datamodel.rst:742 ../../reference/datamodel.rst:1440
msgid "generator"
msgstr "генератор"

#: ../../reference/datamodel.rst:742
msgid "iterator"
msgstr "итератор"

#: ../../reference/datamodel.rst:760 ../../reference/datamodel.rst:3569
msgid "coroutine"
msgstr "корутина"

#: ../../reference/datamodel.rst:773
msgid "asynchronous generator"
msgstr "асинхронный генератор"

#: ../../reference/datamodel.rst:773
msgid "asynchronous iterator"
msgstr "асинхронный итератор"

#: ../../reference/datamodel.rst:822
msgid "built-in method"
msgstr "встроенный метод"

#: ../../reference/datamodel.rst:822
msgid "built-in"
msgstr "встроенный"

#: ../../reference/datamodel.rst:857
msgid "import"
msgstr "импорт"

#: ../../reference/datamodel.rst:877
msgid "__name__ (module attribute)"
msgstr "__name__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__spec__ (module attribute)"
msgstr "__spec__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__package__ (module attribute)"
msgstr "__package__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__loader__ (module attribute)"
msgstr "__loader__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__path__ (module attribute)"
msgstr "__path__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__file__ (module attribute)"
msgstr "__file__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__cached__ (module attribute)"
msgstr "__cached__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__doc__ (module attribute)"
msgstr "__doc__ (атрибут модуля)"

#: ../../reference/datamodel.rst:877
msgid "__annotations__ (module attribute)"
msgstr "__annotations__ (module attribute)"

#: ../../reference/datamodel.rst:1082
msgid "__dict__ (module attribute)"
msgstr "__dict__ (атрибут модуля)"

#: ../../reference/datamodel.rst:1114 ../../reference/datamodel.rst:1132
#: ../../reference/datamodel.rst:1237 ../../reference/datamodel.rst:1849
#: ../../reference/datamodel.rst:2740
msgid "class"
msgstr "класс"

#: ../../reference/datamodel.rst:1114 ../../reference/datamodel.rst:1237
#: ../../reference/datamodel.rst:1257
msgid "class instance"
msgstr "экземпляр класса"

#: ../../reference/datamodel.rst:1114 ../../reference/datamodel.rst:1237
#: ../../reference/datamodel.rst:3010
msgid "instance"
msgstr "instance"

#: ../../reference/datamodel.rst:1114 ../../reference/datamodel.rst:1137
msgid "class object"
msgstr "class object"

#: ../../reference/datamodel.rst:1144
msgid "__name__ (class attribute)"
msgstr "__name__ (class attribute)"

#: ../../reference/datamodel.rst:1144
msgid "__module__ (class attribute)"
msgstr "__module__ (class attribute)"

#: ../../reference/datamodel.rst:1144
msgid "__dict__ (class attribute)"
msgstr "__dict__ (class attribute)"

#: ../../reference/datamodel.rst:1144
msgid "__bases__ (class attribute)"
msgstr "__bases__ (class attribute)"

#: ../../reference/datamodel.rst:1144
msgid "__doc__ (class attribute)"
msgstr "__doc__ (class attribute)"

#: ../../reference/datamodel.rst:1144
msgid "__annotations__ (class attribute)"
msgstr "__annotations__ (class attribute)"

#: ../../reference/datamodel.rst:1144
msgid "__type_params__ (class attribute)"
msgstr "__type_params__ (class attribute)"

#: ../../reference/datamodel.rst:1275
msgid "__dict__ (instance attribute)"
msgstr "__dict__ (instance attribute)"

#: ../../reference/datamodel.rst:1275
msgid "__class__ (instance attribute)"
msgstr "__class__ (атрибут экземпляра)"

#: ../../reference/datamodel.rst:1293
msgid "open"
msgstr "открыть"

#: ../../reference/datamodel.rst:1293
msgid "io"
msgstr "io"

#: ../../reference/datamodel.rst:1293
msgid "popen() (in module os)"
msgstr "popen() (in module os)"

#: ../../reference/datamodel.rst:1293
msgid "makefile() (socket method)"
msgstr "makefile() (socket method)"

#: ../../reference/datamodel.rst:1293
msgid "sys.stdin"
msgstr "sys.stdin"

#: ../../reference/datamodel.rst:1293
msgid "sys.stdout"
msgstr "sys.stdout"

#: ../../reference/datamodel.rst:1293
msgid "sys.stderr"
msgstr "sys.stderr"

#: ../../reference/datamodel.rst:1293
msgid "stdio"
msgstr "stdio"

#: ../../reference/datamodel.rst:1293
msgid "stdin (in module sys)"
msgstr "stdin (in module sys)"

#: ../../reference/datamodel.rst:1293
msgid "stdout (in module sys)"
msgstr "stdout (in module sys)"

#: ../../reference/datamodel.rst:1293
msgid "stderr (in module sys)"
msgstr "stderr (in module sys)"

#: ../../reference/datamodel.rst:1322
msgid "internal type"
msgstr "внутренний тип"

#: ../../reference/datamodel.rst:1322
msgid "types, internal"
msgstr "типы, внутренние"

#: ../../reference/datamodel.rst:1336
msgid "bytecode"
msgstr "байт-код"

#: ../../reference/datamodel.rst:1336
msgid "code"
msgstr "код"

#: ../../reference/datamodel.rst:1336
msgid "code object"
msgstr "объект кода"

#: ../../reference/datamodel.rst:1347
msgid "co_argcount (code object attribute)"
msgstr "co_argcount (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_posonlyargcount (code object attribute)"
msgstr "co_posonlyargcount (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_kwonlyargcount (code object attribute)"
msgstr "co_kwonlyargcount (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_code (code object attribute)"
msgstr "co_code (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_consts (code object attribute)"
msgstr "co_consts (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_filename (code object attribute)"
msgstr "co_filename (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_firstlineno (code object attribute)"
msgstr "co_firstlineno (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_flags (code object attribute)"
msgstr "co_flags (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_lnotab (code object attribute)"
msgstr "co_lnotab (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_name (code object attribute)"
msgstr "co_name (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_names (code object attribute)"
msgstr "co_names (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_nlocals (code object attribute)"
msgstr "co_nlocals (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_stacksize (code object attribute)"
msgstr "co_stacksize (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_varnames (code object attribute)"
msgstr "co_varnames (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_cellvars (code object attribute)"
msgstr "co_cellvars (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_freevars (code object attribute)"
msgstr "co_freevars (code object attribute)"

#: ../../reference/datamodel.rst:1347
msgid "co_qualname (code object attribute)"
msgstr "co_qualname (code object attribute)"

#: ../../reference/datamodel.rst:1458
msgid "documentation string"
msgstr "строка документации"

#: ../../reference/datamodel.rst:1547
msgid "frame"
msgstr "фрейм"

#: ../../reference/datamodel.rst:1553
msgid "f_back (frame attribute)"
msgstr "f_back (frame attribute)"

#: ../../reference/datamodel.rst:1553
msgid "f_code (frame attribute)"
msgstr "f_code (frame attribute)"

#: ../../reference/datamodel.rst:1553
msgid "f_globals (frame attribute)"
msgstr "f_globals (frame attribute)"

#: ../../reference/datamodel.rst:1553
msgid "f_locals (frame attribute)"
msgstr "f_locals (frame attribute)"

#: ../../reference/datamodel.rst:1553
msgid "f_lasti (frame attribute)"
msgstr "f_lasti (frame attribute)"

#: ../../reference/datamodel.rst:1553
msgid "f_builtins (frame attribute)"
msgstr "f_builtins (frame attribute)"

#: ../../reference/datamodel.rst:1592
msgid "f_trace (frame attribute)"
msgstr "f_trace (frame attribute)"

#: ../../reference/datamodel.rst:1592
msgid "f_trace_lines (frame attribute)"
msgstr "f_trace_lines (frame attribute)"

#: ../../reference/datamodel.rst:1592
msgid "f_trace_opcodes (frame attribute)"
msgstr "f_trace_opcodes (frame attribute)"

#: ../../reference/datamodel.rst:1592
msgid "f_lineno (frame attribute)"
msgstr "f_lineno (frame attribute)"

#: ../../reference/datamodel.rst:1647
msgid "traceback"
msgstr "трассировка"

#: ../../reference/datamodel.rst:1647
msgid "stack"
msgstr "stack"

#: ../../reference/datamodel.rst:1647
msgid "trace"
msgstr "trace"

#: ../../reference/datamodel.rst:1647
msgid "exception"
msgstr "exception"

#: ../../reference/datamodel.rst:1647
msgid "handler"
msgstr "handler"

#: ../../reference/datamodel.rst:1647
msgid "execution"
msgstr "execution"

#: ../../reference/datamodel.rst:1647
msgid "exc_info (in module sys)"
msgstr "exc_info (в модуле sys)"

#: ../../reference/datamodel.rst:1647
msgid "last_traceback (in module sys)"
msgstr "last_traceback (in module sys)"

#: ../../reference/datamodel.rst:1647
msgid "sys.exc_info"
msgstr "sys.exc_info"

#: ../../reference/datamodel.rst:1647
msgid "sys.exception"
msgstr "sys.exception"

#: ../../reference/datamodel.rst:1647
msgid "sys.last_traceback"
msgstr "sys.last_traceback"

#: ../../reference/datamodel.rst:1684
msgid "tb_frame (traceback attribute)"
msgstr "tb_frame (traceback attribute)"

#: ../../reference/datamodel.rst:1684
msgid "tb_lineno (traceback attribute)"
msgstr "tb_lineno (traceback attribute)"

#: ../../reference/datamodel.rst:1684
msgid "tb_lasti (traceback attribute)"
msgstr "tb_lasti (traceback attribute)"

#: ../../reference/datamodel.rst:1684
msgid "try"
msgstr "try"

#: ../../reference/datamodel.rst:1714
msgid "tb_next (traceback attribute)"
msgstr "tb_next (traceback attribute)"

#: ../../reference/datamodel.rst:1730 ../../reference/datamodel.rst:3090
msgid "slice"
msgstr "срез"

#: ../../reference/datamodel.rst:1736
msgid "start (slice object attribute)"
msgstr "start (slice object attribute)"

#: ../../reference/datamodel.rst:1736
msgid "stop (slice object attribute)"
msgstr "stop (slice object attribute)"

#: ../../reference/datamodel.rst:1736
msgid "step (slice object attribute)"
msgstr "step (slice object attribute)"

#: ../../reference/datamodel.rst:1784
msgid "operator"
msgstr "оператор"

#: ../../reference/datamodel.rst:1784
msgid "overloading"
msgstr "overloading"

#: ../../reference/datamodel.rst:1784
msgid "__getitem__() (mapping object method)"
msgstr "__getitem__() (метод объекта сопоставления)"

#: ../../reference/datamodel.rst:1820
msgid "subclassing"
msgstr "subclassing"

#: ../../reference/datamodel.rst:1820
msgid "immutable types"
msgstr "неизменяемые типы"

#: ../../reference/datamodel.rst:1849
msgid "constructor"
msgstr "конструктор"

#: ../../reference/datamodel.rst:1866
msgid "destructor"
msgstr "деструктор"

#: ../../reference/datamodel.rst:1866
msgid "finalizer"
msgstr "финализатор"

#: ../../reference/datamodel.rst:1866
msgid "del"
msgstr "del"

#: ../../reference/datamodel.rst:1930
msgid "repr() (built-in function)"
msgstr "repr() (built-in function)"

#: ../../reference/datamodel.rst:1930
msgid "__repr__() (object method)"
msgstr "__repr__() (object method)"

#: ../../reference/datamodel.rst:1948
msgid "__str__() (object method)"
msgstr "__str__() (object method)"

#: ../../reference/datamodel.rst:1948
msgid "format() (built-in function)"
msgstr "format() (встроенная функция)"

#: ../../reference/datamodel.rst:1948
msgid "print() (built-in function)"
msgstr "print() (built-in function)"

#: ../../reference/datamodel.rst:1979
msgid "__format__() (object method)"
msgstr "__format__() (object method)"

#: ../../reference/datamodel.rst:1979
msgid "conversion"
msgstr "conversion"

#: ../../reference/datamodel.rst:1979
msgid "print"
msgstr "print"

#: ../../reference/datamodel.rst:2021
msgid "comparisons"
msgstr "сравнения"

#: ../../reference/datamodel.rst:2072
msgid "hash"
msgstr "hash"

#: ../../reference/datamodel.rst:2153
msgid "__len__() (mapping object method)"
msgstr "__len__() (mapping object method)"

#: ../../reference/datamodel.rst:2258
msgid "__getattr__ (module attribute)"
msgstr "__getattr__ (module attribute)"

#: ../../reference/datamodel.rst:2258
msgid "__dir__ (module attribute)"
msgstr "__dir__ (module attribute)"

#: ../../reference/datamodel.rst:2258
msgid "__class__ (module attribute)"
msgstr "__class__ (module attribute)"

#: ../../reference/datamodel.rst:2629
msgid "metaclass"
msgstr "метакласс"

#: ../../reference/datamodel.rst:2629
msgid "= (equals)"
msgstr "= (равно)"

#: ../../reference/datamodel.rst:2629
msgid "class definition"
msgstr "class definition"

#: ../../reference/datamodel.rst:2693
msgid "metaclass hint"
msgstr "metaclass hint"

#: ../../reference/datamodel.rst:2716
msgid "__prepare__ (metaclass method)"
msgstr "__prepare__ (metaclass method)"

#: ../../reference/datamodel.rst:2740
msgid "body"
msgstr "тело"

#: ../../reference/datamodel.rst:2760
msgid "__class__ (method cell)"
msgstr "__class__ (method cell)"

#: ../../reference/datamodel.rst:2760
msgid "__classcell__ (class namespace entry)"
msgstr "__classcell__ (class namespace entry)"

#: ../../reference/datamodel.rst:3060
msgid "__bool__() (object method)"
msgstr "__bool__() (object method)"

#: ../../reference/datamodel.rst:3218 ../../reference/datamodel.rst:3253
msgid "divmod"
msgstr "divmod"

#: ../../reference/datamodel.rst:3218 ../../reference/datamodel.rst:3253
#: ../../reference/datamodel.rst:3267
msgid "pow"
msgstr "pow"

#: ../../reference/datamodel.rst:3316
msgid "abs"
msgstr "abs"

#: ../../reference/datamodel.rst:3326
msgid "int"
msgstr "int"

#: ../../reference/datamodel.rst:3326
msgid "float"
msgstr "float"

#: ../../reference/datamodel.rst:3354
msgid "round"
msgstr "round"

#: ../../reference/datamodel.rst:3381
msgid "with"
msgstr "with"

#: ../../reference/datamodel.rst:3381
msgid "context manager"
msgstr "контекстный менеджер"
