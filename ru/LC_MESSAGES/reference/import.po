# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../reference/import.rst:6
msgid "The import system"
msgstr "Система импорта"

#: ../../reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""
"Код Python в одном модуле получает доступ к коду другого модуля в процессе "
"его импорта. Оператор :keyword:`import` — наиболее распространенный способ "
"вызова механизма импорта, но не единственный. Такие функции, как :func:"
"`importlib.import_module` и встроенные :func:`__import__`, также можно "
"использовать для вызова механизма импорта."

#: ../../reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`!import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`!import` statement.  See the :"
"keyword:`!import` statement for the exact details of that name binding "
"operation."
msgstr ""
"Оператор :keyword:`import` объединяет две операции; он ищет указанный "
"модуль, а затем привязывает результаты этого поиска к имени в локальной "
"области. Операция поиска оператора :keyword:`!import` определяется как вызов "
"функции :func:`__import__` с соответствующими аргументами. Возвращаемое "
"значение :func:`__import__` используется для выполнения операции привязки "
"имени оператора :keyword:`!import`. См. оператор :keyword:`!import` для "
"получения точных сведений об этой операции привязки имени."

#: ../../reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""
"Прямой вызов :func:`__import__` выполняет только поиск модуля и, если он "
"найден, операцию создания модуля. Хотя могут возникнуть определенные "
"побочные эффекты, такие как импорт родительских пакетов и обновление "
"различных кешей (включая :data:`sys.modules`), только оператор :keyword:"
"`import` выполняет операцию привязки имени."

#: ../../reference/import.rst:31
msgid ""
"When an :keyword:`import` statement is executed, the standard builtin :func:"
"`__import__` function is called. Other mechanisms for invoking the import "
"system (such as :func:`importlib.import_module`) may choose to bypass :func:"
"`__import__` and use their own solutions to implement import semantics."
msgstr ""
"При выполнении оператора :keyword:`import` вызывается стандартная встроенная "
"функция :func:`__import__`. Другие механизмы вызова системы импорта "
"(например, :func:`importlib.import_module`) могут обойти :func:`__import__` "
"и использовать свои собственные решения для реализации семантики импорта."

#: ../../reference/import.rst:36
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, a :exc:`ModuleNotFoundError` is raised.  Python "
"implements various strategies to search for the named module when the import "
"machinery is invoked.  These strategies can be modified and extended by "
"using various hooks described in the sections below."
msgstr ""
"Когда модуль впервые импортируется, Python ищет модуль и, если он найден, "
"создает объект модуля. [#fnmo]_ , инициализируя его. Если указанный модуль "
"не может быть найден, выдается ошибка :exc:`ModuleNotFoundError`. Python "
"реализует различные стратегии поиска именованного модуля при вызове "
"механизма импорта. Эти стратегии можно модифицировать и расширять, используя "
"различные перехватчики, описанные в разделах ниже."

#: ../../reference/import.rst:43
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""
"Система импорта была обновлена ​​для полной реализации второй фазы :pep:`302`. "
"Никакого механизма неявного импорта больше нет — вся система импорта "
"доступна через :data:`sys.meta_path`. Кроме того, реализована поддержка "
"пакетов собственного пространства имен (см. :pep:`420`)."

#: ../../reference/import.rst:51
msgid ":mod:`importlib`"
msgstr ":mod:`importlib`"

#: ../../reference/import.rst:53
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""
"Модуль :mod:`importlib` предоставляет богатый API для взаимодействия с "
"системой импорта. Например, :func:`importlib.import_module` предоставляет "
"рекомендуемый, более простой API, чем встроенный :func:`__import__`, для "
"вызова механизма импорта. Дополнительную информацию можно найти в "
"документации библиотеки :mod:`importlib`."

#: ../../reference/import.rst:62
msgid "Packages"
msgstr "Пакеты"

#: ../../reference/import.rst:67
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""
"В Python есть только один тип объекта модуля, и все модули относятся к этому "
"типу, независимо от того, реализован ли модуль на Python, C или на чем-то "
"другом. Чтобы помочь организовать модули и обеспечить иерархию именования, в "
"Python есть концепция :term:`packages <package>`."

#: ../../reference/import.rst:72
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""
"Вы можете думать о пакетах как о каталогах файловой системы, а о модулях как "
"о файлах внутри каталогов, но не воспринимайте эту аналогию слишком "
"буквально, поскольку пакеты и модули не обязательно происходят из файловой "
"системы. Для целей этой документации мы будем использовать эту удобную "
"аналогию с каталогами и файлами. Подобно каталогам файловой системы, пакеты "
"организованы иерархически, и сами пакеты могут содержать подпакеты, а также "
"обычные модули."

#: ../../reference/import.rst:80
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""
"Важно помнить, что все пакеты являются модулями, но не все модули являются "
"пакетами. Или, другими словами, пакеты — это особый вид модулей. В "
"частности, любой модуль, содержащий атрибут ``__path__``, считается пакетом."

#: ../../reference/import.rst:85
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by a dot, akin to Python's standard attribute access syntax.  "
"Thus you might have a package called :mod:`email`, which in turn has a "
"subpackage called :mod:`email.mime` and a module within that subpackage "
"called :mod:`email.mime.text`."
msgstr ""
"Все модули имеют имя. Имена подпакетов отделяются от имени родительского "
"пакета точкой, аналогично стандартному синтаксису доступа к атрибутам "
"Python. Таким образом, у вас может быть пакет с именем :mod:`email`, "
"который, в свою очередь, имеет подпакет с именем :mod:`email.mime` и модуль "
"внутри этого подпакета с именем :mod:`email.mime.text`."

#: ../../reference/import.rst:93
msgid "Regular packages"
msgstr "Обычные пакеты"

#: ../../reference/import.rst:98
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""
"Python определяет два типа пакетов: :term:`regular packages <regular "
"package>` и :term:`namespace packages <namespace package>`. Обычные пакеты — "
"это традиционные пакеты, существующие в Python 3.2 и более ранних версиях. "
"Обычный пакет обычно реализуется как каталог, содержащий файл ``__init__."
"py``. Когда импортируется обычный пакет, этот файл ``__init__.py`` "
"выполняется неявно, и определяемые им объекты привязываются к именам в "
"пространстве имен пакета. Файл ``__init__.py`` может содержать тот же код "
"Python, что и любой другой модуль, и Python добавит к модулю некоторые "
"дополнительные атрибуты при его импорте."

#: ../../reference/import.rst:108
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""
"Например, следующая структура файловой системы определяет ``родительский`` "
"пакет верхнего уровня с тремя подпакетами:"

#: ../../reference/import.rst:111
msgid ""
"parent/\n"
"    __init__.py\n"
"    one/\n"
"        __init__.py\n"
"    two/\n"
"        __init__.py\n"
"    three/\n"
"        __init__.py"
msgstr ""
"parent/\n"
"    __init__.py\n"
"    one/\n"
"        __init__.py\n"
"    two/\n"
"        __init__.py\n"
"    three/\n"
"        __init__.py"

#: ../../reference/import.rst:120
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""
"Импорт ``parent.one`` неявно выполнит ``parent/__init__.py`` и ``parent/one/"
"__init__.py``. Последующий импорт ``parent.two`` или ``parent.three`` "
"выполнит ``parent/two/__init__.py`` и ``parent/three/__init__.py`` "
"соответственно."

#: ../../reference/import.rst:129
msgid "Namespace packages"
msgstr "Пакеты пространства имен"

#: ../../reference/import.rst:135
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""
"Пакет пространства имен представляет собой совокупность различных :term:"
"`portions <portion>`, где каждая часть представляет собой подпакет "
"родительского пакета. Части могут находиться в разных местах файловой "
"системы. Части также можно найти в zip-файлах, в сети или где-либо еще, где "
"Python ищет во время импорта. Пакеты пространства имен могут напрямую "
"соответствовать объектам файловой системы, а могут и не соответствовать; они "
"могут быть виртуальными модулями, не имеющими конкретного представления."

#: ../../reference/import.rst:143
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""
"Пакеты пространства имен не используют обычный список для атрибута "
"``__path__``. Вместо этого они используют собственный итерируемый тип, "
"который автоматически выполняет новый поиск частей пакета при следующей "
"попытке импорта внутри этого пакета, если путь к их родительскому пакету "
"(или :data:`sys.path` для пакета верхнего уровня) изменится."

#: ../../reference/import.rst:149
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""
"В пакетах пространства имен файл «parent/__init__.py» отсутствует. "
"Фактически, во время поиска импорта может быть найдено несколько "
"``родительских`` каталогов, каждый из которых представлен отдельной частью. "
"Таким образом, \"parent/one\" физически не может находиться рядом с \"parent/"
"two\". В этом случае Python будет создавать пакет пространства имен для "
"``родительского`` пакета верхнего уровня всякий раз, когда импортируется он "
"или один из его подпакетов."

#: ../../reference/import.rst:156
msgid "See also :pep:`420` for the namespace package specification."
msgstr ""
"См. также :pep:`420` для получения информации о спецификации пакета "
"пространства имен."

#: ../../reference/import.rst:160
msgid "Searching"
msgstr "Поиск"

#: ../../reference/import.rst:162
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""
"Чтобы начать поиск, Python нуждается в :term:`полном <квалифицированном "
"имени>` имени импортируемого модуля (или пакета, но для целей данного "
"обсуждения разница несущественна). Это имя может происходить из различных "
"аргументов оператора :keyword:`import` или из параметров функций :func:"
"`importlib.import_module` или :func:`__import__`."

#: ../../reference/import.rst:168
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, a :exc:`ModuleNotFoundError` "
"is raised."
msgstr ""
"Это имя будет использоваться на различных этапах поиска при импорте и может "
"представлять собой пунктирный путь к подмодулю, например ``foo.bar.baz``. В "
"этом случае Python сначала пытается импортировать ``foo``, затем ``foo.bar`` "
"и, наконец, ``foo.bar.baz``. Если какой-либо из промежуточных импортов "
"завершается неудачно, возникает ошибка :exc:`ModuleNotFoundError`."

#: ../../reference/import.rst:175
msgid "The module cache"
msgstr "Кэш модуля"

#: ../../reference/import.rst:180
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""
"Первое место, проверяемое при поиске импорта, — это :data:`sys.modules`. Это "
"сопоставление служит кэшем всех ранее импортированных модулей, включая "
"промежуточные пути. Таким образом, если ``foo.bar.baz`` был ранее "
"импортирован, :data:`sys.modules` будет содержать записи для ``foo``, ``foo."
"bar`` и ``foo.bar.baz` `. Каждый ключ будет иметь в качестве значения "
"соответствующий объект модуля."

#: ../../reference/import.rst:187
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then a :exc:"
"`ModuleNotFoundError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""
"Во время импорта имя модуля ищется в :data:`sys.modules` и, если оно "
"присутствует, соответствующее значение представляет собой модуль, "
"удовлетворяющий импорту, и процесс завершается. Однако, если значение равно "
"«None», то возникает ошибка :exc:`ModuleNotFoundError`. Если имя модуля "
"отсутствует, Python продолжит поиск модуля."

#: ../../reference/import.rst:193
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in a :exc:"
"`ModuleNotFoundError`."
msgstr ""
":data:`sys.modules` доступен для записи. Удаление ключа может не уничтожить "
"связанный модуль (поскольку другие модули могут содержать ссылки на него), "
"но оно сделает недействительной запись в кэше для именованного модуля, "
"заставляя Python заново искать указанный модуль при следующем импорте. Ключу "
"также можно присвоить значение None, что приведет к тому, что следующий "
"импорт модуля приведет к ошибке :exc:`ModuleNotFoundError`."

#: ../../reference/import.rst:200
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""
"Однако будьте осторожны: если вы сохраните ссылку на объект модуля, сделаете "
"недействительной его запись в кэше в :data:`sys.modules`, а затем повторно "
"импортируете указанный модуль, два объекта модуля *не* будут одинаковыми. "
"Напротив, :func:`importlib.reload` будет повторно использовать *тот же* "
"объект модуля и просто повторно инициализировать содержимое модуля, "
"перезапустив код модуля."

#: ../../reference/import.rst:210
msgid "Finders and loaders"
msgstr "Поисковики и загрузчики"

#: ../../reference/import.rst:217
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""
"Если указанный модуль не найден в :data:`sys.modules`, то вызывается "
"протокол импорта Python для поиска и загрузки модуля. Этот протокол состоит "
"из двух концептуальных объектов: :term:`finders <finder>` и :term:`loaders "
"<loader>`. Задача искателя — определить, сможет ли он найти указанный "
"модуль, используя любую известную ему стратегию. Объекты, реализующие оба "
"этих интерфейса, называются :term:`importers <importer>` — они возвращают "
"себя, когда обнаруживают, что могут загрузить запрошенный модуль."

#: ../../reference/import.rst:225
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""
"Python включает в себя ряд средств поиска и импорта по умолчанию. Первый "
"знает, как найти встроенные модули, а второй знает, как найти замороженные "
"модули. Третий поисковик по умолчанию ищет модули по пути импорта. :term:"
"`import path` — это список мест, которые могут называть пути файловой "
"системы или zip-файлы. Его также можно расширить для поиска любого "
"обнаруживаемого ресурса, например, идентифицируемого по URL-адресам."

#: ../../reference/import.rst:232
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""
"Механизм импорта является расширяемым, поэтому можно добавлять новые "
"средства поиска, чтобы расширить диапазон и объем поиска модулей."

#: ../../reference/import.rst:235
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""
"Средства поиска фактически не загружают модули. Если они могут найти "
"указанный модуль, они возвращают :dfn:`спецификацию модуля`, инкапсуляцию "
"информации, связанной с импортом модуля, которую механизм импорта затем "
"использует при загрузке модуля."

#: ../../reference/import.rst:239
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""
"В следующих разделах более подробно описывается протокол для средств поиска "
"и загрузчиков, в том числе способы создания и регистрации новых для "
"расширения механизма импорта."

#: ../../reference/import.rst:243
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""
"В предыдущих версиях Python средства поиска возвращали :term:`loaders "
"<loader>` напрямую, тогда как теперь они возвращают спецификации модулей, "
"*содержащих* загрузчики. Погрузчики по-прежнему используются при импорте, но "
"у них меньше обязанностей."

#: ../../reference/import.rst:249
msgid "Import hooks"
msgstr "Импортировать хуки"

#: ../../reference/import.rst:259
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""
"Импортное оборудование спроектировано так, чтобы его можно было расширять; "
"основным механизмом для этого являются *ловушки импорта*. Существует два "
"типа перехватчиков импорта: *метаперехватчики* и *перехватчики пути импорта*."

#: ../../reference/import.rst:263
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""
"Мета-перехватчики вызываются в начале обработки импорта, до того, как "
"произойдет какая-либо другая обработка импорта, кроме поиска в кэше :data:"
"`sys.modules`. Это позволяет мета-хукам переопределять обработку :data:`sys."
"path`, замороженные модули или даже встроенные модули. Мета-хуки "
"регистрируются путем добавления новых объектов поиска в :data:`sys."
"meta_path`, как описано ниже."

#: ../../reference/import.rst:269
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""
"Перехватчики пути импорта вызываются как часть обработки :data:`sys.path` "
"(или ``package.__path__``) в той точке, где встречается связанный с ними "
"элемент пути. Перехватчики пути импорта регистрируются путем добавления "
"новых вызываемых объектов в :data:`sys.path_hooks`, как описано ниже."

#: ../../reference/import.rst:276
msgid "The meta path"
msgstr "Мета-путь"

#: ../../reference/import.rst:282
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec` which takes three arguments: "
"a name, an import path, and (optionally) a target module.  The meta path "
"finder can use any strategy it wants to determine whether it can handle the "
"named module or not."
msgstr ""
"Если указанный модуль не найден в :data:`sys.modules`, Python затем "
"выполняет поиск :data:`sys.meta_path`, который содержит список объектов "
"поиска метапутей. Этим искателям опрашивается, чтобы узнать, знают ли они, "
"как обращаться с именованным модулем. Средства поиска метапутей должны "
"реализовать метод :meth:`~importlib.abc.MetaPathFinder.find_spec`, который "
"принимает три аргумента: имя, путь импорта и (необязательно) целевой модуль. "
"Поиск метапути может использовать любую стратегию, чтобы определить, может "
"ли он обрабатывать указанный модуль или нет."

#: ../../reference/import.rst:291
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then a :exc:`ModuleNotFoundError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""
"Если средство поиска метапути знает, как обращаться с именованным модулем, "
"оно возвращает объект спецификации. Если он не может обработать указанный "
"модуль, он возвращает None. Если обработка :data:`sys.meta_path` достигает "
"конца списка без возврата спецификации, то возникает ошибка :exc:"
"`ModuleNotFoundError`. Любые другие возникающие исключения просто "
"распространяются, прерывая процесс импорта."

#: ../../reference/import.rst:297
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, a :exc:`ModuleNotFoundError` is raised.  The third argument is an "
"existing module object that will be the target of loading later. The import "
"system passes in a target module only during reload."
msgstr ""
"Метод поиска метапутей :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"вызывается с двумя или тремя аргументами. Первым является полное имя "
"импортируемого модуля, например ``foo.bar.baz``. Второй аргумент — это "
"записи пути, которые будут использоваться для поиска модулей. Для модулей "
"верхнего уровня вторым аргументом является «Нет», но для подмодулей или "
"подпакетов вторым аргументом является значение атрибута «__path__» "
"родительского пакета. Если соответствующий атрибут ``__path__`` недоступен, "
"возникает ошибка :exc:`ModuleNotFoundError`. Третий аргумент — это "
"существующий объект модуля, который будет целью загрузки позже. Система "
"импорта передает целевой модуль только во время перезагрузки."

#: ../../reference/import.rst:308
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""
"Мета-путь может быть пройден несколько раз для одного запроса на импорт. "
"Например, если ни один из задействованных модулей еще не был кэширован, при "
"импорте ``foo.bar.baz`` сначала будет выполнен импорт верхнего уровня, "
"вызывая ``mpf.find_spec(\"foo\", None, None)`` для каждый искатель метапути "
"(``mpf``). После импорта ``foo``, ``foo.bar`` будет импортирован путем "
"повторного прохождения метапути с вызовом ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)`` . После импорта ``foo.bar`` последний обход вызовет ``mpf."
"find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."

#: ../../reference/import.rst:318
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""
"Некоторые средства поиска метапутей поддерживают импорт только верхнего "
"уровня. Эти импортеры всегда будут возвращать None, если в качестве второго "
"аргумента передается что-либо, кроме None."

#: ../../reference/import.rst:322
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""
"По умолчанию в Python :data:`sys.meta_path` есть три средства поиска "
"метапутей: один, который знает, как импортировать встроенные модули, другой, "
"который знает, как импортировать замороженные модули, и третий, который "
"знает, как импортировать модули из :term:` путь импорта` (т.е. поиск по "
"пути`)."

#: ../../reference/import.rst:327
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`!find_module`, which is now deprecated.  While it "
"will continue to work without change, the import machinery will try it only "
"if the finder does not implement :meth:`~importlib.abc.MetaPathFinder."
"find_spec`."
msgstr ""
"Метод поиска метапутей :meth:`~importlib.abc.MetaPathFinder.find_spec` "
"заменил :meth:`!find_module`, который теперь устарел. Хотя он будет "
"продолжать работать без изменений, механизм импорта будет пробовать его, "
"только если средство поиска не реализует :meth:`~importlib.abc."
"MetaPathFinder.find_spec`."

#: ../../reference/import.rst:334
msgid ""
"Use of :meth:`!find_module` by the import system now raises :exc:"
"`ImportWarning`."
msgstr ""
"Использование :meth:`!find_module` системой импорта теперь вызывает :exc:"
"`ImportWarning`."

#: ../../reference/import.rst:338
msgid ""
":meth:`!find_module` has been removed. Use :meth:`~importlib.abc."
"MetaPathFinder.find_spec` instead."
msgstr ""
":meth:`!find_module` был удален. Вместо этого используйте :meth:`~importlib."
"abc.MetaPathFinder.find_spec`."

#: ../../reference/import.rst:344
msgid "Loading"
msgstr "Загрузка"

#: ../../reference/import.rst:346
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""
"Если и когда спецификация модуля будет найдена, механизм импорта будет "
"использовать ее (и содержащийся в ней загрузчик) при загрузке модуля. Вот "
"приблизительное представление о том, что происходит во время загрузки "
"импорта:"

#: ../../reference/import.rst:350
msgid ""
"module = None\n"
"if spec.loader is not None and hasattr(spec.loader, 'create_module'):\n"
"    # It is assumed 'exec_module' will also be defined on the loader.\n"
"    module = spec.loader.create_module(spec)\n"
"if module is None:\n"
"    module = ModuleType(spec.name)\n"
"# The import-related module attributes get set here:\n"
"_init_module_attrs(spec, module)\n"
"\n"
"if spec.loader is None:\n"
"    # unsupported\n"
"    raise ImportError\n"
"if spec.origin is None and spec.submodule_search_locations is not None:\n"
"    # namespace package\n"
"    sys.modules[spec.name] = module\n"
"elif not hasattr(spec.loader, 'exec_module'):\n"
"    module = spec.loader.load_module(spec.name)\n"
"else:\n"
"    sys.modules[spec.name] = module\n"
"    try:\n"
"        spec.loader.exec_module(module)\n"
"    except BaseException:\n"
"        try:\n"
"            del sys.modules[spec.name]\n"
"        except KeyError:\n"
"            pass\n"
"        raise\n"
"return sys.modules[spec.name]"
msgstr ""
"module = None\n"
"if spec.loader is not None and hasattr(spec.loader, 'create_module'):\n"
"    # It is assumed 'exec_module' will also be defined on the loader.\n"
"    module = spec.loader.create_module(spec)\n"
"if module is None:\n"
"    module = ModuleType(spec.name)\n"
"# The import-related module attributes get set here:\n"
"_init_module_attrs(spec, module)\n"
"\n"
"if spec.loader is None:\n"
"    # unsupported\n"
"    raise ImportError\n"
"if spec.origin is None and spec.submodule_search_locations is not None:\n"
"    # namespace package\n"
"    sys.modules[spec.name] = module\n"
"elif not hasattr(spec.loader, 'exec_module'):\n"
"    module = spec.loader.load_module(spec.name)\n"
"else:\n"
"    sys.modules[spec.name] = module\n"
"    try:\n"
"        spec.loader.exec_module(module)\n"
"    except BaseException:\n"
"        try:\n"
"            del sys.modules[spec.name]\n"
"        except KeyError:\n"
"            pass\n"
"        raise\n"
"return sys.modules[spec.name]"

#: ../../reference/import.rst:379
msgid "Note the following details:"
msgstr "Обратите внимание на следующие детали:"

#: ../../reference/import.rst:381
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""
"Если в :data:`sys.modules` существует объект модуля с заданным именем, "
"импорт уже вернет его."

#: ../../reference/import.rst:384
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""
"Модуль будет существовать в :data:`sys.modules` до того, как загрузчик "
"выполнит код модуля. Это очень важно, поскольку код модуля может (прямо или "
"косвенно) импортировать себя; добавление его в :data:`sys.modules` заранее "
"предотвращает неограниченную рекурсию в худшем случае и множественную "
"загрузку в лучшем."

#: ../../reference/import.rst:390
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""
"Если загрузка не удалась, сбойный модуль (и только сбойный модуль) будет "
"удален из :data:`sys.modules`. Любой модуль, уже находящийся в кеше :data:"
"`sys.modules`, а также любой модуль, который был успешно загружен в качестве "
"побочного эффекта, должен оставаться в кеше. Это контрастирует с "
"перезагрузкой, при которой даже неисправный модуль остается в :data:`sys."
"modules`."

#: ../../reference/import.rst:396
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""
"После создания модуля, но до его выполнения, механизм импорта устанавливает "
"атрибуты модуля, связанные с импортом («_init_module_attrs» в приведенном "
"выше примере псевдокода), как описано в следующем разделе <import-mod-"
"attrs>` ."

#: ../../reference/import.rst:401
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""
"Выполнение модуля — это ключевой момент загрузки, во время которого "
"пространство имен модуля заполняется. Выполнение полностью делегируется "
"загрузчику, который решает, что и как заполнять."

#: ../../reference/import.rst:405
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""
"Модуль, созданный во время загрузки и переданный в exec_module(), может "
"отличаться от того, который возвращается в конце импорта. [#fnlo]_ ."

#: ../../reference/import.rst:408
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""
"Система импорта взяла на себя стандартные обязанности грузчиков. Ранее они "
"выполнялись методом :meth:`importlib.abc.Loader.load_module`."

#: ../../reference/import.rst:414
msgid "Loaders"
msgstr "Загрузчики"

#: ../../reference/import.rst:416
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""
"Загрузчики модулей выполняют важнейшую функцию загрузки: выполнение модуля. "
"Механизм импорта вызывает метод :meth:`importlib.abc.Loader.exec_module` с "
"единственным аргументом — объектом модуля, который необходимо выполнить. "
"Любое значение, возвращаемое из :meth:`~importlib.abc.Loader.exec_module`, "
"игнорируется."

#: ../../reference/import.rst:421
msgid "Loaders must satisfy the following requirements:"
msgstr "Погрузчики должны удовлетворять следующим требованиям:"

#: ../../reference/import.rst:423
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""
"Если модуль является модулем Python (в отличие от встроенного модуля или "
"динамически загружаемого расширения), загрузчик должен выполнить код модуля "
"в глобальном пространстве имен модуля (``module.__dict__``)."

#: ../../reference/import.rst:427
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""
"Если загрузчик не может выполнить модуль, он должен вызвать :exc:"
"`ImportError`, хотя любое другое исключение, возникшее во время :meth:"
"`~importlib.abc.Loader.exec_module`, будет распространено."

#: ../../reference/import.rst:431
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""
"Во многих случаях средство поиска и загрузчик может быть одним и тем же "
"объектом; в таких случаях метод :meth:`~importlib.abc.MetaPathFinder."
"find_spec` просто вернет спецификацию с загрузчиком, установленным на "
"``self``."

#: ../../reference/import.rst:435
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the method returns ``None``, the import machinery "
"will create the new module itself."
msgstr ""
"Загрузчики модулей могут выбрать создание объекта модуля во время загрузки, "
"реализовав метод :meth:`~importlib.abc.Loader.create_module`. Он принимает "
"один аргумент, спецификацию модуля, и возвращает новый объект модуля, "
"который будет использоваться во время загрузки. ``create_module()`` не "
"требует установки каких-либо атрибутов объекта модуля. Если метод возвращает "
"None, механизм импорта сам создаст новый модуль."

#: ../../reference/import.rst:442
msgid "The :meth:`~importlib.abc.Loader.create_module` method of loaders."
msgstr "Метод загрузчиков :meth:`~importlib.abc.Loader.create_module`."

#: ../../reference/import.rst:445
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""
"Метод :meth:`~importlib.abc.Loader.load_module` был заменен на :meth:"
"`~importlib.abc.Loader.exec_module`, и механизм импорта взял на себя все "
"стандартные обязанности по загрузке."

#: ../../reference/import.rst:450
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""
"Для совместимости с существующими загрузчиками механизм импорта будет "
"использовать метод загрузчиков load_module(), если он существует и загрузчик "
"также не реализует exec_module(). Однако ``load_module()`` устарел, и вместо "
"него загрузчикам следует реализовать ``exec_module()``."

#: ../../reference/import.rst:455
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""
"Метод ``load_module()`` должен реализовывать все стандартные функции "
"загрузки, описанные выше, в дополнение к выполнению модуля. Применяются все "
"те же ограничения, но с некоторыми дополнительными пояснениями:"

#: ../../reference/import.rst:459
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""
"Если в :data:`sys.modules` существует объект модуля с заданным именем, "
"загрузчик должен использовать этот существующий модуль. (В противном случае :"
"func:`importlib.reload` не будет работать корректно.) Если именованный "
"модуль не существует в :data:`sys.modules`, загрузчик должен создать новый "
"объект модуля и добавить его в :data:` sys.modules`."

#: ../../reference/import.rst:465
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""
"Модуль *должен* существовать в :data:`sys.modules` до того, как загрузчик "
"выполнит код модуля, чтобы предотвратить неограниченную рекурсию или "
"множественную загрузку."

#: ../../reference/import.rst:469
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module(s), and "
"only if the loader itself has loaded the module(s) explicitly."
msgstr ""
"Если загрузка не удалась, загрузчик должен удалить все модули, которые он "
"вставил в :data:`sys.modules`, но он должен удалить **только** неисправные "
"модули, и только если загрузчик сам загрузил модуль( с) явно."

#: ../../reference/import.rst:474
msgid ""
"A :exc:`DeprecationWarning` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
":exc:`DeprecationWarning` возникает, когда ``exec_module()`` определен, а "
"``create_module()`` нет."

#: ../../reference/import.rst:478
msgid ""
"An :exc:`ImportError` is raised when ``exec_module()`` is defined but "
"``create_module()`` is not."
msgstr ""
"Ошибка :exc:`ImportError` возникает, когда ``exec_module()`` определен, а "
"``create_module()`` нет."

#: ../../reference/import.rst:482
msgid "Use of ``load_module()`` will raise :exc:`ImportWarning`."
msgstr "Использование ``load_module()`` вызовет :exc:`ImportWarning`."

#: ../../reference/import.rst:486
msgid "Submodules"
msgstr "Субмодули"

#: ../../reference/import.rst:488
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""
"Когда подмодуль загружается с использованием любого механизма (например, API "
"importlib, операторов import или import-from или встроенного __import__()), "
"привязка помещается в пространство имен родительского модуля в объект "
"подмодуля. Например, если пакет ``spam`` имеет подмодуль ``foo``, после "
"импорта ``spam.foo`` у ``spam`` будет атрибут ``foo``, привязанный к "
"субмодулю. Допустим, у вас есть следующая структура каталогов::"

#: ../../reference/import.rst:495
msgid ""
"spam/\n"
"    __init__.py\n"
"    foo.py"
msgstr ""
"spam/\n"
"    __init__.py\n"
"    foo.py"

#: ../../reference/import.rst:499
msgid "and ``spam/__init__.py`` has the following line in it::"
msgstr "и в ``spam/__init__.py`` есть следующая строка:"

#: ../../reference/import.rst:501
msgid "from .foo import Foo"
msgstr "from .foo import Foo"

#: ../../reference/import.rst:503
msgid ""
"then executing the following puts name bindings for ``foo`` and ``Foo`` in "
"the ``spam`` module::"
msgstr ""
"затем выполнение следующей команды помещает привязки имен для ``foo`` и "
"``Foo`` в модуль ``spam``:"

#: ../../reference/import.rst:506
msgid ""
">>> import spam\n"
">>> spam.foo\n"
"<module 'spam.foo' from '/tmp/imports/spam/foo.py'>\n"
">>> spam.Foo\n"
"<class 'spam.foo.Foo'>"
msgstr ""
">>> import spam\n"
">>> spam.foo\n"
"<module 'spam.foo' from '/tmp/imports/spam/foo.py'>\n"
">>> spam.Foo\n"
"<class 'spam.foo.Foo'>"

#: ../../reference/import.rst:512
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""
"Учитывая знакомые правила привязки имен Python, это может показаться "
"удивительным, но на самом деле это фундаментальная особенность системы "
"импорта. Инвариантным правилом является то, что если у вас есть ``sys."
"modules['spam']`` и ``sys.modules['spam.foo']`` (как и после импорта выше), "
"последние должны выглядеть как атрибут ``foo`` первого."

#: ../../reference/import.rst:521
msgid "Module specs"
msgstr "Характеристики модуля"

#: ../../reference/import.rst:523
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""
"Механизм импорта использует различную информацию о каждом модуле во время "
"импорта, особенно перед загрузкой. Большая часть информации является общей "
"для всех модулей. Цель спецификации модуля — инкапсулировать эту информацию, "
"связанную с импортом, для каждого модуля."

#: ../../reference/import.rst:528
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""
"Использование спецификации во время импорта позволяет передавать состояние "
"между компонентами системы импорта, например, между средством поиска, "
"создающим спецификацию модуля, и загрузчиком, который ее выполняет. Самое "
"главное, это позволяет импортному оборудованию выполнять стандартные "
"операции по загрузке, тогда как без спецификации модуля эту ответственность "
"несет погрузчик."

#: ../../reference/import.rst:534
msgid ""
"The module's spec is exposed as :attr:`module.__spec__`. Setting :attr:`!"
"__spec__` appropriately applies equally to :ref:`modules initialized during "
"interpreter startup <programs>`. The one exception is ``__main__``, where :"
"attr:`!__spec__` is :ref:`set to None in some cases <main_spec>`."
msgstr ""
"Спецификация модуля представлена ​​как :attr:`module.__spec__`. Установка :"
"attr:`!__spec__` соответственно применяется в равной степени к :ref:"
"`модулям, инициализируемым во время запуска интерпретатора <programs>`. "
"Единственным исключением является ``__main__``, где для :attr:`!__spec__` в "
"некоторых случаях :ref:` установлено значение None <main_spec>`."

#: ../../reference/import.rst:540
msgid ""
"See :class:`~importlib.machinery.ModuleSpec` for details on the contents of "
"the module spec."
msgstr ""
"См. :class:`~importlib.machinery.ModuleSpec` для получения подробной "
"информации о содержимом спецификации модуля."

#: ../../reference/import.rst:548
msgid "__path__ attributes on modules"
msgstr "Атрибуты __path__ в модулях"

#: ../../reference/import.rst:550
msgid ""
"The :attr:`~module.__path__` attribute should be a (possibly empty) :term:"
"`sequence` of strings enumerating the locations where the package's "
"submodules will be found. By definition, if a module has a :attr:`!__path__` "
"attribute, it is a :term:`package`."
msgstr ""
"Атрибут :attr:`~module.__path__` должен быть (возможно, пустым) :term:"
"`последовательностью` строк, перечисляющих места, где будут найдены "
"подмодули пакета. По определению, если модуль имеет атрибут :attr:`!"
"__path__`, это :term:`package`."

#: ../../reference/import.rst:555
msgid ""
"A package's :attr:`~module.__path__` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, :attr:`!__path__` is typically much more constrained "
"than :data:`!sys.path`."
msgstr ""
"Атрибут пакета :attr:`~module.__path__` используется во время импорта его "
"подпакетов. В механизме импорта он функционирует почти так же, как :data:"
"`sys.path`, то есть предоставляет список мест для поиска модулей во время "
"импорта. Однако :attr:`!__path__` обычно гораздо более ограничен, чем :data:"
"`!sys.path`."

#: ../../reference/import.rst:562
msgid ""
"The same rules used for :data:`sys.path` also apply to a package's :attr:`!"
"__path__`. :data:`sys.path_hooks` (described below) are consulted when "
"traversing a package's :attr:`!__path__`."
msgstr ""
"Те же правила, что и для :data:`sys.path`, также применяются к :attr:`!"
"__path__` пакета. :data:`sys.path_hooks` (описанный ниже) используется при "
"обходе :attr:`!__path__` пакета."

#: ../../reference/import.rst:566
msgid ""
"A package's ``__init__.py`` file may set or alter the package's :attr:"
"`~module.__path__` attribute, and this was typically the way namespace "
"packages were implemented prior to :pep:`420`.  With the adoption of :pep:"
"`420`, namespace packages no longer need to supply ``__init__.py`` files "
"containing only :attr:`!__path__` manipulation code; the import machinery "
"automatically sets :attr:`!__path__` correctly for the namespace package."
msgstr ""
"Файл ``__init__.py`` пакета может устанавливать или изменять атрибут пакета :"
"attr:`~module.__path__`, и это обычно был способ реализации пакетов "
"пространства имен до :pep:`420`. С появлением :pep:`420` пакетам "
"пространства имен больше не нужно предоставлять файлы ``__init__.py``, "
"содержащие только код манипуляции :attr:`!__path__`; механизм импорта "
"автоматически устанавливает :attr:`!__path__` правильно для пакета "
"пространства имен."

#: ../../reference/import.rst:575
msgid "Module reprs"
msgstr "Module reprs"

#: ../../reference/import.rst:577
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""
"По умолчанию все модули имеют пригодное для использования представление, "
"однако в зависимости от установленных выше атрибутов и спецификации модуля "
"вы можете более явно управлять воспроизведением объектов модуля."

#: ../../reference/import.rst:581
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""
"Если у модуля есть спецификация (``__spec__``), механизм импорта попытается "
"сгенерировать из нее копию. Если это не удается или спецификация "
"отсутствует, система импорта создаст представление по умолчанию, используя "
"любую информацию, доступную в модуле. Он попытается использовать ``module."
"__name__``, ``module.__file__`` и ``module.__loader__`` в качестве входных "
"данных для воспроизведения, со значениями по умолчанию для любой "
"отсутствующей информации."

#: ../../reference/import.rst:588
msgid "Here are the exact rules used:"
msgstr "Вот точные используемые правила:"

#: ../../reference/import.rst:590
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""
"Если у модуля есть атрибут ``__spec__``, информация в спецификации "
"используется для создания repr. Учитываются атрибуты «name», «loader», "
"«origin» и «has_location»."

#: ../../reference/import.rst:594
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""
"Если у модуля есть атрибут ``__file__``, он используется как часть repr "
"модуля."

#: ../../reference/import.rst:597
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""
"Если в модуле нет ``__file__``, но есть ``__loader__``, отличный от "
"``None``, то репродукция загрузчика используется как часть репродукции "
"модуля."

#: ../../reference/import.rst:600
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr "В противном случае просто используйте ``__name__`` модуля в repr."

#: ../../reference/import.rst:602
msgid ""
"Use of :meth:`!module_repr`, having been deprecated since Python 3.4, was "
"removed in Python 3.12 and is no longer called during the resolution of a "
"module's repr."
msgstr ""
"Использование :meth:`!module_repr`, которое устарело начиная с Python 3.4, "
"было удалено в Python 3.12 и больше не вызывается во время разрешения "
"повтора модуля."

#: ../../reference/import.rst:610
msgid "Cached bytecode invalidation"
msgstr "Недействительность кэшированного байт-кода"

#: ../../reference/import.rst:612
msgid ""
"Before Python loads cached bytecode from a ``.pyc`` file, it checks whether "
"the cache is up-to-date with the source ``.py`` file. By default, Python "
"does this by storing the source's last-modified timestamp and size in the "
"cache file when writing it. At runtime, the import system then validates the "
"cache file by checking the stored metadata in the cache file against the "
"source's metadata."
msgstr ""
"Прежде чем Python загрузит кэшированный байт-код из файла ``.pyc``, он "
"проверяет, соответствует ли кэш исходному файлу ``.py``. По умолчанию Python "
"делает это, сохраняя временную метку и размер последнего изменения источника "
"в файле кэша при его записи. Во время выполнения система импорта затем "
"проверяет файл кэша, сверяя сохраненные метаданные в файле кэша с "
"метаданными источника."

#: ../../reference/import.rst:619
msgid ""
"Python also supports \"hash-based\" cache files, which store a hash of the "
"source file's contents rather than its metadata. There are two variants of "
"hash-based ``.pyc`` files: checked and unchecked. For checked hash-based ``."
"pyc`` files, Python validates the cache file by hashing the source file and "
"comparing the resulting hash with the hash in the cache file. If a checked "
"hash-based cache file is found to be invalid, Python regenerates it and "
"writes a new checked hash-based cache file. For unchecked hash-based ``."
"pyc`` files, Python simply assumes the cache file is valid if it exists. "
"Hash-based ``.pyc`` files validation behavior may be overridden with the :"
"option:`--check-hash-based-pycs` flag."
msgstr ""
"Python также поддерживает файлы кэша на основе хеша, в которых хранится хэш "
"содержимого исходного файла, а не его метаданные. Существует два варианта "
"файлов ``.pyc`` на основе хеша: проверенные и непроверенные. Для проверенных "
"файлов ``.pyc`` на основе хеша Python проверяет файл кэша, хэшируя исходный "
"файл и сравнивая полученный хеш с хешем в файле кэша. Если проверенный файл "
"кэша на основе хэша оказывается недействительным, Python восстанавливает его "
"и записывает новый файл кэша на основе проверенного хэша. Для непроверенных "
"файлов ``.pyc`` на основе хэша Python просто предполагает, что файл кэша "
"действителен, если он существует. Поведение проверки файлов ``.pyc`` на "
"основе хеша можно переопределить с помощью флага :option:`--check-hash-based-"
"pycs`."

#: ../../reference/import.rst:630
msgid ""
"Added hash-based ``.pyc`` files. Previously, Python only supported timestamp-"
"based invalidation of bytecode caches."
msgstr ""
"Добавлены файлы ``.pyc`` на основе хеша. Раньше Python поддерживал только "
"аннулирование кэшей байт-кода на основе временных меток."

#: ../../reference/import.rst:636
msgid "The Path Based Finder"
msgstr "Поиск по пути"

#: ../../reference/import.rst:641
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""
"Как упоминалось ранее, Python поставляется с несколькими средствами поиска "
"метапутей по умолчанию. Один из них, называемый :term:`поисковиком на основе "
"пути` (:class:`~importlib.machinery.PathFinder`), ищет :term:`import path`, "
"который содержит список :term:`path записей < запись пути>`. Каждая запись "
"пути называет место для поиска модулей."

#: ../../reference/import.rst:647
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""
"Поиск по пути сам по себе не знает, как что-либо импортировать. Вместо этого "
"он обходит отдельные записи пути, связывая каждую из них со средством поиска "
"записей пути, который знает, как обрабатывать этот конкретный тип пути."

#: ../../reference/import.rst:651
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` files) and "
"shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""
"Набор средств поиска записей пути по умолчанию реализует всю семантику для "
"поиска модулей в файловой системе, обрабатывая специальные типы файлов, "
"такие как исходный код Python (файлы .py), байт-код Python (файлы .pyc). и "
"общие библиотеки (например, файлы ``.so``). При поддержке модуля :mod:"
"`zipimport` в стандартной библиотеке средства поиска записей пути по "
"умолчанию также обрабатывают загрузку всех этих типов файлов (кроме общих "
"библиотек) из zip-файлов."

#: ../../reference/import.rst:658
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""
"Записи пути не обязательно должны ограничиваться расположением файловой "
"системы. Они могут ссылаться на URL-адреса, запросы к базе данных или любое "
"другое местоположение, которое можно указать в виде строки."

#: ../../reference/import.rst:662
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""
"Средство поиска на основе пути предоставляет дополнительные перехватчики и "
"протоколы, позволяющие расширять и настраивать типы записей путей, доступных "
"для поиска. Например, если вы хотите поддерживать записи путей в виде "
"сетевых URL-адресов, вы можете написать перехватчик, реализующий семантику "
"HTTP для поиска модулей в Интернете. Этот хук (вызываемый объект) возвращал :"
"term:`поиск записей пути`, поддерживающий протокол, описанный ниже, который "
"затем использовался для получения загрузчика модуля из Интернета."

#: ../../reference/import.rst:670
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""
"Предупреждение: в этом и предыдущем разделах используется термин *finder*, "
"различая их с помощью терминов :term:`мета-поиск пути` и :term:`поиск записи "
"пути`. Эти два типа средств поиска очень похожи, поддерживают схожие "
"протоколы и функционируют схожим образом в процессе импорта, но важно иметь "
"в виду, что они слегка отличаются. В частности, средства поиска метапутей "
"работают в начале процесса импорта, отключив обход :data:`sys.meta_path`."

#: ../../reference/import.rst:678
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""
"Напротив, средства поиска записей пути в некотором смысле являются деталью "
"реализации средства поиска на основе пути, и фактически, если бы средство "
"поиска на основе пути было удалено из :data:`sys.meta_path`, никакая "
"семантика поиска записей пути не изменилась бы. быть вызвано."

#: ../../reference/import.rst:685
msgid "Path entry finders"
msgstr "Поисковики входа в путь"

#: ../../reference/import.rst:693
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""
"Средство поиска на основе пути отвечает за поиск и загрузку модулей и "
"пакетов Python, местоположение которых указано строкой :term:`path вход`. "
"Большинство записей пути указывают местоположения в файловой системе, но они "
"не обязательно ограничиваются этим."

#: ../../reference/import.rst:698
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""
"В качестве средства поиска метапутей средство поиска на основе пути "
"реализует описанный ранее протокол :meth:`~importlib.abc.MetaPathFinder."
"find_spec`, однако он предоставляет дополнительные перехватчики, которые "
"можно использовать для настройки способа поиска модулей и загружается из :"
"term:`import path`."

#: ../../reference/import.rst:703
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""
"Три переменные используются поиском на основе пути, :data:`sys.path`, :data:"
"`sys.path_hooks` и :data:`sys.path_importer_cache`. Также используются "
"атрибуты ``__path__`` для объектов пакета. Это предоставляет дополнительные "
"возможности персонализации импортного оборудования."

#: ../../reference/import.rst:708
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :envvar:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings should be present on :data:`sys.path`; all "
"other data types are ignored."
msgstr ""
":data:`sys.path` содержит список строк, указывающих места поиска модулей и "
"пакетов. Он инициализируется из переменной среды :envvar:`PYTHONPATH` и "
"различных других значений по умолчанию, зависящих от установки и реализации. "
"Записи в :data:`sys.path` могут называть каталоги в файловой системе, zip-"
"файлы и, возможно, другие «места» (см. модуль :mod:`site`), в которых "
"следует искать модули, например URL-адреса или запросы к базе данных. В :"
"data:`sys.path` должны присутствовать только строки. все остальные типы "
"данных игнорируются."

#: ../../reference/import.rst:717
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""
"Средство поиска на основе пути представляет собой средство поиска метапути, "
"поэтому механизм импорта начинает поиск пути импорта с вызова средства "
"поиска на основе пути :meth:`~importlib.machinery.PathFinder. .find_spec`, "
"как описано ранее. Когда задан аргумент ``path`` для :meth:`~importlib."
"machinery.PathFinder.find_spec`, это будет список строковых путей для обхода "
"- обычно это атрибут пакета ``__path__`` для импорта внутри него. упаковка. "
"Если аргумент ``path`` равен ``None``, это указывает на импорт верхнего "
"уровня и используется :data:`sys.path`."

#: ../../reference/import.rst:726
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be ``stat()`` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again."
msgstr ""
"Средство поиска на основе пути перебирает каждую запись в пути поиска и для "
"каждой из них ищет соответствующий :term:`искатель записи пути` (:class:"
"`~importlib.abc.PathEntryFinder`) для записи пути. Поскольку это может быть "
"дорогостоящей операцией (например, для этого поиска могут потребоваться "
"накладные расходы на вызов ``stat()``), средство поиска на основе пути "
"поддерживает кэширование записей пути, сопоставляющих их средствам поиска "
"записей пути. Этот кеш хранится в :data:`sys.path_importer_cache` (несмотря "
"на название, этот кеш фактически хранит объекты поиска, а не ограничивается "
"объектами :term:`importer`). Таким образом, дорогостоящий поиск "
"определенного местоположения :term:`path входного файла` нужно выполнить "
"только один раз. Код пользователя может свободно удалять записи кэша из :"
"data:`sys.path_importer_cache`, заставляя средство поиска на основе пути "
"снова выполнить поиск записей пути."

#: ../../reference/import.rst:739
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder` for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""
"Если запись пути отсутствует в кеше, средство поиска на основе пути "
"перебирает каждый вызываемый объект в :data:`sys.path_hooks`. Каждый из :"
"term:`перехватчиков записи пути <входной крючок пути>` в этом списке "
"вызывается с одним аргументом — записью пути, по которой осуществляется "
"поиск. Этот вызываемый объект может либо вернуть поисковик записи пути, "
"который может обработать запись пути, либо вызвать :exc:`ImportError`. :exc:"
"`ImportError` используется средством поиска на основе пути, чтобы "
"сигнализировать о том, что перехватчик не может найти :term:`искатель записи "
"пути` для этой :term:`записи пути`. Исключение игнорируется, и итерация :"
"term:`import path` продолжается. Хук должен ожидать либо строкового, либо "
"байтового объекта; кодировка байтовых объектов зависит от перехватчика "
"(например, это может быть кодировка файловой системы, UTF-8 или что-то еще), "
"и если перехватчик не может декодировать аргумент, он должен вызвать :exc:"
"`ImportError`."

#: ../../reference/import.rst:753
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""
"Если итерация :data:`sys.path_hooks` заканчивается без возврата :term:`path "
"input finder`, то метод :meth:`~importlib.machinery.PathFinder.find_spec` "
"средства поиска на основе пути сохранит ``None`` в :data:`sys."
"path_importer_cache` (чтобы указать, что для этой записи пути нет средства "
"поиска) и вернуть ``None``, указывая, что этот :term:`мета-поиск пути` не "
"смог найти модуль."

#: ../../reference/import.rst:760
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""
"Если :term:`path входной искатель` *возвращается одним из :term:`path "
"входных крючков` для :data:`sys.path_hooks`, то следующий протокол "
"используется для запроса искателя о модуле spec, который затем используется "
"при загрузке модуля."

#: ../../reference/import.rst:765
msgid ""
"The current working directory -- denoted by an empty string -- is handled "
"slightly differently from other entries on :data:`sys.path`. First, if the "
"current working directory is found to not exist, no value is stored in :data:"
"`sys.path_importer_cache`. Second, the value for the current working "
"directory is looked up fresh for each module lookup. Third, the path used "
"for :data:`sys.path_importer_cache` and returned by :meth:`importlib."
"machinery.PathFinder.find_spec` will be the actual current working directory "
"and not the empty string."
msgstr ""
"Текущий рабочий каталог, обозначаемый пустой строкой, обрабатывается немного "
"иначе, чем другие записи в :data:`sys.path`. Во-первых, если обнаруживается, "
"что текущий рабочий каталог не существует, никакое значение не сохраняется "
"в :data:`sys.path_importer_cache`. Во-вторых, значение текущего рабочего "
"каталога ищется заново при каждом поиске модуля. В-третьих, путь, "
"используемый для :data:`sys.path_importer_cache` и возвращаемый :meth:"
"`importlib.machinery.PathFinder.find_spec`, будет фактическим текущим "
"рабочим каталогом, а не пустой строкой."

#: ../../reference/import.rst:775
msgid "Path entry finder protocol"
msgstr "Протокол поиска входа в путь"

#: ../../reference/import.rst:777
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""
"Чтобы поддерживать импорт модулей и инициализированных пакетов, а также "
"вносить части в пакеты пространства имен, средства поиска записей пути "
"должны реализовать метод :meth:`~importlib.abc.PathEntryFinder.find_spec`."

#: ../../reference/import.rst:781
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two arguments: the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` принимает два аргумента: "
"полное имя импортируемого модуля и (необязательный) целевой модуль. "
"``find_spec()`` возвращает полностью заполненную спецификацию модуля. В этой "
"спецификации всегда будет установлен «загрузчик» (за одним исключением)."

#: ../../reference/import.rst:786
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`, the path entry finder sets ``submodule_search_locations`` to "
"a list containing the portion."
msgstr ""
"Чтобы указать механизму импорта, что спецификация представляет собой "
"пространство имен :term:`portion`, средство поиска записей пути "
"устанавливает ``submodule_search_locations`` в список, содержащий эту часть."

#: ../../reference/import.rst:790
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`!"
"find_loader` and :meth:`!find_module`, both of which are now deprecated, but "
"will be used if ``find_spec()`` is not defined."
msgstr ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` заменил :meth:`!"
"find_loader` и :meth:`!find_module`, оба из которых теперь устарели, но "
"будут использоваться, если ``find_spec()`` не определен."

#: ../../reference/import.rst:796
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  However, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""
"Старые средства поиска записей пути могут реализовать один из этих двух "
"устаревших методов вместо find_spec(). Эти методы по-прежнему соблюдаются "
"ради обратной совместимости. Однако, если в средстве поиска записей пути "
"реализован метод find_spec(), устаревшие методы игнорируются."

#: ../../reference/import.rst:801
msgid ""
":meth:`!find_loader` takes one argument, the fully qualified name of the "
"module being imported.  ``find_loader()`` returns a 2-tuple where the first "
"item is the loader and the second item is a namespace :term:`portion`."
msgstr ""
":meth:`!find_loader` принимает один аргумент — полное имя импортируемого "
"модуля. ``find_loader()`` возвращает кортеж из двух элементов, где первый "
"элемент — это загрузчик, а второй элемент — пространство имен :term:"
"`portion`."

#: ../../reference/import.rst:806
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""
"Для обратной совместимости с другими реализациями протокола импорта многие "
"средства поиска записей пути также поддерживают тот же традиционный метод "
"find_module(), который поддерживают средства поиска метапутей. Однако методы "
"поиска входов пути find_module() никогда не вызываются с аргументом path "
"(ожидается, что они запишут соответствующую информацию о пути из "
"первоначального вызова перехватчика пути)."

#: ../../reference/import.rst:813
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""
"Метод find_module() для средств поиска записей пути устарел, поскольку он не "
"позволяет средству поиска записей пути вносить части в пакеты пространства "
"имен. Если в искателе записи пути существуют и find_loader(), и "
"find_module(), система импорта всегда будет вызывать find_loader(), а не "
"find_module()."

#: ../../reference/import.rst:819
msgid ""
"Calls to :meth:`!find_module` and :meth:`!find_loader` by the import system "
"will raise :exc:`ImportWarning`."
msgstr ""
"Вызовы :meth:`!find_module` и :meth:`!find_loader` системой импорта вызовут :"
"exc:`ImportWarning`."

#: ../../reference/import.rst:824
msgid "``find_module()`` and ``find_loader()`` have been removed."
msgstr "``find_module()`` и ``find_loader()`` были удалены."

#: ../../reference/import.rst:829
msgid "Replacing the standard import system"
msgstr "Замена стандартной системы импорта"

#: ../../reference/import.rst:831
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""
"Самый надежный механизм замены всей системы импорта — удалить содержимое по "
"умолчанию :data:`sys.meta_path`, полностью заменив его настраиваемым мета-"
"путем."

#: ../../reference/import.rst:835
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""
"Если допустимо изменить только поведение операторов импорта, не затрагивая "
"другие API, которые обращаются к системе импорта, то замены встроенной "
"функции :func:`__import__` может быть достаточно. Этот метод также можно "
"использовать на уровне модуля, чтобы изменить поведение операторов импорта "
"только внутри этого модуля."

#: ../../reference/import.rst:841
msgid ""
"To selectively prevent the import of some modules from a hook early on the "
"meta path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ModuleNotFoundError` directly from :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` instead of returning ``None``. The "
"latter indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""
"Чтобы выборочно предотвратить импорт некоторых модулей с перехвата на ранних "
"этапах метапути (вместо полного отключения стандартной системы импорта), "
"достаточно вызвать :exc:`ModuleNotFoundError` непосредственно из :meth:"
"`~importlib.abc.MetaPathFinder .find_spec` вместо возврата ``None``. "
"Последнее указывает на то, что поиск метапути должен продолжаться, а "
"возникновение исключения немедленно прекращает его."

#: ../../reference/import.rst:851
msgid "Package Relative Imports"
msgstr "Относительный импорт пакетов"

#: ../../reference/import.rst:853
msgid ""
"Relative imports use leading dots. A single leading dot indicates a relative "
"import, starting with the current package. Two or more leading dots indicate "
"a relative import to the parent(s) of the current package, one level per dot "
"after the first. For example, given the following package layout::"
msgstr ""
"Относительный импорт использует ведущие точки. Одна точка в начале указывает "
"на относительный импорт, начиная с текущего пакета. Две или более начальных "
"точки указывают на относительный импорт к родительскому(ям) текущего пакета, "
"на один уровень на точку после первой. Например, учитывая следующий макет "
"пакета:"

#: ../../reference/import.rst:858
msgid ""
"package/\n"
"    __init__.py\n"
"    subpackage1/\n"
"        __init__.py\n"
"        moduleX.py\n"
"        moduleY.py\n"
"    subpackage2/\n"
"        __init__.py\n"
"        moduleZ.py\n"
"    moduleA.py"
msgstr ""
"package/\n"
"    __init__.py\n"
"    subpackage1/\n"
"        __init__.py\n"
"        moduleX.py\n"
"        moduleY.py\n"
"    subpackage2/\n"
"        __init__.py\n"
"        moduleZ.py\n"
"    moduleA.py"

#: ../../reference/import.rst:869
msgid ""
"In either ``subpackage1/moduleX.py`` or ``subpackage1/__init__.py``, the "
"following are valid relative imports::"
msgstr ""
"В ``subpackage1/moduleX.py`` или ``subpackage1/__init__.py`` допустимы "
"следующие относительные импорты:"

#: ../../reference/import.rst:872
msgid ""
"from .moduleY import spam\n"
"from .moduleY import spam as ham\n"
"from . import moduleY\n"
"from ..subpackage1 import moduleY\n"
"from ..subpackage2.moduleZ import eggs\n"
"from ..moduleA import foo"
msgstr ""
"from .moduleY import spam\n"
"from .moduleY import spam as ham\n"
"from . import moduleY\n"
"from ..subpackage1 import moduleY\n"
"from ..subpackage2.moduleZ import eggs\n"
"from ..moduleA import foo"

#: ../../reference/import.rst:879
msgid ""
"Absolute imports may use either the ``import <>`` or ``from <> import <>`` "
"syntax, but relative imports may only use the second form; the reason for "
"this is that::"
msgstr ""
"Абсолютный импорт может использовать синтаксис ``import <>`` или ``from <> "
"import <>``, но относительный импорт может использовать только вторую форму; "
"причина в том, что::"

#: ../../reference/import.rst:883
msgid "import XXX.YYY.ZZZ"
msgstr "import XXX.YYY.ZZZ"

#: ../../reference/import.rst:885
msgid ""
"should expose ``XXX.YYY.ZZZ`` as a usable expression, but .moduleY is not a "
"valid expression."
msgstr ""
"должен предоставлять ``XXX.YYY.ZZZ`` как пригодное для использования "
"выражение, но .moduleY не является допустимым выражением."

#: ../../reference/import.rst:892
msgid "Special considerations for __main__"
msgstr "Особые соображения для __main__"

#: ../../reference/import.rst:894
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""
"Модуль :mod:`__main__` — это особый случай по отношению к системе импорта "
"Python. Как отмечено в другом месте <programs>, модуль __main__` "
"инициализируется непосредственно при запуске интерпретатора, во многом "
"подобно :mod:`sys` и :mod:`builtins`. Однако, в отличие от этих двух, он не "
"является строго встроенным модулем. Это связано с тем, что способ "
"инициализации ``__main__`` зависит от флагов и других параметров, с которыми "
"вызывается интерпретатор."

#: ../../reference/import.rst:905
msgid "__main__.__spec__"
msgstr "__main__.__spec__"

#: ../../reference/import.rst:907
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""
"В зависимости от того, как инициализируется :mod:`__main__`, для ``__main__."
"__spec__`` устанавливается соответствующее значение или значение ``None``."

#: ../../reference/import.rst:910
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""
"Когда Python запускается с опцией :option:`-m`, ``__spec__`` устанавливается "
"на спецификацию соответствующего модуля или пакета. ``__spec__`` также "
"заполняется, когда модуль ``__main__`` загружается как часть выполнения "
"каталога, zip-файла или другой записи :data:`sys.path`."

#: ../../reference/import.rst:915
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""
"В :ref:`остальных случаях <using-on-interface-options>` ``__main__."
"__spec__`` устанавливается в ``None``, так как код, используемый для "
"заполнения :mod:`__main__`, не соответствует напрямую с импортируемым "
"модулем:"

#: ../../reference/import.rst:919
msgid "interactive prompt"
msgstr "интерактивная подсказка"

#: ../../reference/import.rst:920
msgid ":option:`-c` option"
msgstr ":option:`-c` опция"

#: ../../reference/import.rst:921
msgid "running from stdin"
msgstr "запуск со стандартного ввода"

#: ../../reference/import.rst:922
msgid "running directly from a source or bytecode file"
msgstr "запуск непосредственно из исходного файла или файла байт-кода"

#: ../../reference/import.rst:924
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""
"Обратите внимание, что ``__main__.__spec__`` в последнем случае всегда имеет "
"значение ``None``, *даже если* файл технически может быть импортирован "
"напрямую как модуль. Используйте переключатель :option:`-m`, если в :mod:"
"`__main__` требуются действительные метаданные модуля."

#: ../../reference/import.rst:929
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""
"Также обратите внимание, что даже если ``__main__`` соответствует "
"импортируемому модулю и ``__main__.__spec__`` установлен соответствующим "
"образом, они все равно считаются *отдельными* модулями. Это связано с тем, "
"что блоки, защищенные проверками ``if __name__ == \"__main__\":``, "
"выполняются только тогда, когда модуль используется для заполнения "
"пространства имен ``__main__``, а не во время обычного импорта."

#: ../../reference/import.rst:937
msgid "References"
msgstr "References"

#: ../../reference/import.rst:939
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <https://www.python.org/doc/essays/"
"packages/>`_ is still available to read, although some details have changed "
"since the writing of that document."
msgstr ""
"Механизм импорта значительно изменился с момента появления Python. Исходная "
"`спецификация пакетов <https://www.python.org/doc/essays/packages/>`_ по-"
"прежнему доступна для чтения, хотя некоторые детали изменились с момента "
"написания этого документа."

#: ../../reference/import.rst:944
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""
"Исходная спецификация :data:`sys.meta_path` была :pep:`302` с последующим "
"расширением :pep:`420`."

#: ../../reference/import.rst:947
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`!find_loader` protocol as "
"an alternative to :meth:`!find_module`."
msgstr ""
":pep:`420` представил :term:`пакеты пространства имен <пакет пространства "
"имен>` для Python 3.3. :pep:`420` также представил протокол :meth:`!"
"find_loader` как альтернативу :meth:`!find_module`."

#: ../../reference/import.rst:951
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""
":pep:`366` описывает добавление атрибута ``__package__`` для явного "
"относительного импорта в основные модули."

#: ../../reference/import.rst:954
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""
":pep:`328` представил абсолютный и явный относительный импорт и "
"первоначально предложил ``__name__`` для семантики. :pep:`366` в конечном "
"итоге будет указывать для ``__package__``."

#: ../../reference/import.rst:958
msgid ":pep:`338` defines executing modules as scripts."
msgstr ":pep:`338` определяет исполняемые модули как сценарии."

#: ../../reference/import.rst:960
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""
":pep:`451` добавляет инкапсуляцию состояния импорта каждого модуля в "
"объектах спецификации. Это также перекладывает большую часть стандартных "
"обязанностей грузчиков на импортное оборудование. Эти изменения позволяют "
"отказаться от поддержки некоторых API в системе импорта, а также добавить "
"новые методы для средств поиска и загрузчиков."

#: ../../reference/import.rst:967
msgid "Footnotes"
msgstr "Сноски"

#: ../../reference/import.rst:968
msgid "See :class:`types.ModuleType`."
msgstr "См. :class:`types.ModuleType`."

#: ../../reference/import.rst:970
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""
"Реализация importlib позволяет избежать прямого использования возвращаемого "
"значения. Вместо этого он получает объект модуля, просматривая имя модуля в :"
"data:`sys.modules`. Косвенным эффектом этого является то, что "
"импортированный модуль может заменить себя в :data:`sys.modules`. Это "
"поведение, зависящее от реализации, и не гарантируется, что оно будет "
"работать в других реализациях Python."

#: ../../reference/import.rst:8
msgid "import machinery"
msgstr "import machinery"

#: ../../reference/import.rst:64 ../../reference/import.rst:95
#: ../../reference/import.rst:131
msgid "package"
msgstr "пакет"

#: ../../reference/import.rst:95
msgid "regular"
msgstr "regular"

#: ../../reference/import.rst:131
msgid "namespace"
msgstr "пространство имён"

#: ../../reference/import.rst:131
msgid "portion"
msgstr "порция"

#: ../../reference/import.rst:177
msgid "sys.modules"
msgstr "sys.modules"

#: ../../reference/import.rst:212 ../../reference/import.rst:278
msgid "finder"
msgstr "искатель"

#: ../../reference/import.rst:212
msgid "loader"
msgstr "загрузчик"

#: ../../reference/import.rst:212
msgid "module spec"
msgstr "спецификация модуля"

#: ../../reference/import.rst:251
msgid "import hooks"
msgstr "import hooks"

#: ../../reference/import.rst:251
msgid "meta hooks"
msgstr "мета-крючки"

#: ../../reference/import.rst:251
msgid "path hooks"
msgstr "крючки для пути"

#: ../../reference/import.rst:251
msgid "hooks"
msgstr "hooks"

#: ../../reference/import.rst:251
msgid "import"
msgstr "импорт"

#: ../../reference/import.rst:251
msgid "meta"
msgstr "meta"

#: ../../reference/import.rst:251
msgid "path"
msgstr "путь"

#: ../../reference/import.rst:278
msgid "sys.meta_path"
msgstr "sys.meta_path"

#: ../../reference/import.rst:278
msgid "find_spec"
msgstr "find_spec"

#: ../../reference/import.rst:638
msgid "path based finder"
msgstr "искатель в путях"

#: ../../reference/import.rst:687
msgid "sys.path"
msgstr "sys.path"

#: ../../reference/import.rst:687
msgid "sys.path_hooks"
msgstr "sys.path_hooks"

#: ../../reference/import.rst:687
msgid "sys.path_importer_cache"
msgstr "sys.path_importer_cache"

#: ../../reference/import.rst:687
msgid "PYTHONPATH"
msgstr "PYTHONPATH"
