# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/call.rst:6
msgid "Call Protocol"
msgstr "Протокол вызова"

#: ../../c-api/call.rst:8
msgid ""
"CPython supports two different calling protocols: *tp_call* and vectorcall."
msgstr ""
"CPython поддерживает два различных протокола вызова: *tp_call* и vectorcall "
"(векторный вызов)."

#: ../../c-api/call.rst:12
msgid "The *tp_call* Protocol"
msgstr "Протокол *tp_call*"

#: ../../c-api/call.rst:14
msgid ""
"Instances of classes that set :c:member:`~PyTypeObject.tp_call` are "
"callable. The signature of the slot is::"
msgstr ""
"Экземпляры классов, которые задают :c:member:`~PyTypeObject.tp_call`, "
"доступны для вызова. Сигнатура слота - это::"

#: ../../c-api/call.rst:19
msgid ""
"A call is made using a tuple for the positional arguments and a dict for the "
"keyword arguments, similarly to ``callable(*args, **kwargs)`` in Python "
"code. *args* must be non-NULL (use an empty tuple if there are no arguments) "
"but *kwargs* may be *NULL* if there are no keyword arguments."
msgstr ""
"Вызов выполняется с использованием кортежа для позиционных аргументов и "
"словаря для ключевых аргументов, аналогично ``callable(*args, **kwargs)`` в "
"коде Python. *args* должно быть ненулевым (используйте пустой кортеж, если "
"нет аргументов), но *kwargs* может быть *NULL*, если нет аргументов "
"ключевого слова."

#: ../../c-api/call.rst:25
msgid ""
"This convention is not only used by *tp_call*: :c:member:`~PyTypeObject."
"tp_new` and :c:member:`~PyTypeObject.tp_init` also pass arguments this way."
msgstr ""
"Это соглашение используется не только *tp_call*: :c:member:`~PyTypeObject."
"tp_new` и :c:member:`~PyTypeObject.tp_init`, которые также передают "
"аргументы таким образом."

#: ../../c-api/call.rst:29
msgid ""
"To call an object, use :c:func:`PyObject_Call` or another :ref:`call API "
"<capi-call>`."
msgstr ""
"Чтобы вызвать объект, используйте :c:func:`PyObject_Call` или другой :ref:"
"`вызов API 1`."

#: ../../c-api/call.rst:36
msgid "The Vectorcall Protocol"
msgstr "Протокол векторного вызова"

#: ../../c-api/call.rst:40
msgid ""
"The vectorcall protocol was introduced in :pep:`590` as an additional "
"protocol for making calls more efficient."
msgstr ""
"Протокол vectorcall был представлен в :pep:`590` в качестве дополнительного "
"протокола для повышения эффективности вызовов."

#: ../../c-api/call.rst:43
msgid ""
"As rule of thumb, CPython will prefer the vectorcall for internal calls if "
"the callable supports it. However, this is not a hard rule. Additionally, "
"some third-party extensions use *tp_call* directly (rather than using :c:"
"func:`PyObject_Call`). Therefore, a class supporting vectorcall must also "
"implement :c:member:`~PyTypeObject.tp_call`. Moreover, the callable must "
"behave the same regardless of which protocol is used. The recommended way to "
"achieve this is by setting :c:member:`~PyTypeObject.tp_call` to :c:func:"
"`PyVectorcall_Call`. This bears repeating:"
msgstr ""
"Как правило, CPython предпочитает vectorcall для внутренних вызовов, если "
"вызываемый объект поддерживает его. Однако это не является жестким правилом. "
"Кроме того, некоторые сторонние расширения используют *tp_call* напрямую "
"(вместо использования :c:func:`PyObject_Call`). Следовательно, класс, "
"поддерживающий vectorcall, также должен реализовывать :c:member:"
"`~PyTypeObject.tp_call`. Более того, вызываемый объект должен вести себя "
"одинаково независимо от того, какой протокол используется. Рекомендуемый "
"способ добиться этого - установить для :c:member:`~PyTypeObject.tp_call` "
"значение :c:func:`PyVectorcall_Call`. Это следует повторить:"

#: ../../c-api/call.rst:57
msgid ""
"A class supporting vectorcall **must** also implement :c:member:"
"`~PyTypeObject.tp_call` with the same semantics."
msgstr ""
"Класс, поддерживающий vectorcall, должен также реализовывать :c:member:"
"`~PyTypeObject.tp_call` с той же семантикой."

#: ../../c-api/call.rst:60
msgid ""
"A class should not implement vectorcall if that would be slower than "
"*tp_call*. For example, if the callee needs to convert the arguments to an "
"args tuple and kwargs dict anyway, then there is no point in implementing "
"vectorcall."
msgstr ""
"Класс не должен реализовывать векторный вызов, если он будет медленнее, чем "
"*tp_call*. Например, если вызываемому объекту все равно необходимо "
"преобразовать аргументы в кортеж args и словарь kwargs, тогда нет смысла "
"реализовывать векторный вызов."

#: ../../c-api/call.rst:65
msgid ""
"Classes can implement the vectorcall protocol by enabling the :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag and setting :c:member:`~PyTypeObject."
"tp_vectorcall_offset` to the offset inside the object structure where a "
"*vectorcallfunc* appears. This is a pointer to a function with the following "
"signature:"
msgstr ""

#: ../../c-api/call.rst:73
msgid "*callable* is the object being called."
msgstr "*callable* — вызываемый объект."

#: ../../c-api/call.rst:75
msgid ""
"*args* is a C array consisting of the positional arguments followed by the"
msgstr ""
"*args* — это массив C, состоящий из позиционных аргументов, за которыми "
"следует"

#: ../../c-api/call.rst:75
msgid ""
"values of the keyword arguments. This can be *NULL* if there are no "
"arguments."
msgstr ""
"значения аргументов ключевого слова. Это может быть *NULL*, если аргументов "
"нет."

#: ../../c-api/call.rst:79
msgid "*nargsf* is the number of positional arguments plus possibly the"
msgstr "*nargsf* — это количество позиционных аргументов плюс, возможно,"

#: ../../c-api/call.rst:78
msgid ""
":const:`PY_VECTORCALL_ARGUMENTS_OFFSET` flag. To get the actual number of "
"positional arguments from *nargsf*, use :c:func:`PyVectorcall_NARGS`."
msgstr ""

#: ../../c-api/call.rst:85
msgid "*kwnames* is a tuple containing the names of the keyword arguments;"
msgstr "*kwnames* — кортеж, содержащий имена аргументов ключевого слова;"

#: ../../c-api/call.rst:82
msgid ""
"in other words, the keys of the kwargs dict. These names must be strings "
"(instances of ``str`` or a subclass) and they must be unique. If there are "
"no keyword arguments, then *kwnames* can instead be *NULL*."
msgstr ""
"другими словами, ключи дикта кваргов. Эти имена должны быть строками "
"(экземпляры ``str`` или подкласса) и должны быть уникальными. Если аргументы-"
"ключевые слова отсутствуют, то *kwnames* может иметь значение *NULL*."

#: ../../c-api/call.rst:89
msgid ""
"If this flag is set in a vectorcall *nargsf* argument, the callee is allowed "
"to temporarily change ``args[-1]``. In other words, *args* points to "
"argument 1 (not 0) in the allocated vector. The callee must restore the "
"value of ``args[-1]`` before returning."
msgstr ""
"Если этот флаг установлен в аргументе векторного вызова *nargsf*, "
"вызываемому абоненту разрешено временно изменять ``args[-1]``. Другими "
"словами, *args* указывает на аргумент 1 (а не 0) в выделенном векторе. "
"Вызываемая сторона должна восстановить значение args[-1] перед возвратом."

#: ../../c-api/call.rst:94
msgid ""
"For :c:func:`PyObject_VectorcallMethod`, this flag means instead that "
"``args[0]`` may be changed."
msgstr ""
"Для :c:func:` PyObj ect_VectorcallMethod` этот флаг означает, что вместо "
"этого можно изменить ``args[0]``."

#: ../../c-api/call.rst:97
msgid ""
"Whenever they can do so cheaply (without additional allocation), callers are "
"encouraged to use :const:`PY_VECTORCALL_ARGUMENTS_OFFSET`. Doing so will "
"allow callables such as bound methods to make their onward calls (which "
"include a prepended *self* argument) very efficiently."
msgstr ""

#: ../../c-api/call.rst:102
msgid ""
"To call an object that implements vectorcall, use a :ref:`call API <capi-"
"call>` function as with any other callable. :c:func:`PyObject_Vectorcall` "
"will usually be most efficient."
msgstr ""
"Чтобы вызвать объект, реализующий векторный вызов, используйте функцию :ref:"
"`call API <capi-call>`, как и для любого другого вызываемого объекта. :c:"
"func:` PyObj ect_Vectorcall` обычно будет наиболее эффективным."

#: ../../c-api/call.rst:109
msgid ""
"In CPython 3.8, the vectorcall API and related functions were available "
"provisionally under names with a leading underscore: "
"``_PyObject_Vectorcall``, ``_Py_TPFLAGS_HAVE_VECTORCALL``, "
"``_PyObject_VectorcallMethod``, ``_PyVectorcall_Function``, "
"``_PyObject_CallOneArg``, ``_PyObject_CallMethodNoArgs``, "
"``_PyObject_CallMethodOneArg``. Additionally, ``PyObject_VectorcallDict`` "
"was available as ``_PyObject_FastCallDict``. The old names are still defined "
"as aliases of the new, non-underscored names."
msgstr ""
"В CPython 3.8 API векторного вызова и связанные с ним функции были временно "
"доступны под именами с подчеркиванием в начале: ``_PyObject_Vectorcall``, "
"``_Py_TPFLAGS_HAVE_VECTORCALL``, ``_PyObject_VectorcallMethod``, "
"``_PyVectorcall_Function``, ``_PyObject_CallOneArg``, "
"``_PyObject_CallMethodNoArgs``, ``_PyObject_CallMethodOneArg``. Кроме того, "
"PyObject_VectorcallDict был доступен как _PyObject_FastCallDict. Старые "
"имена по-прежнему определяются как псевдонимы новых, неподчеркнутых имен."

#: ../../c-api/call.rst:121
msgid "Recursion Control"
msgstr "Управление рекурсией"

#: ../../c-api/call.rst:123
msgid ""
"When using *tp_call*, callees do not need to worry about :ref:`recursion "
"<recursion>`: CPython uses :c:func:`Py_EnterRecursiveCall` and :c:func:"
"`Py_LeaveRecursiveCall` for calls made using *tp_call*."
msgstr ""
"При использовании *tp_call* вызываемым объектам не нужно беспокоиться о :ref:"
"`recursion <recursion>`: CPython использует :c:func:`Py_EnterRecursiveCall` "
"и :c:func:`Py_LeaveRecursiveCall` для вызовов, выполненных с использованием "
"*tp_call*."

#: ../../c-api/call.rst:128
msgid ""
"For efficiency, this is not the case for calls done using vectorcall: the "
"callee should use *Py_EnterRecursiveCall* and *Py_LeaveRecursiveCall* if "
"needed."
msgstr ""
"В целях эффективности это не относится к вызовам, выполняемым с "
"использованием векторного вызова: вызываемый должен использовать "
"*Py_EnterRecursiveCall* и *Py_LeaveRecursiveCall*, если необходимо."

#: ../../c-api/call.rst:134
msgid "Vectorcall Support API"
msgstr "API поддержки Vectorcall"

#: ../../c-api/call.rst:138
msgid ""
"Given a vectorcall *nargsf* argument, return the actual number of arguments. "
"Currently equivalent to::"
msgstr ""
"Учитывая аргумент векторного вызова *nargsf*, вернёт фактическое количество "
"аргументов. В настоящее время эквивалентно::"

#: ../../c-api/call.rst:144
msgid ""
"However, the function ``PyVectorcall_NARGS`` should be used to allow for "
"future extensions."
msgstr ""
"Однако функцию PyVectorcall_NARGS следует использовать для возможности "
"будущих расширений."

#: ../../c-api/call.rst:151
msgid ""
"If *op* does not support the vectorcall protocol (either because the type "
"does not or because the specific instance does not), return *NULL*. "
"Otherwise, return the vectorcall function pointer stored in *op*. This "
"function never raises an exception."
msgstr ""
"Если *op* не поддерживает протокол векторного вызова (либо из-за того, что "
"тип не поддерживает, либо из-за того, что конкретный экземпляр не "
"поддерживает), вернет *NULL*. В противном случае вернет указатель функции "
"векторного вызова, хранящийся в *op*. Эта функция никогда не вызывает "
"исключение. ."

#: ../../c-api/call.rst:156
msgid ""
"This is mostly useful to check whether or not *op* supports vectorcall, "
"which can be done by checking ``PyVectorcall_Function(op) != NULL``."
msgstr ""
"Чаще всего это полезно для проверки того, поддерживает ли *op* векторный "
"вызов, что можно сделать, проверив ``PyVectorcall_Function(op) != NULL``."

#: ../../c-api/call.rst:163
msgid ""
"Call *callable*'s :c:type:`vectorcallfunc` with positional and keyword "
"arguments given in a tuple and dict, respectively."
msgstr ""
"Вызовите *callable* :c:type:`vectorcallfunc` с позиционными и ключевыми "
"аргументами, заданными в кортеже и dict соответственно."

#: ../../c-api/call.rst:166
msgid ""
"This is a specialized function, intended to be put in the :c:member:"
"`~PyTypeObject.tp_call` slot or be used in an implementation of ``tp_call``. "
"It does not check the :const:`Py_TPFLAGS_HAVE_VECTORCALL` flag and it does "
"not fall back to ``tp_call``."
msgstr ""

#: ../../c-api/call.rst:177
msgid "Object Calling API"
msgstr "API вызова объектов"

#: ../../c-api/call.rst:179
msgid ""
"Various functions are available for calling a Python object. Each converts "
"its arguments to a convention supported by the called object – either "
"*tp_call* or vectorcall. In order to do as little conversion as possible, "
"pick one that best fits the format of data you have available."
msgstr ""
"Для вызова объекта Python доступны различные функции. Каждая из них "
"преобразует свои аргументы в соответствие с соглашением, поддерживаемым "
"вызываемым объектом — либо *tp_call*, либо Vectorcall. Чтобы выполнить как "
"можно меньше преобразований, выберите тот, который лучше всего соответствует "
"формату ваших данных. есть в наличии."

#: ../../c-api/call.rst:185
msgid ""
"The following table summarizes the available functions; please see "
"individual documentation for details."
msgstr ""
"В следующей таблице приведены доступные функции; подробности см. в отдельной "
"документации."

#: ../../c-api/call.rst:189
msgid "Function"
msgstr "Функция"

#: ../../c-api/call.rst:189
msgid "callable"
msgstr "вызываемый объект"

#: ../../c-api/call.rst:189
msgid "args"
msgstr "args"

#: ../../c-api/call.rst:189
msgid "kwargs"
msgstr "kwargs"

#: ../../c-api/call.rst:191
msgid ":c:func:`PyObject_Call`"
msgstr ":c:func:`PyObject_Call`"

#: ../../c-api/call.rst:191 ../../c-api/call.rst:193 ../../c-api/call.rst:195
#: ../../c-api/call.rst:197 ../../c-api/call.rst:199 ../../c-api/call.rst:203
#: ../../c-api/call.rst:211 ../../c-api/call.rst:213
msgid "``PyObject *``"
msgstr "``PyObject *``"

#: ../../c-api/call.rst:191
msgid "tuple"
msgstr "кортеж"

#: ../../c-api/call.rst:191 ../../c-api/call.rst:213
msgid "dict/``NULL``"
msgstr "dict/``NULL``"

#: ../../c-api/call.rst:193
msgid ":c:func:`PyObject_CallNoArgs`"
msgstr ":c:func:`PyObject_CallNoArgs`"

#: ../../c-api/call.rst:193 ../../c-api/call.rst:195 ../../c-api/call.rst:197
#: ../../c-api/call.rst:199 ../../c-api/call.rst:201 ../../c-api/call.rst:203
#: ../../c-api/call.rst:205 ../../c-api/call.rst:207 ../../c-api/call.rst:209
msgid "---"
msgstr "---"

#: ../../c-api/call.rst:195
msgid ":c:func:`PyObject_CallOneArg`"
msgstr ":c:func:`PyObject_CallOneArg`"

#: ../../c-api/call.rst:195 ../../c-api/call.rst:209
msgid "1 object"
msgstr "1 объект"

#: ../../c-api/call.rst:197
msgid ":c:func:`PyObject_CallObject`"
msgstr ":c:func:`PyObject_CallObject`"

#: ../../c-api/call.rst:197
msgid "tuple/``NULL``"
msgstr "tuple/``NULL``"

#: ../../c-api/call.rst:199
msgid ":c:func:`PyObject_CallFunction`"
msgstr ":c:func:`PyObject_CallFunction`"

#: ../../c-api/call.rst:199 ../../c-api/call.rst:201
msgid "format"
msgstr "формат"

#: ../../c-api/call.rst:201
msgid ":c:func:`PyObject_CallMethod`"
msgstr ":c:func:`PyObject_CallMethod`"

#: ../../c-api/call.rst:201
msgid "obj + ``char*``"
msgstr "obj + ``char*``"

#: ../../c-api/call.rst:203
msgid ":c:func:`PyObject_CallFunctionObjArgs`"
msgstr ":c:func:`PyObject_CallFunctionObjArgs`"

#: ../../c-api/call.rst:203 ../../c-api/call.rst:205
msgid "variadic"
msgstr "переменный"

#: ../../c-api/call.rst:205
msgid ":c:func:`PyObject_CallMethodObjArgs`"
msgstr ":c:func:`PyObject_CallMethodObjArgs`"

#: ../../c-api/call.rst:205 ../../c-api/call.rst:207 ../../c-api/call.rst:209
msgid "obj + name"
msgstr "obj + name"

#: ../../c-api/call.rst:207
msgid ":c:func:`PyObject_CallMethodNoArgs`"
msgstr ":c:func:`PyObject_CallMethodNoArgs`"

#: ../../c-api/call.rst:209
msgid ":c:func:`PyObject_CallMethodOneArg`"
msgstr ":c:func:`PyObject_CallMethodOneArg`"

#: ../../c-api/call.rst:211
msgid ":c:func:`PyObject_Vectorcall`"
msgstr ":c:func:`PyObject_Vectorcall`"

#: ../../c-api/call.rst:211 ../../c-api/call.rst:213 ../../c-api/call.rst:215
msgid "vectorcall"
msgstr "векторный вызов"

#: ../../c-api/call.rst:213
msgid ":c:func:`PyObject_VectorcallDict`"
msgstr ":c:func:`PyObject_VectorcallDict`"

#: ../../c-api/call.rst:215
msgid ":c:func:`PyObject_VectorcallMethod`"
msgstr ":c:func:`PyObject_VectorcallMethod`"

#: ../../c-api/call.rst:215
msgid "arg + name"
msgstr "arg + name"

#: ../../c-api/call.rst:221
msgid ""
"Call a callable Python object *callable*, with arguments given by the tuple "
"*args*, and named arguments given by the dictionary *kwargs*."
msgstr ""
"Вызовите вызываемый объект Python *callable* с аргументами, заданными "
"кортежем *args*, и именованными аргументами, заданными словарем *kwargs*."

#: ../../c-api/call.rst:224
msgid ""
"*args* must not be *NULL*; use an empty tuple if no arguments are needed. If "
"no named arguments are needed, *kwargs* can be *NULL*."
msgstr ""
"*args* не должно быть *NULL*; используйте пустой кортеж, если аргументы не "
"нужны, *kwargs* может быть *NULL*."

#: ../../c-api/call.rst:227 ../../c-api/call.rst:239 ../../c-api/call.rst:250
#: ../../c-api/call.rst:261 ../../c-api/call.rst:273 ../../c-api/call.rst:293
#: ../../c-api/call.rst:312 ../../c-api/call.rst:326 ../../c-api/call.rst:335
#: ../../c-api/call.rst:347 ../../c-api/call.rst:360 ../../c-api/call.rst:394
msgid ""
"Return the result of the call on success, or raise an exception and return "
"*NULL* on failure."
msgstr ""
"Вернёт результат вызова в случае успеха или создаст исключение и вернёт "
"*NULL* в случае неудачи."

#: ../../c-api/call.rst:230
msgid ""
"This is the equivalent of the Python expression: ``callable(*args, "
"**kwargs)``."
msgstr "Это эквивалент выражения Python: ``callable(*args, **kwargs)``."

#: ../../c-api/call.rst:236
msgid ""
"Call a callable Python object *callable* without any arguments. It is the "
"most efficient way to call a callable Python object without any argument."
msgstr ""
"Вызов вызываемого объекта Python *callable* без каких-либо аргументов. Это "
"наиболее эффективный способ вызвать вызываемый объект Python без каких-либо "
"аргументов."

#: ../../c-api/call.rst:247
msgid ""
"Call a callable Python object *callable* with exactly 1 positional argument "
"*arg* and no keyword arguments."
msgstr ""
"Вызовите вызываемый объект Python *callable* ровно с одним позиционным "
"аргументом *arg* и без аргументов ключевого слова."

#: ../../c-api/call.rst:258
msgid ""
"Call a callable Python object *callable*, with arguments given by the tuple "
"*args*.  If no arguments are needed, then *args* can be *NULL*."
msgstr ""
"Вызов вызываемого объекта Python *callable* с аргументами, заданными "
"кортежем *args*. Если аргументы не требуются, то *args* может иметь значение "
"*NULL*."

#: ../../c-api/call.rst:264 ../../c-api/call.rst:276
msgid "This is the equivalent of the Python expression: ``callable(*args)``."
msgstr "Это эквивалент выражения Python: ``callable(*args)``."

#: ../../c-api/call.rst:269
msgid ""
"Call a callable Python object *callable*, with a variable number of C "
"arguments. The C arguments are described using a :c:func:`Py_BuildValue` "
"style format string.  The format can be *NULL*, indicating that no arguments "
"are provided."
msgstr ""
"Вызов вызываемого объекта Python *callable* с переменным количеством "
"аргументов C. Аргументы C описываются с использованием строки формата стиля :"
"c:func:`Py_BuildValue`. Формат может быть *NULL*, что указывает на "
"отсутствие аргументов."

#: ../../c-api/call.rst:278
msgid ""
"Note that if you only pass :c:expr:`PyObject *` args, :c:func:"
"`PyObject_CallFunctionObjArgs` is a faster alternative."
msgstr ""
"Обратите внимание: если вы передаете только :c:expr:` PyObj ect *` args, :c:"
"func:` PyObj ect_CallFunctionObjArgs` будет более быстрой альтернативой."

#: ../../c-api/call.rst:281
msgid "The type of *format* was changed from ``char *``."
msgstr "Тип *format* был изменен с ``char *``."

#: ../../c-api/call.rst:287
msgid ""
"Call the method named *name* of object *obj* with a variable number of C "
"arguments.  The C arguments are described by a :c:func:`Py_BuildValue` "
"format string that should produce a tuple."
msgstr ""
"Вызовите метод с именем *name* объекта *obj* с переменным количеством "
"аргументов C. Аргументы C описываются строкой формата :c:func:"
"`Py_BuildValue`, которая должна создавать кортеж."

#: ../../c-api/call.rst:291
msgid "The format can be *NULL*, indicating that no arguments are provided."
msgstr "Формат может быть *NULL*, что указывает на отсутствие аргументов."

#: ../../c-api/call.rst:296
msgid ""
"This is the equivalent of the Python expression: ``obj.name(arg1, "
"arg2, ...)``."
msgstr "Это эквивалент выражения Python: ``obj.name(arg1, arg2, ...)``."

#: ../../c-api/call.rst:299
msgid ""
"Note that if you only pass :c:expr:`PyObject *` args, :c:func:"
"`PyObject_CallMethodObjArgs` is a faster alternative."
msgstr ""
"Обратите внимание: если вы передаете только :c:expr:` PyObj ect *` args, :c:"
"func:` PyObj ect_CallMethodObjArgs` будет более быстрой альтернативой."

#: ../../c-api/call.rst:302
msgid "The types of *name* and *format* were changed from ``char *``."
msgstr "Типы *name* и *format* были изменены с ``char *``."

#: ../../c-api/call.rst:308
msgid ""
"Call a callable Python object *callable*, with a variable number of :c:expr:"
"`PyObject *` arguments.  The arguments are provided as a variable number of "
"parameters followed by *NULL*."
msgstr ""
"Вызовите вызываемый объект Python *callable* с переменным числом аргументов :"
"c:expr:` PyObject *`. Аргументы предоставляются в виде переменного числа "
"параметров, за которыми следует *NULL*."

#: ../../c-api/call.rst:315
msgid ""
"This is the equivalent of the Python expression: ``callable(arg1, "
"arg2, ...)``."
msgstr "Это эквивалент выражения Python: ``callable(arg1, arg2, ...)``."

#: ../../c-api/call.rst:321
msgid ""
"Call a method of the Python object *obj*, where the name of the method is "
"given as a Python string object in *name*.  It is called with a variable "
"number of :c:expr:`PyObject *` arguments.  The arguments are provided as a "
"variable number of parameters followed by *NULL*."
msgstr ""
"Вызовите метод объекта Python *obj*, где имя метода задается как строковый "
"объект Python в *name*. Он вызывается с переменным количеством аргументов :c:"
"expr:` PyObject *`. Аргументы предоставляются в виде переменного числа "
"параметров, за которыми следует *NULL*."

#: ../../c-api/call.rst:332
msgid ""
"Call a method of the Python object *obj* without arguments, where the name "
"of the method is given as a Python string object in *name*."
msgstr ""
"Вызов метода Python-объекта *obj* без аргументов, где имя метода задано как "
"строковый объект Python в *name*."

#: ../../c-api/call.rst:343
msgid ""
"Call a method of the Python object *obj* with a single positional argument "
"*arg*, where the name of the method is given as a Python string object in "
"*name*."
msgstr ""
"Вызовите метод объекта Python *obj* с одним позиционным аргументом *arg*, "
"где имя метода задается как строковый объект Python в *name*."

#: ../../c-api/call.rst:355
msgid ""
"Call a callable Python object *callable*. The arguments are the same as for :"
"c:type:`vectorcallfunc`. If *callable* supports vectorcall_, this directly "
"calls the vectorcall function stored in *callable*."
msgstr ""
"Вызовите вызываемый объект Python *callable*. Аргументы те же, что и для :c:"
"type:`vectorcallfunc`. Если *callable* поддерживает векторный вызов_, это "
"напрямую вызывает функцию векторного вызова, хранящуюся в *callable*."

#: ../../c-api/call.rst:367
msgid ""
"Call *callable* with positional arguments passed exactly as in the "
"vectorcall_ protocol, but with keyword arguments passed as a dictionary "
"*kwdict*. The *args* array contains only the positional arguments."
msgstr ""
"Вызов *callable* с позиционными аргументами, передаваемыми точно так же, как "
"в протоколе Vectorcall_, но с ключевыми аргументами, передаваемыми как "
"словарь *kwdict*. Массив *args* содержит только позиционные аргументы."

#: ../../c-api/call.rst:371
msgid ""
"Regardless of which protocol is used internally, a conversion of arguments "
"needs to be done. Therefore, this function should only be used if the caller "
"already has a dictionary ready to use for the keyword arguments, but not a "
"tuple for the positional arguments."
msgstr ""
"Независимо от того, какой протокол используется внутри, необходимо выполнить "
"преобразование аргументов. Поэтому эту функцию следует использовать только в "
"том случае, если у вызывающей стороны уже есть готовый словарь для ключевых "
"аргументов, но не кортеж для позиционных аргументов."

#: ../../c-api/call.rst:381
msgid ""
"Call a method using the vectorcall calling convention. The name of the "
"method is given as a Python string *name*. The object whose method is called "
"is *args[0]*, and the *args* array starting at *args[1]* represents the "
"arguments of the call. There must be at least one positional argument. "
"*nargsf* is the number of positional arguments including *args[0]*, plus :"
"const:`PY_VECTORCALL_ARGUMENTS_OFFSET` if the value of ``args[0]`` may "
"temporarily be changed. Keyword arguments can be passed just like in :c:func:"
"`PyObject_Vectorcall`."
msgstr ""

#: ../../c-api/call.rst:390
msgid ""
"If the object has the :const:`Py_TPFLAGS_METHOD_DESCRIPTOR` feature, this "
"will call the unbound method object with the full *args* vector as arguments."
msgstr ""

#: ../../c-api/call.rst:401
msgid "Call Support API"
msgstr "API поддержки вызовов"

#: ../../c-api/call.rst:405
msgid ""
"Determine if the object *o* is callable.  Return ``1`` if the object is "
"callable and ``0`` otherwise.  This function always succeeds."
msgstr ""
"Определите, является ли объект *o* вызываемым. Возвращайте ``1``, если "
"объект доступен для вызова, и ``0`` в противном случае. Эта функция всегда "
"завершается успешно."
