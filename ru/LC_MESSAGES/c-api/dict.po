# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/dict.rst:6
msgid "Dictionary Objects"
msgstr "Объекты словаря"

#: ../../c-api/dict.rst:13
msgid ""
"This subtype of :c:type:`PyObject` represents a Python dictionary object."
msgstr "Этот подтип :c:type:`PyObject` представляет объект словаря Python."

#: ../../c-api/dict.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python dictionary "
"type.  This is the same object as :class:`dict` in the Python layer."
msgstr ""
"Этот экземпляр :c:type:`PyTypeObject` представляет тип словаря Python. Это "
"тот же объект, что и :class:`dict` на уровне Python."

#: ../../c-api/dict.rst:24
msgid ""
"Return true if *p* is a dict object or an instance of a subtype of the dict "
"type.  This function always succeeds."
msgstr ""
"Возвращайте true, если *p* является объектом dict или экземпляром подтипа "
"типа dict. Эта функция всегда завершается успешно."

#: ../../c-api/dict.rst:30
msgid ""
"Return true if *p* is a dict object, but not an instance of a subtype of the "
"dict type.  This function always succeeds."
msgstr ""
"Возвращайте true, если *p* является объектом dict, но не экземпляром подтипа "
"типа dict. Эта функция всегда завершается успешно."

#: ../../c-api/dict.rst:36
msgid "Return a new empty dictionary, or ``NULL`` on failure."
msgstr "Вернуть новый пустой словарь или ``NULL`` в случае ошибки."

#: ../../c-api/dict.rst:41
msgid ""
"Return a :class:`types.MappingProxyType` object for a mapping which enforces "
"read-only behavior.  This is normally used to create a view to prevent "
"modification of the dictionary for non-dynamic class types."
msgstr ""
"Возвращает объект :class:`types.MappingProxyType` для сопоставления, которое "
"обеспечивает поведение только для чтения. Обычно это используется для "
"создания представления, предотвращающего изменение словаря для "
"нединамических типов классов."

#: ../../c-api/dict.rst:48
msgid "Empty an existing dictionary of all key-value pairs."
msgstr "Очистите существующий словарь от всех пар ключ-значение."

#: ../../c-api/dict.rst:53
msgid ""
"Determine if dictionary *p* contains *key*.  If an item in *p* is matches "
"*key*, return ``1``, otherwise return ``0``.  On error, return ``-1``. This "
"is equivalent to the Python expression ``key in p``."
msgstr ""
"Определите, содержит ли словарь *p* *key*. Если элемент в *p* соответствует "
"*key*, верните ``1``, в противном случае верните ``0``. В случае ошибки "
"верните ``-1``. Это эквивалентно выражению Python ``key in p``."

#: ../../c-api/dict.rst:60
msgid "Return a new dictionary that contains the same key-value pairs as *p*."
msgstr "Верните новый словарь, содержащий те же пары ключ-значение, что и *p*."

#: ../../c-api/dict.rst:65
msgid ""
"Insert *val* into the dictionary *p* with a key of *key*.  *key* must be :"
"term:`hashable`; if it isn't, :exc:`TypeError` will be raised. Return ``0`` "
"on success or ``-1`` on failure.  This function *does not* steal a reference "
"to *val*."
msgstr ""
"Вставьте *val* в словарь *p* с ключом *key*. *ключ* должен быть :term:"
"`hashable`; если это не так, будет выдано :exc:`TypeError`. Возвращайте "
"``0`` в случае успеха или ``-1`` в случае неудачи. Эта функция *не* крадет "
"ссылку на *val*."

#: ../../c-api/dict.rst:73
msgid ""
"This is the same as :c:func:`PyDict_SetItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Это то же самое, что и :c:func:`PyDict_SetItem`, но *key* указывается как :c:"
"expr:`const char*` строка байтов в кодировке UTF-8, а не как :c:expr:"
"`PyObject* `."

#: ../../c-api/dict.rst:80
msgid ""
"Remove the entry in dictionary *p* with key *key*. *key* must be :term:"
"`hashable`; if it isn't, :exc:`TypeError` is raised. If *key* is not in the "
"dictionary, :exc:`KeyError` is raised. Return ``0`` on success or ``-1`` on "
"failure."
msgstr ""
"Удалить запись в словаре *p* с помощью ключа *key*. *ключ* должен быть :term:"
"`hashable`; если это не так, возникает :exc:`TypeError`. Если *key* "
"отсутствует в словаре, возникает :exc:`KeyError`. Возвращайте ``0`` в случае "
"успеха или ``-1`` в случае неудачи."

#: ../../c-api/dict.rst:88
msgid ""
"This is the same as :c:func:`PyDict_DelItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Это то же самое, что и :c:func:`PyDict_DelItem`, но *key* указывается как :c:"
"expr:`const char*` строка байтов в кодировке UTF-8, а не как :c:expr:"
"`PyObject* `."

#: ../../c-api/dict.rst:95
msgid ""
"Return the object from dictionary *p* which has a key *key*.  Return "
"``NULL`` if the key *key* is not present, but *without* setting an exception."
msgstr ""
"Вернуть объект из словаря *p*, у которого есть ключ *key*. Возвращает "
"``NULL``, если ключ *key* отсутствует, но *без* установки исключения."

#: ../../c-api/dict.rst:100
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and :meth:"
"`~object.__eq__` methods are silently ignored. Prefer the :c:func:"
"`PyDict_GetItemWithError` function instead."
msgstr ""
"Исключения, возникающие при вызове методов :meth:`~object.__hash__` и :meth:"
"`~object.__eq__`, молча игнорируются. Вместо этого предпочтите функцию :c:"
"func:`PyDict_GetItemWithError`."

#: ../../c-api/dict.rst:104
msgid ""
"Calling this API without :term:`GIL` held had been allowed for historical "
"reason. It is no longer allowed."
msgstr ""
"Вызов этого API без удержания :term:`GIL` был разрешен по историческим "
"причинам. Это больше не разрешено."

#: ../../c-api/dict.rst:111
msgid ""
"Variant of :c:func:`PyDict_GetItem` that does not suppress exceptions. "
"Return ``NULL`` **with** an exception set if an exception occurred.  Return "
"``NULL`` **without** an exception set if the key wasn't present."
msgstr ""
"Вариант :c:func:`PyDict_GetItem`, который не подавляет исключения. "
"Возвращает ``NULL`` **с** установленным исключением, если исключение "
"произошло. Верните ``NULL`` **без** установленного исключения, если ключ "
"отсутствовал."

#: ../../c-api/dict.rst:119
msgid ""
"This is the same as :c:func:`PyDict_GetItem`, but *key* is specified as a :c:"
"expr:`const char*` UTF-8 encoded bytes string, rather than a :c:expr:"
"`PyObject*`."
msgstr ""
"Это то же самое, что и :c:func:`PyDict_GetItem`, но *key* указывается как :c:"
"expr:`const char*` строка байтов в кодировке UTF-8, а не как :c:expr:"
"`PyObject* `."

#: ../../c-api/dict.rst:125
msgid ""
"Exceptions that occur while this calls :meth:`~object.__hash__` and :meth:"
"`~object.__eq__` methods or while creating the temporary :class:`str` object "
"are silently ignored. Prefer using the :c:func:`PyDict_GetItemWithError` "
"function with your own :c:func:`PyUnicode_FromString` *key* instead."
msgstr ""
"Исключения, возникающие при вызове методов :meth:`~object.__hash__` и :meth:"
"`~object.__eq__` или при создании временного объекта :class:`str`, молча "
"игнорируются. Предпочитайте вместо этого использовать функцию :c:func:"
"`PyDict_GetItemWithError` с вашим собственным :c:func:`PyUnicode_FromString` "
"*key*."

#: ../../c-api/dict.rst:134
msgid ""
"This is the same as the Python-level :meth:`dict.setdefault`.  If present, "
"it returns the value corresponding to *key* from the dictionary *p*.  If the "
"key is not in the dict, it is inserted with value *defaultobj* and "
"*defaultobj* is returned.  This function evaluates the hash function of "
"*key* only once, instead of evaluating it independently for the lookup and "
"the insertion."
msgstr ""
"Это то же самое, что и :meth:`dict.setdefault` уровня Python. Если он "
"присутствует, он возвращает значение, соответствующее *key* из словаря *p*. "
"Если ключа нет в словаре, он вставляется со значением *defaultobj* и "
"возвращается *defaultobj*. Эта функция оценивает хэш-функцию *key* только "
"один раз, вместо того, чтобы оценивать ее независимо для поиска и вставки."

#: ../../c-api/dict.rst:144
msgid ""
"Return a :c:type:`PyListObject` containing all the items from the dictionary."
msgstr "Верните :c:type:`PyListObject`, содержащий все элементы из словаря."

#: ../../c-api/dict.rst:149
msgid ""
"Return a :c:type:`PyListObject` containing all the keys from the dictionary."
msgstr "Верните :c:type:`PyListObject`, содержащий все ключи из словаря."

#: ../../c-api/dict.rst:154
msgid ""
"Return a :c:type:`PyListObject` containing all the values from the "
"dictionary *p*."
msgstr ""
"Возвращает :c:type:`PyListObject`, содержащий все значения из словаря *p*."

#: ../../c-api/dict.rst:162
msgid ""
"Return the number of items in the dictionary.  This is equivalent to "
"``len(p)`` on a dictionary."
msgstr ""
"Возвращает количество элементов в словаре. Это эквивалентно ``len(p)`` в "
"словаре."

#: ../../c-api/dict.rst:168
msgid ""
"Iterate over all key-value pairs in the dictionary *p*.  The :c:type:"
"`Py_ssize_t` referred to by *ppos* must be initialized to ``0`` prior to the "
"first call to this function to start the iteration; the function returns "
"true for each pair in the dictionary, and false once all pairs have been "
"reported.  The parameters *pkey* and *pvalue* should either point to :c:expr:"
"`PyObject*` variables that will be filled in with each key and value, "
"respectively, or may be ``NULL``.  Any references returned through them are "
"borrowed.  *ppos* should not be altered during iteration. Its value "
"represents offsets within the internal dictionary structure, and since the "
"structure is sparse, the offsets are not consecutive."
msgstr ""
"Перебрать все пары ключ-значение в словаре *p*. :c:type:`Py_ssize_t`, на "
"который ссылается *ppos*, должен быть инициализирован значением ``0`` перед "
"первым вызовом этой функции, чтобы начать итерацию; функция возвращает true "
"для каждой пары в словаре и false после того, как были сообщены обо всех "
"парах. Параметры *pkey* и *pvalue* должны либо указывать на переменные :c:"
"expr:`PyObject*`, которые будут заполнены каждым ключом и значением "
"соответственно, либо могут иметь значение ``NULL``. Любые ссылки, "
"возвращаемые через них, заимствованы. *ppos* не следует изменять во время "
"итерации. Его значение представляет собой смещения во внутренней структуре "
"словаря, а поскольку структура разрежена, смещения не являются "
"последовательными."

#: ../../c-api/dict.rst:179
msgid "For example::"
msgstr "Например::"

#: ../../c-api/dict.rst:181
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    /* do something interesting with the values... */\n"
"    ...\n"
"}"

#: ../../c-api/dict.rst:189
msgid ""
"The dictionary *p* should not be mutated during iteration.  It is safe to "
"modify the values of the keys as you iterate over the dictionary, but only "
"so long as the set of keys does not change.  For example::"
msgstr ""
"Словарь *p* не должен изменяться во время итерации. Можно безопасно изменять "
"значения ключей при переборе словаря, но только до тех пор, пока набор "
"ключей не изменится. Например::"

#: ../../c-api/dict.rst:193
msgid ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"
msgstr ""
"PyObject *key, *value;\n"
"Py_ssize_t pos = 0;\n"
"\n"
"while (PyDict_Next(self->dict, &pos, &key, &value)) {\n"
"    long i = PyLong_AsLong(value);\n"
"    if (i == -1 && PyErr_Occurred()) {\n"
"        return -1;\n"
"    }\n"
"    PyObject *o = PyLong_FromLong(i + 1);\n"
"    if (o == NULL)\n"
"        return -1;\n"
"    if (PyDict_SetItem(self->dict, key, o) < 0) {\n"
"        Py_DECREF(o);\n"
"        return -1;\n"
"    }\n"
"    Py_DECREF(o);\n"
"}"

#: ../../c-api/dict.rst:214
msgid ""
"Iterate over mapping object *b* adding key-value pairs to dictionary *a*. "
"*b* may be a dictionary, or any object supporting :c:func:`PyMapping_Keys` "
"and :c:func:`PyObject_GetItem`. If *override* is true, existing pairs in *a* "
"will be replaced if a matching key is found in *b*, otherwise pairs will "
"only be added if there is not a matching key in *a*. Return ``0`` on success "
"or ``-1`` if an exception was raised."
msgstr ""
"Перебрать объект сопоставления *b*, добавив пары ключ-значение в словарь "
"*a*. *b* может быть словарем или любым объектом, поддерживающим :c:func:"
"`PyMapping_Keys` и :c:func:`PyObject_GetItem`. Если *override* имеет "
"значение true, существующие пары в *a* будут заменены, если соответствующий "
"ключ найден в *b*, в противном случае пары будут добавлены только в том "
"случае, если в *a* нет соответствующего ключа. Возвращайте ``0`` в случае "
"успеха или ``-1``, если возникло исключение."

#: ../../c-api/dict.rst:224
msgid ""
"This is the same as ``PyDict_Merge(a, b, 1)`` in C, and is similar to ``a."
"update(b)`` in Python except that :c:func:`PyDict_Update` doesn't fall back "
"to the iterating over a sequence of key value pairs if the second argument "
"has no \"keys\" attribute.  Return ``0`` on success or ``-1`` if an "
"exception was raised."
msgstr ""
"Это то же самое, что ``PyDict_Merge(a, b, 1)`` в C и аналогично ``a."
"update(b)`` в Python, за исключением того, что :c:func:`PyDict_Update` не "
"падает. вернемся к итерации по последовательности пар ключ-значение, если "
"второй аргумент не имеет атрибута «ключи». Возвращайте ``0`` в случае успеха "
"или ``-1``, если возникло исключение."

#: ../../c-api/dict.rst:233
msgid ""
"Update or merge into dictionary *a*, from the key-value pairs in *seq2*. "
"*seq2* must be an iterable object producing iterable objects of length 2, "
"viewed as key-value pairs.  In case of duplicate keys, the last wins if "
"*override* is true, else the first wins. Return ``0`` on success or ``-1`` "
"if an exception was raised. Equivalent Python (except for the return value)::"
msgstr ""
"Обновите или объедините словарь *a* из пар ключ-значение в *seq2*. *seq2* "
"должен быть итерируемым объектом, создающим итерируемые объекты длиной 2, "
"рассматриваемые как пары ключ-значение. В случае дубликатов ключей "
"выигрывает последний, если *override* истинно, в противном случае выигрывает "
"первый. Возвращайте ``0`` в случае успеха или ``-1``, если возникло "
"исключение. Эквивалент Python (за исключением возвращаемого значения)::"

#: ../../c-api/dict.rst:240
msgid ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"
msgstr ""
"def PyDict_MergeFromSeq2(a, seq2, override):\n"
"    for key, value in seq2:\n"
"        if override or key not in a:\n"
"            a[key] = value"

#: ../../c-api/dict.rst:247
msgid ""
"Register *callback* as a dictionary watcher. Return a non-negative integer "
"id which must be passed to future calls to :c:func:`PyDict_Watch`. In case "
"of error (e.g. no more watcher IDs available), return ``-1`` and set an "
"exception."
msgstr ""
"Зарегистрируйте *callback* в качестве наблюдателя за словарем. Возвращает "
"неотрицательный целочисленный идентификатор, который необходимо передавать в "
"будущие вызовы :c:func:`PyDict_Watch`. В случае ошибки (например, больше нет "
"доступных идентификаторов наблюдателей) верните ``-1`` и установите "
"исключение."

#: ../../c-api/dict.rst:256
msgid ""
"Clear watcher identified by *watcher_id* previously returned from :c:func:"
"`PyDict_AddWatcher`. Return ``0`` on success, ``-1`` on error (e.g. if the "
"given *watcher_id* was never registered.)"
msgstr ""
"Очистить наблюдатель, идентифицированный *watcher_id*, ранее возвращенный "
"из :c:func:`PyDict_AddWatcher`. Возвращает ``0`` в случае успеха, ``-1`` в "
"случае ошибки (например, если данный *watcher_id* никогда не был "
"зарегистрирован)."

#: ../../c-api/dict.rst:264
msgid ""
"Mark dictionary *dict* as watched. The callback granted *watcher_id* by :c:"
"func:`PyDict_AddWatcher` will be called when *dict* is modified or "
"deallocated. Return ``0`` on success or ``-1`` on error."
msgstr ""
"Отметить словарь *dict* как просмотренный. Обратный вызов, предоставленный "
"*watcher_id* :c:func:`PyDict_AddWatcher`, будет вызван, когда *dict* будет "
"изменен или освобожден. Возвращает ``0`` в случае успеха или ``-1`` в случае "
"ошибки."

#: ../../c-api/dict.rst:272
msgid ""
"Mark dictionary *dict* as no longer watched. The callback granted "
"*watcher_id* by :c:func:`PyDict_AddWatcher` will no longer be called when "
"*dict* is modified or deallocated. The dict must previously have been "
"watched by this watcher. Return ``0`` on success or ``-1`` on error."
msgstr ""
"Отметить словарь *dict* как непросматриваемый. Обратный вызов, "
"предоставленный *watcher_id* :c:func:`PyDict_AddWatcher`, больше не будет "
"вызываться, когда *dict* изменяется или освобождается. Этот наблюдатель "
"должен был ранее просмотреть диктовку. Возвращает ``0`` в случае успеха или "
"``-1`` в случае ошибки."

#: ../../c-api/dict.rst:281
msgid ""
"Enumeration of possible dictionary watcher events: ``PyDict_EVENT_ADDED``, "
"``PyDict_EVENT_MODIFIED``, ``PyDict_EVENT_DELETED``, "
"``PyDict_EVENT_CLONED``, ``PyDict_EVENT_CLEARED``, or "
"``PyDict_EVENT_DEALLOCATED``."
msgstr ""
"Перечень возможных событий средства просмотра словаря: PyDict_EVENT_ADDED, "
"PyDict_EVENT_MODIFIED, PyDict_EVENT_DELETED, PyDict_EVENT_CLONED, "
"PyDict_EVENT_CLEARED или PyDict_EVENT_DEALLOCATED."

#: ../../c-api/dict.rst:289
msgid "Type of a dict watcher callback function."
msgstr "Тип функции обратного вызова наблюдателя dict."

#: ../../c-api/dict.rst:291
msgid ""
"If *event* is ``PyDict_EVENT_CLEARED`` or ``PyDict_EVENT_DEALLOCATED``, both "
"*key* and *new_value* will be ``NULL``. If *event* is ``PyDict_EVENT_ADDED`` "
"or ``PyDict_EVENT_MODIFIED``, *new_value* will be the new value for *key*. "
"If *event* is ``PyDict_EVENT_DELETED``, *key* is being deleted from the "
"dictionary and *new_value* will be ``NULL``."
msgstr ""
"Если *event* равно ``PyDict_EVENT_CLEARED`` или "
"``PyDict_EVENT_DEALLOCATED``, то и *key*, и *new_value* будут равны "
"``NULL``. Если *event* равно ``PyDict_EVENT_ADDED`` или "
"``PyDict_EVENT_MODIFIED``, *new_value* будет новым значением для *key*. Если "
"*event* равно ``PyDict_EVENT_DELETED``, *key* удаляется из словаря, а "
"*new_value* будет равно ``NULL``."

#: ../../c-api/dict.rst:297
msgid ""
"``PyDict_EVENT_CLONED`` occurs when *dict* was previously empty and another "
"dict is merged into it. To maintain efficiency of this operation, per-key "
"``PyDict_EVENT_ADDED`` events are not issued in this case; instead a single "
"``PyDict_EVENT_CLONED`` is issued, and *key* will be the source dictionary."
msgstr ""
"``PyDict_EVENT_CLONED`` возникает, когда *dict* ранее был пустым и к нему "
"добавляется другой dict. Для поддержания эффективности этой операции события "
"PyDict_EVENT_ADDED для каждого ключа в этом случае не выдаются; вместо этого "
"выдается одиночный PyDict_EVENT_CLONED, а *key* будет исходным словарем."

#: ../../c-api/dict.rst:303
msgid ""
"The callback may inspect but must not modify *dict*; doing so could have "
"unpredictable effects, including infinite recursion. Do not trigger Python "
"code execution in the callback, as it could modify the dict as a side effect."
msgstr ""
"Обратный вызов может проверять, но не должен изменять *dict*; это может "
"иметь непредсказуемые последствия, включая бесконечную рекурсию. Не "
"запускайте выполнение кода Python в обратном вызове, так как это может "
"изменить dict в качестве побочного эффекта."

#: ../../c-api/dict.rst:307
msgid ""
"If *event* is ``PyDict_EVENT_DEALLOCATED``, taking a new reference in the "
"callback to the about-to-be-destroyed dictionary will resurrect it and "
"prevent it from being freed at this time. When the resurrected object is "
"destroyed later, any watcher callbacks active at that time will be called "
"again."
msgstr ""
"Если *event* равно ``PyDict_EVENT_DEALLOCATED``, использование новой ссылки "
"в обратном вызове на словарь, который вот-вот будет уничтожен, воскресит его "
"и предотвратит его освобождение в данный момент. Когда воскрешенный объект "
"будет позже уничтожен, все активные в тот момент обратные вызовы наблюдателя "
"будут вызваны снова."

#: ../../c-api/dict.rst:313
msgid ""
"Callbacks occur before the notified modification to *dict* takes place, so "
"the prior state of *dict* can be inspected."
msgstr ""
"Обратные вызовы происходят до того, как произойдет уведомление об изменении "
"*dict*, поэтому можно проверить предыдущее состояние *dict*."

#: ../../c-api/dict.rst:316
msgid ""
"If the callback sets an exception, it must return ``-1``; this exception "
"will be printed as an unraisable exception using :c:func:"
"`PyErr_WriteUnraisable`. Otherwise it should return ``0``."
msgstr ""
"Если обратный вызов устанавливает исключение, он должен вернуть ``-1``; это "
"исключение будет напечатано как невызываемое с использованием :c:func:"
"`PyErr_WriteUnraisable`. В противном случае он должен вернуть ``0``."

#: ../../c-api/dict.rst:320
msgid ""
"There may already be a pending exception set on entry to the callback. In "
"this case, the callback should return ``0`` with the same exception still "
"set. This means the callback may not call any other API that can set an "
"exception unless it saves and clears the exception state first, and restores "
"it before returning."
msgstr ""
"При входе в обратный вызов уже может быть установлено ожидающее исключение. "
"В этом случае обратный вызов должен вернуть ``0`` с тем же самым "
"установленным исключением. Это означает, что обратный вызов не может "
"вызывать какой-либо другой API, который может установить исключение, если он "
"сначала не сохранит и не очистит состояние исключения, а затем не "
"восстановит его перед возвратом."

#: ../../c-api/dict.rst:8
msgid "object"
msgstr "объект"

#: ../../c-api/dict.rst:8
msgid "dictionary"
msgstr "словарь"

#: ../../c-api/dict.rst:160
msgid "built-in function"
msgstr "встроенная функция"

#: ../../c-api/dict.rst:160
msgid "len"
msgstr "len"
