# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/bytes.rst:6
msgid "Bytes Objects"
msgstr "Байтовые объекты"

#: ../../c-api/bytes.rst:8
msgid ""
"These functions raise :exc:`TypeError` when expecting a bytes parameter and "
"called with a non-bytes parameter."
msgstr ""
"Эти функции генерируют :exc:`TypeError` при ожидании байтового параметра и "
"вызываются с не байтовым параметром."

#: ../../c-api/bytes.rst:16
msgid "This subtype of :c:type:`PyObject` represents a Python bytes object."
msgstr "Этот подтип :c:type:`PyObject` представляет байтовый объект Python."

#: ../../c-api/bytes.rst:21
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python bytes type; it "
"is the same object as :class:`bytes` in the Python layer."
msgstr ""
"Этот экземпляр :c:type:`PyTypeObject` представляет тип байта Python; это тот "
"же объект, что и :class:`bytes` на уровне Python."

#: ../../c-api/bytes.rst:27
msgid ""
"Return true if the object *o* is a bytes object or an instance of a subtype "
"of the bytes type.  This function always succeeds."
msgstr ""
"Возвращает значение true, если объект *o* является байтовым объектом или "
"экземпляром подтипа типа байтов. Эта функция всегда выполняется успешно."

#: ../../c-api/bytes.rst:33
msgid ""
"Return true if the object *o* is a bytes object, but not an instance of a "
"subtype of the bytes type.  This function always succeeds."
msgstr ""
"Возвращает значение true, если объект *o* является байтовым объектом, но не "
"экземпляром подтипа типа байтов. Эта функция всегда выполняется успешно."

#: ../../c-api/bytes.rst:39
msgid ""
"Return a new bytes object with a copy of the string *v* as value on success, "
"and ``NULL`` on failure.  The parameter *v* must not be ``NULL``; it will "
"not be checked."
msgstr ""
"Возвращает новый байтовый объект с копией строки *v* в качестве значения в "
"случае успеха и ``NULL`` в случае неудачи. Параметр *v* не должен быть "
"``NULL``; он не будет проверяться."

#: ../../c-api/bytes.rst:46
msgid ""
"Return a new bytes object with a copy of the string *v* as value and length "
"*len* on success, and ``NULL`` on failure.  If *v* is ``NULL``, the contents "
"of the bytes object are uninitialized."
msgstr ""
"Возвращает новый байтовый объект с копией строки *v* в качестве значения и "
"длиной *len* в случае успеха и ``NULL`` в случае неудачи. Если *v* равно "
"``NULL``, содержимое байтового объекта не инициализировано."

#: ../../c-api/bytes.rst:53
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python bytes object and "
"return a bytes object with the values formatted into it.  The variable "
"arguments must be C types and must correspond exactly to the format "
"characters in the *format* string.  The following format characters are "
"allowed:"
msgstr ""
"Берет строку C :c:func:`printf`\\ -style *format* и переменное количество "
"аргументов, вычисляет размер результирующего байтового объекта Python и "
"возвращает байтовый объект со значениями, отформатированными в нем. "
"Аргументы переменных должны быть типами C и точно соответствовать символам "
"формата в строке *format*. Допустимы следующие символы формата:"

#: ../../c-api/bytes.rst:65
msgid "Format Characters"
msgstr "Форматирование символов"

#: ../../c-api/bytes.rst:65
msgid "Type"
msgstr "Тип"

#: ../../c-api/bytes.rst:65
msgid "Comment"
msgstr "Комментарий"

#: ../../c-api/bytes.rst:67
msgid "``%%``"
msgstr "``%%``"

#: ../../c-api/bytes.rst:67
msgid "*n/a*"
msgstr "*n/a*"

#: ../../c-api/bytes.rst:67
msgid "The literal % character."
msgstr "Литеральный символ %"

#: ../../c-api/bytes.rst:69
msgid "``%c``"
msgstr "``%c``"

#: ../../c-api/bytes.rst:69 ../../c-api/bytes.rst:72 ../../c-api/bytes.rst:90
#: ../../c-api/bytes.rst:93
msgid "int"
msgstr "int"

#: ../../c-api/bytes.rst:69
msgid "A single byte, represented as a C int."
msgstr "Один байт, представленный в виде C int."

#: ../../c-api/bytes.rst:72
msgid "``%d``"
msgstr "``%d``"

#: ../../c-api/bytes.rst:72
msgid "Equivalent to ``printf(\"%d\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%d\")``. [1]_"

#: ../../c-api/bytes.rst:75
msgid "``%u``"
msgstr "``%u``"

#: ../../c-api/bytes.rst:75
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/bytes.rst:75
msgid "Equivalent to ``printf(\"%u\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%u\")``. [1]_"

#: ../../c-api/bytes.rst:78
msgid "``%ld``"
msgstr "``%ld``"

#: ../../c-api/bytes.rst:78
msgid "long"
msgstr "long"

#: ../../c-api/bytes.rst:78
msgid "Equivalent to ``printf(\"%ld\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%ld\")``. [1]_"

#: ../../c-api/bytes.rst:81
msgid "``%lu``"
msgstr "``%lu``"

#: ../../c-api/bytes.rst:81
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/bytes.rst:81
msgid "Equivalent to ``printf(\"%lu\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%lu\")``. [1]_"

#: ../../c-api/bytes.rst:84
msgid "``%zd``"
msgstr "``%zd``"

#: ../../c-api/bytes.rst:84
msgid ":c:type:`\\ Py_ssize_t`"
msgstr ":c:type:`\\ Py_ssize_t`"

#: ../../c-api/bytes.rst:84
msgid "Equivalent to ``printf(\"%zd\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%zd\")``. [1]_"

#: ../../c-api/bytes.rst:87
msgid "``%zu``"
msgstr "``%zu``"

#: ../../c-api/bytes.rst:87
msgid "size_t"
msgstr "size_t"

#: ../../c-api/bytes.rst:87
msgid "Equivalent to ``printf(\"%zu\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%zu\")``. [1]_"

#: ../../c-api/bytes.rst:90
msgid "``%i``"
msgstr "``%i``"

#: ../../c-api/bytes.rst:90
msgid "Equivalent to ``printf(\"%i\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%i\")``. [1]_"

#: ../../c-api/bytes.rst:93
msgid "``%x``"
msgstr "``%x``"

#: ../../c-api/bytes.rst:93
msgid "Equivalent to ``printf(\"%x\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%x\")``. [1]_"

#: ../../c-api/bytes.rst:96
msgid "``%s``"
msgstr "``%s``"

#: ../../c-api/bytes.rst:96
msgid "const char\\*"
msgstr "const char\\*"

#: ../../c-api/bytes.rst:96
msgid "A null-terminated C character array."
msgstr "Нуль-терминированный массив символов С."

#: ../../c-api/bytes.rst:99
msgid "``%p``"
msgstr "``%p``"

#: ../../c-api/bytes.rst:99
msgid "const void\\*"
msgstr "const void\\*"

#: ../../c-api/bytes.rst:99
msgid ""
"The hex representation of a C pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"Шестнадцатеричное представление указателя на языке Си. В основном "
"эквивалентно ``printf(\"%p\")``, за исключением того, что оно гарантированно "
"начинается с литерала ``0x`` независимо от того, что дает ``printf`` "
"платформы."

#: ../../c-api/bytes.rst:108
msgid ""
"An unrecognized format character causes all the rest of the format string to "
"be copied as-is to the result object, and any extra arguments discarded."
msgstr ""
"Нераспознанный символ формата приводит к тому, что вся остальная строка "
"формата копируется в результирующий объект как есть, а все дополнительные "
"аргументы отбрасываются."

#: ../../c-api/bytes.rst:111
msgid ""
"For integer specifiers (d, u, ld, lu, zd, zu, i, x): the 0-conversion flag "
"has effect even when a precision is given."
msgstr ""
"Для целочисленных спецификаторов (d, u, ld, lu, zd, zu, i, x): флаг "
"преобразования в 0 действует даже при заданной точности."

#: ../../c-api/bytes.rst:117
msgid ""
"Identical to :c:func:`PyBytes_FromFormat` except that it takes exactly two "
"arguments."
msgstr ""
"Идентичен :c:func:`PyBytes_FromFormat`, за исключением того, что он "
"принимает ровно два аргумента."

#: ../../c-api/bytes.rst:123
msgid ""
"Return the bytes representation of object *o* that implements the buffer "
"protocol."
msgstr ""
"Возвращает байтовое представление объекта *o*, который реализует буферный "
"протокол."

#: ../../c-api/bytes.rst:129
msgid "Return the length of the bytes in bytes object *o*."
msgstr "Возвращает длину байтов в байтовом объекте *o*."

#: ../../c-api/bytes.rst:134
msgid "Similar to :c:func:`PyBytes_Size`, but without error checking."
msgstr "Аналогично :c:func:`PyBytes_Size`, но без проверки ошибок."

#: ../../c-api/bytes.rst:139
msgid ""
"Return a pointer to the contents of *o*.  The pointer refers to the internal "
"buffer of *o*, which consists of ``len(o) + 1`` bytes.  The last byte in the "
"buffer is always null, regardless of whether there are any other null "
"bytes.  The data must not be modified in any way, unless the object was just "
"created using ``PyBytes_FromStringAndSize(NULL, size)``. It must not be "
"deallocated.  If *o* is not a bytes object at all, :c:func:"
"`PyBytes_AsString` returns ``NULL`` and raises :exc:`TypeError`."
msgstr ""
"Возвращает указатель на содержимое *o*. Указатель ссылается на внутренний "
"буфер *o*, который состоит из байтов ``len(o) + 1``. Последний байт в буфере "
"всегда равен null, независимо от того, есть ли другие пустые байты. Данные "
"не должны быть изменены каким-либо образом, если только объект не был только "
"что создан с использованием ``PyBytes_FromStringAndSize(NULL, size)``. Он не "
"должен быть освобожден. Если *o* вообще не является байтовым объектом, :c:"
"func:`PyBytes_AsString` возвращает ``NULL`` и вызывает :exc:`TypeError`."

#: ../../c-api/bytes.rst:151
msgid "Similar to :c:func:`PyBytes_AsString`, but without error checking."
msgstr "Аналогично :c:func:`PyBytes_AsString`, но без проверки ошибок."

#: ../../c-api/bytes.rst:156
msgid ""
"Return the null-terminated contents of the object *obj* through the output "
"variables *buffer* and *length*. Returns ``0`` on success."
msgstr ""
"Возвращает содержимое объекта *obj*, завершающееся нулем, через выходные "
"переменные *buffer* и *length*. Возвращает ``0`` в случае успеха."

#: ../../c-api/bytes.rst:160
msgid ""
"If *length* is ``NULL``, the bytes object may not contain embedded null "
"bytes; if it does, the function returns ``-1`` and a :exc:`ValueError` is "
"raised."
msgstr ""
"Если значение *length* равно ``NULL``, байтовый объект может не содержать "
"встроенных нулевых байтов; если это так, функция возвращает ``-1`` и "
"возникает ошибка :exc:`ValueError`."

#: ../../c-api/bytes.rst:164
msgid ""
"The buffer refers to an internal buffer of *obj*, which includes an "
"additional null byte at the end (not counted in *length*).  The data must "
"not be modified in any way, unless the object was just created using "
"``PyBytes_FromStringAndSize(NULL, size)``.  It must not be deallocated.  If "
"*obj* is not a bytes object at all, :c:func:`PyBytes_AsStringAndSize` "
"returns ``-1`` and raises :exc:`TypeError`."
msgstr ""
"Буфер относится к внутреннему буферу *obj*, который включает в себя "
"дополнительный нулевой байт в конце (не учитываемый в *length*). Данные не "
"должны быть изменены каким-либо образом, если только объект не был только "
"что создан с использованием ``PyBytes_FromStringAndSize(NULL, size)``. Он не "
"должен быть освобожден. Если *obj* вообще не является байтовым объектом, :c:"
"func:`PyBytes_AsStringAndSize` возвращает ``-1`` и вызывает :exc:`TypeError`."

#: ../../c-api/bytes.rst:171
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes object."
msgstr ""
"Ранее :exc:`TypeError` вызывался, когда в байтовом объекте обнаруживались "
"встроенные нулевые байты."

#: ../../c-api/bytes.rst:178
msgid ""
"Create a new bytes object in *\\*bytes* containing the contents of *newpart* "
"appended to *bytes*; the caller will own the new reference.  The reference "
"to the old value of *bytes* will be stolen.  If the new object cannot be "
"created, the old reference to *bytes* will still be discarded and the value "
"of *\\*bytes* will be set to ``NULL``; the appropriate exception will be set."
msgstr ""
"Создает новый байтовый объект в *\\*bytes*, содержащий содержимое *newpart*, "
"добавленное к *bytes*; вызывающий объект будет владеть новой ссылкой. Ссылка "
"на старое значение *bytes* будет украдена. Если новый объект не может быть "
"создан, старая ссылка на *bytes* все равно будет удалена, а для значения "
"*\\*bytes* будет установлено значение ``NULL``; будет установлено "
"соответствующее исключение."

#: ../../c-api/bytes.rst:187
msgid ""
"Create a new bytes object in *\\*bytes* containing the contents of *newpart* "
"appended to *bytes*.  This version releases the :term:`strong reference` to "
"*newpart* (i.e. decrements its reference count)."
msgstr ""
"Создайте новый объект bytes в *\\*bytes*, содержащий содержимое *newpart*, "
"добавленное к *bytes*. Эта версия освобождает :term:`strong ссылку` на "
"*newpart* (т.е. уменьшает ее счетчик ссылок)."

#: ../../c-api/bytes.rst:194
msgid ""
"A way to resize a bytes object even though it is \"immutable\". Only use "
"this to build up a brand new bytes object; don't use this if the bytes may "
"already be known in other parts of the code.  It is an error to call this "
"function if the refcount on the input bytes object is not one. Pass the "
"address of an existing bytes object as an lvalue (it may be written into), "
"and the new size desired.  On success, *\\*bytes* holds the resized bytes "
"object and ``0`` is returned; the address in *\\*bytes* may differ from its "
"input value.  If the reallocation fails, the original bytes object at "
"*\\*bytes* is deallocated, *\\*bytes* is set to ``NULL``, :exc:`MemoryError` "
"is set, and ``-1`` is returned."
msgstr ""
"Способ изменить размер байтового объекта, даже если он \"неизменяем\". "
"Используйте это только для создания совершенно нового байтового объекта; не "
"используйте это, если байты уже могут быть известны в других частях кода. "
"Вызов этой функции приводит к ошибке, если значение refcount для входного "
"байтового объекта не равно единице. Передайте адрес существующего байтового "
"объекта в качестве значения lvalue (оно может быть записано в) и желаемый "
"новый размер. В случае успеха *\\*bytes* содержит байтовый объект "
"измененного размера и возвращается значение ``0``; адрес в *\\*bytes* может "
"отличаться от его входного значения. Если перераспределение завершается "
"неудачей, исходный байтовый объект в *\\*bytes* освобождается, *\\*bytes* "
"присваивается значение ``NULL``, устанавливается значение :exc:`MemoryError` "
"и возвращается значение ``-1``."

#: ../../c-api/bytes.rst:11
msgid "object"
msgstr "объект"

#: ../../c-api/bytes.rst:11
msgid "bytes"
msgstr "байт"
