# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/unicode.rst:6
msgid "Unicode Objects and Codecs"
msgstr "Объекты и кодеки Unicode"

#: ../../c-api/unicode.rst:12
msgid "Unicode Objects"
msgstr "Объекты Юникода"

#: ../../c-api/unicode.rst:14
msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"С момента реализации :pep:`393` в Python 3.3 объекты Unicode внутренне "
"используют различные представления, чтобы обеспечить возможность обработки "
"полного диапазона символов Unicode, сохраняя при этом эффективность "
"использования памяти. Существуют особые случаи для строк, в которых все "
"кодовые точки находятся ниже 128, 256 или 65536; в противном случае кодовые "
"точки должны быть ниже 1114112 (полный диапазон Юникода)."

#: ../../c-api/unicode.rst:20
msgid ""
":c:expr:`Py_UNICODE*` and UTF-8 representations are created on demand and "
"cached in the Unicode object.  The :c:expr:`Py_UNICODE*` representation is "
"deprecated and inefficient."
msgstr ""

#: ../../c-api/unicode.rst:24
msgid ""
"Due to the transition between the old APIs and the new APIs, Unicode objects "
"can internally be in two states depending on how they were created:"
msgstr ""

#: ../../c-api/unicode.rst:27
msgid ""
"\"canonical\" Unicode objects are all objects created by a non-deprecated "
"Unicode API.  They use the most efficient representation allowed by the "
"implementation."
msgstr ""

#: ../../c-api/unicode.rst:31
msgid ""
"\"legacy\" Unicode objects have been created through one of the deprecated "
"APIs (typically :c:func:`PyUnicode_FromUnicode`) and only bear the :c:expr:"
"`Py_UNICODE*` representation; you will have to call :c:func:"
"`PyUnicode_READY` on them before calling any other API."
msgstr ""

#: ../../c-api/unicode.rst:37
msgid ""
"The \"legacy\" Unicode object will be removed in Python 3.12 with deprecated "
"APIs. All Unicode objects will be \"canonical\" since then. See :pep:`623` "
"for more information."
msgstr ""

#: ../../c-api/unicode.rst:43
msgid "Unicode Type"
msgstr "Тип Юникода"

#: ../../c-api/unicode.rst:45
msgid ""
"These are the basic Unicode object types used for the Unicode implementation "
"in Python:"
msgstr ""
"Это основные типы объектов Unicode, используемые для реализации Unicode в "
"Python:"

#: ../../c-api/unicode.rst:52
msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"Эти типы являются определениями типов для беззнаковых целочисленных типов, "
"достаточно широких, чтобы содержать символы длиной 32, 16 и 8 бит "
"соответственно. При работе с отдельными символами Юникода используйте :c:"
"type:`Py_UCS4`."

#: ../../c-api/unicode.rst:61
msgid ""
"This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform."
msgstr ""
"Это определение типа :c:type:`wchar_t`, который является 16-битным или 32-"
"битным типом в зависимости от платформы."

#: ../../c-api/unicode.rst:64
msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr ""
"В предыдущих версиях это был 16-битный или 32-битный тип в зависимости от "
"того, выбрали ли вы «узкую» или «широкую» версию Unicode Python во время "
"сборки."

#: ../../c-api/unicode.rst:74
msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"Эти подтипы :c:type:`PyObject` представляют собой объект Unicode Python. "
"Почти во всех случаях их не следует использовать напрямую, поскольку все "
"функции API, работающие с объектами Unicode, принимают и возвращают "
"указатели :c:type:`PyObject`."

#: ../../c-api/unicode.rst:83
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type.  "
"It is exposed to Python code as ``str``."
msgstr ""
"Этот экземпляр :c:type:`PyTypeObject` представляет тип Unicode Python. Он "
"отображается в коде Python как ``str``."

#: ../../c-api/unicode.rst:87
msgid ""
"The following APIs are C macros and static inlined functions for fast checks "
"and access to internal read-only data of Unicode objects:"
msgstr ""
"Следующие API представляют собой макросы C и статические встроенные функции "
"для быстрых проверок и доступа к внутренним данным объектов Unicode, "
"доступным только для чтения:"

#: ../../c-api/unicode.rst:92
msgid ""
"Return true if the object *obj* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr ""
"Возвращайте true, если объект *obj* является объектом Юникода или "
"экземпляром подтипа Юникода. Эта функция всегда завершается успешно."

#: ../../c-api/unicode.rst:98
msgid ""
"Return true if the object *obj* is a Unicode object, but not an instance of "
"a subtype.  This function always succeeds."
msgstr ""
"Возвращайте true, если объект *obj* является объектом Юникода, но не "
"экземпляром подтипа. Эта функция всегда завершается успешно."

#: ../../c-api/unicode.rst:104
msgid ""
"Ensure the string object *o* is in the \"canonical\" representation.  This "
"is required before using any of the access macros described below."
msgstr ""

#: ../../c-api/unicode.rst:109
msgid ""
"Returns ``0`` on success and ``-1`` with an exception set on failure, which "
"in particular happens if memory allocation fails."
msgstr ""

#: ../../c-api/unicode.rst:115
msgid "This API will be removed with :c:func:`PyUnicode_FromUnicode`."
msgstr ""

#: ../../c-api/unicode.rst:120
msgid ""
"Return the length of the Unicode string, in code points.  *unicode* has to "
"be a Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Возвращает длину строки Юникода в кодовых точках. *unicode* должен быть "
"объектом Unicode в «каноническом» представлении (не отмечено)."

#: ../../c-api/unicode.rst:130
msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use :c:func:"
"`PyUnicode_KIND` to select the right macro.  Make sure :c:func:"
"`PyUnicode_READY` has been called before accessing this."
msgstr ""

#: ../../c-api/unicode.rst:144
msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "Возвращаемые значения макроса :c:func:`PyUnicode_KIND`."

#: ../../c-api/unicode.rst:149
msgid "``PyUnicode_WCHAR_KIND`` is deprecated."
msgstr ""

#: ../../c-api/unicode.rst:154
msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  "
"*unicode* has to be a Unicode object in the \"canonical\" representation "
"(not checked)."
msgstr ""
"Возвращает одну из констант типа PyUnicode (см. выше), которая указывает, "
"сколько байтов на символ этот объект Unicode использует для хранения своих "
"данных. *unicode* должен быть объектом Unicode в «каноническом» "
"представлении (не отмечено)."

#: ../../c-api/unicode.rst:165
msgid ""
"Return a void pointer to the raw Unicode buffer.  *unicode* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Верните указатель void в необработанный буфер Юникода. *unicode* должен быть "
"объектом Unicode в «каноническом» представлении (не отмечено)."

#: ../../c-api/unicode.rst:174
msgid ""
"Write into a canonical representation *data* (as obtained with :c:func:"
"`PyUnicode_DATA`).  This function performs no sanity checks, and is intended "
"for usage in loops.  The caller should cache the *kind* value and *data* "
"pointer as obtained from other calls.  *index* is the index in the string "
"(starts at 0) and *value* is the new code point value which should be "
"written to that location."
msgstr ""
"Запишите в каноническое представление *data* (полученное с помощью :c:func:"
"`PyUnicode_DATA`). Эта функция не выполняет никаких проверок "
"работоспособности и предназначена для использования в циклах. Вызывающий "
"должен кэшировать значение *kind* и указатель *data*, полученные из других "
"вызовов. *index* — это индекс в строке (начинается с 0), а *value* — это "
"новое значение кодовой точки, которое должно быть записано в это место."

#: ../../c-api/unicode.rst:187
msgid ""
"Read a code point from a canonical representation *data* (as obtained with :"
"c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr ""
"Считайте кодовую точку из канонического представления *data* (полученного с "
"помощью :c:func:`PyUnicode_DATA`). Никакие проверки или готовые вызовы не "
"выполняются."

#: ../../c-api/unicode.rst:195
msgid ""
"Read a character from a Unicode object *unicode*, which must be in the "
"\"canonical\" representation.  This is less efficient than :c:func:"
"`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"Считайте символ из объекта Юникода *unicode*, который должен находиться в "
"«каноническом» представлении. Это менее эффективно, чем :c:func:"
"`PyUnicode_READ`, если вы выполняете несколько последовательных чтений."

#: ../../c-api/unicode.rst:204
msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *unicode*, which must be in the \"canonical\" representation.  This "
"is always an approximation but more efficient than iterating over the string."
msgstr ""
"Возвращает максимальную кодовую точку, подходящую для создания другой строки "
"на основе *unicode*, которая должна быть в «каноническом» представлении. Это "
"всегда приближение, но более эффективное, чем перебор строки."

#: ../../c-api/unicode.rst:213
msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation, in "
"code units (this includes surrogate pairs as 2 units).  *unicode* has to be "
"a Unicode object (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:219 ../../c-api/unicode.rst:229
#: ../../c-api/unicode.rst:761
msgid ""
"Part of the old-style Unicode API, please migrate to using :c:func:"
"`PyUnicode_GET_LENGTH`."
msgstr ""

#: ../../c-api/unicode.rst:224
msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation in "
"bytes.  *unicode* has to be a Unicode object (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:235
msgid ""
"Return a pointer to a :c:type:`Py_UNICODE` representation of the object.  "
"The returned buffer is always terminated with an extra null code point.  It "
"may also contain embedded null code points, which would cause the string to "
"be truncated when used in most C functions.  The ``AS_DATA`` form casts the "
"pointer to :c:expr:`const char *`.  The *unicode* argument has to be a "
"Unicode object (not checked)."
msgstr ""

#: ../../c-api/unicode.rst:242
msgid ""
"This function is now inefficient -- because in many cases the :c:type:"
"`Py_UNICODE` representation does not exist and needs to be created -- and "
"can fail (return ``NULL`` with an exception set).  Try to port the code to "
"use the new :c:func:`PyUnicode_nBYTE_DATA` macros or use :c:func:"
"`PyUnicode_WRITE` or :c:func:`PyUnicode_READ`."
msgstr ""

#: ../../c-api/unicode.rst:251
msgid ""
"Part of the old-style Unicode API, please migrate to using the :c:func:"
"`PyUnicode_nBYTE_DATA` family of macros."
msgstr ""

#: ../../c-api/unicode.rst:256
msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr ""
"Возвращайте ``1``, если строка является допустимым идентификатором в "
"соответствии с определением языка, раздел :ref:`identifiers`. В противном "
"случае верните ``0``."

#: ../../c-api/unicode.rst:259
msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr ""
"Функция больше не вызывает :c:func:`Py_FatalError`, если строка не готова."

#: ../../c-api/unicode.rst:265
msgid "Unicode Character Properties"
msgstr "Свойства символов Юникода"

#: ../../c-api/unicode.rst:267
msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr ""
"Юникод предоставляет множество различных свойств символов. Наиболее часто "
"необходимые из них доступны через эти макросы, которые отображаются в "
"функции C в зависимости от конфигурации Python."

#: ../../c-api/unicode.rst:274
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* "
"пробельным символом."

#: ../../c-api/unicode.rst:279
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* символом "
"нижнего регистра."

#: ../../c-api/unicode.rst:284
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* символом "
"верхнего регистра."

#: ../../c-api/unicode.rst:289
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* символом "
"регистра заголовка."

#: ../../c-api/unicode.rst:294
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* символом "
"разрыва строки."

#: ../../c-api/unicode.rst:299
msgid "Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* "
"десятичным символом."

#: ../../c-api/unicode.rst:304
msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* цифровым "
"символом."

#: ../../c-api/unicode.rst:309
msgid "Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* числовым "
"символом."

#: ../../c-api/unicode.rst:314
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* буквенным "
"символом."

#: ../../c-api/unicode.rst:319
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric character."
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* буквенно-"
"цифровым символом."

#: ../../c-api/unicode.rst:324
msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character. "
"Nonprintable characters are those characters defined in the Unicode "
"character database as \"Other\" or \"Separator\", excepting the ASCII space "
"(0x20) which is considered printable.  (Note that printable characters in "
"this context are those which should not be escaped when :func:`repr` is "
"invoked on a string. It has no bearing on the handling of strings written "
"to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Возвращает ``1`` или ``0`` в зависимости от того, является ли *ch* печатным "
"символом. Непечатаемые символы — это символы, определенные в базе данных "
"символов Юникода как «Другие» или «Разделители», за исключением пробела "
"ASCII (0x20), который считается печатаемым. (Обратите внимание, что в этом "
"контексте печатаемые символы — это те символы, которые не следует "
"экранировать при вызове :func:`repr` для строки. Это не имеет никакого "
"отношения к обработке строк, записанных в :data:`sys.stdout` или :data. :"
"`sys.stderr`.)"

#: ../../c-api/unicode.rst:333
msgid "These APIs can be used for fast direct character conversions:"
msgstr ""
"Эти API можно использовать для быстрого прямого преобразования символов:"

#: ../../c-api/unicode.rst:338
msgid "Return the character *ch* converted to lower case."
msgstr "Возвращает символ *ch*, преобразованный в нижний регистр."

#: ../../c-api/unicode.rst:340 ../../c-api/unicode.rst:348
#: ../../c-api/unicode.rst:356
msgid "This function uses simple case mappings."
msgstr "Эта функция использует простые сопоставления регистров."

#: ../../c-api/unicode.rst:346
msgid "Return the character *ch* converted to upper case."
msgstr "Возвращает символ *ch*, преобразованный в верхний регистр."

#: ../../c-api/unicode.rst:354
msgid "Return the character *ch* converted to title case."
msgstr "Возвращает символ *ch*, преобразованный в регистр заголовка."

#: ../../c-api/unicode.rst:362
msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This macro does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:368
msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1`` "
"if this is not possible.  This macro does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:374
msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This macro does not raise exceptions."
msgstr ""

#: ../../c-api/unicode.rst:378
msgid "These APIs can be used to work with surrogates:"
msgstr "Эти API можно использовать для работы с суррогатами:"

#: ../../c-api/unicode.rst:382
msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "Проверьте, является ли *ch* суррогатом (``0xD800 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:386
msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr ""
"Проверьте, является ли *ch* старшим суррогатом (``0xD800 <= ch <= 0xDBFF``)."

#: ../../c-api/unicode.rst:390
msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr ""
"Проверьте, является ли *ch* младшим суррогатом (``0xDC00 <= ch <= 0xDFFF``)."

#: ../../c-api/unicode.rst:394
msgid ""
"Join two surrogate characters and return a single Py_UCS4 value. *high* and "
"*low* are respectively the leading and trailing surrogates in a surrogate "
"pair."
msgstr ""

#: ../../c-api/unicode.rst:400
msgid "Creating and accessing Unicode strings"
msgstr "Создание строк Юникода и доступ к ним"

#: ../../c-api/unicode.rst:402
msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr ""
"Чтобы создавать объекты Unicode и получать доступ к их основным свойствам "
"последовательности, используйте следующие API:"

#: ../../c-api/unicode.rst:407
msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up "
"to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"Создайте новый объект Unicode. *maxchar* должен быть истинной максимальной "
"кодовой точкой, помещаемой в строку. В качестве приближения его можно "
"округлить до ближайшего значения в последовательности 127, 255, 65535, "
"1114111."

#: ../../c-api/unicode.rst:411
msgid ""
"This is the recommended way to allocate a new Unicode object.  Objects "
"created using this function are not resizable."
msgstr ""
"Это рекомендуемый способ выделения нового объекта Юникода. Объекты, "
"созданные с помощью этой функции, не подлежат изменению размера."

#: ../../c-api/unicode.rst:420
msgid ""
"Create a new Unicode object with the given *kind* (possible values are :c:"
"macro:`PyUnicode_1BYTE_KIND` etc., as returned by :c:func:"
"`PyUnicode_KIND`).  The *buffer* must point to an array of *size* units of "
"1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"Создайте новый объект Unicode с заданным *видом* (возможные значения: :c:"
"macro:`PyUnicode_1BYTE_KIND` и т. д., возвращаемые :c:func:"
"`PyUnicode_KIND`). *буфер* должен указывать на массив единиц *размера* по 1, "
"2 или 4 байта на символ, в зависимости от типа."

#: ../../c-api/unicode.rst:425
msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string (:c:"
"macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in the UCS1 "
"range, it will be transformed into UCS1 (:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""
"При необходимости входной *буфер* копируется и преобразуется в каноническое "
"представление. Например, если *buffer* представляет собой строку UCS4 (:c:"
"macro:`PyUnicode_4BYTE_KIND`) и состоит только из кодовых точек в диапазоне "
"UCS1, он будет преобразован в UCS1 (:c:macro:`PyUnicode_1BYTE_KIND`)."

#: ../../c-api/unicode.rst:436
msgid ""
"Create a Unicode object from the char buffer *str*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. If the buffer is not ``NULL``, the return value might be a shared "
"object, i.e. modification of the data is not allowed."
msgstr ""

#: ../../c-api/unicode.rst:441
msgid ""
"If *str* is ``NULL``, this function behaves like :c:func:"
"`PyUnicode_FromUnicode` with the buffer set to ``NULL``.  This usage is "
"deprecated in favor of :c:func:`PyUnicode_New`, and will be removed in "
"Python 3.12."
msgstr ""

#: ../../c-api/unicode.rst:448
msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer "
"*str*."
msgstr ""
"Создайте объект Unicode из буфера символов с нулевым завершением в кодировке "
"UTF-8 *str*."

#: ../../c-api/unicode.rst:454
msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string. The following format characters are allowed:"
msgstr ""

#: ../../c-api/unicode.rst:469
msgid "Format Characters"
msgstr "Форматирование символов"

#: ../../c-api/unicode.rst:469
msgid "Type"
msgstr "Тип"

#: ../../c-api/unicode.rst:469
msgid "Comment"
msgstr "Комментарий"

#: ../../c-api/unicode.rst:471
msgid ":attr:`%%`"
msgstr ""

#: ../../c-api/unicode.rst:471
msgid "*n/a*"
msgstr "*n/a*"

#: ../../c-api/unicode.rst:471
msgid "The literal % character."
msgstr "Литеральный символ %"

#: ../../c-api/unicode.rst:473
msgid ":attr:`%c`"
msgstr ""

#: ../../c-api/unicode.rst:473 ../../c-api/unicode.rst:476
#: ../../c-api/unicode.rst:509 ../../c-api/unicode.rst:512
msgid "int"
msgstr "int"

#: ../../c-api/unicode.rst:473
msgid "A single character, represented as a C int."
msgstr ""

#: ../../c-api/unicode.rst:476
msgid ":attr:`%d`"
msgstr ""

#: ../../c-api/unicode.rst:476
msgid "Equivalent to ``printf(\"%d\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%d\")``. [1]_"

#: ../../c-api/unicode.rst:479
msgid ":attr:`%u`"
msgstr ""

#: ../../c-api/unicode.rst:479
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/unicode.rst:479
msgid "Equivalent to ``printf(\"%u\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%u\")``. [1]_"

#: ../../c-api/unicode.rst:482
msgid ":attr:`%ld`"
msgstr ""

#: ../../c-api/unicode.rst:482 ../../c-api/unicode.rst:485
msgid "long"
msgstr "long"

#: ../../c-api/unicode.rst:482
msgid "Equivalent to ``printf(\"%ld\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%ld\")``. [1]_"

#: ../../c-api/unicode.rst:485
msgid ":attr:`%li`"
msgstr ""

#: ../../c-api/unicode.rst:485
msgid "Equivalent to ``printf(\"%li\")``. [1]_"
msgstr ""

#: ../../c-api/unicode.rst:488
msgid ":attr:`%lu`"
msgstr ""

#: ../../c-api/unicode.rst:488
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/unicode.rst:488
msgid "Equivalent to ``printf(\"%lu\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%lu\")``. [1]_"

#: ../../c-api/unicode.rst:491
msgid ":attr:`%lld`"
msgstr ""

#: ../../c-api/unicode.rst:491 ../../c-api/unicode.rst:494
msgid "long long"
msgstr ""

#: ../../c-api/unicode.rst:491
msgid "Equivalent to ``printf(\"%lld\")``. [1]_"
msgstr ""

#: ../../c-api/unicode.rst:494
msgid ":attr:`%lli`"
msgstr ""

#: ../../c-api/unicode.rst:494
msgid "Equivalent to ``printf(\"%lli\")``. [1]_"
msgstr ""

#: ../../c-api/unicode.rst:497
msgid ":attr:`%llu`"
msgstr ""

#: ../../c-api/unicode.rst:497
msgid "unsigned long long"
msgstr "unsigned long long"

#: ../../c-api/unicode.rst:497
msgid "Equivalent to ``printf(\"%llu\")``. [1]_"
msgstr ""

#: ../../c-api/unicode.rst:500
msgid ":attr:`%zd`"
msgstr ""

#: ../../c-api/unicode.rst:500 ../../c-api/unicode.rst:503
msgid ":c:type:`\\ Py_ssize_t`"
msgstr ":c:type:`\\ Py_ssize_t`"

#: ../../c-api/unicode.rst:500
msgid "Equivalent to ``printf(\"%zd\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%zd\")``. [1]_"

#: ../../c-api/unicode.rst:503
msgid ":attr:`%zi`"
msgstr ""

#: ../../c-api/unicode.rst:503
msgid "Equivalent to ``printf(\"%zi\")``. [1]_"
msgstr ""

#: ../../c-api/unicode.rst:506
msgid ":attr:`%zu`"
msgstr ""

#: ../../c-api/unicode.rst:506
msgid "size_t"
msgstr "size_t"

#: ../../c-api/unicode.rst:506
msgid "Equivalent to ``printf(\"%zu\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%zu\")``. [1]_"

#: ../../c-api/unicode.rst:509
msgid ":attr:`%i`"
msgstr ""

#: ../../c-api/unicode.rst:509
msgid "Equivalent to ``printf(\"%i\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%i\")``. [1]_"

#: ../../c-api/unicode.rst:512
msgid ":attr:`%x`"
msgstr ""

#: ../../c-api/unicode.rst:512
msgid "Equivalent to ``printf(\"%x\")``. [1]_"
msgstr "Эквивалентно ``printf(\"%x\")``. [1]_"

#: ../../c-api/unicode.rst:515
msgid ":attr:`%s`"
msgstr ""

#: ../../c-api/unicode.rst:515
msgid "const char\\*"
msgstr "const char\\*"

#: ../../c-api/unicode.rst:515
msgid "A null-terminated C character array."
msgstr "Нуль-терминированный массив символов С."

#: ../../c-api/unicode.rst:518
msgid ":attr:`%p`"
msgstr ""

#: ../../c-api/unicode.rst:518
msgid "const void\\*"
msgstr "const void\\*"

#: ../../c-api/unicode.rst:518
msgid ""
"The hex representation of a C pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"Шестнадцатеричное представление указателя на языке Си. В основном "
"эквивалентно ``printf(\"%p\")``, за исключением того, что оно гарантированно "
"начинается с литерала ``0x`` независимо от того, что дает ``printf`` "
"платформы."

#: ../../c-api/unicode.rst:526
msgid ":attr:`%A`"
msgstr ""

#: ../../c-api/unicode.rst:526 ../../c-api/unicode.rst:529
#: ../../c-api/unicode.rst:538 ../../c-api/unicode.rst:541
msgid "PyObject\\*"
msgstr ""

#: ../../c-api/unicode.rst:526
msgid "The result of calling :func:`ascii`."
msgstr "Результат вызова :func:`ascii`."

#: ../../c-api/unicode.rst:529
msgid ":attr:`%U`"
msgstr ""

#: ../../c-api/unicode.rst:529
msgid "A Unicode object."
msgstr "Объект в Юникоде."

#: ../../c-api/unicode.rst:531
msgid ":attr:`%V`"
msgstr ""

#: ../../c-api/unicode.rst:531
msgid "PyObject\\*, const char\\*"
msgstr ""

#: ../../c-api/unicode.rst:531
msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"Объект Unicode (который может быть ``NULL``) и нуль-терминированный массив "
"символов C в качестве второго параметра (который будет использоваться, если "
"первый параметр равен ``NULL``)."

#: ../../c-api/unicode.rst:538
msgid ":attr:`%S`"
msgstr ""

#: ../../c-api/unicode.rst:538
msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "Результат вызова :c:func:`PyObject_Str`."

#: ../../c-api/unicode.rst:541
msgid ":attr:`%R`"
msgstr ""

#: ../../c-api/unicode.rst:541
msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "Результат вызова :c:func:`PyObject_Repr`."

#: ../../c-api/unicode.rst:545
msgid ""
"An unrecognized format character causes all the rest of the format string to "
"be copied as-is to the result string, and any extra arguments discarded."
msgstr ""

#: ../../c-api/unicode.rst:549
msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes for ``\"%s\"`` and ``\"%V\"`` "
"(if the ``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""

#: ../../c-api/unicode.rst:555
msgid ""
"For integer specifiers (d, u, ld, li, lu, lld, lli, llu, zd, zi, zu, i, x): "
"the 0-conversion flag has effect even when a precision is given."
msgstr ""

#: ../../c-api/unicode.rst:558
msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "Добавлена ​​поддержка ``\"%lld\"`` и ``%llu\"``."

#: ../../c-api/unicode.rst:561
msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "Поддержка ``\"%li\"``, ``\"%lli\"`` и ``\" %день \"`` добавил."

#: ../../c-api/unicode.rst:564
msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr ""
"Поддержка форматирования ширины и точности для ``\" %s \"``, ``\" %А "
"Добавлены \"``, ``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"``."

#: ../../c-api/unicode.rst:571
msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two "
"arguments."
msgstr ""
"Идентичен :c:func:`PyUnicode_FromFormat`, за исключением того, что он "
"принимает ровно два аргумента."

#: ../../c-api/unicode.rst:577
msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return "
"a new :term:`strong reference` to the object."
msgstr ""
"При необходимости скопируйте экземпляр подтипа Юникода в новый настоящий "
"объект Юникода. Если *obj* уже является настоящим объектом Unicode (а не "
"подтипом), верните новую :term:`strong ссылку` на объект."

#: ../../c-api/unicode.rst:581
msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr ""
"Объекты, отличные от Unicode или его подтипов, вызовут ошибку :exc:"
"`TypeError`."

#: ../../c-api/unicode.rst:587
msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "Декодируйте закодированный объект *obj* в объект Unicode."

#: ../../c-api/unicode.rst:589
msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using "
"the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes`, :class:`bytearray` и другие :term:`байтоподобные объекты "
"<байтоподобный объект>` декодируются в соответствии с заданной *кодировкой* "
"и с использованием обработки ошибок, определенной *errors*. Оба могут иметь "
"значение ``NULL``, чтобы интерфейс использовал значения по умолчанию "
"(подробнее см. :ref:`builtincodecs`)."

#: ../../c-api/unicode.rst:595
msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be "
"set."
msgstr ""
"Все остальные объекты, включая объекты Unicode, вызывают установку :exc:"
"`TypeError`."

#: ../../c-api/unicode.rst:598
msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr ""
"API возвращает NULL, если произошла ошибка. Вызывающая сторона несет "
"ответственность за удаление возвращаемых объектов."

#: ../../c-api/unicode.rst:604
msgid "Return the length of the Unicode object, in code points."
msgstr "Возвращает длину объекта Unicode в кодовых точках."

#: ../../c-api/unicode.rst:615
msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to :c:func:`!"
"memcpy` if possible.  Returns ``-1`` and sets an exception on error, "
"otherwise returns the number of copied characters."
msgstr ""
"Копирование символов из одного объекта Unicode в другой. Эта функция "
"выполняет преобразование символов, когда это необходимо, и, если возможно, "
"возвращается к :c:func:`!memcpy`. Возвращает ``-1`` и устанавливает "
"исключение в случае ошибки, в противном случае возвращает количество "
"скопированных символов."

#: ../../c-api/unicode.rst:626
msgid ""
"Fill a string with a character: write *fill_char* into ``unicode[start:"
"start+length]``."
msgstr ""
"Заполните строку символом: напишите *fill_char* в ``unicode[start:"
"start+length]``."

#: ../../c-api/unicode.rst:629
msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr ""
"Ошибка, если *fill_char* больше максимального символа строки или если строка "
"содержит более 1 ссылки."

#: ../../c-api/unicode.rst:632
msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr ""
"Верните количество записанных символов или верните ``-1`` и вызовите "
"исключение в случае ошибки."

#: ../../c-api/unicode.rst:641
msgid ""
"Write a character to a string.  The string must have been created through :c:"
"func:`PyUnicode_New`.  Since Unicode strings are supposed to be immutable, "
"the string must not be shared, or have been hashed yet."
msgstr ""
"Запишите символ в строку. Строка должна быть создана с помощью :c:func:"
"`PyUnicode_New`. Поскольку строки Юникода должны быть неизменяемыми, строка "
"не должна быть общедоступной или еще не хеширована."

#: ../../c-api/unicode.rst:645
msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object can be modified safely (i.e. that it "
"its reference count is one)."
msgstr ""
"Эта функция проверяет, что *unicode* является объектом Unicode, что индекс "
"не выходит за пределы и что объект можно безопасно изменить (т. е. что его "
"счетчик ссылок равен единице)."

#: ../../c-api/unicode.rst:654
msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to :c:func:"
"`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""
"Считайте символ из строки. Эта функция проверяет, что *unicode* является "
"объектом Unicode и индекс не выходит за пределы, в отличие от :c:func:"
"`PyUnicode_READ_CHAR`, которая не выполняет проверку ошибок."

#: ../../c-api/unicode.rst:664
msgid ""
"Return a substring of *unicode*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported."
msgstr ""

#: ../../c-api/unicode.rst:673
msgid ""
"Copy the string *unicode* into a UCS4 buffer, including a null character, if "
"*copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*unicode*).  *buffer* is returned on success."
msgstr ""
"Скопируйте строку *unicode* в буфер UCS4, включая нулевой символ, если "
"установлено *copy_null*. Возвращает ``NULL`` и устанавливает исключение в "
"случае ошибки (в частности, :exc:`SystemError`, если *buflen* меньше длины "
"*unicode*). *buffer* возвращается в случае успеха."

#: ../../c-api/unicode.rst:683
msgid ""
"Copy the string *unicode* into a new UCS4 buffer that is allocated using :c:"
"func:`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a :exc:"
"`MemoryError` set.  The returned buffer always has an extra null code point "
"appended."
msgstr ""
"Скопируйте строку *unicode* в новый буфер UCS4, выделенный с помощью :c:func:"
"`PyMem_Malloc`. Если это не удается, возвращается ``NULL`` с установленным :"
"exc:`MemoryError`. К возвращенному буферу всегда добавляется дополнительная "
"нулевая кодовая точка."

#: ../../c-api/unicode.rst:692
msgid "Deprecated Py_UNICODE APIs"
msgstr ""

#: ../../c-api/unicode.rst:696
msgid ""
"These API functions are deprecated with the implementation of :pep:`393`. "
"Extension modules can continue using them, as they will not be removed in "
"Python 3.x, but need to be aware that their use can now cause performance "
"and memory hits."
msgstr ""

#: ../../c-api/unicode.rst:703
msgid ""
"Create a Unicode object from the Py_UNICODE buffer *u* of the given size. "
"*u* may be ``NULL`` which causes the contents to be undefined. It is the "
"user's responsibility to fill in the needed data.  The buffer is copied into "
"the new object."
msgstr ""

#: ../../c-api/unicode.rst:708
msgid ""
"If the buffer is not ``NULL``, the return value might be a shared object. "
"Therefore, modification of the resulting Unicode object is only allowed when "
"*u* is ``NULL``."
msgstr ""

#: ../../c-api/unicode.rst:712
msgid ""
"If the buffer is ``NULL``, :c:func:`PyUnicode_READY` must be called once the "
"string content has been filled before using any of the access macros such "
"as :c:func:`PyUnicode_KIND`."
msgstr ""

#: ../../c-api/unicode.rst:719
msgid ""
"Part of the old-style Unicode API, please migrate to using :c:func:"
"`PyUnicode_FromKindAndData`, :c:func:`PyUnicode_FromWideChar`, or :c:func:"
"`PyUnicode_New`."
msgstr ""

#: ../../c-api/unicode.rst:724
msgid ""
"Return a read-only pointer to the Unicode object's internal :c:type:"
"`Py_UNICODE` buffer, or ``NULL`` on error. This will create the :c:expr:"
"`Py_UNICODE*` representation of the object if it is not yet available. The "
"buffer is always terminated with an extra null code point. Note that the "
"resulting :c:type:`Py_UNICODE` string may also contain embedded null code "
"points, which would cause the string to be truncated when used in most C "
"functions."
msgstr ""

#: ../../c-api/unicode.rst:735 ../../c-api/unicode.rst:751
msgid ""
"Part of the old-style Unicode API, please migrate to using :c:func:"
"`PyUnicode_AsUCS4`, :c:func:`PyUnicode_AsWideChar`, :c:func:"
"`PyUnicode_ReadChar` or similar new APIs."
msgstr ""

#: ../../c-api/unicode.rst:740
msgid ""
"Like :c:func:`PyUnicode_AsUnicode`, but also saves the :c:func:`Py_UNICODE` "
"array length (excluding the extra null terminator) in *size*. Note that the "
"resulting :c:expr:`Py_UNICODE*` string may contain embedded null code "
"points, which would cause the string to be truncated when used in most C "
"functions."
msgstr ""

#: ../../c-api/unicode.rst:756
msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation, in "
"code units (this includes surrogate pairs as 2 units)."
msgstr ""

#: ../../c-api/unicode.rst:765
msgid "Locale Encoding"
msgstr "Кодировка языка"

#: ../../c-api/unicode.rst:767
msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr ""
"Текущую кодировку локали можно использовать для декодирования текста из "
"операционной системы."

#: ../../c-api/unicode.rst:774
msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a "
"null character but cannot contain embedded null characters."
msgstr ""
"Декодируйте строку из UTF-8 на Android и VxWorks или из текущей кодировки "
"локали на других платформах. Поддерживаемые обработчики ошибок: "
"``\"strict\"`` и ``\"surrogateescape\"`` (:pep:`383`). Декодер использует "
"``строгий'` обработчик ошибок, если *errors* имеет значение ``NULL``. *str* "
"должен заканчиваться нулевым символом, но не может содержать встроенные "
"нулевые символы."

#: ../../c-api/unicode.rst:781
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from :c:"
"data:`Py_FileSystemDefaultEncoding` (the locale encoding read at Python "
"startup)."
msgstr ""

#: ../../c-api/unicode.rst:785 ../../c-api/unicode.rst:821
msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "Эта функция игнорирует :ref:`Режим Python UTF-8 <utf8-mode>`."

#: ../../c-api/unicode.rst:789 ../../c-api/unicode.rst:892
msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "Функция :c:func:`Py_DecodeLocale`."

#: ../../c-api/unicode.rst:793
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_DecodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"Функция теперь также использует текущую языковую кодировку для обработчика "
"ошибок surrogateescape, за исключением Android. Ранее :c:func:"
"`Py_DecodeLocale` использовался для ``surrogateescape``, а текущая кодировка "
"локали использовалась для``strict``."

#: ../../c-api/unicode.rst:802
msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`!strlen`."
msgstr ""
"Аналогично :c:func:`PyUnicode_DecodeLocaleAndSize`, но длину строки "
"вычислите, используя :c:func:`!strlen`."

#: ../../c-api/unicode.rst:810
msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a :class:"
"`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"Закодируйте объект Unicode в UTF-8 на Android и VxWorks или в текущую "
"языковую кодировку на других платформах. Поддерживаемые обработчики ошибок: "
"``\"strict\"`` и ``\"surrogateescape\"`` (:pep:`383`). Кодировщик использует "
"``строгий'` обработчик ошибок, если *errors* имеет значение ``NULL``. "
"Верните объект :class:`bytes`. *unicode* не может содержать встроенные "
"нулевые символы."

#: ../../c-api/unicode.rst:817
msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to :c:data:"
"`Py_FileSystemDefaultEncoding` (the locale encoding read at Python startup)."
msgstr ""

#: ../../c-api/unicode.rst:825 ../../c-api/unicode.rst:928
msgid "The :c:func:`Py_EncodeLocale` function."
msgstr "Функция :c:func:`Py_EncodeLocale`."

#: ../../c-api/unicode.rst:829
msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_EncodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"Функция теперь также использует текущую языковую кодировку для обработчика "
"ошибок surrogateescape, за исключением Android. Ранее :c:func:"
"`Py_EncodeLocale` использовался для ``surrogateescape``, а текущая кодировка "
"локали использовалась для``strict``."

#: ../../c-api/unicode.rst:838
msgid "File System Encoding"
msgstr "Кодировка файловой системы"

#: ../../c-api/unicode.rst:840
msgid ""
"To encode and decode file names and other environment strings, :c:data:"
"`Py_FileSystemDefaultEncoding` should be used as the encoding, and :c:data:"
"`Py_FileSystemDefaultEncodeErrors` should be used as the error handler (:pep:"
"`383` and :pep:`529`). To encode file names to :class:`bytes` during "
"argument parsing, the ``\"O&\"`` converter should be used, passing :c:func:"
"`PyUnicode_FSConverter` as the conversion function:"
msgstr ""

#: ../../c-api/unicode.rst:849
msgid ""
"ParseTuple converter: encode :class:`str` objects -- obtained directly or "
"through the :class:`os.PathLike` interface -- to :class:`bytes` using :c:"
"func:`PyUnicode_EncodeFSDefault`; :class:`bytes` objects are output as-is. "
"*result* must be a :c:expr:`PyBytesObject*` which must be released when it "
"is no longer used."
msgstr ""
"Конвертер ParseTuple: кодирует объекты :class:`str`, полученные напрямую или "
"через интерфейс :class:`os.PathLike`, в :class:`bytes` с помощью :c:func:"
"`PyUnicode_EncodeFSDefault`; Объекты :class:`bytes` выводятся как есть. "
"*result* должен быть :c:expr:`PyBytesObject*`, который должен быть "
"освобожден, когда он больше не используется."

#: ../../c-api/unicode.rst:857 ../../c-api/unicode.rst:874
msgid "Accepts a :term:`path-like object`."
msgstr "Принимает :term:`объект, похожий на путь`."

#: ../../c-api/unicode.rst:860
msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"`` "
"converter should be used, passing :c:func:`PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""
"Чтобы декодировать имена файлов в :class:`str` во время анализа аргументов, "
"следует использовать конвертер ``\"O&\"``, передавая :c:func:"
"`PyUnicode_FSDecoder` в качестве функции преобразования:"

#: ../../c-api/unicode.rst:866
msgid ""
"ParseTuple converter: decode :class:`bytes` objects -- obtained either "
"directly or indirectly through the :class:`os.PathLike` interface -- to :"
"class:`str` using :c:func:`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` "
"objects are output as-is. *result* must be a :c:expr:`PyUnicodeObject*` "
"which must be released when it is no longer used."
msgstr ""
"Конвертер ParseTuple: декодирует объекты :class:`bytes`, полученные прямо "
"или косвенно через интерфейс :class:`os.PathLike`, в :class:`str` с помощью :"
"c:func:`PyUnicode_DecodeFSDefaultAndSize`; Объекты :class:`str` выводятся "
"как есть. *result* должен быть :c:expr:`PyUnicodeObject*`, который должен "
"быть освобожден, когда он больше не используется."

#: ../../c-api/unicode.rst:880
msgid "Decode a string from the :term:`filesystem encoding and error handler`."
msgstr ""
"Декодируйте строку из :term:`кодировки файловой системы и обработчика "
"ошибок`."

#: ../../c-api/unicode.rst:882 ../../c-api/unicode.rst:903
#: ../../c-api/unicode.rst:919
msgid ""
"If :c:data:`Py_FileSystemDefaultEncoding` is not set, fall back to the "
"locale encoding."
msgstr ""

#: ../../c-api/unicode.rst:885
msgid ""
":c:data:`Py_FileSystemDefaultEncoding` is initialized at startup from the "
"locale encoding and cannot be modified later. If you need to decode a string "
"from the current locale encoding, use :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."
msgstr ""

#: ../../c-api/unicode.rst:894 ../../c-api/unicode.rst:908
#: ../../c-api/unicode.rst:932
msgid "Use :c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
msgstr ""

#: ../../c-api/unicode.rst:900
msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr ""
"Декодируйте строку с нулевым символом в конце из :term:`кодирования файловой "
"системы и обработчика ошибок`."

#: ../../c-api/unicode.rst:906
msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` if you know the string length."
msgstr ""

#: ../../c-api/unicode.rst:914
msgid ""
"Encode a Unicode object to :c:data:`Py_FileSystemDefaultEncoding` with the :"
"c:data:`Py_FileSystemDefaultEncodeErrors` error handler, and return :class:"
"`bytes`. Note that the resulting :class:`bytes` object may contain null "
"bytes."
msgstr ""

#: ../../c-api/unicode.rst:922
msgid ""
":c:data:`Py_FileSystemDefaultEncoding` is initialized at startup from the "
"locale encoding and cannot be modified later. If you need to encode a string "
"to the current locale encoding, use :c:func:`PyUnicode_EncodeLocale`."
msgstr ""

#: ../../c-api/unicode.rst:936
msgid "wchar_t Support"
msgstr "поддержка wchar_t"

#: ../../c-api/unicode.rst:938
msgid ":c:type:`wchar_t` support for platforms which support it:"
msgstr ":c:type:`wchar_t` поддержка платформ, которые его поддерживают:"

#: ../../c-api/unicode.rst:942
msgid ""
"Create a Unicode object from the :c:type:`wchar_t` buffer *wstr* of the "
"given *size*. Passing ``-1`` as the *size* indicates that the function must "
"itself compute the length, using :c:func:`!wcslen`. Return ``NULL`` on "
"failure."
msgstr ""
"Создайте объект Unicode из буфера :c:type:`wchar_t` *wstr* заданного "
"*размера*. Передача ``-1`` в качестве *size* указывает, что функция должна "
"сама вычислить длину, используя :c:func:`!wcslen`. Возвращайте ``NULL`` в "
"случае неудачи."

#: ../../c-api/unicode.rst:950
msgid ""
"Copy the Unicode object contents into the :c:type:`wchar_t` buffer *wstr*.  "
"At most *size* :c:type:`wchar_t` characters are copied (excluding a possibly "
"trailing null termination character).  Return the number of :c:type:"
"`wchar_t` characters copied or ``-1`` in case of an error."
msgstr ""
"Скопируйте содержимое объекта Unicode в буфер :c:type:`wchar_t` *wstr*. "
"Копируется не более символов *size* :c:type:`wchar_t` (исключая, возможно, "
"завершающий нулевой символ завершения). Возвращает количество скопированных "
"символов :c:type:`wchar_t` или ``-1`` в случае ошибки."

#: ../../c-api/unicode.rst:955
msgid ""
"When *wstr* is ``NULL``, instead return the *size* that would be required to "
"store all of *unicode* including a terminating null."
msgstr ""
"Если *wstr* имеет значение ``NULL``, вместо этого возвращайте *size*, "
"который потребуется для хранения всего *unicode*, включая завершающий нуль."

#: ../../c-api/unicode.rst:958
msgid ""
"Note that the resulting :c:expr:`wchar_t*` string may or may not be null-"
"terminated.  It is the responsibility of the caller to make sure that the :c:"
"expr:`wchar_t*` string is null-terminated in case this is required by the "
"application. Also, note that the :c:expr:`wchar_t*` string might contain "
"null characters, which would cause the string to be truncated when used with "
"most C functions."
msgstr ""
"Обратите внимание, что результирующая строка :c:expr:`wchar_t*` может "
"заканчиваться нулем, а может и не заканчиваться. Вызывающая сторона несет "
"ответственность за то, чтобы строка :c:expr:`wchar_t*` завершалась нулем, "
"если это требуется приложению. Также обратите внимание, что строка :c:expr:"
"`wchar_t*` может содержать нулевые символы, что приведет к усечению строки "
"при использовании с большинством функций C."

#: ../../c-api/unicode.rst:968
msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:type:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the :c:expr:"
"`wchar_t*` string contains null characters a :exc:`ValueError` is raised."
msgstr ""
"Преобразуйте объект Unicode в строку широких символов. Выходная строка "
"всегда заканчивается нулевым символом. Если *size* не равно ``NULL``, "
"запишите количество широких символов (исключая завершающий нулевой символ "
"завершения) в *\\*size*. Обратите внимание, что результирующая строка :c:"
"type:`wchar_t` может содержать нулевые символы, что приведет к усечению "
"строки при использовании с большинством функций C. Если *size* имеет "
"значение ``NULL`` и строка :c:expr:`wchar_t*` содержит нулевые символы, "
"возникает :exc:`ValueError`."

#: ../../c-api/unicode.rst:976
msgid ""
"Returns a buffer allocated by :c:macro:`PyMem_New` (use :c:func:`PyMem_Free` "
"to free it) on success. On error, returns ``NULL`` and *\\*size* is "
"undefined. Raises a :exc:`MemoryError` if memory allocation is failed."
msgstr ""
"Возвращает буфер, выделенный :c:macro:`PyMem_New` (используйте :c:func:"
"`PyMem_Free`, чтобы освободить его) в случае успеха. В случае ошибки "
"возвращается ``NULL`` и *\\*size* не определен. Вызывает :exc:`MemoryError`, "
"если выделение памяти не удалось."

#: ../../c-api/unicode.rst:983
msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:expr:`wchar_t*` "
"string contains null characters."
msgstr ""
"Вызывает ошибку :exc:`ValueError`, если *size* имеет значение ``NULL`` и "
"строка :c:expr:`wchar_t*` содержит нулевые символы."

#: ../../c-api/unicode.rst:991
msgid "Built-in Codecs"
msgstr "Встроенные кодеки"

#: ../../c-api/unicode.rst:993
msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr ""
"Python предоставляет набор встроенных кодеков, которые для скорости написаны "
"на C. Все эти кодеки можно использовать напрямую с помощью следующих функций."

#: ../../c-api/unicode.rst:996
msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"Многие из следующих API принимают два аргумента: кодирование и ошибки, и они "
"имеют ту же семантику, что и встроенный конструктор строковых объектов :func:"
"`str`."

#: ../../c-api/unicode.rst:1000
msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is "
"UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` for "
"encoding file names. This uses the variable :c:data:"
"`Py_FileSystemDefaultEncoding` internally. This variable should be treated "
"as read-only: on some systems, it will be a pointer to a static string, on "
"others, it will change at run-time (such as when the application invokes "
"setlocale)."
msgstr ""

#: ../../c-api/unicode.rst:1008
msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to "
"use the default handling defined for the codec.  Default error handling for "
"all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"Обработка ошибок задается ошибками, для которых также может быть установлено "
"значение NULL, что означает использование обработки по умолчанию, "
"определенной для кодека. Обработка ошибок по умолчанию для всех встроенных "
"кодеков является «строгой» (возникает:exc:`ValueError`)."

#: ../../c-api/unicode.rst:1012
msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr ""
"Все кодеки используют схожий интерфейс. Для простоты документированы только "
"отклонения от следующих общих значений."

#: ../../c-api/unicode.rst:1017
msgid "Generic Codecs"
msgstr "Универсальные кодеки"

#: ../../c-api/unicode.rst:1019
msgid "These are the generic codec APIs:"
msgstr "Это общие API-интерфейсы кодеков:"

#: ../../c-api/unicode.rst:1025
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string "
"*str*. *encoding* and *errors* have the same meaning as the parameters of "
"the same name in the :func:`str` built-in function.  The codec to be used is "
"looked up using the Python codec registry.  Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты закодированной строки "
"*str*. *encoding* и *errors* имеют то же значение, что и одноименные "
"параметры во встроенной функции :func:`str`. Кодек, который будет "
"использоваться, ищется в реестре кодеков Python. Верните NULL, если кодек "
"вызвал исключение."

#: ../../c-api/unicode.rst:1035
msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Закодируйте объект Unicode и верните результат как объект байтов Python. "
"*encoding* и *errors* имеют то же значение, что и одноименные параметры в "
"методе Unicode :meth:`~str.encode`. Кодек, который будет использоваться, "
"ищется в реестре кодеков Python. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1043
msgid "UTF-8 Codecs"
msgstr "Кодеки UTF-8"

#: ../../c-api/unicode.rst:1045
msgid "These are the UTF-8 codec APIs:"
msgstr "Это API-интерфейсы кодека UTF-8:"

#: ../../c-api/unicode.rst:1050
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"UTF-8. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1057
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Если *consumed* равно NULL, ведите себя как :c:func:`PyUnicode_DecodeUTF8`. "
"Если *consumed* не равно NULL, конечные неполные последовательности байтов "
"UTF-8 не будут рассматриваться как ошибка. Эти байты не будут декодированы, "
"а количество декодированных байтов будет сохранено в *consumed*."

#: ../../c-api/unicode.rst:1065
msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодируйте объект Unicode, используя UTF-8, и верните результат как объект "
"байтов Python. Обработка ошибок является «строгой». Верните NULL, если кодек "
"вызвал исключение."

#: ../../c-api/unicode.rst:1072
msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned "
"buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"Верните указатель на кодировку UTF-8 объекта Unicode и сохраните размер "
"закодированного представления (в байтах) в *size*. Аргумент *size* может "
"иметь значение ``NULL``; в этом случае размер не будет сохранен. К "
"возвращаемому буферу всегда добавляется дополнительный нулевой байт (не "
"включенный в *size*), независимо от того, есть ли какие-либо другие нулевые "
"кодовые точки."

#: ../../c-api/unicode.rst:1078
msgid ""
"In the case of an error, ``NULL`` is returned with an exception set and no "
"*size* is stored."
msgstr ""
"В случае ошибки возвращается NULL с набором исключений и *size* не "
"сохраняется."

#: ../../c-api/unicode.rst:1081
msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"При этом представление строки в формате UTF-8 кэшируется в объекте Unicode, "
"а последующие вызовы будут возвращать указатель на тот же буфер. Вызывающий "
"не несет ответственности за освобождение буфера. Буфер освобождается, и "
"указатели на него становятся недействительными, когда объект Unicode "
"очищается от мусора."

#: ../../c-api/unicode.rst:1088 ../../c-api/unicode.rst:1101
msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "Тип возвращаемого значения теперь ``const char *``, а не ``char *``."

#: ../../c-api/unicode.rst:1091
msgid "This function is a part of the :ref:`limited API <limited-c-api>`."
msgstr "Эта функция является частью :ref:`limited API <limited-c-api>`."

#: ../../c-api/unicode.rst:1097
msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "Как :c:func:`PyUnicode_AsUTF8AndSize`, но размер не сохраняется."

#: ../../c-api/unicode.rst:1106
msgid "UTF-32 Codecs"
msgstr "Кодеки UTF-32"

#: ../../c-api/unicode.rst:1108
msgid "These are the UTF-32 codec APIs:"
msgstr "Это API-интерфейсы кодека UTF-32:"

#: ../../c-api/unicode.rst:1114
msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Декодируйте *size* байты из буферной строки в кодировке UTF-32 и верните "
"соответствующий объект Unicode. *errors* (если не NULL) определяет обработку "
"ошибок. По умолчанию установлено значение «строгое»."

#: ../../c-api/unicode.rst:1118 ../../c-api/unicode.rst:1168
msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr ""
"Если *byteorder* не равен NULL, декодер начинает декодирование, используя "
"заданный порядок байтов:"

#: ../../c-api/unicode.rst:1125
msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"Если ``*byteorder`` равен нулю, а первые четыре байта входных данных "
"представляют собой метку порядка байтов (BOM), декодер переключается на этот "
"порядок байтов, и BOM не копируется в результирующую строку Unicode. Если "
"``*byteorder`` равен ``-1`` или ``1``, любая метка порядка байтов копируется "
"на выход."

#: ../../c-api/unicode.rst:1130
msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end "
"of input data."
msgstr ""
"После завершения *\\*byteorder* устанавливается на текущий порядок байтов в "
"конце входных данных."

#: ../../c-api/unicode.rst:1133 ../../c-api/unicode.rst:1184
msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr ""
"Если *byteorder* имеет значение ``NULL``, кодек запускается в собственном "
"режиме порядка."

#: ../../c-api/unicode.rst:1135 ../../c-api/unicode.rst:1186
msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1141
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not "
"treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Если *consumed* равно NULL, ведите себя как :c:func:`PyUnicode_DecodeUTF32`. "
"Если *consumed* не равно NULL, :c:func:`PyUnicode_DecodeUTF32Stateful` не "
"будет рассматривать конечные неполные последовательности байтов UTF-32 "
"(например, количество байтов, не делящихся на четыре) как ошибку. Эти байты "
"не будут декодированы, а количество декодированных байтов будет сохранено в "
"*consumed*."

#: ../../c-api/unicode.rst:1150
msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Возвращает строку байтов Python, используя кодировку UTF-32 в собственном "
"порядке байтов. Строка всегда начинается с метки спецификации. Обработка "
"ошибок является «строгой». Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1156
msgid "UTF-16 Codecs"
msgstr "Кодеки UTF-16"

#: ../../c-api/unicode.rst:1158
msgid "These are the UTF-16 codec APIs:"
msgstr "Это API-интерфейсы кодека UTF-16:"

#: ../../c-api/unicode.rst:1164
msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Декодируйте *size* байты из буферной строки в кодировке UTF-16 и верните "
"соответствующий объект Unicode. *errors* (если не NULL) определяет обработку "
"ошибок. По умолчанию установлено значение «строгое»."

#: ../../c-api/unicode.rst:1175
msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"Если ``*byteorder`` равен нулю, а первые два байта входных данных "
"представляют собой метку порядка байтов (BOM), декодер переключается на этот "
"порядок байтов, и BOM не копируется в результирующую строку Unicode. Если "
"``*byteorder`` равен ``-1`` или ``1``, любая метка порядка байтов копируется "
"на выход (где это приведет либо к ``\\ufeff``, либо к ``\\ufffe `` персонаж)."

#: ../../c-api/unicode.rst:1181
msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end "
"of input data."
msgstr ""
"После завершения ``*byteorder`` устанавливается на текущий порядок байтов в "
"конце входных данных."

#: ../../c-api/unicode.rst:1192
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not "
"treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"Если *consumed* равно NULL, ведите себя как :c:func:`PyUnicode_DecodeUTF16`. "
"Если *consumed* не равно ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` "
"не будет рассматривать конечные неполные последовательности байтов UTF-16 "
"(например, нечетное число байтов или разделенную суррогатную пару) как "
"ошибку. Эти байты не будут декодированы, а количество декодированных байтов "
"будет сохранено в *consumed*."

#: ../../c-api/unicode.rst:1201
msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Возвращает строку байтов Python, используя кодировку UTF-16 в собственном "
"порядке байтов. Строка всегда начинается с метки спецификации. Обработка "
"ошибок является «строгой». Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1207
msgid "UTF-7 Codecs"
msgstr "Кодеки UTF-7"

#: ../../c-api/unicode.rst:1209
msgid "These are the UTF-7 codec APIs:"
msgstr "Это API-интерфейсы кодека UTF-7:"

#: ../../c-api/unicode.rst:1214
msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string "
"*str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"UTF-7. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1221
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Если *consumed* равно NULL, ведите себя как :c:func:`PyUnicode_DecodeUTF7`. "
"Если *consumed* не равно NULL, конечные неполные разделы UTF-7 base-64 не "
"будут рассматриваться как ошибка. Эти байты не будут декодированы, а "
"количество декодированных байтов будет сохранено в *consumed*."

#: ../../c-api/unicode.rst:1228
msgid "Unicode-Escape Codecs"
msgstr "Кодеки Unicode-Escape"

#: ../../c-api/unicode.rst:1230
msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "Это API-интерфейсы кодека Unicode Escape:"

#: ../../c-api/unicode.rst:1236
msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"Unicode-Escape. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1242
msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Закодируйте объект Unicode с помощью Unicode-Escape и верните результат в "
"виде байтового объекта. Обработка ошибок является «строгой». Верните NULL, "
"если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1248
msgid "Raw-Unicode-Escape Codecs"
msgstr "Кодеки Raw-Unicode-Escape"

#: ../../c-api/unicode.rst:1250
msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "Это API-интерфейсы кодека Raw Unicode Escape:"

#: ../../c-api/unicode.rst:1256
msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *str*.  Return ``NULL`` if an exception was raised by the "
"codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"Raw-Unicode-Escape. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1262
msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Закодируйте объект Unicode с помощью Raw-Unicode-Escape и верните результат "
"в виде байтового объекта. Обработка ошибок является «строгой». Верните NULL, "
"если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1268
msgid "Latin-1 Codecs"
msgstr "Кодеки Latin-1"

#: ../../c-api/unicode.rst:1270
msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr ""
"Это API-интерфейсы кодека Latin-1: Latin-1 соответствует первым 256 "
"порядковым номерам Unicode, и только они принимаются кодеками во время "
"кодирования."

#: ../../c-api/unicode.rst:1276
msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"Latin-1. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1282
msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодируйте объект Unicode, используя Latin-1, и верните результат как "
"объект байтов Python. Обработка ошибок является «строгой». Верните NULL, "
"если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1288
msgid "ASCII Codecs"
msgstr "Кодеки ASCII"

#: ../../c-api/unicode.rst:1290
msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr ""
"Это API-интерфейсы кодека ASCII. Принимаются только 7-битные данные ASCII. "
"Все остальные коды выдают ошибки."

#: ../../c-api/unicode.rst:1296
msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string "
"*str*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки *str* в кодировке "
"ASCII. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1302
msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодируйте объект Unicode, используя ASCII, и верните результат как объект "
"байтов Python. Обработка ошибок является «строгой». Верните NULL, если кодек "
"вызвал исключение."

#: ../../c-api/unicode.rst:1308
msgid "Character Map Codecs"
msgstr "Кодеки карты символов"

#: ../../c-api/unicode.rst:1310
msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`!encodings` package). The codec uses mappings "
"to encode and decode characters.  The mapping objects provided must support "
"the :meth:`~object.__getitem__` mapping interface; dictionaries and "
"sequences work well."
msgstr ""
"Этот кодек уникален тем, что с его помощью можно реализовать множество "
"различных кодеков (именно это и было сделано для получения большинства "
"стандартных кодеков, включенных в пакет :mod:`!encodings`). Кодек использует "
"сопоставления для кодирования и декодирования символов. Предоставленные "
"объекты сопоставления должны поддерживать интерфейс сопоставления :meth:"
"`~object.__getitem__`; словари и последовательности работают хорошо."

#: ../../c-api/unicode.rst:1316
msgid "These are the mapping codec APIs:"
msgstr "Это API-интерфейсы кодеков сопоставления:"

#: ../../c-api/unicode.rst:1321
msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *str* "
"using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты закодированной строки "
"*str*, используя данный объект *mapping*. Верните NULL, если кодек вызвал "
"исключение."

#: ../../c-api/unicode.rst:1325
msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"Если *mapping* имеет значение ``NULL``, будет применено декодирование "
"Latin-1. В противном случае *отображение* должно отображать порядковые "
"номера байтов (целые числа в диапазоне от 0 до 255) в строки Unicode, целые "
"числа (которые затем интерпретируются как порядковые номера Unicode) или "
"``None``. Несопоставленные байты данных — те, которые вызывают :exc:"
"`LookupError`, а также те, которые отображаются в ``None``, ``0xFFFE`` или "
"``'\\ufffe'``, рассматриваются как неопределенные сопоставления. и вызвать "
"ошибку."

#: ../../c-api/unicode.rst:1336
msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if "
"an exception was raised by the codec."
msgstr ""
"Закодируйте объект Unicode, используя данный объект *mapping*, и верните "
"результат в виде байтового объекта. Обработка ошибок является «строгой». "
"Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1340
msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"Объект *mapping* должен отображать порядковые целые числа Юникода в байтовые "
"объекты, целые числа в диапазоне от 0 до 255 или ``None``. Несопоставленные "
"порядковые номера символов (те, которые вызывают :exc:`LookupError`), а "
"также сопоставленные с ``None``, рассматриваются как «неопределенное "
"сопоставление» и вызывают ошибку."

#: ../../c-api/unicode.rst:1346
msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr "Следующий API кодека уникален тем, что сопоставляет Unicode с Unicode."

#: ../../c-api/unicode.rst:1350
msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr ""
"Переведите строку, применив к ней таблицу сопоставления символов, и верните "
"полученный объект Unicode. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1354
msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr ""
"Таблица сопоставления должна сопоставлять порядковые целые числа Юникода с "
"порядковыми целыми числами Юникода или «Нет» (что приводит к удалению "
"символа)."

#: ../../c-api/unicode.rst:1357
msgid ""
"Mapping tables need only provide the :meth:`~object.__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""
"Таблицы отображения должны предоставлять только интерфейс :meth:`~object."
"__getitem__`; словари и последовательности работают хорошо. Несопоставленные "
"порядковые номера символов (те, которые вызывают ошибку :exc:`LookupError`) "
"остаются нетронутыми и копируются как есть."

#: ../../c-api/unicode.rst:1361
msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr ""
"*errors* имеет обычное значение для кодеков. Это может быть ``NULL``, что "
"указывает на использование обработки ошибок по умолчанию."

#: ../../c-api/unicode.rst:1366
msgid "MBCS codecs for Windows"
msgstr "Кодеки MBCS для Windows"

#: ../../c-api/unicode.rst:1368
msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"Это API-интерфейсы кодека MBCS. В настоящее время они доступны только в "
"Windows и используют конвертеры Win32 MBCS для реализации преобразований. "
"Обратите внимание, что MBCS (или DBCS) — это класс кодировок, а не один. "
"Целевая кодировка определяется пользовательскими настройками на компьютере, "
"на котором работает кодек."

#: ../../c-api/unicode.rst:1375
msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*str*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Создайте объект Unicode, декодировав *size* байты строки в кодировке MBCS "
"*str*. Верните NULL, если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1382
msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"Если *consumed* равно NULL, ведите себя как :c:func:`PyUnicode_DecodeMBCS`. "
"Если *consumed* не равно ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` не "
"будет декодировать конечный ведущий байт, а количество декодированных байтов "
"будет сохранено в *consumed*."

#: ../../c-api/unicode.rst:1390
msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодируйте объект Unicode, используя MBCS, и верните результат в виде "
"байтового объекта Python. Обработка ошибок является «строгой». Верните NULL, "
"если кодек вызвал исключение."

#: ../../c-api/unicode.rst:1397
msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use :"
"c:macro:`!CP_ACP` code page to get the MBCS encoder."
msgstr ""
"Закодируйте объект Unicode, используя указанную кодовую страницу, и верните "
"байтовый объект Python. Верните NULL, если кодек вызвал исключение. "
"Используйте кодовую страницу :c:macro:`!CP_ACP`, чтобы получить кодировщик "
"MBCS."

#: ../../c-api/unicode.rst:1405
msgid "Methods & Slots"
msgstr "Методы и слоты"

#: ../../c-api/unicode.rst:1411
msgid "Methods and Slot Functions"
msgstr "Методы и функции слотов"

#: ../../c-api/unicode.rst:1413
msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr ""
"Следующие API-интерфейсы способны обрабатывать объекты и строки Unicode на "
"входе (в описаниях мы называем их строками) и возвращать объекты или целые "
"числа Unicode в зависимости от ситуации."

#: ../../c-api/unicode.rst:1417
msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr ""
"Все они возвращают ``NULL`` или ``-1`` в случае возникновения исключения."

#: ../../c-api/unicode.rst:1422
msgid "Concat two strings giving a new Unicode string."
msgstr "Объедините две строки, давая новую строку Unicode."

#: ../../c-api/unicode.rst:1427
msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"Разделите строку, получив список строк Юникода. Если *sep* имеет значение "
"``NULL``, разделение будет выполняться по всем подстрокам с пробелами. В "
"противном случае разделение происходит по данному разделителю. Будет "
"выполнено не более *maxsplit* разделения. Если оно отрицательное, предел не "
"устанавливается. Разделители не включаются в результирующий список."

#: ../../c-api/unicode.rst:1435
msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepends* is ``0``, the Line "
"break characters are not included in the resulting strings."
msgstr ""
"Разделите строку Юникода по разрывам строк, вернув список строк Юникода. "
"CRLF считается разрывом одной строки. Если *keepends* имеет значение ``0``, "
"символы разрыва строки не включаются в результирующие строки."

#: ../../c-api/unicode.rst:1442
msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr ""
"Соедините последовательность строк, используя заданный *разделитель*, и "
"верните полученную строку в Юникоде."

#: ../../c-api/unicode.rst:1449
msgid ""
"Return ``1`` if *substr* matches ``unicode[start:end]`` at the given tail "
"end (*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` "
"a suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""
"Возвращает ``1``, если *substr* соответствует ``unicode[start:end]`` в "
"заданном конце (*direction* == ``-1`` означает совпадение префикса, "
"*direction* == ``1`` соответствует суффиксу), ``0`` в противном случае. "
"Верните ``-1``, если произошла ошибка."

#: ../../c-api/unicode.rst:1457
msgid ""
"Return the first position of *substr* in ``unicode[start:end]`` using the "
"given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""
"Вернуть первую позицию *substr* в ``unicode[start:end]``, используя заданное "
"*direction* (*direction* == ``1`` означает прямой поиск, *direction* == `` "
"-1`` обратный поиск). Возвращаемое значение — это индекс первого совпадения; "
"значение ``-1`` указывает, что совпадение не найдено, а ``-2`` указывает, "
"что произошла ошибка и было установлено исключение."

#: ../../c-api/unicode.rst:1467
msgid ""
"Return the first position of the character *ch* in ``unicode[start:end]`` "
"using the given *direction* (*direction* == ``1`` means to do a forward "
"search, *direction* == ``-1`` a backward search).  The return value is the "
"index of the first match; a value of ``-1`` indicates that no match was "
"found, and ``-2`` indicates that an error occurred and an exception has been "
"set."
msgstr ""
"Вернуть первую позицию символа *ch* в ``unicode[start:end]``, используя "
"заданное *направление* (*direction* == ``1`` означает прямой поиск, "
"*direction* == ``-1`` обратный поиск). Возвращаемое значение — это индекс "
"первого совпадения; значение ``-1`` указывает, что совпадение не найдено, а "
"``-2`` указывает, что произошла ошибка и было установлено исключение."

#: ../../c-api/unicode.rst:1475
msgid ""
"*start* and *end* are now adjusted to behave like ``unicode[start:end]``."
msgstr ""
"*start* и *end* теперь настроены так, чтобы вести себя как ``unicode[start:"
"end]``."

#: ../../c-api/unicode.rst:1482
msgid ""
"Return the number of non-overlapping occurrences of *substr* in "
"``unicode[start:end]``.  Return ``-1`` if an error occurred."
msgstr ""
"Возвращает количество непересекающихся вхождений *substr* в ``unicode[start:"
"end]``. Верните ``-1``, если произошла ошибка."

#: ../../c-api/unicode.rst:1489
msgid ""
"Replace at most *maxcount* occurrences of *substr* in *unicode* with "
"*replstr* and return the resulting Unicode object. *maxcount* == ``-1`` "
"means replace all occurrences."
msgstr ""
"Замените не более *maxcount* вхождений *substr* в *unicode* на *replstr* и "
"верните полученный объект Unicode. *maxcount* == ``-1`` означает замену всех "
"вхождений."

#: ../../c-api/unicode.rst:1496
msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr ""
"Сравните две строки и верните ``-1``, ``0``, ``1`` для значений меньше, "
"равно и больше соответственно."

#: ../../c-api/unicode.rst:1499
msgid ""
"This function returns ``-1`` upon failure, so one should call :c:func:"
"`PyErr_Occurred` to check for errors."
msgstr ""
"Эта функция возвращает ``-1`` в случае сбоя, поэтому следует вызвать :c:func:"
"`PyErr_Occurred` для проверки ошибок."

#: ../../c-api/unicode.rst:1505
msgid ""
"Compare a Unicode object, *unicode*, with *string* and return ``-1``, ``0``, "
"``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""
"Сравните объект Unicode *unicode* со *string* и верните ``-1``, ``0``, ``1`` "
"для значений меньше, равно и больше соответственно. Лучше всего передавать "
"только строки в кодировке ASCII, но функция интерпретирует входную строку "
"как ISO-8859-1, если она содержит символы, отличные от ASCII."

#: ../../c-api/unicode.rst:1510
msgid "This function does not raise exceptions."
msgstr "Эта функция не вызывает исключений."

#: ../../c-api/unicode.rst:1515
msgid "Rich compare two Unicode strings and return one of the following:"
msgstr ""
"Rich сравнивает две строки Юникода и возвращает одно из следующих значений:"

#: ../../c-api/unicode.rst:1517
msgid "``NULL`` in case an exception was raised"
msgstr "``NULL`` в случае возникновения исключения"

#: ../../c-api/unicode.rst:1518
msgid ":c:data:`Py_True` or :c:data:`Py_False` for successful comparisons"
msgstr ":c:data:`Py_True` или :c:data:`Py_False` для успешного сравнения."

#: ../../c-api/unicode.rst:1519
msgid ":c:data:`Py_NotImplemented` in case the type combination is unknown"
msgstr ":c:data:`Py_NotImplemented` в случае, если комбинация типов неизвестна"

#: ../../c-api/unicode.rst:1521
msgid ""
"Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:"
"`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT`, and :c:macro:`Py_LE`."
msgstr ""
"Возможные значения для *op*: :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:"
"`Py_EQ`, :c:macro:`Py_NE`, :c:macro:`Py_LT ` и :c:macro:`Py_LE`."

#: ../../c-api/unicode.rst:1527
msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr ""
"Вернуть новый строковый объект из *format* и *args*; это аналогично ``format "
"% args``."

#: ../../c-api/unicode.rst:1533
msgid ""
"Check whether *substr* is contained in *unicode* and return true or false "
"accordingly."
msgstr ""
"Проверьте, содержится ли *substr* в *unicode*, и верните true или false "
"соответственно."

#: ../../c-api/unicode.rst:1536
msgid ""
"*substr* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr ""
"*substr* должен привести к одноэлементной строке Unicode. ``-1`` "
"возвращается, если произошла ошибка."

#: ../../c-api/unicode.rst:1542
msgid ""
"Intern the argument :c:expr:`*p_unicode` in place.  The argument must be the "
"address of a pointer variable pointing to a Python Unicode string object.  "
"If there is an existing interned string that is the same as :c:expr:"
"`*p_unicode`, it sets :c:expr:`*p_unicode` to it (releasing the reference to "
"the old string object and creating a new :term:`strong reference` to the "
"interned string object), otherwise it leaves :c:expr:`*p_unicode` alone and "
"interns it (creating a new :term:`strong reference`). (Clarification: even "
"though there is a lot of talk about references, think of this function as "
"reference-neutral; you own the object after the call if and only if you "
"owned it before the call.)"
msgstr ""

#: ../../c-api/unicode.rst:1555
msgid ""
"A combination of :c:func:`PyUnicode_FromString` and :c:func:"
"`PyUnicode_InternInPlace`, returning either a new Unicode string object that "
"has been interned, or a new (\"owned\") reference to an earlier interned "
"string object with the same value."
msgstr ""
