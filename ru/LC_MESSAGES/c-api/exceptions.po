# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-22 21:56+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/exceptions.rst:8
msgid "Exception Handling"
msgstr "Обработка исключений"

#: ../../c-api/exceptions.rst:10
msgid ""
"The functions described in this chapter will let you handle and raise Python "
"exceptions.  It is important to understand some of the basics of Python "
"exception handling.  It works somewhat like the POSIX :c:data:`errno` "
"variable: there is a global indicator (per thread) of the last error that "
"occurred.  Most C API functions don't clear this on success, but will set it "
"to indicate the cause of the error on failure.  Most C API functions also "
"return an error indicator, usually ``NULL`` if they are supposed to return a "
"pointer, or ``-1`` if they return an integer (exception: the :c:func:"
"`PyArg_\\*` functions return ``1`` for success and ``0`` for failure)."
msgstr ""
"Функции, описанные в этой главе, позволят вам обрабатывать и вызывать "
"исключения Python. Важно понимать некоторые основы обработки исключений "
"Python. Это работает примерно так же, как переменная POSIX :c:data:`errno`: "
"существует глобальный индикатор (для каждого потока) последней возникшей "
"ошибки. Большинство функций C API не удаляют этот параметр при успешном "
"выполнении, но устанавливают его для указания причины ошибки при сбое. "
"Большинство функций C API также возвращают индикатор ошибки, обычно "
"``NULL``, если они должны возвращать указатель, или ``-1``, если они "
"возвращают целое число (исключение: функции :c:func:`PyArg_\\*` возвращают "
"``1`` для успешного выполнения и ``0`` для сбоя)."

#: ../../c-api/exceptions.rst:20
msgid ""
"Concretely, the error indicator consists of three object pointers: the "
"exception's type, the exception's value, and the traceback object.  Any of "
"those pointers can be ``NULL`` if non-set (although some combinations are "
"forbidden, for example you can't have a non-``NULL`` traceback if the "
"exception type is ``NULL``)."
msgstr ""
"Конкретно, индикатор ошибки состоит из трех указателей на объекты: тип "
"исключения, значение исключения и объект обратной трассировки. Любой из этих "
"указателей может быть ``NULL``, если не задан (хотя некоторые комбинации "
"запрещены, например, у вас не может быть обратной трассировки, отличной от "
"``NULL``, если тип исключения ``NULL``)."

#: ../../c-api/exceptions.rst:26
msgid ""
"When a function must fail because some function it called failed, it "
"generally doesn't set the error indicator; the function it called already "
"set it.  It is responsible for either handling the error and clearing the "
"exception or returning after cleaning up any resources it holds (such as "
"object references or memory allocations); it should *not* continue normally "
"if it is not prepared to handle the error.  If returning due to an error, it "
"is important to indicate to the caller that an error has been set.  If the "
"error is not handled or carefully propagated, additional calls into the "
"Python/C API may not behave as intended and may fail in mysterious ways."
msgstr ""
"Когда функция должна завершиться неудачно из-за сбоя какой-либо функции, "
"которую она вызвала, индикатор ошибки обычно не устанавливается; функция, "
"которую он вызвал, уже установила его. Он отвечает либо за обработку ошибки "
"и очистку исключения, либо за возврат после очистки любых имеющихся у него "
"ресурсов (таких как ссылки на объекты или выделение памяти); он *не* должен "
"продолжать работать нормально, если не готов обработать ошибку. При возврате "
"из-за ошибки важно указать вызывающему объекту, что была установлена ошибка. "
"Если ошибка не обрабатывается или не распространяется должным образом, "
"дополнительные вызовы API Python/C могут вести себя не так, как "
"предполагалось, и могут загадочным образом завершиться неудачей."

#: ../../c-api/exceptions.rst:37
msgid ""
"The error indicator is **not** the result of :func:`sys.exc_info()`. The "
"former corresponds to an exception that is not yet caught (and is therefore "
"still propagating), while the latter returns an exception after it is caught "
"(and has therefore stopped propagating)."
msgstr ""
"Индикатор ошибки **не** является результатом :func:`sys.exc_info()`. Первое "
"соответствует исключению, которое еще не перехвачено (и, следовательно, все "
"еще распространяется), в то время как второе возвращает исключение после "
"того, как оно перехвачено (и, следовательно, прекратило распространение)."

#: ../../c-api/exceptions.rst:44
msgid "Printing and clearing"
msgstr "Печать и очистка"

#: ../../c-api/exceptions.rst:49
msgid ""
"Clear the error indicator.  If the error indicator is not set, there is no "
"effect."
msgstr ""
"Очищает индикатор ошибки. Если индикатор ошибки не установлен, эффекта не "
"будет."

#: ../../c-api/exceptions.rst:55
msgid ""
"Print a standard traceback to ``sys.stderr`` and clear the error indicator. "
"**Unless** the error is a ``SystemExit``, in that case no traceback is "
"printed and the Python process will exit with the error code specified by "
"the ``SystemExit`` instance."
msgstr ""
"Печатает стандартную обратную трассировку в ``sys.stderr``  и очищает "
"индикатор ошибки. **Если только** ошибка не является ``SystemExit``, в этом "
"случае обратная трассировка не выводится, и процесс Python завершится с "
"кодом ошибки, указанным экземпляром ``SystemExit``."

#: ../../c-api/exceptions.rst:60
msgid ""
"Call this function **only** when the error indicator is set.  Otherwise it "
"will cause a fatal error!"
msgstr ""
"Вызывайте эту функцию **только** при установленном индикаторе ошибки. В "
"противном случае это приведет к фатальной ошибке!"

#: ../../c-api/exceptions.rst:63
msgid ""
"If *set_sys_last_vars* is nonzero, the variables :data:`sys.last_type`, :"
"data:`sys.last_value` and :data:`sys.last_traceback` will be set to the "
"type, value and traceback of the printed exception, respectively."
msgstr ""
"Если значение *set_sys_last_vars* не равно нулю, переменным :data:`sys."
"last_type`, :data:`sys.last_value` и :data:`sys.last_traceback` будут "
"присвоены тип, значение и обратная трассировка напечатанного исключения "
"соответственно."

#: ../../c-api/exceptions.rst:70
msgid "Alias for ``PyErr_PrintEx(1)``."
msgstr "Псевдоним для ``PyErr_PrintEx(1)``."

#: ../../c-api/exceptions.rst:75
msgid ""
"Call :func:`sys.unraisablehook` using the current exception and *obj* "
"argument."
msgstr ""
"Вызывает :func:`sys.unraisablehook``, используя текущее исключение и "
"аргумент *obj*."

#: ../../c-api/exceptions.rst:78
msgid ""
"This utility function prints a warning message to ``sys.stderr`` when an "
"exception has been set but it is impossible for the interpreter to actually "
"raise the exception.  It is used, for example, when an exception occurs in "
"an :meth:`__del__` method."
msgstr ""
"Эта служебная функция выводит предупреждающее сообщение в ``sys.stderr``, "
"когда установлено исключение, но интерпретатор не может фактически вызвать "
"это исключение. Она используется, например, при возникновении исключения в "
"методе :meth:`__del__`."

#: ../../c-api/exceptions.rst:83
msgid ""
"The function is called with a single argument *obj* that identifies the "
"context in which the unraisable exception occurred. If possible, the repr of "
"*obj* will be printed in the warning message."
msgstr ""
"Функция вызывается с единственным аргументом *obj*, который определяет "
"контекст, в котором возникло недопустимое исключение. Если возможно, в "
"предупреждающем сообщении будет напечатано повторное значение *obj*."

#: ../../c-api/exceptions.rst:87
msgid "An exception must be set when calling this function."
msgstr "При вызове этой функции должно быть установлено исключение."

#: ../../c-api/exceptions.rst:91
msgid "Raising exceptions"
msgstr "Создание исключений"

#: ../../c-api/exceptions.rst:93
msgid ""
"These functions help you set the current thread's error indicator. For "
"convenience, some of these functions will always return a ``NULL`` pointer "
"for use in a ``return`` statement."
msgstr ""
"Эти функции помогут вам установить индикатор ошибки текущего потока. Для "
"удобства некоторые из этих функций всегда будут возвращать указатель "
"``NULL`` для использования в инструкции ``return``."

#: ../../c-api/exceptions.rst:100
msgid ""
"This is the most common way to set the error indicator.  The first argument "
"specifies the exception type; it is normally one of the standard exceptions, "
"e.g. :c:data:`PyExc_RuntimeError`.  You need not increment its reference "
"count. The second argument is an error message; it is decoded from "
"``'utf-8'``."
msgstr ""
"Это наиболее распространенный способ установки индикатора ошибки. Первый "
"аргумент указывает тип исключения; обычно это одно из стандартных "
"исключений, например :c:data:`PyExc_RuntimeError`. Вам не нужно увеличивать "
"количество ссылок на него. Второй аргумент - это сообщение об ошибке; оно "
"декодируется из ``'utf-8'``."

#: ../../c-api/exceptions.rst:108
msgid ""
"This function is similar to :c:func:`PyErr_SetString` but lets you specify "
"an arbitrary Python object for the \"value\" of the exception."
msgstr ""
"Эта функция аналогична :c:func:`PyErr_SetString`, но позволяет указать "
"произвольный объект Python для \"значения\" исключения."

#: ../../c-api/exceptions.rst:114
msgid ""
"This function sets the error indicator and returns ``NULL``.  *exception* "
"should be a Python exception class.  The *format* and subsequent parameters "
"help format the error message; they have the same meaning and values as in :"
"c:func:`PyUnicode_FromFormat`. *format* is an ASCII-encoded string."
msgstr ""
"Эта функция устанавливает индикатор ошибки и возвращает ``NULL``. "
"*exception* должен быть классом исключений Python. *format* и последующие "
"параметры помогают отформатировать сообщение об ошибке; они имеют то же "
"значение, что и в :c:func:`PyUnicode_FromFormat`. *format* - это строка в "
"кодировке ASCII."

#: ../../c-api/exceptions.rst:123
msgid ""
"Same as :c:func:`PyErr_Format`, but taking a :c:type:`va_list` argument "
"rather than a variable number of arguments."
msgstr ""
"То же, что и :c:func:`PyErr_Format`, но принимающий аргумент :c:type:"
"`va_list`, а не переменное количество аргументов."

#: ../../c-api/exceptions.rst:131
msgid "This is a shorthand for ``PyErr_SetObject(type, Py_None)``."
msgstr "Это сокращение от ``PyErr_SetObject(type, Py_None)``."

#: ../../c-api/exceptions.rst:136
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_TypeError, message)``, where "
"*message* indicates that a built-in operation was invoked with an illegal "
"argument.  It is mostly for internal use."
msgstr ""
"Это сокращение от ``PyErr_SetString(PyExc_TypeError, message)``, где "
"*message* указывает, что встроенная операция была вызвана с недопустимым "
"аргументом. В основном это для внутреннего использования."

#: ../../c-api/exceptions.rst:143
msgid ""
"This is a shorthand for ``PyErr_SetNone(PyExc_MemoryError)``; it returns "
"``NULL`` so an object allocation function can write ``return "
"PyErr_NoMemory();`` when it runs out of memory."
msgstr ""
"Это сокращение от ``PyErr_SetNone(PyExc_MemoryError)``; оно возвращает "
"``NULL``, поэтому функция выделения объекта может записать ``return "
"PyErr_NoMemory();``, когда у нее заканчивается память."

#: ../../c-api/exceptions.rst:152
msgid ""
"This is a convenience function to raise an exception when a C library "
"function has returned an error and set the C variable :c:data:`errno`.  It "
"constructs a tuple object whose first item is the integer :c:data:`errno` "
"value and whose second item is the corresponding error message (gotten from :"
"c:func:`strerror`), and then calls ``PyErr_SetObject(type, object)``.  On "
"Unix, when the :c:data:`errno` value is :const:`EINTR`, indicating an "
"interrupted system call, this calls :c:func:`PyErr_CheckSignals`, and if "
"that set the error indicator, leaves it set to that.  The function always "
"returns ``NULL``, so a wrapper function around a system call can write "
"``return PyErr_SetFromErrno(type);`` when the system call returns an error."
msgstr ""
"Это удобная функция для создания исключения, когда библиотечная функция C "
"возвращает ошибку и устанавливает переменную C :c:data:`errno`. Она создает "
"объект кортежа, первым элементом которого является значение integer :c:data:"
"`errno`, а вторым элементом - соответствующее сообщение об ошибке "
"(полученное из :c:func:`strerror`), а затем вызывает ``PyErr_SetObject(type, "
"object)``. В Unix, когда значение :c:data:`errno` равно :const:`EINTR`, что "
"указывает на прерванный системный вызов, вызывается :c:func:"
"`PyErr_CheckSignals`, и если это устанавливает индикатор ошибки, он остается "
"установленным на это значение. Функция всегда возвращает ``NULL``, поэтому "
"функция-оболочка для системного вызова может написать ``return "
"PyErr_SetFromErrno(type);``, когда системный вызов возвращает ошибку."

#: ../../c-api/exceptions.rst:166
msgid ""
"Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that "
"if *filenameObject* is not ``NULL``, it is passed to the constructor of "
"*type* as a third parameter.  In the case of :exc:`OSError` exception, this "
"is used to define the :attr:`filename` attribute of the exception instance."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromErrno`, с дополнительным поведением, "
"заключающимся в том, что если *filenameObject* не имеет значения ``NULL``, "
"оно передается конструктору *type* в качестве третьего параметра. В случае "
"исключения :exc:`OSError` это используется для определения атрибута :attr:"
"`filename` экземпляра исключения."

#: ../../c-api/exceptions.rst:175
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but takes a "
"second filename object, for raising errors when a function that takes two "
"filenames fails."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromErrnoWithFilenameObject`, но принимает "
"второе имя объекта для выдачи ошибок при сбое функции, принимающей два имени "
"файлов."

#: ../../c-api/exceptions.rst:184
msgid ""
"Similar to :c:func:`PyErr_SetFromErrnoWithFilenameObject`, but the filename "
"is given as a C string.  *filename* is decoded from the filesystem encoding "
"(:func:`os.fsdecode`)."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromErrnoWithFilenameObject`, но имя файла "
"задается в виде строки на языке С. *filename* декодируется из кодировки "
"файловой системы (:func:`os.fsdecode`)."

#: ../../c-api/exceptions.rst:191
msgid ""
"This is a convenience function to raise :exc:`WindowsError`. If called with "
"*ierr* of :c:data:`0`, the error code returned by a call to :c:func:"
"`GetLastError` is used instead.  It calls the Win32 function :c:func:"
"`FormatMessage` to retrieve the Windows description of error code given by "
"*ierr* or :c:func:`GetLastError`, then it constructs a tuple object whose "
"first item is the *ierr* value and whose second item is the corresponding "
"error message (gotten from :c:func:`FormatMessage`), and then calls "
"``PyErr_SetObject(PyExc_WindowsError, object)``. This function always "
"returns ``NULL``."
msgstr ""
"Это удобная функция для вызова :exc:`WindowsError`. При вызове с *ierr* из :"
"c:data:`0` вместо этого используется код ошибки, возвращаемый вызовом :c:"
"func:`GetLastError`. Она вызывает функцию Win32 :c:func:`FormatMessage` для "
"получения описания кода ошибки Windows, заданного *ierr* или :c:func:"
"`GetLastError`, затем создает объект кортежа, первым элементом которого "
"является значение *ierr*, а вторым элементом - соответствующее сообщение об "
"ошибке (получено из :c:func:`FormatMessage`), а затем вызывает "
"``PyErr_SetObject(PyExc_WindowsError, object)``. Эта функция всегда "
"возвращает значение ``NULL``."

#: ../../c-api/exceptions.rst:200 ../../c-api/exceptions.rst:208
#: ../../c-api/exceptions.rst:217 ../../c-api/exceptions.rst:225
#: ../../c-api/exceptions.rst:234 ../../c-api/exceptions.rst:243
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../c-api/exceptions.rst:205
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErr`, with an additional parameter "
"specifying the exception type to be raised."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromWindowsErr`, с дополнительным параметром, "
"указывающим тип вызываемого исключения."

#: ../../c-api/exceptions.rst:213
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, but the "
"filename is given as a C string.  *filename* is decoded from the filesystem "
"encoding (:func:`os.fsdecode`)."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, но имя файла "
"задается в виде строки на языке С. *filename* декодируется из кодировки "
"файловой системы (:func:`os.fsdecode`)."

#: ../../c-api/exceptions.rst:222
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, with an "
"additional parameter specifying the exception type to be raised."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromWindowsErrWithFilenameObject`, с "
"дополнительным параметром, указывающим тип вызываемого исключения."

#: ../../c-api/exceptions.rst:230
msgid ""
"Similar to :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, but "
"accepts a second filename object."
msgstr ""
"Аналогично :c:func:`PyErr_SetExcFromWindowsErrWithFilenameObject`, но "
"принимает второе имя объекта."

#: ../../c-api/exceptions.rst:240
msgid ""
"Similar to :c:func:`PyErr_SetFromWindowsErrWithFilename`, with an additional "
"parameter specifying the exception type to be raised."
msgstr ""
"Аналогично :c:func:`PyErr_SetFromWindowsErrWithFilename`, с дополнительным "
"параметром, указывающим тип вызываемого исключения."

#: ../../c-api/exceptions.rst:248
msgid ""
"This is a convenience function to raise :exc:`ImportError`. *msg* will be "
"set as the exception's message string. *name* and *path*, both of which can "
"be ``NULL``, will be set as the :exc:`ImportError`'s respective ``name`` and "
"``path`` attributes."
msgstr ""
"Это удобная функция для вызова :exc:`ImportError`. *msg* будет задано в "
"качестве строки сообщения об исключении. *name* и *path*, оба из которых "
"могут быть ``NULL``, будут установлены в качестве соответствующих атрибутов "
"``name`` и ``path`` для :exc:`ImportError`."

#: ../../c-api/exceptions.rst:258
msgid ""
"Much like :c:func:`PyErr_SetImportError` but this function allows for "
"specifying a subclass of :exc:`ImportError` to raise."
msgstr ""
"Очень похоже на :c:func:`PyErr_SetImportError`, но эта функция позволяет "
"указать подкласс :exc:`ImportError` для вызова."

#: ../../c-api/exceptions.rst:266
msgid ""
"Set file, line, and offset information for the current exception.  If the "
"current exception is not a :exc:`SyntaxError`, then it sets additional "
"attributes, which make the exception printing subsystem think the exception "
"is a :exc:`SyntaxError`."
msgstr ""
"Задает информацию о файле, строке и смещении для текущего исключения. Если "
"текущее исключение не является :exc:`SyntaxError`, то оно устанавливает "
"дополнительные атрибуты, которые заставляют подсистему печати исключений "
"думать, что исключение является :exc:`SyntaxError`."

#: ../../c-api/exceptions.rst:276
msgid ""
"Like :c:func:`PyErr_SyntaxLocationObject`, but *filename* is a byte string "
"decoded from the filesystem encoding (:func:`os.fsdecode`)."
msgstr ""
"Как :c:func:`PyErr_SyntaxLocationObject`, но *filename* - это строка байтов, "
"декодированная из кодировки файловой системы (:func:`os.fsdecode`)."

#: ../../c-api/exceptions.rst:284
msgid ""
"Like :c:func:`PyErr_SyntaxLocationEx`, but the *col_offset* parameter is "
"omitted."
msgstr "Как :c:func:`PyErr_SyntaxLocationEx`, но параметр *col_offset* опущен."

#: ../../c-api/exceptions.rst:290
msgid ""
"This is a shorthand for ``PyErr_SetString(PyExc_SystemError, message)``, "
"where *message* indicates that an internal operation (e.g. a Python/C API "
"function) was invoked with an illegal argument.  It is mostly for internal "
"use."
msgstr ""
"Это сокращение от ``PyErr_SetString(PyExc_SystemError, message)``, где "
"*message* указывает, что внутренняя операция (например, функция API Python/"
"C) была вызвана с недопустимым аргументом. В основном для внутреннего "
"использования."

#: ../../c-api/exceptions.rst:297
msgid "Issuing warnings"
msgstr "Выдача предупреждений"

#: ../../c-api/exceptions.rst:299
msgid ""
"Use these functions to issue warnings from C code.  They mirror similar "
"functions exported by the Python :mod:`warnings` module.  They normally "
"print a warning message to *sys.stderr*; however, it is also possible that "
"the user has specified that warnings are to be turned into errors, and in "
"that case they will raise an exception.  It is also possible that the "
"functions raise an exception because of a problem with the warning "
"machinery. The return value is ``0`` if no exception is raised, or ``-1`` if "
"an exception is raised.  (It is not possible to determine whether a warning "
"message is actually printed, nor what the reason is for the exception; this "
"is intentional.)  If an exception is raised, the caller should do its normal "
"exception handling (for example, :c:func:`Py_DECREF` owned references and "
"return an error value)."
msgstr ""
"Используйте эти функции для выдачи предупреждений из кода на C. Они отражают "
"аналогичные функции, экспортируемые модулем Python :mod:`warnings`. Обычно "
"они выводят предупреждающее сообщение в *sys.stderr*; однако также возможно, "
"что пользователь указал, что предупреждения должны быть преобразованы в "
"ошибки, и в этом случае они вызовут исключение. Также возможно, что функции "
"генерируют исключение из-за проблемы с механизмом предупреждения. "
"Возвращаемое значение равно ``0``, если исключение не генерируется, или "
"``-1``, если возникает исключение. (Невозможно определить, действительно ли "
"напечатано предупреждающее сообщение, а также какова причина исключения; это "
"сделано намеренно.) Если возникает исключение, вызывающий объект должен "
"выполнить свою обычную обработку исключений (например, ссылки, "
"принадлежащие :c:func:`Py_DECREF`, и вернуть значение ошибки)."

#: ../../c-api/exceptions.rst:314
msgid ""
"Issue a warning message.  The *category* argument is a warning category (see "
"below) or ``NULL``; the *message* argument is a UTF-8 encoded string.  "
"*stack_level* is a positive number giving a number of stack frames; the "
"warning will be issued from the  currently executing line of code in that "
"stack frame.  A *stack_level* of 1 is the function calling :c:func:"
"`PyErr_WarnEx`, 2 is  the function above that, and so forth."
msgstr ""
"Выдает предупреждающее сообщение. Аргумент *category* - это категория "
"предупреждения (см. ниже) или ``NULL``; аргумент *message* - это строка в "
"кодировке UTF-8. *stack_level* - положительное число, указывающее количество "
"фреймов стека; предупреждение будет выдано из текущей выполняемой строки "
"кода в этом фрейме стека. A *stack_level*, равный 1 - это функция, "
"вызывающая :c:func:`PyErr_WarnEx`, 2 - функция выше этой, и так далее."

#: ../../c-api/exceptions.rst:321
msgid ""
"Warning categories must be subclasses of :c:data:`PyExc_Warning`; :c:data:"
"`PyExc_Warning` is a subclass of :c:data:`PyExc_Exception`; the default "
"warning category is :c:data:`PyExc_RuntimeWarning`. The standard Python "
"warning categories are available as global variables whose names are "
"enumerated at :ref:`standardwarningcategories`."
msgstr ""
"Категории предупреждений должны быть подклассами :c:data:`PyExc_Warning`; :c:"
"data:`PyExc_Warning` является подклассом :c:data:`PyExc_Exception`; "
"категория предупреждений по умолчанию :c:data:`PyExc_RuntimeWarning`. "
"Стандартные категории предупреждений Python доступны в виде глобальных "
"переменных, имена которых перечислены по адресу :ref:"
"`standardwarningcategories`."

#: ../../c-api/exceptions.rst:327
msgid ""
"For information about warning control, see the documentation for the :mod:"
"`warnings` module and the :option:`-W` option in the command line "
"documentation.  There is no C API for warning control."
msgstr ""
"Информацию об управлении предупреждениями смотрите в документации к модулю :"
"mod:`warnings` и опции :option:`-W` в документации по командной строке. Для "
"управления предупреждениями нет C API."

#: ../../c-api/exceptions.rst:334
msgid ""
"Issue a warning message with explicit control over all warning attributes.  "
"This is a straightforward wrapper around the Python function :func:`warnings."
"warn_explicit`; see there for more information.  The *module* and *registry* "
"arguments may be set to ``NULL`` to get the default effect described there."
msgstr ""
"Выдает предупреждающее сообщение с явным контролем над всеми атрибутами "
"предупреждения. Это простая оболочка для функции Python :func:`warnings."
"warn_explicit`; смотрите там для получения дополнительной информации. "
"Аргументам *module* и *registry* может быть присвоено значение ``NULL``, "
"чтобы получить эффект по умолчанию, описанный там."

#: ../../c-api/exceptions.rst:345
msgid ""
"Similar to :c:func:`PyErr_WarnExplicitObject` except that *message* and "
"*module* are UTF-8 encoded strings, and *filename* is decoded from the "
"filesystem encoding (:func:`os.fsdecode`)."
msgstr ""
"Аналогично :c:func:`PyErr_WarnExplicitObject`, за исключением того, что "
"*message* и *module* являются строками в кодировке UTF-8, а *filename* "
"декодируется из кодировки файловой системы (:func:`os.fsdecode`)."

#: ../../c-api/exceptions.rst:352
msgid ""
"Function similar to :c:func:`PyErr_WarnEx`, but use :c:func:"
"`PyUnicode_FromFormat` to format the warning message.  *format* is an ASCII-"
"encoded string."
msgstr ""
"Функция, аналогичная :c:func:`PyErr_WarnEx`, но использует :c:func:"
"`PyUnicode_FromFormat` для форматирования предупреждающего сообщения. "
"*format* - это строка в кодировке ASCII."

#: ../../c-api/exceptions.rst:361
msgid ""
"Function similar to :c:func:`PyErr_WarnFormat`, but *category* is :exc:"
"`ResourceWarning` and it passes *source* to :func:`warnings.WarningMessage`."
msgstr ""
"Функция похожа на :c:func:`PyErr_WarnFormat`, но *категория* - это :exc:"
"`ResourceWarning`, и она передает *источник* в :func:`warnings."
"WarningMessage`."

#: ../../c-api/exceptions.rst:368
msgid "Querying the error indicator"
msgstr "Запрос индикатора ошибки"

#: ../../c-api/exceptions.rst:372
msgid ""
"Test whether the error indicator is set.  If set, return the exception "
"*type* (the first argument to the last call to one of the :c:func:"
"`PyErr_Set\\*` functions or to :c:func:`PyErr_Restore`).  If not set, return "
"``NULL``.  You do not own a reference to the return value, so you do not "
"need to :c:func:`Py_DECREF` it."
msgstr ""
"Проверьте, установлен ли индикатор ошибки. Если установлен, верните "
"исключение *type* (первый аргумент для последнего вызова одной из функций :c:"
"func:`PyErr_Set\\*` или :c:func:`PyErr_Restore`). Если значение не задано, "
"верните ``NULL``. У вас нет ссылки на возвращаемое значение, поэтому вам не "
"нужно :c:func:`Py_DECREF` для него."

#: ../../c-api/exceptions.rst:378
msgid "The caller must hold the GIL."
msgstr "Вызывающий объект должен удерживать GIL."

#: ../../c-api/exceptions.rst:382
msgid ""
"Do not compare the return value to a specific exception; use :c:func:"
"`PyErr_ExceptionMatches` instead, shown below.  (The comparison could easily "
"fail since the exception may be an instance instead of a class, in the case "
"of a class exception, or it may be a subclass of the expected exception.)"
msgstr ""
"Не сравнивайте возвращаемое значение с конкретным исключением; вместо этого "
"используйте :c:func:`PyErr_ExceptionMatches`, как показано ниже. (Сравнение "
"может легко завершиться неудачей, поскольку исключение может быть "
"экземпляром вместо класса, в случае исключения класса, или это может быть "
"подкласс ожидаемого исключения.)"

#: ../../c-api/exceptions.rst:390
msgid ""
"Equivalent to ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``.  This "
"should only be called when an exception is actually set; a memory access "
"violation will occur if no exception has been raised."
msgstr ""
"Эквивалентно ``PyErr_GivenExceptionMatches(PyErr_Occurred(), exc)``. Это "
"должно вызываться только тогда, когда действительно установлено исключение; "
"произойдет нарушение доступа к памяти, если исключение не было вызвано."

#: ../../c-api/exceptions.rst:397
msgid ""
"Return true if the *given* exception matches the exception type in *exc*.  "
"If *exc* is a class object, this also returns true when *given* is an "
"instance of a subclass.  If *exc* is a tuple, all exception types in the "
"tuple (and recursively in subtuples) are searched for a match."
msgstr ""
"Возвращает значение true, если исключение *given* соответствует типу "
"исключения в *exc*. Если *exc* является объектом класса, это также "
"возвращает значение true, когда *given* является экземпляром подкласса. Если "
"*exc* является кортежем, выполняется поиск совпадения по всем типам "
"исключений в кортеже (и рекурсивно в подтипах)."

#: ../../c-api/exceptions.rst:405
msgid ""
"Retrieve the error indicator into three variables whose addresses are "
"passed. If the error indicator is not set, set all three variables to "
"``NULL``.  If it is set, it will be cleared and you own a reference to each "
"object retrieved.  The value and traceback object may be ``NULL`` even when "
"the type object is not."
msgstr ""
"Извлекает индикатор ошибки из трех переменных, адреса которых переданы. Если "
"индикатор ошибки не установлен, устанавливает для всех трех переменных "
"значение ``NULL``. Если он установлен, он будет удален, и у вас будет "
"собственная ссылка на каждый извлеченный объект. Значение и объект обратной "
"трассировки могут быть ``NULL``, даже если объект типа таковым не является."

#: ../../c-api/exceptions.rst:412
msgid ""
"This function is normally only used by code that needs to catch exceptions "
"or by code that needs to save and restore the error indicator temporarily, e."
"g.::"
msgstr ""
"Эта функция обычно используется только в коде, который должен перехватывать "
"исключения, или в коде, который должен временно сохранять и восстанавливать "
"индикатор ошибки, например::"

#: ../../c-api/exceptions.rst:427
msgid ""
"Set  the error indicator from the three objects.  If the error indicator is "
"already set, it is cleared first.  If the objects are ``NULL``, the error "
"indicator is cleared.  Do not pass a ``NULL`` type and non-``NULL`` value or "
"traceback.  The exception type should be a class.  Do not pass an invalid "
"exception type or value. (Violating these rules will cause subtle problems "
"later.)  This call takes away a reference to each object: you must own a "
"reference to each object before the call and after the call you no longer "
"own these references.  (If you don't understand this, don't use this "
"function.  I warned you.)"
msgstr ""
"Устанавливает индикатор ошибки для трех объектов. Если индикатор ошибки уже "
"установлен, сначала он будет удален. Если объекты имеют значение ``NULL``, "
"индикатор ошибки будет удален. Не передавайте тип ``NULL`` и значение, "
"отличное от ``NULL``, или данные обратной трассировки. Типом исключения "
"должен быть класс. Не передавайте недопустимый тип исключения или значение. "
"(Нарушение этих правил приведет к возникновению незначительных проблем в "
"дальнейшем). Этот вызов удаляет ссылку на каждый объект: перед вызовом у вас "
"должна быть ссылка на каждый объект, а после вызова вы больше не будете "
"владеть этими ссылками. (Если вы этого не понимаете, не используйте эту "
"функцию. Я вас предупреждал.)"

#: ../../c-api/exceptions.rst:439
msgid ""
"This function is normally only used by code that needs to save and restore "
"the error indicator temporarily.  Use :c:func:`PyErr_Fetch` to save the "
"current error indicator."
msgstr ""
"Обычно эта функция используется только в коде, которому необходимо временно "
"сохранить и восстановить индикатор ошибки. Используйте :c:func:`PyErr_Fetch` "
"для сохранения текущего индикатора ошибки."

#: ../../c-api/exceptions.rst:446
msgid ""
"Under certain circumstances, the values returned by :c:func:`PyErr_Fetch` "
"below can be \"unnormalized\", meaning that ``*exc`` is a class object but "
"``*val`` is not an instance of the  same class.  This function can be used "
"to instantiate the class in that case.  If the values are already "
"normalized, nothing happens. The delayed normalization is implemented to "
"improve performance."
msgstr ""
"При определенных обстоятельствах значения, возвращаемые :c:func:"
"`PyErr_Fetch`, приведенные ниже, могут быть \"ненормализованными\", что "
"означает, что ``*exc`` является объектом класса, но ``*val`` не является "
"экземпляром того же класса. В этом случае эту функцию можно использовать для "
"создания экземпляра класса. Если значения уже нормализованы, ничего не "
"происходит. Отложенная нормализация реализована для повышения "
"производительности."

#: ../../c-api/exceptions.rst:454
msgid ""
"This function *does not* implicitly set the ``__traceback__`` attribute on "
"the exception value. If setting the traceback appropriately is desired, the "
"following additional snippet is needed::"
msgstr ""
"Эта функция *не устанавливает * неявно атрибут ``__traceback__`` для "
"значения исключения. Если требуется соответствующая настройка обратной "
"трассировки, необходим следующий дополнительный фрагмент кода::"

#: ../../c-api/exceptions.rst:465
msgid ""
"Retrieve the exception info, as known from ``sys.exc_info()``.  This refers "
"to an exception that was *already caught*, not to an exception that was "
"freshly raised.  Returns new references for the three objects, any of which "
"may be ``NULL``.  Does not modify the exception info state."
msgstr ""
"Извлекает информацию об исключении, как известно из ``sys.exc_info()``. Это "
"относится к исключению, которое было *уже перехвачено*, а не к исключению, "
"которое было недавно создано. Возвращает новые ссылки для трех объектов, "
"любой из которых может быть ``NULL``. Не изменяет состояние информации об "
"исключении."

#: ../../c-api/exceptions.rst:472
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_SetExcInfo` to restore or clear the "
"exception state."
msgstr ""
"Эта функция обычно не используется кодом, который хочет обрабатывать "
"исключения. Скорее, ее можно использовать, когда коду необходимо временно "
"сохранить и восстановить состояние исключения. Используйте :c:func:"
"`PyErr_SetExcInfo` для восстановления или очистки состояния исключения."

#: ../../c-api/exceptions.rst:482
msgid ""
"Set the exception info, as known from ``sys.exc_info()``.  This refers to an "
"exception that was *already caught*, not to an exception that was freshly "
"raised.  This function steals the references of the arguments. To clear the "
"exception state, pass ``NULL`` for all three arguments. For general rules "
"about the three arguments, see :c:func:`PyErr_Restore`."
msgstr ""
"Задает информацию об исключении, как это известно из ``sys.exc_info()``. Это "
"относится к исключению, которое было *уже перехвачено*, а не к исключению, "
"которое было вызвано недавно. Эта функция крадет ссылки на аргументы. Чтобы "
"очистить состояние исключения, передайте ``NULL`` для всех трех аргументов. "
"Общие правила, касающиеся трех аргументов, см. в :c:func:`PyErr_Restore`."

#: ../../c-api/exceptions.rst:490
msgid ""
"This function is not normally used by code that wants to handle exceptions. "
"Rather, it can be used when code needs to save and restore the exception "
"state temporarily.  Use :c:func:`PyErr_GetExcInfo` to read the exception "
"state."
msgstr ""
"Эта функция обычно не используется кодом, который хочет обрабатывать "
"исключения. Скорее, ее можно использовать, когда коду необходимо временно "
"сохранить и восстановить состояние исключения. Используйте :c:func:"
"`PyErr_GetExcInfo` для считывания состояния исключения."

#: ../../c-api/exceptions.rst:499
msgid "Signal Handling"
msgstr "Обработка сигналов"

#: ../../c-api/exceptions.rst:509
msgid ""
"This function interacts with Python's signal handling.  It checks whether a "
"signal has been sent to the processes and if so, invokes the corresponding "
"signal handler.  If the :mod:`signal` module is supported, this can invoke a "
"signal handler written in Python.  In all cases, the default effect for :"
"const:`SIGINT` is to raise the  :exc:`KeyboardInterrupt` exception.  If an "
"exception is raised the error indicator is set and the function returns "
"``-1``; otherwise the function returns ``0``.  The error indicator may or "
"may not be cleared if it was previously set."
msgstr ""
"Эта функция взаимодействует с обработкой сигналов в Python. Она проверяет, "
"был ли сигнал отправлен процессам, и если да, то вызывает соответствующий "
"обработчик сигналов. Если поддерживается модуль :mod:`signal`, он может "
"вызвать обработчик сигналов, написанный на Python. Во всех случаях "
"результатом по умолчанию для :const:`SIGINT` является создание исключения :"
"exc:`KeyboardInterrupt`. Если возникает исключение, включается индикатор "
"ошибки, и функция возвращает значение ``-1``; в противном случае функция "
"возвращает значение ``0``. Если индикатор ошибки был ранее установлен, он "
"может быть снят или не снят."

#: ../../c-api/exceptions.rst:525
msgid ""
"Simulate the effect of a :const:`SIGINT` signal arriving. The next time :c:"
"func:`PyErr_CheckSignals` is called,  the Python signal handler for :const:"
"`SIGINT` will be called."
msgstr ""
"Имитируйте эффект поступления сигнала :const:`SIGINT`. При следующем вызове :"
"c:func:`PyErr_CheckSignals` будет вызван обработчик сигнала Python для :"
"const:`SIGINT`."

#: ../../c-api/exceptions.rst:529
msgid ""
"If :const:`SIGINT` isn't handled by Python (it was set to :data:`signal."
"SIG_DFL` or :data:`signal.SIG_IGN`), this function does nothing."
msgstr ""
"Если :const:`SIGINT` не обрабатывается Python (для него было задано "
"значение :data:`signal.SIG_DFL` или :data:`signal.SIG_IGN`), эта функция "
"ничего не делает."

#: ../../c-api/exceptions.rst:535
msgid ""
"This utility function specifies a file descriptor to which the signal number "
"is written as a single byte whenever a signal is received. *fd* must be non-"
"blocking. It returns the previous such file descriptor."
msgstr ""
"Эта служебная функция определяет файловый дескриптор, в который номер "
"сигнала записывается в виде одного байта всякий раз, когда принимается "
"сигнал. *fd* должен быть неблокирующим. Он возвращает предыдущий файловый "
"дескриптор."

#: ../../c-api/exceptions.rst:539
msgid ""
"The value ``-1`` disables the feature; this is the initial state. This is "
"equivalent to :func:`signal.set_wakeup_fd` in Python, but without any error "
"checking.  *fd* should be a valid file descriptor.  The function should only "
"be called from the main thread."
msgstr ""
"Значение ``-1`` отключает функцию; это начальное состояние. Это "
"эквивалентно :func:`signal.set_wakeup_fd` в Python, но без какой-либо "
"проверки на ошибки. *fd* должен быть допустимым файловым дескриптором. "
"Функция должна вызываться только из основного потока."

#: ../../c-api/exceptions.rst:544
msgid "On Windows, the function now also supports socket handles."
msgstr "В Windows эта функция теперь также поддерживает дескрипторы сокетов."

#: ../../c-api/exceptions.rst:549
msgid "Exception Classes"
msgstr "Классы исключений"

#: ../../c-api/exceptions.rst:553
msgid ""
"This utility function creates and returns a new exception class. The *name* "
"argument must be the name of the new exception, a C string of the form "
"``module.classname``.  The *base* and *dict* arguments are normally "
"``NULL``. This creates a class object derived from :exc:`Exception` "
"(accessible in C as :c:data:`PyExc_Exception`)."
msgstr ""
"Эта служебная функция создает и возвращает новый класс исключений. "
"Аргументом *name* должно быть имя нового исключения, строка на языке Си в "
"виде ``module.classname``. Аргументы *base* и *dict* обычно имеют значение "
"``NULL``. Это создает объект класса, производный от :exc:`Exception` "
"(доступный в C как :c:data:`PyExc_Exception`)."

#: ../../c-api/exceptions.rst:559
msgid ""
"The :attr:`__module__` attribute of the new class is set to the first part "
"(up to the last dot) of the *name* argument, and the class name is set to "
"the last part (after the last dot).  The *base* argument can be used to "
"specify alternate base classes; it can either be only one class or a tuple "
"of classes. The *dict* argument can be used to specify a dictionary of class "
"variables and methods."
msgstr ""
"Атрибуту :attr:`__module__` нового класса присваивается значение первой "
"части (до последней точки) аргумента *name*, а имени класса присваивается "
"значение последней части (после последней точки). Аргумент *base* может "
"использоваться для указания альтернативных базовых классов; это может быть "
"либо только один класс, либо набор классов. Аргумент *dict* может "
"использоваться для указания словаря переменных и методов класса."

#: ../../c-api/exceptions.rst:568
msgid ""
"Same as :c:func:`PyErr_NewException`, except that the new exception class "
"can easily be given a docstring: If *doc* is non-``NULL``, it will be used "
"as the docstring for the exception class."
msgstr ""
"То же, что :c:func:`PyErr_NewException`, за исключением того, что новому "
"классу исключений можно легко присвоить строку документации: если значение "
"*doc* не равно ``NULL``, оно будет использоваться в качестве строки "
"документации для класса исключений."

#: ../../c-api/exceptions.rst:576
msgid "Exception Objects"
msgstr "Объекты исключений"

#: ../../c-api/exceptions.rst:580
msgid ""
"Return the traceback associated with the exception as a new reference, as "
"accessible from Python through :attr:`__traceback__`.  If there is no "
"traceback associated, this returns ``NULL``."
msgstr ""
"Возвращает обратную трассировку, связанную с исключением, в виде новой "
"ссылки, доступной из Python через :attr:`__traceback__`. Если обратная "
"трассировка не связана, возвращается значение ``NULL``."

#: ../../c-api/exceptions.rst:587
msgid ""
"Set the traceback associated with the exception to *tb*.  Use ``Py_None`` to "
"clear it."
msgstr ""
"Устанавливает для параметра обратной трассировки, связанного с исключением, "
"значение *tb*. Используйте ``Py_None``, чтобы очистить его."

#: ../../c-api/exceptions.rst:593
msgid ""
"Return the context (another exception instance during whose handling *ex* "
"was raised) associated with the exception as a new reference, as accessible "
"from Python through :attr:`__context__`.  If there is no context associated, "
"this returns ``NULL``."
msgstr ""
"Возвращает контекст (другой экземпляр исключения, при обработке которого был "
"запущен *ex*), связанный с исключением, в качестве новой ссылки, доступной "
"из Python через :attr:`__context__`. Если контекст не связан, возвращается "
"значение ``NULL``."

#: ../../c-api/exceptions.rst:601
msgid ""
"Set the context associated with the exception to *ctx*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *ctx* is an exception "
"instance. This steals a reference to *ctx*."
msgstr ""
"Задает контексту, связанному с исключением, значение *ctx*. Используйте "
"``NULL``, чтобы очистить его. Нет проверки типа, чтобы убедиться, что *ctx* "
"является экземпляром исключения. При этом будет украдена ссылка на *ctx*."

#: ../../c-api/exceptions.rst:608
msgid ""
"Return the cause (either an exception instance, or :const:`None`, set by "
"``raise ... from ...``) associated with the exception as a new reference, as "
"accessible from Python through :attr:`__cause__`."
msgstr ""
"Возвращает причину (либо экземпляр исключения, либо :const:`None`, заданный "
"параметром ``raise ... from ...``), связанный с исключением в качестве новой "
"ссылки, доступной из Python через :attr:`__cause__`."

#: ../../c-api/exceptions.rst:615
msgid ""
"Set the cause associated with the exception to *cause*.  Use ``NULL`` to "
"clear it.  There is no type check to make sure that *cause* is either an "
"exception instance or :const:`None`.  This steals a reference to *cause*."
msgstr ""
"Задает для причины, связанной с исключением, значение *cause*. Используйте "
"``NULL``, чтобы очистить его. Нет проверки типа, чтобы убедиться, что "
"*cause* является либо экземпляром исключения, либо :const:`None`. При этом "
"будет украдена ссылка на *cause*."

#: ../../c-api/exceptions.rst:619
msgid ""
":attr:`__suppress_context__` is implicitly set to ``True`` by this function."
msgstr ""
":attr:`__suppress_context__` этой функции неявно устанавливается значение "
"``True``."

#: ../../c-api/exceptions.rst:625
msgid "Unicode Exception Objects"
msgstr "Объекты исключений в Unicode"

#: ../../c-api/exceptions.rst:627
msgid ""
"The following functions are used to create and modify Unicode exceptions "
"from C."
msgstr ""
"Следующие функции используются для создания и изменения исключений Unicode "
"из C."

#: ../../c-api/exceptions.rst:631
msgid ""
"Create a :class:`UnicodeDecodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""
"Создает объект :class:`UnicodeDecodeError` с атрибутами *encoding*, "
"*object*, *length*, *start*, *end* и *reason*. *encoding* и *reason* "
"являются строками в кодировке UTF-8."

#: ../../c-api/exceptions.rst:637
msgid ""
"Create a :class:`UnicodeEncodeError` object with the attributes *encoding*, "
"*object*, *length*, *start*, *end* and *reason*. *encoding* and *reason* are "
"UTF-8 encoded strings."
msgstr ""
"Создает объект :class:`UnicodeEncodeError` с атрибутами *encoding*, "
"*object*, *length*, *start*, *end* и *reason*. *encoding* и *reason* "
"являются строками в кодировке UTF-8."

#: ../../c-api/exceptions.rst:641 ../../c-api/exceptions.rst:651
msgid "3.11"
msgstr "3.11"

#: ../../c-api/exceptions.rst:643
msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeEncodeError, \"sOnns\", ...)``."
msgstr ""
"``Py_UNICODE`` устарел начиная с версии Python 3.3. Пожалуйста, перейдите на "
"``PyObject_CallFunction(PyExc_UnicodeEncodeError, \"sOnns\", ...)``."

#: ../../c-api/exceptions.rst:648
msgid ""
"Create a :class:`UnicodeTranslateError` object with the attributes *object*, "
"*length*, *start*, *end* and *reason*. *reason* is a UTF-8 encoded string."
msgstr ""
"Создает объект :class:`UnicodeTranslateError` с атрибутами *object*, "
"*length*, *start*, *end* и *reason*. *reason* - это строка в кодировке UTF-8."

#: ../../c-api/exceptions.rst:653
msgid ""
"``Py_UNICODE`` is deprecated since Python 3.3. Please migrate to "
"``PyObject_CallFunction(PyExc_UnicodeTranslateError, \"Onns\", ...)``."
msgstr ""
"``Py_UNICODE`` устарел начиная с версии Python 3.3. Пожалуйста, перейдите на "
"``PyObject_CallFunction(PyExc_UnicodeTranslateError, \"Onns\", ...)``."

#: ../../c-api/exceptions.rst:659
msgid "Return the *encoding* attribute of the given exception object."
msgstr "Возвращает атрибут *encoding* данного объекта исключения."

#: ../../c-api/exceptions.rst:665
msgid "Return the *object* attribute of the given exception object."
msgstr "Возвращает атрибут *object* данного объекта исключения."

#: ../../c-api/exceptions.rst:671
msgid ""
"Get the *start* attribute of the given exception object and place it into "
"*\\*start*.  *start* must not be ``NULL``.  Return ``0`` on success, ``-1`` "
"on failure."
msgstr ""
"Получает атрибут *start* данного объекта exception и помещает его в "
"*\\*start*. Значение *start* не должно быть ``NULL``. Возвращает ``0`` в "
"случае успеха, ``-1`` в случае сбоя."

#: ../../c-api/exceptions.rst:679
msgid ""
"Set the *start* attribute of the given exception object to *start*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Устанавливает для атрибута *start* данного объекта исключения значение "
"*start*. Возвращает ``0`` в случае успеха, ``-1`` в случае сбоя."

#: ../../c-api/exceptions.rst:686
msgid ""
"Get the *end* attribute of the given exception object and place it into "
"*\\*end*.  *end* must not be ``NULL``.  Return ``0`` on success, ``-1`` on "
"failure."
msgstr ""
"Получает атрибут *end* данного объекта exception и помещает его в *\\*end*. "
"*end* не должен быть равен ``NULL``. Возвращает ``0`` в случае успеха, "
"``-1`` в случае сбоя."

#: ../../c-api/exceptions.rst:694
msgid ""
"Set the *end* attribute of the given exception object to *end*.  Return "
"``0`` on success, ``-1`` on failure."
msgstr ""
"Устанавливает для атрибута *end* данного объекта исключения значение *end*. "
"Возвращает ``0`` в случае успеха, ``-1`` в случае сбоя."

#: ../../c-api/exceptions.rst:701
msgid "Return the *reason* attribute of the given exception object."
msgstr "Возвращает атрибут *reason* данного объекта исключения."

#: ../../c-api/exceptions.rst:707
msgid ""
"Set the *reason* attribute of the given exception object to *reason*.  "
"Return ``0`` on success, ``-1`` on failure."
msgstr ""
"Устанавливает для атрибута *reason* данного объекта исключения значение "
"*reason*. Возвращает ``0`` в случае успеха, ``-1`` в случае сбоя."

#: ../../c-api/exceptions.rst:714
msgid "Recursion Control"
msgstr "Управление рекурсией"

#: ../../c-api/exceptions.rst:716
msgid ""
"These two functions provide a way to perform safe recursive calls at the C "
"level, both in the core and in extension modules.  They are needed if the "
"recursive code does not necessarily invoke Python code (which tracks its "
"recursion depth automatically). They are also not needed for *tp_call* "
"implementations because the :ref:`call protocol <call>` takes care of "
"recursion handling."
msgstr ""
"Эти две функции обеспечивают возможность выполнения безопасных рекурсивных "
"вызовов на уровне C, как в ядре, так и в модулях расширения. Они необходимы, "
"если рекурсивный код не обязательно вызывает код на Python (который "
"автоматически отслеживает глубину рекурсии). Они также не нужны для "
"реализаций *tp_call*, потому что :ref:`call protocol <call>` заботится об "
"обработке рекурсии."

#: ../../c-api/exceptions.rst:725
msgid "Marks a point where a recursive C-level call is about to be performed."
msgstr ""
"Отмечает точку, в которой вот-вот будет выполнен рекурсивный вызов уровня C."

#: ../../c-api/exceptions.rst:727
msgid ""
"If :const:`USE_STACKCHECK` is defined, this function checks if the OS stack "
"overflowed using :c:func:`PyOS_CheckStack`.  In this is the case, it sets a :"
"exc:`MemoryError` and returns a nonzero value."
msgstr ""
"Если определено значение :const:`USE_STACKCHECK`, эта функция проверяет, не "
"переполнился ли стек операционной системы, используя :c:func:"
"`PyOS_CheckStack`. В этом случае он устанавливает :exc:`MemoryError` и "
"возвращает ненулевое значение."

#: ../../c-api/exceptions.rst:731
msgid ""
"The function then checks if the recursion limit is reached.  If this is the "
"case, a :exc:`RecursionError` is set and a nonzero value is returned. "
"Otherwise, zero is returned."
msgstr ""
"Затем функция проверяет, достигнут ли предел рекурсии. Если это так, то "
"устанавливается значение :exc:`RecursionError` и возвращается ненулевое "
"значение. В противном случае возвращается ноль."

#: ../../c-api/exceptions.rst:735
msgid ""
"*where* should be a UTF-8 encoded string such as ``\" in instance check\"`` "
"to be concatenated to the :exc:`RecursionError` message caused by the "
"recursion depth limit."
msgstr ""
"*where* должна быть строкой в кодировке UTF-8, такой как ``\" in instance "
"check\"``, которая должна быть объединена с сообщением :exc:"
"`RecursionError`, вызванным ограничением глубины рекурсии."

#: ../../c-api/exceptions.rst:739 ../../c-api/exceptions.rst:747
msgid "This function is now also available in the limited API."
msgstr "Эта функция теперь также доступна в ограниченном API."

#: ../../c-api/exceptions.rst:744
msgid ""
"Ends a :c:func:`Py_EnterRecursiveCall`.  Must be called once for each "
"*successful* invocation of :c:func:`Py_EnterRecursiveCall`."
msgstr ""
"Завершает :c:func:`Py_EnterRecursiveCall`. Должен вызываться один раз для "
"каждого *успешного* вызова :c:func:`Py_EnterRecursiveCall`."

#: ../../c-api/exceptions.rst:750
msgid ""
"Properly implementing :c:member:`~PyTypeObject.tp_repr` for container types "
"requires special recursion handling.  In addition to protecting the stack, :"
"c:member:`~PyTypeObject.tp_repr` also needs to track objects to prevent "
"cycles.  The following two functions facilitate this functionality.  "
"Effectively, these are the C equivalent to :func:`reprlib.recursive_repr`."
msgstr ""
"Правильная реализация :c:member:`~PyTypeObject.tp_repr` для типов "
"контейнеров требует специальной обработки рекурсии. В дополнение к защите "
"стека, :c:member:`~PyTypeObject.tp_repr` также должен отслеживать объекты, "
"чтобы предотвратить циклы. Следующие две функции облегчают эту "
"функциональность. По сути, это C-эквивалент :func:`reprlib.recursive_repr`."

#: ../../c-api/exceptions.rst:758
msgid ""
"Called at the beginning of the :c:member:`~PyTypeObject.tp_repr` "
"implementation to detect cycles."
msgstr ""
"Вызывается в начале реализации :c:member:`~PyTypeObject.tp_repr` для "
"обнаружения циклов."

#: ../../c-api/exceptions.rst:761
msgid ""
"If the object has already been processed, the function returns a positive "
"integer.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should return a string object indicating a cycle.  As examples, :class:"
"`dict` objects return ``{...}`` and :class:`list` objects return ``[...]``."
msgstr ""
"Если объект уже был обработан, функция возвращает положительное целое число. "
"В этом случае реализация :c:member:`~PyTypeObject.tp_repr` должна возвращать "
"строковый объект, указывающий на цикл. В качестве примеров, объекты :class:"
"`dict` возвращают значение ``{...}``, а объекты :class:`list` возвращают "
"значение ``[...]``."

#: ../../c-api/exceptions.rst:767
msgid ""
"The function will return a negative integer if the recursion limit is "
"reached.  In that case the :c:member:`~PyTypeObject.tp_repr` implementation "
"should typically return ``NULL``."
msgstr ""
"Функция вернет отрицательное целое число, если будет достигнут предел "
"рекурсии. В этом случае реализация :c:member:`~PyTypeObject.tp_repr` обычно "
"должна возвращать значение ``NULL``."

#: ../../c-api/exceptions.rst:771
msgid ""
"Otherwise, the function returns zero and the :c:member:`~PyTypeObject."
"tp_repr` implementation can continue normally."
msgstr ""
"В противном случае функция возвращает ноль, и реализация :c:member:"
"`~PyTypeObject.tp_repr` может продолжаться в обычном режиме."

#: ../../c-api/exceptions.rst:776
msgid ""
"Ends a :c:func:`Py_ReprEnter`.  Must be called once for each invocation of :"
"c:func:`Py_ReprEnter` that returns zero."
msgstr ""
"Завершает :c:func:`Py_ReprEnter`. Должен вызываться один раз для каждого "
"вызова :c:func:`Py_ReprEnter`, который возвращает ноль."

#: ../../c-api/exceptions.rst:783
msgid "Standard Exceptions"
msgstr "Стандартные исключения"

#: ../../c-api/exceptions.rst:785
msgid ""
"All standard Python exceptions are available as global variables whose names "
"are ``PyExc_`` followed by the Python exception name.  These have the type :"
"c:type:`PyObject*`; they are all class objects.  For completeness, here are "
"all the variables:"
msgstr ""
"Все стандартные исключения Python доступны в виде глобальных переменных с "
"именами ``PyExc_``, за которыми следует имя исключения Python. Они имеют "
"тип :c:type:`PyObject*`; все они являются объектами класса. Для полноты "
"картины, вот все переменные:"

#: ../../c-api/exceptions.rst:846 ../../c-api/exceptions.rst:979
#: ../../c-api/exceptions.rst:1024
msgid "C Name"
msgstr "C Имя"

#: ../../c-api/exceptions.rst:846 ../../c-api/exceptions.rst:1024
msgid "Python Name"
msgstr "Имя Python"

#: ../../c-api/exceptions.rst:846 ../../c-api/exceptions.rst:979
#: ../../c-api/exceptions.rst:1024
msgid "Notes"
msgstr "Примечания"

#: ../../c-api/exceptions.rst:848
msgid ":c:data:`PyExc_BaseException`"
msgstr ":c:data:`PyExc_BaseException`"

#: ../../c-api/exceptions.rst:848
msgid ":exc:`BaseException`"
msgstr ":exc:`BaseException`"

#: ../../c-api/exceptions.rst:848 ../../c-api/exceptions.rst:850
#: ../../c-api/exceptions.rst:852 ../../c-api/exceptions.rst:898
#: ../../c-api/exceptions.rst:910
msgid "[1]_"
msgstr "[1]_"

#: ../../c-api/exceptions.rst:850
msgid ":c:data:`PyExc_Exception`"
msgstr ":c:data:`PyExc_Exception`"

#: ../../c-api/exceptions.rst:850
msgid ":exc:`Exception`"
msgstr ":exc:`Exception`"

#: ../../c-api/exceptions.rst:852
msgid ":c:data:`PyExc_ArithmeticError`"
msgstr ":c:data:`PyExc_ArithmeticError`"

#: ../../c-api/exceptions.rst:852
msgid ":exc:`ArithmeticError`"
msgstr ":exc:`ArithmeticError`"

#: ../../c-api/exceptions.rst:854
msgid ":c:data:`PyExc_AssertionError`"
msgstr ":c:data:`PyExc_AssertionError`"

#: ../../c-api/exceptions.rst:854
msgid ":exc:`AssertionError`"
msgstr ":exc:`AssertionError`"

#: ../../c-api/exceptions.rst:856
msgid ":c:data:`PyExc_AttributeError`"
msgstr ":c:data:`PyExc_AttributeError`"

#: ../../c-api/exceptions.rst:856
msgid ":exc:`AttributeError`"
msgstr ":exc:`AttributeError`"

#: ../../c-api/exceptions.rst:858
msgid ":c:data:`PyExc_BlockingIOError`"
msgstr ":c:data:`PyExc_BlockingIOError`"

#: ../../c-api/exceptions.rst:858
msgid ":exc:`BlockingIOError`"
msgstr ":exc:`BlockingIOError`"

#: ../../c-api/exceptions.rst:860
msgid ":c:data:`PyExc_BrokenPipeError`"
msgstr ":c:data:`PyExc_BrokenPipeError`"

#: ../../c-api/exceptions.rst:860
msgid ":exc:`BrokenPipeError`"
msgstr ":exc:`BrokenPipeError`"

#: ../../c-api/exceptions.rst:862
msgid ":c:data:`PyExc_BufferError`"
msgstr ":c:data:`PyExc_BufferError`"

#: ../../c-api/exceptions.rst:862
msgid ":exc:`BufferError`"
msgstr ":exc:`BufferError`"

#: ../../c-api/exceptions.rst:864
msgid ":c:data:`PyExc_ChildProcessError`"
msgstr ":c:data:`PyExc_ChildProcessError`"

#: ../../c-api/exceptions.rst:864
msgid ":exc:`ChildProcessError`"
msgstr ":exc:`ChildProcessError`"

#: ../../c-api/exceptions.rst:866
msgid ":c:data:`PyExc_ConnectionAbortedError`"
msgstr ":c:data:`PyExc_ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:866
msgid ":exc:`ConnectionAbortedError`"
msgstr ":exc:`ConnectionAbortedError`"

#: ../../c-api/exceptions.rst:868
msgid ":c:data:`PyExc_ConnectionError`"
msgstr ":c:data:`PyExc_ConnectionError`"

#: ../../c-api/exceptions.rst:868
msgid ":exc:`ConnectionError`"
msgstr ":exc:`ConnectionError`"

#: ../../c-api/exceptions.rst:870
msgid ":c:data:`PyExc_ConnectionRefusedError`"
msgstr ":c:data:`PyExc_ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:870
msgid ":exc:`ConnectionRefusedError`"
msgstr ":exc:`ConnectionRefusedError`"

#: ../../c-api/exceptions.rst:872
msgid ":c:data:`PyExc_ConnectionResetError`"
msgstr ":c:data:`PyExc_ConnectionResetError`"

#: ../../c-api/exceptions.rst:872
msgid ":exc:`ConnectionResetError`"
msgstr ":exc:`ConnectionResetError`"

#: ../../c-api/exceptions.rst:874
msgid ":c:data:`PyExc_EOFError`"
msgstr ":c:data:`PyExc_EOFError`"

#: ../../c-api/exceptions.rst:874
msgid ":exc:`EOFError`"
msgstr ":exc:`EOFError`"

#: ../../c-api/exceptions.rst:876
msgid ":c:data:`PyExc_FileExistsError`"
msgstr ":c:data:`PyExc_FileExistsError`"

#: ../../c-api/exceptions.rst:876
msgid ":exc:`FileExistsError`"
msgstr ":exc:`FileExistsError`"

#: ../../c-api/exceptions.rst:878
msgid ":c:data:`PyExc_FileNotFoundError`"
msgstr ":c:data:`PyExc_FileNotFoundError`"

#: ../../c-api/exceptions.rst:878
msgid ":exc:`FileNotFoundError`"
msgstr ":exc:`FileNotFoundError`"

#: ../../c-api/exceptions.rst:880
msgid ":c:data:`PyExc_FloatingPointError`"
msgstr ":c:data:`PyExc_FloatingPointError`"

#: ../../c-api/exceptions.rst:880
msgid ":exc:`FloatingPointError`"
msgstr ":exc:`FloatingPointError`"

#: ../../c-api/exceptions.rst:882
msgid ":c:data:`PyExc_GeneratorExit`"
msgstr ":c:data:`PyExc_GeneratorExit`"

#: ../../c-api/exceptions.rst:882
msgid ":exc:`GeneratorExit`"
msgstr ":exc:`GeneratorExit`"

#: ../../c-api/exceptions.rst:884
msgid ":c:data:`PyExc_ImportError`"
msgstr ":c:data:`PyExc_ImportError`"

#: ../../c-api/exceptions.rst:884
msgid ":exc:`ImportError`"
msgstr ":exc:`ImportError`"

#: ../../c-api/exceptions.rst:886
msgid ":c:data:`PyExc_IndentationError`"
msgstr ":c:data:`PyExc_IndentationError`"

#: ../../c-api/exceptions.rst:886
msgid ":exc:`IndentationError`"
msgstr ":exc:`IndentationError`"

#: ../../c-api/exceptions.rst:888
msgid ":c:data:`PyExc_IndexError`"
msgstr ":c:data:`PyExc_IndexError`"

#: ../../c-api/exceptions.rst:888
msgid ":exc:`IndexError`"
msgstr ":exc:`IndexError`"

#: ../../c-api/exceptions.rst:890
msgid ":c:data:`PyExc_InterruptedError`"
msgstr ":c:data:`PyExc_InterruptedError`"

#: ../../c-api/exceptions.rst:890
msgid ":exc:`InterruptedError`"
msgstr ":exc:`InterruptedError`"

#: ../../c-api/exceptions.rst:892
msgid ":c:data:`PyExc_IsADirectoryError`"
msgstr ":c:data:`PyExc_IsADirectoryError`"

#: ../../c-api/exceptions.rst:892
msgid ":exc:`IsADirectoryError`"
msgstr ":exc:`IsADirectoryError`"

#: ../../c-api/exceptions.rst:894
msgid ":c:data:`PyExc_KeyError`"
msgstr ":c:data:`PyExc_KeyError`"

#: ../../c-api/exceptions.rst:894
msgid ":exc:`KeyError`"
msgstr ":exc:`KeyError`"

#: ../../c-api/exceptions.rst:896
msgid ":c:data:`PyExc_KeyboardInterrupt`"
msgstr ":c:data:`PyExc_KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:896
msgid ":exc:`KeyboardInterrupt`"
msgstr ":exc:`KeyboardInterrupt`"

#: ../../c-api/exceptions.rst:898
msgid ":c:data:`PyExc_LookupError`"
msgstr ":c:data:`PyExc_LookupError`"

#: ../../c-api/exceptions.rst:898
msgid ":exc:`LookupError`"
msgstr ":exc:`LookupError`"

#: ../../c-api/exceptions.rst:900
msgid ":c:data:`PyExc_MemoryError`"
msgstr ":c:data:`PyExc_MemoryError`"

#: ../../c-api/exceptions.rst:900
msgid ":exc:`MemoryError`"
msgstr ":exc:`MemoryError`"

#: ../../c-api/exceptions.rst:902
msgid ":c:data:`PyExc_ModuleNotFoundError`"
msgstr ":c:data:`PyExc_ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:902
msgid ":exc:`ModuleNotFoundError`"
msgstr ":exc:`ModuleNotFoundError`"

#: ../../c-api/exceptions.rst:904
msgid ":c:data:`PyExc_NameError`"
msgstr ":c:data:`PyExc_NameError`"

#: ../../c-api/exceptions.rst:904
msgid ":exc:`NameError`"
msgstr ":exc:`NameError`"

#: ../../c-api/exceptions.rst:906
msgid ":c:data:`PyExc_NotADirectoryError`"
msgstr ":c:data:`PyExc_NotADirectoryError`"

#: ../../c-api/exceptions.rst:906
msgid ":exc:`NotADirectoryError`"
msgstr ":exc:`NotADirectoryError`"

#: ../../c-api/exceptions.rst:908
msgid ":c:data:`PyExc_NotImplementedError`"
msgstr ":c:data:`PyExc_NotImplementedError`"

#: ../../c-api/exceptions.rst:908
msgid ":exc:`NotImplementedError`"
msgstr ":exc:`NotImplementedError`"

#: ../../c-api/exceptions.rst:910
msgid ":c:data:`PyExc_OSError`"
msgstr ":c:data:`PyExc_OSError`"

#: ../../c-api/exceptions.rst:910
msgid ":exc:`OSError`"
msgstr ":exc:`OSError`"

#: ../../c-api/exceptions.rst:912
msgid ":c:data:`PyExc_OverflowError`"
msgstr ":c:data:`PyExc_OverflowError`"

#: ../../c-api/exceptions.rst:912
msgid ":exc:`OverflowError`"
msgstr ":exc:`OverflowError`"

#: ../../c-api/exceptions.rst:914
msgid ":c:data:`PyExc_PermissionError`"
msgstr ":c:data:`PyExc_PermissionError`"

#: ../../c-api/exceptions.rst:914
msgid ":exc:`PermissionError`"
msgstr ":exc:`PermissionError`"

#: ../../c-api/exceptions.rst:916
msgid ":c:data:`PyExc_ProcessLookupError`"
msgstr ":c:data:`PyExc_ProcessLookupError`"

#: ../../c-api/exceptions.rst:916
msgid ":exc:`ProcessLookupError`"
msgstr ":exc:`ProcessLookupError`"

#: ../../c-api/exceptions.rst:918
msgid ":c:data:`PyExc_RecursionError`"
msgstr ":c:data:`PyExc_RecursionError`"

#: ../../c-api/exceptions.rst:918
msgid ":exc:`RecursionError`"
msgstr ":exc:`RecursionError`"

#: ../../c-api/exceptions.rst:920
msgid ":c:data:`PyExc_ReferenceError`"
msgstr ":c:data:`PyExc_ReferenceError`"

#: ../../c-api/exceptions.rst:920
msgid ":exc:`ReferenceError`"
msgstr ":exc:`ReferenceError`"

#: ../../c-api/exceptions.rst:922
msgid ":c:data:`PyExc_RuntimeError`"
msgstr ":c:data:`PyExc_RuntimeError`"

#: ../../c-api/exceptions.rst:922
msgid ":exc:`RuntimeError`"
msgstr ":exc:`RuntimeError`"

#: ../../c-api/exceptions.rst:924
msgid ":c:data:`PyExc_StopAsyncIteration`"
msgstr ":c:data:`PyExc_StopAsyncIteration`"

#: ../../c-api/exceptions.rst:924
msgid ":exc:`StopAsyncIteration`"
msgstr ":exc:`StopAsyncIteration`"

#: ../../c-api/exceptions.rst:926
msgid ":c:data:`PyExc_StopIteration`"
msgstr ":c:data:`PyExc_StopIteration`"

#: ../../c-api/exceptions.rst:926
msgid ":exc:`StopIteration`"
msgstr ":exc:`StopIteration`"

#: ../../c-api/exceptions.rst:928
msgid ":c:data:`PyExc_SyntaxError`"
msgstr ":c:data:`PyExc_SyntaxError`"

#: ../../c-api/exceptions.rst:928
msgid ":exc:`SyntaxError`"
msgstr ":exc:`SyntaxError`"

#: ../../c-api/exceptions.rst:930
msgid ":c:data:`PyExc_SystemError`"
msgstr ":c:data:`PyExc_SystemError`"

#: ../../c-api/exceptions.rst:930
msgid ":exc:`SystemError`"
msgstr ":exc:`SystemError`"

#: ../../c-api/exceptions.rst:932
msgid ":c:data:`PyExc_SystemExit`"
msgstr ":c:data:`PyExc_SystemExit`"

#: ../../c-api/exceptions.rst:932
msgid ":exc:`SystemExit`"
msgstr ":exc:`SystemExit`"

#: ../../c-api/exceptions.rst:934
msgid ":c:data:`PyExc_TabError`"
msgstr ":c:data:`PyExc_TabError`"

#: ../../c-api/exceptions.rst:934
msgid ":exc:`TabError`"
msgstr ":exc:`TabError`"

#: ../../c-api/exceptions.rst:936
msgid ":c:data:`PyExc_TimeoutError`"
msgstr ":c:data:`PyExc_TimeoutError`"

#: ../../c-api/exceptions.rst:936
msgid ":exc:`TimeoutError`"
msgstr ":exc:`TimeoutError`"

#: ../../c-api/exceptions.rst:938
msgid ":c:data:`PyExc_TypeError`"
msgstr ":c:data:`PyExc_TypeError`"

#: ../../c-api/exceptions.rst:938
msgid ":exc:`TypeError`"
msgstr ":exc:`TypeError`"

#: ../../c-api/exceptions.rst:940
msgid ":c:data:`PyExc_UnboundLocalError`"
msgstr ":c:data:`PyExc_UnboundLocalError`"

#: ../../c-api/exceptions.rst:940
msgid ":exc:`UnboundLocalError`"
msgstr ":exc:`UnboundLocalError`"

#: ../../c-api/exceptions.rst:942
msgid ":c:data:`PyExc_UnicodeDecodeError`"
msgstr ":c:data:`PyExc_UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:942
msgid ":exc:`UnicodeDecodeError`"
msgstr ":exc:`UnicodeDecodeError`"

#: ../../c-api/exceptions.rst:944
msgid ":c:data:`PyExc_UnicodeEncodeError`"
msgstr ":c:data:`PyExc_UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:944
msgid ":exc:`UnicodeEncodeError`"
msgstr ":exc:`UnicodeEncodeError`"

#: ../../c-api/exceptions.rst:946
msgid ":c:data:`PyExc_UnicodeError`"
msgstr ":c:data:`PyExc_UnicodeError`"

#: ../../c-api/exceptions.rst:946
msgid ":exc:`UnicodeError`"
msgstr ":exc:`UnicodeError`"

#: ../../c-api/exceptions.rst:948
msgid ":c:data:`PyExc_UnicodeTranslateError`"
msgstr ":c:data:`PyExc_UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:948
msgid ":exc:`UnicodeTranslateError`"
msgstr ":exc:`UnicodeTranslateError`"

#: ../../c-api/exceptions.rst:950
msgid ":c:data:`PyExc_ValueError`"
msgstr ":c:data:`PyExc_ValueError`"

#: ../../c-api/exceptions.rst:950
msgid ":exc:`ValueError`"
msgstr ":exc:`ValueError`"

#: ../../c-api/exceptions.rst:952
msgid ":c:data:`PyExc_ZeroDivisionError`"
msgstr ":c:data:`PyExc_ZeroDivisionError`"

#: ../../c-api/exceptions.rst:952
msgid ":exc:`ZeroDivisionError`"
msgstr ":exc:`ZeroDivisionError`"

#: ../../c-api/exceptions.rst:955
msgid ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` and :c:data:"
"`PyExc_TimeoutError` were introduced following :pep:`3151`."
msgstr ""
":c:data:`PyExc_BlockingIOError`, :c:data:`PyExc_BrokenPipeError`, :c:data:"
"`PyExc_ChildProcessError`, :c:data:`PyExc_ConnectionError`, :c:data:"
"`PyExc_ConnectionAbortedError`, :c:data:`PyExc_ConnectionRefusedError`, :c:"
"data:`PyExc_ConnectionResetError`, :c:data:`PyExc_FileExistsError`, :c:data:"
"`PyExc_FileNotFoundError`, :c:data:`PyExc_InterruptedError`, :c:data:"
"`PyExc_IsADirectoryError`, :c:data:`PyExc_NotADirectoryError`, :c:data:"
"`PyExc_PermissionError`, :c:data:`PyExc_ProcessLookupError` и :c:data:"
"`PyExc_TimeoutError` были введены следующим образом :pep:`3151`."

#: ../../c-api/exceptions.rst:965
msgid ":c:data:`PyExc_StopAsyncIteration` and :c:data:`PyExc_RecursionError`."
msgstr ":c:data:`PyExc_StopAsyncIteration` и :c:data:`PyExc_RecursionError`."

#: ../../c-api/exceptions.rst:968
msgid ":c:data:`PyExc_ModuleNotFoundError`."
msgstr ":c:data:`PyExc_ModuleNotFoundError`."

#: ../../c-api/exceptions.rst:971
msgid "These are compatibility aliases to :c:data:`PyExc_OSError`:"
msgstr "Это псевдонимы совместимости с :c:data:`PyExc_OSError`:"

#: ../../c-api/exceptions.rst:981
msgid ":c:data:`PyExc_EnvironmentError`"
msgstr ":c:data:`PyExc_EnvironmentError`"

#: ../../c-api/exceptions.rst:983
msgid ":c:data:`PyExc_IOError`"
msgstr ":c:data:`PyExc_IOError`"

#: ../../c-api/exceptions.rst:985
msgid ":c:data:`PyExc_WindowsError`"
msgstr ":c:data:`PyExc_WindowsError`"

#: ../../c-api/exceptions.rst:985
msgid "[2]_"
msgstr "[2]_"

#: ../../c-api/exceptions.rst:988
msgid "These aliases used to be separate exception types."
msgstr "Эти псевдонимы раньше были отдельными типами исключений."

#: ../../c-api/exceptions.rst:991 ../../c-api/exceptions.rst:1052
msgid "Notes:"
msgstr "Примечания:"

#: ../../c-api/exceptions.rst:994
msgid "This is a base class for other standard exceptions."
msgstr "Это базовый класс для других стандартных исключений."

#: ../../c-api/exceptions.rst:997
msgid ""
"Only defined on Windows; protect code that uses this by testing that the "
"preprocessor macro ``MS_WINDOWS`` is defined."
msgstr ""
"Определен только в Windows; защищает код, который использует это, проводя "
"проверку, определен ли макрос препроцессора ``MS_WINDOWS``."

#: ../../c-api/exceptions.rst:1003
msgid "Standard Warning Categories"
msgstr "Стандартные категории предупреждений"

#: ../../c-api/exceptions.rst:1005
msgid ""
"All standard Python warning categories are available as global variables "
"whose names are ``PyExc_`` followed by the Python exception name. These have "
"the type :c:type:`PyObject*`; they are all class objects. For completeness, "
"here are all the variables:"
msgstr ""
"Все стандартные категории предупреждений Python доступны в виде глобальных "
"переменных, имена которых ``PyExc_``, за которыми следует имя исключения "
"Python. Они имеют тип :c:type:`PyObject*`; все они являются объектами "
"класса. Для полноты картины, вот все переменные:"

#: ../../c-api/exceptions.rst:1026
msgid ":c:data:`PyExc_Warning`"
msgstr ":c:data:`PyExc_Warning`"

#: ../../c-api/exceptions.rst:1026
msgid ":exc:`Warning`"
msgstr ":exc:`Warning`"

#: ../../c-api/exceptions.rst:1026
msgid "[3]_"
msgstr "[3]_"

#: ../../c-api/exceptions.rst:1028
msgid ":c:data:`PyExc_BytesWarning`"
msgstr ":c:data:`PyExc_BytesWarning`"

#: ../../c-api/exceptions.rst:1028
msgid ":exc:`BytesWarning`"
msgstr ":exc:`BytesWarning`"

#: ../../c-api/exceptions.rst:1030
msgid ":c:data:`PyExc_DeprecationWarning`"
msgstr ":c:data:`PyExc_DeprecationWarning`"

#: ../../c-api/exceptions.rst:1030
msgid ":exc:`DeprecationWarning`"
msgstr ":exc:`DeprecationWarning`"

#: ../../c-api/exceptions.rst:1032
msgid ":c:data:`PyExc_FutureWarning`"
msgstr ":c:data:`PyExc_FutureWarning`"

#: ../../c-api/exceptions.rst:1032
msgid ":exc:`FutureWarning`"
msgstr ":exc:`FutureWarning`"

#: ../../c-api/exceptions.rst:1034
msgid ":c:data:`PyExc_ImportWarning`"
msgstr ":c:data:`PyExc_ImportWarning`"

#: ../../c-api/exceptions.rst:1034
msgid ":exc:`ImportWarning`"
msgstr ":exc:`ImportWarning`"

#: ../../c-api/exceptions.rst:1036
msgid ":c:data:`PyExc_PendingDeprecationWarning`"
msgstr ":c:data:`PyExc_PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1036
msgid ":exc:`PendingDeprecationWarning`"
msgstr ":exc:`PendingDeprecationWarning`"

#: ../../c-api/exceptions.rst:1038
msgid ":c:data:`PyExc_ResourceWarning`"
msgstr ":c:data:`PyExc_ResourceWarning`"

#: ../../c-api/exceptions.rst:1038
msgid ":exc:`ResourceWarning`"
msgstr ":exc:`ResourceWarning`"

#: ../../c-api/exceptions.rst:1040
msgid ":c:data:`PyExc_RuntimeWarning`"
msgstr ":c:data:`PyExc_RuntimeWarning`"

#: ../../c-api/exceptions.rst:1040
msgid ":exc:`RuntimeWarning`"
msgstr ":exc:`RuntimeWarning`"

#: ../../c-api/exceptions.rst:1042
msgid ":c:data:`PyExc_SyntaxWarning`"
msgstr ":c:data:`PyExc_SyntaxWarning`"

#: ../../c-api/exceptions.rst:1042
msgid ":exc:`SyntaxWarning`"
msgstr ":exc:`SyntaxWarning`"

#: ../../c-api/exceptions.rst:1044
msgid ":c:data:`PyExc_UnicodeWarning`"
msgstr ":c:data:`PyExc_UnicodeWarning`"

#: ../../c-api/exceptions.rst:1044
msgid ":exc:`UnicodeWarning`"
msgstr ":exc:`UnicodeWarning`"

#: ../../c-api/exceptions.rst:1046
msgid ":c:data:`PyExc_UserWarning`"
msgstr ":c:data:`PyExc_UserWarning`"

#: ../../c-api/exceptions.rst:1046
msgid ":exc:`UserWarning`"
msgstr ":exc:`UserWarning`"

#: ../../c-api/exceptions.rst:1049
msgid ":c:data:`PyExc_ResourceWarning`."
msgstr ":c:data:`PyExc_ResourceWarning`."

#: ../../c-api/exceptions.rst:1055
msgid "This is a base class for other standard warning categories."
msgstr "Это базовый класс для других стандартных категорий предупреждений."
