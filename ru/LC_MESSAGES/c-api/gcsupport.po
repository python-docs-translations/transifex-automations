# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:08+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/gcsupport.rst:6
msgid "Supporting Cyclic Garbage Collection"
msgstr "Поддержка циклической сборки мусора"

#: ../../c-api/gcsupport.rst:8
msgid ""
"Python's support for detecting and collecting garbage which involves "
"circular references requires support from object types which are "
"\"containers\" for other objects which may also be containers.  Types which "
"do not store references to other objects, or which only store references to "
"atomic types (such as numbers or strings), do not need to provide any "
"explicit support for garbage collection."
msgstr ""
"Поддержка Python для обнаружения и сбора мусора, включающего циклические "
"ссылки, требует поддержки типов объектов, которые являются «контейнерами» "
"для других объектов, которые также могут быть контейнерами. Типы, которые не "
"хранят ссылки на другие объекты или хранят только ссылки на атомарные типы "
"(например, числа или строки), не нуждаются в явной поддержке сборки мусора."

#: ../../c-api/gcsupport.rst:15
msgid ""
"To create a container type, the :c:member:`~PyTypeObject.tp_flags` field of "
"the type object must include the :c:macro:`Py_TPFLAGS_HAVE_GC` and provide "
"an implementation of the :c:member:`~PyTypeObject.tp_traverse` handler.  If "
"instances of the type are mutable, a :c:member:`~PyTypeObject.tp_clear` "
"implementation must also be provided."
msgstr ""
"Чтобы создать тип контейнера, поле :c:member:`~PyTypeObject.tp_flags` "
"объекта типа должно включать :c:macro:`Py_TPFLAGS_HAVE_GC` и обеспечивать "
"реализацию :c:member:`~PyTypeObject.tp_traverse. `обработчик. Если "
"экземпляры типа изменяемы, необходимо также предоставить реализацию :c:"
"member:`~PyTypeObject.tp_clear`."

#: ../../c-api/gcsupport.rst:24
msgid ":c:macro:`Py_TPFLAGS_HAVE_GC`"
msgstr ":c:macro:`Py_TPFLAGS_HAVE_GC`"

#: ../../c-api/gcsupport.rst:22
msgid ""
"Objects with a type with this flag set must conform with the rules "
"documented here.  For convenience these objects will be referred to as "
"container objects."
msgstr ""
"Объекты типа с этим установленным флагом должны соответствовать правилам, "
"описанным здесь. Для удобства эти объекты будем называть объектами-"
"контейнерами."

#: ../../c-api/gcsupport.rst:26
msgid "Constructors for container types must conform to two rules:"
msgstr "Конструкторы типов контейнеров должны соответствовать двум правилам:"

#: ../../c-api/gcsupport.rst:28
msgid ""
"The memory for the object must be allocated using :c:macro:`PyObject_GC_New` "
"or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"Память для объекта должна быть выделена с помощью :c:macro:`PyObject_GC_New` "
"или :c:macro:`PyObject_GC_NewVar`."

#: ../../c-api/gcsupport.rst:31
msgid ""
"Once all the fields which may contain references to other containers are "
"initialized, it must call :c:func:`PyObject_GC_Track`."
msgstr ""
"После инициализации всех полей, которые могут содержать ссылки на другие "
"контейнеры, необходимо вызвать :c:func:`PyObject_GC_Track`."

#: ../../c-api/gcsupport.rst:34
msgid ""
"Similarly, the deallocator for the object must conform to a similar pair of "
"rules:"
msgstr ""
"Аналогично, освободитель объекта должен соответствовать аналогичной паре "
"правил:"

#: ../../c-api/gcsupport.rst:37
msgid ""
"Before fields which refer to other containers are invalidated, :c:func:"
"`PyObject_GC_UnTrack` must be called."
msgstr ""
"Прежде чем поля, которые ссылаются на другие контейнеры, станут "
"недействительными, необходимо вызвать :c:func:`PyObject_GC_UnTrack`."

#: ../../c-api/gcsupport.rst:40
msgid ""
"The object's memory must be deallocated using :c:func:`PyObject_GC_Del`."
msgstr ""
"Память объекта должна быть освобождена с помощью :c:func:`PyObject_GC_Del`."

#: ../../c-api/gcsupport.rst:43
msgid ""
"If a type adds the Py_TPFLAGS_HAVE_GC, then it *must* implement at least a :"
"c:member:`~PyTypeObject.tp_traverse` handler or explicitly use one from its "
"subclass or subclasses."
msgstr ""
"Если тип добавляет Py_TPFLAGS_HAVE_GC, то он *должен* реализовать как "
"минимум обработчик :c:member:`~PyTypeObject.tp_traverse` или явно "
"использовать один из его подкласса или подклассов."

#: ../../c-api/gcsupport.rst:47
msgid ""
"When calling :c:func:`PyType_Ready` or some of the APIs that indirectly call "
"it like :c:func:`PyType_FromSpecWithBases` or :c:func:`PyType_FromSpec` the "
"interpreter will automatically populate the :c:member:`~PyTypeObject."
"tp_flags`, :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields if the type inherits from a class that "
"implements the garbage collector protocol and the child class does *not* "
"include the :c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"При вызове :c:func:`PyType_Ready` или некоторых API, которые косвенно "
"вызывают его, например :c:func:`PyType_FromSpecWithBases` или :c:func:"
"`PyType_FromSpec`, интерпретатор автоматически заполняет :c:member:`~ Поля "
"PyTypeObject.tp_flags`, :c:member:`~PyTypeObject.tp_traverse` и :c:member:"
"`~PyTypeObject.tp_clear`, если тип наследуется от класса, реализующего "
"протокол сборщика мусора, а дочерний класс *нет* включите флаг :c:macro:"
"`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/gcsupport.rst:57
msgid ""
"Analogous to :c:macro:`PyObject_New` but for container objects with the :c:"
"macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Аналогично :c:macro:`PyObject_New`, но для объектов-контейнеров с "
"установленным флагом :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/gcsupport.rst:63
msgid ""
"Analogous to :c:macro:`PyObject_NewVar` but for container objects with the :"
"c:macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Аналогично :c:macro:`PyObject_NewVar`, но для объектов-контейнеров с "
"установленным флагом :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/gcsupport.rst:69
msgid ""
"Resize an object allocated by :c:macro:`PyObject_NewVar`. Returns the "
"resized object of type ``TYPE*`` (refers to any C type) or ``NULL`` on "
"failure."
msgstr ""
"Измените размер объекта, выделенного :c:macro:`PyObject_NewVar`. Возвращает "
"объект измененного размера типа TYPE* ​​(относится к любому типу C) или NULL в "
"случае ошибки."

#: ../../c-api/gcsupport.rst:73
msgid ""
"*op* must be of type :c:expr:`PyVarObject *` and must not be tracked by the "
"collector yet. *newsize* must be of type :c:type:`Py_ssize_t`."
msgstr ""
"*op* должен иметь тип :c:expr:`PyVarObject *` и пока не должен отслеживаться "
"сборщиком. *newsize* должен иметь тип :c:type:`Py_ssize_t`."

#: ../../c-api/gcsupport.rst:80
msgid ""
"Adds the object *op* to the set of container objects tracked by the "
"collector.  The collector can run at unexpected times so objects must be "
"valid while being tracked.  This should be called once all the fields "
"followed by the :c:member:`~PyTypeObject.tp_traverse` handler become valid, "
"usually near the end of the constructor."
msgstr ""
"Добавляет объект *op* в набор объектов-контейнеров, отслеживаемых сборщиком. "
"Сборщик может запускаться в неожиданное время, поэтому объекты должны быть "
"действительными во время отслеживания. Его следует вызывать, как только все "
"поля, за которыми следует обработчик :c:member:`~PyTypeObject.tp_traverse`, "
"станут действительными, обычно ближе к концу конструктора."

#: ../../c-api/gcsupport.rst:89
msgid ""
"Returns non-zero if the object implements the garbage collector protocol, "
"otherwise returns 0."
msgstr ""
"Возвращает ненулевое значение, если объект реализует протокол сборщика "
"мусора, в противном случае возвращает 0."

#: ../../c-api/gcsupport.rst:92
msgid ""
"The object cannot be tracked by the garbage collector if this function "
"returns 0."
msgstr ""
"Объект не может отслеживаться сборщиком мусора, если эта функция возвращает "
"0."

#: ../../c-api/gcsupport.rst:97
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* is "
"being currently tracked by the garbage collector and 0 otherwise."
msgstr ""
"Возвращает 1, если тип объекта *op* реализует протокол GC и *op* в данный "
"момент отслеживается сборщиком мусора, и 0 в противном случае."

#: ../../c-api/gcsupport.rst:100
msgid "This is analogous to the Python function :func:`gc.is_tracked`."
msgstr "Это аналог функции Python :func:`gc.is_tracked`."

#: ../../c-api/gcsupport.rst:107
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* has "
"been already finalized by the garbage collector and 0 otherwise."
msgstr ""
"Возвращает 1, если тип объекта *op* реализует протокол GC и *op* уже "
"завершен сборщиком мусора, и 0 в противном случае."

#: ../../c-api/gcsupport.rst:110
msgid "This is analogous to the Python function :func:`gc.is_finalized`."
msgstr "Это аналогично функции Python :func:`gc.is_finalized`."

#: ../../c-api/gcsupport.rst:117
msgid ""
"Releases memory allocated to an object using :c:macro:`PyObject_GC_New` or :"
"c:macro:`PyObject_GC_NewVar`."
msgstr ""
"Освобождает память, выделенную объекту, используя :c:macro:`PyObject_GC_New` "
"или :c:macro:`PyObject_GC_NewVar`."

#: ../../c-api/gcsupport.rst:123
msgid ""
"Remove the object *op* from the set of container objects tracked by the "
"collector.  Note that :c:func:`PyObject_GC_Track` can be called again on "
"this object to add it back to the set of tracked objects.  The deallocator (:"
"c:member:`~PyTypeObject.tp_dealloc` handler) should call this for the object "
"before any of the fields used by the :c:member:`~PyTypeObject.tp_traverse` "
"handler become invalid."
msgstr ""
"Удалите объект *op* из набора объектов-контейнеров, отслеживаемых сборщиком. "
"Обратите внимание, что :c:func:`PyObject_GC_Track` можно вызвать снова для "
"этого объекта, чтобы добавить его обратно в набор отслеживаемых объектов. "
"Deallocator (:c:member:`~PyTypeObject.tp_dealloc` обработчик) должен вызвать "
"это для объекта до того, как любое из полей, используемых обработчиком :c:"
"member:`~PyTypeObject.tp_traverse`, станет недействительным."

#: ../../c-api/gcsupport.rst:132
msgid ""
"The :c:func:`!_PyObject_GC_TRACK` and :c:func:`!_PyObject_GC_UNTRACK` macros "
"have been removed from the public C API."
msgstr ""
"Макросы :c:func:`!_PyObject_GC_TRACK` и :c:func:`!_PyObject_GC_UNTRACK` были "
"удалены из общедоступного C API."

#: ../../c-api/gcsupport.rst:135
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function "
"parameter of this type:"
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_traverse` принимает параметр функции "
"этого типа:"

#: ../../c-api/gcsupport.rst:140
msgid ""
"Type of the visitor function passed to the :c:member:`~PyTypeObject."
"tp_traverse` handler. The function should be called with an object to "
"traverse as *object* and the third parameter to the :c:member:`~PyTypeObject."
"tp_traverse` handler as *arg*.  The Python core uses several visitor "
"functions to implement cyclic garbage detection; it's not expected that "
"users will need to write their own visitor functions."
msgstr ""
"Тип функции посетителя, передаваемой обработчику :c:member:`~PyTypeObject."
"tp_traverse`. Функцию следует вызывать с объектом для перемещения как "
"*object* и третьим параметром обработчика :c:member:`~PyTypeObject."
"tp_traverse` как *arg*. Ядро Python использует несколько гостевых функций "
"для реализации циклического обнаружения мусора; не ожидается, что "
"пользователям потребуется писать свои собственные функции посетителей."

#: ../../c-api/gcsupport.rst:147
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler must have the following "
"type:"
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_traverse` должен иметь следующий тип:"

#: ../../c-api/gcsupport.rst:152
msgid ""
"Traversal function for a container object.  Implementations must call the "
"*visit* function for each object directly contained by *self*, with the "
"parameters to *visit* being the contained object and the *arg* value passed "
"to the handler.  The *visit* function must not be called with a ``NULL`` "
"object argument.  If *visit* returns a non-zero value that value should be "
"returned immediately."
msgstr ""
"Функция обхода объекта-контейнера. Реализации должны вызывать функцию "
"*visit* для каждого объекта, непосредственно содержащегося в *self*, причем "
"параметры *visit* являются содержащимся объектом, а значение *arg* "
"передается обработчику. Функцию *visit* нельзя вызывать с аргументом объекта "
"``NULL``. Если *visit* возвращает ненулевое значение, это значение должно "
"быть возвращено немедленно."

#: ../../c-api/gcsupport.rst:159
msgid ""
"To simplify writing :c:member:`~PyTypeObject.tp_traverse` handlers, a :c:"
"func:`Py_VISIT` macro is provided.  In order to use this macro, the :c:"
"member:`~PyTypeObject.tp_traverse` implementation must name its arguments "
"exactly *visit* and *arg*:"
msgstr ""
"Для упрощения написания обработчиков :c:member:`~PyTypeObject.tp_traverse` "
"предусмотрен макрос :c:func:`Py_VISIT`. Чтобы использовать этот макрос, "
"реализация :c:member:`~PyTypeObject.tp_traverse` должна точно назвать свои "
"аргументы *visit* и *arg*:"

#: ../../c-api/gcsupport.rst:166
msgid ""
"If *o* is not ``NULL``, call the *visit* callback, with arguments *o* and "
"*arg*.  If *visit* returns a non-zero value, then return it. Using this "
"macro, :c:member:`~PyTypeObject.tp_traverse` handlers look like::"
msgstr ""
"Если *o* не равно NULL, вызовите обратный вызов *visit* с аргументами *o* и "
"*arg*. Если *visit* возвращает ненулевое значение, верните его. Используя "
"этот макрос, обработчики :c:member:`~PyTypeObject.tp_traverse` выглядят "
"следующим образом::"

#: ../../c-api/gcsupport.rst:179
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` handler must be of the :c:type:"
"`inquiry` type, or ``NULL`` if the object is immutable."
msgstr ""
"Обработчик :c:member:`~PyTypeObject.tp_clear` должен иметь тип :c:type:"
"`inquiry` или ``NULL``, если объект является неизменяемым."

#: ../../c-api/gcsupport.rst:185
msgid ""
"Drop references that may have created reference cycles.  Immutable objects "
"do not have to define this method since they can never directly create "
"reference cycles.  Note that the object must still be valid after calling "
"this method (don't just call :c:func:`Py_DECREF` on a reference).  The "
"collector will call this method if it detects that this object is involved "
"in a reference cycle."
msgstr ""
"Удалите ссылки, которые могли создать ссылочные циклы. Неизменяемым объектам "
"не обязательно определять этот метод, поскольку они никогда не могут "
"напрямую создавать ссылочные циклы. Обратите внимание, что объект должен "
"оставаться действительным после вызова этого метода (не вызывайте просто :c:"
"func:`Py_DECREF` по ссылке). Сборщик вызовет этот метод, если обнаружит, что "
"этот объект участвует в ссылочном цикле."

#: ../../c-api/gcsupport.rst:194
msgid "Controlling the Garbage Collector State"
msgstr "Управление состоянием сборщика мусора"

#: ../../c-api/gcsupport.rst:196
msgid ""
"The C-API provides the following functions for controlling garbage "
"collection runs."
msgstr "C-API предоставляет следующие функции для управления сборкой мусора."

#: ../../c-api/gcsupport.rst:201
msgid ""
"Perform a full garbage collection, if the garbage collector is enabled. "
"(Note that :func:`gc.collect` runs it unconditionally.)"
msgstr ""
"Выполните полную сборку мусора, если сборщик мусора включен. (Обратите "
"внимание, что :func:`gc.collect` запускает его безоговорочно.)"

#: ../../c-api/gcsupport.rst:204
msgid ""
"Returns the number of collected + unreachable objects which cannot be "
"collected. If the garbage collector is disabled or already collecting, "
"returns ``0`` immediately. Errors during garbage collection are passed to :"
"data:`sys.unraisablehook`. This function does not raise exceptions."
msgstr ""
"Возвращает количество собранных + недоступных объектов, которые невозможно "
"собрать. Если сборщик мусора отключен или уже собирает мусор, немедленно "
"возвращает ``0``. Ошибки во время сборки мусора передаются в :data:`sys."
"unraisablehook`. Эта функция не вызывает исключений."

#: ../../c-api/gcsupport.rst:214
msgid ""
"Enable the garbage collector: similar to :func:`gc.enable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Включите сборщик мусора: аналогично :func:`gc.enable`. Возвращает предыдущее "
"состояние: 0 для отключенного и 1 для включенного."

#: ../../c-api/gcsupport.rst:222
msgid ""
"Disable the garbage collector: similar to :func:`gc.disable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Отключите сборщик мусора: аналогично :func:`gc.disable`. Возвращает "
"предыдущее состояние: 0 для отключенного и 1 для включенного."

#: ../../c-api/gcsupport.rst:230
msgid ""
"Query the state of the garbage collector: similar to :func:`gc.isenabled`. "
"Returns the current state, 0 for disabled and 1 for enabled."
msgstr ""
"Запросить состояние сборщика мусора: аналогично :func:`gc.isenabled`. "
"Возвращает текущее состояние: 0 для отключенного и 1 для включенного."
