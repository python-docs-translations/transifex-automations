# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Jon Britva, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "Объекты типа"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Возможно, одной из наиболее важных структур объектной системы Python "
"является структура, определяющая новый тип: структура :c:type:"
"`PyTypeObject`. Объекты типа могут обрабатываться с помощью любой из функций "
"PyObject_* или PyType_*, но они не предлагают многого из того, что интересно "
"большинству приложений Python. Эти объекты имеют фундаментальное значение "
"для поведения объектов, поэтому они очень важны для самого интерпретатора и "
"для любого модуля расширения, реализующего новые типы."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Объекты типов довольно велики по сравнению с большинством стандартных типов. "
"Причиной такого размера является то, что каждый объект типа хранит большое "
"количество значений, в основном указателей на функции C, каждый из которых "
"реализует небольшую часть функциональности типа. Поля объекта типа подробно "
"рассматриваются в этом разделе. Поля будут описаны в том порядке, в котором "
"они встречаются в структуре."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"В дополнение к следующему краткому справочнику раздел :ref:`typedef-"
"examples` дает краткое представление о значении и использовании :c:type:"
"`PyTypeObject`."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Краткий справочник"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"tp slots\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "PyTypeObject Slot [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:199
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Type <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "специальные методы/атрибуты"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Info [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:414
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:344
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:368
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:373
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:366
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:402
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:235
#: ../../c-api/typeobj.rst:238 ../../c-api/typeobj.rst:438
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:379
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:384
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:348
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:246 ../../c-api/typeobj.rst:427
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:404
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid ":c:member:`~PyTypeObject.tp_weaklistoffset`"
msgstr ""

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:410
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:412
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__база__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:140 ../../c-api/typeobj.rst:339
#: ../../c-api/typeobj.rst:344 ../../c-api/typeobj.rst:354
#: ../../c-api/typeobj.rst:366 ../../c-api/typeobj.rst:368
#: ../../c-api/typeobj.rst:379 ../../c-api/typeobj.rst:390
#: ../../c-api/typeobj.rst:402 ../../c-api/typeobj.rst:404
#: ../../c-api/typeobj.rst:410 ../../c-api/typeobj.rst:412
#: ../../c-api/typeobj.rst:414 ../../c-api/typeobj.rst:427
#: ../../c-api/typeobj.rst:429 ../../c-api/typeobj.rst:433
#: ../../c-api/typeobj.rst:438 ../../c-api/typeobj.rst:444
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__диктант__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:390
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:396
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid ":c:member:`~PyTypeObject.tp_dictoffset`"
msgstr ""

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:360
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:339
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:354
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:346
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__базы__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__подклассы__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:153
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""
"**()**: имя слота в круглых скобках указывает на то, что он (фактически) "
"устарел."

#: ../../c-api/typeobj.rst:155
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""
"*<>**: Имена в угловых скобках должны изначально иметь значение ``NULL`` и "
"рассматриваться как доступные только для чтения."

#: ../../c-api/typeobj.rst:158
msgid "**[]**: Names in square brackets are for internal use only."
msgstr ""
"**[]**: Имена в квадратных скобках предназначены только для внутреннего "
"использования."

#: ../../c-api/typeobj.rst:160
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""
"**<R>** (в качестве префикса) означает, что поле является обязательным (не "
"должно иметь значение NULL)."

#: ../../c-api/typeobj.rst:162
msgid "Columns:"
msgstr "Столбцы:"

#: ../../c-api/typeobj.rst:164
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: установлено в :c:data:`PyBaseObject_Type`"

#: ../../c-api/typeobj.rst:166
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**: установлено в :c:data:`PyType_Type`"

#: ../../c-api/typeobj.rst:168
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**:  по умолчанию (если слот установлен на ``NULL``)"

#: ../../c-api/typeobj.rst:178
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**:  наследование"

#: ../../c-api/typeobj.rst:187
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Обратите внимание, что некоторые слоты фактически наследуются через обычную "
"цепочку поиска атрибутов."

#: ../../c-api/typeobj.rst:193
msgid "sub-slots"
msgstr "субслоты"

#: ../../c-api/typeobj.rst:199
msgid "Slot"
msgstr "Слот"

#: ../../c-api/typeobj.rst:199
msgid "special methods"
msgstr "специальные методы"

#: ../../c-api/typeobj.rst:202
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:202 ../../c-api/typeobj.rst:204
#: ../../c-api/typeobj.rst:206 ../../c-api/typeobj.rst:240
#: ../../c-api/typeobj.rst:242 ../../c-api/typeobj.rst:244
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:275
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:289
#: ../../c-api/typeobj.rst:429
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:202
msgid "__await__"
msgstr "__ожидание__"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:204
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:206
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:208
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:212
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:212 ../../c-api/typeobj.rst:215
#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:220
#: ../../c-api/typeobj.rst:222 ../../c-api/typeobj.rst:225
#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:230
#: ../../c-api/typeobj.rst:232 ../../c-api/typeobj.rst:250
#: ../../c-api/typeobj.rst:253 ../../c-api/typeobj.rst:255
#: ../../c-api/typeobj.rst:258 ../../c-api/typeobj.rst:260
#: ../../c-api/typeobj.rst:263 ../../c-api/typeobj.rst:265
#: ../../c-api/typeobj.rst:268 ../../c-api/typeobj.rst:270
#: ../../c-api/typeobj.rst:273 ../../c-api/typeobj.rst:281
#: ../../c-api/typeobj.rst:283 ../../c-api/typeobj.rst:285
#: ../../c-api/typeobj.rst:287 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:294 ../../c-api/typeobj.rst:300
#: ../../c-api/typeobj.rst:309 ../../c-api/typeobj.rst:320
#: ../../c-api/typeobj.rst:433
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:212
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:215
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:215 ../../c-api/typeobj.rst:320
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:217
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:220
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:220
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:222
msgid "__mul__ __rmul__"
msgstr "__мул__ __рмул__"

#: ../../c-api/typeobj.rst:225
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:225 ../../c-api/typeobj.rst:322
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:227
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:230
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:230
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:232
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:235
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:235
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:238
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:238
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:240
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:242
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:244
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:246
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:248
msgid "__invert__"
msgstr "__invert__."

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:250
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:253
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:253
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:255
msgid "__rshift__ __rrshift__"
msgstr "__rrshift__ __rrshift__"

#: ../../c-api/typeobj.rst:258
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:258
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:260
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:263
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:263
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:265
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:268
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:268
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:270
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:273
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:273
msgid "__ior__"
msgstr "__ior__."

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:275
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:346
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:279
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:281
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:289
msgid "__index__"
msgstr "__index__."

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:291
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:294
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:294
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:298
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:298 ../../c-api/typeobj.rst:307
#: ../../c-api/typeobj.rst:414
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:298 ../../c-api/typeobj.rst:307
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:313
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:460
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:302
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:307
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:309
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:313
#: ../../c-api/typeobj.rst:322 ../../c-api/typeobj.rst:444
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:311
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:315 ../../c-api/typeobj.rst:449
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:315
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:318
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:318 ../../c-api/typeobj.rst:455
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:318
msgid "__contains__"
msgstr "__содержит__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:326
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:326
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:334
msgid "slot typedefs"
msgstr "слот typedefs"

#: ../../c-api/typeobj.rst:337
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:337
msgid "Parameter Types"
msgstr "Типы параметров"

#: ../../c-api/typeobj.rst:337
msgid "Return Type"
msgstr "Возвращаемый тип"

#: ../../c-api/typeobj.rst:344 ../../c-api/typeobj.rst:346
#: ../../c-api/typeobj.rst:422
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:348
#: ../../c-api/typeobj.rst:360 ../../c-api/typeobj.rst:373
#: ../../c-api/typeobj.rst:384 ../../c-api/typeobj.rst:396
#: ../../c-api/typeobj.rst:416 ../../c-api/typeobj.rst:427
#: ../../c-api/typeobj.rst:449 ../../c-api/typeobj.rst:455
#: ../../c-api/typeobj.rst:460
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:402
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:416
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:422
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:467
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Более подробную информацию см. в разделе :ref:`slot-typedefs` ниже."

#: ../../c-api/typeobj.rst:471
msgid "PyTypeObject Definition"
msgstr "Определение PyTypeObject"

#: ../../c-api/typeobj.rst:473
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"Определение структуры для :c:type:`PyTypeObject` можно найти в :file:"
"`Include/object.h`. Для удобства ссылок это повторяет найденное там "
"определение:"

#: ../../c-api/typeobj.rst:483
msgid "PyObject Slots"
msgstr "Слоты PyObject"

#: ../../c-api/typeobj.rst:485
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by :"
"c:func:`!type_new`, usually called from a class statement). Note that :c:"
"data:`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"Структура объекта типа расширяет структуру :c:type:`PyVarObject`. Поле :c:"
"member:`~PyVarObject.ob_size` используется для динамических типов "
"(создаваемых :c:func:`!type_new`, обычно вызываемых из оператора класса). "
"Обратите внимание, что :c:data:`PyType_Type` (метатип) инициализирует :c:"
"member:`~PyTypeObject.tp_itemsize`, что означает, что его экземпляры (т.е. "
"объекты типа) *должны* иметь :c:member:`~PyVarObject Поле .ob_size`."

#: ../../c-api/typeobj.rst:494
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :c:member:"
"`~PyObject.ob_type` points back to the type) do *not* count as references.  "
"But for :ref:`dynamically allocated type objects <heap-types>`, the "
"instances *do* count as references."
msgstr ""
"Это счетчик ссылок объекта типа, инициализированный значением 1 макросом "
"PyObject_HEAD_INIT. Обратите внимание, что для :ref:`статически выделенных "
"объектов типа <static-types>` экземпляры типа (объекты, :c:member:`~PyObject."
"ob_type` указывает обратно на тип) *не* считаются ссылками. Но для :ref:"
"`динамически выделяемых объектов типа <heap-types>` экземпляры "
"*действительно* считаются ссылками."

#: ../../c-api/typeobj.rst:501 ../../c-api/typeobj.rst:524
#: ../../c-api/typeobj.rst:546 ../../c-api/typeobj.rst:560
#: ../../c-api/typeobj.rst:604 ../../c-api/typeobj.rst:647
#: ../../c-api/typeobj.rst:706 ../../c-api/typeobj.rst:744
#: ../../c-api/typeobj.rst:764 ../../c-api/typeobj.rst:781
#: ../../c-api/typeobj.rst:799 ../../c-api/typeobj.rst:823
#: ../../c-api/typeobj.rst:840 ../../c-api/typeobj.rst:852
#: ../../c-api/typeobj.rst:864 ../../c-api/typeobj.rst:897
#: ../../c-api/typeobj.rst:915 ../../c-api/typeobj.rst:935
#: ../../c-api/typeobj.rst:956 ../../c-api/typeobj.rst:982
#: ../../c-api/typeobj.rst:1001 ../../c-api/typeobj.rst:1017
#: ../../c-api/typeobj.rst:1056 ../../c-api/typeobj.rst:1067
#: ../../c-api/typeobj.rst:1077 ../../c-api/typeobj.rst:1087
#: ../../c-api/typeobj.rst:1101 ../../c-api/typeobj.rst:1119
#: ../../c-api/typeobj.rst:1142 ../../c-api/typeobj.rst:1189
#: ../../c-api/typeobj.rst:1204 ../../c-api/typeobj.rst:1223
#: ../../c-api/typeobj.rst:1253 ../../c-api/typeobj.rst:1275
#: ../../c-api/typeobj.rst:1291 ../../c-api/typeobj.rst:1359
#: ../../c-api/typeobj.rst:1427 ../../c-api/typeobj.rst:1488
#: ../../c-api/typeobj.rst:1518 ../../c-api/typeobj.rst:1550
#: ../../c-api/typeobj.rst:1573 ../../c-api/typeobj.rst:1586
#: ../../c-api/typeobj.rst:1601 ../../c-api/typeobj.rst:1615
#: ../../c-api/typeobj.rst:1645 ../../c-api/typeobj.rst:1665
#: ../../c-api/typeobj.rst:1691 ../../c-api/typeobj.rst:1709
#: ../../c-api/typeobj.rst:1742 ../../c-api/typeobj.rst:1793
#: ../../c-api/typeobj.rst:1810 ../../c-api/typeobj.rst:1851
#: ../../c-api/typeobj.rst:1873 ../../c-api/typeobj.rst:1905
#: ../../c-api/typeobj.rst:1933 ../../c-api/typeobj.rst:1946
#: ../../c-api/typeobj.rst:1956 ../../c-api/typeobj.rst:1965
#: ../../c-api/typeobj.rst:1975 ../../c-api/typeobj.rst:1989
#: ../../c-api/typeobj.rst:2035 ../../c-api/typeobj.rst:2058
msgid "**Inheritance:**"
msgstr "**Наследование:**"

#: ../../c-api/typeobj.rst:503 ../../c-api/typeobj.rst:562
#: ../../c-api/typeobj.rst:606
msgid "This field is not inherited by subtypes."
msgstr "Это поле не наследуется подтипами."

#: ../../c-api/typeobj.rst:508
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Это тип типа, другими словами, его метатип. Он инициализируется аргументом "
"макроса ``PyObject_HEAD_INIT``, и его значение обычно должно быть "
"``&PyType_Type``. Однако для динамически загружаемых модулей расширения, "
"которые должны использоваться в Windows (по крайней мере), компилятор "
"сообщает, что это недопустимый инициализатор. Поэтому принято передавать "
"NULL в макрос PyObject_HEAD_INIT и явно инициализировать это поле в начале "
"функции инициализации модуля, прежде чем делать что-либо еще. Обычно это "
"делается так:"

#: ../../c-api/typeobj.rst:519
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, and if "
"so, initializes it to the :c:member:`~PyObject.ob_type` field of the base "
"class. :c:func:`PyType_Ready` will not change this field if it is non-zero."
msgstr ""
"Это следует сделать до создания экземпляров типа. :c:func:`PyType_Ready` "
"проверяет, имеет ли :c:member:`~PyObject.ob_type` значение ``NULL``, и если "
"да, то инициализирует его значением поля :c:member:`~PyObject.ob_type` "
"базовый класс. :c:func:`PyType_Ready` не изменит это поле, если оно не равно "
"нулю."

#: ../../c-api/typeobj.rst:526 ../../c-api/typeobj.rst:708
#: ../../c-api/typeobj.rst:825 ../../c-api/typeobj.rst:917
#: ../../c-api/typeobj.rst:937 ../../c-api/typeobj.rst:1552
#: ../../c-api/typeobj.rst:1575 ../../c-api/typeobj.rst:1693
#: ../../c-api/typeobj.rst:1711 ../../c-api/typeobj.rst:1795
#: ../../c-api/typeobj.rst:1907 ../../c-api/typeobj.rst:2037
msgid "This field is inherited by subtypes."
msgstr "Это поле наследуется подтипами."

#: ../../c-api/typeobj.rst:532
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined "
"(see the :option:`configure --with-trace-refs option <--with-trace-refs>`)."
msgstr ""
"Эти поля присутствуют только тогда, когда определен макрос ``Py_TRACE_REFS`` "
"(см. параметр :option:`configure --with-trace-refs <--with-trace-refs>`)."

#: ../../c-api/typeobj.rst:535
msgid ""
"Their initialization to ``NULL`` is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For :ref:`statically allocated objects "
"<static-types>`, these fields always remain ``NULL``.  For :ref:`dynamically "
"allocated objects <heap-types>`, these two fields are used to link the "
"object into a doubly linked list of *all* live objects on the heap."
msgstr ""
"Их инициализация значением NULL осуществляется макросом PyObject_HEAD_INIT. "
"Для :ref:`статически выделенных объектов <static-types>` эти поля всегда "
"остаются ``NULL``. Для :ref:`динамически выделяемых объектов <heap-types>` "
"эти два поля используются для связи объекта с двусвязным списком *всех* "
"живых объектов в куче."

#: ../../c-api/typeobj.rst:541
msgid ""
"This could be used for various debugging purposes; currently the only uses "
"are the :func:`sys.getobjects` function and to print the objects that are "
"still alive at the end of a run when the environment variable :envvar:"
"`PYTHONDUMPREFS` is set."
msgstr ""
"Это можно использовать для различных целей отладки; в настоящее время "
"единственным использованием является функция :func:`sys.getobjects` и для "
"печати объектов, которые все еще живы в конце запуска, когда установлена ​​"
"переменная среды :envvar:`PYTHONDUMPREFS`."

#: ../../c-api/typeobj.rst:548
msgid "These fields are not inherited by subtypes."
msgstr "Эти поля не наследуются подтипами."

#: ../../c-api/typeobj.rst:552
msgid "PyVarObject Slots"
msgstr "Слоты PyVarObject"

#: ../../c-api/typeobj.rst:556
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"Для :ref:`статически выделенных объектов типа <static-types>` это значение "
"должно быть инициализировано равным нулю. Для :ref:`динамически выделяемых "
"объектов типа <heap-types>` это поле имеет особое внутреннее значение."

#: ../../c-api/typeobj.rst:566
msgid "PyTypeObject Slots"
msgstr "Слоты PyTypeObject"

#: ../../c-api/typeobj.rst:568
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:data:"
"`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as defaults.)"
msgstr ""
"В каждом слоте есть раздел, описывающий наследование. Если :c:func:"
"`PyType_Ready` может установить значение, когда поле установлено в ``NULL``, "
"тогда также будет раздел «По умолчанию». (Обратите внимание, что многие "
"поля, установленные в :c:data:`PyBaseObject_Type` и :c:data:`PyType_Type`, "
"фактически действуют как значения по умолчанию.)"

#: ../../c-api/typeobj.rst:575
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage :"
"mod:`!Q` in package :mod:`!P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Указатель на строку, завершающуюся NUL, содержащую имя типа. Для типов, "
"доступных как глобальные переменные модуля, строка должна представлять собой "
"полное имя модуля, за которым следует точка, за которой следует имя типа; "
"для встроенных типов это должно быть просто имя типа. Если модуль является "
"подмодулем пакета, полное имя пакета является частью полного имени модуля. "
"Например, тип с именем :class:`!T`, определенный в модуле :mod:`!M` в "
"подпакете :mod:`!Q` в пакете :mod:`!P`, должен иметь :c:member:` "
"~PyTypeObject.tp_name` инициализатор ``\"PQMT\"``."

#: ../../c-api/typeobj.rst:583
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"Для :ref:`динамически выделяемых объектов типа <heap-types>` это должно быть "
"просто имя типа и имя модуля, явно сохраненное в словаре типа как значение "
"для ключа ``'__module__'``."

#: ../../c-api/typeobj.rst:588
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`__module__` attribute, and everything after the "
"last dot is made accessible as the :attr:`~definition.__name__` attribute."
msgstr ""

#: ../../c-api/typeobj.rst:594
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~definition.__name__` attribute, and the :attr:"
"`__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""

#: ../../c-api/typeobj.rst:600
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Это поле не должно быть NULL. Это единственное обязательное поле в :c:func:"
"`PyTypeObject` (кроме потенциально :c:member:`~PyTypeObject.tp_itemsize`)."

#: ../../c-api/typeobj.rst:612
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr "Эти поля позволяют рассчитать размер экземпляров типа в байтах."

#: ../../c-api/typeobj.rst:614
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Существует два типа типов: типы с экземплярами фиксированной длины имеют "
"нулевое поле :c:member:`~PyTypeObject.tp_itemsize`, типы с экземплярами "
"переменной длины имеют ненулевое поле :c:member:`~PyTypeObject.tp_itemsize` "
"`поле. Для типа с экземплярами фиксированной длины все экземпляры имеют "
"одинаковый размер, указанный в :c:member:`~PyTypeObject.tp_basicsize`."

#: ../../c-api/typeobj.rst:619
msgid ""
"For a type with variable-length instances, the instances must have an :c:"
"member:`~PyVarObject.ob_size` field, and the instance size is :c:member:"
"`~PyTypeObject.tp_basicsize` plus N times :c:member:`~PyTypeObject."
"tp_itemsize`, where N is the \"length\" of the object.  The value of N is "
"typically stored in the instance's :c:member:`~PyVarObject.ob_size` field.  "
"There are exceptions:  for example, ints use a negative :c:member:"
"`~PyVarObject.ob_size` to indicate a negative number, and N is "
"``abs(ob_size)`` there.  Also, the presence of an :c:member:`~PyVarObject."
"ob_size` field in the instance layout doesn't mean that the instance "
"structure is variable-length (for example, the structure for the list type "
"has fixed-length instances, yet those instances have a meaningful :c:member:"
"`~PyVarObject.ob_size` field)."
msgstr ""
"Для типа с экземплярами переменной длины экземпляры должны иметь поле :c:"
"member:`~PyVarObject.ob_size`, а размер экземпляра равен :c:member:"
"`~PyTypeObject.tp_basicsize` плюс N раз :c:member :`~PyTypeObject."
"tp_itemsize`, где N — «длина» объекта. Значение N обычно хранится в поле :c:"
"member:`~PyVarObject.ob_size` экземпляра. Есть исключения: например, ints "
"используют отрицательное значение :c:member:`~PyVarObject.ob_size` для "
"обозначения отрицательного числа, а N там равно ``abs(ob_size)``. Кроме "
"того, наличие поля :c:member:`~PyVarObject.ob_size` в макете экземпляра не "
"означает, что структура экземпляра имеет переменную длину (например, "
"структура для типа списка имеет экземпляры фиксированной длины, тем не "
"менее, эти экземпляры имеют значимое поле :c:member:`~PyVarObject.ob_size`)."

#: ../../c-api/typeobj.rst:630
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the  :c:member:"
"`~PyObject._ob_prev` and :c:member:`~PyObject._ob_next` fields if they are "
"present.  This means that the only correct way to get an initializer for "
"the :c:member:`~PyTypeObject.tp_basicsize` is to use the ``sizeof`` operator "
"on the struct used to declare the instance layout. The basic size does not "
"include the GC header size."
msgstr ""
"Базовый размер включает поля экземпляра, объявленные макросом :c:macro:"
"`PyObject_HEAD` или :c:macro:`PyObject_VAR_HEAD` (в зависимости от того, "
"какой из них используется для объявления структуры экземпляра), а это, в "
"свою очередь, включает :c:member Поля :`~PyObject._ob_prev` и :c:member:"
"`~PyObject._ob_next`, если они присутствуют. Это означает, что единственный "
"правильный способ получить инициализатор для :c:member:`~PyTypeObject."
"tp_basicsize` — это использовать оператор ``sizeof`` в структуре, "
"используемой для объявления макета экземпляра. Базовый размер не включает "
"размер заголовка GC."

#: ../../c-api/typeobj.rst:638
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :c:member:"
"`~PyTypeObject.tp_basicsize`.  Example: suppose a type implements an array "
"of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is ``sizeof(double)``. "
"It is the programmer's responsibility that :c:member:`~PyTypeObject."
"tp_basicsize` is a multiple of ``sizeof(double)`` (assuming this is the "
"alignment requirement for ``double``)."
msgstr ""
"Примечание о выравнивании: если элементы переменных требуют определенного "
"выравнивания, об этом следует позаботиться с помощью значения :c:member:"
"`~PyTypeObject.tp_basicsize`. Пример: предположим, что тип реализует массив "
"double. :c:member:`~PyTypeObject.tp_itemsize` имеет ``sizeof(double)``. "
"Программист несет ответственность за то, чтобы :c:member:`~PyTypeObject."
"tp_basicsize` был кратен ``sizeof(double)`` (при условии, что это требование "
"выравнивания для ``double``)."

#: ../../c-api/typeobj.rst:645
msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr ""
"Для любого типа с экземплярами переменной длины это поле не должно быть NULL."

#: ../../c-api/typeobj.rst:649
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"Эти поля наследуются подтипами отдельно. Если базовый тип имеет ненулевое "
"значение :c:member:`~PyTypeObject.tp_itemsize`, обычно небезопасно "
"устанавливать для :c:member:`~PyTypeObject.tp_itemsize` другое ненулевое "
"значение в подтипе ( хотя это зависит от реализации базового типа)."

#: ../../c-api/typeobj.rst:657
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"Указатель на функцию деструктора экземпляра. Эта функция должна быть "
"определена, если только тип не гарантирует, что ее экземпляры никогда не "
"будут освобождены (как в случае с синглтонами None и Ellipsis). Сигнатура "
"функции::"

#: ../../c-api/typeobj.rst:663
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"call the type's :c:member:`~PyTypeObject.tp_free` function.  If the type is "
"not subtypable (doesn't have the :c:macro:`Py_TPFLAGS_BASETYPE` flag bit "
"set), it is permissible to call the object deallocator directly instead of "
"via :c:member:`~PyTypeObject.tp_free`.  The object deallocator should be the "
"one used to allocate the instance; this is normally :c:func:`PyObject_Del` "
"if the instance was allocated using :c:macro:`PyObject_New` or :c:macro:"
"`PyObject_NewVar`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"Функция деструктора вызывается макросами :c:func:`Py_DECREF` и :c:func:"
"`Py_XDECREF`, когда новый счетчик ссылок равен нулю. На данный момент "
"экземпляр все еще существует, но ссылок на него нет. Функция деструктора "
"должна освободить все ссылки, которыми владеет экземпляр, освободить все "
"буферы памяти, принадлежащие экземпляру (используя функцию освобождения, "
"соответствующую функции выделения, используемой для выделения буфера), и "
"вызвать :c:member:`~PyTypeObject типа. tp_free` функция. Если тип не "
"является подтипируемым (не имеет установленного бита флага :c:macro:"
"`Py_TPFLAGS_BASETYPE`), допустимо вызвать механизм освобождения объектов "
"напрямую, а не через :c:member:`~PyTypeObject.tp_free`. Освободитель объекта "
"должен использоваться для выделения экземпляра; обычно это :c:func:"
"`PyObject_Del`, если экземпляр был выделен с использованием :c:macro:"
"`PyObject_New` или :c:macro:`PyObject_NewVar`, или :c:func:"
"`PyObject_GC_Del`, если экземпляр был выделен с использованием :c:macro:"
"`PyObject_GC_New` или :c:macro:`PyObject_GC_NewVar`."

#: ../../c-api/typeobj.rst:678
msgid ""
"If the type supports garbage collection (has the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit set), the destructor should call :c:func:"
"`PyObject_GC_UnTrack` before clearing any member fields."
msgstr ""
"Если тип поддерживает сбор мусора (у него установлен бит флага :c:macro:"
"`Py_TPFLAGS_HAVE_GC`), деструктор должен вызвать :c:func:"
"`PyObject_GC_UnTrack` перед очисткой любых полей-членов."

#: ../../c-api/typeobj.rst:690
msgid ""
"Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via :c:"
"func:`Py_DECREF`)  after calling the type deallocator. In order to avoid "
"dangling pointers, the recommended way to achieve this is:"
msgstr ""
"Наконец, если тип выделен в куче (:c:macro:`Py_TPFLAGS_HEAPTYPE`), механизм "
"освобождения должен освободить принадлежащую ему ссылку на свой объект типа "
"(через :c:func:`Py_DECREF`) после вызова механизма освобождения типа. Чтобы "
"избежать висячих указателей, рекомендуемый способ добиться этого:"

#: ../../c-api/typeobj.rst:713
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Необязательное смещение для функции для каждого экземпляра, которое "
"реализует вызов объекта с использованием протокола :ref:`vectorcall "
"<vectorcall>`, более эффективной альтернативы более простому :c:member:"
"`~PyTypeObject.tp_call`."

#: ../../c-api/typeobj.rst:718
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Это поле используется только в том случае, если установлен флаг :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL`. Если да, то это должно быть положительное "
"целое число, содержащее смещение в экземпляре указателя :c:type:"
"`vectorcallfunc`."

#: ../../c-api/typeobj.rst:722
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Указатель *vectorcallfunc* может иметь значение NULL, и в этом случае "
"экземпляр ведет себя так, как если бы :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"не был установлен: вызов экземпляра возвращается к :c:member:`~PyTypeObject."
"tp_call` ."

#: ../../c-api/typeobj.rst:726
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Любой класс, который устанавливает ``Py_TPFLAGS_HAVE_VECTORCALL``, должен "
"также установить :c:member:`~PyTypeObject.tp_call` и убедиться, что его "
"поведение соответствует функции *vectorcallfunc*. Это можно сделать, "
"установив для *tp_call* значение :c:func:`PyVectorcall_Call`."

#: ../../c-api/typeobj.rst:733
msgid ""
"It is not recommended for :ref:`mutable heap types <heap-types>` to "
"implement the vectorcall protocol. When a user sets :attr:`__call__` in "
"Python code, only *tp_call* is updated, likely making it inconsistent with "
"the vectorcall function."
msgstr ""

#: ../../c-api/typeobj.rst:740
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"До версии 3.8 этот слот назывался ``tp_print``. В Python 2.x он "
"использовался для печати в файл. В Python 3.0–3.7 он не использовался."

#: ../../c-api/typeobj.rst:746
msgid ""
"This field is always inherited. However, the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not, then "
"the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:func:"
"`PyVectorcall_Call` is explicitly called. This is in particular the case for "
"types without the :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set (including "
"subclasses defined in Python)."
msgstr ""

#: ../../c-api/typeobj.rst:758
msgid "An optional pointer to the get-attribute-string function."
msgstr "Необязательный указатель на функцию get-attribute-string."

#: ../../c-api/typeobj.rst:760
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Это поле устарело. Когда он определен, он должен указывать на функцию, "
"которая действует так же, как функция :c:member:`~PyTypeObject.tp_getattro`, "
"но принимает строку C вместо строкового объекта Python для указания имени "
"атрибута."

#: ../../c-api/typeobj.rst:766 ../../c-api/typeobj.rst:958
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"
msgstr ""
"Группа: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"

#: ../../c-api/typeobj.rst:768
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_getattro`: подтип наследует как :c:member:`~PyTypeObject.tp_getattr`, так "
"и :c:member:`~PyTypeObject.tp_getattro` от своей базы type, когда оба "
"подтипа :c:member:`~PyTypeObject.tp_getattr` и :c:member:`~PyTypeObject."
"tp_getattr` имеют значение ``NULL``."

#: ../../c-api/typeobj.rst:775 ../../c-api/typeobj.rst:971
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "Необязательный указатель на функцию установки и удаления атрибутов."

#: ../../c-api/typeobj.rst:777
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Это поле устарело. Когда он определен, он должен указывать на функцию, "
"которая действует так же, как функция :c:member:`~PyTypeObject.tp_setattro`, "
"но принимает строку C вместо строкового объекта Python для указания имени "
"атрибута."

#: ../../c-api/typeobj.rst:783 ../../c-api/typeobj.rst:984
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"
msgstr ""
"Группа: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"

#: ../../c-api/typeobj.rst:785
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_setattro`: подтип наследует как :c:member:`~PyTypeObject.tp_setattr`, так "
"и :c:member:`~PyTypeObject.tp_setattro` от своей базы type, когда оба "
"подтипа :c:member:`~PyTypeObject.tp_setattr` и :c:member:`~PyTypeObject."
"tp_setattro` имеют значение ``NULL``."

#: ../../c-api/typeobj.rst:792
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Указатель на дополнительную структуру, содержащую поля, относящиеся только к "
"объектам, которые реализуют протоколы :term:`awaitable` и :term:`асинхронный "
"итератор` на уровне C. Подробности смотрите в :ref:`async-structs`."

#: ../../c-api/typeobj.rst:796
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Ранее известный как tp_compare и tp_reserved."

#: ../../c-api/typeobj.rst:801
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_async` не наследуется, но содержащиеся в "
"нем поля наследуются индивидуально."

#: ../../c-api/typeobj.rst:809
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"Необязательный указатель на функцию, реализующую встроенную функцию :func:"
"`repr`."

#: ../../c-api/typeobj.rst:812
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "Подпись такая же, как для :c:func:`PyObject_Repr`::"

#: ../../c-api/typeobj.rst:816
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"Функция должна возвращать строку или объект Unicode. В идеале эта функция "
"должна возвращать строку, которая при передаче в :func:`eval` при подходящей "
"среде возвращает объект с тем же значением. Если это невозможно, он должен "
"возвращать строку, начинающуюся с ``'<'`` и заканчивающуюся ``'>'``, из "
"которой можно определить тип и значение объекта."

#: ../../c-api/typeobj.rst:827 ../../c-api/typeobj.rst:939
#: ../../c-api/typeobj.rst:964 ../../c-api/typeobj.rst:990
#: ../../c-api/typeobj.rst:1032 ../../c-api/typeobj.rst:1497
#: ../../c-api/typeobj.rst:1649 ../../c-api/typeobj.rst:1670
#: ../../c-api/typeobj.rst:1761 ../../c-api/typeobj.rst:1797
#: ../../c-api/typeobj.rst:1815 ../../c-api/typeobj.rst:1857
#: ../../c-api/typeobj.rst:1878 ../../c-api/typeobj.rst:1909
msgid "**Default:**"
msgstr "**Значение по умолчанию:**"

#: ../../c-api/typeobj.rst:829
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Если это поле не задано, строка вида ``< %s возражать против %p >`` "
"возвращается, где `` %s `` заменяется именем типа, а `` %p `` по адресу "
"памяти объекта."

#: ../../c-api/typeobj.rst:836
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Указатель на дополнительную структуру, содержащую поля, относящиеся только к "
"объектам, реализующим числовой протокол. Эти поля описаны в :ref:`number-"
"structs`."

#: ../../c-api/typeobj.rst:842
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_number` не наследуется, но содержащиеся "
"в нем поля наследуются индивидуально."

#: ../../c-api/typeobj.rst:848
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Указатель на дополнительную структуру, содержащую поля, относящиеся только к "
"объектам, реализующим протокол последовательности. Эти поля описаны в :ref:"
"`sequence-structs`."

#: ../../c-api/typeobj.rst:854
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_sequence` не наследуется, но "
"содержащиеся в нем поля наследуются индивидуально."

#: ../../c-api/typeobj.rst:860
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Указатель на дополнительную структуру, содержащую поля, относящиеся только к "
"объектам, реализующим протокол сопоставления. Эти поля описаны в :ref:"
"`mapping-structs`."

#: ../../c-api/typeobj.rst:866
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_mapping` не наследуется, но содержащиеся "
"в нем поля наследуются индивидуально."

#: ../../c-api/typeobj.rst:874
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"Необязательный указатель на функцию, реализующую встроенную функцию :func:"
"`hash`."

#: ../../c-api/typeobj.rst:877
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "Подпись такая же, как для :c:func:`PyObject_Hash`::"

#: ../../c-api/typeobj.rst:881
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"Значение ``-1`` не должно возвращаться как обычное возвращаемое значение; "
"когда во время вычисления хэш-значения возникает ошибка, функция должна "
"установить исключение и вернуть ``-1``."

#: ../../c-api/typeobj.rst:885
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises :exc:"
"`TypeError`. This is the same as setting it to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Если это поле не установлено (*и* :c:member:`~PyTypeObject.tp_richcompare` "
"не установлено), попытка получить хэш объекта вызывает :exc:`TypeError`. Это "
"то же самое, что установить для него значение :c:func:"
"`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:889
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Этому полю можно явно установить значение :c:func:"
"`PyObject_HashNotImplemented`, чтобы заблокировать наследование хеш-метода "
"от родительского типа. Это интерпретируется как эквивалент ``__hash__ = "
"None`` на уровне Python, в результате чего ``isinstance(o, Collections."
"Hashable)`` правильно возвращает ``False``. Обратите внимание, что верно и "
"обратное: установка ``__hash__ = None`` в классе на уровне Python приведет к "
"тому, что слот ``tp_hash`` будет установлен в :c:func:"
"`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:899 ../../c-api/typeobj.rst:1490
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"
msgstr ""
"Группа: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"

#: ../../c-api/typeobj.rst:901
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_richcompare`: подтип наследует оба :c:member:`~PyTypeObject."
"tp_richcompare` и :c:member:`~PyTypeObject.tp_hash`, когда оба подтипа :c:"
"member:`~PyTypeObject.tp_richcompare` и :c:member:`~PyTypeObject.tp_hash` "
"имеют значение ``NULL``."

#: ../../c-api/typeobj.rst:909
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Необязательный указатель на функцию, реализующую вызов объекта. Это значение "
"должно быть NULL, если объект не может быть вызван. Сигнатура такая же, как "
"для :c:func:`PyObject_Call`::"

#: ../../c-api/typeobj.rst:922
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"Необязательный указатель на функцию, реализующую встроенную операцию :func:"
"`str`. (Обратите внимание, что :class:`str` теперь является типом, и :func:"
"`str` вызывает конструктор для этого типа. Этот конструктор вызывает :c:func:"
"`PyObject_Str` для выполнения фактической работы, а :c:func :`PyObject_Str` "
"вызовет этот обработчик.)"

#: ../../c-api/typeobj.rst:927
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "Сигнатура такая же, как для :c:func:`PyObject_Str`::"

#: ../../c-api/typeobj.rst:931
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"Функция должна возвращать строку или объект Unicode. Это должно быть "
"«дружественное» строковое представление объекта, поскольку именно оно будет "
"использоваться, среди прочего, функцией :func:`print`."

#: ../../c-api/typeobj.rst:941
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Если это поле не установлено, вызывается :c:func:`PyObject_Repr` для "
"возврата строкового представления."

#: ../../c-api/typeobj.rst:947
msgid "An optional pointer to the get-attribute function."
msgstr "Необязательный указатель на функцию get-attribute."

#: ../../c-api/typeobj.rst:949
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "Подпись такая же, как для :c:func:`PyObject_GetAttr`::"

#: ../../c-api/typeobj.rst:953
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"Обычно для этого поля удобно установить значение :c:func:"
"`PyObject_GenericGetAttr`, которое реализует обычный способ поиска атрибутов "
"объекта."

#: ../../c-api/typeobj.rst:960
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_getattr`: подтип наследует как :c:member:`~PyTypeObject.tp_getattr`, так "
"и :c:member:`~PyTypeObject.tp_getattr` от своей базы. type, когда оба "
"подтипа :c:member:`~PyTypeObject.tp_getattr` и :c:member:`~PyTypeObject."
"tp_getattr` имеют значение ``NULL``."

#: ../../c-api/typeobj.rst:966
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` использует :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:973
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "Подпись такая же, как для :c:func:`PyObject_SetAttr`::"

#: ../../c-api/typeobj.rst:977
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Кроме того, должна поддерживаться установка *value* в ``NULL`` для удаления "
"атрибута. Обычно для этого поля удобно установить значение :c:func:"
"`PyObject_GenericSetAttr`, которое реализует обычный способ установки "
"атрибутов объекта."

#: ../../c-api/typeobj.rst:986
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_setattr`: подтип наследует как :c:member:`~PyTypeObject.tp_setattr`, так "
"и :c:member:`~PyTypeObject.tp_setattr` от своей базы type, когда оба "
"подтипа :c:member:`~PyTypeObject.tp_setattr` и :c:member:`~PyTypeObject."
"tp_setattro` имеют значение ``NULL``."

#: ../../c-api/typeobj.rst:992
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ""
":c:data:`PyBaseObject_Type` использует :c:func:`PyObject_GenericSetAttr`."

#: ../../c-api/typeobj.rst:997
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Указатель на дополнительную структуру, содержащую поля, относящиеся только к "
"объектам, реализующим интерфейс буфера. Эти поля описаны в :ref:`buffer-"
"structs`."

#: ../../c-api/typeobj.rst:1003
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"Поле :c:member:`~PyTypeObject.tp_as_buffer` не наследуется, но содержащиеся "
"в нем поля наследуются индивидуально."

#: ../../c-api/typeobj.rst:1009
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Это поле представляет собой битовую маску различных флагов. Некоторые флаги "
"указывают на вариант семантики для определенных ситуаций; другие "
"используются для указания того, что определенные поля в объекте типа (или в "
"структурах расширения, на которые ссылаются через :c:member:`~PyTypeObject."
"tp_as_number`, :c:member:`~PyTypeObject.tp_as_sequence`, :c:member:` "
"~PyTypeObject.tp_as_mapping` и :c:member:`~PyTypeObject.tp_as_buffer`), "
"которые исторически не всегда присутствовали, являются действительными; если "
"такой бит флага сброшен, поля типа, которые он защищает, не должны быть "
"доступны и вместо этого должны считаться имеющими нулевое значение или "
"значение ``NULL``."

#: ../../c-api/typeobj.rst:1019
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""

#: ../../c-api/typeobj.rst:1034
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."

#: ../../c-api/typeobj.rst:1037
msgid "**Bit Masks:**"
msgstr "**Маски битов:**"

#: ../../c-api/typeobj.rst:1041
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"В настоящее время определены следующие битовые маски; их можно объединить с "
"помощью операции OR, используя оператор ``|``, чтобы сформировать значение "
"поля :c:member:`~PyTypeObject.tp_flags`. Макрос :c:func:`PyType_HasFeature` "
"принимает тип и значение флагов *tp* и *f* и проверяет, не равно ли ``tp-"
">tp_flags & f`` нулю."

#: ../../c-api/typeobj.rst:1048
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :c:member:`~PyObject.ob_type` field of its instances is considered "
"a reference to the type, and the type object is INCREF'ed when a new "
"instance is created, and DECREF'ed when an instance is destroyed (this does "
"not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed)."
msgstr ""

#: ../../c-api/typeobj.rst:1058 ../../c-api/typeobj.rst:1069
#: ../../c-api/typeobj.rst:1079 ../../c-api/typeobj.rst:1089
#: ../../c-api/typeobj.rst:1121
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1063
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Этот бит устанавливается, когда тип может использоваться в качестве базового "
"типа для другого типа. Если этот бит сброшен, тип не может быть подтипирован "
"(аналогично «конечному» классу в Java)."

#: ../../c-api/typeobj.rst:1074
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Этот бит устанавливается, когда объект типа был полностью инициализирован с "
"помощью :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1084
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Этот бит установлен, пока :c:func:`PyType_Ready` находится в процессе "
"инициализации объекта типа."

#: ../../c-api/typeobj.rst:1094
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:macro:`PyObject_GC_New` and "
"destroyed using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject."
"tp_clear` are present in the type object."
msgstr ""
"Этот бит устанавливается, когда объект поддерживает сборку мусора. Если этот "
"бит установлен, экземпляры должны быть созданы с помощью :c:macro:"
"`PyObject_GC_New` и уничтожены с помощью :c:func:`PyObject_GC_Del`. "
"Дополнительная информация в разделе:ref:`support-cycle-detection`. Этот бит "
"также подразумевает, что поля, связанные со сборщиком мусора, :c:member:"
"`~PyTypeObject.tp_traverse` и :c:member:`~PyTypeObject.tp_clear` "
"присутствуют в объекте типа."

#: ../../c-api/typeobj.rst:1103 ../../c-api/typeobj.rst:1361
#: ../../c-api/typeobj.rst:1429
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:1105
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."
msgstr ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."

#: ../../c-api/typeobj.rst:1115
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Это битовая маска всех битов, которые относятся к существованию определенных "
"полей в объекте типа и его структурах расширения. В настоящее время он "
"включает в себя следующие биты: :c:macro:"
"`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

#: ../../c-api/typeobj.rst:1126
msgid "This bit indicates that objects behave like unbound methods."
msgstr "Этот бит указывает, что объекты ведут себя как несвязанные методы."

#: ../../c-api/typeobj.rst:1128
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Если этот флаг установлен для ``type(meth)``, то:"

#: ../../c-api/typeobj.rst:1130
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (где ``obj`` не None) должен быть "
"эквивалентен ``meth(obj, *args, **kwds)``."

#: ../../c-api/typeobj.rst:1133
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` должен быть эквивалентен "
"``meth(*args, **kwds)``."

#: ../../c-api/typeobj.rst:1136
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Этот флаг позволяет оптимизировать типичные вызовы методов, таких как obj."
"meth(): он позволяет избежать создания временного объекта «связанного "
"метода» для obj.meth."

#: ../../c-api/typeobj.rst:1144
msgid ""
"This flag is never inherited by types without the :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is inherited "
"whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"Этот флаг никогда не наследуется типами без установленного флага :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE`. Для типов расширения он наследуется всякий раз, "
"когда наследуется :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:1161
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Эти флаги используются такими функциями, как :c:func:`PyLong_Check`, чтобы "
"быстро определить, является ли тип подклассом встроенного типа; такие "
"конкретные проверки выполняются быстрее, чем общие проверки, например :c:"
"func:`PyObject_IsInstance`. Пользовательские типы, которые наследуются от "
"встроенных модулей, должны иметь соответствующий параметр :c:member:"
"`~PyTypeObject.tp_flags`, иначе код, который взаимодействует с такими "
"типами, будет вести себя по-разному в зависимости от того, какой тип "
"проверки используется."

#: ../../c-api/typeobj.rst:1172
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Этот бит устанавливается, когда в структуре типа присутствует слот :c:member:"
"`~PyTypeObject.tp_finalize`."

#: ../../c-api/typeobj.rst:1177
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Этот флаг больше не нужен, поскольку интерпретатор предполагает, что слот :c:"
"member:`~PyTypeObject.tp_finalize` всегда присутствует в структуре типа."

#: ../../c-api/typeobj.rst:1185
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Этот бит устанавливается, когда класс реализует протокол векторного вызова "
"<vectorcall>`. Подробности смотрите в :c:member:`~PyTypeObject."
"tp_vectorcall_offset`."

#: ../../c-api/typeobj.rst:1191
msgid ""
"This bit is inherited for types with the :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` "
"flag set, if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr ""

#: ../../c-api/typeobj.rst:1199
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Этот бит установлен для объектов типа, которые являются неизменяемыми: "
"атрибуты типа не могут быть установлены или удалены."

#: ../../c-api/typeobj.rst:1201
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` автоматически применяет этот флаг к :ref:`статическим "
"типам <static-types>`."

#: ../../c-api/typeobj.rst:1206
msgid "This flag is not inherited."
msgstr "Этот флаг не наследуется."

#: ../../c-api/typeobj.rst:1212
msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"Запретите создание экземпляров типа: установите для :c:member:`~PyTypeObject."
"tp_new` значение NULL и не создавайте ключ ``__new__`` в словаре типов."

#: ../../c-api/typeobj.rst:1216
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"Флаг должен быть установлен до создания типа, а не после. Например, его "
"необходимо установить до вызова :c:func:`PyType_Ready` для типа."

#: ../../c-api/typeobj.rst:1219
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"Флаг устанавливается автоматически для :ref:`статических типов <static-"
"types>`, если :c:member:`~PyTypeObject.tp_base` имеет значение NULL или "
"``&PyBaseObject_Type`` и :c:member:`~PyTypeObject.tp_new` НУЛЬ."

#: ../../c-api/typeobj.rst:1225
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"Этот флаг не наследуется. Однако подклассы не будут создавать экземпляры, "
"если они не предоставят не NULL :c:member:`~PyTypeObject.tp_new` (что "
"возможно только через C API)."

#: ../../c-api/typeobj.rst:1232
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"Чтобы запретить создание экземпляра класса напрямую, но разрешить создание "
"экземпляров его подклассов (например, для :term:`абстрактного базового "
"класса`), не используйте этот флаг. Вместо этого сделайте :c:member:"
"`~PyTypeObject.tp_new` успешным только для подклассов."

#: ../../c-api/typeobj.rst:1243
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Этот бит указывает, что экземпляры класса могут соответствовать шаблонам "
"отображения при использовании в качестве субъекта блока :keyword:`match`. Он "
"автоматически устанавливается при регистрации или создании подкласса :class:"
"`collections.abc.Mapping` и сбрасывается при регистрации :class:`collections."
"abc.Sequence`."

#: ../../c-api/typeobj.rst:1250 ../../c-api/typeobj.rst:1272
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":c:macro:`Py_TPFLAGS_MAPPING` и :c:macro:`Py_TPFLAGS_SEQUENCE` являются "
"взаимоисключающими; одновременное включение обоих флагов является ошибкой."

#: ../../c-api/typeobj.rst:1255
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Этот флаг наследуется типами, которые еще не установили :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."

#: ../../c-api/typeobj.rst:1258 ../../c-api/typeobj.rst:1280
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Соответствие структурному шаблону: Спецификация"

#: ../../c-api/typeobj.rst:1265
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Этот бит указывает, что экземпляры класса могут соответствовать шаблонам "
"последовательностей при использовании в качестве субъекта блока :keyword:"
"`match`. Он автоматически устанавливается при регистрации или создании "
"подкласса :class:`collections.abc.Sequence` и сбрасывается при регистрации :"
"class:`collections.abc.Mapping`."

#: ../../c-api/typeobj.rst:1277
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Этот флаг наследуется типами, которые еще не установили :c:macro:"
"`Py_TPFLAGS_MAPPING`."

#: ../../c-api/typeobj.rst:1287
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""

#: ../../c-api/typeobj.rst:1293
msgid "This field is *not* inherited by subtypes."
msgstr "Это поле *не* наследуется подтипами."

#: ../../c-api/typeobj.rst:1298
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Необязательный указатель на функцию обхода сборщика мусора. Используется "
"только в том случае, если установлен бит флага :c:macro:"
"`Py_TPFLAGS_HAVE_GC`. Подпись такая::"

#: ../../c-api/typeobj.rst:1303 ../../c-api/typeobj.rst:1424
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Дополнительную информацию о схеме сборки мусора Python можно найти в разделе:"
"ref:`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1306
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`!local_traverse` from the :mod:"
"`!_thread` extension module::"
msgstr ""
"Указатель :c:member:`~PyTypeObject.tp_traverse` используется сборщиком "
"мусора для обнаружения ссылочных циклов. Типичная реализация функции :c:"
"member:`~PyTypeObject.tp_traverse` просто вызывает :c:func:`Py_VISIT` для "
"каждого из членов экземпляра, которые являются объектами Python, "
"принадлежащими экземпляру. Например, это функция :c:func:`!local_traverse` "
"из модуля расширения :mod:`!_thread`::"

#: ../../c-api/typeobj.rst:1321
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Обратите внимание, что :c:func:`Py_VISIT` вызывается только для тех членов, "
"которые могут участвовать в ссылочных циклах. Хотя существует также элемент "
"self->key, он может быть только NULL или строкой Python и, следовательно, не "
"может быть частью ссылочного цикла."

#: ../../c-api/typeobj.rst:1325
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"С другой стороны, даже если вы знаете, что член никогда не может быть частью "
"цикла, в качестве вспомогательного средства отладки вы все равно можете "
"посетить его, просто чтобы функция модуля :mod:`gc` :func:`~gc."
"get_referents` включит его."

#: ../../c-api/typeobj.rst:1330
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"При реализации :c:member:`~PyTypeObject.tp_traverse` необходимо посещать "
"только те члены, которыми *владеет* экземпляр (благодаря наличию :term:"
"`strong ссылок <strong reference>` на них). Например, если объект "
"поддерживает слабые ссылки через слот :c:member:`~PyTypeObject.tp_weaklist`, "
"указатель, поддерживающий связанный список (на что указывает *tp_weaklist*), "
"не должен **не** посещаться, как это делает экземпляр не владеет напрямую "
"слабыми ссылками на себя (список слабых ссылок предназначен для поддержки "
"механизма слабых ссылок, но экземпляр не имеет сильной ссылки на элементы "
"внутри него, поскольку их можно удалить, даже если экземпляр все еще жив)."

#: ../../c-api/typeobj.rst:1341
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Обратите внимание, что :c:func:`Py_VISIT` требует, чтобы параметры *visit* и "
"*arg* :c:func:`local_traverse` имели эти конкретные имена; не называйте их "
"просто так."

#: ../../c-api/typeobj.rst:1345
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Экземпляры :ref:`типов, выделяемых в куче <heap-types>` содержат ссылку на "
"свой тип. Поэтому их функция обхода должна либо посетить :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, либо делегировать эту ответственность, вызвав "
"``tp_traverse`` другого типа, выделяемого в куче (например, суперкласса, "
"выделенного в куче). В противном случае объект типа не может быть подвергнут "
"сборке мусора."

#: ../../c-api/typeobj.rst:1354
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Ожидается, что типы, выделенные в куче, будут посещать Py_TYPE(self) в "
"tp_traverse. В более ранних версиях Python из-за `ошибки 40217 <https://bugs."
"python.org/issue40217>`_ это может привести к сбоям в подклассах."

#: ../../c-api/typeobj.rst:1363
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject.tp_clear` и "
"битом флага :c:macro:`Py_TPFLAGS_HAVE_GC`: бит флага, :c:member:"
"`~PyTypeObject.tp_traverse` и : c:member:`~PyTypeObject.tp_clear` все "
"наследуются от базового типа, если все они равны нулю в подтипе."

#: ../../c-api/typeobj.rst:1371
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Необязательный указатель на понятную функцию сборщика мусора. Используется "
"только в том случае, если установлен бит флага :c:macro:"
"`Py_TPFLAGS_HAVE_GC`. Подпись такая::"

#: ../../c-api/typeobj.rst:1376
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types must be sufficient to break any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Функция-член :c:member:`~PyTypeObject.tp_clear` используется для разрыва "
"ссылочных циклов в циклическом мусоре, обнаруженном сборщиком мусора. В "
"совокупности все функции :c:member:`~PyTypeObject.tp_clear` в системе должны "
"объединиться, чтобы разорвать все циклы ссылок. Это тонкий момент, и если у "
"вас есть какие-либо сомнения, предоставьте функцию :c:member:`~PyTypeObject."
"tp_clear`. Например, тип кортежа не реализует функцию :c:member:"
"`~PyTypeObject.tp_clear`, поскольку можно доказать, что ни один ссылочный "
"цикл не может состоять полностью из кортежей. Поэтому функций :c:member:"
"`~PyTypeObject.tp_clear` других типов должно быть достаточно, чтобы "
"разорвать любой цикл, содержащий кортеж. Это не сразу очевидно, и редко "
"бывает веская причина избегать реализации :c:member:`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1386
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Реализации :c:member:`~PyTypeObject.tp_clear` должны удалять ссылки "
"экземпляра на те из его членов, которые могут быть объектами Python, и "
"устанавливать указатели на эти члены в значение ``NULL``, как в следующем "
"примере:"

#: ../../c-api/typeobj.rst:1400
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via :"
"c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"Следует использовать макрос :c:func:`Py_CLEAR`, поскольку очистка ссылок "
"является деликатной задачей: ссылка на содержащийся объект не должна "
"освобождаться (через :c:func:`Py_DECREF`) до тех пор, пока указатель на "
"содержащийся объект не будет освобожден. установлен в ``NULL``. Это связано "
"с тем, что освобождение ссылки может привести к тому, что содержащийся "
"объект станет мусором, что вызовет цепочку действий по восстановлению, "
"которая может включать вызов произвольного кода Python (из-за финализаторов "
"или обратных вызовов слабых ссылок, связанных с содержащимся объектом). Если "
"такой код может снова ссылаться на *self*, важно, чтобы указатель на "
"содержащийся объект в этот момент был равен NULL, чтобы *self* знал, что "
"содержащийся объект больше нельзя использовать. Макрос :c:func:`Py_CLEAR` "
"выполняет операции в безопасном порядке."

#: ../../c-api/typeobj.rst:1412
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"Обратите внимание, что :c:member:`~PyTypeObject.tp_clear` не *всегда* "
"вызывается перед освобождением экземпляра. Например, когда подсчета ссылок "
"достаточно, чтобы определить, что объект больше не используется, циклический "
"сборщик мусора не задействуется и :c:member:`~PyTypeObject.tp_dealloc` "
"вызывается напрямую."

#: ../../c-api/typeobj.rst:1418
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Поскольку целью функций :c:member:`~PyTypeObject.tp_clear` является разрыв "
"ссылочных циклов, нет необходимости очищать содержащиеся в них объекты, "
"такие как строки Python или целые числа Python, которые не могут участвовать "
"в ссылочных циклах. С другой стороны, может быть удобно очистить все "
"содержащиеся объекты Python и написать функцию :c:member:`~PyTypeObject."
"tp_dealloc` для вызова :c:member:`~PyTypeObject.tp_clear`."

#: ../../c-api/typeobj.rst:1431
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :"
"c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject."
"tp_traverse` и битом флага :c:macro:`Py_TPFLAGS_HAVE_GC`: бит флага, :c:"
"member:`~PyTypeObject.tp_traverse` и : c:member:`~PyTypeObject.tp_clear` все "
"наследуются от базового типа, если все они равны нулю в подтипе."

#: ../../c-api/typeobj.rst:1439
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Необязательный указатель на расширенную функцию сравнения, подпись которой::"

#: ../../c-api/typeobj.rst:1443
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Первый параметр гарантированно будет экземпляром типа, определенного :c:type:"
"`PyTypeObject`."

#: ../../c-api/typeobj.rst:1446
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"Функция должна возвращать результат сравнения (обычно Py_True или Py_False). "
"Если сравнение не определено, оно должно вернуть Py_NotImplemented, если "
"произошла другая ошибка, оно должно вернуть NULL и установить условие "
"исключения."

#: ../../c-api/typeobj.rst:1451
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Следующие константы определены для использования в качестве третьего "
"аргумента для :c:member:`~PyTypeObject.tp_richcompare` и для :c:func:"
"`PyObject_RichCompare`:"

#: ../../c-api/typeobj.rst:1457
msgid "Constant"
msgstr "Константа"

#: ../../c-api/typeobj.rst:1457
msgid "Comparison"
msgstr "Сравнение"

#: ../../c-api/typeobj.rst:1459
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1461
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1463
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1465
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1467
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1469
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1472
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"Следующий макрос определен для упрощения написания расширенных функций "
"сравнения:"

#: ../../c-api/typeobj.rst:1476
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Возвращает Py_True или Py_False из функции, в зависимости от результата "
"сравнения. VAL_A и VAL_B должны упорядочиваться с помощью операторов "
"сравнения C (например, они могут быть целыми числами C или числами с "
"плавающей запятой). Третий аргумент указывает запрошенную операцию, как и в "
"случае с :c:func:`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1482
msgid "The returned value is a new :term:`strong reference`."
msgstr "Возвращаемое значение представляет собой новую :term:`сильную ссылку`."

#: ../../c-api/typeobj.rst:1484
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "В случае ошибки устанавливает исключение и возвращает NULL из функции."

#: ../../c-api/typeobj.rst:1492
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Это поле наследуется подтипами вместе с :c:member:`~PyTypeObject.tp_hash`: "
"подтип наследует :c:member:`~PyTypeObject.tp_richcompare` и :c:member:"
"`~PyTypeObject.tp_hash`, когда подтип: c:member:`~PyTypeObject."
"tp_richcompare` и :c:member:`~PyTypeObject.tp_hash` имеют значения ``NULL``."

#: ../../c-api/typeobj.rst:1499
msgid ""
":c:data:`PyBaseObject_Type` provides a :c:member:`~PyTypeObject."
"tp_richcompare` implementation, which may be inherited.  However, if only :c:"
"member:`~PyTypeObject.tp_hash` is defined, not even the inherited function "
"is used and instances of the type will not be able to participate in any "
"comparisons."
msgstr ""
":c:data:`PyBaseObject_Type` предоставляет реализацию :c:member:"
"`~PyTypeObject.tp_richcompare`, которая может передаваться по наследству. "
"Однако если определен только :c:member:`~PyTypeObject.tp_hash`, даже "
"унаследованная функция не используется и экземпляры типа не смогут "
"участвовать ни в каких сравнениях."

#: ../../c-api/typeobj.rst:1508
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Если экземпляры этого типа имеют слабую ссылку, это поле больше нуля и "
"содержит смещение в структуре экземпляра заголовка списка слабых ссылок "
"(игнорируя заголовок GC, если он присутствует); это смещение используется "
"функциями :c:func:`PyObject_ClearWeakRefs` и ``PyWeakref_*``. Структура "
"экземпляра должна включать поле типа :c:expr:`PyObject*`, которое "
"инициализируется значением ``NULL``."

#: ../../c-api/typeobj.rst:1515
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"Не путайте это поле с :c:member:`~PyTypeObject.tp_weaklist`; это заголовок "
"списка слабых ссылок на сам объект типа."

#: ../../c-api/typeobj.rst:1520
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Это поле наследуется подтипами, но см. правила, перечисленные ниже. Подтип "
"может переопределить это смещение; это означает, что подтип использует "
"другой заголовок списка слабых ссылок, чем базовый тип. Поскольку заголовок "
"списка всегда находится через :c:member:`~PyTypeObject.tp_weaklistoffset`, "
"это не должно быть проблемой."

#: ../../c-api/typeobj.rst:1525
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :c:member:`~PyTypeObject."
"tp_weaklistoffset` of that slot's offset."
msgstr ""

#: ../../c-api/typeobj.rst:1530
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :c:member:"
"`~PyTypeObject.tp_weaklistoffset`."
msgstr ""

#: ../../c-api/typeobj.rst:1535
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :c:member:`~PyTypeObject."
"tp_weaklistoffset` from its base type."
msgstr ""

#: ../../c-api/typeobj.rst:1542
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"Необязательный указатель на функцию, которая возвращает :term:`итератор` для "
"объекта. Ее наличие обычно сигнализирует о том, что экземпляры этого типа "
"являются :term:`iterable` (хотя последовательности могут быть итерируемыми и "
"без этой функции)."

#: ../../c-api/typeobj.rst:1546
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Эта функция имеет ту же сигнатуру, что и :c:func:`PyObject_GetIter`::"

#: ../../c-api/typeobj.rst:1557
msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"Необязательный указатель на функцию, которая возвращает следующий элемент в :"
"term:`итераторе`. Подпись такая::"

#: ../../c-api/typeobj.rst:1562
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"Когда итератор исчерпан, он должен вернуть NULL; исключение :exc:"
"`StopIteration` может быть установлено или не установлено. При возникновении "
"другой ошибки он также должен вернуть NULL. Его наличие сигнализирует о том, "
"что экземпляры этого типа являются итераторами."

#: ../../c-api/typeobj.rst:1567
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Типы итераторов также должны определять функцию :c:member:`~PyTypeObject."
"tp_iter`, и эта функция должна возвращать сам экземпляр итератора (а не "
"новый экземпляр итератора)."

#: ../../c-api/typeobj.rst:1571
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Эта функция имеет ту же сигнатуру, что и :c:func:`PyIter_Next`."

#: ../../c-api/typeobj.rst:1580
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Необязательный указатель на статический массив структур :c:type:"
"`PyMethodDef`, завершающийся ``NULL``, объявляющий обычные методы этого типа."

#: ../../c-api/typeobj.rst:1583
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Для каждой записи в массиве в словарь типа добавляется запись (см. :c:member:"
"`~PyTypeObject.tp_dict` ниже), содержащая дескриптор метода."

#: ../../c-api/typeobj.rst:1588
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Это поле не наследуется подтипами (методы наследуются через другой механизм)."

#: ../../c-api/typeobj.rst:1594
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"Необязательный указатель на статический массив структур :c:type:"
"`PyMemberDef`, завершающийся ``NULL``, объявляющий обычные элементы данных "
"(поля или слоты) экземпляров этого типа."

#: ../../c-api/typeobj.rst:1598
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Для каждой записи в массиве в словарь типа добавляется запись (см. :c:member:"
"`~PyTypeObject.tp_dict` ниже), содержащая дескриптор члена."

#: ../../c-api/typeobj.rst:1603
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Это поле не наследуется подтипами (члены наследуются с помощью другого "
"механизма)."

#: ../../c-api/typeobj.rst:1609
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"Необязательный указатель на статический массив структур :c:type:"
"`PyGetSetDef`, завершающийся ``NULL``, объявляющий вычисленные атрибуты "
"экземпляров этого типа."

#: ../../c-api/typeobj.rst:1612
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Для каждой записи в массиве в словарь типа добавляется запись (см. :c:member:"
"`~PyTypeObject.tp_dict` ниже), содержащая дескриптор getset."

#: ../../c-api/typeobj.rst:1617
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Это поле не наследуется подтипами (вычисляемые атрибуты наследуются с "
"помощью другого механизма)."

#: ../../c-api/typeobj.rst:1623
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Необязательный указатель на базовый тип, от которого наследуются свойства "
"типа. На этом уровне поддерживается только одиночное наследование; "
"множественное наследование требует динамического создания объекта типа путем "
"вызова метатипа."

#: ../../c-api/typeobj.rst:1631
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"Инициализация слота подчиняется правилам инициализации глобальных "
"переменных. C99 требует, чтобы инициализаторы были «константами адреса». "
"Обозначения функций, такие как :c:func:`PyType_GenericNew`, с неявным "
"преобразованием в указатель, являются действительными адресными константами "
"C99."

#: ../../c-api/typeobj.rst:1636
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"data:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"Однако унарный оператор «&», примененный к нестатической переменной, такой "
"как :c:data:`PyBaseObject_Type`, не требуется для создания адресной "
"константы. Компиляторы могут поддерживать это (gcc поддерживает), MSVC — "
"нет. Оба компилятора строго соответствуют стандартам в этом конкретном "
"поведении."

#: ../../c-api/typeobj.rst:1642
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"Следовательно, :c:member:`~PyTypeObject.tp_base` должен быть установлен в "
"функции инициализации модуля расширения."

#: ../../c-api/typeobj.rst:1647
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Это поле не наследуется подтипами (очевидно)."

#: ../../c-api/typeobj.rst:1651
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"По умолчанию это поле имеет значение ``&PyBaseObject_Type`` (который "
"программистам Python известен как тип :class:`object`)."

#: ../../c-api/typeobj.rst:1657
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "Словарь типов хранится здесь в :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1659
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`~object."
"__add__`)."
msgstr ""

#: ../../c-api/typeobj.rst:1667
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Это поле не наследуется подтипами (хотя определенные здесь атрибуты "
"наследуются с помощью другого механизма)."

#: ../../c-api/typeobj.rst:1672
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Если это поле равно NULL, :c:func:`PyType_Ready` назначит ему новый словарь."

#: ../../c-api/typeobj.rst:1677
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"Небезопасно использовать :c:func:`PyDict_SetItem` или иным образом изменять :"
"c:member:`~PyTypeObject.tp_dict` со словарем C-API."

#: ../../c-api/typeobj.rst:1683
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "Необязательный указатель на функцию «получения дескриптора»."

#: ../../c-api/typeobj.rst:1685 ../../c-api/typeobj.rst:1701
#: ../../c-api/typeobj.rst:1776 ../../c-api/typeobj.rst:1806
#: ../../c-api/typeobj.rst:1830
msgid "The function signature is::"
msgstr "Сигнатура функции::"

#: ../../c-api/typeobj.rst:1698
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Необязательный указатель на функцию для установки и удаления значения "
"дескриптора."

#: ../../c-api/typeobj.rst:1705
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "Аргументу *value* присвоено значение ``NULL`` для удаления значения."

#: ../../c-api/typeobj.rst:1716
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Если экземпляры этого типа имеют словарь, содержащий переменные экземпляра, "
"это поле ненулевое и содержит смещение в экземплярах типа словаря переменных "
"экземпляра; это смещение используется :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1721
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"Не путайте это поле с :c:member:`~PyTypeObject.tp_dict`; это словарь "
"атрибутов самого объекта типа."

#: ../../c-api/typeobj.rst:1724
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :c:member:`~PyTypeObject.tp_basicsize` "
"field should account for the dictionary added to the end in that case, even "
"though the dictionary is not included in the basic object layout.  On a "
"system with a pointer size of 4 bytes, :c:member:`~PyTypeObject."
"tp_dictoffset` should be set to ``-4`` to indicate that the dictionary is at "
"the very end of the structure."
msgstr ""

#: ../../c-api/typeobj.rst:1736
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call :c:func:"
"`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict` may "
"need to allocate memory for the dictionary, so it is may be more efficient "
"to call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
":c:member:`~PyTypeObject.tp_dictoffset` следует рассматривать как доступный "
"только для записи. Чтобы получить указатель на словарь, вызовите :c:func:"
"`PyObject_GenericGetDict`. Вызов :c:func:`PyObject_GenericGetDict` может "
"потребовать выделения памяти для словаря, поэтому может оказаться более "
"эффективным вызвать :c:func:`PyObject_GetAttr` при доступе к атрибуту "
"объекта."

#: ../../c-api/typeobj.rst:1744
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :c:member:`~PyTypeObject.tp_dictoffset`, this "
"should not be a problem."
msgstr ""

#: ../../c-api/typeobj.rst:1749
msgid ""
"When a type defined by a class statement has no :attr:`~object.__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :c:member:"
"`~PyTypeObject.tp_dictoffset` is set to that slot's offset."
msgstr ""

#: ../../c-api/typeobj.rst:1754
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :c:member:`~PyTypeObject.tp_dictoffset` "
"from its base type."
msgstr ""

#: ../../c-api/typeobj.rst:1757
msgid ""
"(Adding a slot named :attr:`~object.__dict__` to the :attr:`__slots__` "
"declaration does not have the expected effect, it just causes confusion.  "
"Maybe this should be added as a feature just like :attr:`__weakref__` "
"though.)"
msgstr ""

#: ../../c-api/typeobj.rst:1763
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"Этот слот не имеет значения по умолчанию. Для :ref:`статических типов "
"<static-types>`, если поле равно ``NULL``, то :attr:`~object.__dict__` для "
"экземпляров не создается."

#: ../../c-api/typeobj.rst:1769
msgid "An optional pointer to an instance initialization function."
msgstr "Необязательный указатель на функцию инициализации экземпляра."

#: ../../c-api/typeobj.rst:1771
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"Эта функция соответствует методу классов :meth:`~object.__init__`. Как и :"
"meth:`!__init__`, можно создать экземпляр без вызова :meth:`!__init__`, а "
"также можно повторно инициализировать экземпляр, снова вызвав его метод :"
"meth:`!__init__`."

#: ../../c-api/typeobj.rst:1780
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`~object.__init__`."
msgstr ""
"Аргумент self — это экземпляр, который нужно инициализировать; Аргументы "
"*args* и *kwds* представляют собой позиционные и ключевые аргументы вызова :"
"meth:`~object.__init__`."

#: ../../c-api/typeobj.rst:1784
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"Функция :c:member:`~PyTypeObject.tp_init`, если она не ``NULL``, вызывается, "
"когда экземпляр создается обычным образом путем вызова его типа, после "
"функции :c:member:`~PyTypeObject.tp_new` типа. вернул экземпляр типа. Если "
"функция :c:member:`~PyTypeObject.tp_new` возвращает экземпляр какого-либо "
"другого типа, который не является подтипом исходного типа, функция :c:member:"
"`~PyTypeObject.tp_init` не вызывается; если :c:member:`~PyTypeObject.tp_new` "
"возвращает экземпляр подтипа исходного типа, вызывается :c:member:"
"`~PyTypeObject.tp_init` подтипа."

#: ../../c-api/typeobj.rst:1791
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"Возвращает ``0`` в случае успеха, ``-1`` и устанавливает исключение в случае "
"ошибки."

#: ../../c-api/typeobj.rst:1799
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr ""
"Для :ref:`static типов <static-types>` это поле не имеет значения по "
"умолчанию."

#: ../../c-api/typeobj.rst:1804
msgid "An optional pointer to an instance allocation function."
msgstr "Необязательный указатель на функцию выделения экземпляра."

#: ../../c-api/typeobj.rst:1812
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""
"Это поле наследуется статическими подтипами, но не динамическими подтипами "
"(подтипами, созданными оператором класса)."

#: ../../c-api/typeobj.rst:1817
msgid ""
"For dynamic subtypes, this field is always set to :c:func:"
"`PyType_GenericAlloc`, to force a standard heap allocation strategy."
msgstr ""
"Для динамических подтипов это поле всегда установлено в :c:func:"
"`PyType_GenericAlloc`, чтобы использовать стандартную стратегию "
"распределения кучи."

#: ../../c-api/typeobj.rst:1821
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:"
"`PyType_GenericAlloc`.  That is the recommended value for all statically "
"defined types."
msgstr ""
"Для статических подтипов :c:data:`PyBaseObject_Type` использует :c:func:"
"`PyType_GenericAlloc`. Это рекомендуемое значение для всех статически "
"определенных типов."

#: ../../c-api/typeobj.rst:1828
msgid "An optional pointer to an instance creation function."
msgstr "Необязательный указатель на функцию создания экземпляра."

#: ../../c-api/typeobj.rst:1834
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"Аргумент *subtype* — это тип создаваемого объекта; Аргументы *args* и *kwds* "
"представляют собой позиционные и ключевые аргументы вызова типа. Обратите "
"внимание, что *subtype* не обязательно должен совпадать с типом, функция :c:"
"member:`~PyTypeObject.tp_new` которого вызывается; это может быть подтип "
"этого типа (но не несвязанный тип)."

#: ../../c-api/typeobj.rst:1840
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"Функция :c:member:`~PyTypeObject.tp_new` должна вызывать ``subtype-"
">tp_alloc(subtype, nitems)``, чтобы выделить место для объекта, а затем "
"выполнять лишь столько дальнейшей инициализации, сколько абсолютно "
"необходимо. Инициализацию, которую можно безопасно игнорировать или "
"повторить, следует поместить в обработчик :c:member:`~PyTypeObject.tp_init`. "
"Хорошее практическое правило заключается в том, что для неизменяемых типов "
"вся инициализация должна происходить в :c:member:`~PyTypeObject.tp_new`, "
"тогда как для изменяемых типов большая часть инициализации должна быть "
"отложена в :c:member:`~PyTypeObject.tp_init. `."

#: ../../c-api/typeobj.rst:1848
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"Установите флаг :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`, чтобы "
"запретить создание экземпляров этого типа в Python."

#: ../../c-api/typeobj.rst:1853
msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Это поле наследуется подтипами, за исключением того, что оно не наследуется :"
"ref:`статическими типами <static-types>`, :c:member:`~PyTypeObject.tp_base` "
"имеет значение ``NULL`` или ``&PyBaseObject_Type``."

#: ../../c-api/typeobj.rst:1859
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"Для :ref:`static типов <static-types>` это поле не имеет значения по "
"умолчанию. Это означает, что если слот определен как NULL, тип не может быть "
"вызван для создания новых экземпляров; предположительно, существует какой-то "
"другой способ создания экземпляров, например, фабричная функция."

#: ../../c-api/typeobj.rst:1867
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"Необязательный указатель на функцию освобождения экземпляра. Его подпись::"

#: ../../c-api/typeobj.rst:1871
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr ""
"Инициализатор, совместимый с этой сигнатурой, — :c:func:`PyObject_Free`."

#: ../../c-api/typeobj.rst:1875
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""
"Это поле наследуется статическими подтипами, но не динамическими подтипами "
"(подтипами, созданными оператором класса)."

#: ../../c-api/typeobj.rst:1880
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to match :c:"
"func:`PyType_GenericAlloc` and the value of the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""
"В динамических подтипах этому полю присваивается освободитель, "
"соответствующий :c:func:`PyType_GenericAlloc` и значению бита флага :c:macro:"
"`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:1884
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_Del`."
msgstr ""
"Для статических подтипов :c:data:`PyBaseObject_Type` использует :c:func:"
"`PyObject_Del`."

#: ../../c-api/typeobj.rst:1889
msgid "An optional pointer to a function called by the garbage collector."
msgstr "Необязательный указатель на функцию, вызываемую сборщиком мусора."

#: ../../c-api/typeobj.rst:1891
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"Сборщику мусора необходимо знать, можно ли собирать конкретный объект или "
"нет. Обычно достаточно просмотреть поле :c:member:`~PyTypeObject.tp_flags` "
"типа объекта и проверить бит флага :c:macro:`Py_TPFLAGS_HAVE_GC`. Но "
"некоторые типы содержат смесь статически и динамически выделяемых "
"экземпляров, и статически выделенные экземпляры не подлежат сбору. Такие "
"типы должны определять эту функцию; он должен возвращать ``1`` для "
"коллекционного экземпляра и ``0`` для неколлекционируемого экземпляра. "
"Подпись такая::"

#: ../../c-api/typeobj.rst:1901
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(Единственным примером являются сами типы. Метатип :c:data:`PyType_Type` "
"определяет эту функцию для различения статически и :ref:`динамически "
"выделяемых типов <heap-types>`.)"

#: ../../c-api/typeobj.rst:1911
msgid ""
"This slot has no default.  If this field is ``NULL``, :c:macro:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Этот слот не имеет значения по умолчанию. Если это поле равно NULL, в "
"качестве функционального эквивалента используется :c:macro:"
"`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:1917
msgid "Tuple of base types."
msgstr "Кортеж базовых типов."

#: ../../c-api/typeobj.rst:1919 ../../c-api/typeobj.rst:1943
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"Это поле должно быть установлено в NULL и рассматриваться как доступное "
"только для чтения. Python заполнит его, если тип :c:func:`initialized "
"<PyType_Ready>`."

#: ../../c-api/typeobj.rst:1922
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"Для динамически создаваемых классов вместо аргумента *bases* функции :c:func:"
"`PyType_FromSpecWithBases` можно использовать ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>`. Форма аргумента является предпочтительной."

#: ../../c-api/typeobj.rst:1929
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"Множественное наследование не работает для статически определенных типов. "
"Если вы установите для tp_bases кортеж, Python не выдаст ошибку, но "
"некоторые слоты будут унаследованы только от первой базы."

#: ../../c-api/typeobj.rst:1935 ../../c-api/typeobj.rst:1958
#: ../../c-api/typeobj.rst:1967 ../../c-api/typeobj.rst:1977
#: ../../c-api/typeobj.rst:1991
msgid "This field is not inherited."
msgstr "Это поле не наследуется."

#: ../../c-api/typeobj.rst:1940
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Кортеж, содержащий расширенный набор базовых типов, начиная с самого типа и "
"заканчивая :class:`object`, в порядке разрешения методов."

#: ../../c-api/typeobj.rst:1948
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"Это поле не наследуется; он вычисляется заново с помощью :c:func:"
"`PyType_Ready`."

#: ../../c-api/typeobj.rst:1954
msgid "Unused.  Internal use only."
msgstr "Неиспользованный. Только для внутреннего использования."

#: ../../c-api/typeobj.rst:1963
msgid "List of weak references to subclasses.  Internal use only."
msgstr ""

#: ../../c-api/typeobj.rst:1972
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Заголовок списка слабых ссылок для слабых ссылок на объект этого типа. Не "
"наследуется. Только для внутреннего использования."

#: ../../c-api/typeobj.rst:1982
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Это поле устарело. Вместо этого используйте :c:member:`~PyTypeObject."
"tp_finalize`."

#: ../../c-api/typeobj.rst:1987
msgid "Used to index into the method cache.  Internal use only."
msgstr ""
"Используется для индексации в кэше методов. Только для внутреннего "
"использования."

#: ../../c-api/typeobj.rst:1996
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr ""
"Необязательный указатель на функцию финализации экземпляра. Его подпись::"

#: ../../c-api/typeobj.rst:2000
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"Если :c:member:`~PyTypeObject.tp_finalize` установлен, интерпретатор "
"вызывает его один раз при финализации экземпляра. Он вызывается либо из "
"сборщика мусора (если экземпляр является частью изолированного ссылочного "
"цикла), либо непосредственно перед освобождением объекта. В любом случае, он "
"гарантированно будет вызван перед попыткой разорвать ссылочные циклы, "
"гарантируя, что он найдет объект в нормальном состоянии."

#: ../../c-api/typeobj.rst:2007
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` не должен изменять текущий статус "
"исключения; поэтому рекомендуемый способ написания нетривиального "
"финализатора:"

#: ../../c-api/typeobj.rst:2024
msgid ""
"Also, note that, in a garbage collected Python, :c:member:`~PyTypeObject."
"tp_dealloc` may be called from any Python thread, not just the thread which "
"created the object (if the object becomes part of a refcount cycle, that "
"cycle might be collected by a garbage collection on any thread).  This is "
"not a problem for Python API calls, since the thread on which tp_dealloc is "
"called will own the Global Interpreter Lock (GIL). However, if the object "
"being destroyed in turn destroys objects from some other C or C++ library, "
"care should be taken to ensure that destroying those objects on the thread "
"which called tp_dealloc will not violate any assumptions of the library."
msgstr ""
"Также обратите внимание, что в Python со сборкой мусора :c:member:"
"`~PyTypeObject.tp_dealloc` может быть вызван из любого потока Python, а не "
"только из потока, создавшего объект (если объект становится частью цикла "
"подсчета ссылок, это цикл может быть собран сборщиком мусора в любом "
"потоке). Это не проблема для вызовов API Python, поскольку поток, в котором "
"вызывается tp_dealloc, будет владеть глобальной блокировкой интерпретатора "
"(GIL). Однако если уничтожаемый объект, в свою очередь, уничтожает объекты "
"из какой-либо другой библиотеки C или C++, следует позаботиться о том, чтобы "
"уничтожение этих объектов в потоке, вызвавшем tp_dealloc, не нарушило "
"никаких предположений библиотеки."

#: ../../c-api/typeobj.rst:2043
msgid ""
"Before version 3.8 it was necessary to set the :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"До версии 3.8 необходимо было установить бит флагов :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE`, чтобы это поле можно было использовать. Это "
"больше не требуется."

#: ../../c-api/typeobj.rst:2047
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "«Безопасная финализация объекта» (:pep:`442`)"

#: ../../c-api/typeobj.rst:2052
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation using :"
"meth:`~object.__new__` and :meth:`~object.__init__` is used."
msgstr ""
"Функция Vectorcall, используемая для вызовов объекта этого типа. Другими "
"словами, он используется для реализации :ref:`vectorcall <vectorcall>` для "
"``type.__call__``. Если ``tp_vectorcall`` имеет значение ``NULL``, "
"используется реализация вызова по умолчанию с использованием :meth:`~object."
"__new__` и :meth:`~object.__init__`."

#: ../../c-api/typeobj.rst:2060
msgid "This field is never inherited."
msgstr "Это поле никогда не наследуется."

#: ../../c-api/typeobj.rst:2062
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(поле существует с версии 3.8, но используется только с версии 3.9)"

#: ../../c-api/typeobj.rst:2068
msgid "Static Types"
msgstr "Статические типы"

#: ../../c-api/typeobj.rst:2070
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Традиционно типы, определенные в коде C, являются *статическими*, то есть "
"статическая структура :c:type:`PyTypeObject` определяется непосредственно в "
"коде и инициализируется с помощью :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2074
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Это приводит к появлению типов, которые ограничены по сравнению с типами, "
"определенными в Python:"

#: ../../c-api/typeobj.rst:2076
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Статические типы ограничены одной базой, т.е. не могут использовать "
"множественное наследование."

#: ../../c-api/typeobj.rst:2078
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Объекты статического типа (но не обязательно их экземпляры) неизменяемы. "
"Невозможно добавить или изменить атрибуты объекта типа из Python."

#: ../../c-api/typeobj.rst:2080
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Объекты статического типа являются общими для всех субинтерпретаторов <sub-"
"interpreter-support>`, поэтому они не должны включать в себя какие-либо "
"состояния, специфичные для субинтерпретатора."

#: ../../c-api/typeobj.rst:2084
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"Кроме того, поскольку :c:type:`PyTypeObject` является лишь частью :ref:"
"`Limited API <limited-c-api>` как непрозрачная структура, любые модули "
"расширения, использующие статические типы, должны быть скомпилированы для "
"конкретной дополнительной версии Python. ."

#: ../../c-api/typeobj.rst:2092
msgid "Heap Types"
msgstr "Типы кучи"

#: ../../c-api/typeobj.rst:2094
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Альтернативой статическим типам <static-types>` являются *типы, выделяемые в "
"куче*, или для краткости *типы в куче*, которые близко соответствуют "
"классам, созданным оператором Python ``class``. Для типов кучи установлен "
"флаг :c:macro:`Py_TPFLAGS_HEAPTYPE`."

#: ../../c-api/typeobj.rst:2099
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, or :c:func:"
"`PyType_FromModuleAndSpec`."
msgstr ""

#: ../../c-api/typeobj.rst:2107
msgid "Number Object Structures"
msgstr "Структуры числовых объектов"

#: ../../c-api/typeobj.rst:2114
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Эта структура содержит указатели на функции, которые объект использует для "
"реализации числового протокола. Каждая функция используется функцией с "
"аналогичным именем, описанной в разделе :ref:`number`."

#: ../../c-api/typeobj.rst:2120 ../../c-api/typeobj.rst:2444
msgid "Here is the structure definition::"
msgstr "Вот определение структуры::"

#: ../../c-api/typeobj.rst:2167
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Двоичные и троичные функции должны проверять тип всех своих операндов и "
"выполнять необходимые преобразования (по крайней мере, один из операндов "
"является экземпляром определенного типа). Если операция не определена для "
"данных операндов, двоичные и троичные функции должны вернуть "
"Py_NotImplemented, если произошла другая ошибка, они должны вернуть NULL и "
"установить исключение."

#: ../../c-api/typeobj.rst:2176
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in "
"Python 3.0.1."
msgstr ""
"Поле :c:member:`~PyNumberMethods.nb_reserved` всегда должно быть ``NULL``. "
"Ранее он назывался :c:member:`!nb_long` и был переименован в Python 3.0.1."

#: ../../c-api/typeobj.rst:2221
msgid "Mapping Object Structures"
msgstr "Сопоставление структур объектов"

#: ../../c-api/typeobj.rst:2228
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Эта структура содержит указатели на функции, которые объект использует для "
"реализации протокола сопоставления. В его состав входят три члена:"

#: ../../c-api/typeobj.rst:2233
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Эта функция используется :c:func:`PyMapping_Size` и :c:func:`PyObject_Size` "
"и имеет одинаковую сигнатуру. Этот слот может быть установлен в NULL, если "
"объект не имеет определенной длины."

#: ../../c-api/typeobj.rst:2239
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Эта функция используется :c:func:`PyObject_GetItem` и :c:func:"
"`PySequence_GetSlice` и имеет ту же сигнатуру, что и :c:func:`!"
"PyObject_GetItem`. Этот слот должен быть заполнен, чтобы функция :c:func:"
"`PyMapping_Check` возвращала ``1``, в противном случае она может быть "
"``NULL``."

#: ../../c-api/typeobj.rst:2247
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and :c:func:"
"`PySequence_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Эта функция используется :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` и :c:func:"
"`PySequence_DelSlice`. Он имеет ту же подпись, что и :c:func:`!"
"PyObject_SetItem`, но для *v* также можно установить значение ``NULL`` для "
"удаления элемента. Если этот слот равен NULL, объект не поддерживает "
"назначение и удаление элементов."

#: ../../c-api/typeobj.rst:2258
msgid "Sequence Object Structures"
msgstr "Структуры объектов последовательности"

#: ../../c-api/typeobj.rst:2265
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Эта структура содержит указатели на функции, которые объект использует для "
"реализации протокола последовательности."

#: ../../c-api/typeobj.rst:2270
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Эта функция используется :c:func:`PySequence_Size` и :c:func:`PyObject_Size` "
"и имеет одинаковую сигнатуру. Он также используется для обработки "
"отрицательных индексов через слоты :c:member:`~PySequenceMethods.sq_item` и :"
"c:member:`~PySequenceMethods.sq_ass_item`."

#: ../../c-api/typeobj.rst:2277
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Эта функция используется :c:func:`PySequence_Concat` и имеет ту же "
"сигнатуру. Он также используется оператором ``+`` после попытки сложения "
"чисел через слот :c:member:`~PyNumberMethods.nb_add`."

#: ../../c-api/typeobj.rst:2283
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Эта функция используется :c:func:`PySequence_Repeat` и имеет ту же "
"сигнатуру. Он также используется оператором ``*`` после попытки числового "
"умножения через слот :c:member:`~PyNumberMethods.nb_multiply`."

#: ../../c-api/typeobj.rst:2289
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Эта функция используется :c:func:`PySequence_GetItem` и имеет ту же "
"сигнатуру. Он также используется :c:func:`PyObject_GetItem` после попытки "
"подписки через слот :c:member:`~PyMappingMethods.mp_subscript`. Этот слот "
"должен быть заполнен, чтобы функция :c:func:`PySequence_Check` возвращала "
"``1``, в противном случае она может быть ``NULL``."

#: ../../c-api/typeobj.rst:2295
msgid ""
"Negative indexes are handled as follows: if the :c:member:"
"`~PySequenceMethods.sq_length` slot is filled, it is called and the sequence "
"length is used to compute a positive index which is passed to  :c:member:"
"`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is ``NULL``, the "
"index is passed as is to the function."
msgstr ""
"Отрицательные индексы обрабатываются следующим образом: если слот :c:member:"
"`~PySequenceMethods.sq_length` заполнен, он вызывается, и длина "
"последовательности используется для вычисления положительного индекса, "
"который передается в :c:member:`~PySequenceMethods .sq_item`. Если :c:member:"
"`!sq_length` имеет значение ``NULL``, индекс передается в функцию как есть."

#: ../../c-api/typeobj.rst:2302
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Эта функция используется :c:func:`PySequence_SetItem` и имеет ту же "
"сигнатуру. Он также используется :c:func:`PyObject_SetItem` и :c:func:"
"`PyObject_DelItem` после попытки назначения и удаления элемента через слот :"
"c:member:`~PyMappingMethods.mp_ass_subscript`. Этот слот можно оставить "
"равным NULL, если объект не поддерживает назначение и удаление элементов."

#: ../../c-api/typeobj.rst:2311
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Эта функция может использоваться :c:func:`PySequence_Contains` и имеет ту же "
"сигнатуру. Этот слот можно оставить равным ``NULL``, в этом случае :c:func:`!"
"PySequence_Contains` просто просматривает последовательность, пока не найдет "
"совпадение."

#: ../../c-api/typeobj.rst:2318
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Эта функция используется :c:func:`PySequence_InPlaceConcat` и имеет ту же "
"сигнатуру. Он должен изменить свой первый операнд и вернуть его. Для этого "
"слота можно оставить значение ``NULL``, в этом случае :c:func:`!"
"PySequence_InPlaceConcat` вернется к значению :c:func:`PySequence_Concat`. "
"Он также используется расширенным присваиванием ``+=`` после попытки "
"сложения чисел на месте через слот :c:member:`~PyNumberMethods."
"nb_inplace_add`."

#: ../../c-api/typeobj.rst:2327
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Эта функция используется :c:func:`PySequence_InPlaceRepeat` и имеет ту же "
"сигнатуру. Он должен изменить свой первый операнд и вернуть его. Этот слот "
"можно оставить равным ``NULL``, в этом случае :c:func:`!"
"PySequence_InPlaceRepeat` вернется к :c:func:`PySequence_Repeat`. Он также "
"используется расширенным присваиванием ``*=`` после попытки числового "
"умножения на месте через слот :c:member:`~PyNumberMethods."
"nb_inplace_multiply`."

#: ../../c-api/typeobj.rst:2338
msgid "Buffer Object Structures"
msgstr "Структуры буферных объектов"

#: ../../c-api/typeobj.rst:2346
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Эта структура содержит указатели на функции, необходимые для протокола "
"буфера <bufferobjects>. Протокол определяет, как объект-экспортер может "
"предоставлять свои внутренние данные объектам-потребителям."

#: ../../c-api/typeobj.rst:2352 ../../c-api/typeobj.rst:2401
#: ../../c-api/typeobj.rst:2455 ../../c-api/typeobj.rst:2466
#: ../../c-api/typeobj.rst:2478 ../../c-api/typeobj.rst:2488
msgid "The signature of this function is::"
msgstr "Сигнатура этой функции:"

#: ../../c-api/typeobj.rst:2356
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Обработать запрос *экспортеру* на заполнение *view*, как указано в *flags*. "
"За исключением пункта (3), реализация этой функции ДОЛЖНА выполнить "
"следующие шаги:"

#: ../../c-api/typeobj.rst:2360
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set :c:"
"expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Проверьте, может ли запрос быть удовлетворен. Если нет, поднимите :exc:"
"`BufferError`, установите :c:expr:`view->obj` в ``NULL`` и верните ``-1``."

#: ../../c-api/typeobj.rst:2363
msgid "Fill in the requested fields."
msgstr "Заполните требуемые поля."

#: ../../c-api/typeobj.rst:2365
msgid "Increment an internal counter for the number of exports."
msgstr "Увеличьте внутренний счетчик количества экспортов."

#: ../../c-api/typeobj.rst:2367
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Установите для :c:expr:`view->obj` значение *exporter* и увеличьте :c:expr:"
"`view->obj`."

#: ../../c-api/typeobj.rst:2369
msgid "Return ``0``."
msgstr "Вернуть ``0``."

#: ../../c-api/typeobj.rst:2371
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Если *экспортер* является частью цепочки или дерева поставщиков буферов, "
"можно использовать две основные схемы:"

#: ../../c-api/typeobj.rst:2374
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"Реэкспорт: каждый член дерева действует как экспортируемый объект и "
"устанавливает :c:expr:`view->obj` в новую ссылку на самого себя."

#: ../../c-api/typeobj.rst:2377
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Перенаправление: запрос буфера перенаправляется на корневой объект дерева. "
"Здесь :c:expr:`view->obj` будет новой ссылкой на корневой объект."

#: ../../c-api/typeobj.rst:2381
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Отдельные поля *view* описаны в разделе :ref:`Структура буфера <buffer-"
"structure>`, правила того, как экспортер должен реагировать на конкретные "
"запросы, находятся в разделе :ref:`Типы запросов буфера <buffer-request-"
"types >`."

#: ../../c-api/typeobj.rst:2386
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Вся память, указанная в структуре :c:type:`Py_buffer`, принадлежит "
"экспортеру и должна оставаться действительной до тех пор, пока не останется "
"потребителей. :c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :"
"c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` и :c :"
"member:`~Py_buffer.internal` доступны потребителю только для чтения."

#: ../../c-api/typeobj.rst:2393
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` обеспечивает простой способ предоставления "
"простого буфера байтов, корректно обрабатывая все типы запросов."

#: ../../c-api/typeobj.rst:2396
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` — это интерфейс для потребителя, который "
"обертывает эту функцию."

#: ../../c-api/typeobj.rst:2405
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Обработка запроса на освобождение ресурсов буфера. Если ресурсы не нужно "
"освобождать, :c:member:`PyBufferProcs.bf_releasebuffer` может иметь значение "
"``NULL``. В противном случае стандартная реализация этой функции выполнит "
"следующие дополнительные шаги:"

#: ../../c-api/typeobj.rst:2410
msgid "Decrement an internal counter for the number of exports."
msgstr "Уменьшите внутренний счетчик количества экспортов."

#: ../../c-api/typeobj.rst:2412
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Если счетчик равен «0», освободите всю память, связанную с *view*."

#: ../../c-api/typeobj.rst:2414
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"Экспортер ДОЛЖЕН использовать поле :c:member:`~Py_buffer.internal` для "
"отслеживания ресурсов, специфичных для буфера. Это поле гарантированно "
"останется постоянным, в то время как потребитель МОЖЕТ передать копию "
"исходного буфера в качестве аргумента *view*."

#: ../../c-api/typeobj.rst:2420
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Эта функция НЕ ДОЛЖНА уменьшать :c:expr:`view->obj`, поскольку это делается "
"автоматически в :c:func:`PyBuffer_Release` (эта схема полезна для разрыва "
"ссылочных циклов)."

#: ../../c-api/typeobj.rst:2425
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` — это интерфейс для потребителя, который "
"обертывает эту функцию."

#: ../../c-api/typeobj.rst:2433
msgid "Async Object Structures"
msgstr "Структуры асинхронных объектов"

#: ../../c-api/typeobj.rst:2441
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Эта структура содержит указатели на функции, необходимые для реализации "
"объектов :term:`awaitable` и :term:`асинхронный итератор`."

#: ../../c-api/typeobj.rst:2459
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"Возвращаемый объект должен быть :term:`итератором`, т.е. :c:func:"
"`PyIter_Check` должен возвращать для него ``1``."

#: ../../c-api/typeobj.rst:2462
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Этот слот может быть установлен в NULL, если объект не является :term:"
"`awaitable`."

#: ../../c-api/typeobj.rst:2470
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`~object."
"__anext__` for details."
msgstr ""
"Должен возвращать объект асинхронного итератора. Подробности смотрите в :"
"meth:`~object.__anext__`."

#: ../../c-api/typeobj.rst:2473
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Этот слот может быть установлен в NULL, если объект не реализует протокол "
"асинхронной итерации."

#: ../../c-api/typeobj.rst:2482
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"Должен возвращать объект :term:`awaitable`. Подробности смотрите в :meth:"
"`~object.__anext__`. Этот слот может быть установлен в значение NULL."

#: ../../c-api/typeobj.rst:2492
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Подробности смотрите в :c:func:`PyIter_Send`. Этот слот может быть "
"установлен в значение NULL."

#: ../../c-api/typeobj.rst:2501
msgid "Slot Type typedefs"
msgstr "Типы слотов"

#: ../../c-api/typeobj.rst:2505
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and :c:member:`~PyObject."
"ob_type` set to the type argument.  If the type's :c:member:`~PyTypeObject."
"tp_itemsize` is non-zero, the object's :c:member:`~PyVarObject.ob_size` "
"field should be initialized to *nitems* and the length of the allocated "
"memory block should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to "
"a multiple of ``sizeof(void*)``; otherwise, *nitems* is not used and the "
"length of the block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Цель этой функции — отделить выделение памяти от инициализации памяти. Он "
"должен возвращать указатель на блок памяти адекватной длины для экземпляра, "
"соответствующим образом выровненный и инициализированный нулями, но с :c:"
"member:`~PyObject.ob_refcnt` установленным в ``1`` и :c:member :`~PyObject."
"ob_type` установлен в аргумент типа. Если :c:member:`~PyTypeObject."
"tp_itemsize` типа не равно нулю, поле :c:member:`~PyVarObject.ob_size` "
"объекта должно быть инициализировано значением *nitems*, а длина выделенного "
"блока памяти должна быть равна ``tp_basicsize + nitems*tp_itemsize``, "
"округляется до кратного ``sizeof(void*)``; в противном случае *nitems* не "
"используется, а длина блока должна быть :c:member:`~PyTypeObject."
"tp_basicsize`."

#: ../../c-api/typeobj.rst:2515
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Эта функция не должна выполнять какую-либо другую инициализацию экземпляра, "
"даже для выделения дополнительной памяти; это должен сделать :c:member:"
"`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2522
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "См. :c:member:`~PyTypeObject.tp_free`."

#: ../../c-api/typeobj.rst:2526
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "См. :c:member:`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2530
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "См. :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2534
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "См. :c:member:`~PyTypeObject.tp_repr`."

#: ../../c-api/typeobj.rst:2538 ../../c-api/typeobj.rst:2547
msgid "Return the value of the named attribute for the object."
msgstr "Верните значение именованного атрибута объекта."

#: ../../c-api/typeobj.rst:2542 ../../c-api/typeobj.rst:2553
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Установите значение именованного атрибута для объекта. Аргументу value "
"присвоено значение NULL, чтобы удалить атрибут."

#: ../../c-api/typeobj.rst:2549
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "См. :c:member:`~PyTypeObject.tp_getattro`."

#: ../../c-api/typeobj.rst:2556
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "См. :c:member:`~PyTypeObject.tp_setattro`."

#: ../../c-api/typeobj.rst:2560
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "См. :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:2564
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "См. :c:member:`~PyTypeObject.tp_descr_set`."

#: ../../c-api/typeobj.rst:2568
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "См. :c:member:`~PyTypeObject.tp_hash`."

#: ../../c-api/typeobj.rst:2572
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "См. :c:member:`~PyTypeObject.tp_richcompare`."

#: ../../c-api/typeobj.rst:2576
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "См. :c:member:`~PyTypeObject.tp_iter`."

#: ../../c-api/typeobj.rst:2580
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "См. :c:member:`~PyTypeObject.tp_iternext`."

#: ../../c-api/typeobj.rst:2594
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "См. :c:member:`~PyAsyncMethods.am_send`."

#: ../../c-api/typeobj.rst:2610
msgid "Examples"
msgstr "Примеры"

#: ../../c-api/typeobj.rst:2612
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Ниже приведены простые примеры определений типов Python. Они включают в себя "
"распространенное использование, с которым вы можете столкнуться. Некоторые "
"демонстрируют сложные угловые случаи. Дополнительные примеры, практическую "
"информацию и руководство см. в разделах :ref:`defining-new-types` и :ref:"
"`new-types-topics`."

#: ../../c-api/typeobj.rst:2617
msgid "A basic :ref:`static type <static-types>`::"
msgstr "Базовый :ref:`статический тип <static-types>`::"

#: ../../c-api/typeobj.rst:2634
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"Вы также можете найти более старый код (особенно в базе кода CPython) с "
"более подробным инициализатором:"

#: ../../c-api/typeobj.rst:2678
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "Тип, поддерживающий слабые ссылки, словари экземпляров и хеширование::"

#: ../../c-api/typeobj.rst:2705
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"Подкласс str, который не может быть подклассом и не может быть вызван для "
"создания экземпляров (например, использует отдельную фабричную функцию) с "
"использованием флага :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`::"

#: ../../c-api/typeobj.rst:2724
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"Самый простой статический тип <static-types>` с экземплярами фиксированной "
"длины::"

#: ../../c-api/typeobj.rst:2735
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"Самый простой статический тип <static-types>` с экземплярами переменной "
"длины::"

#: ../../c-api/typeobj.rst:807 ../../c-api/typeobj.rst:872
msgid "built-in function"
msgstr "встроенная функция"

#: ../../c-api/typeobj.rst:807
msgid "repr"
msgstr "repr"

#: ../../c-api/typeobj.rst:872
msgid "hash"
msgstr "hash"
