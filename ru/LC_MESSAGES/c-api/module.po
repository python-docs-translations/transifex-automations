# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/module.rst:6
msgid "Module Objects"
msgstr "Объекты модуля"

#: ../../c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"Этот экземпляр :c:type:`PyTypeObject` представляет тип модуля Python. В "
"программах Python он предоставляется как «types.ModuleType»."

#: ../../c-api/module.rst:21
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"Возвращайте true, если *p* является объектом модуля или подтипом объекта "
"модуля. Эта функция всегда завершается успешно."

#: ../../c-api/module.rst:27
msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"Возвращайте true, если *p* является объектом модуля, но не подтипом :c:data:"
"`PyModule_Type`. Эта функция всегда завершается успешно."

#: ../../c-api/module.rst:40
msgid ""
"Return a new module object with :attr:`module.__name__` set to *name*. The "
"module's :attr:`!__name__`, :attr:`~module.__doc__`, :attr:`~module."
"__package__` and :attr:`~module.__loader__` attributes are filled in (all "
"but :attr:`!__name__` are set to ``None``). The caller is responsible for "
"setting a :attr:`~module.__file__` attribute."
msgstr ""
"Верните новый объект модуля с :attr:`module.__name__`, установленным в "
"*name*. Атрибуты модуля :attr:`!__name__`, :attr:`~module.__doc__`, :attr:"
"`~module.__package__` и :attr:`~module.__loader__` заполняются (все, кроме :"
"attr:` !__name__` установлены на ``None``). Вызывающая сторона отвечает за "
"установку атрибута :attr:`~module.__file__`."

#: ../../c-api/module.rst:46 ../../c-api/module.rst:416
#: ../../c-api/module.rst:443
msgid "Return ``NULL`` with an exception set on error."
msgstr "Возвращает ``NULL`` с исключением, установленным в случае ошибки."

#: ../../c-api/module.rst:50
msgid ""
":attr:`~module.__package__` and :attr:`~module.__loader__` are now set to "
"``None``."
msgstr ""
":attr:`~module.__package__` и :attr:`~module.__loader__` теперь установлены "
"на ``None``."

#: ../../c-api/module.rst:57
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"Аналогично :c:func:`PyModule_NewObject`, но имя представляет собой строку в "
"кодировке UTF-8, а не объект Unicode."

#: ../../c-api/module.rst:65
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"Возвращает объект словаря, реализующий пространство имен *module*; этот "
"объект аналогичен атрибуту :attr:`~object.__dict__` объекта модуля. Если "
"*module* не является объектом модуля (или подтипом объекта модуля), "
"возникает :exc:`SystemError` и возвращается ``NULL``."

#: ../../c-api/module.rst:70
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""
"Рекомендуется, чтобы расширения использовали другие функции ``PyModule_*`` и "
"``PyObject_*``, а не напрямую манипулировали :attr:`~object.__dict__` модуля."

#: ../../c-api/module.rst:81
msgid ""
"Return *module*'s :attr:`~module.__name__` value.  If the module does not "
"provide one, or if it is not a string, :exc:`SystemError` is raised and "
"``NULL`` is returned."
msgstr ""
"Возвращает значение :attr:`~module.__name__` *module*. Если модуль его не "
"предоставляет или если это не строка, возникает :exc:`SystemError` и "
"возвращается ``NULL``."

#: ../../c-api/module.rst:90
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"Аналогично :c:func:`PyModule_GetNameObject`, но возвращает имя, "
"закодированное в ``'utf-8'``."

#: ../../c-api/module.rst:95
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"Возвращает «состояние» модуля, то есть указатель на блок памяти, выделенный "
"во время создания модуля, или ``NULL``. См. :c:member:`PyModuleDef.m_size`."

#: ../../c-api/module.rst:102
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"Верните указатель на структуру :c:type:`PyModuleDef`, из которой был создан "
"модуль, или ``NULL``, если модуль не был создан на основе определения."

#: ../../c-api/module.rst:112
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`~module.__file__` attribute.  If this is not defined, or if it is not "
"a string, raise :exc:`SystemError` and return ``NULL``; otherwise return a "
"reference to a Unicode object."
msgstr ""
"Верните имя файла, из которого был загружен *module*, используя атрибут :"
"attr:`~module.__file__` *module*. Если это не определено или это не строка, "
"вызовите :exc:`SystemError` и верните ``NULL``; в противном случае верните "
"ссылку на объект Unicode."

#: ../../c-api/module.rst:122
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"Аналогично :c:func:`PyModule_GetFilenameObject`, но возвращает имя файла в "
"кодировке «utf-8»."

#: ../../c-api/module.rst:125
msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` вызывает :exc:`UnicodeEncodeError` для "
"некодируемых имен файлов, вместо этого используйте :c:func:"
"`PyModule_GetFilenameObject`."

#: ../../c-api/module.rst:133
msgid "Module definitions"
msgstr ""

#: ../../c-api/module.rst:135
msgid ""
"The functions in the previous section work on any module object, including "
"modules imported from Python code."
msgstr ""

#: ../../c-api/module.rst:138
msgid ""
"Modules defined using the C API typically use a *module definition*, :c:type:"
"`PyModuleDef` -- a statically allocated, constant “description\" of how a "
"module should be created."
msgstr ""

#: ../../c-api/module.rst:142
msgid ""
"The definition is usually used to define an extension's “main” module object "
"(see :ref:`extension-modules` for details). It is also used to :ref:`create "
"extension modules dynamically <moduledef-dynamic>`."
msgstr ""

#: ../../c-api/module.rst:147
msgid ""
"Unlike :c:func:`PyModule_New`, the definition allows management of *module "
"state* -- a piece of memory that is allocated and cleared together with the "
"module object. Unlike the module's Python attributes, Python code cannot "
"replace or delete data stored in module state."
msgstr ""

#: ../../c-api/module.rst:155
msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. This structure must be statically allocated (or be otherwise "
"guaranteed to be valid while any modules created from it exist). Usually, "
"there is only one variable of this type for each extension module."
msgstr ""

#: ../../c-api/module.rst:163
msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`."
msgstr "Всегда инициализируйте этот член как :c:macro:`PyModuleDef_HEAD_INIT`."

#: ../../c-api/module.rst:167
msgid "Name for the new module."
msgstr "Имя нового модуля."

#: ../../c-api/module.rst:171
msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"Строка документации для модуля; обычно используется переменная строки "
"документации, созданная с помощью :c:macro:`PyDoc_STRVAR`."

#: ../../c-api/module.rst:176
msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"Состояние модуля может храниться в области памяти каждого модуля, которую "
"можно получить с помощью :c:func:`PyModule_GetState`, а не в статических "
"глобальных переменных. Это делает модули безопасными для использования в "
"нескольких субинтерпретаторах."

#: ../../c-api/module.rst:180
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:"
"`~PyModuleDef.m_free` function has been called, if present."
msgstr ""
"Эта область памяти выделяется на основе *m_size* при создании модуля и "
"освобождается, когда объект модуля освобождается после вызова функции :c:"
"member:`~PyModuleDef.m_free`, если она присутствует."

#: ../../c-api/module.rst:184
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state."
msgstr ""

#: ../../c-api/module.rst:188
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state. Negative ``m_size`` is only "
"allowed when using :ref:`legacy single-phase initialization <single-phase-"
"initialization>` or when :ref:`creating modules dynamically <moduledef-"
"dynamic>`."
msgstr ""

#: ../../c-api/module.rst:194
msgid "See :PEP:`3121` for more details."
msgstr "См. :PEP:`3121` для более подробной информации."

#: ../../c-api/module.rst:198
msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"Указатель на таблицу функций уровня модуля, описываемую значениями :c:type:"
"`PyMethodDef`. Может быть NULL, если нет функций."

#: ../../c-api/module.rst:203
msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using legacy single-phase initialization, "
"*m_slots* must be ``NULL``."
msgstr ""

#: ../../c-api/module.rst:209
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "До версии 3.5 этот член всегда имел значение NULL и определялся как:"

#: ../../c-api/module.rst:216
msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Функция обхода, вызываемая во время обхода GC объекта модуля, или NULL, если "
"не требуется."

#: ../../c-api/module.rst:219 ../../c-api/module.rst:234
#: ../../c-api/module.rst:255
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is "
"greater than 0 and the module state (as returned by :c:func:"
"`PyModule_GetState`) is ``NULL``."
msgstr ""
"Эта функция не вызывается, если состояние модуля было запрошено, но еще не "
"выделено. Это происходит сразу после создания модуля и до его выполнения "
"(функция:c:data:`Py_mod_exec`). Точнее, эта функция не вызывается, если :c:"
"member:`~PyModuleDef.m_size` больше 0 и состояние модуля (возвращённое :c:"
"func:`PyModule_GetState`) равно ``NULL``."

#: ../../c-api/module.rst:226 ../../c-api/module.rst:247
#: ../../c-api/module.rst:262
msgid "No longer called before the module state is allocated."
msgstr "Больше не вызывается до выделения состояния модуля."

#: ../../c-api/module.rst:231
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Функция очистки, вызываемая во время очистки GC объекта модуля, или NULL, "
"если она не требуется."

#: ../../c-api/module.rst:241
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"Как и :c:member:`PyTypeObject.tp_clear`, эта функция не *всегда* вызывается "
"перед освобождением модуля. Например, когда подсчета ссылок достаточно, "
"чтобы определить, что объект больше не используется, циклический сборщик "
"мусора не задействуется и :c:member:`~PyModuleDef.m_free` вызывается "
"напрямую."

#: ../../c-api/module.rst:252
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr ""
"Функция, вызываемая во время освобождения объекта модуля, или NULL, если она "
"не нужна."

#: ../../c-api/module.rst:267
msgid "Module slots"
msgstr ""

#: ../../c-api/module.rst:273
msgid "A slot ID, chosen from the available values explained below."
msgstr "Идентификатор слота, выбранный из доступных значений, описанных ниже."

#: ../../c-api/module.rst:277
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "Значение слота, значение которого зависит от идентификатора слота."

#: ../../c-api/module.rst:281
msgid "The available slot types are:"
msgstr "Доступные типы слотов:"

#: ../../c-api/module.rst:285
msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"Указывает функцию, которая вызывается для создания самого объекта модуля. "
"Указатель *value* этого слота должен указывать на функцию подписи:"

#: ../../c-api/module.rst:292
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"Функция получает экземпляр :py:class:`~importlib.machinery.ModuleSpec`, как "
"определено в :PEP:`451`, и определение модуля. Он должен вернуть новый "
"объект модуля или установить ошибку и вернуть NULL."

#: ../../c-api/module.rst:297
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"Эта функция должна быть минимальной. В частности, он не должен вызывать "
"произвольный код Python, поскольку попытка повторного импорта того же модуля "
"может привести к бесконечному циклу."

#: ../../c-api/module.rst:301
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr ""
"В одном определении модуля нельзя указать несколько слотов Py_mod_create."

#: ../../c-api/module.rst:304
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"Если ``Py_mod_create`` не указан, механизм импорта создаст обычный объект "
"модуля, используя :c:func:`PyModule_New`. Имя взято из *spec*, а не из "
"определения, чтобы позволить модулям расширения динамически подстраиваться "
"под свое место в иерархии модулей и импортироваться под разными именами "
"через символические ссылки, при этом используя одно определение модуля."

#: ../../c-api/module.rst:310
msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"Не требуется, чтобы возвращаемый объект был экземпляром :c:type:"
"`PyModule_Type`. Можно использовать любой тип, если он поддерживает "
"установку и получение атрибутов, связанных с импортом. Однако могут быть "
"возвращены только экземпляры PyModule_Type, если PyModuleDef имеет значения, "
"отличные от NULL, ``m_traverse``, ``m_clear``, ``m_free``; ненулевой "
"``m_size``; или слоты, отличные от ``Py_mod_create``."

#: ../../c-api/module.rst:319
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"Указывает функцию, которая вызывается для *выполнения* модуля. Это "
"эквивалентно выполнению кода модуля Python: обычно эта функция добавляет в "
"модуль классы и константы. Сигнатура функции:"

#: ../../c-api/module.rst:328
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"Если указано несколько слотов Py_mod_exec, они обрабатываются в том порядке, "
"в котором они появляются в массиве *m_slots*."

#: ../../c-api/module.rst:333 ../../c-api/module.rst:366
msgid "Specifies one of the following values:"
msgstr "Указывает одно из следующих значений:"

#: ../../c-api/module.rst:339
msgid "The module does not support being imported in subinterpreters."
msgstr "Модуль не поддерживает импорт в субинтерпретаторы."

#: ../../c-api/module.rst:343
msgid ""
"The module supports being imported in subinterpreters, but only when they "
"share the main interpreter's GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"Модуль поддерживает импорт в подинтерпретаторы, но только если они "
"используют GIL основного интерпретатора. (См. :ref:`isolating-extensions-"
"howto`.)"

#: ../../c-api/module.rst:349
msgid ""
"The module supports being imported in subinterpreters, even when they have "
"their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""
"Модуль поддерживает импорт в субинтерпретаторы, даже если у них есть "
"собственный GIL. (См. :ref:`isolating-extensions-howto`.)"

#: ../../c-api/module.rst:353
msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr ""
"Этот слот определяет, завершится ли импорт этого модуля в субинтерпретаторе "
"неудачно."

#: ../../c-api/module.rst:356
msgid ""
"Multiple ``Py_mod_multiple_interpreters`` slots may not be specified in one "
"module definition."
msgstr ""
"Несколько слотов Py_mod_multiple_interpreters не могут быть указаны в одном "
"определении модуля."

#: ../../c-api/module.rst:359
msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import machinery "
"defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."
msgstr ""
"Если ``Py_mod_multiple_interpreters`` не указан, механизм импорта по "
"умолчанию будет ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."

#: ../../c-api/module.rst:372
msgid ""
"The module depends on the presence of the global interpreter lock (GIL), and "
"may access global state without synchronization."
msgstr ""
"Модуль зависит от наличия глобальной блокировки интерпретатора (GIL) и может "
"получать доступ к глобальному состоянию без синхронизации."

#: ../../c-api/module.rst:377
msgid "The module is safe to run without an active GIL."
msgstr "Модуль безопасно запускать без активного GIL."

#: ../../c-api/module.rst:379
msgid ""
"This slot is ignored by Python builds not configured with :option:`--disable-"
"gil`.  Otherwise, it determines whether or not importing this module will "
"cause the GIL to be automatically enabled. See :ref:`whatsnew313-free-"
"threaded-cpython` for more detail."
msgstr ""
"Этот слот игнорируется сборками Python, не настроенными с помощью :option:`--"
"disable-gil`. В противном случае он определяет, приведет ли импорт этого "
"модуля к автоматическому включению GIL. Более подробную информацию смотрите "
"в :ref:`whatsnew313-free-threaded-cpython`."

#: ../../c-api/module.rst:384
msgid ""
"Multiple ``Py_mod_gil`` slots may not be specified in one module definition."
msgstr "В одном определении модуля нельзя указать несколько слотов Py_mod_gil."

#: ../../c-api/module.rst:386
msgid ""
"If ``Py_mod_gil`` is not specified, the import machinery defaults to "
"``Py_MOD_GIL_USED``."
msgstr ""
"Если ``Py_mod_gil`` не указан, механизм импорта по умолчанию использует "
"``Py_MOD_GIL_USED``."

#: ../../c-api/module.rst:395
msgid "Creating extension modules dynamically"
msgstr ""

#: ../../c-api/module.rst:397
msgid ""
"The following functions may be used to create a module outside of an "
"extension's :ref:`initialization function <extension-export-hook>`. They are "
"also used in :ref:`single-phase initialization <single-phase-"
"initialization>`."
msgstr ""

#: ../../c-api/module.rst:404
msgid ""
"Create a new module object, given the definition in *def*. This is a macro "
"that calls :c:func:`PyModule_Create2` with *module_api_version* set to :c:"
"macro:`PYTHON_API_VERSION`, or to :c:macro:`PYTHON_ABI_VERSION` if using "
"the :ref:`limited API <limited-c-api>`."
msgstr ""

#: ../../c-api/module.rst:412
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"Создайте новый объект модуля, учитывая определение в *def*, предполагая "
"версию API *module_api_version*. Если эта версия не соответствует версии "
"работающего интерпретатора, выдается :exc:`RuntimeWarning`."

#: ../../c-api/module.rst:418
msgid ""
"This function does not support slots. The :c:member:`~PyModuleDef.m_slots` "
"member of *def* must be ``NULL``."
msgstr ""

#: ../../c-api/module.rst:424
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"В большинстве случаев вместо этой функции следует использовать :c:func:"
"`PyModule_Create`; используйте это только в том случае, если вы уверены, что "
"вам это нужно."

#: ../../c-api/module.rst:429
msgid ""
"This macro calls :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :c:macro:`PYTHON_API_VERSION`, or to :c:macro:"
"`PYTHON_ABI_VERSION` if using the :ref:`limited API <limited-c-api>`."
msgstr ""

#: ../../c-api/module.rst:438
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""
"Создайте новый объект модуля, учитывая определение в *def* и ModuleSpec "
"*spec*, предполагая версию API *module_api_version*. Если эта версия не "
"соответствует версии работающего интерпретатора, выдается :exc:"
"`RuntimeWarning`."

#: ../../c-api/module.rst:445
msgid ""
"Note that this does not process execution slots (:c:data:`Py_mod_exec`). "
"Both ``PyModule_FromDefAndSpec`` and ``PyModule_ExecDef`` must be called to "
"fully initialize a module."
msgstr ""

#: ../../c-api/module.rst:451
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"В большинстве случаев вместо этой функции следует использовать :c:func:"
"`PyModule_FromDefAndSpec`; используйте это только в том случае, если вы "
"уверены, что вам это нужно."

#: ../../c-api/module.rst:458
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""
"Обработать любые слоты выполнения (:c:data:`Py_mod_exec`), указанные в *def*."

#: ../../c-api/module.rst:464
msgid "The C API version. Defined for backwards compatibility."
msgstr ""

#: ../../c-api/module.rst:466 ../../c-api/module.rst:473
msgid ""
"Currently, this constant is not updated in new Python versions, and is not "
"useful for versioning. This may change in the future."
msgstr ""

#: ../../c-api/module.rst:471
msgid "Defined as ``3`` for backwards compatibility."
msgstr ""

#: ../../c-api/module.rst:478
msgid "Support functions"
msgstr "Вспомогательные функции"

#: ../../c-api/module.rst:480
msgid ""
"The following functions are provided to help initialize a module state. They "
"are intended for a module's execution slots (:c:data:`Py_mod_exec`), the "
"initialization function for legacy :ref:`single-phase initialization <single-"
"phase-initialization>`, or code that creates modules dynamically."
msgstr ""

#: ../../c-api/module.rst:488
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"Добавьте объект в *модуль* как *имя*. Это удобная функция, которую можно "
"использовать из функции инициализации модуля."

#: ../../c-api/module.rst:491
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""
"В случае успеха верните ``0``. В случае ошибки вызвать исключение и вернуть "
"``-1``."

#: ../../c-api/module.rst:493 ../../c-api/module.rst:544
#: ../../c-api/module.rst:571
msgid "Example usage::"
msgstr "Пример использования::"

#: ../../c-api/module.rst:495
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    if (obj == NULL) {\n"
"        return -1;\n"
"    }\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_DECREF(obj);\n"
"    return res;\n"
" }"

#: ../../c-api/module.rst:507
msgid ""
"To be convenient, the function accepts ``NULL`` *value* with an exception "
"set. In this case, return ``-1`` and just leave the raised exception "
"unchanged."
msgstr ""
"Для удобства функция принимает ``NULL`` *value* с набором исключений. В этом "
"случае верните ``-1`` и просто оставьте вызванное исключение без изменений."

#: ../../c-api/module.rst:511
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""
"Пример также можно написать без явной проверки того, имеет ли *obj* значение "
"``NULL``::"

#: ../../c-api/module.rst:514
msgid ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"
msgstr ""
"static int\n"
"add_spam(PyObject *module, int value)\n"
"{\n"
"    PyObject *obj = PyLong_FromLong(value);\n"
"    int res = PyModule_AddObjectRef(module, \"spam\", obj);\n"
"    Py_XDECREF(obj);\n"
"    return res;\n"
" }"

#: ../../c-api/module.rst:523
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"Обратите внимание, что в этом случае вместо Py_DECREF() следует использовать "
"Py_XDECREF(), поскольку *obj* может иметь значение NULL."

#: ../../c-api/module.rst:526
msgid ""
"The number of different *name* strings passed to this function should be "
"kept small, usually by only using statically allocated strings as *name*. "
"For names that aren't known at compile time, prefer calling :c:func:"
"`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. For more "
"details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object."
msgstr ""
"Количество различных строк *name*, передаваемых в эту функцию, должно быть "
"небольшим, обычно за счет использования только статически выделенных строк в "
"качестве *name*. Для имен, которые неизвестны во время компиляции, "
"предпочтительнее вызывать :c:func:`PyUnicode_FromString` и :c:func:"
"`PyObject_SetAttr` напрямую. Для получения более подробной информации см. :c:"
"func:`PyUnicode_InternFromString`, который можно использовать внутри "
"компании для создания ключевого объекта."

#: ../../c-api/module.rst:539
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but \"steals\" a reference to "
"*value*. It can be called with a result of function that returns a new "
"reference without bothering to check its result or even saving it to a "
"variable."
msgstr ""
"Аналогично :c:func:`PyModule_AddObjectRef`, но \"крадет\" ссылку на *value*. "
"Его можно вызвать с результатом функции, которая возвращает новую ссылку, не "
"утруждая себя проверкой результата или даже сохранением его в переменной."

#: ../../c-api/module.rst:546
msgid ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"
msgstr ""
"if (PyModule_Add(module, \"spam\", PyBytes_FromString(value)) < 0) {\n"
"    goto error;\n"
"}"

#: ../../c-api/module.rst:555
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"Аналогично :c:func:`PyModule_AddObjectRef`, но в случае успеха крадет ссылку "
"на *value* (если возвращается ``0``)."

#: ../../c-api/module.rst:558
msgid ""
"The new :c:func:`PyModule_Add` or :c:func:`PyModule_AddObjectRef` functions "
"are recommended, since it is easy to introduce reference leaks by misusing "
"the :c:func:`PyModule_AddObject` function."
msgstr ""
"Рекомендуется использовать новые функции :c:func:`PyModule_Add` или :c:func:"
"`PyModule_AddObjectRef`, так как легко вызвать утечку ссылок при "
"неправильном использовании функции :c:func:`PyModule_AddObject`."

#: ../../c-api/module.rst:565
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr ""
"В отличие от других функций, которые крадут ссылки, PyModule_AddObject() "
"освобождает ссылку на *value* только **в случае успеха**."

#: ../../c-api/module.rst:568
msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_XDECREF` *value* manually on error."
msgstr ""
"Это означает, что его возвращаемое значение должно быть проверено, а "
"вызывающий код должен :c:func:`Py_XDECREF` *value* вручную в случае ошибки."

#: ../../c-api/module.rst:573
msgid ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."
msgstr ""
"PyObject *obj = PyBytes_FromString(value);\n"
"if (PyModule_AddObject(module, \"spam\", obj) < 0) {\n"
"    // If 'obj' is not NULL and PyModule_AddObject() failed,\n"
"    // 'obj' strong reference must be deleted with Py_XDECREF().\n"
"    // If 'obj' is NULL, Py_XDECREF() does nothing.\n"
"    Py_XDECREF(obj);\n"
"    goto error;\n"
"}\n"
"// PyModule_AddObject() stole a reference to obj:\n"
"// Py_XDECREF(obj) is not needed here."

#: ../../c-api/module.rst:586
msgid ":c:func:`PyModule_AddObject` is :term:`soft deprecated`."
msgstr ":c:func:`PyModule_AddObject` :term:`мягко устарел`."

#: ../../c-api/module.rst:591
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` with an "
"exception set on error, ``0`` on success."
msgstr ""
"Добавьте целочисленную константу в *module* как *name*. Эту удобную функцию "
"можно использовать из функции инициализации модуля. Возвращает ``-1`` с "
"установленным исключением в случае ошибки и ``0`` в случае успеха."

#: ../../c-api/module.rst:595
msgid ""
"This is a convenience function that calls :c:func:`PyLong_FromLong` and :c:"
"func:`PyModule_AddObjectRef`; see their documentation for details."
msgstr ""
"Это удобная функция, которая вызывает :c:func:`PyLong_FromLong` и :c:func:"
"`PyModule_AddObjectRef`; подробности см. в их документации."

#: ../../c-api/module.rst:601
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated. Return ``-1`` with an exception set on error, ``0`` "
"on success."
msgstr ""
"Добавьте строковую константу в *module* как *name*. Эту удобную функцию "
"можно использовать из функции инициализации модуля. Строка *value* должна "
"заканчиваться NULL. Возвращает ``-1`` с установленным исключением в случае "
"ошибки и ``0`` в случае успеха."

#: ../../c-api/module.rst:606
msgid ""
"This is a convenience function that calls :c:func:"
"`PyUnicode_InternFromString` and :c:func:`PyModule_AddObjectRef`; see their "
"documentation for details."
msgstr ""
"Это удобная функция, которая вызывает :c:func:`PyUnicode_InternFromString` "
"и :c:func:`PyModule_AddObjectRef`; подробности см. в их документации."

#: ../../c-api/module.rst:613
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` "
"with an exception set on error, ``0`` on success."
msgstr ""
"Добавьте константу int в *module*. Имя и значение взяты из *macro*. "
"Например, PyModule_AddIntMacro(module, AF_INET) добавляет константу int "
"*AF_INET* со значением *AF_INET* к *module*. Возвращает ``-1`` с "
"установленным исключением в случае ошибки и ``0`` в случае успеха."

#: ../../c-api/module.rst:621
msgid "Add a string constant to *module*."
msgstr "Добавьте строковую константу в *module*."

#: ../../c-api/module.rst:625
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Добавьте объект типа в *module*. Объект типа завершается внутренним вызовом :"
"c:func:`PyType_Ready`. Имя объекта типа берется из последнего компонента :c:"
"member:`~PyTypeObject.tp_name` после точки. Возвращает ``-1`` с "
"установленным исключением в случае ошибки и ``0`` в случае успеха."

#: ../../c-api/module.rst:635
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes)."
msgstr ""

#: ../../c-api/module.rst:641
msgid ""
"This function is called automatically when creating a module from "
"``PyModuleDef`` (such as when using :ref:`multi-phase-initialization`, "
"``PyModule_Create``, or ``PyModule_FromDefAndSpec``). Some module authors "
"may prefer defining functions in multiple :c:type:`PyMethodDef` arrays; in "
"that case they should call this function directly."
msgstr ""

#: ../../c-api/module.rst:652
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef`` (such as when "
"using :ref:`multi-phase-initialization`, ``PyModule_Create``, or "
"``PyModule_FromDefAndSpec``)."
msgstr ""

#: ../../c-api/module.rst:661
msgid ""
"Indicate that *module* does or does not support running without the global "
"interpreter lock (GIL), using one of the values from :c:macro:`Py_mod_gil`. "
"It must be called during *module*'s initialization function when using :ref:"
"`single-phase-initialization`. If this function is not called during module "
"initialization, the import machinery assumes the module does not support "
"running without the GIL. This function is only available in Python builds "
"configured with :option:`--disable-gil`. Return ``-1`` with an exception set "
"on error, ``0`` on success."
msgstr ""

#: ../../c-api/module.rst:675
msgid "Module lookup (single-phase initialization)"
msgstr ""

#: ../../c-api/module.rst:677
msgid ""
"The legacy :ref:`single-phase initialization <single-phase-initialization>` "
"initialization scheme creates singleton modules that can be looked up in the "
"context of the current interpreter. This allows the module object to be "
"retrieved later with only a reference to the module definition."
msgstr ""

#: ../../c-api/module.rst:682
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"Эти функции не будут работать с модулями, созданными с использованием "
"многофазной инициализации, поскольку из одного определения можно создать "
"несколько таких модулей."

#: ../../c-api/module.rst:687
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"Возвращает объект модуля, созданный из *def* для текущего интерпретатора. "
"Этот метод требует, чтобы объект модуля был заранее прикреплен к состоянию "
"интерпретатора с помощью :c:func:`PyState_AddModule`. В случае, если "
"соответствующий объект модуля не найден или еще не присоединен к состоянию "
"интерпретатора, он возвращает NULL."

#: ../../c-api/module.rst:694
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"Прикрепляет объект модуля, переданный функции, к состоянию интерпретатора. "
"Это позволяет объекту модуля быть доступным через :c:func:"
"`PyState_FindModule`."

#: ../../c-api/module.rst:697
msgid "Only effective on modules created using single-phase initialization."
msgstr ""
"Действует только на модулях, созданных с использованием однофазной "
"инициализации."

#: ../../c-api/module.rst:699
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module "
"that uses :ref:`single-phase initialization <single-phase-initialization>`, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""

#: ../../c-api/module.rst:708
msgid ""
"If a module was attached previously using the same *def*, it is replaced by "
"the new *module*."
msgstr ""

#: ../../c-api/module.rst:711 ../../c-api/module.rst:722
msgid "The caller must have an :term:`attached thread state`."
msgstr ""

#: ../../c-api/module.rst:713
msgid "Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Возвращает ``-1`` с установленным исключением в случае ошибки и ``0`` в "
"случае успеха."

#: ../../c-api/module.rst:719
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""
"Удаляет объект модуля, созданный из *def*, из состояния интерпретатора. "
"Возвращает ``-1`` с установленным исключением в случае ошибки и ``0`` в "
"случае успеха."

#: ../../c-api/module.rst:8
msgid "object"
msgstr "объект"

#: ../../c-api/module.rst:8
msgid "module"
msgstr "модуль"

#: ../../c-api/module.rst:13
msgid "ModuleType (in module types)"
msgstr "ModuleType (в типах модулей)"

#: ../../c-api/module.rst:33 ../../c-api/module.rst:77
msgid "__name__ (module attribute)"
msgstr "__name__ (атрибут модуля)"

#: ../../c-api/module.rst:33
msgid "__doc__ (module attribute)"
msgstr "__doc__ (атрибут модуля)"

#: ../../c-api/module.rst:33 ../../c-api/module.rst:108
msgid "__file__ (module attribute)"
msgstr "__file__ (атрибут модуля)"

#: ../../c-api/module.rst:33
msgid "__package__ (module attribute)"
msgstr "__package__ (атрибут модуля)"

#: ../../c-api/module.rst:33
msgid "__loader__ (module attribute)"
msgstr "__loader__ (атрибут модуля)"

#: ../../c-api/module.rst:63
msgid "__dict__ (module attribute)"
msgstr "__dict__ (атрибут модуля)"

#: ../../c-api/module.rst:77 ../../c-api/module.rst:108
msgid "SystemError (built-in exception)"
msgstr "SystemError (встроенное исключение)"
