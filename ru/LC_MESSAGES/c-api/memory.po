# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-17 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "Управление памятью"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "Обзор"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Управление памятью в Python включает в себя частную кучу, содержащую все "
"объекты Python и структуры данных. Управление этой частной кучей "
"осуществляется изнутри *менеджером памяти Python*. Диспетчер памяти Python "
"имеет различные компоненты, которые отвечают за различные аспекты "
"динамического управления хранилищем, такие как совместное использование, "
"сегментация, предварительное выделение или кэширование."

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"На самом низком уровне необработанный распределитель памяти гарантирует, что "
"в частной куче достаточно места для хранения всех данных, связанных с "
"Python, путем взаимодействия с диспетчером памяти операционной системы. "
"Помимо необработанного распределителя памяти, несколько объектно-"
"ориентированных распределителей работают в одной куче и реализуют различные "
"политики управления памятью, адаптированные к особенностям каждого типа "
"объекта. Например, целочисленные объекты в куче управляются иначе, чем "
"строки, кортежи или словари, поскольку целые числа подразумевают другие "
"требования к хранению и компромиссы между скоростью и пространством. Таким "
"образом, диспетчер памяти Python делегирует часть работы объектно-"
"ориентированным распределителям, но гарантирует, что последние работают в "
"пределах частной кучи."

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other "
"internal buffers is performed on demand by the Python memory manager through "
"the Python/C API functions listed in this document."
msgstr ""
"Важно понимать, что управление кучей Python осуществляет сам интерпретатор и "
"что пользователь не имеет над ней контроля, даже если он регулярно "
"манипулирует указателями объектов на блоки памяти внутри этой кучи. "
"Выделение кучи для объектов Python и других внутренних буферов выполняется "
"по требованию диспетчером памяти Python с помощью функций API Python/C, "
"перечисленных в этом документе."

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on "
"Python objects with the functions exported by the C library: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  This will "
"result in  mixed calls between the C allocator and the Python memory manager "
"with fatal consequences, because they implement different algorithms and "
"operate on different heaps.  However, one may safely allocate and release "
"memory blocks with the C library allocator for individual purposes, as shown "
"in the following example::"
msgstr ""
"Чтобы избежать повреждения памяти, авторам расширений никогда не следует "
"пытаться работать с объектами Python с помощью функций, экспортируемых "
"библиотекой C: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` и :c:"
"func:`free`. Это приведет к смешанным вызовам между распределителем C и "
"диспетчером памяти Python с фатальными последствиями, поскольку они "
"реализуют разные алгоритмы и работают с разными кучами. Однако можно "
"безопасно выделять и освобождать блоки памяти с помощью распределителя "
"библиотеки C для индивидуальных целей, как показано в следующем примере:"

#: ../../c-api/memory.rst:58
msgid ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Do some I/O operation involving buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Do some I/O operation involving buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"return res;"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"В этом примере запрос памяти для буфера ввода-вывода обрабатывается "
"распределителем библиотеки C. Диспетчер памяти Python участвует только в "
"выделении возвращаемого в результате объекта байтов."

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used "
"exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"Однако в большинстве ситуаций рекомендуется выделять память из кучи Python "
"именно потому, что последняя находится под контролем диспетчера памяти "
"Python. Например, это требуется, когда интерпретатор расширяется новыми "
"типами объектов, написанными на C. Другой причиной использования кучи Python "
"является желание *информировать* менеджер памяти Python о потребностях "
"модуля расширения в памяти. Даже когда запрошенная память используется "
"исключительно для внутренних, весьма специфических целей, делегирование всех "
"запросов к памяти диспетчеру памяти Python приводит к тому, что "
"интерпретатор получает более точное представление о своем объеме памяти в "
"целом. Следовательно, при определенных обстоятельствах диспетчер памяти "
"Python может запускать или не запускать соответствующие действия, такие как "
"сбор мусора, сжатие памяти или другие профилактические процедуры. Обратите "
"внимание, что при использовании распределителя библиотеки C, как показано в "
"предыдущем примере, выделенная память для буфера ввода-вывода полностью "
"выходит за рамки диспетчера памяти Python."

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the "
"memory allocators used by Python."
msgstr ""
"Переменная среды :envvar:`PYTHONMALLOC` может использоваться для настройки "
"распределителей памяти, используемых Python."

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"Переменную среды :envvar:`PYTHONMALLOCSTATS` можно использовать для печати "
"статистики :ref:`распределителя памяти pymalloc <pymalloc>` каждый раз, "
"когда создается новая арена объекта pymalloc, а также при завершении работы."

#: ../../c-api/memory.rst:96
msgid "Allocator Domains"
msgstr "Домены распределителя"

#: ../../c-api/memory.rst:100
msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific "
"details on how every domain allocates memory or what internal functions each "
"domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`here <default-memory-"
"allocators>`. There is no hard requirement to use the memory returned by the "
"allocation functions belonging to a given domain for only the purposes "
"hinted by that domain (although this is the recommended practice). For "
"example, one could use the memory returned by :c:func:`PyMem_RawMalloc` for "
"allocating Python objects or the memory returned by :c:func:"
"`PyObject_Malloc` for allocating memory for buffers."
msgstr ""
"Все функции распределения принадлежат одному из трех разных «доменов» (см. "
"также :c:type:`PyMemAllocatorDomain`). Эти домены представляют разные "
"стратегии распределения и оптимизированы для разных целей. Конкретные "
"подробности о том, как каждый домен распределяет память или какие внутренние "
"функции вызывает каждый домен, считаются деталями реализации, но для целей "
"отладки упрощенную таблицу можно найти по адресу :ref:`здесь <default-memory-"
"allocators>`. Не существует жесткого требования использовать память, "
"возвращаемую функциями распределения, принадлежащими данному домену, только "
"для целей, указанных в этом домене (хотя это рекомендуемая практика). "
"Например, можно использовать память, возвращаемую :c:func:`PyMem_RawMalloc`, "
"для выделения объектов Python, или память, возвращаемую :c:func:"
"`PyObject_Malloc`, для выделения памяти для буферов."

#: ../../c-api/memory.rst:112
msgid "The three allocation domains are:"
msgstr "Три домена распределения:"

#: ../../c-api/memory.rst:114
msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without the :term:`GIL`. The memory is requested "
"directly to the system."
msgstr ""
"Необработанный домен: предназначен для выделения памяти для буферов памяти "
"общего назначения, где выделение *должно* идти системному распределителю или "
"где распределитель может работать без :term:`GIL`. Память запрашивается "
"непосредственно в системе."

#: ../../c-api/memory.rst:119
msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"the :term:`GIL` held. The memory is taken from the Python private heap."
msgstr ""
"Домен «Mem»: предназначен для выделения памяти для буферов Python и буферов "
"памяти общего назначения, где выделение должно выполняться с удержанием :"
"term:`GIL`. Память берется из частной кучи Python."

#: ../../c-api/memory.rst:123
msgid ""
"Object domain: intended for allocating memory belonging to Python objects. "
"The memory is taken from the Python private heap."
msgstr ""
"Домен объекта: предназначен для выделения памяти, принадлежащей объектам "
"Python. Память берется из частной кучи Python."

#: ../../c-api/memory.rst:126
msgid ""
"When freeing memory previously allocated by the allocating functions "
"belonging to a given domain,the matching specific deallocating functions "
"must be used. For example, :c:func:`PyMem_Free` must be used to free memory "
"allocated using :c:func:`PyMem_Malloc`."
msgstr ""
"При освобождении памяти, ранее выделенной функциями выделения, "
"принадлежащими данному домену, необходимо использовать соответствующие "
"конкретные функции освобождения. Например, :c:func:`PyMem_Free` необходимо "
"использовать для освобождения памяти, выделенной с помощью :c:func:"
"`PyMem_Malloc`."

#: ../../c-api/memory.rst:131
msgid "Raw Memory Interface"
msgstr "Интерфейс необработанной памяти"

#: ../../c-api/memory.rst:133
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""
"Следующие наборы функций являются оболочками системного распределителя. Эти "
"функции потокобезопасны, поэтому GIL <глобальная блокировка интерпретатора> "
"удерживать не требуется."

#: ../../c-api/memory.rst:137
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the "
"following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when "
"requesting zero bytes."
msgstr ""
"Распределитель необработанной памяти по умолчанию <default-memory-"
"allocators>` использует следующие функции: :c:func:`malloc`, :c:func:"
"`calloc`, :c:func:`realloc` и : c:func:`!free`; вызовите ``malloc(1)`` (или "
"``calloc(1, 1)``) при запросе нулевых байтов."

#: ../../c-api/memory.rst:146 ../../c-api/memory.rst:217
#: ../../c-api/memory.rst:325
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"Выделяет *n* байтов и возвращает указатель типа :c:expr:`void*` на "
"выделенную память или ``NULL``, если запрос не выполнен."

#: ../../c-api/memory.rst:149
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Запрос нулевых байтов возвращает отдельный указатель, отличный от NULL, если "
"это возможно, как если бы вместо этого был вызван PyMem_RawMalloc(1)``. "
"Память не будет инициализирована каким-либо образом."

#: ../../c-api/memory.rst:156 ../../c-api/memory.rst:227
#: ../../c-api/memory.rst:335
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"Выделяет элементы *nelem*, размер каждого из которых в байтах равен "
"*elsize*, и возвращает указатель типа :c:expr:`void*` на выделенную память "
"или ``NULL``, если запрос не выполнен. Память инициализируется нулями."

#: ../../c-api/memory.rst:160
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запрос нулевых элементов или элементов размером нуль байт возвращает "
"отдельный указатель, отличный от NULL, если это возможно, как если бы вместо "
"этого был вызван PyMem_RawCalloc(1, 1)``."

#: ../../c-api/memory.rst:169 ../../c-api/memory.rst:240
#: ../../c-api/memory.rst:348
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Изменяет размер блока памяти, на который указывает *p*, до *n* байт. "
"Содержимое не изменится до минимума старого и нового размеров."

#: ../../c-api/memory.rst:172
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Если *p* равно NULL, вызов эквивалентен PyMem_RawMalloc(n)``; в противном "
"случае, если *n* равно нулю, размер блока памяти изменяется, но не "
"освобождается, а возвращаемый указатель не равен NULL."

#: ../../c-api/memory.rst:176
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:func:"
"`PyMem_RawCalloc`."
msgstr ""
"Если *p* не равно ``NULL``, оно должно быть возвращено предыдущим вызовом :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` или :c:func:"
"`PyMem_RawCalloc`."

#: ../../c-api/memory.rst:180
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Если запрос завершается неудачей, :c:func:`PyMem_RawRealloc` возвращает "
"``NULL`` и *p* остается действительным указателем на предыдущую область "
"памяти."

#: ../../c-api/memory.rst:186
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:"
"func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Освобождает блок памяти, на который указывает *p*, который должен был быть "
"возвращен предыдущим вызовом :c:func:`PyMem_RawMalloc`, :c:func:"
"`PyMem_RawRealloc` или :c:func:`PyMem_RawCalloc`. В противном случае или "
"если PyMem_RawFree(p) был вызван ранее, произойдет неопределенное поведение."

#: ../../c-api/memory.rst:191 ../../c-api/memory.rst:261
#: ../../c-api/memory.rst:369
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Если *p* равно NULL, никакая операция не выполняется."

#: ../../c-api/memory.rst:197
msgid "Memory Interface"
msgstr "Интерфейс памяти"

#: ../../c-api/memory.rst:199 ../../c-api/memory.rst:305
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating "
"and releasing memory from the Python heap."
msgstr ""
"Следующие наборы функций, созданные по образцу стандарта ANSI C, но "
"определяющие поведение при запросе нулевых байтов, доступны для выделения и "
"освобождения памяти из кучи Python."

#: ../../c-api/memory.rst:203
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"Распределитель памяти по умолчанию <default-memory-allocators>` использует "
"распределитель памяти :ref:`pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:208 ../../c-api/memory.rst:320
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr ""
"При использовании этих функций должен сохраняться :term:`GIL <глобальная "
"блокировка интерпретатора>`."

#: ../../c-api/memory.rst:213
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"Распределителем по умолчанию теперь является pymalloc вместо system :c:func:"
"`malloc`."

#: ../../c-api/memory.rst:220
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"Запрос нулевых байтов возвращает отдельный указатель, отличный от NULL, если "
"это возможно, как если бы вместо этого был вызван PyMem_Malloc(1)``. Память "
"не будет инициализирована каким-либо образом."

#: ../../c-api/memory.rst:231
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запрос нулевых элементов или элементов размером нуль байт возвращает "
"отдельный указатель, отличный от NULL, если это возможно, как если бы вместо "
"этого был вызван PyMem_Calloc(1, 1)``."

#: ../../c-api/memory.rst:243
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Если *p* равно ``NULL``, вызов эквивалентен ``PyMem_Malloc(n)``; в противном "
"случае, если *n* равно нулю, размер блока памяти изменяется, но не "
"освобождается, а возвращаемый указатель не равен NULL."

#: ../../c-api/memory.rst:247
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"Если *p* не равно ``NULL``, оно должно быть возвращено предыдущим вызовом :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` или :c:func:`PyMem_Calloc`."

#: ../../c-api/memory.rst:250
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Если запрос завершается неудачей, :c:func:`PyMem_Realloc` возвращает "
"``NULL`` и *p* остается действительным указателем на предыдущую область "
"памяти."

#: ../../c-api/memory.rst:256
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:"
"`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called before, "
"undefined behavior occurs."
msgstr ""
"Освобождает блок памяти, на который указывает *p*, который должен был быть "
"возвращен предыдущим вызовом :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` "
"или :c:func:`PyMem_Calloc`. В противном случае или если PyMem_Free(p) был "
"вызван ранее, произойдет неопределенное поведение."

#: ../../c-api/memory.rst:263
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that "
"*TYPE* refers to any C type."
msgstr ""
"Для удобства предусмотрены следующие типизированные макросы. Обратите "
"внимание, что *TYPE* ​​относится к любому типу C."

#: ../../c-api/memory.rst:269
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to ``TYPE*``.  The memory will not have "
"been initialized in any way."
msgstr ""
"То же, что :c:func:`PyMem_Malloc`, но выделяет ``(n * sizeof(TYPE))`` байт "
"памяти. Возвращает указатель, приведенный к ``TYPE*``. Память не будет "
"инициализирована каким-либо образом."

#: ../../c-api/memory.rst:276
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to ``TYPE*``. On return, *p* "
"will be a pointer to the new memory area, or ``NULL`` in the event of "
"failure."
msgstr ""
"То же, что и :c:func:`PyMem_Realloc`, но размер блока памяти изменяется до "
"``(n * sizeof(TYPE))`` байт. Возвращает указатель, приведенный к ``TYPE*``. "
"При возврате *p* будет указателем на новую область памяти или NULL в случае "
"сбоя."

#: ../../c-api/memory.rst:281
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original "
"value of *p* to avoid losing memory when handling errors."
msgstr ""
"Это макрос препроцессора C; *p* всегда переназначается. Сохраните исходное "
"значение *p*, чтобы избежать потери памяти при обработке ошибок."

#: ../../c-api/memory.rst:287
msgid "Same as :c:func:`PyMem_Free`."
msgstr "То же, что :c:func:`PyMem_Free`."

#: ../../c-api/memory.rst:289
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Кроме того, предусмотрены следующие наборы макросов для прямого вызова "
"распределителя памяти Python без использования функций C API, перечисленных "
"выше. Однако обратите внимание, что их использование не обеспечивает "
"двоичную совместимость между версиями Python и поэтому не рекомендуется в "
"модулях расширения."

#: ../../c-api/memory.rst:294
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

#: ../../c-api/memory.rst:295
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

#: ../../c-api/memory.rst:296
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:297
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

#: ../../c-api/memory.rst:298
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:299
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:303
msgid "Object allocators"
msgstr "Распределители объектов"

#: ../../c-api/memory.rst:310
msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"Нет никакой гарантии, что память, возвращаемая этими распределителями, может "
"быть успешно преобразована в объект Python при перехвате функций выделения "
"памяти в этом домене методами, описанными в разделе «Настройка "
"распределителей памяти <customize-memory-allocators>»."

#: ../../c-api/memory.rst:315
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"Распределитель объектов по умолчанию <default-memory-allocators>` использует "
"распределитель памяти :ref:`pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:328
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Запрос нулевых байтов возвращает отдельный указатель, отличный от NULL, если "
"это возможно, как если бы вместо этого был вызван PyObject_Malloc(1)``. "
"Память не будет инициализирована каким-либо образом."

#: ../../c-api/memory.rst:339
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запрос нулевых элементов или элементов размером нуль байт возвращает "
"отдельный указатель, отличный от NULL, если это возможно, как если бы вместо "
"этого был вызван PyObject_Calloc(1, 1)``."

#: ../../c-api/memory.rst:351
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Если *p* равно ``NULL``, вызов эквивалентен ``PyObject_Malloc(n)``; в "
"противном случае, если *n* равно нулю, размер блока памяти изменяется, но не "
"освобождается, а возвращаемый указатель не равен NULL."

#: ../../c-api/memory.rst:355
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:func:"
"`PyObject_Calloc`."
msgstr ""
"Если *p* не равно ``NULL``, оно должно быть возвращено предыдущим вызовом :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` или :c:func:"
"`PyObject_Calloc`."

#: ../../c-api/memory.rst:358
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Если запрос завершается неудачно, :c:func:`PyObject_Realloc` возвращает "
"``NULL`` и *p* остается действительным указателем на предыдущую область "
"памяти."

#: ../../c-api/memory.rst:364
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:"
"func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Освобождает блок памяти, на который указывает *p*, который должен был быть "
"возвращен предыдущим вызовом :c:func:`PyObject_Malloc`, :c:func:"
"`PyObject_Realloc` или :c:func:`PyObject_Calloc`. В противном случае или "
"если PyObject_Free(p) был вызван ранее, произойдет неопределенное поведение."

#: ../../c-api/memory.rst:375
msgid "Default Memory Allocators"
msgstr "Распределители памяти по умолчанию"

#: ../../c-api/memory.rst:377
msgid "Default memory allocators:"
msgstr "Распределители памяти по умолчанию:"

#: ../../c-api/memory.rst:380
msgid "Configuration"
msgstr "Конфигурация"

#: ../../c-api/memory.rst:380
msgid "Name"
msgstr "Имя"

#: ../../c-api/memory.rst:380
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:380
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:380
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:382
msgid "Release build"
msgstr "Сборка релиза"

#: ../../c-api/memory.rst:382
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:382 ../../c-api/memory.rst:384
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:382
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:383
msgid "Debug build"
msgstr "Отладочная сборка"

#: ../../c-api/memory.rst:383
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:383 ../../c-api/memory.rst:385
msgid "``malloc`` + debug"
msgstr "``malloc`` + отладка"

#: ../../c-api/memory.rst:383
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + отладка"

#: ../../c-api/memory.rst:384
msgid "Release build, without pymalloc"
msgstr "Выпуск сборки без pymalloc"

#: ../../c-api/memory.rst:384
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:385
msgid "Debug build, without pymalloc"
msgstr "Отладочная сборка без pymalloc"

#: ../../c-api/memory.rst:385
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:388
msgid "Legend:"
msgstr "Легенда:"

#: ../../c-api/memory.rst:390
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "Имя: значение для переменной среды :envvar:`PYTHONMALLOC`."

#: ../../c-api/memory.rst:391
msgid ""
"``malloc``: system allocators from the standard C library, C functions: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: системные распределители из стандартной библиотеки C, функции "
"C: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` и :c:func:` "
"бесплатно`."

#: ../../c-api/memory.rst:393
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`pymalloc распределитель памяти <pymalloc>`."

#: ../../c-api/memory.rst:394
msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"«+ debug»: с :ref:`перехватчиками отладки на распределителях памяти Python "
"<pymem-debug-hooks>`."

#: ../../c-api/memory.rst:396
msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr ""
"«Отладочная сборка»: :ref:`Сборка Python в режиме отладки <debug-build>`."

#: ../../c-api/memory.rst:401
msgid "Customize Memory Allocators"
msgstr "Настройка распределителей памяти"

#: ../../c-api/memory.rst:407
msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Структура, используемая для описания распределителя блоков памяти. Структура "
"имеет следующие поля:"

#: ../../c-api/memory.rst:411 ../../c-api/memory.rst:658
msgid "Field"
msgstr "Поле"

#: ../../c-api/memory.rst:411 ../../c-api/memory.rst:658
msgid "Meaning"
msgstr "Значение"

#: ../../c-api/memory.rst:413 ../../c-api/memory.rst:660
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:413 ../../c-api/memory.rst:660
msgid "user context passed as first argument"
msgstr "пользовательский контекст, передаваемый в качестве первого аргумента"

#: ../../c-api/memory.rst:415
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:415
msgid "allocate a memory block"
msgstr "выделить блок памяти"

#: ../../c-api/memory.rst:417
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:417
msgid "allocate a memory block initialized with zeros"
msgstr "выделить блок памяти, инициализированный нулями"

#: ../../c-api/memory.rst:420
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:420
msgid "allocate or resize a memory block"
msgstr "выделить или изменить размер блока памяти"

#: ../../c-api/memory.rst:422
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:422
msgid "free a memory block"
msgstr "освободить блок памяти"

#: ../../c-api/memory.rst:425
msgid ""
"The :c:type:`!PyMemAllocator` structure was renamed to :c:type:"
"`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"Структура :c:type:`!PyMemAllocator` была переименована в :c:type:"
"`PyMemAllocatorEx` и было добавлено новое поле ``calloc``."

#: ../../c-api/memory.rst:432
msgid "Enum used to identify an allocator domain. Domains:"
msgstr ""
"Перечисление, используемое для идентификации домена распределителя. Домены:"

#: ../../c-api/memory.rst:438 ../../c-api/memory.rst:447
#: ../../c-api/memory.rst:456
msgid "Functions:"
msgstr "Функции:"

#: ../../c-api/memory.rst:440
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:441
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:442
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:443
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:449
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:450
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:451
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:452
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:458
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:459
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:460
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:461
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:465
msgid "Get the memory block allocator of the specified domain."
msgstr "Получите распределитель блоков памяти указанного домена."

#: ../../c-api/memory.rst:470
msgid "Set the memory block allocator of the specified domain."
msgstr "Установите распределитель блоков памяти указанного домена."

#: ../../c-api/memory.rst:472
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"Новый распределитель должен возвращать отдельный указатель, отличный от "
"NULL, при запросе нулевых байтов."

#: ../../c-api/memory.rst:475
msgid ""
"For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""
"Для домена :c:macro:`PYMEM_DOMAIN_RAW` распределитель должен быть "
"потокобезопасным: :term:`GIL <глобальная блокировка интерпретатора>` не "
"удерживается при вызове распределителя."

#: ../../c-api/memory.rst:479
msgid ""
"For the remaining domains, the allocator must also be thread-safe: the "
"allocator may be called in different interpreters that do not share a "
"``GIL``."
msgstr ""
"Для остальных доменов распределитель также должен быть потокобезопасным: "
"распределитель может вызываться в разных интерпретаторах, которые не "
"используют общий ``GIL``."

#: ../../c-api/memory.rst:483
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the "
"debug hooks on top on the new allocator."
msgstr ""
"Если новый распределитель не является перехватчиком (не вызывает предыдущий "
"распределитель), необходимо вызвать функцию :c:func:`PyMem_SetupDebugHooks`, "
"чтобы переустановить отладочные перехватчики поверх нового распределителя."

#: ../../c-api/memory.rst:487
msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""
"См. также :c:member:`PyPreConfig.allocator` и :ref:`Предварительная "
"инициализация Python с помощью PyPreConfig <c-preinit>`."

#: ../../c-api/memory.rst:492
msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ":c:func:`PyMem_SetAllocator` имеет следующий контракт:"

#: ../../c-api/memory.rst:494
msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before :c:func:"
"`Py_InitializeFromConfig` to install a custom memory allocator. There are no "
"restrictions over the installed allocator other than the ones imposed by the "
"domain (for instance, the Raw Domain allows the allocator to be called "
"without the GIL held). See :ref:`the section on allocator domains <allocator-"
"domains>` for more information."
msgstr ""
"Его можно вызвать после :c:func:`Py_PreInitialize` и до :c:func:"
"`Py_InitializeFromConfig` для установки специального распределителя памяти. "
"Для установленного распределителя нет никаких ограничений, кроме тех, "
"которые налагаются доменом (например, необработанный домен позволяет "
"вызывать распределитель без удержания GIL). См. :ref:`раздел о доменах-"
"распределителях <allocator-domains>` для получения дополнительной информации."

#: ../../c-api/memory.rst:502
msgid ""
"If called after Python has finish initializing (after :c:func:"
"`Py_InitializeFromConfig` has been called) the allocator **must** wrap the "
"existing allocator. Substituting the current allocator for some other "
"arbitrary one is **not supported**."
msgstr ""
"Если вызывается после завершения инициализации Python (после вызова :c:func:"
"`Py_InitializeFromConfig`), распределитель **должен** обернуть существующий "
"распределитель. Замена текущего распределителя на какой-либо другой "
"произвольный **не поддерживается**."

#: ../../c-api/memory.rst:507
msgid "All allocators must be thread-safe."
msgstr "Все распределители должны быть потокобезопасными."

#: ../../c-api/memory.rst:513
msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>` "
"to detect memory errors."
msgstr ""
"Установите отладочные перехватчики в распределителях памяти Python <pymem-"
"debug-hooks>` для обнаружения ошибок памяти."

#: ../../c-api/memory.rst:520
msgid "Debug hooks on the Python memory allocators"
msgstr "Обработчики отладки распределителей памяти Python"

#: ../../c-api/memory.rst:522
msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the :c:func:"
"`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"Когда :ref:`Python собран в режиме отладки <debug-build>`, функция :c:func:"
"`PyMem_SetupDebugHooks` вызывается в :ref:`Python preinitialization <c-"
"preinit>` для настройки отладочных перехватчиков на Python распределители "
"памяти для обнаружения ошибок памяти."

#: ../../c-api/memory.rst:527
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug "
"hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
"Переменная среды :envvar:`PYTHONMALLOC` может использоваться для установки "
"перехватчиков отладки в Python, скомпилированном в режиме выпуска (например: "
"``PYTHONMALLOC=debug``)."

#: ../../c-api/memory.rst:530
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
"Функцию :c:func:`PyMem_SetupDebugHooks` можно использовать для установки "
"перехватчиков отладки после вызова :c:func:`PyMem_SetAllocator`."

#: ../../c-api/memory.rst:533
msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"Эти перехватчики отладки заполняют динамически выделяемые блоки памяти "
"специальными, распознаваемыми битовыми шаблонами. Вновь выделенная память "
"заполняется байтом ``0xCD`` (``PYMEM_CLEANBYTE``), освобожденная память "
"заполняется байтом ``0xDD`` (``PYMEM_DEADBYTE``). Блоки памяти окружены "
"«запрещенными байтами», заполненными байтом ``0xFD`` "
"(``PYMEM_FORBIDDENBYTE``). Строки этих байтов вряд ли будут действительными "
"адресами, числами с плавающей запятой или строками ASCII."

#: ../../c-api/memory.rst:540
msgid "Runtime checks:"
msgstr "Проверки во время выполнения:"

#: ../../c-api/memory.rst:542
msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"Обнаружение нарушений API. Например, определите, вызывается ли :c:func:"
"`PyObject_Free` в блоке памяти, выделенном :c:func:`PyMem_Malloc`."

#: ../../c-api/memory.rst:544
msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "Обнаружение записи до начала буфера (переполнение буфера)."

#: ../../c-api/memory.rst:545
msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "Обнаружение записи после окончания буфера (переполнение буфера)."

#: ../../c-api/memory.rst:546
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) "
"and :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are "
"called."
msgstr ""
"Убедитесь, что :term:`GIL <глобальная блокировка интерпретатора>` "
"удерживается, когда функции распределения :c:macro:`PYMEM_DOMAIN_OBJ` "
"(например: :c:func:`PyObject_Malloc`) и :c:macro:`PYMEM_DOMAIN_MEM` "
"( например: :c:func:`PyMem_Malloc`) вызываются домены."

#: ../../c-api/memory.rst:551
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the "
"memory block was traced."
msgstr ""
"В случае ошибки перехватчики отладки используют модуль :mod:`tracemalloc`, "
"чтобы получить обратную трассировку, где был выделен блок памяти. Обратная "
"трассировка отображается только в том случае, если :mod:`tracemalloc` "
"отслеживает распределение памяти Python и блок памяти был отслежен."

#: ../../c-api/memory.rst:556
msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"Пусть *S* = ``sizeof(size_t)``. Байты ``2*S`` добавляются на каждом конце "
"каждого запрошенного блока из *N* байтов. Расположение памяти такое, где p "
"представляет адрес, возвращаемый функцией, подобной malloc или realloc "
"(``p[i:j]`` означает фрагмент байтов из ``*(p+i)`` включительно до "
"``*(p+j)`` исключая, обратите внимание, что обработка отрицательных индексов "
"отличается от среза Python):"

#: ../../c-api/memory.rst:562
msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]``"

#: ../../c-api/memory.rst:563
msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"Первоначально запрошенное количество байтов. Это size_t с прямым порядком "
"байтов (легче читается в дампе памяти)."

#: ../../c-api/memory.rst:565
msgid "``p[-S]``"
msgstr "``p[-S]``"

#: ../../c-api/memory.rst:566
msgid "API identifier (ASCII character):"
msgstr "Идентификатор API (символ ASCII):"

#: ../../c-api/memory.rst:568
msgid "``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` для :c:macro:`PYMEM_DOMAIN_RAW`."

#: ../../c-api/memory.rst:569
msgid "``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`."
msgstr "``'m'`` для :c:macro:`PYMEM_DOMAIN_MEM`."

#: ../../c-api/memory.rst:570
msgid "``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` для :c:macro:`PYMEM_DOMAIN_OBJ`."

#: ../../c-api/memory.rst:572
msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

#: ../../c-api/memory.rst:573
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""
"Копии PYMEM_FORBIDDENBYTE. Используется для перехвата операций записи и "
"чтения."

#: ../../c-api/memory.rst:575
msgid "``p[0:N]``"
msgstr "``p[0:N]``"

#: ../../c-api/memory.rst:576
msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten "
"with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"Запрошенная память, заполненная копиями PYMEM_CLEANBYTE, используется для "
"перехвата ссылок на неинициализированную память. Когда функция, подобная "
"realloc, вызывается с запросом большего блока памяти, новые лишние байты "
"также заполняются PYMEM_CLEANBYTE. Когда вызывается свободная функция, они "
"перезаписываются PYMEM_DEADBYTE, чтобы перехватить ссылку на освобожденную "
"память. Когда функция, подобная realloc, вызывается и запрашивает меньший "
"блок памяти, лишние старые байты также заполняются PYMEM_DEADBYTE."

#: ../../c-api/memory.rst:584
msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

#: ../../c-api/memory.rst:585
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""
"Копии PYMEM_FORBIDDENBYTE. Используется для перехвата перезаписи и чтения."

#: ../../c-api/memory.rst:587
msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

#: ../../c-api/memory.rst:588
msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr ""
"Используется только в том случае, если определен макрос PYMEM_DEBUG_SERIALNO "
"(не определен по умолчанию)."

#: ../../c-api/memory.rst:591
msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian :c:type:`size_t`.  If \"bad memory\" is detected "
"later, the serial number gives an excellent way to set a breakpoint on the "
"next run, to capture the instant at which this block was passed out.  The "
"static function bumpserialno() in obmalloc.c is the only place the serial "
"number is incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"Серийный номер, увеличивающийся на 1 при каждом вызове функции типа malloc "
"или realloc. Прямой порядок :c:type:`size_t`. Если позже обнаруживается "
"«плохая память», серийный номер дает отличный способ установить точку "
"останова при следующем запуске, чтобы зафиксировать момент, когда этот блок "
"был отключен. Статическая функцияumpserialno() в obmalloc.c — единственное "
"место, где увеличивается серийный номер, и она существует, поэтому вы можете "
"легко установить такую ​​точку останова."

#: ../../c-api/memory.rst:598
msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're "
"likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"Функция типа realloc или free сначала проверяет целостность байтов "
"PYMEM_FORBIDDENBYTE на каждом конце. Если они были изменены, диагностические "
"данные записываются в stderr, и программа прерывается с помощью "
"Py_FatalError(). Другой основной вид сбоя — это ошибка памяти, когда "
"программа считывает один из специальных битовых шаблонов и пытается "
"использовать его в качестве адреса. Если вы затем зайдете в отладчик и "
"посмотрите на объект, вы, вероятно, увидите, что он полностью заполнен "
"PYMEM_DEADBYTE (это означает, что используется освобожденная память) или "
"PYMEM_CLEANBYTE (это означает, что используется неинициализированная память)."

#: ../../c-api/memory.rst:607
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use :mod:"
"`tracemalloc` to get the traceback where a memory block was allocated. The "
"debug hooks now also check if the GIL is held when functions of :c:macro:"
"`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""
"Функция :c:func:`PyMem_SetupDebugHooks` теперь также работает на Python, "
"скомпилированном в режиме выпуска. В случае ошибки перехватчики отладки "
"теперь используют :mod:`tracemalloc`, чтобы получить обратную трассировку, "
"где был выделен блок памяти. Перехватчики отладки теперь также проверяют, "
"удерживается ли GIL при вызове функций доменов :c:macro:`PYMEM_DOMAIN_OBJ` "
"и :c:macro:`PYMEM_DOMAIN_MEM`."

#: ../../c-api/memory.rst:615
msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"Байтовые шаблоны ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` "
"(``PYMEM_DEADBYTE``) и ``0xFB`` (``PYMEM_FORBIDDENBYTE``) заменены на "
"``0xCD``, ``0xDD`` и ``0xFD`` для использования тех же значений, что и "
"``malloc()`` и ``free()`` отладки Windows CRT."

#: ../../c-api/memory.rst:625
msgid "The pymalloc allocator"
msgstr "Распределитель pymalloc"

#: ../../c-api/memory.rst:627
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB "
"on 64-bit platforms. It falls back to :c:func:`PyMem_RawMalloc` and :c:func:"
"`PyMem_RawRealloc` for allocations larger than 512 bytes."
msgstr ""
"В Python имеется распределитель *pymalloc*, оптимизированный для небольших "
"объектов (размером меньше или равных 512 байтам) с коротким временем жизни. "
"Он использует сопоставления памяти, называемые «аренами», с фиксированным "
"размером 256 КиБ на 32-битных платформах или 1 МиБ на 64-битных платформах. "
"Он возвращается к :c:func:`PyMem_RawMalloc` и :c:func:`PyMem_RawRealloc` для "
"выделения памяти размером более 512 байт."

#: ../../c-api/memory.rst:633
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and :c:macro:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc* — это :ref:`распределитель по умолчанию <default-memory-"
"allocators>` для :c:macro:`PYMEM_DOMAIN_MEM` (например: :c:func:"
"`PyMem_Malloc`) и :c:macro:`PYMEM_DOMAIN_OBJ` (например: :c:func:"
"`PyObject_Malloc`) домены."

#: ../../c-api/memory.rst:637
msgid "The arena allocator uses the following functions:"
msgstr "Распределитель арены использует следующие функции:"

#: ../../c-api/memory.rst:639
msgid ":c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,"
msgstr ":c:func:`!VirtualAlloc` и :c:func:`!VirtualFree` в Windows,"

#: ../../c-api/memory.rst:640
msgid ":c:func:`!mmap` and :c:func:`!munmap` if available,"
msgstr ":c:func:`!mmap` и :c:func:`!munmap`, если они доступны,"

#: ../../c-api/memory.rst:641
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` и :c:func:`free` в противном случае."

#: ../../c-api/memory.rst:643
msgid ""
"This allocator is disabled if Python is configured with the :option:`--"
"without-pymalloc` option. It can also be disabled at runtime using the :"
"envvar:`PYTHONMALLOC` environment variable (ex: ``PYTHONMALLOC=malloc``)."
msgstr ""
"Этот распределитель отключен, если Python настроен с опцией :option:`--"
"without-pymalloc`. Его также можно отключить во время выполнения с помощью "
"переменной среды :envvar:`PYTHONMALLOC` (например: ``PYTHONMALLOC=malloc``)."

#: ../../c-api/memory.rst:648
msgid "Customize pymalloc Arena Allocator"
msgstr "Настройка распределителя арены pymalloc"

#: ../../c-api/memory.rst:654
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Структура, используемая для описания распределителя арены. Структура имеет "
"три поля:"

#: ../../c-api/memory.rst:662
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:662
msgid "allocate an arena of size bytes"
msgstr "выделить арену размером в байты"

#: ../../c-api/memory.rst:664
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:664
msgid "free an arena"
msgstr "освободить арену"

#: ../../c-api/memory.rst:669
msgid "Get the arena allocator."
msgstr "Получите распределитель арены."

#: ../../c-api/memory.rst:673
msgid "Set the arena allocator."
msgstr "Установите распределитель арены."

#: ../../c-api/memory.rst:677
msgid "tracemalloc C API"
msgstr "tracemalloc C API"

#: ../../c-api/memory.rst:683
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Отслеживайте выделенный блок памяти в модуле :mod:`tracemalloc`."

#: ../../c-api/memory.rst:685
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Возвращает «0» в случае успеха, возвращает «-1» в случае ошибки (не удалось "
"выделить память для хранения трассировки). Верните ``-2``, если Tracemalloc "
"отключен."

#: ../../c-api/memory.rst:688
msgid "If memory block is already tracked, update the existing trace."
msgstr "Если блок памяти уже отслеживается, обновите существующую трассировку."

#: ../../c-api/memory.rst:692
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Отмените отслеживание выделенного блока памяти в модуле :mod:`tracemalloc`. "
"Ничего не делайте, если блок не отслеживался."

#: ../../c-api/memory.rst:695
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr ""
"Верните ``-2``, если Tracemalloc отключен, в противном случае верните ``0``."

#: ../../c-api/memory.rst:701
msgid "Examples"
msgstr "Примеры"

#: ../../c-api/memory.rst:703
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function "
"set::"
msgstr ""
"Вот пример из раздела :ref:`memoryoverview`, переписанный так, что буфер "
"ввода-вывода выделяется из кучи Python с использованием первого набора "
"функций:"

#: ../../c-api/memory.rst:706
msgid ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_Malloc */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_Malloc */\n"
"return res;"

#: ../../c-api/memory.rst:716
msgid "The same code using the type-oriented function set::"
msgstr "Тот же код с использованием типоориентированного набора функций::"

#: ../../c-api/memory.rst:718
msgid ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Del(buf); /* allocated with PyMem_New */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Del(buf); /* allocated with PyMem_New */\n"
"return res;"

#: ../../c-api/memory.rst:728
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two "
"different allocators operating on different heaps. ::"
msgstr ""
"Обратите внимание, что в двух приведенных выше примерах буфер всегда "
"управляется с помощью функций, принадлежащих одному и тому же набору. "
"Действительно, необходимо использовать одно и то же семейство API памяти для "
"данного блока памяти, чтобы риск смешивания разных распределителей был "
"сведен к минимуму. Следующая последовательность кода содержит две ошибки, "
"одна из которых помечена как *фатальная*, поскольку она смешивает два разных "
"распределителя, работающих в разных кучах. ::"

#: ../../c-api/memory.rst:735
msgid ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */\n"
"free(buf2);       /* Right -- allocated via malloc() */\n"
"free(buf1);       /* Fatal -- should be PyMem_Del()  */"
msgstr ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */\n"
"free(buf2);       /* Right -- allocated via malloc() */\n"
"free(buf1);       /* Fatal -- should be PyMem_Del()  */"

#: ../../c-api/memory.rst:743
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar` and :c:func:`PyObject_Del`."
msgstr ""
"В дополнение к функциям, предназначенным для обработки необработанных блоков "
"памяти из кучи Python, объекты в Python выделяются и освобождаются с "
"помощью :c:macro:`PyObject_New`, :c:macro:`PyObject_NewVar` и :c:func:"
"`PyObject_Del` ."

#: ../../c-api/memory.rst:747
msgid ""
"These will be explained in the next chapter on defining and implementing new "
"object types in C."
msgstr ""
"Это будет объяснено в следующей главе, посвященной определению и реализации "
"новых типов объектов в C."

#: ../../c-api/memory.rst:43
msgid "malloc (C function)"
msgstr "malloc (C функция)"

#: ../../c-api/memory.rst:43
msgid "calloc (C function)"
msgstr "calloc (C функция)"

#: ../../c-api/memory.rst:43
msgid "realloc (C function)"
msgstr "realloc (C функция)"

#: ../../c-api/memory.rst:43
msgid "free (C function)"
msgstr "free (C функция)"
