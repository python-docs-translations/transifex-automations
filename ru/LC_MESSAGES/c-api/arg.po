# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2025
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-02 14:54+0000\n"
"PO-Revision-Date: 2024-05-11 00:32+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr "Анализ аргументов и построение значений"

#: ../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extension functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""
"Эти функции полезны при создании собственных функций и методов расширения. "
"Дополнительная информация и примеры доступны в :ref:`extending-index`."

#: ../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :c:func:`PyArg_ParseTuple`, :c:"
"func:`PyArg_ParseTupleAndKeywords`, and :c:func:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""
"Первые три из этих функций описаны, :c:func:`PyArg_ParseTuple`, :c:func:"
"`PyArg_ParseTupleAndKeywords`, и :c:func:`PyArg_Parse`, все они используют "
"*строки формата*, которые используются для сообщения функции об ожидаемых "
"аргументах. Строки формата используют один и тот же синтаксис для каждой из "
"этих функций."

#: ../../c-api/arg.rst:19
msgid "Parsing arguments"
msgstr "Анализ аргументов"

#: ../../c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""
"Строка формата состоит из нуля или более \"единиц формата\". Единица формата "
"описывает один объект Python; обычно это один символ или заключенная в "
"круглые скобки последовательность единиц формата. За некоторыми "
"исключениями, единица формата, которая не является последовательностью, "
"заключенной в круглые скобки, обычно соответствует единственному аргументу "
"адреса для этих функций. В следующем описании форма в кавычках - это единица "
"формата; запись в (круглых) скобках - это тип объекта Python, "
"соответствующий единице формата; а запись в [квадратных] скобках - это тип "
"переменных C, адрес которых должен быть передан."

#: ../../c-api/arg.rst:31
msgid "Strings and buffers"
msgstr "Строки и буферы"

#: ../../c-api/arg.rst:33
msgid ""
"These formats allow accessing an object as a contiguous chunk of memory. You "
"don't have to provide raw storage for the returned unicode or bytes area."
msgstr ""
"Эти форматы позволяют обращаться к объекту как к непрерывному фрагменту "
"памяти. Вам не нужно предоставлять необработанное хранилище для возвращаемой "
"области unicode или bytes."

#: ../../c-api/arg.rst:37
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr "Если не указано иное, буферы не NUL-терминированные."

#: ../../c-api/arg.rst:39
msgid "There are three ways strings and buffers can be converted to C:"
msgstr "Существует три способа преобразования строк и буферов в C:"

#: ../../c-api/arg.rst:41
msgid ""
"Formats such as ``y*`` and ``s*`` fill a :c:type:`Py_buffer` structure. This "
"locks the underlying buffer so that the caller can subsequently use the "
"buffer even inside a :c:type:`Py_BEGIN_ALLOW_THREADS` block without the risk "
"of mutable data being resized or destroyed. As a result, **you have to "
"call** :c:func:`PyBuffer_Release` after you have finished processing the "
"data (or in any early abort case)."
msgstr ""
"Такие форматы, как ``y*`` и ``s*`` заполняют структуру :c:type:`Py_buffer` "
"Это блокирует базовый буфер, так что вызывающий может впоследствии "
"использовать буфер даже внутри блока :c:type:`Py_BEGIN_ALLOW_THREADS` без "
"риска изменения размера или уничтожения изменяемых данных. В результате ** "
"вы должны вызвать** :c:func:`PyBuffer_Release` после завершения обработки "
"данных (или в любом случае раннего прерывания)."

#: ../../c-api/arg.rst:48
msgid ""
"The ``es``, ``es#``, ``et`` and ``et#`` formats allocate the result buffer. "
"**You have to call** :c:func:`PyMem_Free` after you have finished processing "
"the data (or in any early abort case)."
msgstr ""
"Форматы ``es``, ``es#``, ``et`` и ``et#`` выделяют результирующий буфер. "
"**Вы должны вызвать** :c:func:`PyMem_Free` после завершения обработки данных "
"(или в любом случае раннего прерывания)."

#: ../../c-api/arg.rst:54
msgid ""
"Other formats take a :class:`str` or a read-only :term:`bytes-like object`, "
"such as :class:`bytes`, and provide a ``const char *`` pointer to its "
"buffer. In this case the buffer is \"borrowed\": it is managed by the "
"corresponding Python object, and shares the lifetime of this object. You "
"won't have to release any memory yourself."
msgstr ""
"Другие форматы принимают :class:`str` или доступный только для чтения :term:"
"`bytes-like object`, такой как :class:`bytes`,  и предоставляют указатель "
"``const char *`` на его буфер. В этом случае буфер \"заимствован\": он "
"управляется соответствующим объектом Python и разделяет время жизни этого "
"объекта. Вам не придется освобождать память самостоятельно."

#: ../../c-api/arg.rst:61
msgid ""
"To ensure that the underlying buffer may be safely borrowed, the object's :c:"
"member:`PyBufferProcs.bf_releasebuffer` field must be ``NULL``. This "
"disallows common mutable objects such as :class:`bytearray`, but also some "
"read-only objects such as :class:`memoryview` of :class:`bytes`."
msgstr ""
"Чтобы гарантировать, что базовый буфер может быть безопасно заимствован, "
"поле объекта :c:member:`PyBufferProcs.bf_releasebuffer` должно быть "
"``NULL``. Это запрещает обычные изменяемые объекты, такие как :class:"
"`bytearray`, но также некоторые объекты, доступные только для чтения, такие "
"как :class:`memoryview` из :class:`bytes`."

#: ../../c-api/arg.rst:67
msgid ""
"Besides this ``bf_releasebuffer`` requirement, there is no check to verify "
"whether the input object is immutable (e.g. whether it would honor a request "
"for a writable buffer, or whether another thread can mutate the data)."
msgstr ""
"Помимо этого требования ``bf_releasebuffer`` нет никакой проверки, чтобы "
"убедиться, является ли входной объект неизменяемым (например, удовлетворит "
"ли он запрос буфера с возможностью записи или другой поток может изменить "
"данные)."

#: ../../c-api/arg.rst:73
msgid ""
"For all ``#`` variants of formats (``s#``, ``y#``, etc.), the macro :c:macro:"
"`PY_SSIZE_T_CLEAN` must be defined before including :file:`Python.h`. On "
"Python 3.9 and older, the type of the length argument is :c:type:"
"`Py_ssize_t` if the :c:macro:`PY_SSIZE_T_CLEAN` macro is defined, or int "
"otherwise."
msgstr ""
"Для всех вариантов форматов ``#`` (``s#``, ``y#``, и т.д.), макрос :c:macro:"
"`PY_SSIZE_T_CLEAN` должен быть определен перед включением :file:`Python.h`. "
"В Python 3.9 и более ранних версиях типом длины аргумента является :c:type:"
"`Py_ssize_t` если определен макрос :c:macro:`PY_SSIZE_T_CLEAN` или int в "
"противном случае."

#: ../../c-api/arg.rst:80
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr "``s`` (:class:`str`) [const char \\*]"

#: ../../c-api/arg.rst:81
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address "
"you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded null code points; if it does, a :exc:`ValueError` exception "
"is raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""
"Преобразует объект Unicode в указатель C на символьную строку. Указатель на "
"существующую строку хранится в переменной символьного указателя, адрес "
"которой вы передаете. Строка C завершается нулем. Строка Python не должна "
"содержать встроенных нулевых кодовых позиций; если это так, возникает "
"исключение :exc:`ValueError`.  Объекты Unicode преобразуются в строки C с "
"использованием кодировки ``'utf-8'``. Если это преобразование завершается "
"неудачей, возникает ошибка :exc:`UnicodeError`."

#: ../../c-api/arg.rst:90
msgid ""
"This format does not accept :term:`bytes-like objects <bytes-like object>`.  "
"If you want to accept filesystem paths and convert them to C character "
"strings, it is preferable to use the ``O&`` format with :c:func:"
"`PyUnicode_FSConverter` as *converter*."
msgstr ""
"Этот формат не принимает :term:`bytes-like objects <bytes-like object>`. "
"Если вы хотите принять пути к файловой системе и преобразовать их в "
"символьные строки C, предпочтительно использовать формат ``O&`` с :c:func:"
"`PyUnicode_FSConverter` в качестве *конвертера*."

#: ../../c-api/arg.rst:96
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null code points were "
"encountered in the Python string."
msgstr ""
"Ранее, :exc:`TypeError` вызывался при обнаружении встроенных нулевых кодовых "
"позиций в строке Python."

#: ../../c-api/arg.rst:100
msgid "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"
msgstr "``s*`` (:class:`str` or :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:101
msgid ""
"This format accepts Unicode objects as well as bytes-like objects. It fills "
"a :c:type:`Py_buffer` structure provided by the caller. In this case the "
"resulting C string may contain embedded NUL bytes. Unicode objects are "
"converted to C strings using ``'utf-8'`` encoding."
msgstr ""
"Этот формат принимает объекты Unicode, а также байто-подобные объекты. Он "
"заполняет структуру :c:type:`Py_buffer`, предоставленную вызывающим "
"объектом. В этом случае результирующая строка C может содержать встроенные "
"нулевые байты. Объекты Unicode преобразуются в строки C с использованием "
"кодировки ``'utf-8'``."

#: ../../c-api/arg.rst:106
msgid ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, :"
"c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str`, read-only :term:`bytes-like object`) [const char \\*, :"
"c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:107
msgid ""
"Like ``s*``, except that it provides a :ref:`borrowed buffer <c-arg-borrowed-"
"buffer>`. The result is stored into two C variables, the first one a pointer "
"to a C string, the second one its length. The string may contain embedded "
"null bytes. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding."
msgstr ""
"Аналогично ``s*``, за исключением того, что он предоставляет :ref:`borrowed "
"buffer <c-arg-borrowed-buffer>`. Результат сохраняется в двух переменных C, "
"первая из которых является указателем на строку C, вторая - ее длиной. "
"Строка может содержать встроенные нулевые байты. Объекты Unicode "
"преобразуются в строки C с использованием кодировки ``'utf-8'``."

#: ../../c-api/arg.rst:113 ../../c-api/arg.rst:558
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``z`` (:class:`str` or ``None``) [const char \\*]"

#: ../../c-api/arg.rst:114
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Как ``s``, но объект Python также может быть ``None``,и в этом случае "
"указателю C присваивается значение ``NULL``."

#: ../../c-api/arg.rst:117
msgid ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"
msgstr ""
"``z*`` (:class:`str`, :term:`bytes-like object` or ``None``) [Py_buffer]"

#: ../../c-api/arg.rst:118
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :c:type:`Py_buffer` structure is set to ``NULL``."
msgstr ""
"Как ``s*``, но объект Python также может быть ``None``, и в этом случае "
"члену ``buf`` структуры :c:type:`Py_buffer` присваивается значение ``NULL``."

#: ../../c-api/arg.rst:121
msgid ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str`, read-only :term:`bytes-like object` or ``None``) "
"[const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:122
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C "
"pointer is set to ``NULL``."
msgstr ""
"Как ``s#``, но объект Python также может быть ``None``, и в этом случае "
"указателю С присваивается значение ``NULL``."

#: ../../c-api/arg.rst:125
msgid "``y`` (read-only :term:`bytes-like object`) [const char \\*]"
msgstr "``y`` (read-only :term:`bytes-like object`) [const char \\*]"

#: ../../c-api/arg.rst:126
msgid ""
"This format converts a bytes-like object to a C pointer to a :ref:`borrowed "
"<c-arg-borrowed-buffer>` character string; it does not accept Unicode "
"objects.  The bytes buffer must not contain embedded null bytes; if it does, "
"a :exc:`ValueError` exception is raised."
msgstr ""
"Этот формат преобразует байтоподобный объект в указатель C на строку "
"символов :ref:`borrowed <c-arg-borrowed-buffer>`; он не принимает объекты "
"Unicode. Буфер байтов не должен содержать встроенных нулевых байтов; если "
"это так, возникает исключение :exc:`ValueError`."

#: ../../c-api/arg.rst:132
msgid ""
"Previously, :exc:`TypeError` was raised when embedded null bytes were "
"encountered in the bytes buffer."
msgstr ""
"Ранее, :exc:`TypeError` вызывался, когда в буфере байтов обнаруживались "
"встроенные нулевые байты."

#: ../../c-api/arg.rst:136
msgid "``y*`` (:term:`bytes-like object`) [Py_buffer]"
msgstr "``y*`` (:term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:137
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only bytes-like "
"objects.  **This is the recommended way to accept binary data.**"
msgstr ""
"Этот вариант на ``s*`` не принимает объекты в Юникоде, только байто-подобные "
"объекты. **Это рекомендуемый способ приема двоичных данных.**"

#: ../../c-api/arg.rst:141
msgid ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, :c:type:"
"`Py_ssize_t`]"
msgstr ""
"``y#`` (read-only :term:`bytes-like object`) [const char \\*, :c:type:"
"`Py_ssize_t`]"

#: ../../c-api/arg.rst:142
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr ""
"Этот вариант ``s#`` не принимает объекты в Юникоде, только байто-подобные "
"объекты."

#: ../../c-api/arg.rst:145
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr "``S`` (:class:`bytes`) [PyBytesObject \\*]"

#: ../../c-api/arg.rst:146
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"Требуется, чтобы объект Python был объектом :class:`bytes` без попытки "
"какого-либо преобразования. Вызывает :exc:`TypeError`, если объект не "
"является объектом bytes. Переменная C также может быть объявлена как :c:expr:"
"`PyObject*`."

#: ../../c-api/arg.rst:150
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"

#: ../../c-api/arg.rst:151
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a :"
"class:`bytearray` object. The C variable may also be declared as :c:expr:"
"`PyObject*`."
msgstr ""
"Требуется, чтобы объект Python был объектом :class:`bytearray` без попытки "
"какого-либо преобразования. Вызывает :exc:`TypeError`, если объект не "
"является объектом :class:`bytearray`. Переменная C также может быть "
"объявлена как :c:expr:`PyObject*`."

#: ../../c-api/arg.rst:155
msgid "``U`` (:class:`str`) [PyObject \\*]"
msgstr "``U`` (:class:`str`) [PyObject \\*]"

#: ../../c-api/arg.rst:156
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  "
"The C variable may also be declared as :c:expr:`PyObject*`."
msgstr ""
"Требуется, чтобы объект Python был объектом Unicode, без попытки какого-либо "
"преобразования. Вызывает :exc:`TypeError`, если объект не является объектом "
"Unicode. Переменная C также может быть объявлена как :c:expr:`PyObject*`."

#: ../../c-api/arg.rst:160
msgid "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"
msgstr "``w*`` (read-write :term:`bytes-like object`) [Py_buffer]"

#: ../../c-api/arg.rst:161
msgid ""
"This format accepts any object which implements the read-write buffer "
"interface. It fills a :c:type:`Py_buffer` structure provided by the caller. "
"The buffer may contain embedded null bytes. The caller have to call :c:func:"
"`PyBuffer_Release` when it is done with the buffer."
msgstr ""
"Этот формат принимает любой объект, который реализует интерфейс буфера "
"чтения-записи. Он заполняет структуру :c:type:`Py_buffer` , предоставленную "
"вызывающей стороной. Буфер может содержать встроенные нулевые байты. "
"Вызывающий объект должен вызвать :c:func:`PyBuffer_Release`, когда это будет "
"сделано с буфером."

#: ../../c-api/arg.rst:166
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:167
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""
"Этот вариант на ``s`` используется для кодирования Unicode в символьный "
"буфер. Он работает только для закодированных данных без встроенных нулевых "
"байтов."

#: ../../c-api/arg.rst:170
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :c:expr:`const char*` which points to the name of an encoding as a "
"NUL-terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument."
msgstr ""
"Этот формат требует двух аргументов. Первый используется только в качестве "
"входных данных и должен быть :c:expr:`const char*`, который указывает на имя "
"кодировки в виде нуль-терминированной строки, или``NULL``, в этом случае "
"используется кодировка ``'utf-8'``. Возникает исключение, если именованная "
"кодировка неизвестна Python. Вторым аргументом должен быть :c:expr:`char**`; "
"значение указателя, на который он ссылается, будет установлено в буфер с "
"содержимым текста аргумента. Текст будет закодирован в кодировке, указанной "
"в первом аргументе."

#: ../../c-api/arg.rst:178
msgid ""
":c:func:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :c:func:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""
":c:func:`PyArg_ParseTuple` выделит буфер необходимого размера, скопирует "
"закодированные данные в этот буфер и настроит *\\*buffer* для ссылки на "
"вновь выделенное хранилище. Вызывающий объект отвечает за вызов :c:func:"
"`PyMem_Free`, чтобы освободить выделенный буфер после использования."

#: ../../c-api/arg.rst:183
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"

#: ../../c-api/arg.rst:184
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"То же, что и ``es```, за исключением того, что объекты байтовой строки "
"передаются без их перекодирования. Вместо этого реализация предполагает, что "
"объект байтовой строки использует кодировку, переданную в качестве параметра."

#: ../../c-api/arg.rst:188
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, :c:type:"
"`Py_ssize_t` \\*buffer_length]"

#: ../../c-api/arg.rst:189
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer. "
"Unlike the ``es`` format, this variant allows input data which contains NUL "
"characters."
msgstr ""
"Этот вариант на ``s#`` используется для кодирования Unicode в символьный "
"буфер. В отличие от формата ``es``, этот вариант допускает ввод данных, "
"содержащих нулевые символы."

#: ../../c-api/arg.rst:193
msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :c:expr:`const char*` which points to the name of an encoding as a NUL-"
"terminated string, or ``NULL``, in which case ``'utf-8'`` encoding is used. "
"An exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :c:expr:`char**`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""
"Для этого требуются три аргумента. Первый используется только в качестве "
"входных данных и должен быть :c:expr:`const char*`, который указывает на имя "
"кодировки в виде нуль-терминированной строки или``NULL``. В этом случае "
"используется кодировка ``'utf-8'``. Возникает исключение, если именованная "
"кодировка неизвестна Python. Вторым аргументом должен быть :c:expr:`char**`; "
"значение указателя, на который он ссылается, будет установлено в буфер с "
"содержимым текста аргумента. Текст будет закодирован в кодировке, указанной "
"в первом аргументе. Третий аргумент должен быть указателем на целое число; "
"целому числу, на которое ссылается ссылка, будет присвоено количество байт в "
"выходном буфере."

#: ../../c-api/arg.rst:203
msgid "There are two modes of operation:"
msgstr "Существует два режима работы:"

#: ../../c-api/arg.rst:205
msgid ""
"If *\\*buffer* points a ``NULL`` pointer, the function will allocate a "
"buffer of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :c:func:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""
"Если *\\*buffer* указывает на указатель ``NULL``, функция выделит буфер "
"необходимого размера, скопирует закодированные данные в этот буфер и "
"установит *\\*buffer* для ссылки на вновь выделенное хранилище. Вызывающий "
"объект отвечает за вызов :c:func:`PyMem_Free`, чтобы освободить выделенный "
"буфер после использования."

#: ../../c-api/arg.rst:210
msgid ""
"If *\\*buffer* points to a non-``NULL`` pointer (an already allocated "
"buffer), :c:func:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""
"Если *\\*buffer* указывает на указатель не-``NULL``(уже выделенный буфер), :"
"c:func:`PyArg_ParseTuple` будет использовать это местоположение в качестве "
"буфера и интерпретировать начальное значение *\\*buffer_length* как размер "
"буфера. Затем он скопирует закодированные данные в буфер и завершит его "
"обнулением. Если буфер недостаточно велик, будет установлено значение :exc:"
"`ValueError`."

#: ../../c-api/arg.rst:216
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""
"В обоих случаях *\\*buffer_length* устанавливается равным длине "
"закодированных данных без завершающего нулевого байта."

#: ../../c-api/arg.rst:219
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"
msgstr ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, :c:type:`Py_ssize_t` \\*buffer_length]"

#: ../../c-api/arg.rst:220
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""
"То же, что и ``es#``, за исключением того, что объекты байтовой строки "
"передаются без их перекодирования. Вместо этого реализация предполагает, что "
"объект байтовой строки использует кодировку, переданную в качестве параметра."

#: ../../c-api/arg.rst:224
msgid ""
"``u``, ``u#``, ``Z``, and ``Z#`` are removed because they used a legacy "
"``Py_UNICODE*`` representation."
msgstr ""
"``u``, ``u#``, ``Z``, и ``Z#`` удалены, поскольку они использовали "
"устаревшее представление ``Py_UNICODE*``."

#: ../../c-api/arg.rst:230
msgid "Numbers"
msgstr "Числа"

#: ../../c-api/arg.rst:232
msgid ""
"These formats allow representing Python numbers or single characters as C "
"numbers. Formats that require :class:`int`, :class:`float` or :class:"
"`complex` can also use the corresponding special methods :meth:`~object."
"__index__`, :meth:`~object.__float__` or :meth:`~object.__complex__` to "
"convert the Python object to the required type."
msgstr ""
"Эти форматы позволяют представлять номера Python или отдельные символы в "
"виде номеров C. Форматы, которые требуют: класс: `int`,: class:` float` или: "
"class: `complex` также может использовать соответствующие специальные "
"методы: meth:` ~ объект .__ index__`,: meth: `~ объект .__ float__` или : "
"meth: `~ объект .__ Комплекс __` для преобразования объекта Python в "
"требуемый тип."

#: ../../c-api/arg.rst:238
msgid ""
"For signed integer formats, :exc:`OverflowError` is raised if the value is "
"out of range for the C type. For unsigned integer formats, no range checking "
"is done --- the most significant bits are silently truncated when the "
"receiving field is too small to receive the value."
msgstr ""
"Для подписанных целочисленных форматов: exc: `overflowerror Для непосгинных "
"целочисленных форматов не выполняется проверка диапазона-наиболее значимые "
"биты молча усекаются, когда приемное поле слишком мало, чтобы получить "
"значение."

#: ../../c-api/arg.rst:244
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr "``b`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:245
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny integer, stored in "
"a C :c:expr:`unsigned char`."
msgstr ""
"Преобразует неотрицательное целое число Python в беззнаковое крошечное целое "
"число, сохраняемое в C :c:expr:`unsigned char`."

#: ../../c-api/arg.rst:248 ../../c-api/arg.rst:592
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr "``B`` (:class:`int`) [unsigned char]"

#: ../../c-api/arg.rst:249
msgid ""
"Convert a Python integer to a tiny integer without overflow checking, stored "
"in a C :c:expr:`unsigned char`."
msgstr ""
"Преобразует целое число Python в крошечное целое число без проверки "
"переполнения, сохраняемое в C :c:expr:`unsigned char`."

#: ../../c-api/arg.rst:252 ../../c-api/arg.rst:586
msgid "``h`` (:class:`int`) [short int]"
msgstr "``h`` (:class:`int`) [short int]"

#: ../../c-api/arg.rst:253
msgid "Convert a Python integer to a C :c:expr:`short int`."
msgstr "Преобразует целое число Python в C :c:expr:`short int`."

#: ../../c-api/arg.rst:255 ../../c-api/arg.rst:595
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr "``H`` (:class:`int`) [unsigned short int]"

#: ../../c-api/arg.rst:256
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned short int`, without "
"overflow checking."
msgstr ""
"Преобразует целое число Python в C :c:expr:`unsigned short int` без проверки "
"переполнения."

#: ../../c-api/arg.rst:259 ../../c-api/arg.rst:580
msgid "``i`` (:class:`int`) [int]"
msgstr "``i`` (:class:`int`) [int]"

#: ../../c-api/arg.rst:260
msgid "Convert a Python integer to a plain C :c:expr:`int`."
msgstr "Преобразует целое число Python в обычный C :c:expr:`int`."

#: ../../c-api/arg.rst:262 ../../c-api/arg.rst:598
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr "``I`` (:class:`int`) [unsigned int]"

#: ../../c-api/arg.rst:263
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned int`, without overflow "
"checking."
msgstr ""
"Преобразует целое число Python в C :c:expr:`unsigned int` без проверки "
"переполнения."

#: ../../c-api/arg.rst:266 ../../c-api/arg.rst:589
msgid "``l`` (:class:`int`) [long int]"
msgstr "``l`` (:class:`int`) [long int]"

#: ../../c-api/arg.rst:267
msgid "Convert a Python integer to a C :c:expr:`long int`."
msgstr "Преобразует целое число Python в C :c:expr:`long int`."

#: ../../c-api/arg.rst:269 ../../c-api/arg.rst:601
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr "``k`` (:class:`int`) [unsigned long]"

#: ../../c-api/arg.rst:270
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long` without overflow "
"checking."
msgstr ""
"Преобразует целое число Python в C :c:expr:`unsigned long` без проверки "
"переполнения."

#: ../../c-api/arg.rst:273 ../../c-api/arg.rst:604
msgid "``L`` (:class:`int`) [long long]"
msgstr "``L`` (:class:`int`) [long long]"

#: ../../c-api/arg.rst:274
msgid "Convert a Python integer to a C :c:expr:`long long`."
msgstr "Преобразует целое число Python в C :c:expr:`long long`."

#: ../../c-api/arg.rst:276 ../../c-api/arg.rst:607
msgid "``K`` (:class:`int`) [unsigned long long]"
msgstr "``K`` (:class:`int`) [unsigned long long]"

#: ../../c-api/arg.rst:277
msgid ""
"Convert a Python integer to a C :c:expr:`unsigned long long` without "
"overflow checking."
msgstr ""
"Преобразует целое число Python в C :c:expr:`unsigned long long` без проверки "
"переполнения."

#: ../../c-api/arg.rst:280 ../../c-api/arg.rst:610
msgid "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"
msgstr "``n`` (:class:`int`) [:c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:281
msgid "Convert a Python integer to a C :c:type:`Py_ssize_t`."
msgstr "Преобразует целое число Python в C :c:type:`Py_ssize_t`."

#: ../../c-api/arg.rst:283
msgid "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"
msgstr "``c`` (:class:`bytes` or :class:`bytearray` of length 1) [char]"

#: ../../c-api/arg.rst:284
msgid ""
"Convert a Python byte, represented as a :class:`bytes` or :class:`bytearray` "
"object of length 1, to a C :c:expr:`char`."
msgstr ""
"Преобразует байт Python, представленный как объект :class:`bytes` или:class:"
"`bytearray` длины 1, в C :c:expr:`char`."

#: ../../c-api/arg.rst:287
msgid "Allow :class:`bytearray` objects."
msgstr "Разрешает объекты :class:`bytearray`."

#: ../../c-api/arg.rst:290 ../../c-api/arg.rst:617
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr "``C`` (:class:`str` of length 1) [int]"

#: ../../c-api/arg.rst:291
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :c:expr:`int`."
msgstr ""
"Преобразует символ Python, представленный как объект :class:`str` длиной 1, "
"в C :c:expr:`int`."

#: ../../c-api/arg.rst:294 ../../c-api/arg.rst:624
msgid "``f`` (:class:`float`) [float]"
msgstr "``f`` (:class:`float`) [float]"

#: ../../c-api/arg.rst:295
msgid "Convert a Python floating-point number to a C :c:expr:`float`."
msgstr "Преобразуйте число Python с плавающей запятой в C :c:expr:`float`."

#: ../../c-api/arg.rst:297 ../../c-api/arg.rst:621
msgid "``d`` (:class:`float`) [double]"
msgstr "``d`` (:class:`float`) [double]"

#: ../../c-api/arg.rst:298
msgid "Convert a Python floating-point number to a C :c:expr:`double`."
msgstr "Преобразуйте число Python с плавающей запятой в C :c:expr:`double`."

#: ../../c-api/arg.rst:300
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr "``D`` (:class:`complex`) [Py_complex]"

#: ../../c-api/arg.rst:301
msgid "Convert a Python complex number to a C :c:type:`Py_complex` structure."
msgstr ""
"Преобразует комплексное число Python в структуру C :c:type:`Py_complex`."

#: ../../c-api/arg.rst:304
msgid "Other objects"
msgstr "Другие объекты"

#: ../../c-api/arg.rst:306 ../../c-api/arg.rst:630
msgid "``O`` (object) [PyObject \\*]"
msgstr "``O`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:307
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  A new :term:"
"`strong reference` to the object is not created (i.e. its reference count is "
"not increased). The pointer stored is not ``NULL``."
msgstr ""
"Сохраняет объект Python (без какого-либо преобразования) в указателе на "
"объект C. Таким образом, программа C получает фактический объект, который "
"был передан. Новая :term:`strong reference` на объект не создается (т.е. "
"количество его ссылок не увеличивается). Сохраненный указатель не является "
"``NULL``."

#: ../../c-api/arg.rst:313
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr "``O!`` (object) [*typeobject*, PyObject \\*]"

#: ../../c-api/arg.rst:314
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :c:expr:`PyObject*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""
"Сохраняет объект Python в указателе на объект C . Это похоже на ``O``, но "
"принимает два аргумента C: первый - это адрес объекта типа Python, второй - "
"адрес переменной C (типа :c:expr:`PyObject*`), в которой хранится указатель "
"на объект. Если объект Python не имеет требуемого типа, вызывается :exc:"
"`TypeError`."

#: ../../c-api/arg.rst:322
msgid "``O&`` (object) [*converter*, *address*]"
msgstr "``O&`` (object) [*converter*, *address*]"

#: ../../c-api/arg.rst:323
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :c:expr:`void *`.  The "
"*converter* function in turn is called as follows::"
msgstr ""
"Преобразуйте объект Python в переменную C с помощью функции *converter*. Для "
"этого требуется два аргумента: первый - функция, второй - адрес переменной C "
"(произвольного типа), преобразованный в :c:expr:`void*`. Функция "
"*converter*, в свою очередь, вызывается следующим образом::"

#: ../../c-api/arg.rst:328
msgid "status = converter(object, address);"
msgstr "status = converter(object, address);"

#: ../../c-api/arg.rst:330
msgid ""
"where *object* is the Python object to be converted and *address* is the :c:"
"expr:`void*` argument that was passed to the ``PyArg_Parse*`` function. The "
"returned *status* should be ``1`` for a successful conversion and ``0`` if "
"the conversion has failed.  When the conversion fails, the *converter* "
"function should raise an exception and leave the content of *address* "
"unmodified."
msgstr ""
"где *object* - это объект Python, подлежащий преобразованию, а *address* - "
"это аргумент :c:expr:`void*`, который был передан функции ``PyArg_Parse*``. "
"Возвращаемый *статус* должен быть ``1`` для успешного преобразования и "
"``0``, если преобразование завершилось неудачей. При сбое преобразования "
"функция *converter* должна вызвать исключение и оставить содержимое "
"*address* неизмененным."

#: ../../c-api/arg.rst:339
msgid ""
"If the *converter* returns :c:macro:`!Py_CLEANUP_SUPPORTED`, it may get "
"called a second time if the argument parsing eventually fails, giving the "
"converter a chance to release any memory that it had already allocated. In "
"this second call, the *object* parameter will be ``NULL``; *address* will "
"have the same value as in the original call."
msgstr ""
"Если *конвертер* возвращает :c:macro:`!Py_CLEANUP_SUPPORTED`, он может быть "
"вызван второй раз, если синтаксический анализ аргументов в конечном итоге "
"завершится неудачно, давая конвертеру возможность освободить любую память, "
"которую он уже выделил. Во втором вызове параметр *object* будет иметь "
"значение NULL; *адрес* будет иметь то же значение, что и в исходном вызове."

#: ../../c-api/arg.rst:345
msgid ""
"Examples of converters: :c:func:`PyUnicode_FSConverter` and :c:func:"
"`PyUnicode_FSDecoder`."
msgstr ""
"Примеры конвертеров: :c :func :`PyUnicode_FSConverter` и :c :func :"
"`PyUnicode_FSDecoder`."

#: ../../c-api/arg.rst:348
msgid ":c:macro:`!Py_CLEANUP_SUPPORTED` was added."
msgstr ":c:macro:`!Py_CLEANUP_SUPPORTED` был добавлен."

#: ../../c-api/arg.rst:351
msgid "``p`` (:class:`bool`) [int]"
msgstr "``p`` (:class:`bool`) [int]"

#: ../../c-api/arg.rst:352
msgid ""
"Tests the value passed in for truth (a boolean **p**\\ redicate) and "
"converts the result to its equivalent C true/false integer value. Sets the "
"int to ``1`` if the expression was true and ``0`` if it was false. This "
"accepts any valid Python value.  See :ref:`truth` for more information about "
"how Python tests values for truth."
msgstr ""
"Проверяет переданное значение на истинность (логическое значение **p**\\ "
"redicate) и преобразует результат в его эквивалентное целочисленное значение "
"C true/false. Устанавливает значение int равным ``1``, если выражение было "
"истинным, и ``0``, если оно было ложным. Это принимает любое допустимое "
"значение Python. Смотрите :ref:`truth` для получения дополнительной "
"информации о том, как Python проверяет значения на истинность."

#: ../../c-api/arg.rst:360 ../../c-api/arg.rst:654
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr "``(items)`` (:class:`tuple`) [*matching-items*]"

#: ../../c-api/arg.rst:361
msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""
"Объектом должна быть последовательность Python, длина которой равна "
"количеству единиц формата в *items*. Аргументы C должны соответствовать "
"отдельным единицам формата в *items*. Единицы формата для "
"последовательностей могут быть вложенными."

#: ../../c-api/arg.rst:365
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""
"Несколько других символов имеют значение в строке формата. Они могут не "
"встречаться внутри вложенных круглых скобок. Это:"

#: ../../c-api/arg.rst:368
msgid "``|``"
msgstr "``|``"

#: ../../c-api/arg.rst:369
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :c:func:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""
"Указывает, что остальные аргументы в списке аргументов Python являются "
"необязательными. Переменные C, соответствующие необязательным аргументам, "
"должны быть инициализированы их значением по умолчанию --- когда "
"необязательный аргумент не указан, :c:func:`PyArg_ParseTuple` не затрагивает "
"содержимое соответствующих переменных C."

#: ../../c-api/arg.rst:375
msgid "``$``"
msgstr "``$``"

#: ../../c-api/arg.rst:376
msgid ""
":c:func:`PyArg_ParseTupleAndKeywords` only: Indicates that the remaining "
"arguments in the Python argument list are keyword-only.  Currently, all "
"keyword-only arguments must also be optional arguments, so ``|`` must always "
"be specified before ``$`` in the format string."
msgstr ""
"Только для :c:func:`PyArg_ParseTupleAndKeywords`: указывает, что остальные "
"аргументы в списке аргументов Python являются только ключевыми словами. В "
"настоящее время все аргументы, содержащие только ключевые слова, также "
"должны быть необязательными аргументами, поэтому ``|`` всегда должно "
"указываться перед ``$`` в строке формата."

#: ../../c-api/arg.rst:384
msgid "``:``"
msgstr "``:``"

#: ../../c-api/arg.rst:385
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :c:func:`PyArg_ParseTuple` raises)."
msgstr ""
"На этом список единиц форматирования заканчивается; строка после двоеточия "
"используется в качестве имени функции в сообщениях об ошибках (\"связанное "
"значение\" исключения, которое вызывает :c:func:`PyArg_ParseTuple`."

#: ../../c-api/arg.rst:389
msgid "``;``"
msgstr "``;``"

#: ../../c-api/arg.rst:390
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""
"На этом список единиц форматирования заканчивается; строка после точки с "
"запятой используется в качестве сообщения об ошибке *вместо* сообщения об "
"ошибке по умолчанию. ``:`` и ``;`` взаимно исключают друг друга."

#: ../../c-api/arg.rst:394
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not release them (i.e. do not decrement their "
"reference count)!"
msgstr ""
"Обратите внимание, что любые ссылки на объекты Python, которые "
"предоставляются вызывающему объекту, являются *заимствованными* ссылками; не "
"освобождайте их (т.е. не уменьшайте их счётчик ссылок)!"

#: ../../c-api/arg.rst:398
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""
"Дополнительные аргументы, передаваемые этим функциям, должны быть адресами "
"переменных, тип которых определяется строкой формата; они используются для "
"хранения значений из входного кортежа. Есть несколько случаев, как описано в "
"списке единиц измерения формата выше, где эти параметры используются в "
"качестве входных значений; в этом случае они должны соответствовать тому, "
"что указано для соответствующей единицы измерения формата."

#: ../../c-api/arg.rst:404
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the ``PyArg_Parse*`` functions "
"return true, otherwise they return false and raise an appropriate exception. "
"When the ``PyArg_Parse*`` functions fail due to conversion failure in one of "
"the format units, the variables at the addresses corresponding to that and "
"the following format units are left untouched."
msgstr ""
"Чтобы преобразование было успешным, объект *arg* должен соответствовать "
"формату, и формат должен быть исчерпан. В случае успеха функции "
"``PyArg_Parse*`` возвращают значение true, в противном случае они возвращают "
"значение false и вызывают соответствующее исключение. Когда функции "
"``PyArg_Parse*`` завершаются ошибкой из-за сбоя преобразования в одной из "
"единиц формата, переменные по адресам, соответствующим этой и следующим "
"единицам формата, остаются нетронутыми."

#: ../../c-api/arg.rst:413
msgid "API Functions"
msgstr "Функции API"

#: ../../c-api/arg.rst:417
msgid ""
"Parse the parameters of a function that takes only positional parameters "
"into local variables.  Returns true on success; on failure, it returns false "
"and raises the appropriate exception."
msgstr ""
"Анализирует параметры функции, которая преобразует в локальные переменные "
"только позиционные параметры. Возвращает true при успешном выполнении; при "
"сбое возвращает false и вызывает соответствующее исключение."

#: ../../c-api/arg.rst:424
msgid ""
"Identical to :c:func:`PyArg_ParseTuple`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Идентичен :c:func:`PyArg_ParseTuple`, за исключением того, что он принимает "
"va_list, а не переменное количество аргументов."

#: ../../c-api/arg.rst:430
msgid ""
"Parse the parameters of a function that takes both positional and keyword "
"parameters into local variables.  The *keywords* argument is a ``NULL``-"
"terminated array of keyword parameter names.  Empty names denote :ref:"
"`positional-only parameters <positional-only_parameter>`. Returns true on "
"success; on failure, it returns false and raises the appropriate exception."
msgstr ""
"Анализирует параметры функции, которая преобразует как позиционные "
"параметры, так и параметры ключевых слов в локальные переменные. Аргумент "
"*keywords* представляет собой массив имен параметров ключевых слов, "
"заканчивающийся ``NULL``. Пустые имена обозначают :ref:`positional-only "
"parameters <positional-only_parameter>`. Возвращает true при успешном "
"выполнении; при сбое возвращает false и вызывает соответствующее исключение."

#: ../../c-api/arg.rst:437
msgid ""
"Added support for :ref:`positional-only parameters <positional-"
"only_parameter>`."
msgstr ""
"Добавлена поддержка :ref:`positional-only parameters <positional-"
"only_parameter>`."

#: ../../c-api/arg.rst:444
msgid ""
"Identical to :c:func:`PyArg_ParseTupleAndKeywords`, except that it accepts a "
"va_list rather than a variable number of arguments."
msgstr ""
"Идентичен :c:func:`PyArg_ParseTupleAndKeywords`, за исключением того, что он "
"принимает va_list, а не переменное количество аргументов."

#: ../../c-api/arg.rst:450
msgid ""
"Ensure that the keys in the keywords argument dictionary are strings.  This "
"is only needed if :c:func:`PyArg_ParseTupleAndKeywords` is not used, since "
"the latter already does this check."
msgstr ""
"Убедитесь, что ключи в словаре аргументов keywords являются строками. Это "
"необходимо только в том случае, если :c:func:`PyArg_ParseTupleAndKeywords` "
"не используется, поскольку последний уже выполняет эту проверку."

#: ../../c-api/arg.rst:460
msgid ""
"Function used to deconstruct the argument lists of \"old-style\" functions "
"--- these are functions which use the :const:`METH_OLDARGS` parameter "
"parsing method, which has been removed in Python 3.  This is not recommended "
"for use in parameter parsing in new code, and most code in the standard "
"interpreter has been modified to no longer use this for that purpose.  It "
"does remain a convenient way to decompose other tuples, however, and may "
"continue to be used for that purpose."
msgstr ""
"Функция, используемая для деконструкции списков аргументов функций \"старого "
"стиля\" --- это функции, которые используют метод синтаксического анализа "
"параметров :const:`METH_OLDARGS`, который был удален в Python 3. Это не "
"рекомендуется использовать при анализе параметров в новом коде, и большая "
"часть кода в стандартном интерпретаторе была изменена, чтобы больше не "
"использовать этот метод для этой цели. Однако он остается удобным способом "
"декомпозиции других кортежей и может продолжать использоваться для этой цели."

#: ../../c-api/arg.rst:471
msgid ""
"A simpler form of parameter retrieval which does not use a format string to "
"specify the types of the arguments.  Functions which use this method to "
"retrieve their parameters should be declared as :c:macro:`METH_VARARGS` in "
"function or method tables.  The tuple containing the actual parameters "
"should be passed as *args*; it must actually be a tuple.  The length of the "
"tuple must be at least *min* and no more than *max*; *min* and *max* may be "
"equal.  Additional arguments must be passed to the function, each of which "
"should be a pointer to a :c:expr:`PyObject*` variable; these will be filled "
"in with the values from *args*; they will contain :term:`borrowed references "
"<borrowed reference>`. The variables which correspond to optional parameters "
"not given by *args* will not be filled in; these should be initialized by "
"the caller. This function returns true on success and false if *args* is not "
"a tuple or contains the wrong number of elements; an exception will be set "
"if there was a failure."
msgstr ""
"Более простая форма извлечения параметров, которая не использует строку "
"формата для указания типов аргументов. Функции, которые используют этот "
"метод для извлечения своих параметров, должны быть объявлены как :c:macro:"
"`METH_VARARGS` в таблицах функций или методов. Кортеж, содержащий актуальные "
"параметры, должен передаваться как *args*; это действительно должен быть "
"кортеж. Длина кортежа должна быть не менее *min* и не более *max*; *min* и "
"*max* могут быть равны. Функции должны быть переданы дополнительные "
"аргументы, каждый из которых должен быть указателем на переменную :c:expr:"
"`PyObject*`; они будут заполнены значениями из *args*; они будут содержать :"
"term:`borrowed references <borrowed reference>`. Переменные, которые "
"соответствуют необязательным параметрам, не указанным в *args*, заполняться "
"не будут; они должны быть инициализированы вызывающим объектом. Эта функция "
"возвращает true при успешном выполнении и false, если *args* не является "
"кортежем или содержит неправильное количество элементов; в случае сбоя будет "
"установлено исключение."

#: ../../c-api/arg.rst:486
msgid ""
"This is an example of the use of this function, taken from the sources for "
"the :mod:`!_weakref` helper module for weak references::"
msgstr ""
"Это пример использования этой функции, взятый из исходных текстов для "
"вспомогательного модуля :mod:`!_weakref` для слабых ссылок::"

#: ../../c-api/arg.rst:489
msgid ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"static PyObject *\n"
"weakref_ref(PyObject *self, PyObject *args)\n"
"{\n"
"    PyObject *object;\n"
"    PyObject *callback = NULL;\n"
"    PyObject *result = NULL;\n"
"\n"
"    if (PyArg_UnpackTuple(args, \"ref\", 1, 2, &object, &callback)) {\n"
"        result = PyWeakref_NewRef(object, callback);\n"
"    }\n"
"    return result;\n"
"}"

#: ../../c-api/arg.rst:502
msgid ""
"The call to :c:func:`PyArg_UnpackTuple` in this example is entirely "
"equivalent to this call to :c:func:`PyArg_ParseTuple`::"
msgstr ""
"Вызов :c:func:`PyArg_UnpackTuple` в этом примере полностью эквивалентен "
"этому вызову :c:func:`PyArg_ParseTuple`::"

#: ../../c-api/arg.rst:505
msgid "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"
msgstr "PyArg_ParseTuple(args, \"O|O:ref\", &object, &callback)"

#: ../../c-api/arg.rst:510
msgid "Building values"
msgstr "Создание значений"

#: ../../c-api/arg.rst:514
msgid ""
"Create a new value based on a format string similar to those accepted by the "
"``PyArg_Parse*`` family of functions and a sequence of values.  Returns the "
"value or ``NULL`` in the case of an error; an exception will be raised if "
"``NULL`` is returned."
msgstr ""
"Создает новое значение на основе строки формата, аналогичной тем, которые "
"принимаются семейством функций ``PyArg_Parse*``, и последовательности "
"значений. Возвращает значение или ``NULL`` в случае ошибки; исключение будет "
"вызвано, если будет возвращено ``NULL``."

#: ../../c-api/arg.rst:519
msgid ""
":c:func:`Py_BuildValue` does not always build a tuple.  It builds a tuple "
"only if its format string contains two or more format units.  If the format "
"string is empty, it returns ``None``; if it contains exactly one format "
"unit, it returns whatever object is described by that format unit.  To force "
"it to return a tuple of size 0 or one, parenthesize the format string."
msgstr ""
":c:func:`Py_BuildValue` не всегда создает кортеж. Она создает кортеж только "
"в том случае, если строка формата содержит две или более единицы формата. "
"Если строка формата пуста, она возвращает ``None``; если она содержит ровно "
"одну единицу формата, она возвращает любой объект, описываемый этой единицей "
"формата. Чтобы заставить ее возвращать кортеж размером 0 или единицу, "
"заключите строку формата в круглые скобки."

#: ../../c-api/arg.rst:525
msgid ""
"When memory buffers are passed as parameters to supply data to build "
"objects, as for the ``s`` and ``s#`` formats, the required data is copied.  "
"Buffers provided by the caller are never referenced by the objects created "
"by :c:func:`Py_BuildValue`.  In other words, if your code invokes :c:func:"
"`malloc` and passes the allocated memory to :c:func:`Py_BuildValue`, your "
"code is responsible for calling :c:func:`free` for that memory once :c:func:"
"`Py_BuildValue` returns."
msgstr ""
"Когда буферы памяти передаются в качестве параметров для предоставления "
"данных для построения объектов, как для форматов ``s`` и ``s#``, копируются "
"необходимые данные. На буферы, предоставляемые вызывающей стороной, никогда "
"не ссылаются объекты, созданные с помощью :c:func:`Py_BuildValue`.  Другими "
"словами, если ваш код вызывает :c:func:`malloc` и передает выделенную "
"память :c:func:`Py_BuildValue`, ваш код отвечает за вызов :c:func:`free` для "
"этой памяти, как только :c:func:`Py_BuildValue` возвращается."

#: ../../c-api/arg.rst:533
msgid ""
"In the following description, the quoted form is the format unit; the entry "
"in (round) parentheses is the Python object type that the format unit will "
"return; and the entry in [square] brackets is the type of the C value(s) to "
"be passed."
msgstr ""
"В следующем описании форма в кавычках - это единица формата; запись в "
"(круглых) скобках - это тип объекта Python, который вернет единица формата; "
"а запись в [квадратных] скобках - это тип передаваемых значений C ."

#: ../../c-api/arg.rst:537
msgid ""
"The characters space, tab, colon and comma are ignored in format strings "
"(but not within format units such as ``s#``).  This can be used to make long "
"format strings a tad more readable."
msgstr ""
"Символы пробела, табуляции, двоеточия и запятой игнорируются в строках "
"формата (но не в единицах формата, таких как ``s#``). Это можно "
"использовать, чтобы сделать длинные строки формата немного более "
"удобочитаемыми."

#: ../../c-api/arg.rst:541
msgid "``s`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``s`` (:class:`str` or ``None``) [const char \\*]"

#: ../../c-api/arg.rst:542
msgid ""
"Convert a null-terminated C string to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, ``None`` is used."
msgstr ""
"Преобразует нуль-терминированную строку C в объект Python :class:`str`, "
"используя кодировку ``'utf-8'``. Если указатель на строку C равен ``NULL``, "
"используется ``None``."

#: ../../c-api/arg.rst:545
msgid ""
"``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``s#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:546
msgid ""
"Convert a C string and its length to a Python :class:`str` object using "
"``'utf-8'`` encoding. If the C string pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Преобразует строку C и ее длину в объект Python :class:`str`, используя "
"кодировку ``'utf-8'``. Если указатель на строку C равен ``NULL``, длина "
"игнорируется и возвращается ``None``."

#: ../../c-api/arg.rst:550
msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr "``y`` (:class:`bytes`) [const char \\*]"

#: ../../c-api/arg.rst:551
msgid ""
"This converts a C string to a Python :class:`bytes` object.  If the C string "
"pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Преобразует строку С в объект Python :class:`bytes`. Если указатель строки С "
"равен ``NULL``, возвращается ``None``."

#: ../../c-api/arg.rst:554
msgid "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr "``y#`` (:class:`bytes`) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:555
msgid ""
"This converts a C string and its lengths to a Python object.  If the C "
"string pointer is ``NULL``, ``None`` is returned."
msgstr ""
"Это преобразует строку C и ее длины в объект Python. Если указатель на "
"строку C равен ``NULL``, возвращается ``None``."

#: ../../c-api/arg.rst:559 ../../c-api/arg.rst:575
msgid "Same as ``s``."
msgstr "То же, что ``s``."

#: ../../c-api/arg.rst:561
msgid ""
"``z#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``z#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:562 ../../c-api/arg.rst:578
msgid "Same as ``s#``."
msgstr "То же, что ``s#``."

#: ../../c-api/arg.rst:564
msgid "``u`` (:class:`str`) [const wchar_t \\*]"
msgstr "``u`` (:class:`str`) [const wchar_t \\*]"

#: ../../c-api/arg.rst:565
msgid ""
"Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or "
"UCS-4) data to a Python Unicode object.  If the Unicode buffer pointer is "
"``NULL``, ``None`` is returned."
msgstr ""
"Преобразует нуль-терминированный буфер данных Unicode (UTF-16 или UCS-4) :c:"
"type:`wchar_t` в объект Unicode на Python. Если указатель буфера Unicode "
"равен ``NULL``, возвращается ``None``."

#: ../../c-api/arg.rst:569
msgid "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"
msgstr "``u#`` (:class:`str`) [const wchar_t \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:570
msgid ""
"Convert a Unicode (UTF-16 or UCS-4) data buffer and its length to a Python "
"Unicode object.   If the Unicode buffer pointer is ``NULL``, the length is "
"ignored and ``None`` is returned."
msgstr ""
"Преобразует буфер данных Unicode (UTF-16 или UCS-4) и его длину в объект "
"Unicode на Python. Если указатель буфера в Юникоде равен ``NULL``, длина "
"игнорируется и возвращается ``None``."

#: ../../c-api/arg.rst:574
msgid "``U`` (:class:`str` or ``None``) [const char \\*]"
msgstr "``U`` (:class:`str` or ``None``) [const char \\*]"

#: ../../c-api/arg.rst:577
msgid ""
"``U#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"
msgstr ""
"``U#`` (:class:`str` or ``None``) [const char \\*, :c:type:`Py_ssize_t`]"

#: ../../c-api/arg.rst:581
msgid "Convert a plain C :c:expr:`int` to a Python integer object."
msgstr "Преобразует обычный С :c:expr:`int` в целочисленный объект Python."

#: ../../c-api/arg.rst:583
msgid "``b`` (:class:`int`) [char]"
msgstr "``b`` (:class:`int`) [char]"

#: ../../c-api/arg.rst:584
msgid "Convert a plain C :c:expr:`char` to a Python integer object."
msgstr "Преобразует обычный С :c:expr:`char` в целочисленный объект Python."

#: ../../c-api/arg.rst:587
msgid "Convert a plain C :c:expr:`short int` to a Python integer object."
msgstr ""
"Преобразует обычный C :c:expr:`short int` в целочисленный объект Python."

#: ../../c-api/arg.rst:590
msgid "Convert a C :c:expr:`long int` to a Python integer object."
msgstr "Преобразует C :c:expr:`long int` в целочисленный объект Python."

#: ../../c-api/arg.rst:593
msgid "Convert a C :c:expr:`unsigned char` to a Python integer object."
msgstr "Преобразует C :c:expr:`unsigned char` в целочисленный объект Python."

#: ../../c-api/arg.rst:596
msgid "Convert a C :c:expr:`unsigned short int` to a Python integer object."
msgstr ""
"Преобразует C :c:expr:`unsigned short int` в целочисленный объект Python."

#: ../../c-api/arg.rst:599
msgid "Convert a C :c:expr:`unsigned int` to a Python integer object."
msgstr "Преобразует C :c:expr:`unsigned int` в целочисленный объект Python."

#: ../../c-api/arg.rst:602
msgid "Convert a C :c:expr:`unsigned long` to a Python integer object."
msgstr "Преобразует C :c:expr:`unsigned long` в целочисленный объект Python."

#: ../../c-api/arg.rst:605
msgid "Convert a C :c:expr:`long long` to a Python integer object."
msgstr "Преобразует C :c:expr:`long long` в целочисленный объект Python."

#: ../../c-api/arg.rst:608
msgid "Convert a C :c:expr:`unsigned long long` to a Python integer object."
msgstr ""
"Преобразует C :c:expr:`unsigned long long` в целочисленный объект Python."

#: ../../c-api/arg.rst:611
msgid "Convert a C :c:type:`Py_ssize_t` to a Python integer."
msgstr "Преобразует С :c:type:`Py_ssize_t` в целое число Python."

#: ../../c-api/arg.rst:613
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr "``c`` (:class:`bytes` of length 1) [char]"

#: ../../c-api/arg.rst:614
msgid ""
"Convert a C :c:expr:`int` representing a byte to a Python :class:`bytes` "
"object of length 1."
msgstr ""
"Преобразует C :c:expr:`int` представляющий байт, в объект Python :class:"
"`bytes` длиной 1."

#: ../../c-api/arg.rst:618
msgid ""
"Convert a C :c:expr:`int` representing a character to Python :class:`str` "
"object of length 1."
msgstr ""
"Преобразует C :c:expr:`int` представляющий символ, в объект Python :class:"
"`str` длиной 1."

#: ../../c-api/arg.rst:622
msgid "Convert a C :c:expr:`double` to a Python floating-point number."
msgstr "Преобразуйте C :c:expr:`double` в число Python с плавающей запятой."

#: ../../c-api/arg.rst:625
msgid "Convert a C :c:expr:`float` to a Python floating-point number."
msgstr "Преобразуйте C :c:expr:`float` в число Python с плавающей запятой."

#: ../../c-api/arg.rst:627
msgid "``D`` (:class:`complex`) [Py_complex \\*]"
msgstr "``D`` (:class:`complex`) [Py_complex \\*]"

#: ../../c-api/arg.rst:628
msgid "Convert a C :c:type:`Py_complex` structure to a Python complex number."
msgstr ""
"Преобразует структуру C :c:type:`Py_complex` в комплексное число Python."

#: ../../c-api/arg.rst:631
msgid ""
"Pass a Python object untouched but create a new :term:`strong reference` to "
"it (i.e. its reference count is incremented by one). If the object passed in "
"is a ``NULL`` pointer, it is assumed that this was caused because the call "
"producing the argument found an error and set an exception. Therefore, :c:"
"func:`Py_BuildValue` will return ``NULL`` but won't raise an exception.  If "
"no exception has been raised yet, :exc:`SystemError` is set."
msgstr ""
"Передает объект Python нетронутым, но создает новый :term:`strong reference` "
"на него (т.е. количество его ссылок увеличивается на единицу). Если "
"переданный объект является указателем ``NULL``, предполагается, что это было "
"вызвано тем, что вызов, генерирующий аргумент, обнаружил ошибку и установил "
"исключение. Следовательно, :c:func:`Py_BuildValue` вернет ``NULL`` , но не "
"вызовет исключение. Если исключение еще не было вызвано, устанавливается :"
"exc:`SystemError`."

#: ../../c-api/arg.rst:640
msgid "``S`` (object) [PyObject \\*]"
msgstr "``S`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:641
msgid "Same as ``O``."
msgstr "То же, что ``O``."

#: ../../c-api/arg.rst:643
msgid "``N`` (object) [PyObject \\*]"
msgstr "``N`` (object) [PyObject \\*]"

#: ../../c-api/arg.rst:644
msgid ""
"Same as ``O``, except it doesn't create a new :term:`strong reference`. "
"Useful when the object is created by a call to an object constructor in the "
"argument list."
msgstr ""
"То же, что и ``O``, за исключением того, что оно не создает новый :term:"
"`strong reference`. Полезно, когда объект создается вызовом конструктора "
"объекта в списке аргументов."

#: ../../c-api/arg.rst:648
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr "``O&`` (object) [*converter*, *anything*]"

#: ../../c-api/arg.rst:649
msgid ""
"Convert *anything* to a Python object through a *converter* function.  The "
"function is called with *anything* (which should be compatible with :c:expr:"
"`void*`) as its argument and should return a \"new\" Python object, or "
"``NULL`` if an error occurred."
msgstr ""
"Преобразует *anything* в объект Python с помощью функции *converter*. "
"Функция вызывается с *anything* (который должен быть совместим с :c:expr:"
"`void*`)в качестве аргумента и должна возвращать \"новый\" объект Python или "
"``NULL``, если произошла ошибка."

#: ../../c-api/arg.rst:655
msgid ""
"Convert a sequence of C values to a Python tuple with the same number of "
"items."
msgstr ""
"Преобразует последовательность значений C в кортеж Python с таким же "
"количеством элементов."

#: ../../c-api/arg.rst:657
msgid "``[items]`` (:class:`list`) [*matching-items*]"
msgstr "``[items]`` (:class:`list`) [*matching-items*]"

#: ../../c-api/arg.rst:658
msgid ""
"Convert a sequence of C values to a Python list with the same number of "
"items."
msgstr ""
"Преобразует последовательность значений C в список Python с таким же "
"количеством элементов."

#: ../../c-api/arg.rst:660
msgid "``{items}`` (:class:`dict`) [*matching-items*]"
msgstr "``{items}`` (:class:`dict`) [*matching-items*]"

#: ../../c-api/arg.rst:661
msgid ""
"Convert a sequence of C values to a Python dictionary.  Each pair of "
"consecutive C values adds one item to the dictionary, serving as key and "
"value, respectively."
msgstr ""
"Преобразует последовательность значений C в словарь Python. Каждая пара "
"последовательных значений C добавляет один элемент в словарь, служащий "
"ключом и значением соответственно."

#: ../../c-api/arg.rst:665
msgid ""
"If there is an error in the format string, the :exc:`SystemError` exception "
"is set and ``NULL`` returned."
msgstr ""
"Если в строке формата есть ошибка, устанавливается исключение :exc:"
"`SystemError` и возвращается ``NULL``."

#: ../../c-api/arg.rst:670
msgid ""
"Identical to :c:func:`Py_BuildValue`, except that it accepts a va_list "
"rather than a variable number of arguments."
msgstr ""
"Идентичен :c:func:`Py_BuildValue`, за исключением того, что он принимает "
"va_list, а не переменное количество аргументов."
