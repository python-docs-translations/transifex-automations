# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr "Инициализация, финализация и потоки"

#: ../../c-api/init.rst:10
msgid "See also :ref:`Python Initialization Configuration <init-config>`."
msgstr "См. также :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:15
msgid "Before Python Initialization"
msgstr "Перед инициализацией Python"

#: ../../c-api/init.rst:17
msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function "
"must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables "
"<global-conf-vars>`."
msgstr ""
"В приложении, встраивающем Python, функцию :c:func:`Py_Initialize` "
"необходимо вызывать перед использованием любых других функций API Python/C; "
"за исключением нескольких функций и :ref:`глобальных переменных конфигурации "
"<global-conf-vars>`."

#: ../../c-api/init.rst:22
msgid ""
"The following functions can be safely called before Python is initialized:"
msgstr "Следующие функции можно безопасно вызвать до инициализации Python:"

#: ../../c-api/init.rst:24
msgid "Configuration functions:"
msgstr "Функции настройки:"

#: ../../c-api/init.rst:26
msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

#: ../../c-api/init.rst:27
msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

#: ../../c-api/init.rst:28
msgid ":c:func:`PyInitFrozenExtensions`"
msgstr ""

#: ../../c-api/init.rst:29
msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

#: ../../c-api/init.rst:30
msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

#: ../../c-api/init.rst:31
msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

#: ../../c-api/init.rst:32
msgid ":c:func:`Py_SetPath`"
msgstr ":c:func:`Py_SetPath`"

#: ../../c-api/init.rst:33
msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

#: ../../c-api/init.rst:34
msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

#: ../../c-api/init.rst:35
msgid ":c:func:`Py_SetStandardStreamEncoding`"
msgstr ":c:func:`Py_SetStandardStreamEncoding`"

#: ../../c-api/init.rst:36
msgid ":c:func:`PySys_AddWarnOption`"
msgstr ":c:func:`PySys_AddWarnOption`"

#: ../../c-api/init.rst:37
msgid ":c:func:`PySys_AddXOption`"
msgstr ":c:func:`PySys_AddXOption`"

#: ../../c-api/init.rst:38
msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

#: ../../c-api/init.rst:40
msgid "Informative functions:"
msgstr "Информационные функции:"

#: ../../c-api/init.rst:42
msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:43
msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

#: ../../c-api/init.rst:44
msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

#: ../../c-api/init.rst:45
msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

#: ../../c-api/init.rst:46
msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

#: ../../c-api/init.rst:47
msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

#: ../../c-api/init.rst:48
msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

#: ../../c-api/init.rst:49
msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:51
msgid "Utilities:"
msgstr "Утилиты:"

#: ../../c-api/init.rst:53
msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

#: ../../c-api/init.rst:55
msgid "Memory allocators:"
msgstr "Распределители памяти:"

#: ../../c-api/init.rst:57
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:58
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/init.rst:59
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/init.rst:60
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/init.rst:64
msgid ""
"The following functions **should not be called** before :c:func:"
"`Py_Initialize`: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:"
"`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:"
"`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:"
"`Py_GetProgramName` and :c:func:`PyEval_InitThreads`."
msgstr ""
"Следующие функции ** не должны вызываться ** перед :c:func:`Py_Initialize`: :"
"c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:"
"func:`Py_GetExecPrefix`, :c:функции:`Py_GetProgramFullPath`, :c:func:"
"`Py_GetPythonHome`, :c:func:`Py_GetProgramName` и :c:func:"
"`PyEval_InitThreads`."

#: ../../c-api/init.rst:74
msgid "Global configuration variables"
msgstr "Глобальные переменные конфигурации"

#: ../../c-api/init.rst:76
msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled by :ref:"
"`command line options <using-on-interface-options>`."
msgstr ""
"В Python есть переменные для глобальной конфигурации, позволяющие управлять "
"различными функциями и параметрами. По умолчанию эти флаги контролируются :"
"ref:`параметрами командной строки <using-on-interface-options>`."

#: ../../c-api/init.rst:80
msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` sets :c:data:"
"`Py_BytesWarningFlag` to 1 and ``-bb`` sets :c:data:`Py_BytesWarningFlag` to "
"2."
msgstr ""
"Если флаг установлен опцией, значение флага равно количеству раз, когда "
"опция была установлена. Например, ``-b`` устанавливает :c:data:"
"`Py_BytesWarningFlag` равным 1, а ``-bb`` устанавливает :c:data:"
"`Py_BytesWarningFlag` равным 2."

#: ../../c-api/init.rst:86
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with :"
"class:`str` or :class:`bytes` with :class:`int`.  Issue an error if greater "
"or equal to ``2``."
msgstr ""
"Выдает предупреждение при сравнении :class:`bytes` или :class:`bytearray` с :"
"class:`str` или :class:`bytes` с :class:`int`. Выдать ошибку, если оно "
"больше или равно ``2``."

#: ../../c-api/init.rst:90
msgid "Set by the :option:`-b` option."
msgstr "Устанавливается опцией :option:`-b`."

#: ../../c-api/init.rst:94
msgid ""
"Turn on parser debugging output (for expert only, depending on compilation "
"options)."
msgstr ""
"Включите вывод отладки парсера (только для экспертов, в зависимости от "
"параметров компиляции)."

#: ../../c-api/init.rst:97
msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-d` и переменной среды :envvar:`PYTHONDEBUG`."

#: ../../c-api/init.rst:102
msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the import "
"of source modules."
msgstr ""
"Если установлено значение, отличное от нуля, Python не будет пытаться "
"записывать файлы ``.pyc`` при импорте исходных модулей."

#: ../../c-api/init.rst:105
msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ""
"Устанавливается опцией :option:`-B` и переменной среды :envvar:"
"`PYTHONDONTWRITEBYTECODE`."

#: ../../c-api/init.rst:110
msgid ""
"Suppress error messages when calculating the module search path in :c:func:"
"`Py_GetPath`."
msgstr ""
"Подавить сообщения об ошибках при вычислении пути поиска модуля в :c:func:"
"`Py_GetPath`."

#: ../../c-api/init.rst:113
msgid "Private flag used by ``_freeze_importlib`` and ``frozenmain`` programs."
msgstr ""

#: ../../c-api/init.rst:117
msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set to "
"a non-empty string."
msgstr ""
"Установите значение ``1``, если для переменной среды :envvar:"
"`PYTHONHASHSEED` задана непустая строка."

#: ../../c-api/init.rst:120
msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr ""
"Если флаг ненулевой, прочитайте переменную среды :envvar:`PYTHONHASHSEED`, "
"чтобы инициализировать секретное начальное значение хеша."

#: ../../c-api/init.rst:125
msgid ""
"Ignore all :envvar:`PYTHON*` environment variables, e.g. :envvar:"
"`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""

#: ../../c-api/init.rst:128
msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr "Устанавливается опциями :option:`-E` и :option:`-I`."

#: ../../c-api/init.rst:132
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, even "
"when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"Если сценарий передается в качестве первого аргумента или используется "
"опция :option:`-c`, войдите в интерактивный режим после выполнения сценария "
"или команды, даже если :data:`sys.stdin` не выглядит как терминал."

#: ../../c-api/init.rst:136
msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-i` и переменной среды :envvar:"
"`PYTHONINSPECT`."

#: ../../c-api/init.rst:141
msgid "Set by the :option:`-i` option."
msgstr "Устанавливается опцией :option:`-i`."

#: ../../c-api/init.rst:145
msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"Запустите Python в изолированном режиме. В изолированном режиме :data:`sys."
"path` не содержит ни каталога сценария, ни каталога пакетов сайта "
"пользователя."

#: ../../c-api/init.rst:148
msgid "Set by the :option:`-I` option."
msgstr "Устанавливается опцией :option:`-I`."

#: ../../c-api/init.rst:154
msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error "
"handler, instead of the UTF-8 encoding with ``surrogatepass`` error handler, "
"for the :term:`filesystem encoding and error handler`."
msgstr ""
"Если флаг ненулевой, используйте кодировку mbcs с обработчиком ошибок "
"replace вместо кодировки UTF-8 с обработчиком ошибок surrogatepass для "
"кодировки файловой системы и обработчик ошибок`."

#: ../../c-api/init.rst:158
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
"Установите значение ``1``, если для переменной среды :envvar:"
"`PYTHONLEGACYWINDOWSFSENCODING` задана непустая строка."

#: ../../c-api/init.rst:161
msgid "See :pep:`529` for more details."
msgstr "См. :pep:`529` для более подробной информации."

#: ../../c-api/init.rst:163 ../../c-api/init.rst:175
msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Availability <availability>`: Windows."

#: ../../c-api/init.rst:167
msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of :class:"
"`WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""

#: ../../c-api/init.rst:170
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment variable "
"is set to a non-empty string."
msgstr ""
"Установите значение ``1``, если для переменной среды :envvar:"
"`PYTHONLEGACYWINDOWSSTDIO` задана непустая строка."

#: ../../c-api/init.rst:173
msgid "See :pep:`528` for more details."
msgstr "См. :pep:`528` для более подробной информации."

#: ../../c-api/init.rst:179
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call :func:`site."
"main` if you want them to be triggered)."
msgstr ""
"Отключите импорт модуля :mod:`site` и связанные с ним манипуляции с :data:"
"`sys.path`, зависящие от сайта. Также отключите эти манипуляции, если :mod:"
"`site` будет явно импортирован позже (вызовите :func:`site.main`, если вы "
"хотите, чтобы они запускались)."

#: ../../c-api/init.rst:184
msgid "Set by the :option:`-S` option."
msgstr "Устанавливается опцией :option:`-S`."

#: ../../c-api/init.rst:188
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to :data:"
"`sys.path`."
msgstr ""
"Не добавляйте каталог :data:`user site-packages <site.USER_SITE>` в :data:"
"`sys.path`."

#: ../../c-api/init.rst:191
msgid ""
"Set by the :option:`-s` and :option:`-I` options, and the :envvar:"
"`PYTHONNOUSERSITE` environment variable."
msgstr ""
"Устанавливается параметрами :option:`-s` и :option:`-I`, а также переменной "
"среды :envvar:`PYTHONNOUSERSITE`."

#: ../../c-api/init.rst:196
msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-O` и переменной среды :envvar:"
"`PYTHONOPTIMIZE`."

#: ../../c-api/init.rst:201
msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr ""
"Не отображайте сообщения об авторских правах и версии даже в интерактивном "
"режиме."

#: ../../c-api/init.rst:203
msgid "Set by the :option:`-q` option."
msgstr "Устанавливается опцией :option:`-q`."

#: ../../c-api/init.rst:209
msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "Принудительно отключить буферизацию потоков stdout и stderr."

#: ../../c-api/init.rst:211
msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ""
"Устанавливается опцией :option:`-u` и переменной среды :envvar:"
"`PYTHONUNBUFFERED`."

#: ../../c-api/init.rst:216
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or equal "
"to ``2``, print a message for each file that is checked for when searching "
"for a module. Also provides information on module cleanup at exit."
msgstr ""
"Выводите сообщение каждый раз при инициализации модуля, показывая место (имя "
"файла или встроенный модуль), из которого он загружен. Если больше или равно "
"``2``, выведите сообщение для каждого файла, который проверяется при поиске "
"модуля. Также предоставляет информацию об очистке модуля при выходе."

#: ../../c-api/init.rst:221
msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-v` и переменной среды :envvar:"
"`PYTHONVERBOSE`."

#: ../../c-api/init.rst:226
msgid "Initializing and finalizing the interpreter"
msgstr "Инициализация и финализация интерпретатора"

#: ../../c-api/init.rst:244
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; see :"
"ref:`Before Python Initialization <pre-init-safe>` for the few exceptions."
msgstr ""
"Инициализируйте интерпретатор Python. В приложении, встраивающем Python, его "
"следует вызывать перед использованием любых других функций API Python/C; "
"см. :ref:`Before Python Initialization <pre-init-safe>` для нескольких "
"исключений."

#: ../../c-api/init.rst:248
msgid ""
"This initializes the table of loaded modules (``sys.modules``), and creates "
"the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`.  It "
"also initializes the module search path (``sys.path``). It does not set "
"``sys.argv``; use :c:func:`PySys_SetArgvEx` for that.  This is a no-op when "
"called for a second time (without calling :c:func:`Py_FinalizeEx` first).  "
"There is no return value; it is a fatal error if the initialization fails."
msgstr ""
"Это инициализирует таблицу загруженных модулей (``sys.modules``) и создает "
"основные модули :mod:`builtins`, :mod:`__main__` и :mod:`sys`. Он также "
"инициализирует путь поиска модуля (``sys.path``). Он не устанавливает ``sys."
"argv``; используйте для этого :c:func:`PySys_SetArgvEx`. Это пустая операция "
"при втором вызове (без первого вызова :c:func:`Py_FinalizeEx`). "
"Возвращаемого значения нет; это фатальная ошибка, если инициализация не "
"удалась."

#: ../../c-api/init.rst:257
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"В Windows изменяет режим консоли с ``O_TEXT`` на ``O_BINARY``, что также "
"повлияет на использование консоли не на Python с использованием среды "
"выполнения C."

#: ../../c-api/init.rst:263
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which might be useful when Python is embedded."
msgstr ""
"Эта функция работает как :c:func:`Py_Initialize`, если *initsigs* равен "
"``1``. Если *initsigs* равен ``0``, он пропускает регистрацию инициализации "
"обработчиков сигналов, что может быть полезно при встроенном Python."

#: ../../c-api/init.rst:270
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Возвращайте true (не ноль), если интерпретатор Python был инициализирован, и "
"false (ноль), если нет. После вызова :c:func:`Py_FinalizeEx` он возвращает "
"false до тех пор, пока :c:func:`Py_Initialize` не будет вызван снова."

#: ../../c-api/init.rst:277
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters (see :c:func:"
"`Py_NewInterpreter` below) that were created and not yet destroyed since the "
"last call to :c:func:`Py_Initialize`.  Ideally, this frees all memory "
"allocated by the Python interpreter.  This is a no-op when called for a "
"second time (without calling :c:func:`Py_Initialize` again first).  Normally "
"the return value is ``0``.  If there were errors during finalization "
"(flushing buffered data), ``-1`` is returned."
msgstr ""

#: ../../c-api/init.rst:286
msgid ""
"This function is provided for a number of reasons.  An embedding application "
"might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks "
"in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"Эта функция предусмотрена по ряду причин. Встраиваемому приложению может "
"потребоваться перезапустить Python без перезапуска самого приложения. "
"Приложение, загрузившее интерпретатор Python из динамически загружаемой "
"библиотеки (или DLL), может захотеть освободить всю память, выделенную "
"Python, перед выгрузкой DLL. Во время поиска утечек памяти в приложении "
"разработчик может захотеть освободить всю память, выделенную Python, перед "
"выходом из приложения."

#: ../../c-api/init.rst:294
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`__del__` methods) "
"to fail when they depend on other objects (even functions) or modules.  "
"Dynamically loaded extension modules loaded by Python are not unloaded.  "
"Small amounts of memory allocated by the Python interpreter may not be freed "
"(if you find a leak, please report it).  Memory tied up in circular "
"references between objects is not freed.  Some memory allocated by extension "
"modules may not be freed.  Some extensions may not work properly if their "
"initialization routine is called more than once; this can happen if an "
"application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` more "
"than once."
msgstr ""

#: ../../c-api/init.rst:305
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"_PySys_ClearAuditHooks`` with no arguments."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``cpython._PySys_ClearAuditHooks`` "
"без аргументов."

#: ../../c-api/init.rst:311
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr ""
"Это обратно совместимая версия :c:func:`Py_FinalizeEx`, которая игнорирует "
"возвращаемое значение."

#: ../../c-api/init.rst:316
msgid "Process-wide parameters"
msgstr "Общепроцессные параметры"

#: ../../c-api/init.rst:326
msgid ""
"This function should be called before :c:func:`Py_Initialize`, if it is "
"called at all. It specifies which encoding and error handling to use with "
"standard IO, with the same meanings as in :func:`str.encode`."
msgstr ""
"Эту функцию следует вызывать до :c:func:`Py_Initialize`, если она вообще "
"вызывается. Он определяет, какую кодировку и обработку ошибок использовать "
"со стандартным вводом-выводом, с теми же значениями, что и в :func:`str."
"encode`."

#: ../../c-api/init.rst:330
msgid ""
"It overrides :envvar:`PYTHONIOENCODING` values, and allows embedding code to "
"control IO encoding when the environment variable does not work."
msgstr ""
"Он переопределяет значения :envvar:`PYTHONIOENCODING` и позволяет встраивать "
"код для управления кодировкой ввода-вывода, когда переменная среды не "
"работает."

#: ../../c-api/init.rst:333
msgid ""
"*encoding* and/or *errors* may be ``NULL`` to use :envvar:`PYTHONIOENCODING` "
"and/or default values (depending on other settings)."
msgstr ""
"*кодирование* и/или *ошибки* могут иметь значение ``NULL`` для "
"использования :envvar:`PYTHONIOENCODING` и/или значений по умолчанию (в "
"зависимости от других настроек)."

#: ../../c-api/init.rst:337
msgid ""
"Note that :data:`sys.stderr` always uses the \"backslashreplace\" error "
"handler, regardless of this (or any other) setting."
msgstr ""
"Обратите внимание, что :data:`sys.stderr` всегда использует обработчик "
"ошибок «обратная косая черта», независимо от этого (или любого другого) "
"параметра."

#: ../../c-api/init.rst:340
msgid ""
"If :c:func:`Py_FinalizeEx` is called, this function will need to be called "
"again in order to affect subsequent calls to :c:func:`Py_Initialize`."
msgstr ""
"Если вызывается :c:func:`Py_FinalizeEx`, эту функцию необходимо будет "
"вызвать еще раз, чтобы повлиять на последующие вызовы :c:func:"
"`Py_Initialize`."

#: ../../c-api/init.rst:343
msgid ""
"Returns ``0`` if successful, a nonzero value on error (e.g. calling after "
"the interpreter has already been initialized)."
msgstr ""
"Возвращает ``0`` в случае успеха, ненулевое значение в случае ошибки "
"(например, вызов после того, как интерпретатор уже был инициализирован)."

#: ../../c-api/init.rst:356
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to "
"the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Эту функцию следует вызывать до первого вызова :c:func:`Py_Initialize`, если "
"она вообще вызывается. Он сообщает интерпретатору значение аргумента "
"``argv[0]`` функции :c:func:`main` программы (преобразованное в широкие "
"символы). Это используется :c:func:`Py_GetPath` и некоторыми другими "
"функциями ниже для поиска библиотек времени выполнения Python относительно "
"исполняемого файла интерпретатора. Значение по умолчанию — ``'python'``. "
"Аргумент должен указывать на строку широких символов с нулевым завершением в "
"статической памяти, содержимое которой не изменится во время выполнения "
"программы. Никакой код в интерпретаторе Python не изменит содержимое этого "
"хранилища."

#: ../../c-api/init.rst:367 ../../c-api/init.rst:511 ../../c-api/init.rst:617
#: ../../c-api/init.rst:644 ../../c-api/init.rst:661
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a :c:expr:"
"`wchar_*` string."
msgstr ""
"Используйте :c:func:`Py_DecodeLocale` для декодирования строки байтов и "
"получения строки :c:expr:`wchar_*`."

#: ../../c-api/init.rst:375
msgid ""
"Return the program name set with :c:func:`Py_SetProgramName`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""
"Возвращает имя программы, установленное с помощью :c:func:"
"`Py_SetProgramName` или значение по умолчанию. Возвращенная строка указывает "
"на статическое хранилище; вызывающая сторона не должна изменять его значение."

#: ../../c-api/init.rst:379 ../../c-api/init.rst:398 ../../c-api/init.rst:439
#: ../../c-api/init.rst:458 ../../c-api/init.rst:482 ../../c-api/init.rst:671
msgid ""
"This function should not be called before :c:func:`Py_Initialize`, otherwise "
"it returns ``NULL``."
msgstr ""
"Эту функцию не следует вызывать до :c:func:`Py_Initialize`, иначе она вернет "
"``NULL``."

#: ../../c-api/init.rst:382 ../../c-api/init.rst:401 ../../c-api/init.rst:442
#: ../../c-api/init.rst:461 ../../c-api/init.rst:487 ../../c-api/init.rst:674
msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr "Теперь он возвращает NULL, если был вызван до :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:388
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller "
"should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the :option:`--prefix` "
"argument to the :program:`configure` script at build time.  The value is "
"available to Python code as ``sys.prefix``. It is only useful on Unix.  See "
"also the next function."
msgstr ""
"Верните *префикс* для установленных файлов, независимых от платформы. Это "
"получается с помощью ряда сложных правил из имени программы, заданного с "
"помощью :c:func:`Py_SetProgramName` и некоторых переменных среды; например, "
"если имя программы ``'/usr/local/bin/python'``, префикс будет ``'/usr/"
"local'``. Возвращенная строка указывает на статическое хранилище; вызывающая "
"сторона не должна изменять его значение. Это соответствует переменной :"
"makevar:`prefix` в :file:`Makefile` верхнего уровня и аргументу :option:`--"
"prefix` скрипта :program:`configure` во время сборки. Это значение доступно "
"для кода Python как ``sys.prefix``. Это полезно только в Unix. См. также "
"следующую функцию."

#: ../../c-api/init.rst:407
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix "
"is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to the :makevar:"
"`exec_prefix` variable in the top-level :file:`Makefile` and the ``--exec-"
"prefix`` argument to the :program:`configure` script at build  time.  The "
"value is available to Python code as ``sys.exec_prefix``.  It is only useful "
"on Unix."
msgstr ""
"Верните *exec-префикс* для установленных *зависимых* от платформы файлов. "
"Это получается с помощью ряда сложных правил из имени программы, заданного с "
"помощью :c:func:`Py_SetProgramName` и некоторых переменных среды; например, "
"если имя программы ``'/usr/local/bin/python'``, префикс exec будет ``'/usr/"
"local'``. Возвращенная строка указывает на статическое хранилище; вызывающая "
"сторона не должна изменять его значение. Это соответствует переменной :"
"makevar:`exec_prefix` в :file:`Makefile` верхнего уровня и аргументу ``--"
"exec-prefix`` сценария :program:`configure` во время сборки. Это значение "
"доступно для кода Python как ``sys.exec_prefix``. Это полезно только в Unix."

#: ../../c-api/init.rst:417
msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform "
"independent may be installed in :file:`/usr/local`."
msgstr ""
"Справочная информация. Префикс exec-prefix отличается от префикса, когда "
"файлы, зависящие от платформы (например, исполняемые файлы и общие "
"библиотеки), устанавливаются в другое дерево каталогов. При типичной "
"установке файлы, зависящие от платформы, могут быть установлены в поддереве :"
"file:`/usr/local/plat`, тогда как независимые от платформы файлы могут быть "
"установлены в :file:`/usr/local`."

#: ../../c-api/init.rst:423
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system generally "
"also form different platforms.  Non-Unix operating systems are a different "
"story; the installation strategies on those systems are so different that "
"the prefix and exec-prefix are meaningless, and set to the empty string. "
"Note that compiled Python bytecode files are platform independent (but not "
"independent from the Python version by which they were compiled!)."
msgstr ""
"Вообще говоря, платформа представляет собой комбинацию семейств аппаратного "
"и программного обеспечения, например, машины Sparc под управлением "
"операционной системы Solaris 2.x считаются одной и той же платформой, но "
"машины Intel под управлением Solaris 2.x — это другая платформа, а машины "
"Intel под управлением Linux — еще одна платформа. другая платформа. "
"Различные основные версии одной и той же операционной системы обычно "
"образуют разные платформы. Операционные системы, отличные от Unix, — это "
"совсем другая история; стратегии установки в этих системах настолько "
"различны, что префикс и префикс exec не имеют смысла и устанавливаются в "
"пустую строку. Обратите внимание, что скомпилированные файлы байт-кода "
"Python не зависят от платформы (но не от версии Python, с помощью которой "
"они были скомпилированы!)."

#: ../../c-api/init.rst:434
msgid ""
"System administrators will know how to configure the :program:`mount` or :"
"program:`automount` programs to share :file:`/usr/local` between platforms "
"while having :file:`/usr/local/plat` be a different filesystem for each "
"platform."
msgstr ""
"Системные администраторы знают, как настроить программы :program:`mount` "
"или :program:`automount` для совместного использования :file:`/usr/local` "
"между платформами, при этом :file:`/usr/local/plat` будет разные файловые "
"системы для каждой платформы."

#: ../../c-api/init.rst:452
msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:func:`Py_SetProgramName` above). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""
"Вернуть полное имя исполняемого файла Python; это вычисляется как побочный "
"эффект получения пути поиска модуля по умолчанию из имени программы "
"(установленного :c:func:`Py_SetProgramName` выше). Возвращенная строка "
"указывает на статическое хранилище; вызывающий абонент не должен изменять "
"его значение. Это значение доступно для кода Python как ``sys.executable``."

#: ../../c-api/init.rst:472
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:func:`Py_SetProgramName` above) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path "
"for loading modules."
msgstr ""
"Вернуть путь поиска модуля по умолчанию; это вычисляется на основе имени "
"программы (установленного :c:func:`Py_SetProgramName` выше) и некоторых "
"переменных среды. Возвращенная строка состоит из серии имен каталогов, "
"разделенных символом-разделителем, зависящим от платформы. Символом-"
"разделителем является ``':'`` в Unix и macOS, ``';'`` в Windows. "
"Возвращенная строка указывает на статическое хранилище; вызывающая сторона "
"не должна изменять его значение. Список :data:`sys.path` инициализируется "
"этим значением при запуске интерпретатора; его можно (и обычно это делается) "
"изменить позже, чтобы изменить путь поиска для загрузки модулей."

#: ../../c-api/init.rst:498
msgid ""
"Set the default module search path.  If this function is called before :c:"
"func:`Py_Initialize`, then :c:func:`Py_GetPath` won't attempt to compute a "
"default search path but uses the one provided instead.  This is useful if "
"Python is embedded by an application that has full knowledge of the location "
"of all modules.  The path components should be separated by the platform "
"dependent delimiter character, which is ``':'`` on Unix and macOS, ``';'`` "
"on Windows."
msgstr ""
"Установите путь поиска модулей по умолчанию. Если эта функция вызывается до :"
"c:func:`Py_Initialize`, то :c:func:`Py_GetPath` не будет пытаться вычислить "
"путь поиска по умолчанию, а вместо этого будет использовать предоставленный. "
"Это полезно, если Python встроен в приложение, которое полностью знает "
"расположение всех модулей. Компоненты пути должны быть разделены символом-"
"разделителем, зависящим от платформы, который имеет вид ``':'`` в Unix и "
"macOS, ``';'`` в Windows."

#: ../../c-api/init.rst:506
msgid ""
"This also causes :data:`sys.executable` to be set to the program full path "
"(see :c:func:`Py_GetProgramFullPath`) and for :data:`sys.prefix` and :data:"
"`sys.exec_prefix` to be empty.  It is up to the caller to modify these if "
"required after calling :c:func:`Py_Initialize`."
msgstr ""
"Это также приводит к тому, что :data:`sys.executable` будет установлен на "
"полный путь программы (см. :c:func:`Py_GetProgramFullPath`), а для :data:"
"`sys.prefix` и :data:`sys.exec_prefix` быть пустым. Вызывающая сторона может "
"изменить их, если это необходимо, после вызова :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:514
msgid ""
"The path argument is copied internally, so the caller may free it after the "
"call completes."
msgstr ""
"Аргумент пути копируется внутри, поэтому вызывающая сторона может освободить "
"его после завершения вызова."

#: ../../c-api/init.rst:517
msgid ""
"The program full path is now used for :data:`sys.executable`, instead of the "
"program name."
msgstr ""
"Полный путь к программе теперь используется для :data:`sys.executable` "
"вместо имени программы."

#: ../../c-api/init.rst:524
msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr ""
"Верните версию этого интерпретатора Python. Это строка, которая выглядит "
"примерно так::"

#: ../../c-api/init.rst:531
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated by a "
"period.  The returned string points into static storage; the caller should "
"not modify its value.  The value is available to Python code as :data:`sys."
"version`."
msgstr ""
"Первое слово (до первого пробела) — это текущая версия Python; первые "
"символы — это основная и второстепенная версии, разделенные точкой. "
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Это значение доступно для кода Python как :"
"data:`sys.version`."

#: ../../c-api/init.rst:541
msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On macOS, it "
"is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.platform``."
msgstr ""
"Возвращает идентификатор текущей платформы. В Unix оно формируется из "
"«официального» названия операционной системы, преобразованного в нижний "
"регистр, за которым следует основной номер версии; например, для Solaris 2."
"x, который также известен как SunOS 5.x, значение равно ``'sunos5'``. В "
"macOS это «Дарвин». В Windows это ``'win'``. Возвращенная строка указывает "
"на статическое хранилище; вызывающий абонент не должен изменять его "
"значение. Значение доступно для кода Python как ``sys.platform``."

#: ../../c-api/init.rst:552
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr ""
"Возвратите официальную строку авторских прав для текущей версии Python, "
"например"

#: ../../c-api/init.rst:554
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:558
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Это значение доступно для кода Python как "
"``sys.copyright``."

#: ../../c-api/init.rst:564
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr ""
"Возвращает указание компилятора, использованного для сборки текущей версии "
"Python, в квадратных скобках, например::"

#: ../../c-api/init.rst:571 ../../c-api/init.rst:585
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Это значение доступно для кода Python как "
"часть переменной ``sys.version``."

#: ../../c-api/init.rst:578
msgid ""
"Return information about the sequence number and build date and time  of the "
"current Python interpreter instance, for example ::"
msgstr ""
"Возвращает информацию о порядковом номере, дате и времени сборки текущего "
"экземпляра интерпретатора Python, например:::"

#: ../../c-api/init.rst:597
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"Установите :data:`sys.argv` на основе *argc* и *argv*. Эти параметры "
"аналогичны параметрам, передаваемым в функцию :c:func:`main` программы, с "
"той разницей, что первая запись должна ссылаться на файл сценария, который "
"должен быть выполнен, а не на исполняемый файл, в котором размещен "
"интерпретатор Python. Если скрипта, который будет запущен, нет, первая "
"запись в *argv* может быть пустой строкой. Если этой функции не удается "
"инициализировать :data:`sys.argv`, фатальное состояние сигнализируется с "
"помощью :c:func:`Py_FatalError`."

#: ../../c-api/init.rst:605
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"Если *updatepath* равен нулю, это все, что делает функция. Если *updatepath* "
"ненулевое значение, функция также изменяет :data:`sys.path` в соответствии "
"со следующим алгоритмом:"

#: ../../c-api/init.rst:609
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to :data:`sys."
"path`."
msgstr ""
"Если имя существующего скрипта передается в ``argv[0]``, к :data:`sys.path` "
"добавляется абсолютный путь к каталогу, в котором находится скрипт."

#: ../../c-api/init.rst:612
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which "
"is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"В противном случае (то есть, если *argc* равен ``0`` или ``argv[0]`` не "
"указывает на существующее имя файла), перед :data:`sys.path` добавляется "
"пустая строка, это то же самое, что добавление текущего рабочего каталога "
"(``\".\"``)."

#: ../../c-api/init.rst:621
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See `CVE-2008-5983 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_."
msgstr ""

#: ../../c-api/init.rst:626
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called :c:func:"
"`PySys_SetArgv`, for example using::"
msgstr ""
"В версиях до 3.1.3 вы можете добиться того же эффекта, вручную извлекая "
"первый элемент :data:`sys.path` после вызова :c:func:`PySys_SetArgv`, "
"например, используя::"

#: ../../c-api/init.rst:640
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with the :option:"
"`-I`."
msgstr ""
"Эта функция работает как :c:func:`PySys_SetArgvEx` с параметром "
"*updatepath*, установленным в ``1``, если только интерпретатор :program:"
"`python` не был запущен с :option:`-I`."

#: ../../c-api/init.rst:647
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "Значение *updatepath* зависит от :option:`-I`."

#: ../../c-api/init.rst:652
msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"Установите «домашний» каталог по умолчанию, то есть расположение стандартных "
"библиотек Python. См. :envvar:`PYTHONHOME`, чтобы узнать значение строки "
"аргумента."

#: ../../c-api/init.rst:656
msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Аргумент должен указывать на символьную строку с нулевым завершением в "
"статической памяти, содержимое которой не изменится во время выполнения "
"программы. Никакой код в интерпретаторе Python не изменит содержимое этого "
"хранилища."

#: ../../c-api/init.rst:667
msgid ""
"Return the default \"home\", that is, the value set by a previous call to :c:"
"func:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""
"Возвращает «домой» по умолчанию, то есть значение, установленное предыдущим "
"вызовом :c:func:`Py_SetPythonHome`, или значение переменной среды :envvar:"
"`PYTHONHOME`, если она установлена."

#: ../../c-api/init.rst:681
msgid "Thread State and the Global Interpreter Lock"
msgstr "Состояние потока и глобальная блокировка интерпретатора"

#: ../../c-api/init.rst:688
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Интерпретатор Python не является полностью потокобезопасным. Для поддержки "
"многопоточных программ Python существует глобальная блокировка, называемая :"
"term:`глобальной блокировкой интерпретатора` или :term:`GIL`, которая должна "
"удерживаться текущим потоком, прежде чем он сможет безопасно получить доступ "
"к объектам Python. Без блокировки даже самые простые операции могут вызвать "
"проблемы в многопоточной программе: например, когда два потока одновременно "
"увеличивают счетчик ссылок одного и того же объекта, счетчик ссылок может "
"увеличиться только один раз, а не дважды."

#: ../../c-api/init.rst:698
msgid ""
"Therefore, the rule exists that only the thread that has acquired the :term:"
"`GIL` may operate on Python objects or call Python/C API functions. In order "
"to emulate concurrency of execution, the interpreter regularly tries to "
"switch threads (see :func:`sys.setswitchinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""
"Следовательно, существует правило, согласно которому только поток, "
"получивший :term:`GIL`, может работать с объектами Python или вызывать "
"функции API Python/C. Чтобы эмулировать параллельное выполнение, "
"интерпретатор регулярно пытается переключать потоки (см. :func:`sys."
"setswitchinterval`). Блокировка также снимается для потенциальной блокировки "
"операций ввода-вывода, таких как чтение или запись файла, чтобы в это время "
"могли выполняться другие потоки Python."

#: ../../c-api/init.rst:709
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`.  There's also one "
"global variable pointing to the current :c:type:`PyThreadState`: it can be "
"retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"Интерпретатор Python хранит некоторую учетную информацию, специфичную для "
"потока, внутри структуры данных, называемой :c:type:`PyThreadState`. Также "
"есть одна глобальная переменная, указывающая на текущий :c:type:"
"`PyThreadState`: ее можно получить с помощью :c:func:`PyThreadState_Get`."

#: ../../c-api/init.rst:715
msgid "Releasing the GIL from extension code"
msgstr "Освобождение GIL из кода расширения"

#: ../../c-api/init.rst:717
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr ""
"Большая часть кода расширения, управляющего :term:`GIL`, имеет следующую "
"простую структуру::"

#: ../../c-api/init.rst:726
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"Это настолько распространено, что существует пара макросов для упрощения:"

#: ../../c-api/init.rst:736
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the "
"block."
msgstr ""
"Макрос :c:macro:`Py_BEGIN_ALLOW_THREADS` открывает новый блок и объявляет "
"скрытую локальную переменную; Макрос :c:macro:`Py_END_ALLOW_THREADS` "
"закрывает блок."

#: ../../c-api/init.rst:740
msgid "The block above expands to the following code::"
msgstr "Блок выше расширяется до следующего кода:"

#: ../../c-api/init.rst:752
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"Вот как работают эти функции: глобальная блокировка интерпретатора "
"используется для защиты указателя на текущее состояние потока. При снятии "
"блокировки и сохранении состояния потока указатель текущего состояния потока "
"должен быть получен до того, как блокировка будет снята (поскольку другой "
"поток может немедленно получить блокировку и сохранить свое собственное "
"состояние потока в глобальной переменной). И наоборот, при получении "
"блокировки и восстановлении состояния потока блокировка должна быть получена "
"до сохранения указателя состояния потока."

#: ../../c-api/init.rst:761
msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""
"Вызов системных функций ввода-вывода является наиболее распространенным "
"вариантом использования для освобождения GIL, но он также может быть полезен "
"перед вызовом длительных вычислений, которым не требуется доступ к объектам "
"Python, например, функции сжатия или шифрования, работающие с буферами "
"памяти. Например, стандартные модули :mod:`zlib` и :mod:`hashlib` "
"освобождают GIL при сжатии или хешировании данных."

#: ../../c-api/init.rst:772
msgid "Non-Python created threads"
msgstr "Потоки, созданные не на Python"

#: ../../c-api/init.rst:774
msgid ""
"When threads are created using the dedicated Python APIs (such as the :mod:"
"`threading` module), a thread state is automatically associated to them and "
"the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""
"Когда потоки создаются с использованием выделенных API-интерфейсов Python "
"(таких как модуль :mod:`threading`), состояние потока автоматически "
"связывается с ними, и поэтому код, показанный выше, является правильным. "
"Однако, когда потоки создаются из C (например, сторонней библиотекой с "
"собственным управлением потоками), они не содержат GIL, и для них не "
"существует структуры состояния потока."

#: ../../c-api/init.rst:781
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you "
"are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""
"Если вам нужно вызвать код Python из этих потоков (часто это будет частью "
"API обратного вызова, предоставляемого вышеупомянутой сторонней "
"библиотекой), вы должны сначала зарегистрировать эти потоки в "
"интерпретаторе, создав структуру данных состояния потока, а затем получив "
"GIL и, наконец, сохранение указателя состояния потока, прежде чем вы сможете "
"начать использовать API Python/C. Когда вы закончите, вам следует сбросить "
"указатель состояния потока, освободить GIL и, наконец, освободить структуру "
"данных состояния потока."

#: ../../c-api/init.rst:789
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
"Функции :c:func:`PyGILState_Ensure` и :c:func:`PyGILState_Release` выполняют "
"все вышеперечисленное автоматически. Типичная идиома для вызова Python из "
"потока C:"

#: ../../c-api/init.rst:803
msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters (using :c:func:"
"`Py_NewInterpreter`), but mixing multiple interpreters and the "
"``PyGILState_*`` API is unsupported."
msgstr ""
"Обратите внимание, что функции ``PyGILState_*`` предполагают, что существует "
"только один глобальный интерпретатор (созданный автоматически :c:func:"
"`Py_Initialize`). Python поддерживает создание дополнительных "
"интерпретаторов (с использованием :c:func:`Py_NewInterpreter`), но "
"смешивание нескольких интерпретаторов и API ``PyGILState_*`` не "
"поддерживается."

#: ../../c-api/init.rst:813
msgid "Cautions about fork()"
msgstr "Предостережения относительно fork()"

#: ../../c-api/init.rst:815
msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist.  This has a "
"concrete impact both on how locks must be handled and on all stored state in "
"CPython's runtime."
msgstr ""
"Еще одна важная вещь, которую следует отметить в отношении потоков, — это их "
"поведение при вызове C :c:func:`fork`. В большинстве систем с :c:func:`fork` "
"после разветвления процесса будет существовать только поток, выдавший "
"разветвление. Это оказывает конкретное влияние как на то, как должны "
"обрабатываться блокировки, так и на все сохраненные состояния во время "
"выполнения CPython."

#: ../../c-api/init.rst:821
msgid ""
"The fact that only the \"current\" thread remains means any locks held by "
"other threads will never be released. Python solves this for :func:`os.fork` "
"by acquiring the locks it uses internally before the fork, and releasing "
"them afterwards. In addition, it resets any :ref:`lock-objects` in the "
"child. When extending or embedding Python, there is no way to inform Python "
"of additional (non-Python) locks that need to be acquired before or reset "
"after a fork. OS facilities such as :c:func:`pthread_atfork` would need to "
"be used to accomplish the same thing. Additionally, when extending or "
"embedding Python, calling :c:func:`fork` directly rather than through :func:"
"`os.fork` (and returning to or calling into Python) may result in a deadlock "
"by one of Python's internal locks being held by a thread that is defunct "
"after the fork. :c:func:`PyOS_AfterFork_Child` tries to reset the necessary "
"locks, but is not always able to."
msgstr ""

#: ../../c-api/init.rst:836
msgid ""
"The fact that all other threads go away also means that CPython's runtime "
"state there must be cleaned up properly, which :func:`os.fork` does.  This "
"means finalizing all other :c:type:`PyThreadState` objects belonging to the "
"current interpreter and all other :c:type:`PyInterpreterState` objects.  Due "
"to this and the special nature of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`, :c:func:`fork` should only be called in that "
"interpreter's \"main\" thread, where the CPython global runtime was "
"originally initialized. The only exception is if :c:func:`exec` will be "
"called immediately after."
msgstr ""
"Тот факт, что все остальные потоки исчезают, также означает, что состояние "
"времени выполнения CPython должно быть должным образом очищено, что и "
"делает :func:`os.fork`. Это означает финализацию всех остальных объектов :c:"
"type:`PyThreadState`, принадлежащих текущему интерпретатору, и всех "
"остальных объектов :c:type:`PyInterpreterState`. Из-за этого, а также из-за "
"особой природы :ref:`\"main\" интерпретатора <sub-interpreter-support>`, :c:"
"func:`fork` следует вызывать только в \"основном\" потоке этого "
"интерпретатора, где глобальный CPython среда выполнения была изначально "
"инициализирована. Единственное исключение — если сразу после этого будет "
"вызвана :c:func:`exec`."

#: ../../c-api/init.rst:849
msgid "High-level API"
msgstr "Высокоуровневый API"

#: ../../c-api/init.rst:851
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""
"Это наиболее часто используемые типы и функции при написании кода расширения "
"C или при внедрении интерпретатора Python:"

#: ../../c-api/init.rst:856
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"Эта структура данных представляет состояние, разделяемое несколькими "
"взаимодействующими потоками. Потоки, принадлежащие одному и тому же "
"интерпретатору, совместно используют административные модули и некоторые "
"другие внутренние элементы. В этой структуре нет публичных членов."

#: ../../c-api/init.rst:861
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"Потоки, принадлежащие разным интерпретаторам, изначально ничего не "
"разделяют, кроме состояния процесса, такого как доступная память, "
"дескрипторы открытых файлов и т. д. Глобальная блокировка интерпретатора "
"также используется всеми потоками, независимо от того, какому интерпретатору "
"они принадлежат."

#: ../../c-api/init.rst:869
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is :attr:`interp` (:c:expr:`PyInterpreterState *`), which "
"points to this thread's interpreter state."
msgstr ""

#: ../../c-api/init.rst:882
msgid "Deprecated function which does nothing."
msgstr "Устаревшая функция, которая ничего не делает."

#: ../../c-api/init.rst:884
msgid ""
"In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr ""
"В Python 3.6 и старше эта функция создавала GIL, если он не существовал."

#: ../../c-api/init.rst:886
msgid "The function now does nothing."
msgstr "Функция теперь ничего не делает."

#: ../../c-api/init.rst:889
msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't have "
"to call it yourself anymore."
msgstr ""
"Эта функция теперь вызывается :c:func:`Py_Initialize()`, поэтому вам больше "
"не придется вызывать ее самостоятельно."

#: ../../c-api/init.rst:893
msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr "Эту функцию больше нельзя вызывать до :c:func:`Py_Initialize()`."

#: ../../c-api/init.rst:903
msgid ""
"Returns a non-zero value if :c:func:`PyEval_InitThreads` has been called.  "
"This function can be called without holding the GIL, and therefore can be "
"used to avoid calls to the locking API when running single-threaded."
msgstr ""
"Возвращает ненулевое значение, если была вызвана :c:func:"
"`PyEval_InitThreads`. Эту функцию можно вызвать без сохранения GIL и, "
"следовательно, ее можно использовать, чтобы избежать вызовов API блокировки "
"при однопоточной работе."

#: ../../c-api/init.rst:907
msgid "The :term:`GIL` is now initialized by :c:func:`Py_Initialize()`."
msgstr ""
":term:`GIL` теперь инициализируется с помощью :c:func:`Py_Initialize()`."

#: ../../c-api/init.rst:915
msgid ""
"Release the global interpreter lock (if it has been created) and reset the "
"thread state to ``NULL``, returning the previous thread state (which is not "
"``NULL``).  If the lock has been created, the current thread must have "
"acquired it."
msgstr ""
"Снимите глобальную блокировку интерпретатора (если она была создана) и "
"сбросьте состояние потока на NULL, вернув предыдущее состояние потока "
"(которое не равно NULL). Если блокировка была создана, текущий поток должен "
"ее получить."

#: ../../c-api/init.rst:923
msgid ""
"Acquire the global interpreter lock (if it has been created) and set the "
"thread state to *tstate*, which must not be ``NULL``.  If the lock has been "
"created, the current thread must not have acquired it, otherwise deadlock "
"ensues."
msgstr ""
"Получите глобальную блокировку интерпретатора (если она была создана) и "
"установите состояние потока в *tstate*, которое не должно быть ``NULL``. "
"Если блокировка была создана, текущий поток не должен ее захватить, иначе "
"возникнет взаимоблокировка."

#: ../../c-api/init.rst:929 ../../c-api/init.rst:975 ../../c-api/init.rst:1234
#: ../../c-api/init.rst:1272
msgid ""
"Calling this function from a thread when the runtime is finalizing will "
"terminate the thread, even if the thread was not created by Python. You can "
"use :c:func:`_Py_IsFinalizing` or :func:`sys.is_finalizing` to check if the "
"interpreter is in process of being finalized before calling this function to "
"avoid unwanted termination."
msgstr ""
"Вызов этой функции из потока во время завершения среды выполнения приведет к "
"завершению потока, даже если поток не был создан Python. Вы можете "
"использовать :c:func:`_Py_IsFinalizing` или :func:`sys.is_finalizing`, чтобы "
"проверить, находится ли интерпретатор в процессе завершения, прежде чем "
"вызывать эту функцию, чтобы избежать нежелательного завершения."

#: ../../c-api/init.rst:937
msgid ""
"Return the current thread state.  The global interpreter lock must be held. "
"When the current thread state is ``NULL``, this issues a fatal error (so "
"that the caller needn't check for ``NULL``)."
msgstr ""
"Вернуть текущее состояние потока. Глобальная блокировка интерпретатора "
"должна быть удержана. Когда текущее состояние потока равно NULL, это "
"приводит к фатальной ошибке (поэтому вызывающей стороне не нужно проверять "
"наличие NULL)."

#: ../../c-api/init.rst:944
msgid ""
"Swap the current thread state with the thread state given by the argument "
"*tstate*, which may be ``NULL``.  The global interpreter lock must be held "
"and is not released."
msgstr ""
"Замените текущее состояние потока на состояние потока, заданное аргументом "
"*tstate*, которое может быть ``NULL``. Глобальная блокировка интерпретатора "
"должна удерживаться и не сниматься."

#: ../../c-api/init.rst:949
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""
"Следующие функции используют локальное хранилище потока и несовместимы с "
"подинтерпретаторами:"

#: ../../c-api/init.rst:954
msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the global interpreter lock. This may "
"be called as many times as desired by a thread as long as each call is "
"matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls as long as the thread state is restored to "
"its previous state before the Release().  For example, normal usage of the :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` macros "
"is acceptable."
msgstr ""
"Убедитесь, что текущий поток готов вызвать API Python C независимо от "
"текущего состояния Python или глобальной блокировки интерпретатора. Поток "
"может вызывать ее столько раз, сколько пожелает, при условии, что каждый "
"вызов соответствует вызову :c:func:`PyGILState_Release`. В общем, между "
"вызовами :c:func:`PyGILState_Ensure` и :c:func:`PyGILState_Release` можно "
"использовать другие API, связанные с потоками, при условии, что состояние "
"потока восстанавливается до предыдущего состояния перед Release(). Например, "
"допустимо обычное использование макросов :c:macro:`Py_BEGIN_ALLOW_THREADS` "
"и :c:macro:`Py_END_ALLOW_THREADS`."

#: ../../c-api/init.rst:964
msgid ""
"The return value is an opaque \"handle\" to the thread state when :c:func:"
"`PyGILState_Ensure` was called, and must be passed to :c:func:"
"`PyGILState_Release` to ensure Python is left in the same state. Even though "
"recursive calls are allowed, these handles *cannot* be shared - each unique "
"call to :c:func:`PyGILState_Ensure` must save the handle for its call to :c:"
"func:`PyGILState_Release`."
msgstr ""
"Возвращаемое значение представляет собой непрозрачный «дескриптор» состояния "
"потока при вызове :c:func:`PyGILState_Ensure` и должно быть передано в :c:"
"func:`PyGILState_Release`, чтобы гарантировать, что Python останется в том "
"же состоянии. Несмотря на то, что рекурсивные вызовы разрешены, эти "
"дескрипторы *не могут* быть общими — каждый уникальный вызов :c:func:"
"`PyGILState_Ensure` должен сохранять дескриптор для своего вызова :c:func:"
"`PyGILState_Release`."

#: ../../c-api/init.rst:971
msgid ""
"When the function returns, the current thread will hold the GIL and be able "
"to call arbitrary Python code.  Failure is a fatal error."
msgstr ""
"Когда функция вернется, текущий поток будет хранить GIL и сможет вызывать "
"произвольный код Python. Неудача – это фатальная ошибка."

#: ../../c-api/init.rst:983
msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the corresponding :c:func:"
"`PyGILState_Ensure` call (but generally this state will be unknown to the "
"caller, hence the use of the GILState API)."
msgstr ""
"Освободите все ранее приобретенные ресурсы. После этого вызова состояние "
"Python будет таким же, как и до соответствующего вызова :c:func:"
"`PyGILState_Ensure` (но обычно это состояние будет неизвестно вызывающей "
"стороне, поэтому используется API GILState)."

#: ../../c-api/init.rst:988
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to :c:"
"func:`PyGILState_Release` on the same thread."
msgstr ""
"Каждый вызов :c:func:`PyGILState_Ensure` должен сопровождаться вызовом :c:"
"func:`PyGILState_Release` в том же потоке."

#: ../../c-api/init.rst:994
msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main thread "
"always has such a thread-state, even if no auto-thread-state call has been "
"made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""
"Получите текущее состояние потока для этого потока. Может возвращать NULL, "
"если в текущем потоке не использовался API GILState. Обратите внимание, что "
"основной поток всегда имеет такое состояние потока, даже если в основном "
"потоке не было выполнено никакого автоматического вызова состояния потока. В "
"основном это вспомогательная/диагностическая функция."

#: ../../c-api/init.rst:1002
msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` otherwise. "
"This function can be called from any thread at any time. Only if it has had "
"its Python thread state initialized and currently is holding the GIL will it "
"return ``1``. This is mainly a helper/diagnostic function.  It can be useful "
"for example in callback contexts or memory allocation functions when knowing "
"that the GIL is locked can allow the caller to perform sensitive actions or "
"otherwise behave differently."
msgstr ""
"Возвращайте ``1``, если текущий поток содержит GIL, и ``0`` в противном "
"случае. Эту функцию можно вызвать из любого потока в любое время. Только "
"если состояние потока Python было инициализировано и в данный момент "
"удерживается GIL, он вернет «1». В основном это вспомогательная/"
"диагностическая функция. Это может быть полезно, например, в контекстах "
"обратного вызова или функциях выделения памяти, когда знание того, что GIL "
"заблокирован, может позволить вызывающей стороне выполнять конфиденциальные "
"действия или иным образом вести себя по-другому."

#: ../../c-api/init.rst:1014
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"Следующие макросы обычно используются без точки с запятой в конце; "
"посмотрите пример использования в дистрибутиве исходного кода Python."

#: ../../c-api/init.rst:1020
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"``. Note that it contains an opening brace; it must be matched with a "
"following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro."
msgstr ""
"Этот макрос расширяется до ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Обратите внимание, что он содержит открывающую "
"скобку; он должен соответствовать следующему макросу :c:macro:"
"`Py_END_ALLOW_THREADS`. См. выше дальнейшее обсуждение этого макроса."

#: ../../c-api/init.rst:1028
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of this "
"macro."
msgstr ""
"Этот макрос расширяется до ``PyEval_RestoreThread(_save); }``. Обратите "
"внимание, что он содержит закрывающую скобку; он должен соответствовать "
"более раннему макросу :c:macro:`Py_BEGIN_ALLOW_THREADS`. См. выше дальнейшее "
"обсуждение этого макроса."

#: ../../c-api/init.rst:1036
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to :"
"c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"Этот макрос расширяется до ``PyEval_RestoreThread(_save);``: он "
"эквивалентен :c:macro:`Py_END_ALLOW_THREADS` без закрывающей скобки."

#: ../../c-api/init.rst:1042
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration."
msgstr ""
"Этот макрос расширяется до ``_save = PyEval_SaveThread();``: он "
"эквивалентен :c:macro:`Py_BEGIN_ALLOW_THREADS` без открывающей скобки и "
"объявления переменной."

#: ../../c-api/init.rst:1048
msgid "Low-level API"
msgstr "Низкоуровневый API"

#: ../../c-api/init.rst:1050
msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr "Все следующие функции должны вызываться после :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:1052
msgid ":c:func:`Py_Initialize()` now initializes the :term:`GIL`."
msgstr ":c:func:`Py_Initialize()` теперь инициализирует :term:`GIL`."

#: ../../c-api/init.rst:1058
msgid ""
"Create a new interpreter state object.  The global interpreter lock need not "
"be held, but may be held if it is necessary to serialize calls to this "
"function."
msgstr ""
"Создайте новый объект состояния интерпретатора. Глобальную блокировку "
"интерпретатора удерживать не обязательно, но ее можно удерживать, если "
"необходимо сериализовать вызовы этой функции."

#: ../../c-api/init.rst:1062
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_New`` with no arguments."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``cpython.PyInterpreterState_New`` "
"без аргументов."

#: ../../c-api/init.rst:1067
msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr ""
"Сброс всей информации в объекте состояния интерпретатора. Глобальная "
"блокировка интерпретатора должна быть удержана."

#: ../../c-api/init.rst:1070
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_Clear`` with no arguments."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``cpython.PyInterpreterState_Clear`` "
"без аргументов."

#: ../../c-api/init.rst:1075
msgid ""
"Destroy an interpreter state object.  The global interpreter lock need not "
"be held.  The interpreter state must have been reset with a previous call "
"to :c:func:`PyInterpreterState_Clear`."
msgstr ""
"Уничтожить объект состояния интерпретатора. Глобальную блокировку "
"интерпретатора удерживать не требуется. Состояние интерпретатора должно быть "
"сброшено предыдущим вызовом :c:func:`PyInterpreterState_Clear`."

#: ../../c-api/init.rst:1082
msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"The global interpreter lock need not be held, but may be held if it is "
"necessary to serialize calls to this function."
msgstr ""
"Создайте новый объект состояния потока, принадлежащий данному объекту "
"интерпретатора. Глобальную блокировку интерпретатора удерживать не "
"обязательно, но ее можно удерживать, если необходимо сериализовать вызовы "
"этой функции."

#: ../../c-api/init.rst:1089
msgid ""
"Reset all information in a thread state object.  The global interpreter lock "
"must be held."
msgstr ""
"Сброс всей информации в объекте состояния потока. Глобальная блокировка "
"интерпретатора должна быть удержана."

#: ../../c-api/init.rst:1092
msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback. "
"Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""
"Эта функция теперь вызывает обратный вызов :c:member:`PyThreadState."
"on_delete`. Ранее это происходило в :c:func:`PyThreadState_Delete`."

#: ../../c-api/init.rst:1099
msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"Уничтожить объект состояния потока. Глобальную блокировку интерпретатора "
"удерживать не требуется. Состояние потока должно быть сброшено предыдущим "
"вызовом :c:func:`PyThreadState_Clear`."

#: ../../c-api/init.rst:1106
msgid ""
"Destroy the current thread state and release the global interpreter lock. "
"Like :c:func:`PyThreadState_Delete`, the global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""

#: ../../c-api/init.rst:1114
msgid "Get the current frame of the Python thread state *tstate*."
msgstr "Получите текущий кадр состояния потока Python *tstate*."

#: ../../c-api/init.rst:1116
msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is currently "
"executing."
msgstr ""
"Верните :term:`сильную ссылку`. Верните NULL, если в данный момент не "
"выполняется ни один кадр."

#: ../../c-api/init.rst:1119
msgid "See also :c:func:`PyEval_GetFrame`."
msgstr "См. также :c:func:`PyEval_GetFrame`."

#: ../../c-api/init.rst:1121 ../../c-api/init.rst:1130
#: ../../c-api/init.rst:1139
msgid "*tstate* must not be ``NULL``."
msgstr "*tstate* не должен быть ``NULL``."

#: ../../c-api/init.rst:1128
msgid ""
"Get the unique thread state identifier of the Python thread state *tstate*."
msgstr "Получите уникальный идентификатор состояния потока Python *tstate*."

#: ../../c-api/init.rst:1137
msgid "Get the interpreter of the Python thread state *tstate*."
msgstr "Получите интерпретатор состояния потока Python *tstate*."

#: ../../c-api/init.rst:1146
msgid "Get the current interpreter."
msgstr "Получите текущий интерпретатор."

#: ../../c-api/init.rst:1148
msgid ""
"Issue a fatal error if there no current Python thread state or no current "
"interpreter. It cannot return NULL."
msgstr ""
"Выдает фатальную ошибку, если нет текущего состояния потока Python или "
"текущего интерпретатора. Он не может вернуть NULL."

#: ../../c-api/init.rst:1151 ../../c-api/init.rst:1161
msgid "The caller must hold the GIL."
msgstr "Вызывающий объект должен удерживать GIL."

#: ../../c-api/init.rst:1158
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then "
"``-1`` is returned and an error is set."
msgstr ""
"Возвращает уникальный идентификатор переводчика. Если при этом произошла "
"какая-либо ошибка, то возвращается ``-1`` и устанавливается ошибка."

#: ../../c-api/init.rst:1168
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"Возвращает словарь, в котором могут храниться данные, специфичные для "
"интерпретатора. Если эта функция возвращает NULL, то исключение не возникло, "
"и вызывающая сторона должна предполагать, что словарь, специфичный для "
"интерпретатора, недоступен."

#: ../../c-api/init.rst:1172
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"Это не замена :c:func:`PyModule_GetState()`, расширения которого должны "
"использоваться для хранения информации о состоянии, специфичной для "
"интерпретатора."

#: ../../c-api/init.rst:1179
msgid "Type of a frame evaluation function."
msgstr "Тип функции оценки кадра."

#: ../../c-api/init.rst:1181
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""
"Параметр *throwflag* используется методом генераторов ``throw()``: если он "
"не равен нулю, обрабатывается текущее исключение."

#: ../../c-api/init.rst:1184
msgid "The function now takes a *tstate* parameter."
msgstr "Теперь функция принимает параметр *tstate*."

#: ../../c-api/init.rst:1189
msgid "Get the frame evaluation function."
msgstr "Получите функцию оценки кадра."

#: ../../c-api/init.rst:1191 ../../c-api/init.rst:1199
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr "См. :pep:`523` «Добавление API оценки кадров в CPython»."

#: ../../c-api/init.rst:1197
msgid "Set the frame evaluation function."
msgstr "Установите функцию оценки кадра."

#: ../../c-api/init.rst:1206
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no current thread "
"state is available. If this function returns ``NULL``, no exception has been "
"raised and the caller should assume no current thread state is available."
msgstr ""
"Возвращает словарь, в котором расширения могут хранить информацию о "
"состоянии конкретного потока. Каждое расширение должно использовать "
"уникальный ключ для хранения состояния в словаре. Эту функцию можно "
"вызывать, когда текущее состояние потока недоступно. Если эта функция "
"возвращает NULL, исключение не возникло, и вызывающая сторона должна "
"предполагать, что текущее состояние потока недоступно."

#: ../../c-api/init.rst:1215
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with the GIL held. Returns the number of thread states modified; this is "
"normally one, but will be zero if the thread id isn't found.  If *exc* is :"
"const:`NULL`, the pending exception (if any) for the thread is cleared. This "
"raises no exceptions."
msgstr ""

#: ../../c-api/init.rst:1223
msgid ""
"The type of the *id* parameter changed from :c:expr:`long` to :c:expr:"
"`unsigned long`."
msgstr ""
"Тип параметра *id* изменен с :c:expr:`long` на :c:expr:`unsigned long`."

#: ../../c-api/init.rst:1229
msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which must not be ``NULL``.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"Получите глобальную блокировку интерпретатора и установите текущее состояние "
"потока в *tstate*, которое не должно быть ``NULL``. Замок должен быть создан "
"ранее. Если этот поток уже имеет блокировку, возникает взаимоблокировка."

#: ../../c-api/init.rst:1240 ../../c-api/init.rst:1278
msgid ""
"Updated to be consistent with :c:func:`PyEval_RestoreThread`, :c:func:"
"`Py_END_ALLOW_THREADS`, and :c:func:`PyGILState_Ensure`, and terminate the "
"current thread if called while the interpreter is finalizing."
msgstr ""
"Обновлено для совместимости с :c:func:`PyEval_RestoreThread`, :c:func:"
"`Py_END_ALLOW_THREADS` и :c:func:`PyGILState_Ensure`, а также завершает "
"текущий поток, если он вызывается во время завершения работы интерпретатора."

#: ../../c-api/init.rst:1245
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` — это функция более высокого уровня, которая "
"доступна всегда (даже если потоки не инициализированы)."

#: ../../c-api/init.rst:1251
msgid ""
"Reset the current thread state to ``NULL`` and release the global "
"interpreter lock.  The lock must have been created earlier and must be held "
"by the current thread.  The *tstate* argument, which must not be ``NULL``, "
"is only used to check that it represents the current thread state --- if it "
"isn't, a fatal error is reported."
msgstr ""
"Сбросьте текущее состояние потока на NULL и снимите глобальную блокировку "
"интерпретатора. Блокировка должна быть создана ранее и удерживаться текущим "
"потоком. Аргумент *tstate*, который не должен быть NULL, используется только "
"для проверки того, что он представляет текущее состояние потока. Если это не "
"так, сообщается о фатальной ошибке."

#: ../../c-api/init.rst:1257
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` — это функция более высокого уровня, которая "
"всегда доступна (даже если потоки не инициализированы)."

#: ../../c-api/init.rst:1263
msgid ""
"Acquire the global interpreter lock.  The lock must have been created "
"earlier. If this thread already has the lock, a deadlock ensues."
msgstr ""
"Получите глобальную блокировку переводчика. Замок должен быть создан ранее. "
"Если этот поток уже имеет блокировку, возникает взаимоблокировка."

#: ../../c-api/init.rst:1266
msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_RestoreThread` or :c:func:`PyEval_AcquireThread` instead."
msgstr ""
"Эта функция не обновляет текущее состояние потока. Вместо этого используйте :"
"c:func:`PyEval_RestoreThread` или :c:func:`PyEval_AcquireThread`."

#: ../../c-api/init.rst:1286
msgid ""
"Release the global interpreter lock.  The lock must have been created "
"earlier."
msgstr ""
"Снимите глобальную блокировку интерпретатора. Замок должен быть создан ранее."

#: ../../c-api/init.rst:1288
msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_SaveThread` or :c:func:`PyEval_ReleaseThread` instead."
msgstr ""
"Эта функция не обновляет текущее состояние потока. Вместо этого используйте :"
"c:func:`PyEval_SaveThread` или :c:func:`PyEval_ReleaseThread`."

#: ../../c-api/init.rst:1297
msgid "Sub-interpreter support"
msgstr "Поддержка субпереводчика"

#: ../../c-api/init.rst:1299
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you "
"to do that."
msgstr ""
"Хотя в большинстве случаев вам понадобится встроить только один "
"интерпретатор Python, в некоторых случаях вам необходимо создать несколько "
"независимых интерпретаторов в одном процессе и, возможно, даже в одном "
"потоке. Субинтерпретаторы позволяют вам это сделать."

#: ../../c-api/init.rst:1304
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike "
"sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution "
"during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""
"«Основной» интерпретатор создается первым при инициализации среды "
"выполнения. Обычно это единственный интерпретатор Python в процессе. В "
"отличие от субинтерпретаторов, главный интерпретатор имеет уникальные "
"глобальные обязанности, такие как обработка сигналов. Он также отвечает за "
"выполнение во время инициализации среды выполнения и обычно является "
"активным интерпретатором во время финализации среды выполнения. Функция :c:"
"func:`PyInterpreterState_Main` возвращает указатель на свое состояние."

#: ../../c-api/init.rst:1311
msgid ""
"You can switch between sub-interpreters using the :c:func:"
"`PyThreadState_Swap` function. You can create and destroy them using the "
"following functions:"
msgstr ""
"Вы можете переключаться между субинтерпретаторами с помощью функции :c:func:"
"`PyThreadState_Swap`. Вы можете создавать и уничтожать их, используя "
"следующие функции:"

#: ../../c-api/init.rst:1325
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:"
"`sys`.  The table of loaded modules (``sys.modules``) and the module search "
"path (``sys.path``) are also separate.  The new environment has no ``sys."
"argv`` variable.  It has new standard I/O stream file objects ``sys.stdin``, "
"``sys.stdout`` and ``sys.stderr`` (however these refer to the same "
"underlying file descriptors)."
msgstr ""
"Создайте нового субинтерпретатора. Это (почти) полностью отдельная среда для "
"выполнения кода Python. В частности, новый интерпретатор имеет отдельные, "
"независимые версии всех импортированных модулей, включая фундаментальные "
"модули :mod:`builtins`, :mod:`__main__` и :mod:`sys`. Таблица загруженных "
"модулей («sys.modules») и путь поиска модулей («sys.path») также разделены. "
"В новой среде нет переменной sys.argv. Он имеет новые стандартные файловые "
"объекты потока ввода-вывода ``sys.stdin``, ``sys.stdout`` и ``sys.stderr`` "
"(однако они относятся к одним и тем же базовым файловым дескрипторам)."

#: ../../c-api/init.rst:1335
msgid ""
"The return value points to the first thread state created in the new sub-"
"interpreter.  This thread state is made in the current thread state. Note "
"that no actual thread is created; see the discussion of thread states "
"below.  If creation of the new interpreter is unsuccessful, ``NULL`` is "
"returned; no exception is set since the exception state is stored in the "
"current thread state and there may not be a current thread state.  (Like all "
"other Python/C API functions, the global interpreter lock must be held "
"before calling this function and is still held when it returns; however, "
"unlike most other Python/C API functions, there needn't be a current thread "
"state on entry.)"
msgstr ""

#: ../../c-api/init.rst:1350
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr ""
"Модули расширения распределяются между (суб)интерпретаторами следующим "
"образом:"

#: ../../c-api/init.rst:1352
msgid ""
"For modules using multi-phase initialization, e.g. :c:func:"
"`PyModule_FromDefAndSpec`, a separate module object is created and "
"initialized for each interpreter. Only C-level static and global variables "
"are shared between these module objects."
msgstr ""
"Для модулей, использующих многофазную инициализацию, например :c:func:"
"`PyModule_FromDefAndSpec`, для каждого интерпретатора создается и "
"инициализируется отдельный объект модуля. Эти объекты модуля совместно "
"используют только статические и глобальные переменные уровня C."

#: ../../c-api/init.rst:1358
msgid ""
"For modules using single-phase initialization, e.g. :c:func:"
"`PyModule_Create`, the first time a particular extension is imported, it is "
"initialized normally, and a (shallow) copy of its module's dictionary is "
"squirreled away. When the same extension is imported by another "
"(sub-)interpreter, a new module is initialized and filled with the contents "
"of this copy; the extension's ``init`` function is not called. Objects in "
"the module's dictionary thus end up shared across (sub-)interpreters, which "
"might cause unwanted behavior (see `Bugs and caveats`_ below)."
msgstr ""
"Для модулей, использующих однофазную инициализацию, например :c:func:"
"`PyModule_Create`, при первом импорте определенного расширения оно "
"инициализируется нормально, а (неполная) копия словаря его модуля "
"сохраняется. Когда то же расширение импортируется другим "
"(суб)интерпретатором, новый модуль инициализируется и заполняется содержимым "
"этой копии; функция ``init`` расширения не вызывается. Таким образом, "
"объекты в словаре модуля становятся общими для (суб)интерпретаторов, что "
"может вызвать нежелательное поведение (см. `Ошибки и предостережения`_ ниже)."

#: ../../c-api/init.rst:1369
msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by calling :c:func:"
"`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, the extension's "
"``initmodule`` function *is* called again. As with multi-phase "
"initialization, this means that only C-level static and global variables are "
"shared between these modules."
msgstr ""
"Обратите внимание, что это отличается от того, что происходит, когда "
"расширение импортируется после полной повторной инициализации интерпретатора "
"путем вызова :c:func:`Py_FinalizeEx` и :c:func:`Py_Initialize`; в этом "
"случае функция ``initmodule`` расширения *вызывается* снова. Как и в случае "
"с многофазной инициализацией, это означает, что между этими модулями "
"используются только статические и глобальные переменные уровня C."

#: ../../c-api/init.rst:1383
msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion of "
"thread states below.  When the call returns, the current thread state is "
"``NULL``.  All thread states associated with this interpreter are "
"destroyed.  (The global interpreter lock must be held before calling this "
"function and is still held when it returns.)  :c:func:`Py_FinalizeEx` will "
"destroy all sub-interpreters that haven't been explicitly destroyed at that "
"point."
msgstr ""

#: ../../c-api/init.rst:1393
msgid "Bugs and caveats"
msgstr "Ошибки и предостережения"

#: ../../c-api/init.rst:1395
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""
"Поскольку подинтерпретаторы (и основной интерпретатор) являются частью "
"одного и того же процесса, изоляция между ними не идеальна — например, "
"используя низкоуровневые файловые операции, такие как :func:`os.close`, они "
"могут (случайно или злонамеренно) влияют на открытые файлы друг друга. Из-за "
"способа совместного использования расширений между (суб)интерпретаторами "
"некоторые расширения могут работать неправильно; это особенно вероятно при "
"использовании однофазной инициализации или (статических) глобальных "
"переменных. Можно вставлять объекты, созданные в одном субинтерпретаторе, в "
"пространство имен другого (суб)интерпретатора; этого следует избегать, если "
"это возможно."

#: ../../c-api/init.rst:1405
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's "
"dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""
"Особое внимание следует уделить тому, чтобы избежать совместного "
"использования определяемых пользователем функций, методов, экземпляров или "
"классов между субинтерпретаторами, поскольку операции импорта, выполняемые "
"такими объектами, могут повлиять на неправильный словарь (суб)интерпретатора "
"загруженных модулей. Не менее важно избегать совместного использования "
"объектов, из которых доступно вышеперечисленное."

#: ../../c-api/init.rst:1411
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states "
"and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""
"Также обратите внимание, что объединение этой функциональности с API "
"PyGILState_*`` является деликатным, поскольку эти API предполагают биекцию "
"между состояниями потоков Python и потоками уровня ОС, что нарушается "
"наличием субинтерпретаторов. Настоятельно рекомендуется не переключать "
"подинтерпретаторы между парой совпадающих вызовов :c:func:"
"`PyGILState_Ensure` и :c:func:`PyGILState_Release`. Более того, расширения "
"(такие как :mod:`ctypes`), использующие эти API для разрешения вызова кода "
"Python из потоков, созданных не на Python, вероятно, будут нарушены при "
"использовании субинтерпретаторов."

#: ../../c-api/init.rst:1422
msgid "Asynchronous Notifications"
msgstr "Асинхронные уведомления"

#: ../../c-api/init.rst:1424
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void pointer argument."
msgstr ""
"Предусмотрен механизм отправки асинхронных уведомлений в основной поток "
"интерпретатора. Эти уведомления принимают форму указателя на функцию и "
"аргумента указателя void."

#: ../../c-api/init.rst:1433
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main "
"thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"Запланируйте вызов функции из основного потока интерпретатора. В случае "
"успеха возвращается ``0`` и *func* ставится в очередь для вызова в основном "
"потоке. В случае неудачи возвращается ``-1`` без установки каких-либо "
"исключений."

#: ../../c-api/init.rst:1437
msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"При успешной постановке в очередь *func* будет *в конечном итоге* вызвана из "
"основного потока интерпретатора с аргументом *arg*. Он будет вызываться "
"асинхронно относительно нормально работающего кода Python, но при соблюдении "
"обоих этих условий:"

#: ../../c-api/init.rst:1442
msgid "on a :term:`bytecode` boundary;"
msgstr "на :term:`bytecode` boundary;"

#: ../../c-api/init.rst:1443
msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* can "
"therefore use the full C API)."
msgstr ""
"с основным потоком, удерживающим :term:`глобальную блокировку "
"интерпретатора` (поэтому *func* может использовать полный C API)."

#: ../../c-api/init.rst:1446
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the global interpreter lock is released."
msgstr ""
"*func* должна возвращать ``0`` в случае успеха или ``-1`` в случае неудачи с "
"установленным исключением. *func* не будет прервана для рекурсивного "
"выполнения другого асинхронного уведомления, но ее все равно можно прервать "
"для переключения потоков, если глобальная блокировка интерпретатора снята."

#: ../../c-api/init.rst:1451
msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr ""
"Для запуска этой функции не требуется текущее состояние потока и не "
"требуется глобальная блокировка интерпретатора."

#: ../../c-api/init.rst:1454
msgid ""
"To call this function in a subinterpreter, the caller must hold the GIL. "
"Otherwise, the function *func* can be scheduled to be called from the wrong "
"interpreter."
msgstr ""
"Чтобы вызвать эту функцию в субинтерпретаторе, вызывающая сторона должна "
"хранить GIL. В противном случае вызов функции *func* может быть запланирован "
"не из того интерпретатора."

#: ../../c-api/init.rst:1459
msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use the :ref:"
"`PyGILState API<gilstate>`."
msgstr ""
"Это низкоуровневая функция, полезная только в особых случаях. Нет никакой "
"гарантии, что *func* будет вызвана как можно быстрее. Если основной поток "
"занят выполнением системного вызова, *func* не будет вызываться до возврата "
"системного вызова. Эта функция обычно **не** подходит для вызова кода Python "
"из произвольных потоков C. Вместо этого используйте :ref:`PyGILState "
"API<gilstate>`."

#: ../../c-api/init.rst:1466
msgid ""
"If this function is called in a subinterpreter, the function *func* is now "
"scheduled to be called from the subinterpreter, rather than being called "
"from the main interpreter. Each subinterpreter now has its own list of "
"scheduled calls."
msgstr ""
"Если эта функция вызывается в субинтерпретаторе, функция *func* теперь "
"запланирована для вызова из субинтерпретатора, а не из основного "
"интерпретатора. У каждого субпереводчика теперь есть свой список "
"запланированных вызовов."

#: ../../c-api/init.rst:1477
msgid "Profiling and Tracing"
msgstr "Профилирование и трассировка"

#: ../../c-api/init.rst:1482
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Интерпретатор Python обеспечивает некоторую низкоуровневую поддержку для "
"подключения средств профилирования и отслеживания выполнения. Они "
"используются для инструментов профилирования, отладки и анализа покрытия."

#: ../../c-api/init.rst:1486
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"Этот интерфейс C позволяет коду профилирования или трассировки избежать "
"накладных расходов на вызов через вызываемые объекты уровня Python, вместо "
"этого выполняя прямой вызов функции C. Основные характеристики объекта не "
"изменились; интерфейс позволяет устанавливать функции трассировки для "
"каждого потока, а основные события, сообщаемые функции трассировки, такие "
"же, как и функции трассировки уровня Python в предыдущих версиях."

#: ../../c-api/init.rst:1496
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the constants :const:`PyTrace_CALL`, :const:"
"`PyTrace_EXCEPTION`, :const:`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:"
"`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION`, :const:`PyTrace_C_RETURN`, "
"or :const:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:"
msgstr ""

#: ../../c-api/init.rst:1505
msgid "Value of *what*"
msgstr "Value of *what*"

#: ../../c-api/init.rst:1505
msgid "Meaning of *arg*"
msgstr "Значение *arg*"

#: ../../c-api/init.rst:1507
msgid ":const:`PyTrace_CALL`"
msgstr ""

#: ../../c-api/init.rst:1507 ../../c-api/init.rst:1512
#: ../../c-api/init.rst:1523
msgid "Always :c:data:`Py_None`."
msgstr "Всегда :c:data:`Py_None`."

#: ../../c-api/init.rst:1509
msgid ":const:`PyTrace_EXCEPTION`"
msgstr ""

#: ../../c-api/init.rst:1509
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr "Информация об исключении, возвращаемая :func:`sys.exc_info`."

#: ../../c-api/init.rst:1512
msgid ":const:`PyTrace_LINE`"
msgstr ""

#: ../../c-api/init.rst:1514
msgid ":const:`PyTrace_RETURN`"
msgstr ""

#: ../../c-api/init.rst:1514
msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr ""
"Значение, возвращаемое вызывающему объекту, или ``NULL``, если оно вызвано "
"исключением."

#: ../../c-api/init.rst:1517
msgid ":const:`PyTrace_C_CALL`"
msgstr ""

#: ../../c-api/init.rst:1517 ../../c-api/init.rst:1519
#: ../../c-api/init.rst:1521
msgid "Function object being called."
msgstr "Вызываемый функциональный объект."

#: ../../c-api/init.rst:1519
msgid ":const:`PyTrace_C_EXCEPTION`"
msgstr ""

#: ../../c-api/init.rst:1521
msgid ":const:`PyTrace_C_RETURN`"
msgstr ""

#: ../../c-api/init.rst:1523
msgid ":const:`PyTrace_OPCODE`"
msgstr ""

#: ../../c-api/init.rst:1528
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"Значение параметра *what* функции :c:type:`Py_tracefunc`, когда сообщается о "
"новом вызове функции или метода или о новой записи в генераторе. Обратите "
"внимание, что о создании итератора для функции-генератора не сообщается, "
"поскольку в соответствующем кадре нет передачи управления байт-коду Python."

#: ../../c-api/init.rst:1537
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"Значение параметра *what* функции :c:type:`Py_tracefunc` при возникновении "
"исключения. Функция обратного вызова вызывается с этим значением для *what*, "
"когда после обработки любого байт-кода возникает исключение в исполняемом "
"кадре. Результатом этого является то, что, поскольку распространение "
"исключения приводит к раскручиванию стека Python, обратный вызов вызывается "
"при возврате к каждому кадру по мере распространения исключения. Эти события "
"получают только функции трассировки; они не нужны профилировщику."

#: ../../c-api/init.rst:1548
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by setting :attr:`f_trace_lines` to "
"*0* on that frame."
msgstr ""

#: ../../c-api/init.rst:1555
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc`, когда вызов "
"собирается вернуться."

#: ../../c-api/init.rst:1561
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc`, когда должна "
"быть вызвана функция C."

#: ../../c-api/init.rst:1567
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc`, когда функция "
"C вызвала исключение."

#: ../../c-api/init.rst:1573
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc` при возврате "
"функции C."

#: ../../c-api/init.rst:1579
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by setting :"
"attr:`f_trace_opcodes` to *1* on the frame."
msgstr ""

#: ../../c-api/init.rst:1587
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events except :const:"
"`PyTrace_LINE` :const:`PyTrace_OPCODE` and :const:`PyTrace_EXCEPTION`."
msgstr ""

#: ../../c-api/init.rst:1594 ../../c-api/init.rst:1606
msgid "The caller must hold the :term:`GIL`."
msgstr "Вызывающая сторона должна удерживать :term:`GIL`."

#: ../../c-api/init.rst:1599
msgid ""
"Set the tracing function to *func*.  This is similar to :c:func:"
"`PyEval_SetProfile`, except the tracing function does receive line-number "
"events and per-opcode events, but does not receive any event related to C "
"function objects being called.  Any trace function registered using :c:func:"
"`PyEval_SetTrace` will not receive :const:`PyTrace_C_CALL`, :const:"
"`PyTrace_C_EXCEPTION` or :const:`PyTrace_C_RETURN` as a value for the *what* "
"parameter."
msgstr ""

#: ../../c-api/init.rst:1612
msgid "Advanced Debugger Support"
msgstr "Расширенная поддержка отладчика"

#: ../../c-api/init.rst:1617
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr ""
"Эти функции предназначены только для использования расширенными "
"инструментами отладки."

#: ../../c-api/init.rst:1622
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""
"Верните объект состояния интерпретатора в начало списка всех таких объектов."

#: ../../c-api/init.rst:1627
msgid "Return the main interpreter state object."
msgstr "Верните основной объект состояния интерпретатора."

#: ../../c-api/init.rst:1632
msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr ""
"Возвращает следующий объект состояния интерпретатора после *interp* из "
"списка всех таких объектов."

#: ../../c-api/init.rst:1638
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"Верните указатель на первый объект :c:type:`PyThreadState` в списке потоков, "
"связанных с интерпретатором *interp*."

#: ../../c-api/init.rst:1644
msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"Возвращает следующий объект состояния потока после *tstate* из списка всех "
"таких объектов, принадлежащих одному и тому же объекту :c:type:"
"`PyInterpreterState`."

#: ../../c-api/init.rst:1651
msgid "Thread Local Storage Support"
msgstr "Поддержка локального хранилища потоков"

#: ../../c-api/init.rst:1655
msgid ""
"The Python interpreter provides low-level support for thread-local storage "
"(TLS) which wraps the underlying native TLS implementation to support the "
"Python-level thread local storage API (:class:`threading.local`).  The "
"CPython C level APIs are similar to those offered by pthreads and Windows: "
"use a thread key and functions to associate a :c:expr:`void*` value per "
"thread."
msgstr ""
"Интерпретатор Python обеспечивает низкоуровневую поддержку локального "
"хранилища потоков (TLS), которое оборачивает базовую собственную реализацию "
"TLS для поддержки API локального хранилища потоков уровня Python (:class:"
"`threading.local`). API-интерфейсы уровня C CPython аналогичны API-"
"интерфейсам, предлагаемым pthreads и Windows: используйте ключ потока и "
"функции для связывания значения :c:expr:`void*` с каждым потоком."

#: ../../c-api/init.rst:1662
msgid ""
"The GIL does *not* need to be held when calling these functions; they supply "
"their own locking."
msgstr ""
"GIL *не* нужно удерживать при вызове этих функций; они обеспечивают "
"собственную блокировку."

#: ../../c-api/init.rst:1665
msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS APIs, "
"you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
"Обратите внимание, что :file:`Python.h` не включает декларацию TLS API, вам "
"необходимо включить :file:`pythread.h` для использования локального "
"хранилища потока."

#: ../../c-api/init.rst:1669
msgid ""
"None of these API functions handle memory management on behalf of the :c:"
"expr:`void*` values.  You need to allocate and deallocate them yourself. If "
"the :c:expr:`void*` values happen to be :c:expr:`PyObject*`, these functions "
"don't do refcount operations on them either."
msgstr ""
"Ни одна из этих функций API не обрабатывает управление памятью от имени "
"значений :c:expr:`void*`. Вам нужно выделить и освободить их самостоятельно. "
"Если значения :c:expr:`void*` оказались :c:expr:`PyObject*`, эти функции "
"также не выполняют над ними операции подсчета ссылок."

#: ../../c-api/init.rst:1677
msgid "Thread Specific Storage (TSS) API"
msgstr "API хранилища для конкретных потоков (TSS)"

#: ../../c-api/init.rst:1679
msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within "
"the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""
"TSS API заменяет использование существующего TLS API в интерпретаторе "
"CPython. Этот API использует новый тип :c:type:`Py_tss_t` вместо :c:expr:"
"`int` для представления ключей потока."

#: ../../c-api/init.rst:1685
msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr "«Новый C-API для локального хранилища потоков в CPython» (:pep:`539`)"

#: ../../c-api/init.rst:1690
msgid ""
"This data structure represents the state of a thread key, the definition of "
"which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no "
"public members in this structure."
msgstr ""
"Эта структура данных представляет состояние ключа потока, определение "
"которого может зависеть от базовой реализации TLS, и имеет внутреннее поле, "
"представляющее состояние инициализации ключа. В этой структуре нет публичных "
"членов."

#: ../../c-api/init.rst:1695
msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
"Если :ref:`Py_LIMITED_API <stable>` не определен, статическое выделение "
"этого типа с помощью :c:macro:`Py_tss_NEEDS_INIT` разрешено."

#: ../../c-api/init.rst:1701
msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. Note "
"that this macro won't be defined with :ref:`Py_LIMITED_API <stable>`."
msgstr ""
"Этот макрос расширяется до инициализатора переменных :c:type:`Py_tss_t`. "
"Обратите внимание, что этот макрос не будет определен с помощью :ref:"
"`Py_LIMITED_API <stable>`."

#: ../../c-api/init.rst:1706
msgid "Dynamic Allocation"
msgstr "Динамическое распределение"

#: ../../c-api/init.rst:1708
msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension modules "
"built with :ref:`Py_LIMITED_API <stable>`, where static allocation of this "
"type is not possible due to its implementation being opaque at build time."
msgstr ""
"Динамическое выделение :c:type:`Py_tss_t`, необходимое в модулях расширения, "
"созданных с помощью :ref:`Py_LIMITED_API <stable>`, где статическое "
"выделение этого типа невозможно из-за того, что его реализация непрозрачна "
"во время сборки."

#: ../../c-api/init.rst:1715
msgid ""
"Return a value which is the same state as a value initialized with :c:macro:"
"`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic allocation failure."
msgstr ""
"Возвращает значение, которое находится в том же состоянии, что и значение, "
"инициализированное с помощью :c:macro:`Py_tss_NEEDS_INIT` или ``NULL`` в "
"случае сбоя динамического выделения."

#: ../../c-api/init.rst:1722
msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after first "
"calling :c:func:`PyThread_tss_delete` to ensure any associated thread locals "
"have been unassigned. This is a no-op if the *key* argument is ``NULL``."
msgstr ""
"Освободите данный *ключ*, выделенный :c:func:`PyThread_tss_alloc`, после "
"первого вызова :c:func:`PyThread_tss_delete`, чтобы убедиться, что все "
"связанные локальные переменные потока не назначены. Это пустая операция, "
"если аргумент *key* равен ``NULL``."

#: ../../c-api/init.rst:1728
msgid ""
"A freed key becomes a dangling pointer. You should reset the key to `NULL`."
msgstr ""

#: ../../c-api/init.rst:1733
msgid "Methods"
msgstr "Методы"

#: ../../c-api/init.rst:1735
msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, the "
"behaviors of :c:func:`PyThread_tss_set` and :c:func:`PyThread_tss_get` are "
"undefined if the given :c:type:`Py_tss_t` has not been initialized by :c:"
"func:`PyThread_tss_create`."
msgstr ""
"Параметр *key* этих функций не должен иметь значение NULL. Более того, "
"поведение :c:func:`PyThread_tss_set` и :c:func:`PyThread_tss_get` не "
"определено, если данный :c:type:`Py_tss_t` не был инициализирован :c:func:"
"`PyThread_tss_create`."

#: ../../c-api/init.rst:1743
msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been initialized "
"by :c:func:`PyThread_tss_create`."
msgstr ""
"Возвращает ненулевое значение, если данный :c:type:`Py_tss_t` был "
"инициализирован :c:func:`PyThread_tss_create`."

#: ../../c-api/init.rst:1749
msgid ""
"Return a zero value on successful initialization of a TSS key.  The behavior "
"is undefined if the value pointed to by the *key* argument is not "
"initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be called "
"repeatedly on the same key -- calling it on an already initialized key is a "
"no-op and immediately returns success."
msgstr ""
"Возвращает нулевое значение при успешной инициализации ключа TSS. Поведение "
"не определено, если значение, на которое указывает аргумент *key*, не "
"инициализировано :c:macro:`Py_tss_NEEDS_INIT`. Эту функцию можно вызывать "
"повторно для одного и того же ключа — вызов ее для уже инициализированного "
"ключа является пустым и немедленно возвращает успех."

#: ../../c-api/init.rst:1758
msgid ""
"Destroy a TSS key to forget the values associated with the key across all "
"threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again by :c:func:"
"`PyThread_tss_create`. This function can be called repeatedly on the same "
"key -- calling it on an already destroyed key is a no-op."
msgstr ""
"Уничтожьте ключ TSS, чтобы забыть значения, связанные с ним во всех потоках, "
"и измените состояние инициализации ключа на неинициализированное. "
"Уничтоженный ключ можно снова инициализировать с помощью :c:func:"
"`PyThread_tss_create`. Эту функцию можно вызывать повторно для одного и того "
"же ключа — вызов ее для уже уничтоженного ключа является пустым процессом."

#: ../../c-api/init.rst:1767
msgid ""
"Return a zero value to indicate successfully associating a :c:expr:`void*` "
"value with a TSS key in the current thread.  Each thread has a distinct "
"mapping of the key to a :c:expr:`void*` value."
msgstr ""
"Возвращает нулевое значение, чтобы указать успешное связывание значения :c:"
"expr:`void*` с ключом TSS в текущем потоке. Каждый поток имеет отдельное "
"сопоставление ключа со значением :c:expr:`void*`."

#: ../../c-api/init.rst:1774
msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current "
"thread.  This returns ``NULL`` if no value is associated with the key in the "
"current thread."
msgstr ""
"Возвращает значение :c:expr:`void*`, связанное с ключом TSS в текущем "
"потоке. Это возвращает NULL, если с ключом в текущем потоке не связано "
"никакое значение."

#: ../../c-api/init.rst:1782
msgid "Thread Local Storage (TLS) API"
msgstr "API локального хранилища потоков (TLS)"

#: ../../c-api/init.rst:1784
msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API <thread-"
"specific-storage-api>`."
msgstr ""
"Этот API заменяется API-интерфейсом :ref:`Thread-Specific Storage (TSS) "
"<thread-dependent-storage-api>`."

#: ../../c-api/init.rst:1789
msgid ""
"This version of the API does not support platforms where the native TLS key "
"is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""
"Эта версия API не поддерживает платформы, где собственный ключ TLS определен "
"таким образом, что его невозможно безопасно привести к int. На таких "
"платформах :c:func:`PyThread_create_key` немедленно вернется со статусом "
"сбоя, а все остальные функции TLS на таких платформах будут недоступны."

#: ../../c-api/init.rst:1794
msgid ""
"Due to the compatibility problem noted above, this version of the API should "
"not be used in new code."
msgstr ""
"Из-за отмеченной выше проблемы совместимости эту версию API не следует "
"использовать в новом коде."
