# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-11 14:18+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr "Инициализация, финализация и потоки"

#: ../../c-api/init.rst:10
msgid ""
"See :ref:`Python Initialization Configuration <init-config>` for details on "
"how to configure the interpreter prior to initialization."
msgstr ""
"См. :ref:`Конфигурация инициализации Python <init-config>` для получения "
"подробной информации о том, как настроить интерпретатор перед инициализацией."

#: ../../c-api/init.rst:16
msgid "Before Python Initialization"
msgstr "Перед инициализацией Python"

#: ../../c-api/init.rst:18
msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function "
"must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables "
"<global-conf-vars>`."
msgstr ""
"В приложении, встраивающем Python, функцию :c:func:`Py_Initialize` "
"необходимо вызывать перед использованием любых других функций API Python/C; "
"за исключением нескольких функций и :ref:`глобальных переменных конфигурации "
"<global-conf-vars>`."

#: ../../c-api/init.rst:23
msgid ""
"The following functions can be safely called before Python is initialized:"
msgstr "Следующие функции можно безопасно вызвать до инициализации Python:"

#: ../../c-api/init.rst:25
msgid "Functions that initialize the interpreter:"
msgstr "Функции, инициализирующие интерпретатор:"

#: ../../c-api/init.rst:27
msgid ":c:func:`Py_Initialize`"
msgstr ":c:func:`Py_Initialize`"

#: ../../c-api/init.rst:28
msgid ":c:func:`Py_InitializeEx`"
msgstr ":c:func:`Py_InitializeEx`"

#: ../../c-api/init.rst:29
msgid ":c:func:`Py_InitializeFromConfig`"
msgstr ":c:func:`Py_InitializeFromConfig`"

#: ../../c-api/init.rst:30
msgid ":c:func:`Py_BytesMain`"
msgstr ":c:func:`Py_BytesMain`"

#: ../../c-api/init.rst:31
msgid ":c:func:`Py_Main`"
msgstr ":c:func:`Py_Main`"

#: ../../c-api/init.rst:32
msgid "the runtime pre-initialization functions covered in :ref:`init-config`"
msgstr ""
"функции предварительной инициализации во время выполнения, описанные "
"в :ref:`init-config`"

#: ../../c-api/init.rst:34
msgid "Configuration functions:"
msgstr "Функции настройки:"

#: ../../c-api/init.rst:36
msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

#: ../../c-api/init.rst:37
msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

#: ../../c-api/init.rst:38
msgid ":c:func:`!PyInitFrozenExtensions`"
msgstr ":c:func:`!PyInitFrozenExtensions`"

#: ../../c-api/init.rst:39
msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

#: ../../c-api/init.rst:40
msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

#: ../../c-api/init.rst:41
msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

#: ../../c-api/init.rst:42
msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

#: ../../c-api/init.rst:43
msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

#: ../../c-api/init.rst:44
msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

#: ../../c-api/init.rst:45
msgid "the configuration functions covered in :ref:`init-config`"
msgstr "функции конфигурации, описанные в :ref:`init-config`"

#: ../../c-api/init.rst:47
msgid "Informative functions:"
msgstr "Информационные функции:"

#: ../../c-api/init.rst:49 ../../c-api/init.rst:57
msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

#: ../../c-api/init.rst:50
msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

#: ../../c-api/init.rst:51
msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

#: ../../c-api/init.rst:52
msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

#: ../../c-api/init.rst:53
msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

#: ../../c-api/init.rst:54
msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

#: ../../c-api/init.rst:55
msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

#: ../../c-api/init.rst:56
msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

#: ../../c-api/init.rst:59
msgid "Utilities:"
msgstr "Утилиты:"

#: ../../c-api/init.rst:61
msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

#: ../../c-api/init.rst:62
msgid ""
"the status reporting and utility functions covered in :ref:`init-config`"
msgstr "отчеты о состоянии и служебные функции, описанные в :ref:`init-config`"

#: ../../c-api/init.rst:64
msgid "Memory allocators:"
msgstr "Распределители памяти:"

#: ../../c-api/init.rst:66
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/init.rst:67
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/init.rst:68
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/init.rst:69
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/init.rst:71
msgid "Synchronization:"
msgstr "Синхронизация:"

#: ../../c-api/init.rst:73
msgid ":c:func:`PyMutex_Lock`"
msgstr ":c:func:`PyMutex_Lock`"

#: ../../c-api/init.rst:74
msgid ":c:func:`PyMutex_Unlock`"
msgstr ":c:func:`PyMutex_Unlock`"

#: ../../c-api/init.rst:78
msgid ""
"Despite their apparent similarity to some of the functions listed above, the "
"following functions **should not be called** before the interpreter has been "
"initialized: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:`Py_GetProgramName`, :c:func:`PyEval_InitThreads`, "
"and :c:func:`Py_RunMain`."
msgstr ""
"Несмотря на их очевидное сходство с некоторыми функциями, перечисленными "
"выше, следующие функции **не следует вызывать** до инициализации "
"интерпретатора: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c :func:`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:`Py_GetProgramName`, :c:func:`PyEval_InitThreads "
"` и :c:func:`Py_RunMain`."

#: ../../c-api/init.rst:90
msgid "Global configuration variables"
msgstr "Глобальные переменные конфигурации"

#: ../../c-api/init.rst:92
msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled "
"by :ref:`command line options <using-on-interface-options>`."
msgstr ""
"В Python есть переменные для глобальной конфигурации, позволяющие управлять "
"различными функциями и параметрами. По умолчанию эти флаги "
"контролируются :ref:`параметрами командной строки <using-on-interface-"
"options>`."

#: ../../c-api/init.rst:96
msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` "
"sets :c:data:`Py_BytesWarningFlag` to 1 and ``-bb`` "
"sets :c:data:`Py_BytesWarningFlag` to 2."
msgstr ""
"Если флаг установлен опцией, значение флага равно количеству раз, когда "
"опция была установлена. Например, ``-b`` "
"устанавливает :c:data:`Py_BytesWarningFlag` равным 1, а ``-bb`` "
"устанавливает :c:data:`Py_BytesWarningFlag` равным 2."

#: ../../c-api/init.rst:102
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.bytes_warning` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.bytes_warning`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:106
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` "
"with :class:`str` or :class:`bytes` with :class:`int`.  Issue an error if "
"greater or equal to ``2``."
msgstr ""
"Выдает предупреждение при сравнении :class:`bytes` или :class:`bytearray` "
"с :class:`str` или :class:`bytes` с :class:`int`. Выдать ошибку, если оно "
"больше или равно ``2``."

#: ../../c-api/init.rst:110
msgid "Set by the :option:`-b` option."
msgstr "Устанавливается опцией :option:`-b`."

#: ../../c-api/init.rst:116
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.parser_debug` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.parser_debug`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:120
msgid ""
"Turn on parser debugging output (for expert only, depending on compilation "
"options)."
msgstr ""
"Включите вывод отладки парсера (только для экспертов, в зависимости от "
"параметров компиляции)."

#: ../../c-api/init.rst:123
msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-d` и переменной среды :envvar:`PYTHONDEBUG`."

#: ../../c-api/init.rst:130
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.write_bytecode` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.write_bytecode`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:134
msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the import "
"of source modules."
msgstr ""
"Если установлено значение, отличное от нуля, Python не будет пытаться "
"записывать файлы ``.pyc`` при импорте исходных модулей."

#: ../../c-api/init.rst:137
msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ""
"Устанавливается опцией :option:`-B` и переменной "
"среды :envvar:`PYTHONDONTWRITEBYTECODE`."

#: ../../c-api/init.rst:144
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.pathconfig_warnings` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.pathconfig_warnings`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:148
msgid ""
"Suppress error messages when calculating the module search path "
"in :c:func:`Py_GetPath`."
msgstr ""
"Подавить сообщения об ошибках при вычислении пути поиска модуля "
"в :c:func:`Py_GetPath`."

#: ../../c-api/init.rst:151
msgid "Private flag used by ``_freeze_module`` and ``frozenmain`` programs."
msgstr ""
"Частный флаг, используемый программами ``_freeze_module`` и ``frozenmain``."

#: ../../c-api/init.rst:157
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.hash_seed` "
"and :c:member:`PyConfig.use_hash_seed` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо этого следует "
"использовать настройки :c:member:`PyConfig.hash_seed` "
"и :c:member:`PyConfig.use_hash_seed`, см. :ref:`Конфигурация инициализации "
"Python <init-config>`."

#: ../../c-api/init.rst:162
msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set to "
"a non-empty string."
msgstr ""
"Установите значение ``1``, если для переменной "
"среды :envvar:`PYTHONHASHSEED` задана непустая строка."

#: ../../c-api/init.rst:165
msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr ""
"Если флаг ненулевой, прочитайте переменную среды :envvar:`PYTHONHASHSEED`, "
"чтобы инициализировать секретное начальное значение хеша."

#: ../../c-api/init.rst:172
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.use_environment` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.use_environment`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:176
msgid ""
"Ignore all :envvar:`!PYTHON*` environment variables, "
"e.g. :envvar:`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""
"Игнорируйте все переменные среды :envvar:`!PYTHON*`, "
"например :envvar:`PYTHONPATH` и :envvar:`PYTHONHOME`, которые могут быть "
"установлены."

#: ../../c-api/init.rst:179
msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr "Устанавливается опциями :option:`-E` и :option:`-I`."

#: ../../c-api/init.rst:185
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.inspect` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.inspect`, см. :ref:`Конфигурация "
"инициализации Python <init-config>`."

#: ../../c-api/init.rst:189
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, even "
"when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"Если сценарий передается в качестве первого аргумента или используется "
"опция :option:`-c`, войдите в интерактивный режим после выполнения сценария "
"или команды, даже если :data:`sys.stdin` не выглядит как терминал."

#: ../../c-api/init.rst:193
msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-i` и переменной "
"среды :envvar:`PYTHONINSPECT`."

#: ../../c-api/init.rst:200
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.interactive` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.interactive`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:204
msgid "Set by the :option:`-i` option."
msgstr "Устанавливается опцией :option:`-i`."

#: ../../c-api/init.rst:210
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.isolated` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.isolated`, см. :ref:`Конфигурация "
"инициализации Python <init-config>`."

#: ../../c-api/init.rst:214
msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"Запустите Python в изолированном режиме. В изолированном "
"режиме :data:`sys.path` не содержит ни каталога сценария, ни каталога "
"пакетов сайта пользователя."

#: ../../c-api/init.rst:217
msgid "Set by the :option:`-I` option."
msgstr "Устанавливается опцией :option:`-I`."

#: ../../c-api/init.rst:225
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyPreConfig.legacy_windows_fs_encoding` should be used "
"instead, see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyPreConfig.legacy_windows_fs_encoding`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:229
msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error "
"handler, instead of the UTF-8 encoding with ``surrogatepass`` error handler, "
"for the :term:`filesystem encoding and error handler`."
msgstr ""
"Если флаг ненулевой, используйте кодировку mbcs с обработчиком ошибок "
"replace вместо кодировки UTF-8 с обработчиком ошибок surrogatepass для "
"кодировки файловой системы и обработчик ошибок`."

#: ../../c-api/init.rst:233
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
"Установите значение ``1``, если для переменной "
"среды :envvar:`PYTHONLEGACYWINDOWSFSENCODING` задана непустая строка."

#: ../../c-api/init.rst:236
msgid "See :pep:`529` for more details."
msgstr "См. :pep:`529` для более подробной информации."

#: ../../c-api/init.rst:238 ../../c-api/init.rst:256
msgid "Availability"
msgstr "Доступность"

#: ../../c-api/init.rst:244
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.legacy_windows_stdio` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.legacy_windows_stdio`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:248
msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of :class:`!"
"io._WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""
"Если флаг ненулевой, используйте :class:`io.FileIO` вместо :class:`!"
"io._WindowsConsoleIO` для стандартных потоков :mod:`sys`."

#: ../../c-api/init.rst:251
msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment variable "
"is set to a non-empty string."
msgstr ""
"Установите значение ``1``, если для переменной "
"среды :envvar:`PYTHONLEGACYWINDOWSSTDIO` задана непустая строка."

#: ../../c-api/init.rst:254
msgid "See :pep:`528` for more details."
msgstr "См. :pep:`528` для более подробной информации."

#: ../../c-api/init.rst:262
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.site_import` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.site_import`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:266
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later "
"(call :func:`site.main` if you want them to be triggered)."
msgstr ""
"Отключите импорт модуля :mod:`site` и связанные с ним манипуляции "
"с :data:`sys.path`, зависящие от сайта. Также отключите эти манипуляции, "
"если :mod:`site` будет явно импортирован позже (вызовите :func:`site.main`, "
"если вы хотите, чтобы они запускались)."

#: ../../c-api/init.rst:271
msgid "Set by the :option:`-S` option."
msgstr "Устанавливается опцией :option:`-S`."

#: ../../c-api/init.rst:277
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.user_site_directory` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.user_site_directory`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:281
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` "
"to :data:`sys.path`."
msgstr ""
"Не добавляйте каталог :data:`user site-packages <site.USER_SITE>` "
"в :data:`sys.path`."

#: ../../c-api/init.rst:284
msgid ""
"Set by the :option:`-s` and :option:`-I` options, and "
"the :envvar:`PYTHONNOUSERSITE` environment variable."
msgstr ""
"Устанавливается параметрами :option:`-s` и :option:`-I`, а также переменной "
"среды :envvar:`PYTHONNOUSERSITE`."

#: ../../c-api/init.rst:291
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.optimization_level` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.optimization_level`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:295
msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-O` и переменной "
"среды :envvar:`PYTHONOPTIMIZE`."

#: ../../c-api/init.rst:302
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.quiet` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.quiet`, см. :ref:`Конфигурация "
"инициализации Python <init-config>`."

#: ../../c-api/init.rst:306
msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr ""
"Не отображайте сообщения об авторских правах и версии даже в интерактивном "
"режиме."

#: ../../c-api/init.rst:308
msgid "Set by the :option:`-q` option."
msgstr "Устанавливается опцией :option:`-q`."

#: ../../c-api/init.rst:316
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.buffered_stdio` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.buffered_stdio`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:320
msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "Принудительно отключить буферизацию потоков stdout и stderr."

#: ../../c-api/init.rst:322
msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ""
"Устанавливается опцией :option:`-u` и переменной "
"среды :envvar:`PYTHONUNBUFFERED`."

#: ../../c-api/init.rst:329
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.verbose` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.verbose`, см. :ref:`Конфигурация "
"инициализации Python <init-config>`."

#: ../../c-api/init.rst:333
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or equal "
"to ``2``, print a message for each file that is checked for when searching "
"for a module. Also provides information on module cleanup at exit."
msgstr ""
"Выводите сообщение каждый раз при инициализации модуля, показывая место (имя "
"файла или встроенный модуль), из которого он загружен. Если больше или равно "
"``2``, выведите сообщение для каждого файла, который проверяется при поиске "
"модуля. Также предоставляет информацию об очистке модуля при выходе."

#: ../../c-api/init.rst:338
msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` environment "
"variable."
msgstr ""
"Устанавливается опцией :option:`-v` и переменной "
"среды :envvar:`PYTHONVERBOSE`."

#: ../../c-api/init.rst:345
msgid "Initializing and finalizing the interpreter"
msgstr "Инициализация и финализация интерпретатора"

#: ../../c-api/init.rst:360
msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; "
"see :ref:`Before Python Initialization <pre-init-safe>` for the few "
"exceptions."
msgstr ""
"Инициализируйте интерпретатор Python. В приложении, встраивающем Python, его "
"следует вызывать перед использованием любых других функций API Python/C; "
"см. :ref:`Before Python Initialization <pre-init-safe>` для нескольких "
"исключений."

#: ../../c-api/init.rst:364
msgid ""
"This initializes the table of loaded modules (``sys.modules``), and creates "
"the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`. It "
"also initializes the module search path (``sys.path``). It does not set "
"``sys.argv``; use the :ref:`Python Initialization Configuration <init-"
"config>` API for that. This is a no-op when called for a second time "
"(without calling :c:func:`Py_FinalizeEx` first).  There is no return value; "
"it is a fatal error if the initialization fails."
msgstr ""
"Это инициализирует таблицу загруженных модулей (``sys.modules``) и создает "
"основные модули :mod:`builtins`, :mod:`__main__` и :mod:`sys`. Он также "
"инициализирует путь поиска модуля (``sys.path``). Он не устанавливает "
"``sys.argv``; для этого используйте API конфигурации инициализации Python "
"<init-config>`. Это пустая операция при втором вызове (без первого "
"вызова :c:func:`Py_FinalizeEx`). Возвращаемого значения нет; это фатальная "
"ошибка, если инициализация не удалась."

#: ../../c-api/init.rst:372 ../../c-api/init.rst:386
msgid ""
"Use :c:func:`Py_InitializeFromConfig` to customize the :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""
"Используйте :c:func:`Py_InitializeFromConfig` для "
"настройки :ref:`Конфигурации инициализации Python <init-config>`."

#: ../../c-api/init.rst:376
msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"В Windows изменяет режим консоли с ``O_TEXT`` на ``O_BINARY``, что также "
"повлияет на использование консоли не на Python с использованием среды "
"выполнения C."

#: ../../c-api/init.rst:382
msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which may be useful when CPython is embedded as part of a larger "
"application."
msgstr ""
"Эта функция работает как :c:func:`Py_Initialize`, если *initsigs* равен "
"``1``. Если *initsigs* равен ``0``, он пропускает регистрацию инициализации "
"обработчиков сигналов, что может быть полезно, когда CPython встроен как "
"часть более крупного приложения."

#: ../../c-api/init.rst:392
msgid ""
"Initialize Python from *config* configuration, as described in :ref:`init-"
"from-config`."
msgstr ""
"Инициализируйте Python из конфигурации *config*, как описано в :ref:`init-"
"from-config`."

#: ../../c-api/init.rst:395
msgid ""
"See the :ref:`init-config` section for details on pre-initializing the "
"interpreter, populating the runtime configuration structure, and querying "
"the returned status structure."
msgstr ""
"См. раздел :ref:`init-config` для получения подробной информации о "
"предварительной инициализации интерпретатора, заполнении структуры "
"конфигурации времени выполнения и запросе возвращаемой структуры состояния."

#: ../../c-api/init.rst:402
msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Возвращайте true (не ноль), если интерпретатор Python был инициализирован, и "
"false (ноль), если нет. После вызова :c:func:`Py_FinalizeEx` он возвращает "
"false до тех пор, пока :c:func:`Py_Initialize` не будет вызван снова."

#: ../../c-api/init.rst:409
msgid ""
"Return true (non-zero) if the main Python interpreter is :term:`shutting "
"down <interpreter shutdown>`. Return false (zero) otherwise."
msgstr ""
"Возвращает true (не ноль), если основной интерпретатор "
"Python :term:`завершает работу <интерпретатор завершение работы>`. В "
"противном случае верните false (ноль)."

#: ../../c-api/init.rst:417
msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters "
"(see :c:func:`Py_NewInterpreter` below) that were created and not yet "
"destroyed since the last call to :c:func:`Py_Initialize`.  This is a no-op "
"when called for a second time (without calling :c:func:`Py_Initialize` again "
"first)."
msgstr ""

#: ../../c-api/init.rst:423
msgid ""
"Since this is the reverse of :c:func:`Py_Initialize`, it should be called in "
"the same thread with the same interpreter active.  That means the main "
"thread and the main interpreter. This should never be called "
"while :c:func:`Py_RunMain` is running."
msgstr ""
"Поскольку это противоположно :c:func:`Py_Initialize`, его следует вызывать в "
"том же потоке с тем же активным интерпретатором. Это означает основной поток "
"и главный интерпретатор. Это никогда не следует вызывать во время "
"работы :c:func:`Py_RunMain`."

#: ../../c-api/init.rst:428
msgid ""
"Normally the return value is ``0``. If there were errors during finalization "
"(flushing buffered data), ``-1`` is returned."
msgstr ""
"Обычно возвращаемое значение равно ``0``. Если во время финализации (очистки "
"буферизованных данных) возникли ошибки, возвращается ``-1``."

#: ../../c-api/init.rst:432
msgid ""
"Note that Python will do a best effort at freeing all memory allocated by "
"the Python interpreter.  Therefore, any C-Extension should make sure to "
"correctly clean up all of the preveiously allocated PyObjects before using "
"them in subsequent calls to :c:func:`Py_Initialize`.  Otherwise it could "
"introduce vulnerabilities and incorrect behavior."
msgstr ""

#: ../../c-api/init.rst:438
msgid ""
"This function is provided for a number of reasons.  An embedding application "
"might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks "
"in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"Эта функция предусмотрена по ряду причин. Встраиваемому приложению может "
"потребоваться перезапустить Python без перезапуска самого приложения. "
"Приложение, загрузившее интерпретатор Python из динамически загружаемой "
"библиотеки (или DLL), может захотеть освободить всю память, выделенную "
"Python, перед выгрузкой DLL. Во время поиска утечек памяти в приложении "
"разработчик может захотеть освободить всю память, выделенную Python, перед "
"выходом из приложения."

#: ../../c-api/init.rst:446
msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`~object.__del__` "
"methods) to fail when they depend on other objects (even functions) or "
"modules.  Dynamically loaded extension modules loaded by Python are not "
"unloaded.  Small amounts of memory allocated by the Python interpreter may "
"not be freed (if you find a leak, please report it).  Memory tied up in "
"circular references between objects is not freed.  Interned strings will all "
"be deallocated regardless of their reference count. Some memory allocated by "
"extension modules may not be freed.  Some extensions may not work properly "
"if their initialization routine is called more than once; this can happen if "
"an application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` "
"more than once.  :c:func:`Py_FinalizeEx` must not be called recursively from "
"within itself.  Therefore, it must not be called by any code that may be run "
"as part of the interpreter shutdown process, such as :py:mod:`atexit` "
"handlers, object finalizers, or any code that may be run while flushing the "
"stdout and stderr files."
msgstr ""

#: ../../c-api/init.rst:462
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython._PySys_ClearAuditHooks`` with no arguments."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``cpython._PySys_ClearAuditHooks`` "
"без аргументов."

#: ../../c-api/init.rst:469
msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr ""
"Это обратно совместимая версия :c:func:`Py_FinalizeEx`, которая игнорирует "
"возвращаемое значение."

#: ../../c-api/init.rst:475
msgid ""
"Similar to :c:func:`Py_Main` but *argv* is an array of bytes strings, "
"allowing the calling application to delegate the text decoding step to the "
"CPython runtime."
msgstr ""
"Аналогично :c:func:`Py_Main`, но *argv* представляет собой массив строк "
"байтов, позволяющий вызывающему приложению делегировать этап декодирования "
"текста среде выполнения CPython."

#: ../../c-api/init.rst:484
msgid ""
"The main program for the standard interpreter, encapsulating a full "
"initialization/finalization cycle, as well as additional behaviour to "
"implement reading configurations settings from the environment and command "
"line, and then executing ``__main__`` in accordance with :ref:`using-on-"
"cmdline`."
msgstr ""
"Основная программа для стандартного интерпретатора, инкапсулирующая полный "
"цикл инициализации/финализации, а также дополнительное поведение для "
"реализации чтения настроек конфигурации из окружения и командной строки, а "
"затем выполнения ``__main__`` в соответствии с :ref:`using- on-cmdline`."

#: ../../c-api/init.rst:490
msgid ""
"This is made available for programs which wish to support the full CPython "
"command line interface, rather than just embedding a Python runtime in a "
"larger application."
msgstr ""
"Это доступно для программ, которые хотят поддерживать полный интерфейс "
"командной строки CPython, а не просто встраивать среду выполнения Python в "
"более крупное приложение."

#: ../../c-api/init.rst:494
msgid ""
"The *argc* and *argv* parameters are similar to those which are passed to a "
"C program's :c:func:`main` function, except that the *argv* entries are "
"first converted to ``wchar_t`` using :c:func:`Py_DecodeLocale`. It is also "
"important to note that the argument list entries may be modified to point to "
"strings other than those passed in (however, the contents of the strings "
"pointed to by the argument list are not modified)."
msgstr ""
"Параметры *argc* и *argv* аналогичны тем, которые передаются в "
"функцию :c:func:`main` программы C, за исключением того, что записи *argv* "
"сначала преобразуются в ``wchar_t`` с помощью :c: func:`Py_DecodeLocale`. "
"Также важно отметить, что записи списка аргументов могут быть изменены, "
"чтобы указывать на строки, отличные от переданных (однако содержимое строк, "
"на которые указывает список аргументов, не изменяется)."

#: ../../c-api/init.rst:501
msgid ""
"The return value is ``2`` if the argument list does not represent a valid "
"Python command line, and otherwise the same as :c:func:`Py_RunMain`."
msgstr ""

#: ../../c-api/init.rst:504
msgid ""
"In terms of the CPython runtime configuration APIs documented in "
"the :ref:`runtime configuration <init-config>` section (and without "
"accounting for error handling), ``Py_Main`` is approximately equivalent to::"
msgstr ""
"С точки зрения API-интерфейсов конфигурации среды выполнения CPython, "
"описанных в разделе конфигурации среды выполнения <init-config> (и без учета "
"обработки ошибок), Py_Main примерно эквивалентен:"

#: ../../c-api/init.rst:508
msgid ""
"PyConfig config;\n"
"PyConfig_InitPythonConfig(&config);\n"
"PyConfig_SetArgv(&config, argc, argv);\n"
"Py_InitializeFromConfig(&config);\n"
"PyConfig_Clear(&config);\n"
"\n"
"Py_RunMain();"
msgstr ""
"PyConfig config;\n"
"PyConfig_InitPythonConfig(&config);\n"
"PyConfig_SetArgv(&config, argc, argv);\n"
"Py_InitializeFromConfig(&config);\n"
"PyConfig_Clear(&config);\n"
"\n"
"Py_RunMain();"

#: ../../c-api/init.rst:516
msgid ""
"In normal usage, an embedding application will call this function *instead* "
"of calling :c:func:`Py_Initialize`, :c:func:`Py_InitializeEx` "
"or :c:func:`Py_InitializeFromConfig` directly, and all settings will be "
"applied as described elsewhere in this documentation. If this function is "
"instead called *after* a preceding runtime initialization API call, then "
"exactly which environmental and command line configuration settings will be "
"updated is version dependent (as it depends on which settings correctly "
"support being modified after they have already been set once when the "
"runtime was first initialized)."
msgstr ""
"При обычном использовании приложение для внедрения будет вызывать эту "
"функцию *вместо* прямого "
"вызова :c:func:`Py_Initialize`, :c:func:`Py_InitializeEx` "
"или :c:func:`Py_InitializeFromConfig`, и все настройки будут применены. как "
"описано в других разделах этой документации. Если вместо этого эта функция "
"вызывается *после* предыдущего вызова API инициализации среды выполнения, то "
"какие именно параметры конфигурации среды и командной строки будут "
"обновлены, зависит от версии (так как это зависит от того, какие параметры "
"правильно поддерживают изменение после того, как они уже были установлены "
"один раз, когда среда выполнения была впервые инициализирована)."

#: ../../c-api/init.rst:529
msgid "Executes the main module in a fully configured CPython runtime."
msgstr ""
"Выполняет основной модуль в полностью настроенной среде выполнения CPython."

#: ../../c-api/init.rst:531
msgid ""
"Executes the command (:c:member:`PyConfig.run_command`), the script "
"(:c:member:`PyConfig.run_filename`) or the module "
"(:c:member:`PyConfig.run_module`) specified on the command line or in the "
"configuration. If none of these values are set, runs the interactive Python "
"prompt (REPL) using the ``__main__`` module's global namespace."
msgstr ""
"Выполняет команду (:c:member:`PyConfig.run_command`), сценарий "
"(:c:member:`PyConfig.run_filename`) или модуль "
"(:c:member:`PyConfig.run_module`), указанный в командной строке. или в "
"конфигурации. Если ни одно из этих значений не установлено, запускается "
"интерактивная подсказка Python (REPL), используя глобальное пространство "
"имен модуля ``__main__``."

#: ../../c-api/init.rst:537
msgid ""
"If :c:member:`PyConfig.inspect` is not set (the default), the return value "
"will be ``0`` if the interpreter exits normally (that is, without raising an "
"exception), the exit status of an unhandled :exc:`SystemExit`, or ``1`` for "
"any other unhandled exception."
msgstr ""

#: ../../c-api/init.rst:542
msgid ""
"If :c:member:`PyConfig.inspect` is set (such as when the :option:`-i` option "
"is used), rather than returning when the interpreter exits, execution will "
"instead resume in an interactive Python prompt (REPL) using the ``__main__`` "
"module's global namespace. If the interpreter exited with an exception, it "
"is immediately raised in the REPL session. The function return value is then "
"determined by the way the *REPL session* terminates: ``0``, ``1``, or the "
"status of a :exc:`SystemExit`, as specified above."
msgstr ""

#: ../../c-api/init.rst:550
msgid ""
"This function always finalizes the Python interpreter before it returns."
msgstr ""

#: ../../c-api/init.rst:552
msgid ""
"See :ref:`Python Configuration <init-python-config>` for an example of a "
"customized Python that always runs in isolated mode "
"using :c:func:`Py_RunMain`."
msgstr ""
"См. :ref:`Конфигурация Python <init-python-config>` для примера настроенного "
"Python, который всегда работает в изолированном режиме с "
"использованием :c:func:`Py_RunMain`."

#: ../../c-api/init.rst:558
msgid ""
"Register an :mod:`atexit` callback for the target interpreter *interp*. This "
"is similar to :c:func:`Py_AtExit`, but takes an explicit interpreter and "
"data pointer for the callback."
msgstr ""
"Зарегистрируйте обратный вызов :mod:`atexit` для целевого интерпретатора "
"*interp*. Это похоже на :c:func:`Py_AtExit`, но для обратного вызова "
"требуется явный интерпретатор и указатель данных."

#: ../../c-api/init.rst:562
msgid "There must be an :term:`attached thread state` for *interp*."
msgstr ""

#: ../../c-api/init.rst:567
msgid "Process-wide parameters"
msgstr "Общепроцессные параметры"

#: ../../c-api/init.rst:577
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.program_name` should be used instead, "
"see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.program_name`, "
"см. :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:581
msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to "
"the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Эту функцию следует вызывать до первого вызова :c:func:`Py_Initialize`, если "
"она вообще вызывается. Он сообщает интерпретатору значение аргумента "
"``argv[0]`` функции :c:func:`main` программы (преобразованное в широкие "
"символы). Это используется :c:func:`Py_GetPath` и некоторыми другими "
"функциями ниже для поиска библиотек времени выполнения Python относительно "
"исполняемого файла интерпретатора. Значение по умолчанию — ``'python'``. "
"Аргумент должен указывать на строку широких символов с нулевым завершением в "
"статической памяти, содержимое которой не изменится во время выполнения "
"программы. Никакой код в интерпретаторе Python не изменит содержимое этого "
"хранилища."

#: ../../c-api/init.rst:592 ../../c-api/init.rst:840 ../../c-api/init.rst:876
#: ../../c-api/init.rst:902
msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get "
"a :c:expr:`wchar_t*` string."
msgstr ""
"Используйте :c:func:`Py_DecodeLocale` для декодирования строки байтов и "
"получения строки :c:expr:`wchar_t*`."

#: ../../c-api/init.rst:600
msgid ""
"Return the program name set with :c:member:`PyConfig.program_name`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""
"Возвращает имя программы, установленное с "
"помощью :c:member:`PyConfig.program_name`, или значение по умолчанию. "
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение."

#: ../../c-api/init.rst:604 ../../c-api/init.rst:627 ../../c-api/init.rst:675
#: ../../c-api/init.rst:699 ../../c-api/init.rst:726 ../../c-api/init.rst:914
msgid ""
"This function should not be called before :c:func:`Py_Initialize`, otherwise "
"it returns ``NULL``."
msgstr ""
"Эту функцию не следует вызывать до :c:func:`Py_Initialize`, иначе она вернет "
"``NULL``."

#: ../../c-api/init.rst:607 ../../c-api/init.rst:630 ../../c-api/init.rst:678
#: ../../c-api/init.rst:702 ../../c-api/init.rst:731 ../../c-api/init.rst:917
msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr "Теперь он возвращает NULL, если был вызван до :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:610 ../../c-api/init.rst:705
msgid ""
"Use :c:func:`PyConfig_Get(\"executable\") <PyConfig_Get>` "
"(:data:`sys.executable`) instead."
msgstr ""

#: ../../c-api/init.rst:617
msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:member:`PyConfig.program_name` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller "
"should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the :option:`--prefix` "
"argument to the :program:`configure` script at build time.  The value is "
"available to Python code as ``sys.base_prefix``. It is only useful on Unix.  "
"See also the next function."
msgstr ""
"Верните *префикс* для установленных файлов, независимых от платформы. Это "
"получается с помощью ряда сложных правил из имени программы, заданного с "
"помощью :c:member:`PyConfig.program_name` и некоторых переменных среды; "
"например, если имя программы ``'/usr/local/bin/python'``, префикс будет ``'/"
"usr/local'``. Возвращенная строка указывает на статическое хранилище; "
"вызывающая сторона не должна изменять его значение. Это соответствует "
"переменной :makevar:`prefix` в :file:`Makefile` верхнего уровня и "
"аргументу :option:`--prefix` скрипта :program:`configure` во время сборки. "
"Это значение доступно для кода Python как ``sys.base_prefix``. Это полезно "
"только в Unix. См. также следующую функцию."

#: ../../c-api/init.rst:633
msgid ""
"Use :c:func:`PyConfig_Get(\"base_prefix\") <PyConfig_Get>` "
"(:data:`sys.base_prefix`) instead. Use :c:func:`PyConfig_Get(\"prefix\") "
"<PyConfig_Get>` (:data:`sys.prefix`) if :ref:`virtual environments <venv-"
"def>` need to be handled."
msgstr ""

#: ../../c-api/init.rst:642
msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set "
"with :c:member:`PyConfig.program_name` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix "
"is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to "
"the :makevar:`exec_prefix` variable in the top-level :file:`Makefile` and "
"the ``--exec-prefix`` argument to the :program:`configure` script at build  "
"time.  The value is available to Python code as ``sys.base_exec_prefix``.  "
"It is only useful on Unix."
msgstr ""
"Верните *exec-префикс* для установленных *зависимых* от платформы файлов. "
"Это получается с помощью ряда сложных правил из имени программы, заданного с "
"помощью :c:member:`PyConfig.program_name` и некоторых переменных среды; "
"например, если имя программы ``'/usr/local/bin/python'``, префикс exec будет "
"``'/usr/local'``. Возвращенная строка указывает на статическое хранилище; "
"вызывающая сторона не должна изменять его значение. Это соответствует "
"переменной :makevar:`exec_prefix` в :file:`Makefile` верхнего уровня и "
"аргументу ``--exec-prefix`` сценария :program:`configure` во время сборки. "
"Это значение доступно для кода Python как ``sys.base_exec_prefix``. Это "
"полезно только в Unix."

#: ../../c-api/init.rst:653
msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform "
"independent may be installed in :file:`/usr/local`."
msgstr ""
"Справочная информация. Префикс exec-prefix отличается от префикса, когда "
"файлы, зависящие от платформы (например, исполняемые файлы и общие "
"библиотеки), устанавливаются в другое дерево каталогов. При типичной "
"установке файлы, зависящие от платформы, могут быть установлены в "
"поддереве :file:`/usr/local/plat`, тогда как независимые от платформы файлы "
"могут быть установлены в :file:`/usr/local`."

#: ../../c-api/init.rst:659
msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system generally "
"also form different platforms.  Non-Unix operating systems are a different "
"story; the installation strategies on those systems are so different that "
"the prefix and exec-prefix are meaningless, and set to the empty string. "
"Note that compiled Python bytecode files are platform independent (but not "
"independent from the Python version by which they were compiled!)."
msgstr ""
"Вообще говоря, платформа представляет собой комбинацию семейств аппаратного "
"и программного обеспечения, например, машины Sparc под управлением "
"операционной системы Solaris 2.x считаются одной и той же платформой, но "
"машины Intel под управлением Solaris 2.x — это другая платформа, а машины "
"Intel под управлением Linux — еще одна платформа. другая платформа. "
"Различные основные версии одной и той же операционной системы обычно "
"образуют разные платформы. Операционные системы, отличные от Unix, — это "
"совсем другая история; стратегии установки в этих системах настолько "
"различны, что префикс и префикс exec не имеют смысла и устанавливаются в "
"пустую строку. Обратите внимание, что скомпилированные файлы байт-кода "
"Python не зависят от платформы (но не от версии Python, с помощью которой "
"они были скомпилированы!)."

#: ../../c-api/init.rst:670
msgid ""
"System administrators will know how to configure the :program:`mount` "
"or :program:`automount` programs to share :file:`/usr/local` between "
"platforms while having :file:`/usr/local/plat` be a different filesystem for "
"each platform."
msgstr ""
"Системные администраторы знают, как настроить программы :program:`mount` "
"или :program:`automount` для совместного использования :file:`/usr/local` "
"между платформами, при этом :file:`/usr/local/plat` будет разные файловые "
"системы для каждой платформы."

#: ../../c-api/init.rst:681
msgid ""
"Use :c:func:`PyConfig_Get(\"base_exec_prefix\") <PyConfig_Get>` "
"(:data:`sys.base_exec_prefix`) instead. "
"Use :c:func:`PyConfig_Get(\"exec_prefix\") <PyConfig_Get>` "
"(:data:`sys.exec_prefix`) if :ref:`virtual environments <venv-def>` need to "
"be handled."
msgstr ""

#: ../../c-api/init.rst:693
msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:member:`PyConfig.program_name`). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""
"Вернуть полное имя исполняемого файла Python; это вычисляется как побочный "
"эффект получения пути поиска модуля по умолчанию из имени программы "
"(установленного :c:member:`PyConfig.program_name`). Возвращенная строка "
"указывает на статическое хранилище; вызывающий абонент не должен изменять "
"его значение. Это значение доступно для кода Python как ``sys.executable``."

#: ../../c-api/init.rst:716
msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:member:`PyConfig.program_name`) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path "
"for loading modules."
msgstr ""
"Вернуть путь поиска модуля по умолчанию; это вычисляется на основе имени "
"программы (заданного :c:member:`PyConfig.program_name`) и некоторых "
"переменных среды. Возвращенная строка состоит из серии имен каталогов, "
"разделенных символом-разделителем, зависящим от платформы. Символом-"
"разделителем является ``':'`` в Unix и macOS, ``';'`` в Windows. "
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Список :data:`sys.path` инициализируется "
"этим значением при запуске интерпретатора; его можно (и обычно это делают) "
"изменить позже, чтобы изменить путь поиска для загрузки модулей."

#: ../../c-api/init.rst:734
msgid ""
"Use :c:func:`PyConfig_Get(\"module_search_paths\") <PyConfig_Get>` "
"(:data:`sys.path`) instead."
msgstr ""

#: ../../c-api/init.rst:740
msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr ""
"Верните версию этого интерпретатора Python. Это строка, которая выглядит "
"примерно так::"

#: ../../c-api/init.rst:743
msgid "\"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\""
msgstr "\"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\""

#: ../../c-api/init.rst:747
msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated by a "
"period.  The returned string points into static storage; the caller should "
"not modify its value.  The value is available to Python code "
"as :data:`sys.version`."
msgstr ""
"Первое слово (до первого пробела) — это текущая версия Python; первые "
"символы — это основная и второстепенная версии, разделенные точкой. "
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Это значение доступно для кода Python "
"как :data:`sys.version`."

#: ../../c-api/init.rst:752
msgid "See also the :c:var:`Py_Version` constant."
msgstr "См. также константу :c:var:`Py_Version`."

#: ../../c-api/init.rst:759
msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On macOS, it "
"is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.platform``."
msgstr ""
"Возвращает идентификатор текущей платформы. В Unix оно формируется из "
"«официального» названия операционной системы, преобразованного в нижний "
"регистр, за которым следует основной номер версии; например, для Solaris "
"2.x, который также известен как SunOS 5.x, значение равно ``'sunos5'``. В "
"macOS это «Дарвин». В Windows это ``'win'``. Возвращенная строка указывает "
"на статическое хранилище; вызывающий абонент не должен изменять его "
"значение. Значение доступно для кода Python как ``sys.platform``."

#: ../../c-api/init.rst:770
msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr ""
"Возвратите официальную строку авторских прав для текущей версии Python, "
"например"

#: ../../c-api/init.rst:772
msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

#: ../../c-api/init.rst:776
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Это значение доступно для кода Python как "
"``sys.copyright``."

#: ../../c-api/init.rst:782
msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr ""
"Возвращает указание компилятора, использованного для сборки текущей версии "
"Python, в квадратных скобках, например::"

#: ../../c-api/init.rst:785
msgid "\"[GCC 2.7.2.2]\""
msgstr "\"[GCC 2.7.2.2]\""

#: ../../c-api/init.rst:789 ../../c-api/init.rst:803
msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"Возвращенная строка указывает на статическое хранилище; вызывающий абонент "
"не должен изменять его значение. Это значение доступно для кода Python как "
"часть переменной ``sys.version``."

#: ../../c-api/init.rst:796
msgid ""
"Return information about the sequence number and build date and time  of the "
"current Python interpreter instance, for example ::"
msgstr ""
"Возвращает информацию о порядковом номере, дате и времени сборки текущего "
"экземпляра интерпретатора Python, например:::"

#: ../../c-api/init.rst:799
msgid "\"#67, Aug  1 1997, 22:34:28\""
msgstr "\"#67, Aug  1 1997, 22:34:28\""

#: ../../c-api/init.rst:815
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.argv`, :c:member:`PyConfig.parse_argv` "
"and :c:member:`PyConfig.safe_path` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо этого следует "
"использовать "
"настройки :c:member:`PyConfig.argv`, :c:member:`PyConfig.parse_argv` "
"и :c:member:`PyConfig.safe_path`, см. :ref: `Конфигурация инициализации "
"Python <init-config>`."

#: ../../c-api/init.rst:820
msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"Установите :data:`sys.argv` на основе *argc* и *argv*. Эти параметры "
"аналогичны параметрам, передаваемым в функцию :c:func:`main` программы, с "
"той разницей, что первая запись должна ссылаться на файл сценария, который "
"должен быть выполнен, а не на исполняемый файл, в котором размещен "
"интерпретатор Python. Если скрипта, который будет запущен, нет, первая "
"запись в *argv* может быть пустой строкой. Если этой функции не удается "
"инициализировать :data:`sys.argv`, фатальное состояние сигнализируется с "
"помощью :c:func:`Py_FatalError`."

#: ../../c-api/init.rst:828
msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"Если *updatepath* равен нулю, это все, что делает функция. Если *updatepath* "
"ненулевое значение, функция также изменяет :data:`sys.path` в соответствии "
"со следующим алгоритмом:"

#: ../../c-api/init.rst:832
msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended "
"to :data:`sys.path`."
msgstr ""
"Если имя существующего скрипта передается в ``argv[0]``, к :data:`sys.path` "
"добавляется абсолютный путь к каталогу, в котором находится скрипт."

#: ../../c-api/init.rst:835
msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which "
"is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"В противном случае (то есть, если *argc* равен ``0`` или ``argv[0]`` не "
"указывает на существующее имя файла), перед :data:`sys.path` добавляется "
"пустая строка, это то же самое, что добавление текущего рабочего каталога "
"(``\".\"``)."

#: ../../c-api/init.rst:843 ../../c-api/init.rst:879
msgid ""
"See also :c:member:`PyConfig.orig_argv` and :c:member:`PyConfig.argv` "
"members of the :ref:`Python Initialization Configuration <init-config>`."
msgstr ""
"См. также члены :c:member:`PyConfig.orig_argv` и :c:member:`PyConfig.argv` "
"в :ref:`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/init.rst:847
msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See :cve:`2008-5983`."
msgstr ""
"Приложениям, встраивающим интерпретатор Python для целей, отличных от "
"выполнения отдельного сценария, рекомендуется передавать ``0`` в качестве "
"*updatepath* и при необходимости обновлять :data:`sys.path` самостоятельно. "
"См.:cve:`2008-5983`."

#: ../../c-api/init.rst:852
msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having "
"called :c:func:`PySys_SetArgv`, for example using::"
msgstr ""
"В версиях до 3.1.3 вы можете добиться того же эффекта, вручную извлекая "
"первый элемент :data:`sys.path` после вызова :c:func:`PySys_SetArgv`, "
"например, используя::"

#: ../../c-api/init.rst:856
msgid "PyRun_SimpleString(\"import sys; sys.path.pop(0)\\n\");"
msgstr "PyRun_SimpleString(\"import sys; sys.path.pop(0)\\n\");"

#: ../../c-api/init.rst:868
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.argv` and :c:member:`PyConfig.parse_argv` should "
"be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройки :c:member:`PyConfig.argv` "
"и :c:member:`PyConfig.parse_argv`, см. :ref:`Конфигурация инициализации "
"Python <init-config>`."

#: ../../c-api/init.rst:872
msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with "
"the :option:`-I`."
msgstr ""
"Эта функция работает как :c:func:`PySys_SetArgvEx` с параметром "
"*updatepath*, установленным в ``1``, если только "
"интерпретатор :program:`python` не был запущен с :option:`-I`."

#: ../../c-api/init.rst:882
msgid "The *updatepath* value depends on :option:`-I`."
msgstr "Значение *updatepath* зависит от :option:`-I`."

#: ../../c-api/init.rst:889
msgid ""
"This API is kept for backward compatibility: "
"setting :c:member:`PyConfig.home` should be used instead, see :ref:`Python "
"Initialization Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.home`, см. :ref:`Конфигурация "
"инициализации Python <init-config>`."

#: ../../c-api/init.rst:893
msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"Установите «домашний» каталог по умолчанию, то есть расположение стандартных "
"библиотек Python. См. :envvar:`PYTHONHOME`, чтобы узнать значение строки "
"аргумента."

#: ../../c-api/init.rst:897
msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Аргумент должен указывать на символьную строку с нулевым завершением в "
"статической памяти, содержимое которой не изменится во время выполнения "
"программы. Никакой код в интерпретаторе Python не изменит содержимое этого "
"хранилища."

#: ../../c-api/init.rst:910
msgid ""
"Return the default \"home\", that is, the value set "
"by :c:member:`PyConfig.home`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""
"Возвращает «домой» по умолчанию, то есть значение, "
"установленное :c:member:`PyConfig.home`, или значение переменной "
"среды :envvar:`PYTHONHOME`, если она установлена."

#: ../../c-api/init.rst:920
msgid ""
"Use :c:func:`PyConfig_Get(\"home\") <PyConfig_Get>` or "
"the :envvar:`PYTHONHOME` environment variable instead."
msgstr ""

#: ../../c-api/init.rst:928
msgid "Thread State and the Global Interpreter Lock"
msgstr "Состояние потока и глобальная блокировка интерпретатора"

#: ../../c-api/init.rst:935
msgid ""
"Unless on a :term:`free-threaded <free threading>` build of :term:`CPython`, "
"the Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Если только не используется сборка :term:`free-threaded <free "
"threading>` :term:`CPython`, интерпретатор Python не является полностью "
"потокобезопасным. Для поддержки многопоточных программ Python существует "
"глобальная блокировка, называемая :term:`global interpretationr lock` "
"или :term:`GIL`, которая должна удерживаться текущим потоком, прежде чем он "
"сможет безопасно получить доступ к объектам Python. Без блокировки даже "
"самые простые операции могут вызвать проблемы в многопоточной программе: "
"например, когда два потока одновременно увеличивают счетчик ссылок одного и "
"того же объекта, счетчик ссылок может увеличиться только один раз, а не "
"дважды."

#: ../../c-api/init.rst:946
msgid ""
"Therefore, the rule exists that only the thread that has acquired "
"the :term:`GIL` may operate on Python objects or call Python/C API "
"functions. In order to emulate concurrency of execution, the interpreter "
"regularly tries to switch threads (see :func:`sys.setswitchinterval`).  The "
"lock is also released around potentially blocking I/O operations like "
"reading or writing a file, so that other Python threads can run in the "
"meantime."
msgstr ""
"Следовательно, существует правило, согласно которому только поток, "
"получивший :term:`GIL`, может работать с объектами Python или вызывать "
"функции API Python/C. Чтобы эмулировать параллельное выполнение, "
"интерпретатор регулярно пытается переключать потоки "
"(см. :func:`sys.setswitchinterval`). Блокировка также снимается для "
"потенциальной блокировки операций ввода-вывода, таких как чтение или запись "
"файла, чтобы в это время могли выполняться другие потоки Python."

#: ../../c-api/init.rst:956
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`, known as "
"a :term:`thread state`. Each OS thread has a thread-local pointer to "
"a :c:type:`PyThreadState`; a thread state referenced by this pointer is "
"considered to be :term:`attached <attached thread state>`."
msgstr ""

#: ../../c-api/init.rst:961
msgid ""
"A thread can only have one :term:`attached thread state` at a time. An "
"attached thread state is typically analogous with holding the :term:`GIL`, "
"except on :term:`free-threaded <free threading>` builds.  On builds with "
"the :term:`GIL` enabled, :term:`attaching <attached thread state>` a thread "
"state will block until the :term:`GIL` can be acquired. However,  even on "
"builds with the :term:`GIL` disabled, it is still required to have an "
"attached thread state to call most of the C API."
msgstr ""

#: ../../c-api/init.rst:968
msgid ""
"In general, there will always be an :term:`attached thread state` when using "
"Python's C API. Only in some specific cases (such as in "
"a :c:macro:`Py_BEGIN_ALLOW_THREADS` block) will the thread not have an "
"attached thread state. If uncertain, check "
"if :c:func:`PyThreadState_GetUnchecked` returns ``NULL``."
msgstr ""

#: ../../c-api/init.rst:974
msgid "Detaching the thread state from extension code"
msgstr ""

#: ../../c-api/init.rst:976
msgid ""
"Most extension code manipulating the :term:`thread state` has the following "
"simple structure::"
msgstr ""

#: ../../c-api/init.rst:979
msgid ""
"Save the thread state in a local variable.\n"
"... Do some blocking I/O operation ...\n"
"Restore the thread state from the local variable."
msgstr ""

#: ../../c-api/init.rst:983
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"Это настолько распространено, что существует пара макросов для упрощения:"

#: ../../c-api/init.rst:985
msgid ""
"Py_BEGIN_ALLOW_THREADS\n"
"... Do some blocking I/O operation ...\n"
"Py_END_ALLOW_THREADS"
msgstr ""
"Py_BEGIN_ALLOW_THREADS ... Выполните некоторую блокирующую операцию ввода-"
"вывода... Py_END_ALLOW_THREADS"

#: ../../c-api/init.rst:993
msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the "
"block."
msgstr ""
"Макрос :c:macro:`Py_BEGIN_ALLOW_THREADS` открывает новый блок и объявляет "
"скрытую локальную переменную; Макрос :c:macro:`Py_END_ALLOW_THREADS` "
"закрывает блок."

#: ../../c-api/init.rst:997
msgid "The block above expands to the following code::"
msgstr "Блок выше расширяется до следующего кода:"

#: ../../c-api/init.rst:999
msgid ""
"PyThreadState *_save;\n"
"\n"
"_save = PyEval_SaveThread();\n"
"... Do some blocking I/O operation ...\n"
"PyEval_RestoreThread(_save);"
msgstr ""
"PyThreadState *_save;\n"
"\n"
"_save = PyEval_SaveThread();\n"
"... Do some blocking I/O operation ...\n"
"PyEval_RestoreThread(_save);"

#: ../../c-api/init.rst:1009
msgid "Here is how these functions work:"
msgstr ""

#: ../../c-api/init.rst:1011
msgid ""
"The :term:`attached thread state` holds the :term:`GIL` for the entire "
"interpreter. When detaching the :term:`attached thread state`, "
"the :term:`GIL` is released, allowing other threads to attach a thread state "
"to their own thread, thus getting the :term:`GIL` and can start executing. "
"The pointer to the prior :term:`attached thread state` is stored as a local "
"variable. Upon reaching :c:macro:`Py_END_ALLOW_THREADS`, the thread state "
"that was previously :term:`attached <attached thread state>` is passed "
"to :c:func:`PyEval_RestoreThread`. This function will block until another "
"releases its :term:`thread state <attached thread state>`, thus allowing the "
"old :term:`thread state <attached thread state>` to get re-attached and the "
"C API can be called again."
msgstr ""
":term:`attached thread state` содержит :term:`GIL` для всего интерпретатора. "
"При отсоединении :term:`attached thread state`, :term:`GIL` освобождается, "
"позволяя другим потокам присоединить состояние потока к своему собственному "
"потоку, таким образом получая :term:`GIL` и может начать выполнение. "
"Указатель на предыдущее :term:`attached thread state` сохраняется как "
"локальная переменная. При достижении :c:macro:`Py_END_ALLOW_THREADS` "
"состояние потока, которое ранее было :term:`attached <attached thread "
"state>`, передается в :c:func:`PyEval_RestoreThread`. Эта функция будет "
"блокироваться до тех пор, пока другая не освободит свое :term:`thread state "
"<attached thread state>`, таким образом позволяя старому :term:`thread state "
"<attached thread state>` быть повторно присоединенным, и API C может быть "
"вызвано снова."

#: ../../c-api/init.rst:1021
msgid ""
"For :term:`free-threaded <free threading>` builds, the :term:`GIL` is "
"normally out of the question, but detaching the :term:`thread state "
"<attached thread state>` is still required for blocking I/O and long "
"operations. The difference is that threads don't have to wait for "
"the :term:`GIL` to be released to attach their thread state, allowing true "
"multi-core parallelism."
msgstr ""

#: ../../c-api/init.rst:1027
msgid ""
"Calling system I/O functions is the most common use case for detaching "
"the :term:`thread state <attached thread state>`, but it can also be useful "
"before calling long-running computations which don't need access to Python "
"objects, such as compression or cryptographic functions operating over "
"memory buffers. For example, the standard :mod:`zlib` and :mod:`hashlib` "
"modules detach the :term:`thread state <attached thread state>` when "
"compressing or hashing data."
msgstr ""

#: ../../c-api/init.rst:1038
msgid "Non-Python created threads"
msgstr "Потоки, созданные не на Python"

#: ../../c-api/init.rst:1040
msgid ""
"When threads are created using the dedicated Python APIs (such as "
"the :mod:`threading` module), a thread state is automatically associated to "
"them and the code showed above is therefore correct.  However, when threads "
"are created from C (for example by a third-party library with its own thread "
"management), they don't hold the :term:`GIL`, because they don't have "
"an :term:`attached thread state`."
msgstr ""

#: ../../c-api/init.rst:1047
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating "
"an :term:`attached thread state` before you can start using the Python/C "
"API.  When you are done, you should detach the :term:`thread state <attached "
"thread state>`, and finally free it."
msgstr ""

#: ../../c-api/init.rst:1054
msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
"Функции :c:func:`PyGILState_Ensure` и :c:func:`PyGILState_Release` выполняют "
"все вышеперечисленное автоматически. Типичная идиома для вызова Python из "
"потока C:"

#: ../../c-api/init.rst:1058
msgid ""
"PyGILState_STATE gstate;\n"
"gstate = PyGILState_Ensure();\n"
"\n"
"/* Perform Python actions here. */\n"
"result = CallSomeFunction();\n"
"/* evaluate result or handle exception */\n"
"\n"
"/* Release the thread. No Python API allowed beyond this point. */\n"
"PyGILState_Release(gstate);"
msgstr ""
"PyGILState_STATE gstate;\n"
"gstate = PyGILState_Ensure();\n"
"\n"
"/* Perform Python actions here. */\n"
"result = CallSomeFunction();\n"
"/* evaluate result or handle exception */\n"
"\n"
"/* Release the thread. No Python API allowed beyond this point. */\n"
"PyGILState_Release(gstate);"

#: ../../c-api/init.rst:1068
msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters "
"(using :c:func:`Py_NewInterpreter`), but mixing multiple interpreters and "
"the ``PyGILState_*`` API is unsupported. This is "
"because :c:func:`PyGILState_Ensure` and similar functions default "
"to :term:`attaching <attached thread state>` a :term:`thread state` for the "
"main interpreter, meaning that the thread can't safely interact with the "
"calling subinterpreter."
msgstr ""

#: ../../c-api/init.rst:1078
msgid "Supporting subinterpreters in non-Python threads"
msgstr ""

#: ../../c-api/init.rst:1080
msgid ""
"If you would like to support subinterpreters with non-Python created "
"threads, you must use the ``PyThreadState_*`` API instead of the traditional "
"``PyGILState_*`` API."
msgstr ""

#: ../../c-api/init.rst:1084
msgid ""
"In particular, you must store the interpreter state from the calling "
"function and pass it to :c:func:`PyThreadState_New`, which will ensure that "
"the :term:`thread state` is targeting the correct interpreter::"
msgstr ""

#: ../../c-api/init.rst:1088
msgid ""
"/* The return value of PyInterpreterState_Get() from the\n"
"   function that created this thread. */\n"
"PyInterpreterState *interp = ThreadData->interp;\n"
"PyThreadState *tstate = PyThreadState_New(interp);\n"
"PyThreadState_Swap(tstate);\n"
"\n"
"/* GIL of the subinterpreter is now held.\n"
"   Perform Python actions here. */\n"
"result = CallSomeFunction();\n"
"/* evaluate result or handle exception */\n"
"\n"
"/* Destroy the thread state. No Python API allowed beyond this point. */\n"
"PyThreadState_Clear(tstate);\n"
"PyThreadState_DeleteCurrent();"
msgstr ""

#: ../../c-api/init.rst:1106
msgid "Cautions about fork()"
msgstr "Предостережения относительно fork()"

#: ../../c-api/init.rst:1108
msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist.  This has a "
"concrete impact both on how locks must be handled and on all stored state in "
"CPython's runtime."
msgstr ""
"Еще одна важная вещь, которую следует отметить в отношении потоков, — это их "
"поведение при вызове C :c:func:`fork`. В большинстве систем с :c:func:`fork` "
"после разветвления процесса будет существовать только поток, выдавший "
"разветвление. Это оказывает конкретное влияние как на то, как должны "
"обрабатываться блокировки, так и на все сохраненные состояния во время "
"выполнения CPython."

#: ../../c-api/init.rst:1114
msgid ""
"The fact that only the \"current\" thread remains means any locks held by "
"other threads will never be released. Python solves this for :func:`os.fork` "
"by acquiring the locks it uses internally before the fork, and releasing "
"them afterwards. In addition, it resets any :ref:`lock-objects` in the "
"child. When extending or embedding Python, there is no way to inform Python "
"of additional (non-Python) locks that need to be acquired before or reset "
"after a fork. OS facilities such as :c:func:`!pthread_atfork` would need to "
"be used to accomplish the same thing. Additionally, when extending or "
"embedding Python, calling :c:func:`fork` directly rather than "
"through :func:`os.fork` (and returning to or calling into Python) may result "
"in a deadlock by one of Python's internal locks being held by a thread that "
"is defunct after the fork. :c:func:`PyOS_AfterFork_Child` tries to reset the "
"necessary locks, but is not always able to."
msgstr ""
"Тот факт, что остается только «текущий» поток, означает, что любые "
"блокировки, удерживаемые другими потоками, никогда не будут сняты. Python "
"решает эту проблему для :func:`os.fork`, получая внутренние блокировки, "
"которые он использует перед разветвлением, и освобождая их после этого. "
"Кроме того, он сбрасывает любые :ref:`lock-objects` в дочернем объекте. При "
"расширении или внедрении Python невозможно сообщить Python о дополнительных "
"(не Python) блокировках, которые необходимо получить до или сбросить после "
"разветвления. Для достижения той же цели необходимо будет использовать такие "
"средства ОС, как :c:func:`!pthread_atfork`. Кроме того, при расширении или "
"встраивании Python вызов :c:func:`fork` напрямую, а не через :func:`os.fork` "
"(и возврат или вызов Python) может привести к взаимоблокировке из-за того, "
"что одна из внутренних блокировок Python удерживается потоком, который "
"прекратил свое существование после "
"разветвления. :c:func:`PyOS_AfterFork_Child` пытается сбросить необходимые "
"блокировки, но не всегда это удается."

#: ../../c-api/init.rst:1129
msgid ""
"The fact that all other threads go away also means that CPython's runtime "
"state there must be cleaned up properly, which :func:`os.fork` does.  This "
"means finalizing all other :c:type:`PyThreadState` objects belonging to the "
"current interpreter and all other :c:type:`PyInterpreterState` objects.  Due "
"to this and the special nature of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`, :c:func:`fork` should only be called in that "
"interpreter's \"main\" thread, where the CPython global runtime was "
"originally initialized. The only exception is if :c:func:`exec` will be "
"called immediately after."
msgstr ""
"Тот факт, что все остальные потоки исчезают, также означает, что состояние "
"времени выполнения CPython должно быть должным образом очищено, что и "
"делает :func:`os.fork`. Это означает финализацию всех остальных "
"объектов :c:type:`PyThreadState`, принадлежащих текущему интерпретатору, и "
"всех остальных объектов :c:type:`PyInterpreterState`. Из-за этого, а также "
"из-за особой природы :ref:`\"main\" интерпретатора <sub-interpreter-"
"support>`, :c:func:`fork` следует вызывать только в \"основном\" потоке "
"этого интерпретатора, где глобальный CPython среда выполнения была "
"изначально инициализирована. Единственное исключение — если сразу после "
"этого будет вызвана :c:func:`exec`."

#: ../../c-api/init.rst:1143
msgid "Cautions regarding runtime finalization"
msgstr ""

#: ../../c-api/init.rst:1145
msgid ""
"In the late stage of :term:`interpreter shutdown`, after attempting to wait "
"for non-daemon threads to exit (though this can be interrupted "
"by :class:`KeyboardInterrupt`) and running the :mod:`atexit` functions, the "
"runtime is marked as *finalizing*: :c:func:`Py_IsFinalizing` "
"and :func:`sys.is_finalizing` return true.  At this point, only the "
"*finalization thread* that initiated finalization (typically the main "
"thread) is allowed to acquire the :term:`GIL`."
msgstr ""

#: ../../c-api/init.rst:1153
msgid ""
"If any thread, other than the finalization thread, attempts to attach "
"a :term:`thread state` during finalization, either explicitly or implicitly, "
"the thread enters **a permanently blocked state** where it remains until the "
"program exits.  In most cases this is harmless, but this can result in "
"deadlock if a later stage of finalization attempts to acquire a lock owned "
"by the blocked thread, or otherwise waits on the blocked thread."
msgstr ""

#: ../../c-api/init.rst:1160
msgid ""
"Gross? Yes. This prevents random crashes and/or unexpectedly skipped C++ "
"finalizations further up the call stack when such threads were forcibly "
"exited here in CPython 3.13 and earlier. The CPython runtime :term:`thread "
"state` C APIs have never had any error reporting or handling expectations "
"at :term:`thread state` attachment time that would've allowed for graceful "
"exit from this situation. Changing that would require new stable C APIs and "
"rewriting the majority of C code in the CPython ecosystem to use those with "
"error handling."
msgstr ""

#: ../../c-api/init.rst:1170
msgid "High-level API"
msgstr "Высокоуровневый API"

#: ../../c-api/init.rst:1172
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""
"Это наиболее часто используемые типы и функции при написании кода расширения "
"C или при внедрении интерпретатора Python:"

#: ../../c-api/init.rst:1177
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"Эта структура данных представляет состояние, разделяемое несколькими "
"взаимодействующими потоками. Потоки, принадлежащие одному и тому же "
"интерпретатору, совместно используют административные модули и некоторые "
"другие внутренние элементы. В этой структуре нет публичных членов."

#: ../../c-api/init.rst:1182
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"Потоки, принадлежащие разным интерпретаторам, изначально ничего не "
"разделяют, кроме состояния процесса, такого как доступная память, "
"дескрипторы открытых файлов и т. д. Глобальная блокировка интерпретатора "
"также используется всеми потоками, независимо от того, какому интерпретатору "
"они принадлежат."

#: ../../c-api/init.rst:1189
msgid ""
":pep:`684` introduced the possibility of a :ref:`per-interpreter GIL <per-"
"interpreter-gil>`. See :c:func:`Py_NewInterpreterFromConfig`."
msgstr ""

#: ../../c-api/init.rst:1196
msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is:"
msgstr ""
"Эта структура данных представляет состояние одного потока. Единственный "
"общедоступный элемент данных:"

#: ../../c-api/init.rst:1201
msgid "This thread's interpreter state."
msgstr "Состояние интерпретатора этого потока."

#: ../../c-api/init.rst:1212
msgid "Deprecated function which does nothing."
msgstr "Устаревшая функция, которая ничего не делает."

#: ../../c-api/init.rst:1214
msgid ""
"In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr ""
"В Python 3.6 и старше эта функция создавала GIL, если он не существовал."

#: ../../c-api/init.rst:1216
msgid "The function now does nothing."
msgstr "Функция теперь ничего не делает."

#: ../../c-api/init.rst:1219
msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't have "
"to call it yourself anymore."
msgstr ""
"Эта функция теперь вызывается :c:func:`Py_Initialize()`, поэтому вам больше "
"не придется вызывать ее самостоятельно."

#: ../../c-api/init.rst:1223
msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr "Эту функцию больше нельзя вызывать до :c:func:`Py_Initialize()`."

#: ../../c-api/init.rst:1233
msgid ""
"Detach the :term:`attached thread state` and return it. The thread will have "
"no :term:`thread state` upon returning."
msgstr ""

#: ../../c-api/init.rst:1239
msgid ""
"Set the :term:`attached thread state` to *tstate*. The passed :term:`thread "
"state` **should not** be :term:`attached <attached thread state>`, otherwise "
"deadlock ensues. *tstate* will be attached upon returning."
msgstr ""

#: ../../c-api/init.rst:1244 ../../c-api/init.rst:1615
msgid ""
"Calling this function from a thread when the runtime is finalizing will hang "
"the thread until the program exits, even if the thread was not created by "
"Python.  Refer to :ref:`cautions-regarding-runtime-finalization` for more "
"details."
msgstr ""

#: ../../c-api/init.rst:1249 ../../c-api/init.rst:1320
#: ../../c-api/init.rst:1625
msgid ""
"Hangs the current thread, rather than terminating it, if called while the "
"interpreter is finalizing."
msgstr ""

#: ../../c-api/init.rst:1255
msgid ""
"Return the :term:`attached thread state`. If the thread has no attached "
"thread state, (such as when inside of :c:macro:`Py_BEGIN_ALLOW_THREADS` "
"block), then this issues a fatal error (so that the caller needn't check for "
"``NULL``)."
msgstr ""

#: ../../c-api/init.rst:1260
msgid "See also :c:func:`PyThreadState_GetUnchecked`."
msgstr "См. также :c:func:`PyThreadState_GetUnchecked`."

#: ../../c-api/init.rst:1264
msgid ""
"Similar to :c:func:`PyThreadState_Get`, but don't kill the process with a "
"fatal error if it is NULL. The caller is responsible to check if the result "
"is NULL."
msgstr ""
"Аналогично :c:func:`PyThreadState_Get`, но не завершайте процесс с фатальной "
"ошибкой, если он равен NULL. Вызывающая сторона несет ответственность за "
"проверку того, является ли результат NULL."

#: ../../c-api/init.rst:1268
msgid ""
"In Python 3.5 to 3.12, the function was private and known as "
"``_PyThreadState_UncheckedGet()``."
msgstr ""
"В версиях Python 3.5–3.12 эта функция была частной и называлась "
"``_PyThreadState_UncheckedGet()``."

#: ../../c-api/init.rst:1275
msgid ""
"Set the :term:`attached thread state` to *tstate*, and return "
"the :term:`thread state` that was attached prior to calling."
msgstr ""

#: ../../c-api/init.rst:1278
msgid ""
"This function is safe to call without an :term:`attached thread state`; it "
"will simply return ``NULL`` indicating that there was no prior thread state."
msgstr ""

#: ../../c-api/init.rst:1285
msgid ""
"Similar to :c:func:`PyGILState_Ensure`, this function will hang the thread "
"if the runtime is finalizing."
msgstr ""

#: ../../c-api/init.rst:1289
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""
"Следующие функции используют локальное хранилище потока и несовместимы с "
"подинтерпретаторами:"

#: ../../c-api/init.rst:1294
msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the :term:`attached thread state`. "
"This may be called as many times as desired by a thread as long as each call "
"is matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` "
"and :c:func:`PyGILState_Release` calls as long as the thread state is "
"restored to its previous state before the Release().  For example, normal "
"usage of the :c:macro:`Py_BEGIN_ALLOW_THREADS` "
"and :c:macro:`Py_END_ALLOW_THREADS` macros is acceptable."
msgstr ""
"Убедитесь, что текущий поток готов вызвать Python C API независимо от "
"текущего состояния Python или :term:`attached thread state`. Это может быть "
"вызвано потоком столько раз, сколько необходимо, пока каждый вызов "
"соответствует вызову :c:func:`PyGILState_Release`. В общем случае, другие "
"API, связанные с потоками, могут использоваться между "
"вызовами :c:func:`PyGILState_Ensure` и :c:func:`PyGILState_Release`, пока "
"состояние потока восстановлено до предыдущего состояния до Release(). "
"Например, нормальное использование "
"макросов :c:macro:`Py_BEGIN_ALLOW_THREADS` и :c:macro:`Py_END_ALLOW_THREADS` "
"является приемлемым."

#: ../../c-api/init.rst:1304
msgid ""
"The return value is an opaque \"handle\" to the :term:`attached thread "
"state` when :c:func:`PyGILState_Ensure` was called, and must be passed "
"to :c:func:`PyGILState_Release` to ensure Python is left in the same state. "
"Even though recursive calls are allowed, these handles *cannot* be shared - "
"each unique call to :c:func:`PyGILState_Ensure` must save the handle for its "
"call to :c:func:`PyGILState_Release`."
msgstr ""

#: ../../c-api/init.rst:1311
msgid ""
"When the function returns, there will be an :term:`attached thread state` "
"and the thread will be able to call arbitrary Python code.  Failure is a "
"fatal error."
msgstr ""

#: ../../c-api/init.rst:1315
msgid ""
"Calling this function when the runtime is finalizing is unsafe. Doing so "
"will either hang the thread until the program ends, or fully crash the "
"interpreter in rare cases. Refer to :ref:`cautions-regarding-runtime-"
"finalization` for more details."
msgstr ""

#: ../../c-api/init.rst:1326
msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the "
"corresponding :c:func:`PyGILState_Ensure` call (but generally this state "
"will be unknown to the caller, hence the use of the GILState API)."
msgstr ""
"Освободите все ранее приобретенные ресурсы. После этого вызова состояние "
"Python будет таким же, как и до соответствующего "
"вызова :c:func:`PyGILState_Ensure` (но обычно это состояние будет неизвестно "
"вызывающей стороне, поэтому используется API GILState)."

#: ../../c-api/init.rst:1331
msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call "
"to :c:func:`PyGILState_Release` on the same thread."
msgstr ""
"Каждый вызов :c:func:`PyGILState_Ensure` должен сопровождаться "
"вызовом :c:func:`PyGILState_Release` в том же потоке."

#: ../../c-api/init.rst:1336
msgid ""
"Get the :term:`attached thread state` for this thread.  May return ``NULL`` "
"if no GILState API has been used on the current thread.  Note that the main "
"thread always has such a thread-state, even if no auto-thread-state call has "
"been made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""

#: ../../c-api/init.rst:1342
msgid ""
"This function does not account for :term:`thread states <thread state>` "
"created by something other than :c:func:`PyGILState_Ensure` (such "
"as :c:func:`PyThreadState_New`). Prefer :c:func:`PyThreadState_Get` "
"or :c:func:`PyThreadState_GetUnchecked` for most cases."
msgstr ""

#: ../../c-api/init.rst:1351
msgid ""
"Return ``1`` if the current thread is holding the :term:`GIL` and ``0`` "
"otherwise. This function can be called from any thread at any time. Only if "
"it has had its :term:`thread state <attached thread state>` initialized "
"via :c:func:`PyGILState_Ensure` will it return ``1``. This is mainly a "
"helper/diagnostic function.  It can be useful for example in callback "
"contexts or memory allocation functions when knowing that the :term:`GIL` is "
"locked can allow the caller to perform sensitive actions or otherwise behave "
"differently."
msgstr ""

#: ../../c-api/init.rst:1361
msgid ""
"If the current Python process has ever created a subinterpreter, this "
"function will *always* return ``1``. "
"Prefer :c:func:`PyThreadState_GetUnchecked` for most cases."
msgstr ""

#: ../../c-api/init.rst:1368
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"Следующие макросы обычно используются без точки с запятой в конце; "
"посмотрите пример использования в дистрибутиве исходного кода Python."

#: ../../c-api/init.rst:1374
msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Note that it contains an opening brace; it must be "
"matched with a following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above "
"for further discussion of this macro."
msgstr ""
"Этот макрос расширяется до ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Обратите внимание, что он содержит открывающую "
"скобку; он должен соответствовать следующему "
"макросу :c:macro:`Py_END_ALLOW_THREADS`. См. выше дальнейшее обсуждение "
"этого макроса."

#: ../../c-api/init.rst:1382
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an "
"earlier :c:macro:`Py_BEGIN_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro."
msgstr ""
"Этот макрос расширяется до ``PyEval_RestoreThread(_save); }``. Обратите "
"внимание, что он содержит закрывающую скобку; он должен соответствовать "
"более раннему макросу :c:macro:`Py_BEGIN_ALLOW_THREADS`. См. выше дальнейшее "
"обсуждение этого макроса."

#: ../../c-api/init.rst:1390
msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent "
"to :c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"Этот макрос расширяется до ``PyEval_RestoreThread(_save);``: он "
"эквивалентен :c:macro:`Py_END_ALLOW_THREADS` без закрывающей скобки."

#: ../../c-api/init.rst:1396
msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent "
"to :c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration."
msgstr ""
"Этот макрос расширяется до ``_save = PyEval_SaveThread();``: он "
"эквивалентен :c:macro:`Py_BEGIN_ALLOW_THREADS` без открывающей скобки и "
"объявления переменной."

#: ../../c-api/init.rst:1402
msgid "Low-level API"
msgstr "Низкоуровневый API"

#: ../../c-api/init.rst:1404
msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr "Все следующие функции должны вызываться после :c:func:`Py_Initialize`."

#: ../../c-api/init.rst:1406
msgid ""
":c:func:`Py_Initialize()` now initializes the :term:`GIL` and sets "
"an :term:`attached thread state`."
msgstr ""

#: ../../c-api/init.rst:1413
msgid ""
"Create a new interpreter state object.  An :term:`attached thread state` is "
"not needed, but may optionally exist if it is necessary to serialize calls "
"to this function."
msgstr ""

#: ../../c-api/init.rst:1417
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.PyInterpreterState_New`` with no arguments."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``cpython.PyInterpreterState_New`` "
"без аргументов."

#: ../../c-api/init.rst:1422
msgid ""
"Reset all information in an interpreter state object.  There must be "
"an :term:`attached thread state` for the interpreter."
msgstr ""

#: ../../c-api/init.rst:1425
msgid ""
"Raises an :ref:`auditing event <auditing>` "
"``cpython.PyInterpreterState_Clear`` with no arguments."
msgstr ""
"Вызывает :ref:`событие аудита <auditing>``cpython.PyInterpreterState_Clear`` "
"без аргументов."

#: ../../c-api/init.rst:1430
msgid ""
"Destroy an interpreter state object.  There **should not** be "
"an :term:`attached thread state` for the target interpreter. The interpreter "
"state must have been reset with a previous call "
"to :c:func:`PyInterpreterState_Clear`."
msgstr ""

#: ../../c-api/init.rst:1437
msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"An :term:`attached thread state` is not needed."
msgstr ""

#: ../../c-api/init.rst:1442
msgid ""
"Reset all information in a :term:`thread state` object.  *tstate* must "
"be :term:`attached <attached thread state>`"
msgstr ""

#: ../../c-api/init.rst:1445
msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback. "
"Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""
"Эта функция теперь вызывает обратный "
"вызов :c:member:`PyThreadState.on_delete`. Ранее это происходило "
"в :c:func:`PyThreadState_Delete`."

#: ../../c-api/init.rst:1449
msgid "The :c:member:`PyThreadState.on_delete` callback was removed."
msgstr "Обратный вызов :c:member:`PyThreadState.on_delete` был удален."

#: ../../c-api/init.rst:1455
msgid ""
"Destroy a :term:`thread state` object.  *tstate* should not "
"be :term:`attached <attached thread state>` to any thread. *tstate* must "
"have been reset with a previous call to :c:func:`PyThreadState_Clear`."
msgstr ""

#: ../../c-api/init.rst:1463
msgid ""
"Detach the :term:`attached thread state` (which must have been reset with a "
"previous call to :c:func:`PyThreadState_Clear`) and then destroy it."
msgstr ""

#: ../../c-api/init.rst:1466
msgid ""
"No :term:`thread state` will be :term:`attached <attached thread state>` "
"upon returning."
msgstr ""

#: ../../c-api/init.rst:1471
msgid "Get the current frame of the Python thread state *tstate*."
msgstr "Получите текущий кадр состояния потока Python *tstate*."

#: ../../c-api/init.rst:1473
msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is currently "
"executing."
msgstr ""
"Верните :term:`сильную ссылку`. Верните NULL, если в данный момент не "
"выполняется ни один кадр."

#: ../../c-api/init.rst:1476
msgid "See also :c:func:`PyEval_GetFrame`."
msgstr "См. также :c:func:`PyEval_GetFrame`."

#: ../../c-api/init.rst:1478 ../../c-api/init.rst:1487
#: ../../c-api/init.rst:1496
msgid ""
"*tstate* must not be ``NULL``, and must be :term:`attached <attached thread "
"state>`."
msgstr ""

#: ../../c-api/init.rst:1485
msgid ""
"Get the unique :term:`thread state` identifier of the Python thread state "
"*tstate*."
msgstr ""

#: ../../c-api/init.rst:1494
msgid "Get the interpreter of the Python thread state *tstate*."
msgstr "Получите интерпретатор состояния потока Python *tstate*."

#: ../../c-api/init.rst:1503
msgid "Suspend tracing and profiling in the Python thread state *tstate*."
msgstr ""
"Приостановить трассировку и профилирование в состоянии потока Python "
"*tstate*."

#: ../../c-api/init.rst:1505
msgid "Resume them using the :c:func:`PyThreadState_LeaveTracing` function."
msgstr ""
"Возобновите их, используя функцию :c:func:`PyThreadState_LeaveTracing`."

#: ../../c-api/init.rst:1512
msgid ""
"Resume tracing and profiling in the Python thread state *tstate* suspended "
"by the :c:func:`PyThreadState_EnterTracing` function."
msgstr ""
"Возобновите трассировку и профилирование в состоянии потока Python *tstate*, "
"приостановленном функцией :c:func:`PyThreadState_EnterTracing`."

#: ../../c-api/init.rst:1515
msgid ""
"See also :c:func:`PyEval_SetTrace` and :c:func:`PyEval_SetProfile` functions."
msgstr ""
"См. также функции :c:func:`PyEval_SetTrace` и :c:func:`PyEval_SetProfile`."

#: ../../c-api/init.rst:1523
msgid "Get the current interpreter."
msgstr "Получите текущий интерпретатор."

#: ../../c-api/init.rst:1525
msgid ""
"Issue a fatal error if there no :term:`attached thread state`. It cannot "
"return NULL."
msgstr ""

#: ../../c-api/init.rst:1533
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then "
"``-1`` is returned and an error is set."
msgstr ""
"Возвращает уникальный идентификатор переводчика. Если при этом произошла "
"какая-либо ошибка, то возвращается ``-1`` и устанавливается ошибка."

#: ../../c-api/init.rst:1536 ../../c-api/init.rst:2125
#: ../../c-api/init.rst:2132 ../../c-api/init.rst:2151
#: ../../c-api/init.rst:2158
msgid "The caller must have an :term:`attached thread state`."
msgstr ""

#: ../../c-api/init.rst:1543
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"Возвращает словарь, в котором могут храниться данные, специфичные для "
"интерпретатора. Если эта функция возвращает NULL, то исключение не возникло, "
"и вызывающая сторона должна предполагать, что словарь, специфичный для "
"интерпретатора, недоступен."

#: ../../c-api/init.rst:1547
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"Это не замена :c:func:`PyModule_GetState()`, расширения которого должны "
"использоваться для хранения информации о состоянии, специфичной для "
"интерпретатора."

#: ../../c-api/init.rst:1555
msgid "Type of a frame evaluation function."
msgstr "Тип функции оценки кадра."

#: ../../c-api/init.rst:1557
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""
"Параметр *throwflag* используется методом генераторов ``throw()``: если он "
"не равен нулю, обрабатывается текущее исключение."

#: ../../c-api/init.rst:1560
msgid "The function now takes a *tstate* parameter."
msgstr "Теперь функция принимает параметр *tstate*."

#: ../../c-api/init.rst:1563
msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr ""
"Параметр *frame* изменен с ``PyFrameObject*`` на ``_PyInterpreterFrame*``."

#: ../../c-api/init.rst:1568
msgid "Get the frame evaluation function."
msgstr "Получите функцию оценки кадра."

#: ../../c-api/init.rst:1570 ../../c-api/init.rst:1578
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr "См. :pep:`523` «Добавление API оценки кадров в CPython»."

#: ../../c-api/init.rst:1576
msgid "Set the frame evaluation function."
msgstr "Установите функцию оценки кадра."

#: ../../c-api/init.rst:1585
msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no :term:`thread "
"state` is :term:`attached <attached thread state>`. If this function returns "
"``NULL``, no exception has been raised and the caller should assume no "
"thread state is attached."
msgstr ""

#: ../../c-api/init.rst:1595
msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with an :term:`attached thread state`. Returns the number of thread states "
"modified; this is normally one, but will be zero if the thread id isn't "
"found.  If *exc* is ``NULL``, the pending exception (if any) for the thread "
"is cleared. This raises no exceptions."
msgstr ""
"Асинхронно вызвать исключение в потоке. Аргумент *id* — это идентификатор "
"потока целевого потока; *exc* — это объект исключения, который должен быть "
"вызван. Эта функция не крадет никаких ссылок на *exc*. Чтобы предотвратить "
"наивное неправильное использование, вы должны написать собственное "
"расширение C для вызова этой функции. Необходимо вызывать с :term:`attached "
"thread state`. Возвращает количество измененных состояний потока; обычно это "
"один, но будет равно нулю, если идентификатор потока не найден. Если *exc* "
"равен ``NULL``, ожидающее исключение (если есть) для потока очищается. Это "
"не вызывает исключений."

#: ../../c-api/init.rst:1603
msgid ""
"The type of the *id* parameter changed from :c:expr:`long` "
"to :c:expr:`unsigned long`."
msgstr ""
"Тип параметра *id* изменен с :c:expr:`long` на :c:expr:`unsigned long`."

#: ../../c-api/init.rst:1609
msgid ""
":term:`Attach <attached thread state>` *tstate* to the current thread, which "
"must not be ``NULL`` or already :term:`attached <attached thread state>`."
msgstr ""

#: ../../c-api/init.rst:1612
msgid ""
"The calling thread must not already have an :term:`attached thread state`."
msgstr ""

#: ../../c-api/init.rst:1620
msgid ""
"Updated to be consistent "
"with :c:func:`PyEval_RestoreThread`, :c:func:`Py_END_ALLOW_THREADS`, "
"and :c:func:`PyGILState_Ensure`, and terminate the current thread if called "
"while the interpreter is finalizing."
msgstr ""
"Обновлено для совместимости "
"с :c:func:`PyEval_RestoreThread`, :c:func:`Py_END_ALLOW_THREADS` "
"и :c:func:`PyGILState_Ensure`, а также завершает текущий поток, если он "
"вызывается во время завершения работы интерпретатора."

#: ../../c-api/init.rst:1629
msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` — это функция более высокого уровня, которая "
"доступна всегда (даже если потоки не инициализированы)."

#: ../../c-api/init.rst:1635
msgid ""
"Detach the :term:`attached thread state`. The *tstate* argument, which must "
"not be ``NULL``, is only used to check that it represents "
"the :term:`attached thread state` --- if it isn't, a fatal error is reported."
msgstr ""

#: ../../c-api/init.rst:1640
msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` — это функция более высокого уровня, которая "
"всегда доступна (даже если потоки не инициализированы)."

#: ../../c-api/init.rst:1647
msgid "Sub-interpreter support"
msgstr "Поддержка субпереводчика"

#: ../../c-api/init.rst:1649
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you "
"to do that."
msgstr ""
"Хотя в большинстве случаев вам понадобится встроить только один "
"интерпретатор Python, в некоторых случаях вам необходимо создать несколько "
"независимых интерпретаторов в одном процессе и, возможно, даже в одном "
"потоке. Субинтерпретаторы позволяют вам это сделать."

#: ../../c-api/init.rst:1654
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike "
"sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution "
"during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""
"«Основной» интерпретатор создается первым при инициализации среды "
"выполнения. Обычно это единственный интерпретатор Python в процессе. В "
"отличие от субинтерпретаторов, главный интерпретатор имеет уникальные "
"глобальные обязанности, такие как обработка сигналов. Он также отвечает за "
"выполнение во время инициализации среды выполнения и обычно является "
"активным интерпретатором во время финализации среды выполнения. "
"Функция :c:func:`PyInterpreterState_Main` возвращает указатель на свое "
"состояние."

#: ../../c-api/init.rst:1661
msgid ""
"You can switch between sub-interpreters using "
"the :c:func:`PyThreadState_Swap` function. You can create and destroy them "
"using the following functions:"
msgstr ""
"Вы можете переключаться между субинтерпретаторами с помощью "
"функции :c:func:`PyThreadState_Swap`. Вы можете создавать и уничтожать их, "
"используя следующие функции:"

#: ../../c-api/init.rst:1667
msgid ""
"Structure containing most parameters to configure a sub-interpreter. Its "
"values are used only in :c:func:`Py_NewInterpreterFromConfig` and never "
"modified by the runtime."
msgstr ""
"Структура, содержащая большинство параметров для настройки "
"субинтерпретатора. Его значения используются только "
"в :c:func:`Py_NewInterpreterFromConfig` и никогда не изменяются во время "
"выполнения."

#: ../../c-api/init.rst:1673
msgid "Structure fields:"
msgstr "Структурные поля:"

#: ../../c-api/init.rst:1677
msgid ""
"If this is ``0`` then the sub-interpreter will use its own \"object\" "
"allocator state. Otherwise it will use (share) the main interpreter's."
msgstr ""
"Если это ``0``, то субинтерпретатор будет использовать свое собственное "
"состояние распределителя «объекта». В противном случае он будет использовать "
"(разделять) основной интерпретатор."

#: ../../c-api/init.rst:1681
msgid ""
"If this is ``0`` "
"then :c:member:`~PyInterpreterConfig.check_multi_interp_extensions` must be "
"``1`` (non-zero). If this is ``1`` then :c:member:`~PyInterpreterConfig.gil` "
"must not be :c:macro:`PyInterpreterConfig_OWN_GIL`."
msgstr ""
"Если это ``0``, "
"то :c:member:`~PyInterpreterConfig.check_multi_interp_extensions` должен "
"быть ``1`` (не ноль). Если это ``1``, "
"то :c:member:`~PyInterpreterConfig.gil` не должен "
"быть :c:macro:`PyInterpreterConfig_OWN_GIL`."

#: ../../c-api/init.rst:1689
msgid ""
"If this is ``0`` then the runtime will not support forking the process in "
"any thread where the sub-interpreter is currently active. Otherwise fork is "
"unrestricted."
msgstr ""
"Если это ``0``, то среда выполнения не будет поддерживать разветвление "
"процесса в любом потоке, где субинтерпретатор в данный момент активен. В "
"противном случае форк не имеет ограничений."

#: ../../c-api/init.rst:1693
msgid ""
"Note that the :mod:`subprocess` module still works when fork is disallowed."
msgstr ""
"Обратите внимание, что модуль :mod:`subprocess` по-прежнему работает, когда "
"fork запрещен."

#: ../../c-api/init.rst:1698
msgid ""
"If this is ``0`` then the runtime will not support replacing the current "
"process via exec (e.g. :func:`os.execv`) in any thread where the sub-"
"interpreter is currently active. Otherwise exec is unrestricted."
msgstr ""
"Если это ``0``, то среда выполнения не будет поддерживать замену текущего "
"процесса через exec (например, :func:`os.execv`) в любом потоке, где "
"субинтерпретатор в данный момент активен. В противном случае exec не имеет "
"ограничений."

#: ../../c-api/init.rst:1703
msgid ""
"Note that the :mod:`subprocess` module still works when exec is disallowed."
msgstr ""
"Обратите внимание, что модуль :mod:`subprocess` по-прежнему работает, даже "
"если exec запрещен."

#: ../../c-api/init.rst:1708
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create threads. Otherwise threads are allowed."
msgstr ""
"Если это ``0``, то модуль субинтерпретатора :mod:`threading` не будет "
"создавать потоки. В противном случае потоки разрешены."

#: ../../c-api/init.rst:1714
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create daemon threads. Otherwise daemon threads are allowed (as long "
"as :c:member:`~PyInterpreterConfig.allow_threads` is non-zero)."
msgstr ""
"Если это ``0``, то модуль :mod:`threading` субинтерпретатора не будет "
"создавать потоки демона. В противном случае потоки демона разрешены "
"(если :c:member:`~PyInterpreterConfig.allow_threads` не равно нулю)."

#: ../../c-api/init.rst:1721
msgid ""
"If this is ``0`` then all extension modules may be imported, including "
"legacy (single-phase init) modules, in any thread where the sub-interpreter "
"is currently active. Otherwise only multi-phase init extension modules "
"(see :pep:`489`) may be imported. (Also "
"see :c:macro:`Py_mod_multiple_interpreters`.)"
msgstr ""
"Если это ``0``, то все модули расширения могут быть импортированы, включая "
"устаревшие модули (однофазная инициализация), в любом потоке, где "
"субинтерпретатор в данный момент активен. В противном случае можно "
"импортировать только модули расширения многофазной инициализации "
"(см. :pep:`489`). (См. также :c:macro:`Py_mod_multiple_interpreters`.)"

#: ../../c-api/init.rst:1728
msgid ""
"This must be ``1`` (non-zero) "
"if :c:member:`~PyInterpreterConfig.use_main_obmalloc` is ``0``."
msgstr ""
"Это должно быть ``1`` (не ноль), "
"если :c:member:`~PyInterpreterConfig.use_main_obmalloc` равно ``0``."

#: ../../c-api/init.rst:1733
msgid ""
"This determines the operation of the GIL for the sub-interpreter. It may be "
"one of the following:"
msgstr ""
"Это определяет работу GIL для субинтерпретатора. Это может быть одно из "
"следующих:"

#: ../../c-api/init.rst:1740
msgid "Use the default selection (:c:macro:`PyInterpreterConfig_SHARED_GIL`)."
msgstr ""
"Используйте выбор по умолчанию (:c:macro:`PyInterpreterConfig_SHARED_GIL`)."

#: ../../c-api/init.rst:1744
msgid "Use (share) the main interpreter's GIL."
msgstr "Используйте (делитесь) GIL основного интерпретатора."

#: ../../c-api/init.rst:1748
msgid "Use the sub-interpreter's own GIL."
msgstr "Используйте собственный GIL субинтерпретатора."

#: ../../c-api/init.rst:1750
msgid ""
"If this is :c:macro:`PyInterpreterConfig_OWN_GIL` "
"then :c:member:`PyInterpreterConfig.use_main_obmalloc` must be ``0``."
msgstr ""
"Если это :c:macro:`PyInterpreterConfig_OWN_GIL`, "
"то :c:member:`PyInterpreterConfig.use_main_obmalloc` должен быть ``0``."

#: ../../c-api/init.rst:1764
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` "
"and :mod:`sys`.  The table of loaded modules (``sys.modules``) and the "
"module search path (``sys.path``) are also separate.  The new environment "
"has no ``sys.argv`` variable.  It has new standard I/O stream file objects "
"``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` (however these refer to the "
"same underlying file descriptors)."
msgstr ""
"Создайте нового субинтерпретатора. Это (почти) полностью отдельная среда для "
"выполнения кода Python. В частности, новый интерпретатор имеет отдельные, "
"независимые версии всех импортированных модулей, включая фундаментальные "
"модули :mod:`builtins`, :mod:`__main__` и :mod:`sys`. Таблица загруженных "
"модулей («sys.modules») и путь поиска модулей («sys.path») также разделены. "
"В новой среде нет переменной sys.argv. Он имеет новые стандартные файловые "
"объекты потока ввода-вывода ``sys.stdin``, ``sys.stdout`` и ``sys.stderr`` "
"(однако они относятся к одним и тем же базовым файловым дескрипторам)."

#: ../../c-api/init.rst:1774
msgid ""
"The given *config* controls the options with which the interpreter is "
"initialized."
msgstr ""
"Данная *config* управляет опциями, с которыми инициализируется интерпретатор."

#: ../../c-api/init.rst:1777
msgid ""
"Upon success, *tstate_p* will be set to the first :term:`thread state` "
"created in the new sub-interpreter.  This thread state is :term:`attached "
"<attached thread state>`. Note that no actual thread is created; see the "
"discussion of thread states below.  If creation of the new interpreter is "
"unsuccessful, *tstate_p* is set to ``NULL``; no exception is set since the "
"exception state is stored in the :term:`attached thread state`, which might "
"not exist."
msgstr ""

#: ../../c-api/init.rst:1786
msgid ""
"Like all other Python/C API functions, an :term:`attached thread state` must "
"be present before calling this function, but it might be detached upon "
"returning. On success, the returned thread state will be :term:`attached "
"<attached thread state>`. If the sub-interpreter is created with its "
"own :term:`GIL` then the :term:`attached thread state` of the calling "
"interpreter will be detached. When the function returns, the new "
"interpreter's :term:`thread state` will be :term:`attached <attached thread "
"state>` to the current thread and the previous interpreter's :term:`attached "
"thread state` will remain detached."
msgstr ""

#: ../../c-api/init.rst:1797
msgid ""
"Sub-interpreters are most effective when isolated from each other, with "
"certain functionality restricted::"
msgstr ""
"Субинтерпретаторы наиболее эффективны, когда они изолированы друг от друга с "
"ограничением определенных функций:"

#: ../../c-api/init.rst:1800
msgid ""
"PyInterpreterConfig config = {\n"
"    .use_main_obmalloc = 0,\n"
"    .allow_fork = 0,\n"
"    .allow_exec = 0,\n"
"    .allow_threads = 1,\n"
"    .allow_daemon_threads = 0,\n"
"    .check_multi_interp_extensions = 1,\n"
"    .gil = PyInterpreterConfig_OWN_GIL,\n"
"};\n"
"PyThreadState *tstate = NULL;\n"
"PyStatus status = Py_NewInterpreterFromConfig(&tstate, &config);\n"
"if (PyStatus_Exception(status)) {\n"
"    Py_ExitStatusException(status);\n"
"}"
msgstr ""
"PyInterpreterConfig config = {\n"
"    .use_main_obmalloc = 0,\n"
"    .allow_fork = 0,\n"
"    .allow_exec = 0,\n"
"    .allow_threads = 1,\n"
"    .allow_daemon_threads = 0,\n"
"    .check_multi_interp_extensions = 1,\n"
"    .gil = PyInterpreterConfig_OWN_GIL,\n"
"};\n"
"PyThreadState *tstate = NULL;\n"
"PyStatus status = Py_NewInterpreterFromConfig(&tstate, &config);\n"
"if (PyStatus_Exception(status)) {\n"
"    Py_ExitStatusException(status);\n"
"}"

#: ../../c-api/init.rst:1815
msgid ""
"Note that the config is used only briefly and does not get modified. During "
"initialization the config's values are converted into "
"various :c:type:`PyInterpreterState` values.  A read-only copy of the config "
"may be stored internally on the :c:type:`PyInterpreterState`."
msgstr ""
"Обратите внимание, что конфигурация используется недолго и не изменяется. Во "
"время инициализации значения конфигурации преобразуются в различные "
"значения :c:type:`PyInterpreterState`. Копия конфигурации, доступная только "
"для чтения, может храниться внутри :c:type:`PyInterpreterState`."

#: ../../c-api/init.rst:1824
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr ""
"Модули расширения распределяются между (суб)интерпретаторами следующим "
"образом:"

#: ../../c-api/init.rst:1826
msgid ""
"For modules using multi-phase initialization, "
"e.g. :c:func:`PyModule_FromDefAndSpec`, a separate module object is created "
"and initialized for each interpreter. Only C-level static and global "
"variables are shared between these module objects."
msgstr ""
"Для модулей, использующих многофазную инициализацию, "
"например :c:func:`PyModule_FromDefAndSpec`, для каждого интерпретатора "
"создается и инициализируется отдельный объект модуля. Эти объекты модуля "
"совместно используют только статические и глобальные переменные уровня C."

#: ../../c-api/init.rst:1832
msgid ""
"For modules using single-phase initialization, "
"e.g. :c:func:`PyModule_Create`, the first time a particular extension is "
"imported, it is initialized normally, and a (shallow) copy of its module's "
"dictionary is squirreled away. When the same extension is imported by "
"another (sub-)interpreter, a new module is initialized and filled with the "
"contents of this copy; the extension's ``init`` function is not called. "
"Objects in the module's dictionary thus end up shared across "
"(sub-)interpreters, which might cause unwanted behavior (see `Bugs and "
"caveats`_ below)."
msgstr ""
"Для модулей, использующих однофазную инициализацию, "
"например :c:func:`PyModule_Create`, при первом импорте определенного "
"расширения оно инициализируется нормально, а (неполная) копия словаря его "
"модуля сохраняется. Когда то же расширение импортируется другим "
"(суб)интерпретатором, новый модуль инициализируется и заполняется содержимым "
"этой копии; функция ``init`` расширения не вызывается. Таким образом, "
"объекты в словаре модуля становятся общими для (суб)интерпретаторов, что "
"может вызвать нежелательное поведение (см. `Ошибки и предостережения`_ ниже)."

#: ../../c-api/init.rst:1843
msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by "
"calling :c:func:`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, "
"the extension's ``initmodule`` function *is* called again. As with multi-"
"phase initialization, this means that only C-level static and global "
"variables are shared between these modules."
msgstr ""
"Обратите внимание, что это отличается от того, что происходит, когда "
"расширение импортируется после полной повторной инициализации интерпретатора "
"путем вызова :c:func:`Py_FinalizeEx` и :c:func:`Py_Initialize`; в этом "
"случае функция ``initmodule`` расширения *вызывается* снова. Как и в случае "
"с многофазной инициализацией, это означает, что между этими модулями "
"используются только статические и глобальные переменные уровня C."

#: ../../c-api/init.rst:1863
msgid ""
"Create a new sub-interpreter.  This is essentially just a wrapper "
"around :c:func:`Py_NewInterpreterFromConfig` with a config that preserves "
"the existing behavior.  The result is an unisolated sub-interpreter that "
"shares the main interpreter's GIL, allows fork/exec, allows daemon threads, "
"and allows single-phase init modules."
msgstr ""
"Создайте нового субинтерпретатора. По сути, это просто "
"оболочка :c:func:`Py_NewInterpreterFromConfig` с конфигурацией, сохраняющей "
"существующее поведение. В результате получается неизолированный "
"подинтерпретатор, который использует GIL основного интерпретатора, допускает "
"fork/exec, разрешает потоки демона и допускает однофазные модули "
"инициализации."

#: ../../c-api/init.rst:1875
msgid ""
"Destroy the (sub-)interpreter represented by the given :term:`thread state`. "
"The given thread state must be :term:`attached <attached thread state>`. "
"When the call returns, there will be no :term:`attached thread state`. All "
"thread states associated with this interpreter are destroyed."
msgstr ""

#: ../../c-api/init.rst:1880
msgid ""
":c:func:`Py_FinalizeEx` will destroy all sub-interpreters that haven't been "
"explicitly destroyed at that point."
msgstr ""
":c:func:`Py_FinalizeEx` уничтожит все субинтерпретаторы, которые не были "
"явно уничтожены на данный момент."

#: ../../c-api/init.rst:1887
msgid "A Per-Interpreter GIL"
msgstr "GIL для каждого интерпретатора"

#: ../../c-api/init.rst:1889
msgid ""
"Using :c:func:`Py_NewInterpreterFromConfig` you can create a sub-interpreter "
"that is completely isolated from other interpreters, including having its "
"own GIL.  The most important benefit of this isolation is that such an "
"interpreter can execute Python code without being blocked by other "
"interpreters or blocking any others.  Thus a single Python process can truly "
"take advantage of multiple CPU cores when running Python code.  The "
"isolation also encourages a different approach to concurrency than that of "
"just using threads. (See :pep:`554` and :pep:`684`.)"
msgstr ""

#: ../../c-api/init.rst:1899
msgid ""
"Using an isolated interpreter requires vigilance in preserving that "
"isolation.  That especially means not sharing any objects or mutable state "
"without guarantees about thread-safety.  Even objects that are otherwise "
"immutable (e.g. ``None``, ``(1, 5)``) can't normally be shared because of "
"the refcount.  One simple but less-efficient approach around this is to use "
"a global lock around all use of some state (or object). Alternately, "
"effectively immutable objects (like integers or strings) can be made safe in "
"spite of their refcounts by making them :term:`immortal`. In fact, this has "
"been done for the builtin singletons, small integers, and a number of other "
"builtin objects."
msgstr ""
"Использование изолированного переводчика требует бдительности и сохранения "
"этой изоляции. Это особенно означает, что нельзя совместно использовать "
"какие-либо объекты или изменяемое состояние без гарантий потокобезопасности. "
"Даже объекты, которые в противном случае являются неизменяемыми (например, "
"``None``, ``(1, 5)``), обычно не могут быть разделены из-за счетчика ссылок. "
"Один простой, но менее эффективный подход заключается в использовании "
"глобальной блокировки для любого использования некоторого состояния (или "
"объекта). С другой стороны, фактически неизменяемые объекты (например, целые "
"числа или строки) можно сделать безопасными, несмотря на их счетчики ссылок, "
"сделав их :term:`бессмертными`. Фактически, это было сделано для встроенных "
"одиночных объектов, малых целых чисел и ряда других встроенных объектов."

#: ../../c-api/init.rst:1910
msgid ""
"If you preserve isolation then you will have access to proper multi-core "
"computing without the complications that come with free-threading. Failure "
"to preserve isolation will expose you to the full consequences of free-"
"threading, including races and hard-to-debug crashes."
msgstr ""
"Если вы сохраните изоляцию, у вас будет доступ к полноценным многоядерным "
"вычислениям без сложностей, связанных со свободной многопоточностью. "
"Неспособность сохранить изоляцию подвергнет вас всем последствиям свободной "
"многопоточности, включая гонки и трудноотлаживаемые сбои."

#: ../../c-api/init.rst:1915
msgid ""
"Aside from that, one of the main challenges of using multiple isolated "
"interpreters is how to communicate between them safely (not break isolation) "
"and efficiently.  The runtime and stdlib do not provide any standard "
"approach to this yet.  A future stdlib module would help mitigate the effort "
"of preserving isolation and expose effective tools for communicating (and "
"sharing) data between interpreters."
msgstr ""
"Помимо этого, одна из основных проблем использования нескольких "
"изолированных переводчиков заключается в том, как безопасно и эффективно "
"общаться между ними (не нарушая изоляцию). Среда выполнения и стандартная "
"библиотека пока не предоставляют стандартного подхода к этому. Будущий "
"модуль stdlib поможет смягчить усилия по сохранению изоляции и предоставит "
"эффективные инструменты для передачи (и совместного использования) данных "
"между интерпретаторами."

#: ../../c-api/init.rst:1926
msgid "Bugs and caveats"
msgstr "Ошибки и предостережения"

#: ../../c-api/init.rst:1928
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""
"Поскольку подинтерпретаторы (и основной интерпретатор) являются частью "
"одного и того же процесса, изоляция между ними не идеальна — например, "
"используя низкоуровневые файловые операции, такие как :func:`os.close`, они "
"могут (случайно или злонамеренно) влияют на открытые файлы друг друга. Из-за "
"способа совместного использования расширений между (суб)интерпретаторами "
"некоторые расширения могут работать неправильно; это особенно вероятно при "
"использовании однофазной инициализации или (статических) глобальных "
"переменных. Можно вставлять объекты, созданные в одном субинтерпретаторе, в "
"пространство имен другого (суб)интерпретатора; этого следует избегать, если "
"это возможно."

#: ../../c-api/init.rst:1938
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's "
"dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""
"Особое внимание следует уделить тому, чтобы избежать совместного "
"использования определяемых пользователем функций, методов, экземпляров или "
"классов между субинтерпретаторами, поскольку операции импорта, выполняемые "
"такими объектами, могут повлиять на неправильный словарь (суб)интерпретатора "
"загруженных модулей. Не менее важно избегать совместного использования "
"объектов, из которых доступно вышеперечисленное."

#: ../../c-api/init.rst:1944
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states "
"and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` "
"and :c:func:`PyGILState_Release` calls. Furthermore, extensions (such "
"as :mod:`ctypes`) using these APIs to allow calling of Python code from non-"
"Python created threads will probably be broken when using sub-interpreters."
msgstr ""
"Также обратите внимание, что объединение этой функциональности с API "
"PyGILState_*`` является деликатным, поскольку эти API предполагают биекцию "
"между состояниями потоков Python и потоками уровня ОС, что нарушается "
"наличием субинтерпретаторов. Настоятельно рекомендуется не переключать "
"подинтерпретаторы между парой совпадающих "
"вызовов :c:func:`PyGILState_Ensure` и :c:func:`PyGILState_Release`. Более "
"того, расширения (такие как :mod:`ctypes`), использующие эти API для "
"разрешения вызова кода Python из потоков, созданных не на Python, вероятно, "
"будут нарушены при использовании субинтерпретаторов."

#: ../../c-api/init.rst:1955
msgid "Asynchronous Notifications"
msgstr "Асинхронные уведомления"

#: ../../c-api/init.rst:1957
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void pointer argument."
msgstr ""
"Предусмотрен механизм отправки асинхронных уведомлений в основной поток "
"интерпретатора. Эти уведомления принимают форму указателя на функцию и "
"аргумента указателя void."

#: ../../c-api/init.rst:1964
msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main "
"thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"Запланируйте вызов функции из основного потока интерпретатора. В случае "
"успеха возвращается ``0`` и *func* ставится в очередь для вызова в основном "
"потоке. В случае неудачи возвращается ``-1`` без установки каких-либо "
"исключений."

#: ../../c-api/init.rst:1968
msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"При успешной постановке в очередь *func* будет *в конечном итоге* вызвана из "
"основного потока интерпретатора с аргументом *arg*. Он будет вызываться "
"асинхронно относительно нормально работающего кода Python, но при соблюдении "
"обоих этих условий:"

#: ../../c-api/init.rst:1973
msgid "on a :term:`bytecode` boundary;"
msgstr "на :term:`bytecode` boundary;"

#: ../../c-api/init.rst:1974
msgid ""
"with the main thread holding an :term:`attached thread state` (*func* can "
"therefore use the full C API)."
msgstr ""

#: ../../c-api/init.rst:1977
msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the :term:`thread state <attached thread state>` is detached."
msgstr ""

#: ../../c-api/init.rst:1982
msgid ""
"This function doesn't need an :term:`attached thread state`. However, to "
"call this function in a subinterpreter, the caller must have "
"an :term:`attached thread state`. Otherwise, the function *func* can be "
"scheduled to be called from the wrong interpreter."
msgstr ""

#: ../../c-api/init.rst:1987
msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use "
"the :ref:`PyGILState API<gilstate>`."
msgstr ""
"Это низкоуровневая функция, полезная только в особых случаях. Нет никакой "
"гарантии, что *func* будет вызвана как можно быстрее. Если основной поток "
"занят выполнением системного вызова, *func* не будет вызываться до возврата "
"системного вызова. Эта функция обычно **не** подходит для вызова кода Python "
"из произвольных потоков C. Вместо этого используйте :ref:`PyGILState "
"API<gilstate>`."

#: ../../c-api/init.rst:1996
msgid ""
"If this function is called in a subinterpreter, the function *func* is now "
"scheduled to be called from the subinterpreter, rather than being called "
"from the main interpreter. Each subinterpreter now has its own list of "
"scheduled calls."
msgstr ""
"Если эта функция вызывается в субинтерпретаторе, функция *func* теперь "
"запланирована для вызова из субинтерпретатора, а не из основного "
"интерпретатора. У каждого субпереводчика теперь есть свой список "
"запланированных вызовов."

#: ../../c-api/init.rst:2005
msgid "Profiling and Tracing"
msgstr "Профилирование и трассировка"

#: ../../c-api/init.rst:2010
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Интерпретатор Python обеспечивает некоторую низкоуровневую поддержку для "
"подключения средств профилирования и отслеживания выполнения. Они "
"используются для инструментов профилирования, отладки и анализа покрытия."

#: ../../c-api/init.rst:2014
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"Этот интерфейс C позволяет коду профилирования или трассировки избежать "
"накладных расходов на вызов через вызываемые объекты уровня Python, вместо "
"этого выполняя прямой вызов функции C. Основные характеристики объекта не "
"изменились; интерфейс позволяет устанавливать функции трассировки для "
"каждого потока, а основные события, сообщаемые функции трассировки, такие "
"же, как и функции трассировки уровня Python в предыдущих версиях."

#: ../../c-api/init.rst:2024
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the "
"constants :c:data:`PyTrace_CALL`, :c:data:`PyTrace_EXCEPTION`, :c:data:`PyTrace_LINE`, :c:data:`PyTrace_RETURN`, :c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION`, :c:data:`PyTrace_C_RETURN`, "
"or :c:data:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:"
msgstr ""
"Тип функции трассировки, зарегистрированной с "
"помощью :c:func:`PyEval_SetProfile` и :c:func:`PyEval_SetTrace`. Первый "
"параметр — это объект, передаваемый в функцию регистрации как *obj*, *frame* "
"— объект кадра, к которому относится событие, *what* — одна из "
"констант :c:data:`PyTrace_CALL`, :c:data :`PyTrace_EXCEPTION`, :c:data:`PyTrace_LINE`, :c:data:`PyTrace_RETURN`, :c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION`, :c:data:`PyTrace_C_RETURN`, "
"или :c:data:`PyTrace_OPCODE`, а *arg* зависит от значения *what*:"

#: ../../c-api/init.rst:2033
msgid "Value of *what*"
msgstr "Value of *what*"

#: ../../c-api/init.rst:2033
msgid "Meaning of *arg*"
msgstr "Значение *arg*"

#: ../../c-api/init.rst:2035
msgid ":c:data:`PyTrace_CALL`"
msgstr ":c:data:`PyTrace_CALL`"

#: ../../c-api/init.rst:2035 ../../c-api/init.rst:2040
#: ../../c-api/init.rst:2051
msgid "Always :c:data:`Py_None`."
msgstr "Всегда :c:data:`Py_None`."

#: ../../c-api/init.rst:2037
msgid ":c:data:`PyTrace_EXCEPTION`"
msgstr ":c:data:`PyTrace_EXCEPTION`"

#: ../../c-api/init.rst:2037
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr "Информация об исключении, возвращаемая :func:`sys.exc_info`."

#: ../../c-api/init.rst:2040
msgid ":c:data:`PyTrace_LINE`"
msgstr ":c:data:`PyTrace_LINE`"

#: ../../c-api/init.rst:2042
msgid ":c:data:`PyTrace_RETURN`"
msgstr ":c:data:`PyTrace_RETURN`"

#: ../../c-api/init.rst:2042
msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr ""
"Значение, возвращаемое вызывающему объекту, или ``NULL``, если оно вызвано "
"исключением."

#: ../../c-api/init.rst:2045
msgid ":c:data:`PyTrace_C_CALL`"
msgstr ":c:data:`PyTrace_C_CALL`"

#: ../../c-api/init.rst:2045 ../../c-api/init.rst:2047
#: ../../c-api/init.rst:2049
msgid "Function object being called."
msgstr "Вызываемый функциональный объект."

#: ../../c-api/init.rst:2047
msgid ":c:data:`PyTrace_C_EXCEPTION`"
msgstr ":c:data:`PyTrace_C_EXCEPTION`"

#: ../../c-api/init.rst:2049
msgid ":c:data:`PyTrace_C_RETURN`"
msgstr ":c:data:`PyTrace_C_RETURN`"

#: ../../c-api/init.rst:2051
msgid ":c:data:`PyTrace_OPCODE`"
msgstr ":c:data:`PyTrace_OPCODE`"

#: ../../c-api/init.rst:2056
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"Значение параметра *what* функции :c:type:`Py_tracefunc`, когда сообщается о "
"новом вызове функции или метода или о новой записи в генераторе. Обратите "
"внимание, что о создании итератора для функции-генератора не сообщается, "
"поскольку в соответствующем кадре нет передачи управления байт-коду Python."

#: ../../c-api/init.rst:2065
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"Значение параметра *what* функции :c:type:`Py_tracefunc` при возникновении "
"исключения. Функция обратного вызова вызывается с этим значением для *what*, "
"когда после обработки любого байт-кода возникает исключение в исполняемом "
"кадре. Результатом этого является то, что, поскольку распространение "
"исключения приводит к раскручиванию стека Python, обратный вызов вызывается "
"при возврате к каждому кадру по мере распространения исключения. Эти события "
"получают только функции трассировки; они не нужны профилировщику."

#: ../../c-api/init.rst:2076
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by "
"setting :attr:`~frame.f_trace_lines` to *0* on that frame."
msgstr ""
"Значение передается как параметр *what* в функцию :c:type:`Py_tracefunc` (но "
"не в функцию профилирования), когда сообщается о событии с номером строки. "
"Его можно отключить для кадра, установив для :attr:`~frame.f_trace_lines` "
"значение *0* в этом кадре."

#: ../../c-api/init.rst:2084
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc`, когда вызов "
"собирается вернуться."

#: ../../c-api/init.rst:2090
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc`, когда должна "
"быть вызвана функция C."

#: ../../c-api/init.rst:2096
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc`, когда функция "
"C вызвала исключение."

#: ../../c-api/init.rst:2102
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""
"Значение параметра *what* для функции :c:type:`Py_tracefunc` при возврате "
"функции C."

#: ../../c-api/init.rst:2108
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by "
"setting :attr:`~frame.f_trace_opcodes` to *1* on the frame."
msgstr ""
"Значение параметра *what* для функций :c:type:`Py_tracefunc` (но не для "
"функций профилирования), когда новый код операции должен быть выполнен. Это "
"событие не генерируется по умолчанию: его необходимо явно запросить, "
"установив для :attr:`~frame.f_trace_opcodes` значение *1* в кадре."

#: ../../c-api/init.rst:2116
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events "
"except :c:data:`PyTrace_LINE` :c:data:`PyTrace_OPCODE` "
"and :c:data:`PyTrace_EXCEPTION`."
msgstr ""
"Установите для функции профилировщика значение *func*. Параметр *obj* "
"передается функции в качестве первого параметра и может быть любым объектом "
"Python или ``NULL``. Если функции профиля необходимо сохранять состояние, "
"использование разных значений *obj* для каждого потока обеспечивает удобное "
"и потокобезопасное место для его хранения. Функция профиля вызывается для "
"всех отслеживаемых событий, "
"кроме :c:data:`PyTrace_LINE` :c:data:`PyTrace_OPCODE` "
"и :c:data:`PyTrace_EXCEPTION`."

#: ../../c-api/init.rst:2123
msgid "See also the :func:`sys.setprofile` function."
msgstr "См. также функцию :func:`sys.setprofile`."

#: ../../c-api/init.rst:2129
msgid ""
"Like :c:func:`PyEval_SetProfile` but sets the profile function in all "
"running threads belonging to the current interpreter instead of the setting "
"it only on the current thread."
msgstr ""
"Подобно :c:func:`PyEval_SetProfile`, но устанавливает функцию профиля во "
"всех запущенных потоках, принадлежащих текущему интерпретатору, а не "
"устанавливает ее только в текущем потоке."

#: ../../c-api/init.rst:2134
msgid ""
"As :c:func:`PyEval_SetProfile`, this function ignores any exceptions raised "
"while setting the profile functions in all threads."
msgstr ""
"Как и :c:func:`PyEval_SetProfile`, эта функция игнорирует любые исключения, "
"возникающие при настройке функций профиля во всех потоках."

#: ../../c-api/init.rst:2142
msgid ""
"Set the tracing function to *func*.  This is similar "
"to :c:func:`PyEval_SetProfile`, except the tracing function does receive "
"line-number events and per-opcode events, but does not receive any event "
"related to C function objects being called.  Any trace function registered "
"using :c:func:`PyEval_SetTrace` will not "
"receive :c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION` "
"or :c:data:`PyTrace_C_RETURN` as a value for the *what* parameter."
msgstr ""
"Установите для функции трассировки значение *func*. Это похоже "
"на :c:func:`PyEval_SetProfile`, за исключением того, что функция трассировки "
"получает события номера строки и события для каждого кода операции, но не "
"получает никаких событий, связанных с вызываемыми объектами функции C. Любая "
"функция трассировки, зарегистрированная с "
"использованием :c:func:`PyEval_SetTrace`, не "
"получит :c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION` "
"или :c:data:`PyTrace_C_RETURN` в качестве значения для *what* параметр."

#: ../../c-api/init.rst:2149
msgid "See also the :func:`sys.settrace` function."
msgstr "См. также функцию :func:`sys.settrace`."

#: ../../c-api/init.rst:2155
msgid ""
"Like :c:func:`PyEval_SetTrace` but sets the tracing function in all running "
"threads belonging to the current interpreter instead of the setting it only "
"on the current thread."
msgstr ""
"Подобно :c:func:`PyEval_SetTrace`, но устанавливает функцию трассировки во "
"всех запущенных потоках, принадлежащих текущему интерпретатору, а не только "
"в текущем потоке."

#: ../../c-api/init.rst:2160
msgid ""
"As :c:func:`PyEval_SetTrace`, this function ignores any exceptions raised "
"while setting the trace functions in all threads."
msgstr ""
"Как и :c:func:`PyEval_SetTrace`, эта функция игнорирует любые исключения, "
"возникающие при установке функций трассировки во всех потоках."

#: ../../c-api/init.rst:2166
msgid "Reference tracing"
msgstr "Отслеживание ссылок"

#: ../../c-api/init.rst:2172
msgid ""
"The type of the trace function registered "
"using :c:func:`PyRefTracer_SetTracer`. The first parameter is a Python "
"object that has been just created (when **event** is set "
"to :c:data:`PyRefTracer_CREATE`) or about to be destroyed (when **event** is "
"set to :c:data:`PyRefTracer_DESTROY`). The **data** argument is the opaque "
"pointer that was provided when :c:func:`PyRefTracer_SetTracer` was called."
msgstr ""
"Тип функции трассировки, зарегистрированной с "
"помощью :c:func:`PyRefTracer_SetTracer`. Первый параметр — это объект "
"Python, который только что был создан (когда для **event** установлено "
"значение :c:data:`PyRefTracer_CREATE`) или собирается быть уничтоженным "
"(когда для **event** установлено значение :c:data). :`PyRefTracer_DESTROY`). "
"Аргумент **data** — это непрозрачный указатель, который был предоставлен при "
"вызове :c:func:`PyRefTracer_SetTracer`."

#: ../../c-api/init.rst:2182
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been created."
msgstr ""
"Значение параметра *event* для функции :c:type:`PyRefTracer` при создании "
"объекта Python."

#: ../../c-api/init.rst:2187
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been destroyed."
msgstr ""
"Значение параметра *event* для функции :c:type:`PyRefTracer`, когда объект "
"Python был уничтожен."

#: ../../c-api/init.rst:2192
msgid ""
"Register a reference tracer function. The function will be called when a new "
"Python has been created or when an object is going to be destroyed. If "
"**data** is provided it must be an opaque pointer that will be provided when "
"the tracer function is called. Return ``0`` on success. Set an exception and "
"return ``-1`` on error."
msgstr ""
"Зарегистрируйте функцию трассировки ссылок. Функция будет вызываться, когда "
"будет создан новый Python или когда объект будет уничтожен. Если указаны "
"**данные**, это должен быть непрозрачный указатель, который будет "
"предоставлен при вызове функции трассировки. Верните ``0`` в случае успеха. "
"Установите исключение и возвращайте ``-1`` в случае ошибки."

#: ../../c-api/init.rst:2198
msgid ""
"Not that tracer functions **must not** create Python objects inside or "
"otherwise the call will be re-entrant. The tracer also **must not** clear "
"any existing exception or set an exception.  A :term:`thread state` will be "
"active every time the tracer function is called."
msgstr ""

#: ../../c-api/init.rst:2203 ../../c-api/init.rst:2214
msgid ""
"There must be an :term:`attached thread state` when calling this function."
msgstr ""

#: ../../c-api/init.rst:2209
msgid ""
"Get the registered reference tracer function and the value of the opaque "
"data pointer that was registered when :c:func:`PyRefTracer_SetTracer` was "
"called. If no tracer was registered this function will return NULL and will "
"set the **data** pointer to NULL."
msgstr ""
"Получите зарегистрированную функцию трассировки ссылок и значение "
"непрозрачного указателя данных, который был зарегистрирован при "
"вызове :c:func:`PyRefTracer_SetTracer`. Если трассировщик не был "
"зарегистрирован, эта функция вернет NULL и установит указатель **data** в "
"NULL."

#: ../../c-api/init.rst:2221
msgid "Advanced Debugger Support"
msgstr "Расширенная поддержка отладчика"

#: ../../c-api/init.rst:2226
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr ""
"Эти функции предназначены только для использования расширенными "
"инструментами отладки."

#: ../../c-api/init.rst:2231
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""
"Верните объект состояния интерпретатора в начало списка всех таких объектов."

#: ../../c-api/init.rst:2236
msgid "Return the main interpreter state object."
msgstr "Верните основной объект состояния интерпретатора."

#: ../../c-api/init.rst:2241
msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr ""
"Возвращает следующий объект состояния интерпретатора после *interp* из "
"списка всех таких объектов."

#: ../../c-api/init.rst:2247
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"Верните указатель на первый объект :c:type:`PyThreadState` в списке потоков, "
"связанных с интерпретатором *interp*."

#: ../../c-api/init.rst:2253
msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"Возвращает следующий объект состояния потока после *tstate* из списка всех "
"таких объектов, принадлежащих одному и тому же "
"объекту :c:type:`PyInterpreterState`."

#: ../../c-api/init.rst:2260
msgid "Thread Local Storage Support"
msgstr "Поддержка локального хранилища потоков"

#: ../../c-api/init.rst:2264
msgid ""
"The Python interpreter provides low-level support for thread-local storage "
"(TLS) which wraps the underlying native TLS implementation to support the "
"Python-level thread local storage API (:class:`threading.local`).  The "
"CPython C level APIs are similar to those offered by pthreads and Windows: "
"use a thread key and functions to associate a :c:expr:`void*` value per "
"thread."
msgstr ""
"Интерпретатор Python обеспечивает низкоуровневую поддержку локального "
"хранилища потоков (TLS), которое оборачивает базовую собственную реализацию "
"TLS для поддержки API локального хранилища потоков уровня Python "
"(:class:`threading.local`). API-интерфейсы уровня C CPython аналогичны API-"
"интерфейсам, предлагаемым pthreads и Windows: используйте ключ потока и "
"функции для связывания значения :c:expr:`void*` с каждым потоком."

#: ../../c-api/init.rst:2271
msgid ""
"A :term:`thread state` does *not* need to be :term:`attached <attached "
"thread state>` when calling these functions; they suppl their own locking."
msgstr ""

#: ../../c-api/init.rst:2274
msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS APIs, "
"you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
"Обратите внимание, что :file:`Python.h` не включает декларацию TLS API, вам "
"необходимо включить :file:`pythread.h` для использования локального "
"хранилища потока."

#: ../../c-api/init.rst:2278
msgid ""
"None of these API functions handle memory management on behalf of "
"the :c:expr:`void*` values.  You need to allocate and deallocate them "
"yourself. If the :c:expr:`void*` values happen to be :c:expr:`PyObject*`, "
"these functions don't do refcount operations on them either."
msgstr ""
"Ни одна из этих функций API не обрабатывает управление памятью от имени "
"значений :c:expr:`void*`. Вам нужно выделить и освободить их самостоятельно. "
"Если значения :c:expr:`void*` оказались :c:expr:`PyObject*`, эти функции "
"также не выполняют над ними операции подсчета ссылок."

#: ../../c-api/init.rst:2286
msgid "Thread Specific Storage (TSS) API"
msgstr "API хранилища для конкретных потоков (TSS)"

#: ../../c-api/init.rst:2288
msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within "
"the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""
"TSS API заменяет использование существующего TLS API в интерпретаторе "
"CPython. Этот API использует новый тип :c:type:`Py_tss_t` "
"вместо :c:expr:`int` для представления ключей потока."

#: ../../c-api/init.rst:2294
msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr "«Новый C-API для локального хранилища потоков в CPython» (:pep:`539`)"

#: ../../c-api/init.rst:2299
msgid ""
"This data structure represents the state of a thread key, the definition of "
"which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no "
"public members in this structure."
msgstr ""
"Эта структура данных представляет состояние ключа потока, определение "
"которого может зависеть от базовой реализации TLS, и имеет внутреннее поле, "
"представляющее состояние инициализации ключа. В этой структуре нет публичных "
"членов."

#: ../../c-api/init.rst:2304
msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
"Если :ref:`Py_LIMITED_API <stable>` не определен, статическое выделение "
"этого типа с помощью :c:macro:`Py_tss_NEEDS_INIT` разрешено."

#: ../../c-api/init.rst:2310
msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. Note "
"that this macro won't be defined with :ref:`Py_LIMITED_API <stable>`."
msgstr ""
"Этот макрос расширяется до инициализатора переменных :c:type:`Py_tss_t`. "
"Обратите внимание, что этот макрос не будет определен с "
"помощью :ref:`Py_LIMITED_API <stable>`."

#: ../../c-api/init.rst:2315
msgid "Dynamic Allocation"
msgstr "Динамическое распределение"

#: ../../c-api/init.rst:2317
msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension modules "
"built with :ref:`Py_LIMITED_API <stable>`, where static allocation of this "
"type is not possible due to its implementation being opaque at build time."
msgstr ""
"Динамическое выделение :c:type:`Py_tss_t`, необходимое в модулях расширения, "
"созданных с помощью :ref:`Py_LIMITED_API <stable>`, где статическое "
"выделение этого типа невозможно из-за того, что его реализация непрозрачна "
"во время сборки."

#: ../../c-api/init.rst:2324
msgid ""
"Return a value which is the same state as a value initialized "
"with :c:macro:`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic "
"allocation failure."
msgstr ""
"Возвращает значение, которое находится в том же состоянии, что и значение, "
"инициализированное с помощью :c:macro:`Py_tss_NEEDS_INIT` или ``NULL`` в "
"случае сбоя динамического выделения."

#: ../../c-api/init.rst:2331
msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after first "
"calling :c:func:`PyThread_tss_delete` to ensure any associated thread locals "
"have been unassigned. This is a no-op if the *key* argument is ``NULL``."
msgstr ""
"Освободите данный *ключ*, выделенный :c:func:`PyThread_tss_alloc`, после "
"первого вызова :c:func:`PyThread_tss_delete`, чтобы убедиться, что все "
"связанные локальные переменные потока не назначены. Это пустая операция, "
"если аргумент *key* равен ``NULL``."

#: ../../c-api/init.rst:2337
msgid ""
"A freed key becomes a dangling pointer. You should reset the key to ``NULL``."
msgstr ""
"Освобожденная клавиша становится висячим указателем. Вам следует сбросить "
"ключ на ``NULL``."

#: ../../c-api/init.rst:2342
msgid "Methods"
msgstr "Методы"

#: ../../c-api/init.rst:2344
msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, the "
"behaviors of :c:func:`PyThread_tss_set` and :c:func:`PyThread_tss_get` are "
"undefined if the given :c:type:`Py_tss_t` has not been initialized "
"by :c:func:`PyThread_tss_create`."
msgstr ""
"Параметр *key* этих функций не должен иметь значение NULL. Более того, "
"поведение :c:func:`PyThread_tss_set` и :c:func:`PyThread_tss_get` не "
"определено, если данный :c:type:`Py_tss_t` не был "
"инициализирован :c:func:`PyThread_tss_create`."

#: ../../c-api/init.rst:2352
msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been initialized "
"by :c:func:`PyThread_tss_create`."
msgstr ""
"Возвращает ненулевое значение, если данный :c:type:`Py_tss_t` был "
"инициализирован :c:func:`PyThread_tss_create`."

#: ../../c-api/init.rst:2358
msgid ""
"Return a zero value on successful initialization of a TSS key.  The behavior "
"is undefined if the value pointed to by the *key* argument is not "
"initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be called "
"repeatedly on the same key -- calling it on an already initialized key is a "
"no-op and immediately returns success."
msgstr ""
"Возвращает нулевое значение при успешной инициализации ключа TSS. Поведение "
"не определено, если значение, на которое указывает аргумент *key*, не "
"инициализировано :c:macro:`Py_tss_NEEDS_INIT`. Эту функцию можно вызывать "
"повторно для одного и того же ключа — вызов ее для уже инициализированного "
"ключа является пустым и немедленно возвращает успех."

#: ../../c-api/init.rst:2367
msgid ""
"Destroy a TSS key to forget the values associated with the key across all "
"threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again "
"by :c:func:`PyThread_tss_create`. This function can be called repeatedly on "
"the same key -- calling it on an already destroyed key is a no-op."
msgstr ""
"Уничтожьте ключ TSS, чтобы забыть значения, связанные с ним во всех потоках, "
"и измените состояние инициализации ключа на неинициализированное. "
"Уничтоженный ключ можно снова инициализировать с "
"помощью :c:func:`PyThread_tss_create`. Эту функцию можно вызывать повторно "
"для одного и того же ключа — вызов ее для уже уничтоженного ключа является "
"пустым процессом."

#: ../../c-api/init.rst:2376
msgid ""
"Return a zero value to indicate successfully associating a :c:expr:`void*` "
"value with a TSS key in the current thread.  Each thread has a distinct "
"mapping of the key to a :c:expr:`void*` value."
msgstr ""
"Возвращает нулевое значение, чтобы указать успешное связывание "
"значения :c:expr:`void*` с ключом TSS в текущем потоке. Каждый поток имеет "
"отдельное сопоставление ключа со значением :c:expr:`void*`."

#: ../../c-api/init.rst:2383
msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current "
"thread.  This returns ``NULL`` if no value is associated with the key in the "
"current thread."
msgstr ""
"Возвращает значение :c:expr:`void*`, связанное с ключом TSS в текущем "
"потоке. Это возвращает NULL, если с ключом в текущем потоке не связано "
"никакое значение."

#: ../../c-api/init.rst:2391
msgid "Thread Local Storage (TLS) API"
msgstr "API локального хранилища потоков (TLS)"

#: ../../c-api/init.rst:2393
msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API <thread-"
"specific-storage-api>`."
msgstr ""
"Этот API заменяется API-интерфейсом :ref:`Thread-Specific Storage (TSS) "
"<thread-dependent-storage-api>`."

#: ../../c-api/init.rst:2398
msgid ""
"This version of the API does not support platforms where the native TLS key "
"is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""
"Эта версия API не поддерживает платформы, где собственный ключ TLS определен "
"таким образом, что его невозможно безопасно привести к int. На таких "
"платформах :c:func:`PyThread_create_key` немедленно вернется со статусом "
"сбоя, а все остальные функции TLS на таких платформах будут недоступны."

#: ../../c-api/init.rst:2403
msgid ""
"Due to the compatibility problem noted above, this version of the API should "
"not be used in new code."
msgstr ""
"Из-за отмеченной выше проблемы совместимости эту версию API не следует "
"использовать в новом коде."

#: ../../c-api/init.rst:2414
msgid "Synchronization Primitives"
msgstr "Примитивы синхронизации"

#: ../../c-api/init.rst:2416
msgid "The C-API provides a basic mutual exclusion lock."
msgstr "C-API обеспечивает базовую блокировку взаимного исключения."

#: ../../c-api/init.rst:2420
msgid ""
"A mutual exclusion lock.  The :c:type:`!PyMutex` should be initialized to "
"zero to represent the unlocked state.  For example::"
msgstr ""
"Блокировка взаимного исключения. :c:type:`!PyMutex` должен быть "
"инициализирован нулем, чтобы представлять разблокированное состояние. "
"Например::"

#: ../../c-api/init.rst:2423
msgid "PyMutex mutex = {0};"
msgstr "PyMutex mutex = {0};"

#: ../../c-api/init.rst:2425
msgid ""
"Instances of :c:type:`!PyMutex` should not be copied or moved.  Both the "
"contents and address of a :c:type:`!PyMutex` are meaningful, and it must "
"remain at a fixed, writable location in memory."
msgstr ""
"Экземпляры :c:type:`!PyMutex` не следует копировать или перемещать. И "
"содержимое, и адрес :c:type:`!PyMutex` имеют смысл, и они должны оставаться "
"в фиксированном, доступном для записи месте в памяти."

#: ../../c-api/init.rst:2431
msgid ""
"A :c:type:`!PyMutex` currently occupies one byte, but the size should be "
"considered unstable.  The size may change in future Python releases without "
"a deprecation period."
msgstr ""
"A :c:type:`!PyMutex` в настоящее время занимает один байт, но размер следует "
"считать нестабильным. Размер может измениться в будущих выпусках Python без "
"периода устаревания."

#: ../../c-api/init.rst:2439
msgid ""
"Lock mutex *m*.  If another thread has already locked it, the calling thread "
"will block until the mutex is unlocked.  While blocked, the thread will "
"temporarily detach the :term:`thread state <attached thread state>` if one "
"exists."
msgstr ""

#: ../../c-api/init.rst:2447
msgid ""
"Unlock mutex *m*. The mutex must be locked --- otherwise, the function will "
"issue a fatal error."
msgstr ""
"Разблокировать мьютекс *m*. Мьютекс должен быть заблокирован — в противном "
"случае функция выдаст фатальную ошибку."

#: ../../c-api/init.rst:2454
msgid "Returns non-zero if the mutex *m* is currently locked, zero otherwise."
msgstr ""

#: ../../c-api/init.rst:2458
msgid ""
"This function is intended for use in assertions and debugging only and "
"should not be used to make concurrency control decisions, as the lock state "
"may change immediately after the check."
msgstr ""

#: ../../c-api/init.rst:2467
msgid "Python Critical Section API"
msgstr "API критической секции Python"

#: ../../c-api/init.rst:2469
msgid ""
"The critical section API provides a deadlock avoidance layer on top of per-"
"object locks for :term:`free-threaded <free threading>` CPython.  They are "
"intended to replace reliance on the :term:`global interpreter lock`, and are "
"no-ops in versions of Python with the global interpreter lock."
msgstr ""
"API критической секции обеспечивает уровень предотвращения взаимоблокировок "
"поверх блокировок для каждого объекта для :term:`free-threaded <free "
"threading>` CPython. Они предназначены для замены "
"использования :term:`глобальной блокировки интерпретатора` и не используются "
"в версиях Python с глобальной блокировкой интерпретатора."

#: ../../c-api/init.rst:2474
msgid ""
"Critical sections are intended to be used for custom types implemented in C-"
"API extensions. They should generally not be used with built-in types "
"like :class:`list` and :class:`dict` because their public C-APIs already use "
"critical sections internally, with the notable exception "
"of :c:func:`PyDict_Next`, which requires critical section to be acquired "
"externally."
msgstr ""

#: ../../c-api/init.rst:2481
msgid ""
"Critical sections avoid deadlocks by implicitly suspending active critical "
"sections, hence, they do not provide exclusive access such as provided by "
"traditional locks like :c:type:`PyMutex`.  When a critical section is "
"started, the per-object lock for the object is acquired. If the code "
"executed inside the critical section calls C-API functions then it can "
"suspend the critical section thereby releasing the per-object lock, so other "
"threads can acquire the per-object lock for the same object."
msgstr ""

#: ../../c-api/init.rst:2489
msgid ""
"Variants that accept :c:type:`PyMutex` pointers rather than Python objects "
"are also available. Use these variants to start a critical section in a "
"situation where there is no :c:type:`PyObject` -- for example, when working "
"with a C type that does not extend or wrap :c:type:`PyObject` but still "
"needs to call into the C API in a manner that might lead to deadlocks."
msgstr ""

#: ../../c-api/init.rst:2495
msgid ""
"The functions and structs used by the macros are exposed for cases where C "
"macros are not available. They should only be used as in the given macro "
"expansions. Note that the sizes and contents of the structures may change in "
"future Python versions."
msgstr ""
"Функции и структуры, используемые макросами, доступны в тех случаях, когда "
"макросы C недоступны. Их следует использовать только так, как в данных "
"макрорасширениях. Обратите внимание, что размеры и содержимое структур могут "
"измениться в будущих версиях Python."

#: ../../c-api/init.rst:2502
msgid ""
"Operations that need to lock two objects at once must "
"use :c:macro:`Py_BEGIN_CRITICAL_SECTION2`.  You *cannot* use nested critical "
"sections to lock more than one object at once, because the inner critical "
"section may suspend the outer critical sections.  This API does not provide "
"a way to lock more than two objects at once."
msgstr ""
"Операции, которым необходимо заблокировать два объекта одновременно, должны "
"использовать :c:macro:`Py_BEGIN_CRITICAL_SECTION2`. Вы *не можете* "
"использовать вложенные критические секции для одновременной блокировки более "
"чем одного объекта, поскольку внутренняя критическая секция может "
"приостановить работу внешних критических секций. Этот API не предоставляет "
"возможности заблокировать более двух объектов одновременно."

#: ../../c-api/init.rst:2508
msgid "Example usage::"
msgstr "Пример использования::"

#: ../../c-api/init.rst:2510
msgid ""
"static PyObject *\n"
"set_field(MyObject *self, PyObject *value)\n"
"{\n"
"   Py_BEGIN_CRITICAL_SECTION(self);\n"
"   Py_SETREF(self->field, Py_XNewRef(value));\n"
"   Py_END_CRITICAL_SECTION();\n"
"   Py_RETURN_NONE;\n"
"}"
msgstr ""
"static PyObject *\n"
"set_field(MyObject *self, PyObject *value)\n"
"{\n"
"   Py_BEGIN_CRITICAL_SECTION(self);\n"
"   Py_SETREF(self->field, Py_XNewRef(value));\n"
"   Py_END_CRITICAL_SECTION();\n"
"   Py_RETURN_NONE;\n"
"}"

#: ../../c-api/init.rst:2519
msgid ""
"In the above example, :c:macro:`Py_SETREF` calls :c:macro:`Py_DECREF`, which "
"can call arbitrary code through an object's deallocation function.  The "
"critical section API avoids potential deadlocks due to reentrancy and lock "
"ordering by allowing the runtime to temporarily suspend the critical section "
"if the code triggered by the finalizer blocks and "
"calls :c:func:`PyEval_SaveThread`."
msgstr ""
"В приведенном выше примере :c:macro:`Py_SETREF` "
"вызывает :c:macro:`Py_DECREF`, который может вызывать произвольный код через "
"функцию освобождения объекта. API критической секции позволяет избежать "
"потенциальных взаимоблокировок из-за повторного входа и порядка блокировок, "
"позволяя среде выполнения временно приостанавливать критическую секцию, если "
"код, запущенный финализатором, блокируется и "
"вызывает :c:func:`PyEval_SaveThread`."

#: ../../c-api/init.rst:2527
msgid ""
"Acquires the per-object lock for the object *op* and begins a critical "
"section."
msgstr ""
"Получает блокировку для каждого объекта *op* и начинает критическую секцию."

#: ../../c-api/init.rst:2530 ../../c-api/init.rst:2544
#: ../../c-api/init.rst:2561 ../../c-api/init.rst:2576
#: ../../c-api/init.rst:2590 ../../c-api/init.rst:2607
msgid "In the free-threaded build, this macro expands to::"
msgstr "В свободнопоточной сборке этот макрос расширяется до:"

#: ../../c-api/init.rst:2532
msgid ""
"{\n"
"    PyCriticalSection _py_cs;\n"
"    PyCriticalSection_Begin(&_py_cs, (PyObject*)(op))"
msgstr ""
"{\n"
"    PyCriticalSection _py_cs;\n"
"    PyCriticalSection_Begin(&_py_cs, (PyObject*)(op))"

#: ../../c-api/init.rst:2536 ../../c-api/init.rst:2582
msgid "In the default build, this macro expands to ``{``."
msgstr "В сборке по умолчанию этот макрос расширяется до ``{``."

#: ../../c-api/init.rst:2542
msgid "Locks the mutex *m* and begins a critical section."
msgstr ""

#: ../../c-api/init.rst:2546
msgid ""
"{\n"
"     PyCriticalSection _py_cs;\n"
"     PyCriticalSection_BeginMutex(&_py_cs, m)"
msgstr ""

#: ../../c-api/init.rst:2550
msgid ""
"Note that unlike :c:macro:`Py_BEGIN_CRITICAL_SECTION`, there is no cast for "
"the argument of the macro - it must be a :c:type:`PyMutex` pointer."
msgstr ""

#: ../../c-api/init.rst:2553 ../../c-api/init.rst:2599
msgid "On the default build, this macro expands to ``{``."
msgstr ""

#: ../../c-api/init.rst:2559
msgid "Ends the critical section and releases the per-object lock."
msgstr "Завершает критическую секцию и снимает блокировку каждого объекта."

#: ../../c-api/init.rst:2563
msgid ""
"    PyCriticalSection_End(&_py_cs);\n"
"}"
msgstr ""
"    PyCriticalSection_End(&_py_cs);\n"
"}"

#: ../../c-api/init.rst:2566 ../../c-api/init.rst:2612
msgid "In the default build, this macro expands to ``}``."
msgstr "В сборке по умолчанию этот макрос расширяется до ``}``."

#: ../../c-api/init.rst:2572
msgid ""
"Acquires the per-objects locks for the objects *a* and *b* and begins a "
"critical section.  The locks are acquired in a consistent order (lowest "
"address first) to avoid lock ordering deadlocks."
msgstr ""
"Получает блокировки для объектов *a* и *b* и начинает критическую секцию. "
"Блокировки устанавливаются в последовательном порядке (сначала наименьший "
"адрес), чтобы избежать взаимоблокировок в порядке блокировок."

#: ../../c-api/init.rst:2578
msgid ""
"{\n"
"    PyCriticalSection2 _py_cs2;\n"
"    PyCriticalSection2_Begin(&_py_cs2, (PyObject*)(a), (PyObject*)(b))"
msgstr ""
"{\n"
"    PyCriticalSection2 _py_cs2;\n"
"    PyCriticalSection2_Begin(&_py_cs2, (PyObject*)(a), (PyObject*)(b))"

#: ../../c-api/init.rst:2588
msgid "Locks the mutexes *m1* and *m2* and begins a critical section."
msgstr ""

#: ../../c-api/init.rst:2592
msgid ""
"{\n"
"     PyCriticalSection2 _py_cs2;\n"
"     PyCriticalSection2_BeginMutex(&_py_cs2, m1, m2)"
msgstr ""

#: ../../c-api/init.rst:2596
msgid ""
"Note that unlike :c:macro:`Py_BEGIN_CRITICAL_SECTION2`, there is no cast for "
"the arguments of the macro - they must be :c:type:`PyMutex` pointers."
msgstr ""

#: ../../c-api/init.rst:2605
msgid "Ends the critical section and releases the per-object locks."
msgstr "Завершает критическую секцию и снимает блокировки для каждого объекта."

#: ../../c-api/init.rst:2609
msgid ""
"    PyCriticalSection2_End(&_py_cs2);\n"
"}"
msgstr ""
"    PyCriticalSection2_End(&_py_cs2);\n"
"}"

#: ../../c-api/init.rst:350
msgid "PyEval_InitThreads()"
msgstr "PyEval_InitThreads()"

#: ../../c-api/init.rst:350
msgid "modules (in module sys)"
msgstr "modules (in module sys)"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:712
msgid "path (in module sys)"
msgstr "path (в модуле sys)"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:712 ../../c-api/init.rst:1228
#: ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "module"
msgstr "модуль"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "builtins"
msgstr "встроенные"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "__main__"
msgstr "__main__"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "sys"
msgstr "sys"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:712
msgid "search"
msgstr "поиск"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:712
msgid "path"
msgstr "путь"

#: ../../c-api/init.rst:350 ../../c-api/init.rst:1820 ../../c-api/init.rst:1873
msgid "Py_FinalizeEx (C function)"
msgstr "Py_FinalizeEx (C функция)"

#: ../../c-api/init.rst:572
msgid "Py_Initialize()"
msgstr "Py_Initialize()"

#: ../../c-api/init.rst:572 ../../c-api/init.rst:810
msgid "main()"
msgstr "main()"

#: ../../c-api/init.rst:572
msgid "Py_GetPath()"
msgstr "Py_GetPath()"

#: ../../c-api/init.rst:690
msgid "executable (in module sys)"
msgstr "executable (in module sys)"

#: ../../c-api/init.rst:745 ../../c-api/init.rst:787 ../../c-api/init.rst:801
msgid "version (in module sys)"
msgstr "version (in module sys)"

#: ../../c-api/init.rst:757
msgid "platform (in module sys)"
msgstr "platform (in module sys)"

#: ../../c-api/init.rst:774
msgid "copyright (in module sys)"
msgstr "copyright (in module sys)"

#: ../../c-api/init.rst:810
msgid "Py_FatalError()"
msgstr "Py_FatalError()"

#: ../../c-api/init.rst:810
msgid "argv (in module sys)"
msgstr "argv (in module sys)"

#: ../../c-api/init.rst:930
msgid "global interpreter lock"
msgstr "глобальная блокировка интерпретатора"

#: ../../c-api/init.rst:930
msgid "interpreter lock"
msgstr "interpreter lock"

#: ../../c-api/init.rst:930
msgid "lock, interpreter"
msgstr "lock, interpreter"

#: ../../c-api/init.rst:944
msgid "setswitchinterval (in module sys)"
msgstr "setswitchinterval (in module sys)"

#: ../../c-api/init.rst:953
msgid "PyThreadState (C type)"
msgstr "PyThreadState (тип C)"

#: ../../c-api/init.rst:989
msgid "Py_BEGIN_ALLOW_THREADS (C macro)"
msgstr "Py_BEGIN_ALLOW_THREADS (C макрос)"

#: ../../c-api/init.rst:989
msgid "Py_END_ALLOW_THREADS (C macro)"
msgstr "Py_END_ALLOW_THREADS (C макрос)"

#: ../../c-api/init.rst:1005
msgid "PyEval_RestoreThread (C function)"
msgstr "PyEval_RestoreThread (C функция)"

#: ../../c-api/init.rst:1005
msgid "PyEval_SaveThread (C function)"
msgstr "PyEval_SaveThread (C функция)"

#: ../../c-api/init.rst:1206
msgid "PyEval_AcquireThread()"
msgstr "PyEval_AcquireThread()"

#: ../../c-api/init.rst:1206
msgid "PyEval_ReleaseThread()"
msgstr "PyEval_ReleaseThread()"

#: ../../c-api/init.rst:1206
msgid "PyEval_SaveThread()"
msgstr "PyEval_SaveThread()"

#: ../../c-api/init.rst:1206
msgid "PyEval_RestoreThread()"
msgstr "PyEval_RestoreThread()"

#: ../../c-api/init.rst:1228
msgid "_thread"
msgstr "_thread"

#: ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "stdout (in module sys)"
msgstr "stdout (in module sys)"

#: ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "stderr (in module sys)"
msgstr "stderr (in module sys)"

#: ../../c-api/init.rst:1756 ../../c-api/init.rst:1855
msgid "stdin (in module sys)"
msgstr "stdin (in module sys)"

#: ../../c-api/init.rst:1820
msgid "Py_Initialize (C function)"
msgstr "Py_Initialize (C функция)"

#: ../../c-api/init.rst:1850
msgid "close (in module os)"
msgstr "close (in module os)"
