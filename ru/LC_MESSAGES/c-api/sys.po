# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:09+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/sys.rst:6
msgid "Operating System Utilities"
msgstr "Утилиты операционной системы"

#: ../../c-api/sys.rst:11
msgid ""
"Return the file system representation for *path*. If the object is a :class:"
"`str` or :class:`bytes` object, then a new :term:`strong reference` is "
"returned. If the object implements the :class:`os.PathLike` interface, then :"
"meth:`~os.PathLike.__fspath__` is returned as long as it is a :class:`str` "
"or :class:`bytes` object. Otherwise :exc:`TypeError` is raised and ``NULL`` "
"is returned."
msgstr ""
"Возвращает представление файловой системы для *path*. Если объект является "
"объектом :class:`str` или :class:`bytes`, то возвращается новая :term:"
"`strong ссылка`. Если объект реализует интерфейс :class:`os.PathLike`, то :"
"meth:`~os.PathLike.__fspath__` возвращается, если это объект :class:`str` "
"или :class:`bytes`. В противном случае возникает :exc:`TypeError` и "
"возвращается ``NULL``."

#: ../../c-api/sys.rst:24
msgid ""
"Return true (nonzero) if the standard I/O file *fp* with name *filename* is "
"deemed interactive.  This is the case for files for which "
"``isatty(fileno(fp))`` is true.  If the global flag :c:data:"
"`Py_InteractiveFlag` is true, this function also returns true if the "
"*filename* pointer is ``NULL`` or if the name is equal to one of the strings "
"``'<stdin>'`` or ``'???'``."
msgstr ""

#: ../../c-api/sys.rst:33
msgid ""
"Function to prepare some internal state before a process fork.  This should "
"be called before calling :c:func:`fork` or any similar function that clones "
"the current process. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Функция для подготовки некоторого внутреннего состояния перед разветвлением "
"процесса. Ее следует вызывать перед вызовом :c:func:`fork` или любой "
"подобной функции, которая клонирует текущий процесс. Доступно только в "
"системах, где определена :c:func:`fork`."

#: ../../c-api/sys.rst:39
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_BeforeFork()``."
msgstr ""
"Вызов C :c:func:`fork` должен выполняться только из :ref:`\"main\" потока "
"<fork-and-threads>` (интерпретатора :ref:`\"main\" <sub-interpreter-support "
">`). То же самое верно и для PyOS_BeforeFork()."

#: ../../c-api/sys.rst:49
msgid ""
"Function to update some internal state after a process fork.  This should be "
"called from the parent process after calling :c:func:`fork` or any similar "
"function that clones the current process, regardless of whether process "
"cloning was successful. Only available on systems where :c:func:`fork` is "
"defined."
msgstr ""
"Функция для обновления некоторого внутреннего состояния после разветвления "
"процесса. Ее следует вызывать из родительского процесса после вызова :c:func:"
"`fork` или любой подобной функции, которая клонирует текущий процесс, "
"независимо от того, было ли клонирование процесса успешным. Доступно только "
"в системах, где определена :c:func:`fork`."

#: ../../c-api/sys.rst:56
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Parent()``."
msgstr ""
"Вызов C :c:func:`fork` должен выполняться только из :ref:`\"main\" потока "
"<fork-and-threads>` (интерпретатора :ref:`\"main\" <sub-interpreter-support "
">`). То же самое верно и для PyOS_AfterFork_Parent()."

#: ../../c-api/sys.rst:66
msgid ""
"Function to update internal interpreter state after a process fork. This "
"must be called from the child process after calling :c:func:`fork`, or any "
"similar function that clones the current process, if there is any chance the "
"process will call back into the Python interpreter. Only available on "
"systems where :c:func:`fork` is defined."
msgstr ""
"Функция для обновления внутреннего состояния интерпретатора после "
"разветвления процесса. Ее необходимо вызвать из дочернего процесса после "
"вызова :c:func:`fork` или любой подобной функции, которая клонирует текущий "
"процесс, если есть хоть какая-то вероятность, что процесс выполнит обратный "
"вызов интерпретатора Python. Доступно только в системах, где определена :c:"
"func:`fork`."

#: ../../c-api/sys.rst:73
msgid ""
"The C :c:func:`fork` call should only be made from the :ref:`\"main\" thread "
"<fork-and-threads>` (of the :ref:`\"main\" interpreter <sub-interpreter-"
"support>`).  The same is true for ``PyOS_AfterFork_Child()``."
msgstr ""
"Вызов C :c:func:`fork` должен выполняться только из :ref:`\"main\" потока "
"<fork-and-threads>` (интерпретатора :ref:`\"main\" <sub-interpreter-support "
">`). То же самое верно и для PyOS_AfterFork_Child()."

#: ../../c-api/sys.rst:81
msgid ""
":func:`os.register_at_fork` allows registering custom Python functions to be "
"called by :c:func:`PyOS_BeforeFork()`, :c:func:`PyOS_AfterFork_Parent` and  :"
"c:func:`PyOS_AfterFork_Child`."
msgstr ""
":func:`os.register_at_fork` позволяет регистрировать пользовательские "
"функции Python, которые будут вызываться :c:func:`PyOS_BeforeFork()`, :c:"
"func:`PyOS_AfterFork_Parent` и :c:func:`PyOS_AfterFork_Child`."

#: ../../c-api/sys.rst:88
msgid ""
"Function to update some internal state after a process fork; this should be "
"called in the new process if the Python interpreter will continue to be "
"used. If a new executable is loaded into the new process, this function does "
"not need to be called."
msgstr ""
"Функция для обновления некоторого внутреннего состояния после разветвления "
"процесса; это следует вызывать в новом процессе, если интерпретатор Python "
"будет продолжать использоваться. Если в новый процесс загружается новый "
"исполняемый файл, эту функцию вызывать не нужно."

#: ../../c-api/sys.rst:93
msgid "This function is superseded by :c:func:`PyOS_AfterFork_Child()`."
msgstr "Эта функция заменяется :c:func:`PyOS_AfterFork_Child()`."

#: ../../c-api/sys.rst:101
msgid ""
"Return true when the interpreter runs out of stack space.  This is a "
"reliable check, but is only available when :c:macro:`!USE_STACKCHECK` is "
"defined (currently on certain versions of Windows using the Microsoft Visual "
"C++ compiler). :c:macro:`!USE_STACKCHECK` will be defined automatically; you "
"should never change the definition in your own code."
msgstr ""
"Возвращайте true, когда интерпретатору не хватает места в стеке. Это "
"надежная проверка, но она доступна только в том случае, если определен :c:"
"macro:`!USE_STACKCHECK` (в настоящее время в некоторых версиях Windows с "
"использованием компилятора Microsoft Visual C++). :c:macro:`!USE_STACKCHECK` "
"будет определен автоматически; вам никогда не следует менять определение в "
"своем собственном коде."

#: ../../c-api/sys.rst:113
msgid ""
"Return the current signal handler for signal *i*.  This is a thin wrapper "
"around either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call those "
"functions directly!"
msgstr ""
"Верните текущий обработчик сигнала для сигнала *i*. Это тонкая оболочка "
"вокруг :c:func:`!sigaction` или :c:func:`!signal`. Не вызывайте эти функции "
"напрямую!"

#: ../../c-api/sys.rst:120
msgid ""
"Set the signal handler for signal *i* to be *h*; return the old signal "
"handler. This is a thin wrapper around either :c:func:`!sigaction` or :c:"
"func:`!signal`.  Do not call those functions directly!"
msgstr ""
"Установите обработчик сигнала *i* равным *h*; вернуть старый обработчик "
"сигнала. Это тонкая оболочка вокруг :c:func:`!sigaction` или :c:func:`!"
"signal`. Не вызывайте эти функции напрямую!"

#: ../../c-api/sys.rst:127
msgid ""
"This function should not be called directly: use the :c:type:`PyConfig` API "
"with the :c:func:`PyConfig_SetBytesString` function which ensures that :ref:"
"`Python is preinitialized <c-preinit>`."
msgstr ""
"Эту функцию не следует вызывать напрямую: используйте API :c:type:`PyConfig` "
"с функцией :c:func:`PyConfig_SetBytesString`, которая гарантирует, что :ref:"
"`Python предварительно инициализирован <c-preinit>`."

#: ../../c-api/sys.rst:131 ../../c-api/sys.rst:198
msgid ""
"This function must not be called before :ref:`Python is preinitialized <c-"
"preinit>` and so that the LC_CTYPE locale is properly configured: see the :c:"
"func:`Py_PreInitialize` function."
msgstr ""
"Эту функцию нельзя вызывать до того, как :ref:`Python будет предварительно "
"инициализирован <c-preinit>` и чтобы локаль LC_CTYPE была правильно "
"настроена: см. функцию :c:func:`Py_PreInitialize`."

#: ../../c-api/sys.rst:135
msgid ""
"Decode a byte string from the :term:`filesystem encoding and error handler`. "
"If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, undecodable bytes are decoded as characters in range "
"U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate "
"character, the bytes are escaped using the surrogateescape error handler "
"instead of decoding them."
msgstr ""
"Декодируйте строку байтов из :term:`кодирования файловой системы и "
"обработчика ошибок`. Если обработчиком ошибок является :ref:`surrogateescape "
"error handler <surrogateescape>`, недекодируемые байты декодируются как "
"символы в диапазоне U+DC80..U+DCFF; и если последовательность байтов может "
"быть декодирована как суррогатный символ, байты экранируются с "
"использованием обработчика ошибок surrogateescape вместо их декодирования."

#: ../../c-api/sys.rst:142
msgid ""
"Return a pointer to a newly allocated wide character string, use :c:func:"
"`PyMem_RawFree` to free the memory. If size is not ``NULL``, write the "
"number of wide characters excluding the null character into ``*size``"
msgstr ""
"Верните указатель на вновь выделенную строку широких символов, используйте :"
"c:func:`PyMem_RawFree`, чтобы освободить память. Если размер не ``NULL``, "
"запишите количество широких символов, исключая нулевой символ, в ``*size``."

#: ../../c-api/sys.rst:146
msgid ""
"Return ``NULL`` on decoding error or memory allocation error. If *size* is "
"not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to "
"``(size_t)-2`` on decoding error."
msgstr ""
"Возвращает NULL в случае ошибки декодирования или ошибки распределения "
"памяти. Если *size* не равно NULL, то *size устанавливается в (size_t)-1 при "
"ошибке памяти или устанавливается в (size_t)-2 при ошибке декодирования."

#: ../../c-api/sys.rst:150 ../../c-api/sys.rst:190
msgid ""
"The :term:`filesystem encoding and error handler` are selected by :c:func:"
"`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and :c:member:"
"`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`."
msgstr ""
":term:`Кодировка файловой системы и обработчик ошибок` выбираются :c:func:"
"`PyConfig_Read`: см. :c:member:`~PyConfig.filesystem_encoding` и :c:member:"
"`~PyConfig.filesystem_errors` члены : c:type:`PyConfig`."

#: ../../c-api/sys.rst:154
msgid ""
"Decoding errors should never happen, unless there is a bug in the C library."
msgstr ""
"Ошибок декодирования быть не должно, если только в библиотеке C нет ошибки."

#: ../../c-api/sys.rst:157
msgid ""
"Use the :c:func:`Py_EncodeLocale` function to encode the character string "
"back to a byte string."
msgstr ""
"Используйте функцию :c:func:`Py_EncodeLocale` для кодирования строки "
"символов обратно в строку байтов."

#: ../../c-api/sys.rst:162
msgid ""
"The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and :c:func:"
"`PyUnicode_DecodeLocaleAndSize` functions."
msgstr ""
"Функции :c:func:`PyUnicode_DecodeFSDefaultAndSize` и :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."

#: ../../c-api/sys.rst:167 ../../c-api/sys.rst:209
msgid ""
"The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode "
"<utf8-mode>`."
msgstr ""
"Функция теперь использует кодировку UTF-8 в режиме Python UTF-8 <utf8-mode>."

#: ../../c-api/sys.rst:171
msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` is zero;"
msgstr ""

#: ../../c-api/sys.rst:178
msgid ""
"Encode a wide character string to the :term:`filesystem encoding and error "
"handler`. If the error handler is :ref:`surrogateescape error handler "
"<surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are "
"converted to bytes 0x80..0xFF."
msgstr ""
"Закодируйте строку широких символов в :term:`кодировку файловой системы и "
"обработчик ошибок`. Если обработчиком ошибок является :ref:`surrogateescape "
"error handler <surrogateescape>`, замещающие символы в диапазоне U+DC80.."
"U+DCFF преобразуются в байты 0x80..0xFF."

#: ../../c-api/sys.rst:183
msgid ""
"Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free` "
"to free the memory. Return ``NULL`` on encoding error or memory allocation "
"error."
msgstr ""
"Верните указатель на вновь выделенную строку байтов, используйте :c:func:"
"`PyMem_Free`, чтобы освободить память. Возвращает ``NULL`` при ошибке "
"кодирования или ошибке выделения памяти."

#: ../../c-api/sys.rst:187
msgid ""
"If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on "
"success,  or set to the index of the invalid character on encoding error."
msgstr ""
"Если error_pos не равен NULL, то error_pos устанавливается в (size_t)-1 в "
"случае успеха или устанавливается в индекс недопустимого символа в случае "
"ошибки кодирования."

#: ../../c-api/sys.rst:194
msgid ""
"Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back "
"to a wide character string."
msgstr ""
"Используйте функцию :c:func:`Py_DecodeLocale` для декодирования строки "
"байтов обратно в строку широких символов."

#: ../../c-api/sys.rst:204
msgid ""
"The :c:func:`PyUnicode_EncodeFSDefault` and :c:func:`PyUnicode_EncodeLocale` "
"functions."
msgstr ""
"Функции :c:func:`PyUnicode_EncodeFSDefault` и :c:func:"
"`PyUnicode_EncodeLocale`."

#: ../../c-api/sys.rst:213
msgid ""
"The function now uses the UTF-8 encoding on Windows if :c:data:"
"`Py_LegacyWindowsFSEncodingFlag` is zero."
msgstr ""

#: ../../c-api/sys.rst:221
msgid "System Functions"
msgstr "Системные функции"

#: ../../c-api/sys.rst:223
msgid ""
"These are utility functions that make functionality from the :mod:`sys` "
"module accessible to C code.  They all work with the current interpreter "
"thread's :mod:`sys` module's dict, which is contained in the internal thread "
"state structure."
msgstr ""
"Это служебные функции, которые делают функциональность модуля :mod:`sys` "
"доступной для кода C. Все они работают с dict модуля :mod:`sys` текущего "
"потока интерпретатора, который содержится во внутренней структуре состояния "
"потока."

#: ../../c-api/sys.rst:229
msgid ""
"Return the object *name* from the :mod:`sys` module or ``NULL`` if it does "
"not exist, without setting an exception."
msgstr ""
"Верните объект *name* из модуля :mod:`sys` или ``NULL``, если он не "
"существует, без установки исключения."

#: ../../c-api/sys.rst:234
msgid ""
"Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which "
"case *name* is deleted from the sys module. Returns ``0`` on success, ``-1`` "
"on error."
msgstr ""
"Установите для *name* в модуле :mod:`sys` значение *v*, если только *v* не "
"равно ``NULL``, в этом случае *name* удаляется из модуля sys. Возвращает "
"``0`` в случае успеха, ``-1`` в случае ошибки."

#: ../../c-api/sys.rst:240
msgid ""
"Reset :data:`sys.warnoptions` to an empty list. This function may be called "
"prior to :c:func:`Py_Initialize`."
msgstr ""
"Сбросьте :data:`sys.warnoptions` до пустого списка. Эту функцию можно "
"вызвать до :c:func:`Py_Initialize`."

#: ../../c-api/sys.rst:245 ../../c-api/sys.rst:256
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"warnoptions` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.warnoptions`, см. :ref:"
"`Конфигурация инициализации Python <init-config>`."

#: ../../c-api/sys.rst:249
msgid ""
"Append *s* to :data:`sys.warnoptions`. This function must be called prior "
"to :c:func:`Py_Initialize` in order to affect the warnings filter list."
msgstr ""
"Добавьте *s* к :data:`sys.warnoptions`. Эта функция должна быть вызвана до :"
"c:func:`Py_Initialize`, чтобы повлиять на список фильтров предупреждений."

#: ../../c-api/sys.rst:260
msgid "Append *unicode* to :data:`sys.warnoptions`."
msgstr "Добавьте *unicode* в :data:`sys.warnoptions`."

#: ../../c-api/sys.rst:262
msgid ""
"Note: this function is not currently usable from outside the CPython "
"implementation, as it must be called prior to the implicit import of :mod:"
"`warnings` in :c:func:`Py_Initialize` to be effective, but can't be called "
"until enough of the runtime has been initialized to permit the creation of "
"Unicode objects."
msgstr ""
"Примечание. Эту функцию в настоящее время нельзя использовать вне реализации "
"CPython, поскольку для ее эффективности ее необходимо вызвать до неявного "
"импорта :mod:`warnings` в :c:func:`Py_Initialize`, но ее нельзя вызвать. до "
"тех пор, пока не будет инициализировано достаточно времени выполнения, чтобы "
"разрешить создание объектов Unicode."

#: ../../c-api/sys.rst:272
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"module_search_paths` and :c:member:`PyConfig.module_search_paths_set` should "
"be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройки :c:member:`PyConfig.module_search_paths` и :c:member:"
"`PyConfig.module_search_paths_set`, см. :ref:`Конфигурация инициализации "
"Python <init-config>`."

#: ../../c-api/sys.rst:277
msgid ""
"Set :data:`sys.path` to a list object of paths found in *path* which should "
"be a list of paths separated with the platform's search path delimiter (``:"
"`` on Unix, ``;`` on Windows)."
msgstr ""
"Установите :data:`sys.path` в объект списка путей, найденных в *path*, "
"который должен представлять собой список путей, разделенных разделителем "
"пути поиска платформы (``:`` в Unix, ``;`` в Windows )."

#: ../../c-api/sys.rst:285
msgid ""
"Write the output string described by *format* to :data:`sys.stdout`.  No "
"exceptions are raised, even if truncation occurs (see below)."
msgstr ""
"Запишите выходную строку, описанную *format*, в :data:`sys.stdout`. "
"Исключения не создаются, даже если происходит усечение (см. ниже)."

#: ../../c-api/sys.rst:288
msgid ""
"*format* should limit the total size of the formatted output string to 1000 "
"bytes or less -- after 1000 bytes, the output string is truncated. In "
"particular, this means that no unrestricted \"%s\" formats should occur; "
"these should be limited using \"%.<N>s\" where <N> is a decimal number "
"calculated so that <N> plus the maximum size of other formatted text does "
"not exceed 1000 bytes.  Also watch out for \"%f\", which can print hundreds "
"of digits for very large numbers."
msgstr ""
"*format* должен ограничивать общий размер форматированной выходной строки до "
"1000 байт или меньше — после 1000 байт выходная строка усекается. В "
"частности, это означает, что никаких неограниченных \" %s \" должны "
"встречаться форматы; они должны быть ограничены с помощью \"%.<N>s\", где "
"<N> — десятичное число, рассчитанное таким образом, чтобы <N> плюс "
"максимальный размер другого форматированного текста не превышал 1000 байт. "
"Также следите за \" %f \", который может печатать сотни цифр для очень "
"больших чисел."

#: ../../c-api/sys.rst:296
msgid ""
"If a problem occurs, or :data:`sys.stdout` is unset, the formatted message "
"is written to the real (C level) *stdout*."
msgstr ""
"Если возникает проблема или :data:`sys.stdout` не установлен, "
"форматированное сообщение записывается в реальный (уровень C) *stdout*."

#: ../../c-api/sys.rst:301
msgid ""
"As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Как :c:func:`PySys_WriteStdout`, но вместо этого записывайте в :data:`sys."
"stderr` или *stderr*."

#: ../../c-api/sys.rst:306
msgid ""
"Function similar to PySys_WriteStdout() but format the message using :c:func:"
"`PyUnicode_FromFormatV` and don't truncate the message to an arbitrary "
"length."
msgstr ""
"Функция аналогична PySys_WriteStdout(), но форматирует сообщение с помощью :"
"c:func:`PyUnicode_FromFormatV` и не усекает сообщение до произвольной длины."

#: ../../c-api/sys.rst:314
msgid ""
"As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr* "
"instead."
msgstr ""
"Как :c:func:`PySys_FormatStdout`, но вместо этого записывайте в :data:`sys."
"stderr` или *stderr*."

#: ../../c-api/sys.rst:321
msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"xoptions` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""
"Этот API сохранен для обратной совместимости: вместо него следует "
"использовать настройку :c:member:`PyConfig.xoptions`, см. :ref:`Конфигурация "
"инициализации Python <init-config>`."

#: ../../c-api/sys.rst:325
msgid ""
"Parse *s* as a set of :option:`-X` options and add them to the current "
"options mapping as returned by :c:func:`PySys_GetXOptions`. This function "
"may be called prior to :c:func:`Py_Initialize`."
msgstr ""
"Разберите *s* как набор опций :option:`-X` и добавьте их в текущее "
"сопоставление опций, возвращаемое :c:func:`PySys_GetXOptions`. Эту функцию "
"можно вызвать до :c:func:`Py_Initialize`."

#: ../../c-api/sys.rst:335
msgid ""
"Return the current dictionary of :option:`-X` options, similarly to :data:"
"`sys._xoptions`.  On error, ``NULL`` is returned and an exception is set."
msgstr ""
"Возвращает текущий словарь опций :option:`-X` аналогично :data:`sys."
"_xoptions`. В случае ошибки возвращается NULL и устанавливается исключение."

#: ../../c-api/sys.rst:344
msgid ""
"Raise an auditing event with any active hooks. Return zero for success and "
"non-zero with an exception set on failure."
msgstr ""
"Вызовите событие аудита с любыми активными перехватчиками. Возвращайте ноль "
"в случае успеха и ненулевое значение с исключением, установленным в случае "
"неудачи."

#: ../../c-api/sys.rst:347
msgid ""
"If any hooks have been added, *format* and other arguments will be used to "
"construct a tuple to pass. Apart from ``N``, the same format characters as "
"used in :c:func:`Py_BuildValue` are available. If the built value is not a "
"tuple, it will be added into a single-element tuple. (The ``N`` format "
"option consumes a reference, but since there is no way to know whether "
"arguments to this function will be consumed, using it may cause reference "
"leaks.)"
msgstr ""
"Если были добавлены какие-либо перехватчики, *format* и другие аргументы "
"будут использоваться для создания кортежа для передачи. Помимо ``N``, "
"доступны те же символы формата, что и в :c:func:`Py_BuildValue`. Если "
"построенное значение не является кортежем, оно будет добавлено в "
"одноэлементный кортеж. (Опция формата ``N`` использует ссылку, но поскольку "
"невозможно узнать, будут ли использованы аргументы этой функции, ее "
"использование может привести к утечке ссылок.)"

#: ../../c-api/sys.rst:355
msgid ""
"Note that ``#`` format characters should always be treated as :c:type:"
"`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was defined."
msgstr ""
"Обратите внимание, что символы формата ``#`` всегда следует интерпретировать "
"как :c:type:`Py_ssize_t`, независимо от того, был ли определен "
"``PY_SSIZE_T_CLEAN``."

#: ../../c-api/sys.rst:358
msgid ":func:`sys.audit` performs the same function from Python code."
msgstr ":func:`sys.audit` выполняет ту же функцию из кода Python."

#: ../../c-api/sys.rst:364
msgid ""
"Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an "
"unavoidable deprecation warning was raised."
msgstr ""
"Требуется :c:type:`Py_ssize_t` для символов формата ``#``. Ранее было выдано "
"неизбежное предупреждение об устаревании."

#: ../../c-api/sys.rst:370
msgid ""
"Append the callable *hook* to the list of active auditing hooks. Return zero "
"on success and non-zero on failure. If the runtime has been initialized, "
"also set an error on failure. Hooks added through this API are called for "
"all interpreters created by the runtime."
msgstr ""
"Добавьте вызываемый *крючок* в список активных перехватчиков аудита. "
"Возвращает ноль в случае успеха и ненулевое значение в случае неудачи. Если "
"среда выполнения была инициализирована, также установите ошибку при сбое. "
"Хуки, добавленные через этот API, вызываются для всех интерпретаторов, "
"созданных средой выполнения."

#: ../../c-api/sys.rst:376
msgid ""
"The *userData* pointer is passed into the hook function. Since hook "
"functions may be called from different runtimes, this pointer should not "
"refer directly to Python state."
msgstr ""
"В функцию перехвата передается указатель *userData*. Поскольку функции "
"перехвата могут вызываться из разных сред выполнения, этот указатель не "
"должен напрямую ссылаться на состояние Python."

#: ../../c-api/sys.rst:380
msgid ""
"This function is safe to call before :c:func:`Py_Initialize`. When called "
"after runtime initialization, existing audit hooks are notified and may "
"silently abort the operation by raising an error subclassed from :class:"
"`Exception` (other errors will not be silenced)."
msgstr ""
"Эту функцию можно безопасно вызывать до :c:func:`Py_Initialize`. При вызове "
"после инициализации среды выполнения существующие перехватчики аудита "
"уведомляются и могут молча прервать операцию, вызвав ошибку, унаследованную "
"от :class:`Exception` (другие ошибки не будут отключены)."

#: ../../c-api/sys.rst:385
msgid ""
"The hook function is always called with the GIL held by the Python "
"interpreter that raised the event."
msgstr ""
"Функция-перехватчик всегда вызывается с GIL, хранящимся в интерпретаторе "
"Python, вызвавшем событие."

#: ../../c-api/sys.rst:388
msgid ""
"See :pep:`578` for a detailed description of auditing.  Functions in the "
"runtime and standard library that raise events are listed in the :ref:`audit "
"events table <audit-events>`. Details are in each function's documentation."
msgstr ""
"См. :pep:`578` для подробного описания одитинга. Функции среды выполнения и "
"стандартной библиотеки, вызывающие события, перечислены в таблице событий "
"аудита <audit-events>`. Подробности находятся в документации каждой функции."

#: ../../c-api/sys.rst:395
msgid ""
"If the interpreter is initialized, this function raises an auditing event "
"``sys.addaudithook`` with no arguments. If any existing hooks raise an "
"exception derived from :class:`Exception`, the new hook will not be added "
"and the exception is cleared. As a result, callers cannot assume that their "
"hook has been added unless they control all existing hooks."
msgstr ""
"Если интерпретатор инициализирован, эта функция вызывает событие аудита "
"``sys.addaudithook`` без аргументов. Если какие-либо существующие "
"перехватчики вызывают исключение, полученное из :class:`Exception`, новый "
"перехватчик не будет добавлен, а исключение будет очищено. В результате "
"вызывающие программы не могут предположить, что их перехват был добавлен, "
"если они не контролируют все существующие перехватчики."

#: ../../c-api/sys.rst:404
msgid ""
"The type of the hook function. *event* is the C string event argument passed "
"to :c:func:`PySys_Audit`. *args* is guaranteed to be a :c:type:"
"`PyTupleObject`. *userData* is the argument passed to PySys_AddAuditHook()."
msgstr ""
"Тип функции-перехватчика. *event* — это аргумент события строки C, "
"передаваемый в :c:func:`PySys_Audit`. *args* гарантированно будет :c:type:"
"`PyTupleObject`. *userData* — это аргумент, передаваемый в "
"PySys_AddAuditHook()."

#: ../../c-api/sys.rst:415
msgid "Process Control"
msgstr "Управление процессом"

#: ../../c-api/sys.rst:422
msgid ""
"Print a fatal error message and kill the process.  No cleanup is performed. "
"This function should only be invoked when a condition is detected that would "
"make it dangerous to continue using the Python interpreter; e.g., when the "
"object administration appears to be corrupted.  On Unix, the standard C "
"library function :c:func:`!abort` is called which will attempt to produce a :"
"file:`core` file."
msgstr ""
"Выведите сообщение о фатальной ошибке и завершите процесс. Очистка не "
"производится. Эту функцию следует вызывать только при обнаружении условия, "
"при котором дальнейшее использование интерпретатора Python может быть "
"опасным; например, когда администрация объекта кажется поврежденной. В Unix "
"вызывается стандартная библиотечная функция C :c:func:`!abort`, которая "
"пытается создать файл :file:`core`."

#: ../../c-api/sys.rst:429
msgid ""
"The ``Py_FatalError()`` function is replaced with a macro which logs "
"automatically the name of the current function, unless the "
"``Py_LIMITED_API`` macro is defined."
msgstr ""
"Функция Py_FatalError() заменяется макросом, который автоматически "
"записывает имя текущей функции, если не определен макрос Py_LIMITED_API."

#: ../../c-api/sys.rst:433
msgid "Log the function name automatically."
msgstr "Зарегистрируйте имя функции автоматически."

#: ../../c-api/sys.rst:443
msgid ""
"Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls "
"the standard C library function ``exit(status)``.  If :c:func:"
"`Py_FinalizeEx` indicates an error, the exit status is set to 120."
msgstr ""
"Выйти из текущего процесса. Это вызывает :c:func:`Py_FinalizeEx`, а затем "
"вызывает стандартную функцию библиотеки C ``exit(status)``. Если :c:func:"
"`Py_FinalizeEx` указывает на ошибку, статус выхода устанавливается на 120."

#: ../../c-api/sys.rst:447
msgid "Errors from finalization no longer ignored."
msgstr "Ошибки финализации больше не игнорируются."

#: ../../c-api/sys.rst:457
msgid ""
"Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The "
"cleanup function will be called with no arguments and should return no "
"value.  At most 32 cleanup functions can be registered.  When the "
"registration is successful, :c:func:`Py_AtExit` returns ``0``; on failure, "
"it returns ``-1``.  The cleanup function registered last is called first. "
"Each cleanup function will be called at most once.  Since Python's internal "
"finalization will have completed before the cleanup function, no Python APIs "
"should be called by *func*."
msgstr ""
"Зарегистрируйте функцию очистки, которая будет вызываться :c:func:"
"`Py_FinalizeEx`. Функция очистки будет вызываться без аргументов и не должна "
"возвращать никакого значения. Можно зарегистрировать максимум 32 функции "
"очистки. Если регистрация прошла успешно, :c:func:`Py_AtExit` возвращает "
"``0``; в случае неудачи возвращается ``-1``. Функция очистки, "
"зарегистрированная последней, вызывается первой. Каждая функция очистки "
"будет вызываться не более одного раза. Поскольку внутренняя финализация "
"Python завершится до выполнения функции очистки, никакие API-интерфейсы "
"Python не должны вызываться с помощью *func*."

#: ../../c-api/sys.rst:99
msgid "USE_STACKCHECK (C macro)"
msgstr "USE_STACKCHECK (C макрос)"

#: ../../c-api/sys.rst:420
msgid "abort (C function)"
msgstr "прервать (C функция)"

#: ../../c-api/sys.rst:439 ../../c-api/sys.rst:453
msgid "Py_FinalizeEx (C function)"
msgstr "Py_FinalizeEx (C функция)"

#: ../../c-api/sys.rst:439
msgid "exit (C function)"
msgstr "выход (C функция)"

#: ../../c-api/sys.rst:453
msgid "cleanup functions"
msgstr "функции очистки"
