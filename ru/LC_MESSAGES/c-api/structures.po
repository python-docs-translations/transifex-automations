# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:33+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Общие структуры объектов"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Существует большое количество структур, которые используются при определении "
"типов объектов в Python. В этом разделе описываются эти структуры и способы "
"их использования."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Базовые типы объектов и макросы"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"Все объекты Python в конечном итоге совместно используют небольшое "
"количество полей в начале представления объекта в памяти. Они представлены "
"типами :c:type:`PyObject` и :c:type:`PyVarObject`, которые, в свою очередь, "
"определяются расширениями некоторых макросов, которые также используются, "
"прямо или косвенно, при определении всех другие объекты Python. "
"Дополнительные макросы можно найти в разделе :ref:`reference counting "
"<countingrefs>`."

#: ../../c-api/structures.rst:26
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`."
msgstr ""

#: ../../c-api/structures.rst:33
msgid ""
"The members must not be accessed directly; instead use macros such as :c:"
"macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""

#: ../../c-api/structures.rst:38
msgid ""
"The object's reference count, as returned by :c:macro:`Py_REFCNT`. Do not "
"use this field directly; instead use functions and macros such as :c:macro:`!"
"Py_REFCNT`, :c:func:`Py_INCREF` and :c:func:`Py_DecRef`."
msgstr ""

#: ../../c-api/structures.rst:42
msgid ""
"The field type may be different from ``Py_ssize_t``, depending on build "
"configuration and platform."
msgstr ""

#: ../../c-api/structures.rst:47
msgid ""
"The object's type. Do not use this field directly; use :c:macro:`Py_TYPE` "
"and :c:func:`Py_SET_TYPE` instead."
msgstr ""

#: ../../c-api/structures.rst:54
msgid ""
"An extension of :c:type:`PyObject` that adds the :c:member:`~PyVarObject."
"ob_size` field. This is intended for objects that have some notion of "
"*length*."
msgstr ""

#: ../../c-api/structures.rst:58
msgid ""
"As with :c:type:`!PyObject`, the members must not be accessed directly; "
"instead use macros such as :c:macro:`Py_SIZE`, :c:macro:`Py_REFCNT` and :c:"
"macro:`Py_TYPE`."
msgstr ""

#: ../../c-api/structures.rst:64
msgid ""
"A size field, whose contents should be considered an object's internal "
"implementation detail."
msgstr ""

#: ../../c-api/structures.rst:67
msgid "Do not use this field directly; use :c:macro:`Py_SIZE` instead."
msgstr ""

#: ../../c-api/structures.rst:69
msgid ""
"Object creation functions such as :c:func:`PyObject_NewVar` will generally "
"set this field to the requested size (number of items). After creation, "
"arbitrary values can be stored in :c:member:`!ob_size` using :c:macro:"
"`Py_SET_SIZE`."
msgstr ""

#: ../../c-api/structures.rst:74
msgid ""
"To get an object's publicly exposed length, as returned by the Python "
"function :py:func:`len`, use :c:func:`PyObject_Length` instead."
msgstr ""

#: ../../c-api/structures.rst:81
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Это макрос, используемый при объявлении новых типов, представляющих объекты "
"без меняющейся длины. Макрос PyObject_HEAD расширяется до::"

#: ../../c-api/structures.rst:84
msgid "PyObject ob_base;"
msgstr "PyObject ob_base;"

#: ../../c-api/structures.rst:86
msgid "See documentation of :c:type:`PyObject` above."
msgstr "См. документацию :c:type:`PyObject` выше."

#: ../../c-api/structures.rst:91
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Это макрос, используемый при объявлении новых типов, которые представляют "
"объекты, длина которых варьируется от экземпляра к экземпляру. Макрос "
"PyObject_VAR_HEAD расширяется до::"

#: ../../c-api/structures.rst:95
msgid "PyVarObject ob_base;"
msgstr "PyVarObject ob_base;"

#: ../../c-api/structures.rst:97
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "См. документацию :c:type:`PyVarObject` выше."

#: ../../c-api/structures.rst:102
msgid ""
"The base class of all other objects, the same as :class:`object` in Python."
msgstr ""
"Базовый класс всех остальных объектов, такой же, как :class:`object` в "
"Python."

#: ../../c-api/structures.rst:107
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Проверьте, является ли объект *x* объектом *y*, так же, как ``x is y`` в "
"Python."

#: ../../c-api/structures.rst:114
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Проверьте, является ли объект синглтоном None, так же, как x is None в "
"Python."

#: ../../c-api/structures.rst:122
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Проверьте, является ли объект синглтоном ``True``, так же, как ``x is True`` "
"в Python."

#: ../../c-api/structures.rst:130
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Проверьте, является ли объект синглтоном ``False``, так же, как ``x is "
"False`` в Python."

#: ../../c-api/structures.rst:138
msgid "Get the type of the Python object *o*."
msgstr "Получите тип объекта Python *o*."

#: ../../c-api/structures.rst:140
msgid ""
"The returned reference is :term:`borrowed <borrowed reference>` from *o*. Do "
"not release it with :c:func:`Py_DECREF` or similar."
msgstr ""

#: ../../c-api/structures.rst:143
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` заменена на встроенную статическую функцию. Тип "
"параметра больше не :c:expr:`const PyObject*`."

#: ../../c-api/structures.rst:150
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Возвращает ненулевое значение, если тип объекта *o* равен *type*. В "
"противном случае верните ноль. Эквивалент: ``Py_TYPE(o) == type``."

#: ../../c-api/structures.rst:158
msgid ""
"Set the type of object *o* to *type*, without any checking or reference "
"counting."
msgstr ""

#: ../../c-api/structures.rst:161
msgid ""
"This is a very low-level operation. Consider instead setting the Python "
"attribute :attr:`~object.__class__` using :c:func:`PyObject_SetAttrString` "
"or similar."
msgstr ""

#: ../../c-api/structures.rst:165
msgid ""
"Note that assigning an incompatible type can lead to undefined behavior."
msgstr ""

#: ../../c-api/structures.rst:167
msgid ""
"If *type* is a :ref:`heap type <heap-types>`, the caller must create a new "
"reference to it. Similarly, if the old type of *o* is a heap type, the "
"caller must release a reference to that type."
msgstr ""

#: ../../c-api/structures.rst:177
msgid "Get the :c:member:`~PyVarObject.ob_size` field of *o*."
msgstr ""

#: ../../c-api/structures.rst:179
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` заменена на встроенную статическую функцию. Тип "
"параметра больше не :c:expr:`const PyVarObject*`."

#: ../../c-api/structures.rst:186
msgid "Set the :c:member:`~PyVarObject.ob_size` field of *o* to *size*."
msgstr ""

#: ../../c-api/structures.rst:193
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Это макрос, который расширяется до значений инициализации для нового типа :c:"
"type:`PyObject`. Этот макрос расширяется до::"

#: ../../c-api/structures.rst:196
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type,"

#: ../../c-api/structures.rst:202
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field. "
"This macro expands to::"
msgstr ""
"Это макрос, который расширяется до значений инициализации для нового типа :c:"
"type:`PyVarObject`, включая поле :c:member:`~PyVarObject.ob_size`. Этот "
"макрос расширяется до::"

#: ../../c-api/structures.rst:206
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"

#: ../../c-api/structures.rst:211
msgid "Implementing functions and methods"
msgstr "Реализация функций и методов"

#: ../../c-api/structures.rst:215
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Тип функций, используемых для реализации большинства вызываемых объектов "
"Python в C. Функции этого типа принимают два параметра :c:expr:`PyObject*` и "
"возвращают одно такое значение. Если возвращаемое значение равно NULL, "
"должно быть установлено исключение. Если значение не ``NULL``, возвращаемое "
"значение интерпретируется как возвращаемое значение функции, представленное "
"в Python. Функция должна вернуть новую ссылку."

#: ../../c-api/structures.rst:222
msgid "The function signature is::"
msgstr "Сигнатура функции::"

#: ../../c-api/structures.rst:224
msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"

#: ../../c-api/structures.rst:229
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Тип функций, используемых для реализации вызовов Python в C с сигнатурой :"
"ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. Сигнатура "
"функции:"

#: ../../c-api/structures.rst:233
msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"

#: ../../c-api/structures.rst:240
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Тип функций, используемых для реализации вызовов Python в C с сигнатурой :c:"
"macro:`METH_FASTCALL`. Сигнатура функции:"

#: ../../c-api/structures.rst:244
msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"

#: ../../c-api/structures.rst:250
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Тип функций, используемых для реализации вызовов Python в C с сигнатурой :"
"ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>`. Сигнатура "
"функции:"

#: ../../c-api/structures.rst:254
msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"

#: ../../c-api/structures.rst:261
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Тип функций, используемых для реализации вызовов Python в C с сигнатурой :"
"ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`. Сигнатура функции:"

#: ../../c-api/structures.rst:265
msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"

#: ../../c-api/structures.rst:276
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Структура, используемая для описания метода типа расширения. Эта структура "
"имеет четыре поля:"

#: ../../c-api/structures.rst:281
msgid "Name of the method."
msgstr "Название метода."

#: ../../c-api/structures.rst:285
msgid "Pointer to the C implementation."
msgstr "Указатель на реализацию C."

#: ../../c-api/structures.rst:289
msgid "Flags bits indicating how the call should be constructed."
msgstr "Биты флагов, указывающие, как должен быть построен вызов."

#: ../../c-api/structures.rst:293
msgid "Points to the contents of the docstring."
msgstr "Указывает на содержимое строки документации."

#: ../../c-api/structures.rst:295
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":c:member:`~PyMethodDef.ml_meth` — это указатель на функцию C. Функции могут "
"быть разных типов, но они всегда возвращают :c:expr:`PyObject*`. Если "
"функция не относится к типу :c:type:`PyCFunction`, компилятор потребует "
"приведение в таблице методов. Несмотря на то, что :c:type:`PyCFunction` "
"определяет первый параметр как :c:expr:`PyObject*`, обычно реализация метода "
"использует конкретный тип C объекта *self*."

#: ../../c-api/structures.rst:303
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"Поле :c:member:`~PyMethodDef.ml_flags` представляет собой битовое поле, "
"которое может включать следующие флаги. Отдельные флаги указывают либо "
"соглашение о вызовах, либо соглашение о привязке."

#: ../../c-api/structures.rst:308
msgid "There are these calling conventions:"
msgstr "Существуют следующие соглашения о вызовах:"

#: ../../c-api/structures.rst:312
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Это типичное соглашение о вызовах, где методы имеют тип :c:type:"
"`PyCFunction`. Функция ожидает два значения :c:expr:`PyObject*`. Первый — "
"это объект *self* для методов; для функций модуля это объект модуля. Второй "
"параметр (часто называемый *args*) представляет собой объект-кортеж, "
"представляющий все аргументы. Этот параметр обычно обрабатывается с помощью :"
"c:func:`PyArg_ParseTuple` или :c:func:`PyArg_UnpackTuple`."

#: ../../c-api/structures.rst:322
msgid ""
"Can only be used in certain combinations with other flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""
"Может использоваться только в определенных комбинациях с другими флагами: :"
"ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` и :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

#: ../../c-api/structures.rst:330
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

#: ../../c-api/structures.rst:331
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Методы с этими флагами должны иметь тип :c:type:`PyCFunctionWithKeywords`. "
"Функция ожидает три параметра: *self*, *args*, *kwargs*, где *kwargs* — "
"словарь всех аргументов ключевых слов или, возможно, ``NULL``, если "
"аргументов ключевых слов нет. Параметры обычно обрабатываются с помощью :c:"
"func:`PyArg_ParseTupleAndKeywords`."

#: ../../c-api/structures.rst:340
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Соглашение о быстрых вызовах, поддерживающее только позиционные аргументы. "
"Методы имеют тип :c:type:`PyCFunctionFast`. Первый параметр — *self*, второй "
"параметр — это массив C значений :c:expr:`PyObject*`, указывающий аргументы, "
"а третий параметр — это количество аргументов (длина массива)."

#: ../../c-api/structures.rst:350
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr ""
"``METH_FASTCALL`` теперь является частью :ref:`stable ABI <stable-abi>`."

#: ../../c-api/structures.rst:355
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:356
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Расширение :c:macro:`METH_FASTCALL`, поддерживающее также аргументы ключевых "
"слов, с методами типа :c:type:`PyCFunctionFastWithKeywords`. Аргументы "
"ключевых слов передаются так же, как и в протоколе :ref:`vectorcall "
"<vectorcall>`: есть дополнительный четвертый параметр :c:expr:`PyObject*`, "
"который представляет собой кортеж, представляющий имена аргументов ключевых "
"слов (которые гарантированно будут строками) или, возможно, ``NULL``, если "
"ключевые слова отсутствуют. Значения аргументов ключевого слова сохраняются "
"в массиве *args* после позиционных аргументов."

#: ../../c-api/structures.rst:371
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"Может использоваться только в сочетании с другими флагами: :ref:`METH_METHOD "
"| METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."

#: ../../c-api/structures.rst:377
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:378
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Расширение :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` поддерживающий *определяющий класс*, то есть класс, "
"содержащий рассматриваемый метод. Определяющий класс может быть суперклассом "
"``Py_TYPE(self)``."

#: ../../c-api/structures.rst:383
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"Метод должен иметь тип :c:type:`PyCMethod`, такой же, как для "
"``METH_FASTCALL | METH_KEYWORDS`` с аргументом ``defining_class``, "
"добавленным после ``self``."

#: ../../c-api/structures.rst:392
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Методам без параметров не нужно проверять, переданы ли аргументы, если они "
"указаны с флагом :c:macro:`METH_NOARGS`. Они должны иметь тип :c:type:"
"`PyCFunction`. Первый параметр обычно называется *self* и содержит ссылку на "
"экземпляр модуля или объекта. Во всех случаях второй параметр будет NULL."

#: ../../c-api/structures.rst:398
msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"Функция должна иметь 2 параметра. Поскольку второй параметр не "
"используется, :c:macro:`Py_UNUSED` можно использовать для предотвращения "
"предупреждения компилятора."

#: ../../c-api/structures.rst:404
msgid ""
"Methods with a single object argument can be listed with the :c:macro:"
"`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with a "
"``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Методы с одним аргументом объекта могут быть перечислены с флагом :c:macro:"
"`METH_O` вместо вызова :c:func:`PyArg_ParseTuple` с аргументом ``\"O\"``. "
"Они имеют тип :c:type:`PyCFunction` с параметром *self* и параметром :c:expr:"
"`PyObject*`, представляющим один аргумент."

#: ../../c-api/structures.rst:410
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Эти две константы используются не для обозначения соглашения о вызовах, а "
"для привязки при использовании с методами классов. Их нельзя использовать "
"для функций, определенных для модулей. Для любого метода может быть "
"установлен не более одного из этих флагов."

#: ../../c-api/structures.rst:420
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"Методу будет передан объект типа в качестве первого параметра, а не "
"экземпляр типа. Это используется для создания *методов класса*, аналогично "
"тому, что создается при использовании встроенной функции :func:`classmethod`."

#: ../../c-api/structures.rst:430
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Методу будет передан NULL в качестве первого параметра, а не экземпляр типа. "
"Это используется для создания *статических методов*, аналогично тому, что "
"создается при использовании встроенной функции :func:`staticmethod`."

#: ../../c-api/structures.rst:434
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Еще одна константа контролирует, загружается ли метод вместо другого "
"определения с тем же именем метода."

#: ../../c-api/structures.rst:440
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will "
"be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"Метод будет загружен вместо существующих определений. Без *METH_COEXIST* по "
"умолчанию повторяющиеся определения пропускаются. Поскольку оболочки слотов "
"загружаются до таблицы методов, существование слота *sq_contains*, например, "
"приведет к созданию обернутого метода с именем :meth:`~object.__contains__` "
"и предотвратит загрузку соответствующей PyCFunction с тем же именем. Если "
"флаг определен, PyCFunction будет загружен вместо объекта-оболочки и будет "
"сосуществовать со слотом. Это полезно, поскольку вызовы PyCFunctions "
"оптимизированы больше, чем вызовы объектов-оболочек."

#: ../../c-api/structures.rst:452
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"Превратите *ml* в объект Python :term:`callable`. Вызывающий должен "
"гарантировать, что *ml* переживет :term:`callable`. Обычно *ml* определяется "
"как статическая переменная."

#: ../../c-api/structures.rst:456
msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"Параметр *self* будет передан как аргумент *self* функции C в ``ml-"
">ml_meth`` при вызове. *self* может быть ``NULL``."

#: ../../c-api/structures.rst:460
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
"Атрибут ``__module__`` объекта :term:`callable` может быть установлен из "
"данного аргумента *module*. *module* должен быть строкой Python, которая "
"будет использоваться в качестве имени модуля, в котором определена функция. "
"Если он недоступен, для него можно установить значение :const:`None` или "
"``NULL``."

#: ../../c-api/structures.rst:466
msgid ":attr:`function.__module__`"
msgstr ":attr:`function.__module__`"

#: ../../c-api/structures.rst:468
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"Параметр *cls* будет передан в качестве аргумента *defining_class* функции "
"C. Должен быть установлен, если :c:macro:`METH_METHOD` установлен в ``ml-"
">ml_flags``."

#: ../../c-api/structures.rst:477
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "Эквивалент ``PyCMethod_New(ml, self, Module, NULL)``."

#: ../../c-api/structures.rst:482
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "Эквивалент ``PyCMethod_New(ml, self, NULL, NULL)``."

#: ../../c-api/structures.rst:486
msgid "Accessing attributes of extension types"
msgstr "Доступ к атрибутам типов расширения"

#: ../../c-api/structures.rst:490
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"Структура, описывающая атрибут типа, соответствующего члену структуры C. При "
"определении класса поместите массив этих структур, завершающийся NULL, в "
"слот :c:member:`~PyTypeObject.tp_members`."

#: ../../c-api/structures.rst:495
msgid "Its fields are, in order:"
msgstr "Его поля по порядку:"

#: ../../c-api/structures.rst:499
msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr "Имя участника. Значение NULL отмечает конец массива ``PyMemberDef[]``."

#: ../../c-api/structures.rst:502
msgid "The string should be static, no copy is made of it."
msgstr "Строка должна быть статической, ее копия не создается."

#: ../../c-api/structures.rst:506
msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the "
"possible values."
msgstr ""
"Тип члена в структуре C. См. возможные значения в разделе :ref:`PyMemberDef-"
"types`."

#: ../../c-api/structures.rst:511
msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr "объекта"

#: ../../c-api/structures.rst:515
msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""
"Ноль или более :ref:`PyMemberDef-флагов`, объединенных с помощью побитового "
"ИЛИ."

#: ../../c-api/structures.rst:519
msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""
"Строка документации или NULL. Строка должна быть статической, ее копия не "
"создается. Обычно он определяется с помощью :c:macro:`PyDoc_STR`."

#: ../../c-api/structures.rst:523
msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply :c:macro:"
"`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy :c:macro:"
"`T_OBJECT`) members can be deleted."
msgstr ""
"По умолчанию (когда :c:member:`~PyMemberDef.flags` имеет значение ``0``), "
"члены разрешают доступ как для чтения, так и для записи. Используйте флаг :c:"
"macro:`Py_READONLY` для доступа только для чтения. Некоторые типы, например :"
"c:macro:`Py_T_STRING`, подразумевают :c:macro:`Py_READONLY`. Удалить можно "
"только члены :c:macro:`Py_T_OBJECT_EX` (и устаревшие :c:macro:`T_OBJECT`)."

#: ../../c-api/structures.rst:532
msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding to :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. This member must be defined with "
"``Py_T_PYSSIZET``, and either ``Py_READONLY`` or ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. For example::"
msgstr ""

#: ../../c-api/structures.rst:539
msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"

#: ../../c-api/structures.rst:545
msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr ""
"(Вам может потребоваться ``#include <stddef.h>`` для :c:func:`!offsetof`.)"

#: ../../c-api/structures.rst:547
msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and :c:member:"
"`~PyTypeObject.tp_weaklistoffset` can be defined similarly using "
"``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""
"Устаревшие смещения :c:member:`~PyTypeObject.tp_dictoffset` и :c:member:"
"`~PyTypeObject.tp_weaklistoffset` могут быть определены аналогичным образом "
"с использованием членов ``\"__dictoffset__\"`` и ``\"__weaklistoffset__\"``, "
"но с расширениями. настоятельно рекомендуется вместо этого использовать :c:"
"macro:`Py_TPFLAGS_MANAGED_DICT` и :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF`."

#: ../../c-api/structures.rst:555
msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMemberDef`` всегда доступен. Раньше требовалось включить "
"``\"structmember.h\"``."

#: ../../c-api/structures.rst:560
msgid ""
":c:macro:`Py_RELATIVE_OFFSET` is now allowed for "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` and "
"``\"__weaklistoffset__\"``."
msgstr ""

#: ../../c-api/structures.rst:566
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Получите атрибут, принадлежащий объекту по адресу *obj_addr*. Атрибут "
"описывается ``PyMemberDef`` *m*. Возвращает ``NULL`` в случае ошибки."

#: ../../c-api/structures.rst:572
msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_GetOne`` всегда доступен. Раньше требовалось включить "
"``\"structmember.h\"``."

#: ../../c-api/structures.rst:577
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Установите атрибут, принадлежащий объекту по адресу *obj_addr*, на объект "
"*o*. Устанавливаемый атрибут описывается ``PyMemberDef`` *m*. Возвращает "
"``0`` в случае успеха и отрицательное значение в случае неудачи."

#: ../../c-api/structures.rst:583
msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_SetOne`` всегда доступен. Раньше требовалось включить "
"``\"structmember.h\"``."

#: ../../c-api/structures.rst:589
msgid "Member flags"
msgstr "Флаги участников"

#: ../../c-api/structures.rst:591
msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr "Следующие флаги можно использовать с :c:member:`PyMemberDef.flags`:"

#: ../../c-api/structures.rst:595
msgid "Not writable."
msgstr "Недоступен для записи."

#: ../../c-api/structures.rst:599
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""
"Перед чтением создайте ``object.__getattr__`` :ref:`audit event <audit-"
"events>`."

#: ../../c-api/structures.rst:604
msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""
"Указывает, что :c:member:`~PyMemberDef.offset` этой записи ``PyMemberDef`` "
"указывает смещение от данных, специфичных для подкласса, а не от "
"``PyObject``."

#: ../../c-api/structures.rst:608
msgid ""
"Can only be used as part of :c:member:`Py_tp_members <PyTypeObject."
"tp_members>` :c:type:`slot <PyType_Slot>` when creating a class using "
"negative :c:member:`~PyType_Spec.basicsize`. It is mandatory in that case."
msgstr ""
"Может использоваться только как часть :c:member:`Py_tp_members <PyTypeObject."
"tp_members>` :c:type:`slot <PyType_Slot>` при создании класса с "
"использованием отрицательного :c:member:`~PyType_Spec.basicsize`. В таком "
"случае это обязательно."

#: ../../c-api/structures.rst:613
msgid ""
"This flag is only used in :c:type:`PyType_Slot`. When setting :c:member:"
"`~PyTypeObject.tp_members` during class creation, Python clears it and sets :"
"c:member:`PyMemberDef.offset` to the offset from the ``PyObject`` struct."
msgstr ""
"Этот флаг используется только в :c:type:`PyType_Slot`. При установке :c:"
"member:`~PyTypeObject.tp_members` во время создания класса Python очищает "
"его и устанавливает для :c:member:`PyMemberDef.offset` значение смещения из "
"структуры ``PyObject``."

#: ../../c-api/structures.rst:625
msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and :c:macro:`!"
"WRITE_RESTRICTED` macros available with ``#include \"structmember.h\"`` are "
"deprecated. :c:macro:`!READ_RESTRICTED` and :c:macro:`!RESTRICTED` are "
"equivalent to :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` does "
"nothing."
msgstr ""
"Макросы :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` и :c:macro:`!"
"WRITE_RESTRICTED`, доступные с ``#include \"structmember.h\"``, устарели. :c:"
"macro:`!READ_RESTRICTED` и :c:macro:`!RESTRICTED` эквивалентны :c:macro:"
"`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` ничего не делает."

#: ../../c-api/structures.rst:636
msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The :c:"
"macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The new "
"names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""
"Макрос :c:macro:`!READONLY` был переименован в :c:macro:`Py_READONLY`. "
"Макрос :c:macro:`!PY_AUDIT_READ` был переименован с префиксом ``Py_``. Новые "
"имена теперь всегда доступны. Раньше для этого требовался ``#include "
"\"structmember.h\"``. Заголовок все еще доступен и содержит старые имена."

#: ../../c-api/structures.rst:645
msgid "Member types"
msgstr "Типы участников"

#: ../../c-api/structures.rst:647
msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python, "
"it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""
":c:member:`PyMemberDef.type` может быть одним из следующих макросов, "
"соответствующих различным типам C. Когда к элементу обращаются в Python, он "
"преобразуется в эквивалентный тип Python. Если он установлен из Python, он "
"будет преобразован обратно в тип C. Если это невозможно, создается "
"исключение, такое как :exc:`TypeError` или :exc:`ValueError`."

#: ../../c-api/structures.rst:655
msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using e.g. :"
"keyword:`del` or :py:func:`delattr`."
msgstr ""
"Если не отмечено (D), атрибуты, определенные таким образом, не могут быть "
"удалены, например, с помощью :keyword:`del` или :py:func:`delattr`."

#: ../../c-api/structures.rst:659
msgid "Macro name"
msgstr "Название макроса"

#: ../../c-api/structures.rst:659
msgid "C type"
msgstr "Тип C"

#: ../../c-api/structures.rst:659
msgid "Python type"
msgstr "Тип Python"

#: ../../c-api/structures.rst:661
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../c-api/structures.rst:661 ../../c-api/structures.rst:662
#: ../../c-api/structures.rst:663 ../../c-api/structures.rst:664
#: ../../c-api/structures.rst:665 ../../c-api/structures.rst:666
#: ../../c-api/structures.rst:667 ../../c-api/structures.rst:668
#: ../../c-api/structures.rst:669 ../../c-api/structures.rst:670
#: ../../c-api/structures.rst:671
msgid ":py:class:`int`"
msgstr ":py:class:`int`"

#: ../../c-api/structures.rst:662
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../c-api/structures.rst:663
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/structures.rst:664
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../c-api/structures.rst:665
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: ../../c-api/structures.rst:666
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../c-api/structures.rst:667
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../c-api/structures.rst:668
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../c-api/structures.rst:669
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../c-api/structures.rst:670
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: ../../c-api/structures.rst:671
msgid ":c:expr:`Py_ssize_t`"
msgstr ":c:expr:`Py_ssize_t`"

#: ../../c-api/structures.rst:672
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../c-api/structures.rst:672 ../../c-api/structures.rst:673
msgid ":py:class:`float`"
msgstr ":py:class:`float`"

#: ../../c-api/structures.rst:673
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../c-api/structures.rst:674
msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ":c:expr:`char` (записывается как 0 или 1)"

#: ../../c-api/structures.rst:674
msgid ":py:class:`bool`"
msgstr ":py:class:`bool`"

#: ../../c-api/structures.rst:676
msgid ":c:expr:`const char *` (*)"
msgstr ":c:expr:`const char *` (*)"

#: ../../c-api/structures.rst:676 ../../c-api/structures.rst:677
msgid ":py:class:`str` (RO)"
msgstr ":py:class:`str` (RO)"

#: ../../c-api/structures.rst:677
msgid ":c:expr:`const char[]` (*)"
msgstr ":c:expr:`const char[]` (*)"

#: ../../c-api/structures.rst:678
msgid ":c:expr:`char` (0-127)"
msgstr ":c:expr:`char` (0-127)"

#: ../../c-api/structures.rst:678
msgid ":py:class:`str` (**)"
msgstr ":py:class:`str` (**)"

#: ../../c-api/structures.rst:679
msgid ":c:expr:`PyObject *`"
msgstr ":c:expr:`PyObject *`"

#: ../../c-api/structures.rst:679
msgid ":py:class:`object` (D)"
msgstr ":py:class:`object` (D)"

#: ../../c-api/structures.rst:682
msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""
"(*): строка C с нулевым завершением в кодировке UTF8. С :c:macro:`!"
"Py_T_STRING` представление C является указателем; с :c:macro:`!"
"Py_T_STRING_INPLACE` строка сохраняется непосредственно в структуре."

#: ../../c-api/structures.rst:687
msgid "(**): String of length 1. Only ASCII is accepted."
msgstr "(**): строка длиной 1. Принимается только ASCII."

#: ../../c-api/structures.rst:689
msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr "(RO): подразумевает :c:macro:`Py_READONLY`."

#: ../../c-api/structures.rst:691
msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a "
"``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""
"(D): Можно удалить, в этом случае указатель устанавливается в NULL. Чтение "
"указателя ``NULL`` вызывает :py:exc:`AttributeError`."

#: ../../c-api/structures.rst:717
msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""
"В предыдущих версиях макросы были доступны только с ``#include "
"\"structmember.h\"`` и назывались без префикса ``Py_`` (например, как "
"``T_INT``). Заголовок по-прежнему доступен и содержит старые имена, а также "
"следующие устаревшие типы:"

#: ../../c-api/structures.rst:725
msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results "
"in surprising behavior in Python: deleting the attribute effectively sets it "
"to ``None``."
msgstr ""
"Аналогично Py_T_OBJECT_EX, но NULL преобразуется в None. Это приводит к "
"удивительному поведению Python: удаление атрибута фактически устанавливает "
"его в значение None."

#: ../../c-api/structures.rst:731
msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr "Всегда ``Нет``. Должен использоваться с :c:macro:`Py_READONLY`."

#: ../../c-api/structures.rst:734
msgid "Defining Getters and Setters"
msgstr "Определение геттеров и сеттеров"

#: ../../c-api/structures.rst:738
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Структура для определения доступа к типу наподобие свойства. См. также "
"описание слота :c:member:`PyTypeObject.tp_getset`."

#: ../../c-api/structures.rst:743
msgid "attribute name"
msgstr "имя атрибута"

#: ../../c-api/structures.rst:747
msgid "C function to get the attribute."
msgstr "Функция C для получения атрибута."

#: ../../c-api/structures.rst:751
msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr ""
"Дополнительная функция C для установки или удаления атрибута. Если ``NULL``, "
"атрибут доступен только для чтения."

#: ../../c-api/structures.rst:756
msgid "optional docstring"
msgstr "необязательная строка документации"

#: ../../c-api/structures.rst:760
msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr ""
"Необязательный указатель пользовательских данных, предоставляющий "
"дополнительные данные для методов получения и установки."

#: ../../c-api/structures.rst:764
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"Функция get принимает один параметр :c:expr:`PyObject*` (экземпляр) и "
"указатель пользовательских данных (связанное с ним ``замыкание``):"

#: ../../c-api/structures.rst:767
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Он должен возвращать новую ссылку в случае успеха или ``NULL`` с "
"установленным исключением в случае неудачи."

#: ../../c-api/structures.rst:772
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"Функции ``set`` принимают два параметра :c:expr:`PyObject*` (экземпляр и "
"значение, которое нужно установить) и указатель пользовательских данных "
"(связанное с ним ``замыкание``):"

#: ../../c-api/structures.rst:775
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"В случае, если атрибут должен быть удален, вторым параметром будет ``NULL``. "
"Должен возвращать ``0`` в случае успеха или ``-1`` с установленным "
"исключением в случае неудачи."

#: ../../c-api/structures.rst:418 ../../c-api/structures.rst:428
msgid "built-in function"
msgstr "встроенная функция"

#: ../../c-api/structures.rst:418
msgid "classmethod"
msgstr "classmethod"

#: ../../c-api/structures.rst:428
msgid "staticmethod"
msgstr "staticmethod"

#: ../../c-api/structures.rst:618
msgid "READ_RESTRICTED (C macro)"
msgstr "READ_RESTRICTED (C макрос)"

#: ../../c-api/structures.rst:618
msgid "WRITE_RESTRICTED (C macro)"
msgstr "WRITE_RESTRICTED (C макрос)"

#: ../../c-api/structures.rst:618
msgid "RESTRICTED (C macro)"
msgstr "ОГРАНИЧЕННЫЙ (C макрос)"

#: ../../c-api/structures.rst:631
msgid "READONLY (C macro)"
msgstr "READONLY (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_BYTE (C macro)"
msgstr "T_BYTE (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_SHORT (C macro)"
msgstr "T_SHORT (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_INT (C macro)"
msgstr "T_INT (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_LONG (C macro)"
msgstr "T_LONG (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_UBYTE (C macro)"
msgstr "T_UBYTE (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_USHORT (C macro)"
msgstr "T_USHORT (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_UINT (C macro)"
msgstr "T_UINT (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_ULONG (C macro)"
msgstr "T_ULONG (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGULONG (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_FLOAT (C macro)"
msgstr "T_FLOAT (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_BOOL (C macro)"
msgstr "T_BOOL (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_CHAR (C macro)"
msgstr "T_CHAR (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_STRING (C macro)"
msgstr "T_STRING (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING_INPLACE (C макрос)"

#: ../../c-api/structures.rst:694
msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX (C макрос)"

#: ../../c-api/structures.rst:694
msgid "structmember.h"
msgstr "structmember.h"
