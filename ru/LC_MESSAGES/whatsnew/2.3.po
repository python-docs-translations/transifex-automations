# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 14:51+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../whatsnew/2.3.rst:3
msgid "What's New in Python 2.3"
msgstr "Что нового в Python 2.3"

#: ../../whatsnew/2.3.rst:0
msgid "Author"
msgstr "Автор"

#: ../../whatsnew/2.3.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.3.rst:11
msgid ""
"This article explains the new features in Python 2.3.  Python 2.3 was "
"released on July 29, 2003."
msgstr ""
"В этой статье объясняются новые возможности Python 2.3. Python 2.3 был "
"выпущен 29 июля 2003 года."

#: ../../whatsnew/2.3.rst:14
msgid ""
"The main themes for Python 2.3 are polishing some of the features added in "
"2.2, adding various small but useful enhancements to the core language, and "
"expanding the standard library.  The new object model introduced in the "
"previous version has benefited from 18 months of bugfixes and from "
"optimization efforts that have improved the performance of new-style "
"classes.  A few new built-in functions have been added such as :func:`sum` "
"and :func:`enumerate`.  The :keyword:`in` operator can now be used for "
"substring searches (e.g. ``\"ab\" in \"abc\"`` returns :const:`True`)."
msgstr ""
"Основные темы Python 2.3 — это доработка некоторых функций, добавленных в "
"версии 2.2, добавление различных небольших, но полезных улучшений в основной "
"язык и расширение стандартной библиотеки. Новая объектная модель, "
"представленная в предыдущей версии, улучшилась благодаря 18-месячному "
"исправлению ошибок и усилиям по оптимизации, которые улучшили "
"производительность классов нового стиля. Было добавлено несколько новых "
"встроенных функций, таких как :func:`sum` и :func:`enumerate`. Оператор :"
"keyword:`in` теперь можно использовать для поиска подстроки (например, "
"``\"ab\" в \"abc\"`` возвращает :const:`True`)."

#: ../../whatsnew/2.3.rst:23
msgid ""
"Some of the many new library features include Boolean, set, heap, and date/"
"time data types, the ability to import modules from ZIP-format archives, "
"metadata support for the long-awaited Python catalog, an updated version of "
"IDLE, and modules for logging messages, wrapping text, parsing CSV files, "
"processing command-line options, using BerkeleyDB databases...  the list of "
"new and enhanced modules is lengthy."
msgstr ""
"Некоторые из многих новых функций библиотеки включают логические типы "
"данных, наборы, кучу и типы данных даты/времени, возможность импорта модулей "
"из архивов формата ZIP, поддержку метаданных для долгожданного каталога "
"Python, обновленную версию IDLE и модули. для регистрации сообщений, "
"переноса текста, анализа файлов CSV, обработки параметров командной строки, "
"использования баз данных BerkeleyDB... список новых и улучшенных модулей "
"длинный."

#: ../../whatsnew/2.3.rst:30
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.3, such as the Python Library "
"Reference and the Python Reference Manual.  If you want to understand the "
"complete implementation and design rationale, refer to the PEP for a "
"particular new feature."
msgstr ""
"В этой статье не делается попытка предоставить полную спецификацию новых "
"функций, а вместо этого представлен удобный обзор. Для получения более "
"подробной информации вам следует обратиться к документации по Python 2.3, "
"такой как Справочник по библиотеке Python и Справочное руководство по "
"Python. Если вы хотите понять полное обоснование реализации и "
"проектирования, обратитесь к PEP за конкретной новой функцией."

#: ../../whatsnew/2.3.rst:41
msgid "PEP 218: A Standard Set Datatype"
msgstr "PEP 218: стандартный набор типов данных"

#: ../../whatsnew/2.3.rst:43
msgid ""
"The new :mod:`!sets` module contains an implementation of a set datatype.  "
"The :class:`Set` class is for mutable sets, sets that can have members added "
"and removed.  The :class:`!ImmutableSet` class is for sets that can't be "
"modified, and instances of :class:`!ImmutableSet` can therefore be used as "
"dictionary keys. Sets are built on top of dictionaries, so the elements "
"within a set must be hashable."
msgstr ""
"Новый модуль :mod:`!sets` содержит реализацию типа данных set. Класс :class:"
"`Set` предназначен для изменяемых наборов, наборов, в которые можно "
"добавлять и удалять члены. Класс :class:`!ImmutableSet` предназначен для "
"наборов, которые нельзя изменить, поэтому экземпляры :class:`!ImmutableSet` "
"могут использоваться в качестве ключей словаря. Наборы создаются на основе "
"словарей, поэтому элементы внутри набора должны быть хешируемыми."

#: ../../whatsnew/2.3.rst:50
msgid "Here's a simple example::"
msgstr "Вот простой пример::"

#: ../../whatsnew/2.3.rst:52
msgid ""
">>> import sets\n"
">>> S = sets.Set([1,2,3])\n"
">>> S\n"
"Set([1, 2, 3])\n"
">>> 1 in S\n"
"True\n"
">>> 0 in S\n"
"False\n"
">>> S.add(5)\n"
">>> S.remove(3)\n"
">>> S\n"
"Set([1, 2, 5])\n"
">>>"
msgstr ""
">>> import sets\n"
">>> S = sets.Set([1,2,3])\n"
">>> S\n"
"Set([1, 2, 3])\n"
">>> 1 in S\n"
"True\n"
">>> 0 in S\n"
"False\n"
">>> S.add(5)\n"
">>> S.remove(3)\n"
">>> S\n"
"Set([1, 2, 5])\n"
">>>"

#: ../../whatsnew/2.3.rst:66
msgid ""
"The union and intersection of sets can be computed with the :meth:"
"`~frozenset.union` and :meth:`~frozenset.intersection` methods; an "
"alternative notation uses the bitwise operators ``&`` and ``|``. Mutable "
"sets also have in-place versions of these methods, :meth:`!union_update` "
"and :meth:`~frozenset.intersection_update`. ::"
msgstr ""
"Объединение и пересечение множеств можно вычислить с помощью методов :meth:"
"`~frozenset.union` и :meth:`~frozenset.intersection`; альтернативная запись "
"использует побитовые операторы ``&`` и ``|``. Изменяемые наборы также имеют "
"встроенные версии этих методов: :meth:`!union_update` и :meth:`~frozenset."
"intersection_update`. ::"

#: ../../whatsnew/2.3.rst:71
msgid ""
">>> S1 = sets.Set([1,2,3])\n"
">>> S2 = sets.Set([4,5,6])\n"
">>> S1.union(S2)\n"
"Set([1, 2, 3, 4, 5, 6])\n"
">>> S1 | S2                  # Alternative notation\n"
"Set([1, 2, 3, 4, 5, 6])\n"
">>> S1.intersection(S2)\n"
"Set([])\n"
">>> S1 & S2                  # Alternative notation\n"
"Set([])\n"
">>> S1.union_update(S2)\n"
">>> S1\n"
"Set([1, 2, 3, 4, 5, 6])\n"
">>>"
msgstr ""
">>> S1 = sets.Set([1,2,3])\n"
">>> S2 = sets.Set([4,5,6])\n"
">>> S1.union(S2)\n"
"Set([1, 2, 3, 4, 5, 6])\n"
">>> S1 | S2                  # Alternative notation\n"
"Set([1, 2, 3, 4, 5, 6])\n"
">>> S1.intersection(S2)\n"
"Set([])\n"
">>> S1 & S2                  # Alternative notation\n"
"Set([])\n"
">>> S1.union_update(S2)\n"
">>> S1\n"
"Set([1, 2, 3, 4, 5, 6])\n"
">>>"

#: ../../whatsnew/2.3.rst:86
msgid ""
"It's also possible to take the symmetric difference of two sets.  This is "
"the set of all elements in the union that aren't in the intersection.  "
"Another way of putting it is that the symmetric difference contains all "
"elements that are in exactly one set.  Again, there's an alternative "
"notation (``^``), and an in-place version with the ungainly name :meth:"
"`~frozenset.symmetric_difference_update`. ::"
msgstr ""
"Также можно взять симметричную разность двух множеств. Это набор всех "
"элементов объединения, которые не находятся в пересечении. Другими словами, "
"симметричная разность содержит все элементы, входящие ровно в один набор. "
"Опять же, есть альтернативное обозначение (``^``) и локальная версия с "
"неуклюжим именем :meth:`~frozenset.symmetric_difference_update`. ::"

#: ../../whatsnew/2.3.rst:92
msgid ""
">>> S1 = sets.Set([1,2,3,4])\n"
">>> S2 = sets.Set([3,4,5,6])\n"
">>> S1.symmetric_difference(S2)\n"
"Set([1, 2, 5, 6])\n"
">>> S1 ^ S2\n"
"Set([1, 2, 5, 6])\n"
">>>"
msgstr ""
">>> S1 = sets.Set([1,2,3,4])\n"
">>> S2 = sets.Set([3,4,5,6])\n"
">>> S1.symmetric_difference(S2)\n"
"Set([1, 2, 5, 6])\n"
">>> S1 ^ S2\n"
"Set([1, 2, 5, 6])\n"
">>>"

#: ../../whatsnew/2.3.rst:100
msgid ""
"There are also :meth:`!issubset` and :meth:`!issuperset` methods for "
"checking whether one set is a subset or superset of another::"
msgstr ""
"Существуют также методы :meth:`!issubset` и :meth:`!issuperset` для проверки "
"того, является ли один набор подмножеством или надмножеством другого::"

#: ../../whatsnew/2.3.rst:103
msgid ""
">>> S1 = sets.Set([1,2,3])\n"
">>> S2 = sets.Set([2,3])\n"
">>> S2.issubset(S1)\n"
"True\n"
">>> S1.issubset(S2)\n"
"False\n"
">>> S1.issuperset(S2)\n"
"True\n"
">>>"
msgstr ""
">>> S1 = sets.Set([1,2,3])\n"
">>> S2 = sets.Set([2,3])\n"
">>> S2.issubset(S1)\n"
"True\n"
">>> S1.issubset(S2)\n"
"False\n"
">>> S1.issuperset(S2)\n"
"True\n"
">>>"

#: ../../whatsnew/2.3.rst:116
msgid ":pep:`218` - Adding a Built-In Set Object Type"
msgstr ":pep:`218` - Добавление встроенного набора типов объектов"

#: ../../whatsnew/2.3.rst:117
msgid ""
"PEP written by Greg V. Wilson. Implemented by Greg V. Wilson, Alex Martelli, "
"and GvR."
msgstr ""
"PEP, написанный Грегом В. Уилсоном. Реализовано Грегом В. Уилсоном, Алексом "
"Мартелли и GvR."

#: ../../whatsnew/2.3.rst:126
msgid "PEP 255: Simple Generators"
msgstr "PEP 255: Простые генераторы"

#: ../../whatsnew/2.3.rst:128
msgid ""
"In Python 2.2, generators were added as an optional feature, to be enabled "
"by a ``from __future__ import generators`` directive.  In 2.3 generators no "
"longer need to be specially enabled, and are now always present; this means "
"that :keyword:`yield` is now always a keyword.  The rest of this section is "
"a copy of the description of generators from the \"What's New in Python "
"2.2\" document; if you read it back when Python 2.2 came out, you can skip "
"the rest of this section."
msgstr ""
"В Python 2.2 генераторы были добавлены в качестве дополнительной функции, "
"которая включается директивой from __future__ importgenerators``. В версии "
"2.3 генераторы больше не нужно специально включать, и теперь они "
"присутствуют всегда; это означает, что :keyword:`yield` теперь всегда "
"является ключевым словом. Остальная часть этого раздела представляет собой "
"копию описания генераторов из документа «Что нового в Python 2.2»; если вы "
"перечитаете его, когда вышел Python 2.2, вы можете пропустить остальную "
"часть этого раздела."

#: ../../whatsnew/2.3.rst:136
msgid ""
"You're doubtless familiar with how function calls work in Python or C. When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"Вы, несомненно, знакомы с тем, как работают вызовы функций в Python или C. "
"Когда вы вызываете функцию, она получает частное пространство имен, в "
"котором создаются ее локальные переменные. Когда функция достигает "
"оператора :keyword:`return`, локальные переменные уничтожаются, а полученное "
"значение возвращается вызывающей стороне. Более поздний вызов той же функции "
"получит новый набор локальных переменных. Но что, если бы локальные "
"переменные не удалялись при выходе из функции? Что, если бы вы могли позже "
"возобновить выполнение функции с того места, где она остановилась? Это то, "
"что обеспечивают генераторы; их можно рассматривать как возобновляемые "
"функции."

#: ../../whatsnew/2.3.rst:145
msgid "Here's the simplest example of a generator function::"
msgstr "Вот простейший пример функции-генератора:"

#: ../../whatsnew/2.3.rst:147
msgid ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"
msgstr ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"

#: ../../whatsnew/2.3.rst:151
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result."
msgstr ""
"Для генераторов было введено новое ключевое слово :keyword:`yield`. Любая "
"функция, содержащая оператор :keyword:`!yield`, является функцией-"
"генератором; это обнаруживается компилятором байт-кода Python, который в "
"результате специально компилирует функцию."

#: ../../whatsnew/2.3.rst:156
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's ``."
"next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`try` block of a :keyword:`!"
"try`...\\ :keyword:`!finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"Когда вы вызываете функцию-генератор, она не возвращает ни одного значения; "
"вместо этого он возвращает объект-генератор, поддерживающий протокол "
"итератора. При выполнении оператора :keyword:`yield` генератор выводит "
"значение ``i``, аналогично оператору :keyword:`return`. Большая разница "
"между оператором :keyword:`!yield` и оператором :keyword:`!return` "
"заключается в том, что при достижении :keyword:`!yield` состояние выполнения "
"генератора приостанавливается и локальные переменные сохраняются. При "
"следующем вызове метода генератора ``.next()`` функция возобновит выполнение "
"сразу после оператора :keyword:`!yield`. (По сложным причинам оператор :"
"keyword:`!yield` не допускается внутри блока :keyword:`try` оператора :"
"keyword:`!try`...\\ :keyword:`!finally`; прочитайте :pep:`255` для полного "
"объяснения взаимодействия между :keyword:`!yield` и исключениями.)"

#: ../../whatsnew/2.3.rst:169
msgid "Here's a sample usage of the :func:`!generate_ints` generator::"
msgstr "Вот пример использования генератора :func:`!generate_ints`::"

#: ../../whatsnew/2.3.rst:171
msgid ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<generator object at 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"stdin\", line 1, in ?\n"
"  File \"stdin\", line 2, in generate_ints\n"
"StopIteration"
msgstr ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<generator object at 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"stdin\", line 1, in ?\n"
"  File \"stdin\", line 2, in generate_ints\n"
"StopIteration"

#: ../../whatsnew/2.3.rst:186
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"Вы также можете написать ``for i ingener_ints(5)`` или ``a,b,c "
"=generate_ints(3)``."

#: ../../whatsnew/2.3.rst:189
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"Внутри функции-генератора оператор :keyword:`return` может использоваться "
"только без значения и сигнализирует об окончании обработки значений; после "
"этого генератор не может возвращать дальнейшие значения. :keyword:`!return` "
"со значением, например ``return 5``, является синтаксической ошибкой внутри "
"функции-генератора. Окончание результатов генератора также можно указать, "
"подняв :exc:`StopIteration` вручную или просто позволив потоку выполнения "
"выпасть из нижней части функции."

#: ../../whatsnew/2.3.rst:197
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"Эффекта генераторов можно добиться вручную, написав собственный класс и "
"сохранив все локальные переменные генератора как переменные экземпляра. "
"Например, возврат списка целых чисел можно выполнить, установив для ``self."
"count`` значение 0, а метод :meth:`next` увеличит ``self.count`` и вернет "
"его. Однако для генератора средней сложности написание соответствующего "
"класса было бы гораздо сложнее. :file:`Lib/test/test_generators.py` содержит "
"ряд более интересных примеров. Самый простой реализует обход дерева по "
"порядку с использованием рекурсивных генераторов. ::"

#: ../../whatsnew/2.3.rst:206
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"

#: ../../whatsnew/2.3.rst:215
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"Два других примера в :file:`Lib/test/test_generators.py` дают решения "
"проблемы N-ферзей (размещение $N$ ферзей на шахматной доске $NxN$ так, чтобы "
"ни один ферзь не угрожал другому) и конского тура ( маршрут, который "
"доставляет коня на каждую клетку шахматной доски $NxN$, не посещая ни одну "
"клетку дважды)."

#: ../../whatsnew/2.3.rst:220
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www2.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www2.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""
"Идея генераторов пришла из других языков программирования, особенно из Icon "
"(https://www2.cs.arizona.edu/icon/), где идея генераторов занимает "
"центральное место. В Icon каждое выражение и вызов функции ведет себя как "
"генератор. Один пример из «Обзора языка программирования значков» по ​​адресу "
"https://www2.cs.arizona.edu/icon/docs/ipd266.htm дает представление о том, "
"как это выглядит:"

#: ../../whatsnew/2.3.rst:227
msgid ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"
msgstr ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"

#: ../../whatsnew/2.3.rst:230
msgid ""
"In Icon the :func:`!find` function returns the indexes at which the "
"substring \"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` "
"is first assigned a value of 3, but 3 is less than 5, so the comparison "
"fails, and Icon retries it with the second value of 23.  23 is greater than "
"5, so the comparison now succeeds, and the code prints the value 23 to the "
"screen."
msgstr ""
"В Icon функция :func:`!find` возвращает индексы, по которым найдена "
"подстрока \"или\": 3, 23, 33. В операторе :keyword:`if` ``i`` сначала "
"присваивается значение 3, но 3 меньше 5, поэтому сравнение не удается, и "
"Icon повторяет его со вторым значением 23. 23 больше 5, поэтому сравнение "
"теперь завершается успешно, и код выводит значение 23 на экран."

#: ../../whatsnew/2.3.rst:236
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered part of the core Python language, but "
"learning or using them isn't compulsory; if they don't solve any problems "
"that you have, feel free to ignore them. One novel feature of Python's "
"interface as compared to Icon's is that a generator's state is represented "
"as a concrete object (the iterator) that can be passed around to other "
"functions or stored in a data structure."
msgstr ""
"Python не заходит так далеко, как Icon, в принятии генераторов в качестве "
"центральной концепции. Генераторы считаются частью основного языка Python, "
"но их изучение или использование не является обязательным; если они не "
"решают ваших проблем, не стесняйтесь их игнорировать. Одной из новых "
"особенностей интерфейса Python по сравнению с интерфейсом Icon является то, "
"что состояние генератора представлено в виде конкретного объекта "
"(итератора), который можно передавать другим функциям или сохранять в "
"структуре данных."

#: ../../whatsnew/2.3.rst:247
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Простые генераторы"

#: ../../whatsnew/2.3.rst:248
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"Сценарист: Нил Шеменауэр, Тим Питерс, Магнус Ли Хетланд. Реализовано в "
"основном Нилом Шеменауэром и Тимом Питерсом, а другие исправления внесены "
"командой Python Labs."

#: ../../whatsnew/2.3.rst:257
msgid "PEP 263: Source Code Encodings"
msgstr "PEP 263: Кодировки исходного кода"

#: ../../whatsnew/2.3.rst:259
msgid ""
"Python source files can now be declared as being in different character set "
"encodings.  Encodings are declared by including a specially formatted "
"comment in the first or second line of the source file.  For example, a "
"UTF-8 file can be declared with::"
msgstr ""
"Исходные файлы Python теперь можно объявлять как находящиеся в разных "
"кодировках набора символов. Кодировки объявляются путем включения специально "
"отформатированного комментария в первую или вторую строку исходного файла. "
"Например, файл UTF-8 можно объявить с помощью:"

#: ../../whatsnew/2.3.rst:264
msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: UTF-8 -*-"
msgstr ""
"#!/usr/bin/env python\n"
"# -*- coding: UTF-8 -*-"

#: ../../whatsnew/2.3.rst:267
msgid ""
"Without such an encoding declaration, the default encoding used is 7-bit "
"ASCII. Executing or importing modules that contain string literals with 8-"
"bit characters and have no encoding declaration will result in a :exc:"
"`DeprecationWarning` being signalled by Python 2.3; in 2.4 this will be a "
"syntax error."
msgstr ""
"Без такого объявления кодировки по умолчанию используется 7-битная кодировка "
"ASCII. Выполнение или импорт модулей, которые содержат строковые литералы с "
"8-битными символами и не имеют объявления кодировки, приведет к сигналу :exc:"
"`DeprecationWarning` от Python 2.3; в версии 2.4 это будет синтаксическая "
"ошибка."

#: ../../whatsnew/2.3.rst:273
msgid ""
"The encoding declaration only affects Unicode string literals, which will be "
"converted to Unicode using the specified encoding.  Note that Python "
"identifiers are still restricted to ASCII characters, so you can't have "
"variable names that use characters outside of the usual alphanumerics."
msgstr ""
"Объявление кодировки влияет только на строковые литералы Юникода, которые "
"будут преобразованы в Юникод с использованием указанной кодировки. Обратите "
"внимание, что идентификаторы Python по-прежнему ограничены символами ASCII, "
"поэтому в именах переменных не могут использоваться символы, отличные от "
"обычных буквенно-цифровых символов."

#: ../../whatsnew/2.3.rst:281
msgid ":pep:`263` - Defining Python Source Code Encodings"
msgstr ":pep:`263` - Определение кодировки исходного кода Python"

#: ../../whatsnew/2.3.rst:282
msgid ""
"Written by Marc-André Lemburg and Martin von Löwis; implemented by Suzuki "
"Hisao and Martin von Löwis."
msgstr ""
"Авторы сценария Марк-Андре Лембург и Мартин фон Лёвис; реализовано Сузуки "
"Хисао и Мартином фон Лёвисом."

#: ../../whatsnew/2.3.rst:289
msgid "PEP 273: Importing Modules from ZIP Archives"
msgstr "PEP 273: импорт модулей из ZIP-архивов"

#: ../../whatsnew/2.3.rst:291
msgid ""
"The new :mod:`zipimport` module adds support for importing modules from a "
"ZIP-format archive.  You don't need to import the module explicitly; it will "
"be automatically imported if a ZIP archive's filename is added to ``sys."
"path``. For example:"
msgstr ""
"Новый модуль :mod:`zipimport` добавляет поддержку импорта модулей из архива "
"формата ZIP. Вам не нужно явно импортировать модуль; он будет автоматически "
"импортирован, если имя файла ZIP-архива будет добавлено в ``sys.path``. "
"Например:"

#: ../../whatsnew/2.3.rst:296
msgid ""
"amk@nyman:~/src/python$ unzip -l /tmp/example.zip\n"
"Archive:  /tmp/example.zip\n"
"  Length     Date   Time    Name\n"
" --------    ----   ----    ----\n"
"     8467  11-26-02 22:30   jwzthreading.py\n"
" --------                   -------\n"
"     8467                   1 file\n"
"amk@nyman:~/src/python$ ./python\n"
"Python 2.3 (#1, Aug 1 2003, 19:54:32)\n"
">>> import sys\n"
">>> sys.path.insert(0, '/tmp/example.zip')  # Add .zip file to front of "
"path\n"
">>> import jwzthreading\n"
">>> jwzthreading.__file__\n"
"'/tmp/example.zip/jwzthreading.py'\n"
">>>"
msgstr ""
"amk@nyman:~/src/python$ unzip -l /tmp/example.zip\n"
"Archive:  /tmp/example.zip\n"
"  Length     Date   Time    Name\n"
" --------    ----   ----    ----\n"
"     8467  11-26-02 22:30   jwzthreading.py\n"
" --------                   -------\n"
"     8467                   1 file\n"
"amk@nyman:~/src/python$ ./python\n"
"Python 2.3 (#1, Aug 1 2003, 19:54:32)\n"
">>> import sys\n"
">>> sys.path.insert(0, '/tmp/example.zip')  # Add .zip file to front of "
"path\n"
">>> import jwzthreading\n"
">>> jwzthreading.__file__\n"
"'/tmp/example.zip/jwzthreading.py'\n"
">>>"

#: ../../whatsnew/2.3.rst:314
msgid ""
"An entry in ``sys.path`` can now be the filename of a ZIP archive. The ZIP "
"archive can contain any kind of files, but only files named :file:`\\*.py`, :"
"file:`\\*.pyc`, or :file:`\\*.pyo` can be imported.  If an archive only "
"contains :file:`\\*.py` files, Python will not attempt to modify the archive "
"by adding the corresponding :file:`\\*.pyc` file, meaning that if a ZIP "
"archive doesn't contain :file:`\\*.pyc` files, importing may be rather slow."
msgstr ""
"Запись в ``sys.path`` теперь может быть именем файла ZIP-архива. ZIP-архив "
"может содержать файлы любого типа, но импортировать можно только файлы с "
"именами :file:`\\*.py`, :file:`\\*.pyc` или :file:`\\*.pyo`. Если архив "
"содержит только файлы :file:`\\*.py`, Python не будет пытаться изменить "
"архив, добавляя соответствующий файл :file:`\\*.pyc`, а это означает, что "
"если ZIP-архив не содержит: file:`\\*.pyc`, импорт может быть довольно "
"медленным."

#: ../../whatsnew/2.3.rst:321
msgid ""
"A path within the archive can also be specified to only import from a "
"subdirectory; for example, the path :file:`/tmp/example.zip/lib/` would only "
"import from the :file:`lib/` subdirectory within the archive."
msgstr ""
"Путь внутри архива также можно указать только для импорта из подкаталога; "
"например, путь :file:`/tmp/example.zip/lib/` будет импортироваться только из "
"подкаталога :file:`lib/` внутри архива."

#: ../../whatsnew/2.3.rst:328
msgid ":pep:`273` - Import Modules from Zip Archives"
msgstr ":pep:`273` - Импорт модулей из Zip-архивов"

#: ../../whatsnew/2.3.rst:329
msgid ""
"Written by James C. Ahlstrom,  who also provided an implementation. Python "
"2.3 follows the specification in :pep:`273`,  but uses an implementation "
"written by Just van Rossum  that uses the import hooks described in :pep:"
"`302`. See section :ref:`section-pep302` for a description of the new import "
"hooks."
msgstr ""
"Написано Джеймсом К. Альстромом, который также предоставил реализацию. "
"Python 2.3 следует спецификации :pep:`273`, но использует реализацию, "
"написанную Джастом ван Россумом, которая использует перехватчики импорта, "
"описанные в :pep:`302`. См. раздел :ref:`section-pep302` для описания новых "
"хуков импорта."

#: ../../whatsnew/2.3.rst:338
msgid "PEP 277: Unicode file name support for Windows NT"
msgstr "PEP 277: поддержка имен файлов в Юникоде для Windows NT"

#: ../../whatsnew/2.3.rst:340
msgid ""
"On Windows NT, 2000, and XP, the system stores file names as Unicode "
"strings. Traditionally, Python has represented file names as byte strings, "
"which is inadequate because it renders some file names inaccessible."
msgstr ""
"В Windows NT, 2000 и XP система хранит имена файлов в виде строк Юникода. "
"Традиционно Python представляет имена файлов в виде байтовых строк, что "
"является неадекватным, поскольку делает некоторые имена файлов недоступными."

#: ../../whatsnew/2.3.rst:344
msgid ""
"Python now allows using arbitrary Unicode strings (within the limitations of "
"the file system) for all functions that expect file names, most notably the :"
"func:`open` built-in function. If a Unicode string is passed to :func:`os."
"listdir`, Python now returns a list of Unicode strings.  A new function, :"
"func:`!os.getcwdu`, returns the current directory as a Unicode string."
msgstr ""
"Python теперь позволяет использовать произвольные строки Unicode (в пределах "
"ограничений файловой системы) для всех функций, которые ожидают имена "
"файлов, особенно для встроенной функции :func:`open`. Если в :func:`os."
"listdir` передается строка Юникода, Python теперь возвращает список строк "
"Юникода. Новая функция :func:`!os.getcwdu` возвращает текущий каталог в виде "
"строки Unicode."

#: ../../whatsnew/2.3.rst:350
msgid ""
"Byte strings still work as file names, and on Windows Python will "
"transparently convert them to Unicode using the ``mbcs`` encoding."
msgstr ""
"Байтовые строки по-прежнему работают как имена файлов, а в Windows Python "
"прозрачно преобразует их в Unicode, используя кодировку mbcs."

#: ../../whatsnew/2.3.rst:353
msgid ""
"Other systems also allow Unicode strings as file names but convert them to "
"byte strings before passing them to the system, which can cause a :exc:"
"`UnicodeError` to be raised. Applications can test whether arbitrary Unicode "
"strings are supported as file names by checking :const:`os.path."
"supports_unicode_filenames`, a Boolean value."
msgstr ""
"Другие системы также разрешают строки Unicode в качестве имен файлов, но "
"преобразуют их в строки байтов, прежде чем передавать их в систему, что "
"может привести к повышению: `` Unicodeerror`. Приложения могут проверить, "
"поддерживаются ли произвольные строки Unicode в качестве имен файлов путем "
"проверки: const: `os.path.supports_unicode_filenames`, логическое значение."

#: ../../whatsnew/2.3.rst:359
msgid "Under MacOS, :func:`os.listdir` may now return Unicode filenames."
msgstr ""
"В MacOS :func:`os.listdir` теперь может возвращать имена файлов в Юникоде."

#: ../../whatsnew/2.3.rst:364
msgid ":pep:`277` - Unicode file name support for Windows NT"
msgstr ":pep:`277` - поддержка имен файлов в формате Unicode для Windows NT."

#: ../../whatsnew/2.3.rst:365
msgid ""
"Written by Neil Hodgson; implemented by Neil Hodgson, Martin von Löwis, and "
"Mark Hammond."
msgstr ""
"Автор Нил Ходжсон; реализовано Нилом Ходжсоном, Мартином фон Лёвисом и "
"Марком Хаммондом."

#: ../../whatsnew/2.3.rst:375
msgid "PEP 278: Universal Newline Support"
msgstr "PEP 278: универсальная поддержка новой строки"

#: ../../whatsnew/2.3.rst:377
msgid ""
"The three major operating systems used today are Microsoft Windows, Apple's "
"Macintosh OS, and the various Unix derivatives.  A minor irritation of cross-"
"platform work  is that these three platforms all use different characters to "
"mark the ends of lines in text files.  Unix uses the linefeed (ASCII "
"character 10), MacOS uses the carriage return (ASCII character 13), and "
"Windows uses a two-character sequence of a carriage return plus a newline."
msgstr ""
"Сегодня используются три основные операционные системы: Microsoft Windows, "
"Macintosh OS от Apple и различные производные Unix. Небольшое раздражение "
"при кросс-платформенной работе заключается в том, что все эти три платформы "
"используют разные символы для обозначения концов строк в текстовых файлах. "
"Unix использует перевод строки (символ ASCII 10), MacOS использует возврат "
"каретки (символ ASCII 13), а Windows использует двухсимвольную "
"последовательность возврата каретки и новой строки."

#: ../../whatsnew/2.3.rst:384
msgid ""
"Python's file objects can now support end of line conventions other than the "
"one followed by the platform on which Python is running. Opening a file with "
"the mode ``'U'`` or ``'rU'`` will open a file for reading in :term:"
"`universal newlines` mode.  All three line ending conventions will be "
"translated to a ``'\\n'`` in the strings returned by the various file "
"methods such as :meth:`!read` and :meth:`!readline`."
msgstr ""
"Файловые объекты Python теперь могут поддерживать соглашения о конце строки, "
"отличные от тех, которые используются платформой, на которой работает "
"Python. Открытие файла в режиме ``'U'`` или ``'rU'`` откроет файл для чтения "
"в режиме :term:`универсальных новых строк`. Все три соглашения об окончании "
"строк будут преобразованы в ``'\\n'`` в строках, возвращаемых различными "
"файловыми методами, такими как :meth:`!read` и :meth:`!readline`."

#: ../../whatsnew/2.3.rst:391
msgid ""
"Universal newline support is also used when importing modules and when "
"executing a file with the :func:`!execfile` function.  This means that "
"Python modules can be shared between all three operating systems without "
"needing to convert the line-endings."
msgstr ""
"Универсальная поддержка новой строки также используется при импорте модулей "
"и при выполнении файла с помощью функции :func:`!execfile`. Это означает, "
"что модули Python могут использоваться всеми тремя операционными системами "
"без необходимости преобразования концов строк."

#: ../../whatsnew/2.3.rst:396
msgid ""
"This feature can be disabled when compiling Python by specifying the :option:"
"`!--without-universal-newlines` switch when running Python's :program:"
"`configure` script."
msgstr ""
"Эту функцию можно отключить при компиляции Python, указав переключатель :"
"option:`!--without-universal-newlines` при запуске скрипта Python :program:"
"`configure`."

#: ../../whatsnew/2.3.rst:403
msgid ":pep:`278` - Universal Newline Support"
msgstr ":pep:`278` - универсальная поддержка новой строки"

#: ../../whatsnew/2.3.rst:404
msgid "Written and implemented by Jack Jansen."
msgstr "Написано и реализовано Джеком Янсеном."

#: ../../whatsnew/2.3.rst:412
msgid "PEP 279: enumerate()"
msgstr "PEP 279: enumerate()"

#: ../../whatsnew/2.3.rst:414
msgid ""
"A new built-in function, :func:`enumerate`, will make certain loops a bit "
"clearer.  ``enumerate(thing)``, where *thing* is either an iterator or a "
"sequence, returns an iterator that will return ``(0, thing[0])``, ``(1, "
"thing[1])``, ``(2, thing[2])``, and so forth."
msgstr ""
"Новая встроенная функция :func:`enumerate` сделает некоторые циклы более "
"понятными. ``enumerate(thing)``, где *thing* — это итератор или "
"последовательность, возвращает итератор, который вернет ``(0,thing[0])``, "
"``(1,thing[1]) ``, ``(2,thing[2])`` и так далее."

#: ../../whatsnew/2.3.rst:419
msgid "A common idiom to change every element of a list looks like this::"
msgstr ""
"Распространенная идиома изменения каждого элемента списка выглядит следующим "
"образом:"

#: ../../whatsnew/2.3.rst:421
msgid ""
"for i in range(len(L)):\n"
"    item = L[i]\n"
"    # ... compute some result based on item ...\n"
"    L[i] = result"
msgstr ""
"for i in range(len(L)):\n"
"    item = L[i]\n"
"    # ... compute some result based on item ...\n"
"    L[i] = result"

#: ../../whatsnew/2.3.rst:426
msgid "This can be rewritten using :func:`enumerate` as::"
msgstr "Это можно переписать с помощью :func:`enumerate` как::"

#: ../../whatsnew/2.3.rst:428
msgid ""
"for i, item in enumerate(L):\n"
"    # ... compute some result based on item ...\n"
"    L[i] = result"
msgstr ""
"for i, item in enumerate(L):\n"
"    # ... compute some result based on item ...\n"
"    L[i] = result"

#: ../../whatsnew/2.3.rst:435
msgid ":pep:`279` - The enumerate() built-in function"
msgstr ":pep:`279` - Встроенная функция enumerate()"

#: ../../whatsnew/2.3.rst:436
msgid "Written and implemented by Raymond D. Hettinger."
msgstr "Написано и реализовано Рэймондом Д. Хеттингером."

#: ../../whatsnew/2.3.rst:442
msgid "PEP 282: The logging Package"
msgstr "PEP 282: Пакет журналирования"

#: ../../whatsnew/2.3.rst:444
msgid ""
"A standard package for writing logs, :mod:`logging`, has been added to "
"Python 2.3.  It provides a powerful and flexible mechanism for generating "
"logging output which can then be filtered and processed in various ways.  A "
"configuration file written in a standard format can be used to control the "
"logging behavior of a program.  Python includes handlers that will write log "
"records to standard error or to a file or socket, send them to the system "
"log, or even e-mail them to a particular address; of course, it's also "
"possible to write your own handler classes."
msgstr ""
"В Python 2.3 добавлен стандартный пакет для записи логов :mod:`logging`. Он "
"предоставляет мощный и гибкий механизм для создания выходных данных журнала, "
"которые затем можно фильтровать и обрабатывать различными способами. Файл "
"конфигурации, написанный в стандартном формате, можно использовать для "
"управления поведением программы при ведении журналов. Python включает в себя "
"обработчики, которые будут записывать записи журнала в стандартную ошибку, в "
"файл или сокет, отправлять их в системный журнал или даже отправлять по "
"электронной почте на определенный адрес; конечно, также возможно написать "
"свои собственные классы-обработчики."

#: ../../whatsnew/2.3.rst:453
msgid ""
"The :class:`~logging.Logger` class is the primary class. Most application "
"code will deal with one or more :class:`~logging.Logger` objects, each one "
"used by a particular subsystem of the application. Each :class:`~logging."
"Logger` is identified by a name, and names are organized into a hierarchy "
"using ``.``  as the component separator. For example, you might have :class:"
"`~logging.Logger` instances named ``server``, ``server.auth`` and ``server."
"network``.  The latter two instances are below ``server`` in the hierarchy.  "
"This means that if you turn up the verbosity for ``server`` or direct "
"``server`` messages to a different handler, the changes will also apply to "
"records logged to ``server.auth`` and ``server.network``. There's also a "
"root :class:`~logging.Logger` that's the parent of all other loggers."
msgstr ""
"Класс :class:`~logging.Logger` является основным классом. Большая часть кода "
"приложения будет иметь дело с одним или несколькими объектами :class:"
"`~logging.Logger`, каждый из которых используется определенной подсистемой "
"приложения. Каждый :class:`~logging.Logger` идентифицируется по имени, а "
"имена организованы в иерархию с использованием ``.`` в качестве разделителя "
"компонентов. Например, у вас могут быть экземпляры :class:`~logging.Logger` "
"с именами ``server``, ``server.auth`` и ``server.network``. Последние два "
"экземпляра находятся ниже «сервера» в иерархии. Это означает, что если вы "
"увеличите уровень детализации для ``server`` или направите сообщения "
"``server`` другому обработчику, изменения также будут применены к записям, "
"зарегистрированным в ``server.auth`` и ``server.network``. ``. Также "
"существует корневой :class:`~logging.Logger`, который является родительским "
"для всех остальных регистраторов."

#: ../../whatsnew/2.3.rst:464
msgid ""
"For simple uses, the :mod:`logging` package contains some convenience "
"functions that always use the root log::"
msgstr ""
"Для простого использования пакет :mod:`logging` содержит несколько удобных "
"функций, которые всегда используют корневой журнал::"

#: ../../whatsnew/2.3.rst:467
msgid ""
"import logging\n"
"\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"
msgstr ""
"import logging\n"
"\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"

#: ../../whatsnew/2.3.rst:475 ../../whatsnew/2.3.rst:500
msgid "This produces the following output::"
msgstr "Это дает следующий результат:"

#: ../../whatsnew/2.3.rst:477
msgid ""
"WARNING:root:Warning:config file server.conf not found\n"
"ERROR:root:Error occurred\n"
"CRITICAL:root:Critical error -- shutting down"
msgstr ""
"ВНИМАНИЕ: root: Предупреждение: файл конфигурации server.conf не найден. "
"ОШИБКА:корень:Произошла ошибка КРИТИЧЕСКИЙ:root:Критическая ошибка – "
"завершение работы"

#: ../../whatsnew/2.3.rst:481
msgid ""
"In the default configuration, informational and debugging messages are "
"suppressed and the output is sent to standard error.  You can enable the "
"display of informational and debugging messages by calling the :meth:"
"`~logging.Logger.setLevel` method on the root logger."
msgstr ""
"В конфигурации по умолчанию информационные и отладочные сообщения "
"подавляются, а выходные данные отправляются в стандартную ошибку. Вы можете "
"включить отображение информационных и отладочных сообщений, вызвав метод :"
"meth:`~logging.Logger.setLevel` в корневом регистраторе."

#: ../../whatsnew/2.3.rst:486
msgid ""
"Notice the :func:`~logging.warning` call's use of string formatting "
"operators; all of the functions for logging messages take the arguments "
"``(msg, arg1, arg2, ...)`` and log the string resulting from ``msg % (arg1, "
"arg2, ...)``."
msgstr ""
"Обратите внимание на использование операторов форматирования строк в вызове :"
"func:`~logging.warning`; все функции для регистрации сообщений принимают "
"аргументы ``(msg, arg1, arg2, ...)`` и записывают строку, полученную из "
"``msg % (arg1, arg2, ...)``."

#: ../../whatsnew/2.3.rst:490
msgid ""
"There's also an :func:`~logging.exception` function that records the most "
"recent traceback.  Any of the other functions will also record the traceback "
"if you specify a true value for the keyword argument *exc_info*. ::"
msgstr ""
"Существует также функция :func:`~logging.Exception`, которая записывает "
"самую последнюю обратную трассировку. Любая из других функций также будет "
"записывать обратную трассировку, если вы укажете истинное значение для "
"аргумента ключевого слова *exc_info*. ::"

#: ../../whatsnew/2.3.rst:494
msgid ""
"def f():\n"
"    try:    1/0\n"
"    except: logging.exception('Problem recorded')\n"
"\n"
"f()"
msgstr ""
"def f():\n"
"    try:    1/0\n"
"    except: logging.exception('Problem recorded')\n"
"\n"
"f()"

#: ../../whatsnew/2.3.rst:502
msgid ""
"ERROR:root:Problem recorded\n"
"Traceback (most recent call last):\n"
"  File \"t.py\", line 6, in f\n"
"    1/0\n"
"ZeroDivisionError: integer division or modulo by zero"
msgstr ""
"ERROR:root:Problem recorded\n"
"Traceback (most recent call last):\n"
"  File \"t.py\", line 6, in f\n"
"    1/0\n"
"ZeroDivisionError: integer division or modulo by zero"

#: ../../whatsnew/2.3.rst:508
msgid ""
"Slightly more advanced programs will use a logger other than the root "
"logger. The ``getLogger(name)`` function is used to get a particular log, "
"creating it if it doesn't exist yet. ``getLogger(None)`` returns the root "
"logger. ::"
msgstr ""
"Немного более продвинутые программы будут использовать другой регистратор, а "
"не корневой. Функция getLogger(name) используется для получения "
"определенного журнала и создания его, если он еще не существует. "
"``getLogger(None)`` возвращает корневой регистратор. ::"

#: ../../whatsnew/2.3.rst:512
msgid ""
"log = logging.getLogger('server')\n"
" ...\n"
"log.info('Listening on port %i', port)\n"
" ...\n"
"log.critical('Disk full')\n"
" ..."
msgstr ""
"log = logging.getLogger('server')\n"
" ...\n"
"log.info('Listening on port %i', port)\n"
" ...\n"
"log.critical('Disk full')\n"
" ..."

#: ../../whatsnew/2.3.rst:519
msgid ""
"Log records are usually propagated up the hierarchy, so a message logged to "
"``server.auth`` is also seen by ``server`` and ``root``, but a :class:"
"`~logging.Logger` can prevent this by setting its :attr:`~logging.Logger."
"propagate` attribute to :const:`False`."
msgstr ""
"Записи журнала обычно распространяются вверх по иерархии, поэтому сообщение, "
"записанное на ``server.auth``, также видно ``server`` и ``root``, но :class:"
"`~logging.Logger` может предотвратить это можно сделать, установив для "
"атрибута :attr:`~logging.Logger.propagate` значение :const:`False`."

#: ../../whatsnew/2.3.rst:523
msgid ""
"There are more classes provided by the :mod:`logging` package that can be "
"customized.  When a :class:`~logging.Logger` instance is told to log a "
"message, it creates a :class:`~logging.LogRecord` instance that is sent to "
"any number of different :class:`~logging.Handler` instances.  Loggers and "
"handlers can also have an attached list of filters, and each filter can "
"cause the :class:`~logging.LogRecord` to be ignored or can modify the record "
"before passing it along.  When they're finally output, :class:`~logging."
"LogRecord` instances are converted to text by a :class:`~logging.Formatter` "
"class.  All of these classes can be replaced by your own specially written "
"classes."
msgstr ""
"В пакете :mod:`logging` есть дополнительные классы, которые можно настроить. "
"Когда экземпляру :class:`~logging.Logger` приказывают зарегистрировать "
"сообщение, он создает экземпляр :class:`~logging.LogRecord`, который "
"отправляется любому количеству различных экземпляров :class:`~logging."
"Handler` . Регистраторы и обработчики также могут иметь прикрепленный список "
"фильтров, и каждый фильтр может привести к игнорированию :class:`~logging."
"LogRecord` или к изменению записи перед ее передачей. Когда они наконец "
"выводятся, экземпляры :class:`~logging.LogRecord` преобразуются в текст с "
"помощью класса :class:`~logging.Formatter`. Все эти классы можно заменить "
"собственными, специально написанными классами."

#: ../../whatsnew/2.3.rst:533
msgid ""
"With all of these features the :mod:`logging` package should provide enough "
"flexibility for even the most complicated applications.  This is only an "
"incomplete overview of its features, so please see the package's reference "
"documentation for all of the details.  Reading :pep:`282` will also be "
"helpful."
msgstr ""
"Благодаря всем этим функциям пакет :mod:`logging` должен обеспечивать "
"достаточную гибкость даже для самых сложных приложений. Это лишь неполный "
"обзор его возможностей, поэтому все подробности смотрите в справочной "
"документации пакета. Чтение :pep:`282` также будет полезно."

#: ../../whatsnew/2.3.rst:541
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - Система журналирования"

#: ../../whatsnew/2.3.rst:542
msgid "Written by Vinay Sajip and Trent Mick; implemented by Vinay Sajip."
msgstr "Авторы сценария Винай Саджип и Трент Мик; реализован Винаем Саджипом."

#: ../../whatsnew/2.3.rst:550
msgid "PEP 285: A Boolean Type"
msgstr "PEP 285: логический тип"

#: ../../whatsnew/2.3.rst:552
msgid ""
"A Boolean type was added to Python 2.3.  Two new constants were added to "
"the :mod:`!__builtin__` module, :const:`True` and :const:`False`.  (:const:"
"`True` and :const:`False` constants were added to the built-ins in Python "
"2.2.1, but the 2.2.1 versions are simply set to integer values of 1 and 0 "
"and aren't a different type.)"
msgstr ""
"В Python 2.3 был добавлен логический тип. В модуль :mod:`!__builtin__` были "
"добавлены две новые константы: :const:`True` и :const:`False`. (Константы :"
"const:`True` и :const:`False` были добавлены во встроенные модули Python "
"2.2.1, но версии 2.2.1 просто устанавливают целочисленные значения 1 и 0 и "
"ничем не отличаются от них. тип.)"

#: ../../whatsnew/2.3.rst:558
msgid ""
"The type object for this new type is named :class:`bool`; the constructor "
"for it takes any Python value and converts it to :const:`True` or :const:"
"`False`. ::"
msgstr ""
"Объект типа для этого нового типа называется :class:`bool`; его конструктор "
"принимает любое значение Python и преобразует его в :const:`True` или :const:"
"`False`. ::"

#: ../../whatsnew/2.3.rst:561
msgid ""
">>> bool(1)\n"
"True\n"
">>> bool(0)\n"
"False\n"
">>> bool([])\n"
"False\n"
">>> bool( (1,) )\n"
"True"
msgstr ""
">>> bool(1)\n"
"True\n"
">>> bool(0)\n"
"False\n"
">>> bool([])\n"
"False\n"
">>> bool( (1,) )\n"
"True"

#: ../../whatsnew/2.3.rst:570
msgid ""
"Most of the standard library modules and built-in functions have been "
"changed to return Booleans. ::"
msgstr ""
"Большинство модулей стандартной библиотеки и встроенных функций были "
"изменены и теперь возвращают логические значения. ::"

#: ../../whatsnew/2.3.rst:573
msgid ""
">>> obj = []\n"
">>> hasattr(obj, 'append')\n"
"True\n"
">>> isinstance(obj, list)\n"
"True\n"
">>> isinstance(obj, tuple)\n"
"False"
msgstr ""
">>> obj = []\n"
">>> hasattr(obj, 'append')\n"
"True\n"
">>> isinstance(obj, list)\n"
"True\n"
">>> isinstance(obj, tuple)\n"
"False"

#: ../../whatsnew/2.3.rst:581
msgid ""
"Python's Booleans were added with the primary goal of making code clearer.  "
"For example, if you're reading a function and encounter the statement "
"``return 1``, you might wonder whether the ``1`` represents a Boolean truth "
"value, an index, or a coefficient that multiplies some other quantity.  If "
"the statement is ``return True``, however, the meaning of the return value "
"is quite clear."
msgstr ""
"Логические значения Python были добавлены с основной целью сделать код более "
"понятным. Например, если вы читаете функцию и встречаете оператор return 1, "
"вы можете задаться вопросом, представляет ли «1» логическое значение "
"истинности, индекс или коэффициент, который умножает какую-то другую "
"величину. Однако если оператор возвращает True, смысл возвращаемого значения "
"совершенно ясен."

#: ../../whatsnew/2.3.rst:587
msgid ""
"Python's Booleans were *not* added for the sake of strict type-checking.  A "
"very strict language such as Pascal would also prevent you performing "
"arithmetic with Booleans, and would require that the expression in an :"
"keyword:`if` statement always evaluate to a Boolean result.  Python is not "
"this strict and never will be, as :pep:`285` explicitly says.  This means "
"you can still use any expression in an :keyword:`!if` statement, even ones "
"that evaluate to a list or tuple or some random object.  The Boolean type is "
"a subclass of the :class:`int` class so that arithmetic using a Boolean "
"still works. ::"
msgstr ""
"Логические значения Python *не* были добавлены ради строгой проверки типов. "
"Очень строгий язык, такой как Паскаль, также не позволит вам выполнять "
"арифметические операции с логическими значениями и потребует, чтобы "
"выражение в операторе :keyword:`if` всегда приводило к логическому "
"результату. Python не настолько строг и никогда не будет таким строгим, как "
"прямо говорит :pep:`285`. Это означает, что вы по-прежнему можете "
"использовать любое выражение в операторе :keyword:`!if`, даже те, которые "
"оцениваются как список, кортеж или какой-либо случайный объект. Тип Boolean "
"является подклассом класса :class:`int`, поэтому арифметика с использованием "
"Boolean по-прежнему работает. ::"

#: ../../whatsnew/2.3.rst:596
msgid ""
">>> True + 1\n"
"2\n"
">>> False + 1\n"
"1\n"
">>> False * 75\n"
"0\n"
">>> True * 75\n"
"75"
msgstr ""
">>> True + 1\n"
"2\n"
">>> False + 1\n"
"1\n"
">>> False * 75\n"
"0\n"
">>> True * 75\n"
"75"

#: ../../whatsnew/2.3.rst:605
msgid ""
"To sum up :const:`True` and :const:`False` in a sentence: they're "
"alternative ways to spell the integer values 1 and 0, with the single "
"difference that :func:`str` and :func:`repr` return the strings ``'True'`` "
"and ``'False'`` instead of ``'1'`` and ``'0'``."
msgstr ""
"Подводя итог, :const:`True` и :const:`False` в одном предложении: это "
"альтернативные способы написания целочисленных значений 1 и 0, с той "
"единственной разницей, что :func:`str` и :func:` repr` возвращает строки "
"``'True'`` и ``'False'`` вместо ``'1'`` и ``'0'``."

#: ../../whatsnew/2.3.rst:613
msgid ":pep:`285` - Adding a bool type"
msgstr ":pep:`285` - Добавление типа bool"

#: ../../whatsnew/2.3.rst:614
msgid "Written and implemented by GvR."
msgstr "Написано и реализовано GvR."

#: ../../whatsnew/2.3.rst:620
msgid "PEP 293: Codec Error Handling Callbacks"
msgstr "PEP 293: обратные вызовы обработки ошибок кодека"

#: ../../whatsnew/2.3.rst:622
msgid ""
"When encoding a Unicode string into a byte string, unencodable characters "
"may be encountered.  So far, Python has allowed specifying the error "
"processing as either \"strict\" (raising :exc:`UnicodeError`), "
"\"ignore\" (skipping the character), or \"replace\" (using a question mark "
"in the output string), with \"strict\" being the default behavior. It may be "
"desirable to specify alternative processing of such errors, such as "
"inserting an XML character reference or HTML entity reference into the "
"converted string."
msgstr ""
"При кодировании строки Юникода в байтовую строку могут встретиться "
"некодируемые символы. До сих пор Python позволял определять обработку ошибок "
"как «строгую» (поднятие :exc:`UnicodeError`), «игнорировать» (пропускать "
"символ) или «заменять» (с использованием вопросительного знака в выходной "
"строке), с «строгий» — поведение по умолчанию. Может оказаться желательным "
"указать альтернативную обработку таких ошибок, например вставку ссылки на "
"символ XML или ссылку на объект HTML в преобразованную строку."

#: ../../whatsnew/2.3.rst:630
msgid ""
"Python now has a flexible framework to add different processing strategies.  "
"New error handlers can be added with :func:`codecs.register_error`, and "
"codecs then can access the error handler with :func:`codecs.lookup_error`. "
"An equivalent C API has been added for codecs written in C. The error "
"handler gets the necessary state information such as the string being "
"converted, the position in the string where the error was detected, and the "
"target encoding.  The handler can then either raise an exception or return a "
"replacement string."
msgstr ""
"Python теперь имеет гибкую структуру для добавления различных стратегий "
"обработки. Новые обработчики ошибок могут быть добавлены с помощью :func:"
"`codecs.register_error`, а затем кодеки смогут получить доступ к обработчику "
"ошибок с помощью :func:`codecs.lookup_error`. Для кодеков, написанных на C, "
"был добавлен эквивалентный API C. Обработчик ошибок получает необходимую "
"информацию о состоянии, такую ​​как преобразуемая строка, позиция в строке, "
"где была обнаружена ошибка, и целевая кодировка. Затем обработчик может либо "
"вызвать исключение, либо вернуть строку замены."

#: ../../whatsnew/2.3.rst:638
msgid ""
"Two additional error handlers have been implemented using this framework: "
"\"backslashreplace\" uses Python backslash quoting to represent unencodable "
"characters and \"xmlcharrefreplace\" emits XML character references."
msgstr ""
"С помощью этой платформы были реализованы два дополнительных обработчика "
"ошибок: «backslashreplace» использует обратную косую черту Python для "
"представления некодируемых символов, а «xmlcharrefreplace» выдает ссылки на "
"символы XML."

#: ../../whatsnew/2.3.rst:645
msgid ":pep:`293` - Codec Error Handling Callbacks"
msgstr ":pep:`293` - Обратные вызовы обработки ошибок кодека"

#: ../../whatsnew/2.3.rst:646
msgid "Written and implemented by Walter Dörwald."
msgstr "Написано и реализовано Вальтером Дорвальдом."

#: ../../whatsnew/2.3.rst:654
msgid "PEP 301: Package Index and Metadata for Distutils"
msgstr "PEP 301: Индекс пакета и метаданные для Distutils"

#: ../../whatsnew/2.3.rst:656
msgid ""
"Support for the long-requested Python catalog makes its first appearance in "
"2.3."
msgstr ""
"Поддержка давно запрошенного каталога Python впервые появилась в версии 2.3."

#: ../../whatsnew/2.3.rst:658
msgid ""
"The heart of the catalog is the new Distutils :command:`register` command. "
"Running ``python setup.py register`` will collect the metadata describing a "
"package, such as its name, version, maintainer, description, &c., and send "
"it to a central catalog server.  The resulting catalog is available from "
"https://pypi.org."
msgstr ""
"Сердцем каталога является новая команда Distutils :command:`register`. "
"Запуск ``python setup.py Register`` соберет метаданные, описывающие пакет, "
"такие как его имя, версия, сопровождающий, описание и т. д., и отправит их "
"на центральный сервер каталога. Полученный каталог доступен на https://pypi."
"org."

#: ../../whatsnew/2.3.rst:664
msgid ""
"To make the catalog a bit more useful, a new optional *classifiers* keyword "
"argument has been added to the Distutils :func:`!setup` function.  A list of "
"`Trove <http://catb.org/~esr/trove/>`_-style strings can be supplied to help "
"classify the software."
msgstr ""
"Чтобы сделать каталог более полезным, в функцию Distutils :func:`!setup` был "
"добавлен новый необязательный аргумент ключевого слова *classifiers*. Для "
"помощи в классификации программного обеспечения можно предоставить список "
"строк в стиле `Trove <http://catb.org/~esr/trove/>`_."

#: ../../whatsnew/2.3.rst:669
msgid ""
"Here's an example :file:`setup.py` with classifiers, written to be "
"compatible with older versions of the Distutils::"
msgstr ""
"Вот пример файла:`setup.py` с классификаторами, написанного для "
"совместимости со старыми версиями Distutils::"

#: ../../whatsnew/2.3.rst:672
msgid ""
"from distutils import core\n"
"kw = {'name': \"Quixote\",\n"
"      'version': \"0.5.1\",\n"
"      'description': \"A highly Pythonic Web application framework\",\n"
"      # ...\n"
"      }\n"
"\n"
"if (hasattr(core, 'setup_keywords') and\n"
"    'classifiers' in core.setup_keywords):\n"
"    kw['classifiers'] = \\\n"
"        ['Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n"
"         'Environment :: No Input/Output (Daemon)',\n"
"         'Intended Audience :: Developers'],\n"
"\n"
"core.setup(**kw)"
msgstr ""
"from distutils import core\n"
"kw = {'name': \"Quixote\",\n"
"      'version': \"0.5.1\",\n"
"      'description': \"A highly Pythonic Web application framework\",\n"
"      # ...\n"
"      }\n"
"\n"
"if (hasattr(core, 'setup_keywords') and\n"
"    'classifiers' in core.setup_keywords):\n"
"    kw['classifiers'] = \\\n"
"        ['Topic :: Internet :: WWW/HTTP :: Dynamic Content',\n"
"         'Environment :: No Input/Output (Daemon)',\n"
"         'Intended Audience :: Developers'],\n"
"\n"
"core.setup(**kw)"

#: ../../whatsnew/2.3.rst:688
msgid ""
"The full list of classifiers can be obtained by running  ``python setup.py "
"register --list-classifiers``."
msgstr ""
"Полный список классификаторов можно получить, запустив ``python setup.py "
"Register --list-classifiers``."

#: ../../whatsnew/2.3.rst:694
msgid ":pep:`301` - Package Index and Metadata for Distutils"
msgstr ":pep:`301` - Индекс пакетов и метаданные для Distutils"

#: ../../whatsnew/2.3.rst:695
msgid "Written and implemented by Richard Jones."
msgstr "Написано и реализовано Ричардом Джонсом."

#: ../../whatsnew/2.3.rst:703
msgid "PEP 302: New Import Hooks"
msgstr "PEP 302: новые крючки импорта"

#: ../../whatsnew/2.3.rst:705
msgid ""
"While it's been possible to write custom import hooks ever since the :mod:`!"
"ihooks` module was introduced in Python 1.3, no one has ever been really "
"happy with it because writing new import hooks is difficult and messy.  "
"There have been various proposed alternatives such as the :mod:`!imputil` "
"and :mod:`!iu` modules, but none of them has ever gained much acceptance, "
"and none of them were easily usable from C code."
msgstr ""
"Хотя писать собственные перехватчики импорта можно было с тех пор, как в "
"Python 1.3 был представлен модуль :mod:`!ihooks`, никто никогда не был этим "
"доволен, потому что написание новых перехватчиков импорта сложно и "
"запутанно. Были предложены различные альтернативы, такие как модули :mod:`!"
"imputil` и :mod:`!iu`, но ни один из них никогда не получил широкого "
"признания, и ни один из них нельзя было легко использовать из кода C."

#: ../../whatsnew/2.3.rst:712
msgid ""
":pep:`302` borrows ideas from its predecessors, especially from Gordon "
"McMillan's :mod:`!iu` module.  Three new items  are added to the :mod:`sys` "
"module:"
msgstr ""
":pep:`302` заимствует идеи у своих предшественников, особенно у модуля :mod:"
"`!iu` Гордона Макмиллана. В модуль :mod:`sys` добавлены три новых элемента:"

#: ../../whatsnew/2.3.rst:716
msgid ""
"``sys.path_hooks`` is a list of callable objects; most  often they'll be "
"classes.  Each callable takes a string containing a path and either returns "
"an importer object that will handle imports from this path or raises an :exc:"
"`ImportError` exception if it can't handle this path."
msgstr ""
"``sys.path_hooks`` — это список вызываемых объектов; чаще всего это будут "
"классы. Каждый вызываемый объект принимает строку, содержащую путь, и либо "
"возвращает объект импортера, который будет обрабатывать импорт по этому "
"пути, либо вызывает исключение :exc:`ImportError`, если он не может "
"обработать этот путь."

#: ../../whatsnew/2.3.rst:721
msgid ""
"``sys.path_importer_cache`` caches importer objects for each path, so ``sys."
"path_hooks`` will only need to be traversed once for each path."
msgstr ""
"``sys.path_importer_cache`` кэширует объекты импортера для каждого пути, "
"поэтому ``sys.path_hooks`` нужно будет пройти только один раз для каждого "
"пути."

#: ../../whatsnew/2.3.rst:724
msgid ""
"``sys.meta_path`` is a list of importer objects that will be traversed "
"before ``sys.path`` is checked.  This list is initially empty, but user code "
"can add objects to it.  Additional built-in and frozen modules can be "
"imported by an object added to this list."
msgstr ""
"``sys.meta_path`` — это список объектов импортера, которые будут пройдены до "
"проверки ``sys.path``. Этот список изначально пуст, но пользовательский код "
"может добавлять в него объекты. Дополнительные встроенные и замороженные "
"модули можно импортировать с помощью объекта, добавленного в этот список."

#: ../../whatsnew/2.3.rst:729
msgid ""
"Importer objects must have a single method, ``find_module(fullname, "
"path=None)``.  *fullname* will be a module or package name, e.g. ``string`` "
"or ``distutils.core``.  :meth:`!find_module` must return a loader object "
"that has a single method, ``load_module(fullname)``, that creates and "
"returns the corresponding module object."
msgstr ""
"Объекты импортера должны иметь единственный метод find_module(fullname, "
"path=None)``. *полное имя* будет именем модуля или пакета, например "
"``string`` или ``distutils.core``. :meth:`!find_module` должен возвращать "
"объект-загрузчик, имеющий единственный метод ``load_module(fullname)``, "
"который создает и возвращает соответствующий объект модуля."

#: ../../whatsnew/2.3.rst:735
msgid ""
"Pseudo-code for Python's new import logic, therefore, looks something like "
"this (simplified a bit; see :pep:`302` for the full details)::"
msgstr ""
"Таким образом, псевдокод новой логики импорта Python выглядит примерно так "
"(немного упрощенно; подробности см. в :pep:`302`)::"

#: ../../whatsnew/2.3.rst:738
msgid ""
"for mp in sys.meta_path:\n"
"    loader = mp(fullname)\n"
"    if loader is not None:\n"
"        <module> = loader.load_module(fullname)\n"
"\n"
"for path in sys.path:\n"
"    for hook in sys.path_hooks:\n"
"        try:\n"
"            importer = hook(path)\n"
"        except ImportError:\n"
"            # ImportError, so try the other path hooks\n"
"            pass\n"
"        else:\n"
"            loader = importer.find_module(fullname)\n"
"            <module> = loader.load_module(fullname)\n"
"\n"
"# Not found!\n"
"raise ImportError"
msgstr ""
"for mp in sys.meta_path:\n"
"    loader = mp(fullname)\n"
"    if loader is not None:\n"
"        <module> = loader.load_module(fullname)\n"
"\n"
"for path in sys.path:\n"
"    for hook in sys.path_hooks:\n"
"        try:\n"
"            importer = hook(path)\n"
"        except ImportError:\n"
"            # ImportError, so try the other path hooks\n"
"            pass\n"
"        else:\n"
"            loader = importer.find_module(fullname)\n"
"            <module> = loader.load_module(fullname)\n"
"\n"
"# Not found!\n"
"raise ImportError"

#: ../../whatsnew/2.3.rst:760
msgid ":pep:`302` - New Import Hooks"
msgstr ":pep:`302` - Новые хуки импорта"

#: ../../whatsnew/2.3.rst:761
msgid ""
"Written by Just van Rossum and Paul Moore. Implemented by Just van Rossum."
msgstr ""
"Авторы сценария Джаст ван Россум и Пол Мур. Реализован Джастом ван Россумом."

#: ../../whatsnew/2.3.rst:769
msgid "PEP 305: Comma-separated Files"
msgstr "PEP 305: файлы, разделенные запятыми"

#: ../../whatsnew/2.3.rst:771
msgid ""
"Comma-separated files are a format frequently used for exporting data from "
"databases and spreadsheets.  Python 2.3 adds a parser for comma-separated "
"files."
msgstr ""
"Файлы, разделенные запятыми, — это формат, часто используемый для экспорта "
"данных из баз данных и электронных таблиц. В Python 2.3 добавлен анализатор "
"файлов, разделенных запятыми."

#: ../../whatsnew/2.3.rst:774
msgid "Comma-separated format is deceptively simple at first glance::"
msgstr "Формат, разделенный запятыми, на первый взгляд обманчиво прост::"

#: ../../whatsnew/2.3.rst:776
msgid "Costs,150,200,3.95"
msgstr "Costs,150,200,3.95"

#: ../../whatsnew/2.3.rst:778
msgid ""
"Read a line and call ``line.split(',')``: what could be simpler? But toss in "
"string data that can contain commas, and things get more complicated::"
msgstr ""
"Прочитайте строку и вызовите ``line.split(',')``: что может быть проще? Но "
"если добавить строковые данные, которые могут содержать запятые, ситуация "
"усложнится:"

#: ../../whatsnew/2.3.rst:781
msgid "\"Costs\",150,200,3.95,\"Includes taxes, shipping, and sundry items\""
msgstr "«Расходы», 150,200,3,95, «Включает налоги, доставку и прочие расходы»"

#: ../../whatsnew/2.3.rst:783
msgid ""
"A big ugly regular expression can parse this, but using the new  :mod:`csv` "
"package is much simpler::"
msgstr ""
"Это можно разобрать с помощью большого уродливого регулярного выражения, но "
"использовать новый пакет :mod:`csv` гораздо проще::"

#: ../../whatsnew/2.3.rst:786
msgid ""
"import csv\n"
"\n"
"input = open('datafile', 'rb')\n"
"reader = csv.reader(input)\n"
"for line in reader:\n"
"    print line"
msgstr ""
"import csv\n"
"\n"
"input = open('datafile', 'rb')\n"
"reader = csv.reader(input)\n"
"for line in reader:\n"
"    print line"

#: ../../whatsnew/2.3.rst:793
msgid ""
"The :func:`~csv.reader` function takes a number of different options. The "
"field separator isn't limited to the comma and can be changed to any "
"character, and so can the quoting and line-ending characters."
msgstr ""
"Функция :func:`~csv.reader` принимает несколько различных опций. Разделитель "
"полей не ограничивается запятой и может быть заменен на любой символ, как и "
"символы кавычек и конца строки."

#: ../../whatsnew/2.3.rst:797
msgid ""
"Different dialects of comma-separated files can be defined and registered; "
"currently there are two dialects, both used by Microsoft Excel. A separate :"
"class:`csv.writer` class will generate comma-separated files from a "
"succession of tuples or lists, quoting strings that contain the delimiter."
msgstr ""
"Могут быть определены и зарегистрированы различные диалекты файлов, "
"разделенных запятыми; в настоящее время существует два диалекта, оба из "
"которых используются в Microsoft Excel. Отдельный класс :class:`csv.writer` "
"будет генерировать файлы, разделенные запятыми, из последовательности "
"кортежей или списков, заключая в кавычки строки, содержащие разделитель."

#: ../../whatsnew/2.3.rst:805
msgid ":pep:`305` - CSV File API"
msgstr ":pep:`305` - API CSV-файлов"

#: ../../whatsnew/2.3.rst:806
msgid ""
"Written and implemented  by Kevin Altis, Dave Cole, Andrew McNamara, Skip "
"Montanaro, Cliff Wells."
msgstr ""
"Написано и реализовано Кевином Алтисом, Дэйвом Коулом, Эндрю Макнамарой, "
"Скипом Монтанаро, Клиффом Уэллсом."

#: ../../whatsnew/2.3.rst:815
msgid "PEP 307: Pickle Enhancements"
msgstr "PEP 307: Улучшения Pickle"

#: ../../whatsnew/2.3.rst:817
msgid ""
"The :mod:`pickle` and :mod:`!cPickle` modules received some attention during "
"the 2.3 development cycle.  In 2.2, new-style classes could be pickled "
"without difficulty, but they weren't pickled very compactly; :pep:`307` "
"quotes a trivial example where a new-style class results in a pickled string "
"three times longer than that for a classic class."
msgstr ""
"Модулям :mod:`pickle` и :mod:`!cPickle` уделялось некоторое внимание во "
"время цикла разработки 2.3. В версии 2.2 классы нового стиля можно было "
"мариновать без труда, но они мариновались не очень компактно; :pep:`307` "
"приводит тривиальный пример, когда класс нового стиля приводит к "
"маринованной строке в три раза длиннее, чем у классического класса."

#: ../../whatsnew/2.3.rst:823
msgid ""
"The solution was to invent a new pickle protocol.  The :func:`pickle.dumps` "
"function has supported a text-or-binary flag  for a long time.  In 2.3, this "
"flag is redefined from a Boolean to an integer: 0 is the old text-mode "
"pickle format, 1 is the old binary format, and now 2 is a new 2.3-specific "
"format.  A new constant, :const:`pickle.HIGHEST_PROTOCOL`, can be used to "
"select the fanciest protocol available."
msgstr ""
"Решением было изобрести новый протокол рассола. Функция :func:`pickle.dumps` "
"уже давно поддерживает текстовый или двоичный флаг. В версии 2.3 этот флаг "
"переопределен с логического на целое число: 0 — старый формат Pickle для "
"текстового режима, 1 — старый двоичный формат, а теперь 2 — новый формат, "
"специфичный для версии 2.3. Новую константу :const:`pickle.HIGHEST_PROTOCOL` "
"можно использовать для выбора самого сложного доступного протокола."

#: ../../whatsnew/2.3.rst:830
msgid ""
"Unpickling is no longer considered a safe operation.  2.2's :mod:`pickle` "
"provided hooks for trying to prevent unsafe classes from being unpickled "
"(specifically, a :attr:`!__safe_for_unpickling__` attribute), but none of "
"this code was ever audited and therefore it's all been ripped out in 2.3.  "
"You should not unpickle untrusted data in any version of Python."
msgstr ""
"Расмаринование больше не считается безопасной операцией. В :mod:`pickle` "
"версии 2.2 предусмотрены перехватчики для предотвращения распаковки "
"небезопасных классов (в частности, атрибут :attr:`!"
"__safe_for_unpickling__`), но ни один из этих кодов никогда не проверялся, и "
"поэтому весь этот код был удален в 2.3. Не следует отключать ненадежные "
"данные ни в одной версии Python."

#: ../../whatsnew/2.3.rst:836
msgid ""
"To reduce the pickling overhead for new-style classes, a new interface for "
"customizing pickling was added using three special methods: :meth:`~object."
"__getstate__`, :meth:`~object.__setstate__`, and :meth:`~object."
"__getnewargs__`.  Consult :pep:`307` for the full semantics  of these "
"methods."
msgstr ""
"Чтобы уменьшить накладные расходы на травление для классов нового стиля, был "
"добавлен новый интерфейс для настройки травления с использованием трех "
"специальных методов: :meth:`~object.__getstate__`, :meth:`~object."
"__setstate__` и :meth:`~ object.__getnewargs__`. Обратитесь к :pep:`307` для "
"получения полной семантики этих методов."

#: ../../whatsnew/2.3.rst:841
msgid ""
"As a way to compress pickles yet further, it's now possible to use integer "
"codes instead of long strings to identify pickled classes. The Python "
"Software Foundation will maintain a list of standardized codes; there's also "
"a range of codes for private use.  Currently no codes have been specified."
msgstr ""
"В качестве способа еще большего сжатия маринованных классов теперь можно "
"использовать целочисленные коды вместо длинных строк для идентификации "
"маринованных классов. Python Software Foundation будет поддерживать список "
"стандартизированных кодов; есть также ряд кодов для частного использования. "
"На данный момент коды не указаны."

#: ../../whatsnew/2.3.rst:849
msgid ":pep:`307` - Extensions to the pickle protocol"
msgstr ":pep:`307` - Расширения протокола рассола"

#: ../../whatsnew/2.3.rst:850
msgid "Written and implemented  by Guido van Rossum and Tim Peters."
msgstr "Написано и реализовано Гвидо ван Россумом и Тимом Питерсом."

#: ../../whatsnew/2.3.rst:858
msgid "Extended Slices"
msgstr "Расширенные срезы"

#: ../../whatsnew/2.3.rst:860
msgid ""
"Ever since Python 1.4, the slicing syntax has supported an optional third "
"\"step\" or \"stride\" argument.  For example, these are all legal Python "
"syntax: ``L[1:10:2]``, ``L[:-1:1]``, ``L[::-1]``.  This was added to Python "
"at the request of the developers of Numerical Python, which uses the third "
"argument extensively.  However, Python's built-in list, tuple, and string "
"sequence types have never supported this feature, raising a :exc:`TypeError` "
"if you tried it. Michael Hudson contributed a patch to fix this shortcoming."
msgstr ""
"Начиная с Python 1.4, синтаксис срезов поддерживает необязательный третий "
"аргумент «шаг» или «шаг». Например, это все допустимые синтаксисы Python: "
"``L[1:10:2]``, ``L[:-1:1]``, ``L[::-1]``. Это было добавлено в Python по "
"просьбе разработчиков Numerical Python, который широко использует третий "
"аргумент. Однако встроенные в Python типы последовательностей списков, "
"кортежей и строк никогда не поддерживали эту функцию, что вызывало ошибку :"
"exc:`TypeError`, если вы попробовали ее. Майкл Хадсон предоставил патч, "
"исправляющий этот недостаток."

#: ../../whatsnew/2.3.rst:868
msgid ""
"For example, you can now easily extract the elements of a list that have "
"even indexes::"
msgstr ""
"Например, теперь вы можете легко извлечь элементы списка, имеющие четные "
"индексы:"

#: ../../whatsnew/2.3.rst:871
msgid ""
">>> L = range(10)\n"
">>> L[::2]\n"
"[0, 2, 4, 6, 8]"
msgstr ""
">>> L = range(10)\n"
">>> L[::2]\n"
"[0, 2, 4, 6, 8]"

#: ../../whatsnew/2.3.rst:875
msgid ""
"Negative values also work to make a copy of the same list in reverse order::"
msgstr ""
"Отрицательные значения также позволяют создать копию того же списка в "
"обратном порядке:"

#: ../../whatsnew/2.3.rst:877
msgid ""
">>> L[::-1]\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
msgstr ""
">>> L[::-1]\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"

#: ../../whatsnew/2.3.rst:880
msgid "This also works for tuples, arrays, and strings::"
msgstr "Это также работает для кортежей, массивов и строк:"

#: ../../whatsnew/2.3.rst:882
msgid ""
">>> s='abcd'\n"
">>> s[::2]\n"
"'ac'\n"
">>> s[::-1]\n"
"'dcba'"
msgstr ""
">>> s='abcd'\n"
">>> s[::2]\n"
"'ac'\n"
">>> s[::-1]\n"
"'dcba'"

#: ../../whatsnew/2.3.rst:888
msgid ""
"If you have a mutable sequence such as a list or an array you can assign to "
"or delete an extended slice, but there are some differences between "
"assignment to extended and regular slices.  Assignment to a regular slice "
"can be used to change the length of the sequence::"
msgstr ""
"Если у вас есть изменяемая последовательность, такая как список или массив, "
"вы можете назначить или удалить расширенный фрагмент, но между назначением "
"расширенным и обычным фрагментам есть некоторые различия. Присвоение "
"обычному срезу можно использовать для изменения длины последовательности:"

#: ../../whatsnew/2.3.rst:893
msgid ""
">>> a = range(3)\n"
">>> a\n"
"[0, 1, 2]\n"
">>> a[1:3] = [4, 5, 6]\n"
">>> a\n"
"[0, 4, 5, 6]"
msgstr ""
">>> a = range(3)\n"
">>> a\n"
"[0, 1, 2]\n"
">>> a[1:3] = [4, 5, 6]\n"
">>> a\n"
"[0, 4, 5, 6]"

#: ../../whatsnew/2.3.rst:900
msgid ""
"Extended slices aren't this flexible.  When assigning to an extended slice, "
"the list on the right hand side of the statement must contain the same "
"number of items as the slice it is replacing::"
msgstr ""
"Расширенные фрагменты не настолько гибки. При присвоении расширенному срезу "
"список в правой части оператора должен содержать то же количество элементов, "
"что и срез, который он заменяет:"

#: ../../whatsnew/2.3.rst:904
msgid ""
">>> a = range(4)\n"
">>> a\n"
"[0, 1, 2, 3]\n"
">>> a[::2]\n"
"[0, 2]\n"
">>> a[::2] = [0, -1]\n"
">>> a\n"
"[0, 1, -1, 3]\n"
">>> a[::2] = [0,1,2]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: attempt to assign sequence of size 3 to extended slice of size 2"
msgstr ""
">>> a = range(4)\n"
">>> a\n"
"[0, 1, 2, 3]\n"
">>> a[::2]\n"
"[0, 2]\n"
">>> a[::2] = [0, -1]\n"
">>> a\n"
"[0, 1, -1, 3]\n"
">>> a[::2] = [0,1,2]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: attempt to assign sequence of size 3 to extended slice of size 2"

#: ../../whatsnew/2.3.rst:917
msgid "Deletion is more straightforward::"
msgstr "Удаление проще:"

#: ../../whatsnew/2.3.rst:919
msgid ""
">>> a = range(4)\n"
">>> a\n"
"[0, 1, 2, 3]\n"
">>> a[::2]\n"
"[0, 2]\n"
">>> del a[::2]\n"
">>> a\n"
"[1, 3]"
msgstr ""
">>> a = range(4)\n"
">>> a\n"
"[0, 1, 2, 3]\n"
">>> a[::2]\n"
"[0, 2]\n"
">>> del a[::2]\n"
">>> a\n"
"[1, 3]"

#: ../../whatsnew/2.3.rst:928
msgid ""
"One can also now pass slice objects to the :meth:`~object.__getitem__` "
"methods of the built-in sequences::"
msgstr ""
"Теперь можно также передавать объекты среза в методы :meth:`~object."
"__getitem__` встроенных последовательностей::"

#: ../../whatsnew/2.3.rst:931
msgid ""
">>> range(10).__getitem__(slice(0, 5, 2))\n"
"[0, 2, 4]"
msgstr ""
">>> range(10).__getitem__(slice(0, 5, 2))\n"
"[0, 2, 4]"

#: ../../whatsnew/2.3.rst:934
msgid "Or use slice objects directly in subscripts::"
msgstr "Или используйте объекты срезов непосредственно в индексах::"

#: ../../whatsnew/2.3.rst:936
msgid ""
">>> range(10)[slice(0, 5, 2)]\n"
"[0, 2, 4]"
msgstr ""
">>> range(10)[slice(0, 5, 2)]\n"
"[0, 2, 4]"

#: ../../whatsnew/2.3.rst:939
msgid ""
"To simplify implementing sequences that support extended slicing, slice "
"objects now have a method ``indices(length)`` which, given the length of a "
"sequence, returns a ``(start, stop, step)`` tuple that can be passed "
"directly to :func:`range`. :meth:`!indices` handles omitted and out-of-"
"bounds indices in a manner consistent with regular slices (and this "
"innocuous phrase hides a welter of confusing details!).  The method is "
"intended to be used like this::"
msgstr ""
"Чтобы упростить реализацию последовательностей, поддерживающих расширенную "
"срезку, объекты срезов теперь имеют метод indexes(length)``, который, "
"учитывая длину последовательности, возвращает кортеж ``(start, stop, "
"Step)``, который можно передать непосредственно в :func:`range`. :meth:`!"
"indices` обрабатывает пропущенные и выходящие за пределы индексы способом, "
"соответствующим обычным срезам (и эта безобидная фраза скрывает массу "
"запутанных деталей!). Этот метод предназначен для использования следующим "
"образом:"

#: ../../whatsnew/2.3.rst:946
msgid ""
"class FakeSeq:\n"
"    ...\n"
"    def calc_item(self, i):\n"
"        ...\n"
"    def __getitem__(self, item):\n"
"        if isinstance(item, slice):\n"
"            indices = item.indices(len(self))\n"
"            return FakeSeq([self.calc_item(i) for i in range(*indices)])\n"
"        else:\n"
"            return self.calc_item(i)"
msgstr ""
"class FakeSeq:\n"
"    ...\n"
"    def calc_item(self, i):\n"
"        ...\n"
"    def __getitem__(self, item):\n"
"        if isinstance(item, slice):\n"
"            indices = item.indices(len(self))\n"
"            return FakeSeq([self.calc_item(i) for i in range(*indices)])\n"
"        else:\n"
"            return self.calc_item(i)"

#: ../../whatsnew/2.3.rst:957
msgid ""
"From this example you can also see that the built-in :class:`slice` object "
"is now the type object for the slice type, and is no longer a function.  "
"This is consistent with Python 2.2, where :class:`int`, :class:`str`, etc., "
"underwent the same change."
msgstr ""
"Из этого примера вы также можете видеть, что встроенный объект :class:"
"`slice` теперь является объектом типа для типа среза и больше не является "
"функцией. Это соответствует Python 2.2, где :class:`int`, :class:`str` и т. "
"д. претерпели те же изменения."

#: ../../whatsnew/2.3.rst:966
msgid "Other Language Changes"
msgstr "Другие языковые изменения"

#: ../../whatsnew/2.3.rst:968
msgid ""
"Here are all of the changes that Python 2.3 makes to the core Python "
"language."
msgstr "Вот все изменения, которые Python 2.3 вносит в основной язык Python."

#: ../../whatsnew/2.3.rst:970
msgid ""
"The :keyword:`yield` statement is now always a keyword, as described in "
"section :ref:`section-generators` of this document."
msgstr ""
"Оператор :keyword:`yield` теперь всегда является ключевым словом, как "
"описано в разделе :ref:`section-generators` этого документа."

#: ../../whatsnew/2.3.rst:973
msgid ""
"A new built-in function :func:`enumerate` was added, as described in "
"section :ref:`section-enumerate` of this document."
msgstr ""
"Была добавлена ​​новая встроенная функция :func:`enumerate`, как описано в "
"разделе :ref:`section-enumerate` этого документа."

#: ../../whatsnew/2.3.rst:976
msgid ""
"Two new constants, :const:`True` and :const:`False` were added along with "
"the built-in :class:`bool` type, as described in section :ref:`section-bool` "
"of this document."
msgstr ""
"Две новые константы: :const:`True` и :const:`False` были добавлены вместе со "
"встроенным типом :class:`bool`, как описано в разделе :ref:`section-bool` "
"этого документа."

#: ../../whatsnew/2.3.rst:980
msgid ""
"The :func:`int` type constructor will now return a long integer instead of "
"raising an :exc:`OverflowError` when a string or floating-point number is "
"too large to fit into an integer.  This can lead to the paradoxical result "
"that ``isinstance(int(expression), int)`` is false, but that seems unlikely "
"to cause problems in practice."
msgstr ""
"Конструктор типа :func:`int` теперь будет возвращать длинное целое число "
"вместо вызова :exc:`OverflowError`, когда строка или число с плавающей "
"запятой слишком велики, чтобы поместиться в целое число. Это может привести "
"к парадоксальному результату: ``isinstance(int(expression), int)`` является "
"ложным, но вряд ли это вызовет проблемы на практике."

#: ../../whatsnew/2.3.rst:986
msgid ""
"Built-in types now support the extended slicing syntax, as described in "
"section :ref:`section-slices` of this document."
msgstr ""
"Встроенные типы теперь поддерживают расширенный синтаксис срезов, как "
"описано в разделе :ref:`section-slices` этого документа."

#: ../../whatsnew/2.3.rst:989
msgid ""
"A new built-in function, ``sum(iterable, start=0)``,  adds up the numeric "
"items in the iterable object and returns their sum.  :func:`sum` only "
"accepts numbers, meaning that you can't use it to concatenate a bunch of "
"strings. (Contributed by Alex Martelli.)"
msgstr ""
"Новая встроенная функция sum(iterable, start=0) складывает числовые элементы "
"в итерируемом объекте и возвращает их сумму. :func:`sum` принимает только "
"числа, а это означает, что вы не можете использовать ее для объединения "
"нескольких строк. (Предоставлено Алексом Мартелли.)"

#: ../../whatsnew/2.3.rst:994
msgid ""
"``list.insert(pos, value)`` used to  insert *value* at the front of the list "
"when *pos* was negative.  The behaviour has now been changed to be "
"consistent with slice indexing, so when *pos* is -1 the value will be "
"inserted before the last element, and so forth."
msgstr ""
"``list.insert(pos, value)`` используется для вставки *value* в начале "
"списка, когда *pos* имеет отрицательное значение. Поведение теперь изменено, "
"чтобы соответствовать индексации срезов, поэтому, когда *pos* равно -1, "
"значение будет вставлено перед последним элементом и так далее."

#: ../../whatsnew/2.3.rst:999
msgid ""
"``list.index(value)``, which searches for *value*  within the list and "
"returns its index, now takes optional  *start* and *stop* arguments to limit "
"the search to  only part of the list."
msgstr ""
"``list.index(value)``, который ищет *value* в списке и возвращает его "
"индекс, теперь принимает дополнительные аргументы *start* и *stop*, чтобы "
"ограничить поиск только частью списка."

#: ../../whatsnew/2.3.rst:1003
msgid ""
"Dictionaries have a new method, ``pop(key[, *default*])``, that returns the "
"value corresponding to *key* and removes that key/value pair from the "
"dictionary.  If the requested key isn't present in the dictionary, *default* "
"is returned if it's specified and :exc:`KeyError` raised if it isn't. ::"
msgstr ""
"В словарях появился новый метод pop(key[, *default*])``, который возвращает "
"значение, соответствующее *key*, и удаляет эту пару ключ/значение из "
"словаря. Если запрошенный ключ отсутствует в словаре, возвращается "
"*default*, если он указан, и выдается :exc:`KeyError`, если его нет. ::"

#: ../../whatsnew/2.3.rst:1008
msgid ""
">>> d = {1:2}\n"
">>> d\n"
"{1: 2}\n"
">>> d.pop(4)\n"
"Traceback (most recent call last):\n"
"  File \"stdin\", line 1, in ?\n"
"KeyError: 4\n"
">>> d.pop(1)\n"
"2\n"
">>> d.pop(1)\n"
"Traceback (most recent call last):\n"
"  File \"stdin\", line 1, in ?\n"
"KeyError: 'pop(): dictionary is empty'\n"
">>> d\n"
"{}\n"
">>>"
msgstr ""
">>> d = {1:2}\n"
">>> d\n"
"{1: 2}\n"
">>> d.pop(4)\n"
"Traceback (most recent call last):\n"
"  File \"stdin\", line 1, in ?\n"
"KeyError: 4\n"
">>> d.pop(1)\n"
"2\n"
">>> d.pop(1)\n"
"Traceback (most recent call last):\n"
"  File \"stdin\", line 1, in ?\n"
"KeyError: 'pop(): dictionary is empty'\n"
">>> d\n"
"{}\n"
">>>"

#: ../../whatsnew/2.3.rst:1025
msgid ""
"There's also a new class method,  ``dict.fromkeys(iterable, value)``, that "
"creates a dictionary with keys taken from the supplied iterator *iterable* "
"and all values set to *value*, defaulting to ``None``."
msgstr ""
"Также имеется новый метод класса ``dict.fromkeys(iterable, value)``, который "
"создает словарь с ключами, взятыми из предоставленного итератора *iterable*, "
"и всеми значениями, установленными в *value*, по умолчанию — ``None`` ."

#: ../../whatsnew/2.3.rst:1029
msgid "(Patches contributed by Raymond Hettinger.)"
msgstr "(Патчи предоставлены Рэймондом Хеттингером.)"

#: ../../whatsnew/2.3.rst:1031
msgid ""
"Also, the :func:`dict` constructor now accepts keyword arguments to simplify "
"creating small dictionaries::"
msgstr ""
"Кроме того, конструктор :func:`dict` теперь принимает аргументы ключевых "
"слов, чтобы упростить создание небольших словарей::"

#: ../../whatsnew/2.3.rst:1034
msgid ""
">>> dict(red=1, blue=2, green=3, black=4)\n"
"{'blue': 2, 'black': 4, 'green': 3, 'red': 1}"
msgstr ""
">>> dict(red=1, blue=2, green=3, black=4)\n"
"{'blue': 2, 'black': 4, 'green': 3, 'red': 1}"

#: ../../whatsnew/2.3.rst:1037
msgid "(Contributed by Just van Rossum.)"
msgstr "(Предоставлено Джастом ван Россумом.)"

#: ../../whatsnew/2.3.rst:1039
msgid ""
"The :keyword:`assert` statement no longer checks the ``__debug__`` flag, so "
"you can no longer disable assertions by assigning to ``__debug__``. Running "
"Python with the :option:`-O` switch will still generate code that doesn't "
"execute any assertions."
msgstr ""
"Оператор :keyword:`assert` больше не проверяет флаг ``__debug__``, поэтому "
"вы больше не можете отключить утверждения, назначив его ``__debug__``. "
"Запуск Python с ключом :option:`-O` по-прежнему будет генерировать код, "
"который не выполняет никаких утверждений."

#: ../../whatsnew/2.3.rst:1044
msgid ""
"Most type objects are now callable, so you can use them to create new "
"objects such as functions, classes, and modules.  (This means that the :mod:"
"`!new` module can be deprecated in a future Python version, because you can "
"now use the type objects available in the :mod:`types` module.) For example, "
"you can create a new module object with the following code:"
msgstr ""
"Большинство объектов типов теперь являются вызываемыми, поэтому их можно "
"использовать для создания новых объектов, таких как функции, классы и "
"модули. (Это означает, что модуль :mod:`!new` может быть объявлен устаревшим "
"в будущей версии Python, поскольку теперь вы можете использовать объекты "
"типов, доступные в модуле :mod:`types`.) Например, вы можете создать новый "
"объект модуля со следующим кодом:"

#: ../../whatsnew/2.3.rst:1052
msgid ""
">>> import types\n"
">>> m = types.ModuleType('abc','docstring')\n"
">>> m\n"
"<module 'abc' (built-in)>\n"
">>> m.__doc__\n"
"'docstring'"
msgstr ""
">>> import types\n"
">>> m = types.ModuleType('abc','docstring')\n"
">>> m\n"
"<module 'abc' (built-in)>\n"
">>> m.__doc__\n"
"'docstring'"

#: ../../whatsnew/2.3.rst:1059
msgid ""
"A new warning, :exc:`PendingDeprecationWarning` was added to indicate "
"features which are in the process of being deprecated.  The warning will "
"*not* be printed by default.  To check for use of features that will be "
"deprecated in the future, supply :option:`-Walways::"
"PendingDeprecationWarning:: <-W>` on the command line or use :func:`warnings."
"filterwarnings`."
msgstr ""
"Было добавлено новое предупреждение :exc:`PendingDeprecationWarning` для "
"обозначения функций, которые устаревают. Предупреждение *не* печатается по "
"умолчанию. Чтобы проверить использование функций, которые в будущем станут "
"устаревшими, укажите :option:`-Walways::PendingDeprecationWarning:: <-W>` в "
"командной строке или используйте :func:`warnings.filterwarnings`."

#: ../../whatsnew/2.3.rst:1065
msgid ""
"The process of deprecating string-based exceptions, as in ``raise \"Error "
"occurred\"``, has begun.  Raising a string will now trigger :exc:"
"`PendingDeprecationWarning`."
msgstr ""
"Начался процесс прекращения поддержки строковых исключений, как в случае с "
"сообщением «Произошла ошибка». Подъем строки теперь вызывает :exc:"
"`PendingDeprecationWarning`."

#: ../../whatsnew/2.3.rst:1069
msgid ""
"Using ``None`` as a variable name will now result in a :exc:`SyntaxWarning` "
"warning.  In a future version of Python, ``None`` may finally become a "
"keyword."
msgstr ""
"Использование None в качестве имени переменной теперь приведет к "
"предупреждению :exc:`SyntaxWarning`. В будущей версии Python слово None "
"может наконец стать ключевым словом."

#: ../../whatsnew/2.3.rst:1072
msgid ""
"The :meth:`!xreadlines` method of file objects, introduced in Python 2.1, is "
"no longer necessary because files now behave as their own iterator. :meth:`!"
"xreadlines` was originally introduced as a faster way to loop over all the "
"lines in a file, but now you can simply write ``for line in file_obj``. File "
"objects also have a new read-only :attr:`!encoding` attribute that gives the "
"encoding used by the file; Unicode strings written to the file will be "
"automatically  converted to bytes using the given encoding."
msgstr ""
"Метод файловых объектов :meth:`!xreadlines`, представленный в Python 2.1, "
"больше не нужен, поскольку файлы теперь ведут себя как собственный "
"итератор. :meth:`!xreadlines` изначально был представлен как более быстрый "
"способ перебора всех строк в файле, но теперь вы можете просто написать "
"``for line in file_obj``. Файловые объекты также имеют новый атрибут :attr:`!"
"encoding`, доступный только для чтения, который указывает кодировку, "
"используемую файлом; Строки Юникода, записанные в файл, будут автоматически "
"преобразованы в байты с использованием заданной кодировки."

#: ../../whatsnew/2.3.rst:1080
msgid ""
"The method resolution order used by new-style classes has changed, though "
"you'll only notice the difference if you have a really complicated "
"inheritance hierarchy.  Classic classes are unaffected by this change.  "
"Python 2.2 originally used a topological sort of a class's ancestors, but "
"2.3 now uses the C3 algorithm as described in the paper `\"A Monotonic "
"Superclass Linearization for Dylan\" <https://citeseerx.ist.psu.edu/viewdoc/"
"summary?doi=10.1.1.19.3910>`_. To understand the motivation for this "
"change,  read Michele Simionato's article :ref:`python_2.3_mro`, or read the "
"thread on python-dev starting with the message at https://mail.python.org/"
"pipermail/python-dev/2002-October/029035.html. Samuele Pedroni first pointed "
"out the problem and also implemented the fix by coding the C3 algorithm."
msgstr ""
"Порядок разрешения методов, используемый классами нового стиля, изменился, "
"хотя вы заметите разницу только в том случае, если у вас действительно "
"сложная иерархия наследования. Классические классы не затронуты этим "
"изменением. Python 2.2 изначально использовал топологическую разновидность "
"предков класса, но теперь 2.3 использует алгоритм C3, как описано в статье "
"«Монотонная линеаризация суперкласса для Дилана» <https://citeseerx.ist.psu."
"edu/viewdoc/summary? doi=10.1.1.19.3910>`_. Чтобы понять мотивацию этого "
"изменения, прочитайте статью Микеле Симионато :ref:`python_2.3_mro` или "
"прочитайте ветку на python-dev, начинающуюся с сообщения по адресу https://"
"mail.python.org/pipermail/python-dev/. 2002-октябрь/029035.html. Самуэле "
"Педрони первым указал на проблему, а также реализовал ее исправление, "
"написав алгоритм C3."

#: ../../whatsnew/2.3.rst:1093
msgid ""
"Python runs multithreaded programs by switching between threads after "
"executing N bytecodes.  The default value for N has been increased from 10 "
"to 100 bytecodes, speeding up single-threaded applications by reducing the "
"switching overhead.  Some multithreaded applications may suffer slower "
"response time, but that's easily fixed by setting the limit back to a lower "
"number using ``sys.setcheckinterval(N)``. The limit can be retrieved with "
"the new :func:`!sys.getcheckinterval` function."
msgstr ""
"Python запускает многопоточные программы, переключаясь между потоками после "
"выполнения N байт-кодов. Значение по умолчанию для N было увеличено с 10 до "
"100 байт-кодов, что ускоряет работу однопоточных приложений за счет снижения "
"затрат на переключение. Некоторые многопоточные приложения могут иметь более "
"медленное время отклика, но это легко исправить, установив ограничение на "
"меньшее значение с помощью ``sys.setcheckinterval(N)``. Предел можно "
"получить с помощью новой функции :func:`!sys.getcheckinterval`."

#: ../../whatsnew/2.3.rst:1101
msgid ""
"One minor but far-reaching change is that the names of extension types "
"defined by the modules included with Python now contain the module and a "
"``'.'`` in front of the type name.  For example, in Python 2.2, if you "
"created a socket and printed its :attr:`!__class__`, you'd get this output::"
msgstr ""
"Одно незначительное, но далеко идущее изменение заключается в том, что имена "
"типов расширений, определенных модулями, включенными в Python, теперь "
"содержат модуль и ``'.'`` перед именем типа. Например, в Python 2.2, если вы "
"создали сокет и напечатали его :attr:`!__class__`, вы получите следующий "
"вывод:"

#: ../../whatsnew/2.3.rst:1106
msgid ""
">>> s = socket.socket()\n"
">>> s.__class__\n"
"<type 'socket'>"
msgstr ""
">>> s = socket.socket()\n"
">>> s.__class__\n"
"<type 'socket'>"

#: ../../whatsnew/2.3.rst:1110
msgid "In 2.3, you get this::"
msgstr "В версии 2.3 вы получите следующее:"

#: ../../whatsnew/2.3.rst:1112
msgid ""
">>> s.__class__\n"
"<type '_socket.socket'>"
msgstr ""
">>> s.__class__\n"
"<type '_socket.socket'>"

#: ../../whatsnew/2.3.rst:1115
msgid ""
"One of the noted incompatibilities between old- and new-style classes has "
"been removed: you can now assign to the :attr:`~type.__name__` and :attr:"
"`~type.__bases__` attributes of new-style classes.  There are some "
"restrictions on what can be assigned to :attr:`!__bases__` along the lines "
"of those relating to assigning to an instance's :attr:`~object.__class__` "
"attribute."
msgstr ""
"Одна из отмеченных несовместимостей между классами старого и нового стиля "
"была устранена: теперь вы можете назначать атрибуты :attr:`~type.__name__` "
"и :attr:`~type.__bases__` классов нового стиля. Существуют некоторые "
"ограничения на то, что может быть присвоено :attr:`!__bases__`, аналогично "
"тем, которые относятся к присвоению атрибуту :attr:`~object.__class__` "
"экземпляра."

#: ../../whatsnew/2.3.rst:1125
msgid "String Changes"
msgstr "Изменения в строке"

#: ../../whatsnew/2.3.rst:1127
msgid ""
"The :keyword:`in` operator now works differently for strings. Previously, "
"when evaluating ``X in Y`` where *X* and *Y* are strings, *X* could only be "
"a single character. That's now changed; *X* can be a string of any length, "
"and ``X in Y`` will return :const:`True` if *X* is a substring of *Y*.  If "
"*X* is the empty string, the result is always :const:`True`. ::"
msgstr ""
"Оператор :keyword:`in` теперь работает по-другому для строк. Раньше при "
"вычислении ``X в Y``, где *X* и *Y* — строки, *X* мог быть только одним "
"символом. Теперь это изменилось; *X* может быть строкой любой длины, а ``X в "
"Y`` вернет :const:`True`, если *X* является подстрокой *Y*. Если *X* — "
"пустая строка, результатом всегда будет :const:`True`. ::"

#: ../../whatsnew/2.3.rst:1133
msgid ""
">>> 'ab' in 'abcd'\n"
"True\n"
">>> 'ad' in 'abcd'\n"
"False\n"
">>> '' in 'abcd'\n"
"True"
msgstr ""
">>> 'ab' in 'abcd'\n"
"True\n"
">>> 'ad' in 'abcd'\n"
"False\n"
">>> '' in 'abcd'\n"
"True"

#: ../../whatsnew/2.3.rst:1140
msgid ""
"Note that this doesn't tell you where the substring starts; if you need that "
"information, use the :meth:`~str.find` string method."
msgstr ""
"Обратите внимание, что это не говорит вам, где начинается подстрока; если "
"вам нужна эта информация, используйте строковый метод :meth:`~str.find`."

#: ../../whatsnew/2.3.rst:1143
msgid ""
"The :meth:`~str.strip`, :meth:`~str.lstrip`, and :meth:`~str.rstrip` string "
"methods now have an optional argument for specifying the characters to "
"strip.  The default is still to remove all whitespace characters::"
msgstr ""
"Строковые методы :meth:`~str.strip`, :meth:`~str.lstrip` и :meth:`~str."
"rstrip` теперь имеют необязательный аргумент для указания символов для "
"удаления. По умолчанию по-прежнему удаляются все пробельные символы::"

#: ../../whatsnew/2.3.rst:1147
msgid ""
">>> '   abc '.strip()\n"
"'abc'\n"
">>> '><><abc<><><>'.strip('<>')\n"
"'abc'\n"
">>> '><><abc<><><>\\n'.strip('<>')\n"
"'abc<><><>\\n'\n"
">>> u'\\u4000\\u4001abc\\u4000'.strip(u'\\u4000')\n"
"u'\\u4001abc'\n"
">>>"
msgstr ""
">>> '   abc '.strip()\n"
"'abc'\n"
">>> '><><abc<><><>'.strip('<>')\n"
"'abc'\n"
">>> '><><abc<><><>\\n'.strip('<>')\n"
"'abc<><><>\\n'\n"
">>> u'\\u4000\\u4001abc\\u4000'.strip(u'\\u4000')\n"
"u'\\u4001abc'\n"
">>>"

#: ../../whatsnew/2.3.rst:1157
msgid "(Suggested by Simon Brunning and implemented by Walter Dörwald.)"
msgstr "(Предложено Саймоном Бруннингом и реализовано Вальтером Дорвальдом.)"

#: ../../whatsnew/2.3.rst:1159
msgid ""
"The :meth:`~str.startswith` and :meth:`~str.endswith` string methods now "
"accept negative numbers for the *start* and *end* parameters."
msgstr ""
"Строковые методы :meth:`~str.startswith` и :meth:`~str.endswith` теперь "
"принимают отрицательные числа для параметров *start* и *end*."

#: ../../whatsnew/2.3.rst:1162
msgid ""
"Another new string method is :meth:`~str.zfill`, originally a function in "
"the :mod:`string` module.  :meth:`~str.zfill` pads a numeric string with "
"zeros on the left until it's the specified width. Note that the ``%`` "
"operator is still more flexible and powerful than :meth:`~str.zfill`. ::"
msgstr ""
"Еще один новый строковый метод — :meth:`~str.zfill`, первоначально функция в "
"модуле :mod:`string`. :meth:`~str.zfill` дополняет числовую строку нулями "
"слева до тех пор, пока она не достигнет указанной ширины. Обратите внимание, "
"что оператор ``%`` по-прежнему более гибкий и мощный, чем :meth:`~str."
"zfill`. ::"

#: ../../whatsnew/2.3.rst:1167
msgid ""
">>> '45'.zfill(4)\n"
"'0045'\n"
">>> '12345'.zfill(4)\n"
"'12345'\n"
">>> 'goofy'.zfill(6)\n"
"'0goofy'"
msgstr ""
">>> '45'.zfill(4)\n"
"'0045'\n"
">>> '12345'.zfill(4)\n"
"'12345'\n"
">>> 'goofy'.zfill(6)\n"
"'0goofy'"

#: ../../whatsnew/2.3.rst:1174
msgid "(Contributed by Walter Dörwald.)"
msgstr "(Предоставлено Вальтером Дорвальдом.)"

#: ../../whatsnew/2.3.rst:1176
msgid ""
"A new type object, :class:`!basestring`, has been added. Both 8-bit strings "
"and Unicode strings inherit from this type, so ``isinstance(obj, "
"basestring)`` will return :const:`True` for either kind of string.  It's a "
"completely abstract type, so you can't create :class:`!basestring` instances."
msgstr ""
"Был добавлен новый объект типа :class:`!basestring`. И 8-битные строки, и "
"строки Unicode наследуются от этого типа, поэтому isinstance(obj, "
"basestring)`` вернет :const:`True` для любого типа строки. Это полностью "
"абстрактный тип, поэтому вы не можете создавать экземпляры :class:`!"
"basestring`."

#: ../../whatsnew/2.3.rst:1181
msgid ""
"Interned strings are no longer immortal and will now be garbage-collected in "
"the usual way when the only reference to them is from the internal "
"dictionary of interned strings.  (Implemented by Oren Tirosh.)"
msgstr ""
"Интернированные строки больше не бессмертны и теперь будут убираться обычным "
"способом, если единственная ссылка на них находится во внутреннем словаре "
"интернированных строк. (Реализован Орен Тирош.)"

#: ../../whatsnew/2.3.rst:1189
msgid "Optimizations"
msgstr "Оптимизации"

#: ../../whatsnew/2.3.rst:1191
msgid ""
"The creation of new-style class instances has been made much faster; they're "
"now faster than classic classes!"
msgstr ""
"Создание экземпляров классов нового стиля стало намного быстрее; теперь они "
"быстрее классических занятий!"

#: ../../whatsnew/2.3.rst:1194
msgid ""
"The :meth:`~list.sort` method of list objects has been extensively rewritten "
"by Tim Peters, and the implementation is significantly faster."
msgstr ""
"Метод :meth:`~list.sort` для объектов списка был тщательно переписан Тимом "
"Питерсом, и его реализация реализована значительно быстрее."

#: ../../whatsnew/2.3.rst:1197
msgid ""
"Multiplication of large long integers is now much faster thanks to an "
"implementation of Karatsuba multiplication, an algorithm that scales better "
"than the *O*\\ (*n*\\ :sup:`2`) required for the grade-school multiplication "
"algorithm.  (Original patch by Christopher A. Craig, and significantly "
"reworked by Tim Peters.)"
msgstr ""
"Умножение больших длинных целых чисел теперь происходит намного быстрее "
"благодаря реализации умножения Карацубы, алгоритма, который масштабируется "
"лучше, чем *O*\\ (*n*\\ :sup:`2`), необходимый для алгоритма умножения в "
"начальной школе. (Оригинальный патч Кристофера А. Крейга и значительно "
"переработан Тимом Питерсом.)"

#: ../../whatsnew/2.3.rst:1202
msgid ""
"The ``SET_LINENO`` opcode is now gone.  This may provide a small speed "
"increase, depending on your compiler's idiosyncrasies. See section :ref:"
"`23section-other` for a longer explanation. (Removed by Michael Hudson.)"
msgstr ""
"Опкода ``SET_LINENO`` больше нет. Это может обеспечить небольшое увеличение "
"скорости, в зависимости от особенностей вашего компилятора. См. раздел :ref:"
"`23section-other` для более подробного объяснения. (Удален Майклом Хадсоном.)"

#: ../../whatsnew/2.3.rst:1206
msgid ""
":func:`!xrange` objects now have their own iterator, making ``for i in "
"xrange(n)`` slightly faster than ``for i in range(n)``.  (Patch by Raymond "
"Hettinger.)"
msgstr ""
"Объекты :func:`!xrange` теперь имеют собственный итератор, что делает ``for "
"i in xrange(n)`` немного быстрее, чем ``for i in range(n)``. (Нашивка "
"Раймонда Хеттингера.)"

#: ../../whatsnew/2.3.rst:1210
msgid ""
"A number of small rearrangements have been made in various hotspots to "
"improve performance, such as inlining a function or removing some code.  "
"(Implemented mostly by GvR, but lots of people have contributed single "
"changes.)"
msgstr ""
"В различных «горячих точках» был внесен ряд небольших изменений для "
"повышения производительности, таких как встраивание функции или удаление "
"некоторого кода. (В основном реализовано GvR, но многие люди внесли "
"отдельные изменения.)"

#: ../../whatsnew/2.3.rst:1214
msgid ""
"The net result of the 2.3 optimizations is that Python 2.3 runs the  pystone "
"benchmark around 25% faster than Python 2.2."
msgstr ""
"Конечным результатом оптимизации 2.3 является то, что Python 2.3 выполняет "
"тест pystone примерно на 25% быстрее, чем Python 2.2."

#: ../../whatsnew/2.3.rst:1221
msgid "New, Improved, and Deprecated Modules"
msgstr "Новые, улучшенные и устаревшие модули"

#: ../../whatsnew/2.3.rst:1223
msgid ""
"As usual, Python's standard library received a number of enhancements and "
"bug fixes.  Here's a partial list of the most notable changes, sorted "
"alphabetically by module name. Consult the :file:`Misc/NEWS` file in the "
"source tree for a more complete list of changes, or look through the CVS "
"logs for all the details."
msgstr ""
"Как обычно, стандартная библиотека Python получила ряд улучшений и "
"исправлений ошибок. Вот неполный список наиболее заметных изменений, "
"отсортированный в алфавитном порядке по названию модуля. Обратитесь к файлу :"
"file:`Misc/NEWS` в дереве исходного кода для получения более полного списка "
"изменений или просмотрите журналы CVS для получения всех подробностей."

#: ../../whatsnew/2.3.rst:1228
msgid ""
"The :mod:`array` module now supports arrays of Unicode characters using the "
"``'u'`` format character.  Arrays also now support using the ``+=`` "
"assignment operator to add another array's contents, and the ``*=`` "
"assignment operator to repeat an array. (Contributed by Jason Orendorff.)"
msgstr ""
"Модуль :mod:`array` теперь поддерживает массивы символов Юникода, используя "
"символ формата ``'u'``. Массивы также теперь поддерживают использование "
"оператора присваивания ``+=`` для добавления содержимого другого массива и "
"оператора присваивания ``*=`` для повторения массива. (Предоставлено "
"Джейсоном Орендорфом.)"

#: ../../whatsnew/2.3.rst:1233
msgid ""
"The :mod:`!bsddb` module has been replaced by version 4.1.6 of the `PyBSDDB "
"<https://pybsddb.sourceforge.net>`_ package, providing a more complete "
"interface to the transactional features of the BerkeleyDB library."
msgstr ""
"Модуль :mod:`!bsddb` был заменен версией 4.1.6 пакета `PyBSDDB <https://"
"pybsddb.sourceforge.net>`_, предоставляя более полный интерфейс для "
"транзакционных функций библиотеки BerkeleyDB."

#: ../../whatsnew/2.3.rst:1237
msgid ""
"The old version of the module has been renamed to  :mod:`!bsddb185` and is "
"no longer built automatically; you'll  have to edit :file:`Modules/Setup` to "
"enable it.  Note that the new :mod:`!bsddb` package is intended to be "
"compatible with the  old module, so be sure to file bugs if you discover any "
"incompatibilities. When upgrading to Python 2.3, if the new interpreter is "
"compiled with a new version of  the underlying BerkeleyDB library, you will "
"almost certainly have to convert your database files to the new version.  "
"You can do this fairly easily with the new scripts :file:`db2pickle.py` and :"
"file:`pickle2db.py` which you will find in the distribution's :file:`Tools/"
"scripts` directory.  If you've already been using the PyBSDDB package and "
"importing it as :mod:`!bsddb3`, you will have to change your ``import`` "
"statements to import it as :mod:`!bsddb`."
msgstr ""
"Старая версия модуля была переименована в :mod:`!bsddb185` и больше не "
"собирается автоматически; вам придется отредактировать :file:`Modules/"
"Setup`, чтобы включить его. Обратите внимание, что новый пакет :mod:`!bsddb` "
"предназначен для совместимости со старым модулем, поэтому обязательно "
"сообщайте об ошибках, если вы обнаружите какие-либо несовместимости. Если "
"при обновлении до Python 2.3 новый интерпретатор скомпилирован с новой "
"версией базовой библиотеки BerkeleyDB, вам почти наверняка придется "
"преобразовать файлы базы данных в новую версию. Вы можете сделать это "
"довольно легко с помощью новых скриптов :file:`db2pickle.py` и :file:"
"`pickle2db.py`, которые вы найдете в каталоге :file:`Tools/scripts` "
"дистрибутива. Если вы уже использовали пакет PyBSDDB и импортировали его "
"как :mod:`!bsddb3`, вам придется изменить операторы ``import``, чтобы "
"импортировать его как :mod:`!bsddb`."

#: ../../whatsnew/2.3.rst:1249
msgid ""
"The new :mod:`bz2` module is an interface to the bz2 data compression "
"library. bz2-compressed data is usually smaller than  corresponding :mod:"
"`zlib`\\ -compressed data. (Contributed by Gustavo Niemeyer.)"
msgstr ""
"Новый модуль :mod:`bz2` представляет собой интерфейс к библиотеке сжатия "
"данных bz2. Данные, сжатые bz2, обычно меньше, чем соответствующие данные, "
"сжатые :mod:`zlib`\\. (Предоставлено Густаво Нимейером.)"

#: ../../whatsnew/2.3.rst:1253
msgid ""
"A set of standard date/time types has been added in the new :mod:`datetime` "
"module.  See the following section for more details."
msgstr ""
"В новый модуль :mod:`datetime` добавлен набор стандартных типов даты/"
"времени. Более подробную информацию смотрите в следующем разделе."

#: ../../whatsnew/2.3.rst:1256
msgid ""
"The Distutils :class:`!Extension` class now supports an extra constructor "
"argument named *depends* for listing additional source files that an "
"extension depends on.  This lets Distutils recompile the module if any of "
"the dependency files are modified.  For example, if :file:`sampmodule.c` "
"includes the header file :file:`sample.h`, you would create the :class:`!"
"Extension` object like this::"
msgstr ""
"Класс Distutils :class:`!Extension` теперь поддерживает дополнительный "
"аргумент конструктора с именем *dependents* для вывода списка дополнительных "
"исходных файлов, от которых зависит расширение. Это позволяет Distutils "
"перекомпилировать модуль, если какой-либо из файлов зависимостей был "
"изменен. Например, если :file:`sampmodule.c` включает заголовочный файл :"
"file:`sample.h`, вы создадите объект :class:`!Extension` следующим образом::"

#: ../../whatsnew/2.3.rst:1263
msgid ""
"ext = Extension(\"samp\",\n"
"                sources=[\"sampmodule.c\"],\n"
"                depends=[\"sample.h\"])"
msgstr ""
"ext = Extension(\"samp\",\n"
"                sources=[\"sampmodule.c\"],\n"
"                depends=[\"sample.h\"])"

#: ../../whatsnew/2.3.rst:1267
msgid ""
"Modifying :file:`sample.h` would then cause the module to be recompiled. "
"(Contributed by Jeremy Hylton.)"
msgstr ""
"Изменение :file:`sample.h` приведет к перекомпиляции модуля. (Предоставлено "
"Джереми Хилтоном.)"

#: ../../whatsnew/2.3.rst:1270
msgid ""
"Other minor changes to Distutils: it now checks for the :envvar:`CC`, :"
"envvar:`CFLAGS`, :envvar:`!CPP`, :envvar:`LDFLAGS`, and :envvar:`CPPFLAGS` "
"environment variables, using them to override the settings in Python's "
"configuration (contributed by Robert Weber)."
msgstr ""
"Другие незначительные изменения в Distutils: теперь он проверяет переменные "
"среды :envvar:`CC`, :envvar:`CFLAGS`, :envvar:`!CPP`, :envvar:`LDFLAGS` и :"
"envvar:`CPPFLAGS`, используя их для переопределения настроек в конфигурации "
"Python (предоставлено Робертом Вебером)."

#: ../../whatsnew/2.3.rst:1275
msgid ""
"Previously the :mod:`doctest` module would only search the docstrings of "
"public methods and functions for test cases, but it now also examines "
"private ones as well.  The :func:`~doctest.DocTestSuite` function creates a :"
"class:`unittest.TestSuite` object from a set of :mod:`doctest` tests."
msgstr ""
"Раньше модуль :mod:`doctest` выполнял поиск тестовых примеров только в "
"строках документации общедоступных методов и функций, но теперь он также "
"проверяет и частные. Функция :func:`~doctest.DocTestSuite` создает объект :"
"class:`unittest.TestSuite` из набора тестов :mod:`doctest`."

#: ../../whatsnew/2.3.rst:1280
msgid ""
"The new ``gc.get_referents(object)`` function returns a list of all the "
"objects referenced by *object*."
msgstr ""
"Новая функция gc.get_referents(object) возвращает список всех объектов, на "
"которые ссылается *object*."

#: ../../whatsnew/2.3.rst:1283
msgid ""
"The :mod:`getopt` module gained a new function, :func:`~getopt.gnu_getopt`, "
"that supports the same arguments as the existing :func:`~getopt.getopt` "
"function but uses GNU-style scanning mode. The existing :func:`~getopt."
"getopt` stops processing options as soon as a non-option argument is "
"encountered, but in GNU-style mode processing continues, meaning that "
"options and arguments can be mixed.  For example::"
msgstr ""
"Модуль :mod:`getopt` получил новую функцию :func:`~getopt.gnu_getopt`, "
"которая поддерживает те же аргументы, что и существующая функция :func:"
"`~getopt.getopt`, но использует режим сканирования в стиле GNU. "
"Существующая :func:`~getopt.getopt` прекращает обработку опций, как только "
"встречается аргумент, не являющийся опцией, но в режиме GNU обработка "
"продолжается, что означает, что опции и аргументы могут быть смешаны. "
"Например::"

#: ../../whatsnew/2.3.rst:1289
msgid ""
">>> getopt.getopt(['-f', 'filename', 'output', '-v'], 'f:v')\n"
"([('-f', 'filename')], ['output', '-v'])\n"
">>> getopt.gnu_getopt(['-f', 'filename', 'output', '-v'], 'f:v')\n"
"([('-f', 'filename'), ('-v', '')], ['output'])"
msgstr ""
">>> getopt.getopt(['-f', 'filename', 'output', '-v'], 'f:v')\n"
"([('-f', 'filename')], ['output', '-v'])\n"
">>> getopt.gnu_getopt(['-f', 'filename', 'output', '-v'], 'f:v')\n"
"([('-f', 'filename'), ('-v', '')], ['output'])"

#: ../../whatsnew/2.3.rst:1294
msgid "(Contributed by Peter Åstrand.)"
msgstr "(Предоставлено Питером Острандом.)"

#: ../../whatsnew/2.3.rst:1296
msgid ""
"The :mod:`grp`, :mod:`pwd`, and :mod:`resource` modules now return enhanced "
"tuples::"
msgstr ""
"Модули :mod:`grp`, :mod:`pwd` и :mod:`resource` теперь возвращают "
"расширенные кортежи::"

#: ../../whatsnew/2.3.rst:1299
msgid ""
">>> import grp\n"
">>> g = grp.getgrnam('amk')\n"
">>> g.gr_name, g.gr_gid\n"
"('amk', 500)"
msgstr ""
">>> import grp\n"
">>> g = grp.getgrnam('amk')\n"
">>> g.gr_name, g.gr_gid\n"
"('amk', 500)"

#: ../../whatsnew/2.3.rst:1304
msgid "The :mod:`gzip` module can now handle files exceeding 2 GiB."
msgstr ""
"Модуль :mod:`gzip` теперь может обрабатывать файлы размером более 2 ГиБ."

#: ../../whatsnew/2.3.rst:1306
msgid ""
"The new :mod:`heapq` module contains an implementation of a heap queue "
"algorithm.  A heap is an array-like data structure that keeps items in a "
"partially sorted order such that, for every index *k*, ``heap[k] <= "
"heap[2*k+1]`` and ``heap[k] <= heap[2*k+2]``.  This makes it quick to remove "
"the smallest item, and inserting a new item while maintaining the heap "
"property is *O*\\ (log *n*).  (See https://xlinux.nist.gov/dads//HTML/"
"priorityque.html for more information about the priority queue data "
"structure.)"
msgstr ""
"Новый модуль :mod:`heapq` содержит реализацию алгоритма очереди в куче. Куча "
"— это структура данных, подобная массиву, которая хранит элементы в частично "
"отсортированном порядке, так что для каждого индекса *k* ``heap[k] <= "
"heap[2*k+1]`` и ``heap[ k] <= куча[2*k+2]``. Это позволяет быстро удалить "
"самый маленький элемент и вставить новый элемент с сохранением свойства кучи "
"*O*\\ (log *n*). (Дополнительную информацию о структуре данных приоритетной "
"очереди см. на странице https://xlinux.nist.gov/dads//HTML/priorityque.html.)"

#: ../../whatsnew/2.3.rst:1314
msgid ""
"The :mod:`heapq` module provides :func:`~heapq.heappush` and :func:`~heapq."
"heappop` functions for adding and removing items while maintaining the heap "
"property on top of some other mutable Python sequence type.  Here's an "
"example that uses a Python list::"
msgstr ""
"Модуль :mod:`heapq` предоставляет функции :func:`~heapq.heappush` и :func:"
"`~heapq.heappop` для добавления и удаления элементов, сохраняя при этом "
"свойство кучи поверх некоторого другого изменяемого типа последовательности "
"Python. Вот пример, в котором используется список Python:"

#: ../../whatsnew/2.3.rst:1318
msgid ""
">>> import heapq\n"
">>> heap = []\n"
">>> for item in [3, 7, 5, 11, 1]:\n"
"...    heapq.heappush(heap, item)\n"
"...\n"
">>> heap\n"
"[1, 3, 5, 11, 7]\n"
">>> heapq.heappop(heap)\n"
"1\n"
">>> heapq.heappop(heap)\n"
"3\n"
">>> heap\n"
"[5, 7, 11]"
msgstr ""
">>> import heapq\n"
">>> heap = []\n"
">>> for item in [3, 7, 5, 11, 1]:\n"
"...    heapq.heappush(heap, item)\n"
"...\n"
">>> heap\n"
"[1, 3, 5, 11, 7]\n"
">>> heapq.heappop(heap)\n"
"1\n"
">>> heapq.heappop(heap)\n"
"3\n"
">>> heap\n"
"[5, 7, 11]"

#: ../../whatsnew/2.3.rst:1332
msgid "(Contributed by Kevin O'Connor.)"
msgstr "(Предоставлено Кевином О'Коннором.)"

#: ../../whatsnew/2.3.rst:1334
msgid ""
"The IDLE integrated development environment has been updated using the code "
"from the IDLEfork project (https://idlefork.sourceforge.net).  The most "
"notable feature is that the code being developed is now executed in a "
"subprocess, meaning that there's no longer any need for manual ``reload()`` "
"operations. IDLE's core code has been incorporated into the standard library "
"as the :mod:`idlelib` package."
msgstr ""
"Интегрированная среда разработки IDLE была обновлена ​​с использованием кода "
"проекта IDLEfork (https://idlefork.sourceforge.net). Наиболее примечательной "
"особенностью является то, что разрабатываемый код теперь выполняется в "
"подпроцессе, а это означает, что больше нет необходимости в ручных операциях "
"``reload()``. Основной код IDLE включен в стандартную библиотеку как пакет :"
"mod:`idlelib`."

#: ../../whatsnew/2.3.rst:1340
msgid ""
"The :mod:`imaplib` module now supports IMAP over SSL. (Contributed by Piers "
"Lauder and Tino Lange.)"
msgstr ""
"Модуль :mod:`imaplib` теперь поддерживает IMAP через SSL. (Сообщили Пирс "
"Лаудер и Тино Ланге.)"

#: ../../whatsnew/2.3.rst:1343
msgid ""
"The :mod:`itertools` contains a number of useful functions for use with "
"iterators, inspired by various functions provided by the ML and Haskell "
"languages.  For example, ``itertools.ifilter(predicate, iterator)`` returns "
"all elements in the iterator for which the function :func:`!predicate` "
"returns :const:`True`, and ``itertools.repeat(obj, N)`` returns ``obj`` *N* "
"times. There are a number of other functions in the module; see the "
"package's reference documentation for details. (Contributed by Raymond "
"Hettinger.)"
msgstr ""
":mod:`itertools` содержит ряд полезных функций для использования с "
"итераторами, вдохновленными различными функциями языков ML и Haskell. "
"Например, ``itertools.ifilter(predicate, iterator)`` возвращает все элементы "
"в итераторе, для которых функция :func:`!predicate` возвращает :const:`True` "
"и ``itertools.repeat(obj, N )`` возвращает ``obj`` *N* раз. В модуле имеется "
"ряд других функций; подробности см. в справочной документации пакета. "
"(Предоставлено Раймондом Хеттингером.)"

#: ../../whatsnew/2.3.rst:1352
msgid ""
"Two new functions in the :mod:`math` module, ``degrees(rads)`` and "
"``radians(degs)``, convert between radians and degrees.  Other functions in "
"the :mod:`math` module such as :func:`math.sin` and :func:`math.cos` have "
"always required input values measured in radians.  Also, an optional *base* "
"argument was added to :func:`math.log` to make it easier to compute "
"logarithms for bases other than ``e`` and ``10``.  (Contributed by Raymond "
"Hettinger.)"
msgstr ""
"Две новые функции в модуле :mod:`math`, ``градусы(рады)`` и "
"``радианы(градусы)``, преобразуют радианы в градусы. Другие функции в "
"модуле :mod:`math`, такие как :func:`math.sin` и :func:`math.cos`, всегда "
"требуют входных значений, измеряемых в радианах. Кроме того, в :func:`math."
"log` был добавлен необязательный аргумент *base*, чтобы упростить вычисление "
"логарифмов для оснований, отличных от ``e`` и ``10``. (Предоставлено "
"Раймондом Хеттингером.)"

#: ../../whatsnew/2.3.rst:1359
msgid ""
"Several new POSIX functions (:func:`!getpgid`, :func:`!killpg`, :func:`!"
"lchown`, :func:`!loadavg`, :func:`!major`, :func:`!makedev`, :func:`!minor`, "
"and :func:`!mknod`) were added to the :mod:`posix` module that underlies "
"the :mod:`os` module. (Contributed by Gustavo Niemeyer, Geert Jansen, and "
"Denis S. Otkidach.)"
msgstr ""
"Несколько новых функций POSIX (:func:`!getpgid`, :func:`!killpg`, :func:`!"
"lchown`, :func:`!loadavg`, :func:`!major`, :func:`! makedev`, :func:`!minor` "
"и :func:`!mknod`) были добавлены в модуль :mod:`posix`, который лежит в "
"основе модуля :mod:`os`. (Сообщили Густаво Нимейер, Герт Янсен и Денис С. "
"Откидач.)"

#: ../../whatsnew/2.3.rst:1365
msgid ""
"In the :mod:`os` module, the :func:`!\\*stat` family of functions can now "
"report fractions of a second in a timestamp.  Such time stamps are "
"represented as floats, similar to the value returned by :func:`time.time`."
msgstr ""
"В модуле :mod:`os` семейство функций :func:`!\\*stat` теперь может сообщать "
"о долях секунды в метке времени. Такие метки времени представлены в виде "
"чисел с плавающей запятой, аналогично значению, возвращаемому :func:`time."
"time`."

#: ../../whatsnew/2.3.rst:1369
msgid ""
"During testing, it was found that some applications will break if time "
"stamps are floats.  For compatibility, when using the tuple interface of "
"the :class:`~os.stat_result` time stamps will be represented as integers. "
"When using named fields (a feature first introduced in Python 2.2), time "
"stamps are still represented as integers, unless :func:`!os."
"stat_float_times` is invoked to enable float return values::"
msgstr ""
"В ходе тестирования было обнаружено, что некоторые приложения будут "
"ломаться, если отметки времени будут плавающими. Для совместимости при "
"использовании интерфейса кортежа метки времени :class:`~os.stat_result` "
"будут представлены как целые числа. При использовании именованных полей "
"(функция, впервые представленная в Python 2.2), отметки времени по-прежнему "
"представляются как целые числа, если только не вызывается :func:`!os."
"stat_float_times` для включения возвращаемых значений с плавающей запятой::"

#: ../../whatsnew/2.3.rst:1376
msgid ""
">>> os.stat(\"/tmp\").st_mtime\n"
"1034791200\n"
">>> os.stat_float_times(True)\n"
">>> os.stat(\"/tmp\").st_mtime\n"
"1034791200.6335014"
msgstr ""
">>> os.stat(\"/tmp\").st_mtime\n"
"1034791200\n"
">>> os.stat_float_times(True)\n"
">>> os.stat(\"/tmp\").st_mtime\n"
"1034791200.6335014"

#: ../../whatsnew/2.3.rst:1382
msgid "In Python 2.4, the default will change to always returning floats."
msgstr ""
"В Python 2.4 значение по умолчанию изменится на постоянное возвращение чисел "
"с плавающей запятой."

#: ../../whatsnew/2.3.rst:1384
msgid ""
"Application developers should enable this feature only if all their "
"libraries work properly when confronted with floating-point time stamps, or "
"if they use the tuple API. If used, the feature should be activated on an "
"application level instead of trying to enable it on a per-use basis."
msgstr ""
"Разработчикам приложений следует включать эту функцию только в том случае, "
"если все их библиотеки работают правильно при работе с отметками времени с "
"плавающей запятой или если они используют API-интерфейс кортежа. Если эта "
"функция используется, ее следует активировать на уровне приложения, а не "
"пытаться включить ее для каждого использования."

#: ../../whatsnew/2.3.rst:1389
msgid ""
"The :mod:`optparse` module contains a new parser for command-line arguments "
"that can convert option values to a particular Python type  and will "
"automatically generate a usage message.  See the following section for  more "
"details."
msgstr ""
"Модуль :mod:`optparse` содержит новый анализатор аргументов командной "
"строки, который может преобразовывать значения параметров в определенный тип "
"Python и автоматически генерировать сообщение об использовании. Более "
"подробную информацию смотрите в следующем разделе."

#: ../../whatsnew/2.3.rst:1394
msgid ""
"The old and never-documented :mod:`!linuxaudiodev` module has been "
"deprecated, and a new version named :mod:`ossaudiodev` has been added.  The "
"module was renamed because the OSS sound drivers can be used on platforms "
"other than Linux, and the interface has also been tidied and brought up to "
"date in various ways. (Contributed by Greg Ward and Nicholas FitzRoy-Dale.)"
msgstr ""
"Старый и никогда не документированный модуль :mod:`!linuxaudiodev` устарел, "
"и была добавлена ​​новая версия с именем :mod:`ossaudiodev`. Модуль был "
"переименован, поскольку звуковые драйверы OSS можно использовать на "
"платформах, отличных от Linux, а также интерфейс был приведен в порядок и "
"обновлен различными способами. (Сообщили Грег Уорд и Николас Фицрой-Дейл.)"

#: ../../whatsnew/2.3.rst:1400
msgid ""
"The new :mod:`platform` module contains a number of functions that try to "
"determine various properties of the platform you're running on.  There are "
"functions for getting the architecture, CPU type, the Windows OS version, "
"and even the Linux distribution version. (Contributed by Marc-André Lemburg.)"
msgstr ""
"Новый модуль :mod:`platform` содержит ряд функций, которые пытаются "
"определить различные свойства платформы, на которой вы работаете. Есть "
"функции для получения архитектуры, типа процессора, версии ОС Windows и даже "
"версии дистрибутива Linux. (Предоставлено Марком-Андре Лембургом.)"

#: ../../whatsnew/2.3.rst:1405
msgid ""
"The parser objects provided by the :mod:`pyexpat <xml.parsers.expat>` module "
"can now optionally buffer character data, resulting in fewer calls to your "
"character data handler and therefore faster performance.  Setting the parser "
"object's :attr:`~xml.parsers.expat.xmlparser.buffer_text` attribute to :"
"const:`True` will enable buffering."
msgstr ""
"Объекты синтаксического анализатора, предоставляемые модулем :mod:`pyexpat "
"<xml.parsers.expat>`, теперь могут опционально буферизовать символьные "
"данные, что приводит к меньшему количеству вызовов вашего обработчика "
"символьных данных и, следовательно, к повышению производительности. "
"Установка атрибута :attr:`~xml.parsers.expat.xmlparser.buffer_text` объекта "
"парсера на :const:`True` включит буферизацию."

#: ../../whatsnew/2.3.rst:1410
msgid ""
"The ``sample(population, k)`` function was added to the :mod:`random` "
"module.  *population* is a sequence or :class:`!xrange` object containing "
"the elements of a population, and :func:`~random.sample` chooses *k* "
"elements from the population without replacing chosen elements.  *k* can be "
"any value up to ``len(population)``. For example::"
msgstr ""
"В модуль :mod:`random` была добавлена ​​функция ``sample(population, k)``. "
"*population* — это последовательность или объект :class:`!xrange`, "
"содержащий элементы совокупности, а :func:`~random.sample` выбирает *k* "
"элементов из совокупности без замены выбранных элементов. *k* может быть "
"любым значением до ``len(population)``. Например::"

#: ../../whatsnew/2.3.rst:1416
msgid ""
">>> days = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'St', 'Sn']\n"
">>> random.sample(days, 3)      # Choose 3 elements\n"
"['St', 'Sn', 'Th']\n"
">>> random.sample(days, 7)      # Choose 7 elements\n"
"['Tu', 'Th', 'Mo', 'We', 'St', 'Fr', 'Sn']\n"
">>> random.sample(days, 7)      # Choose 7 again\n"
"['We', 'Mo', 'Sn', 'Fr', 'Tu', 'St', 'Th']\n"
">>> random.sample(days, 8)      # Can't choose eight\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"random.py\", line 414, in sample\n"
"      raise ValueError, \"sample larger than population\"\n"
"ValueError: sample larger than population\n"
">>> random.sample(xrange(1,10000,2), 10)   # Choose ten odd nos. under "
"10000\n"
"[3407, 3805, 1505, 7023, 2401, 2267, 9733, 3151, 8083, 9195]"
msgstr ""
">>> days = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'St', 'Sn']\n"
">>> random.sample(days, 3)      # Choose 3 elements\n"
"['St', 'Sn', 'Th']\n"
">>> random.sample(days, 7)      # Choose 7 elements\n"
"['Tu', 'Th', 'Mo', 'We', 'St', 'Fr', 'Sn']\n"
">>> random.sample(days, 7)      # Choose 7 again\n"
"['We', 'Mo', 'Sn', 'Fr', 'Tu', 'St', 'Th']\n"
">>> random.sample(days, 8)      # Can't choose eight\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"random.py\", line 414, in sample\n"
"      raise ValueError, \"sample larger than population\"\n"
"ValueError: sample larger than population\n"
">>> random.sample(xrange(1,10000,2), 10)   # Choose ten odd nos. under "
"10000\n"
"[3407, 3805, 1505, 7023, 2401, 2267, 9733, 3151, 8083, 9195]"

#: ../../whatsnew/2.3.rst:1432
msgid ""
"The :mod:`random` module now uses a new algorithm, the Mersenne Twister, "
"implemented in C.  It's faster and more extensively studied than the "
"previous algorithm."
msgstr ""
"Модуль :mod:`random` теперь использует новый алгоритм Mersenne Twister, "
"реализованный на C. Он быстрее и более тщательно изучен, чем предыдущий "
"алгоритм."

#: ../../whatsnew/2.3.rst:1436
msgid "(All changes contributed by Raymond Hettinger.)"
msgstr "(Все изменения внесены Рэймондом Хеттингером.)"

#: ../../whatsnew/2.3.rst:1438
msgid ""
"The :mod:`readline` module also gained a number of new functions: :func:"
"`~readline.get_history_item`, :func:`~readline.get_current_history_length`, "
"and :func:`~readline.redisplay`."
msgstr ""
"Модуль :mod:`readline` также получил ряд новых функций: :func:`~readline."
"get_history_item`, :func:`~readline.get_current_history_length` и :func:"
"`~readline.redisplay`."

#: ../../whatsnew/2.3.rst:1442
msgid ""
"The :mod:`!rexec` and :mod:`!Bastion` modules have been declared dead, and "
"attempts to import them will fail with a :exc:`RuntimeError`.  New-style "
"classes provide new ways to break out of the restricted execution "
"environment provided by :mod:`!rexec`, and no one has interest in fixing "
"them or time to do so.  If you have applications using :mod:`!rexec`, "
"rewrite them to use something else."
msgstr ""
"Модули :mod:`!rexec` и :mod:`!Bastion` были объявлены мертвыми, и попытки "
"импортировать их завершатся ошибкой :exc:`RuntimeError`. Классы нового стиля "
"предоставляют новые способы выхода из ограниченной среды выполнения, "
"предоставляемой :mod:`!rexec`, и никто не заинтересован в их исправлении или "
"времени на это. Если у вас есть приложения, использующие :mod:`!rexec`, "
"перепишите их, чтобы использовать что-нибудь другое."

#: ../../whatsnew/2.3.rst:1448
msgid ""
"(Sticking with Python 2.2 or 2.1 will not make your applications any safer "
"because there are known bugs in the :mod:`!rexec` module in those versions.  "
"To repeat: if you're using :mod:`!rexec`, stop using it immediately.)"
msgstr ""
"(Придерживаясь Python 2.2 или 2.1, ваши приложения не станут безопаснее, "
"поскольку в этих версиях есть известные ошибки в модуле :mod:`!rexec`. "
"Повторяем: если вы используете :mod:`!rexec`, остановитесь немедленно "
"воспользуюсь им.)"

#: ../../whatsnew/2.3.rst:1452
msgid ""
"The :mod:`!rotor` module has been deprecated because the  algorithm it uses "
"for encryption is not believed to be secure.  If you need encryption, use "
"one of the several AES Python modules that are available separately."
msgstr ""
"Модуль :mod:`!rotor` устарел, поскольку алгоритм, используемый им для "
"шифрования, не считается безопасным. Если вам нужно шифрование, используйте "
"один из нескольких модулей AES Python, которые доступны отдельно."

#: ../../whatsnew/2.3.rst:1456
msgid ""
"The :mod:`shutil` module gained a ``move(src, dest)`` function that "
"recursively moves a file or directory to a new location."
msgstr ""
"Модуль :mod:`shutil` получил функцию ``move(src, dest)``, которая рекурсивно "
"перемещает файл или каталог в новое место."

#: ../../whatsnew/2.3.rst:1459
msgid ""
"Support for more advanced POSIX signal handling was added to the :mod:"
"`signal` but then removed again as it proved impossible to make it work "
"reliably across platforms."
msgstr ""
"Поддержка более продвинутой обработки сигналов POSIX была добавлена ​​в :mod:"
"`signal`, но затем снова удалена, поскольку оказалось невозможным обеспечить "
"его надежную работу на разных платформах."

#: ../../whatsnew/2.3.rst:1463
msgid ""
"The :mod:`socket` module now supports timeouts.  You can call the "
"``settimeout(t)`` method on a socket object to set a timeout of *t* seconds. "
"Subsequent socket operations that take longer than *t* seconds to complete "
"will abort and raise a :exc:`socket.timeout` exception."
msgstr ""
"Модуль :mod:`socket` теперь поддерживает таймауты. Вы можете вызвать метод "
"``settimeout(t)`` для объекта сокета, чтобы установить таймаут в *t* секунд. "
"Последующие операции с сокетами, выполнение которых занимает более *t* "
"секунд, будут прерваны и выдадут исключение :exc:`socket.timeout`."

#: ../../whatsnew/2.3.rst:1468
msgid ""
"The original timeout implementation was by Tim O'Malley.  Michael Gilfix "
"integrated it into the Python :mod:`socket` module and shepherded it through "
"a lengthy review.  After the code was checked in, Guido van Rossum rewrote "
"parts of it.  (This is a good example of a collaborative development process "
"in action.)"
msgstr ""
"Оригинальную реализацию тайм-аута разработал Тим О'Мэлли. Майкл Гилфикс "
"интегрировал его в модуль Python :mod:`socket` и провел его длительный "
"обзор. После того как код был проверен, Гвидо ван Россум переписал его "
"части. (Это хороший пример совместного процесса разработки в действии.)"

#: ../../whatsnew/2.3.rst:1474
msgid ""
"On Windows, the :mod:`socket` module now ships with Secure  Sockets Layer "
"(SSL) support."
msgstr ""
"В Windows модуль :mod:`socket` теперь поставляется с поддержкой Secure "
"Sockets Layer (SSL)."

#: ../../whatsnew/2.3.rst:1477
msgid ""
"The value of the C :c:macro:`!PYTHON_API_VERSION` macro is now exposed at "
"the Python level as ``sys.api_version``.  The current exception can be "
"cleared by calling the new :func:`!sys.exc_clear` function."
msgstr ""
"Значение макроса C :c:macro:`!PYTHON_API_VERSION` теперь отображается на "
"уровне Python как ``sys.api_version``. Текущее исключение можно очистить, "
"вызвав новую функцию :func:`!sys.exc_clear`."

#: ../../whatsnew/2.3.rst:1481
msgid ""
"The new :mod:`tarfile` module  allows reading from and writing to :program:"
"`tar`\\ -format archive files. (Contributed by Lars Gustäbel.)"
msgstr ""
"Новый модуль :mod:`tarfile` позволяет читать и записывать в архивные файлы "
"формата :program:`tar`\\. (Предоставлено Ларсом Густебелем.)"

#: ../../whatsnew/2.3.rst:1484
msgid ""
"The new :mod:`textwrap` module contains functions for wrapping strings "
"containing paragraphs of text.  The ``wrap(text, width)`` function takes a "
"string and returns a list containing the text split into lines of no more "
"than the chosen width.  The ``fill(text, width)`` function returns a single "
"string, reformatted to fit into lines no longer than the chosen width. (As "
"you can guess, :func:`~textwrap.fill` is built on top of :func:`~textwrap."
"wrap`.  For example::"
msgstr ""
"Новый модуль :mod:`textwrap` содержит функции для переноса строк, содержащих "
"абзацы текста. Функция wrap(text, width) принимает строку и возвращает "
"список, содержащий текст, разделенный на строки шириной не более выбранной. "
"Функция fill(text, width) возвращает одну строку, отформатированную так, "
"чтобы она помещалась в строки длиной не более выбранной ширины. (Как вы "
"можете догадаться, :func:`~textwrap.fill` построен на основе :func:"
"`~textwrap.wrap`. Например::"

#: ../../whatsnew/2.3.rst:1491
msgid ""
">>> import textwrap\n"
">>> paragraph = \"Not a whit, we defy augury: ... more text ...\"\n"
">>> textwrap.wrap(paragraph, 60)\n"
"[\"Not a whit, we defy augury: there's a special providence in\",\n"
" \"the fall of a sparrow. If it be now, 'tis not to come; if it\",\n"
" ...]\n"
">>> print textwrap.fill(paragraph, 35)\n"
"Not a whit, we defy augury: there's\n"
"a special providence in the fall of\n"
"a sparrow. If it be now, 'tis not\n"
"to come; if it be not to come, it\n"
"will be now; if it be not now, yet\n"
"it will come: the readiness is all.\n"
">>>"
msgstr ""
">>> import textwrap\n"
">>> paragraph = \"Not a whit, we defy augury: ... more text ...\"\n"
">>> textwrap.wrap(paragraph, 60)\n"
"[\"Not a whit, we defy augury: there's a special providence in\",\n"
" \"the fall of a sparrow. If it be now, 'tis not to come; if it\",\n"
" ...]\n"
">>> print textwrap.fill(paragraph, 35)\n"
"Not a whit, we defy augury: there's\n"
"a special providence in the fall of\n"
"a sparrow. If it be now, 'tis not\n"
"to come; if it be not to come, it\n"
"will be now; if it be not now, yet\n"
"it will come: the readiness is all.\n"
">>>"

#: ../../whatsnew/2.3.rst:1506
msgid ""
"The module also contains a :class:`~textwrap.TextWrapper` class that "
"actually implements the text wrapping strategy.   Both the :class:`~textwrap."
"TextWrapper` class and the :func:`~textwrap.wrap` and :func:`~textwrap.fill` "
"functions support a number of additional keyword arguments for fine-tuning "
"the formatting; consult the module's documentation for details. (Contributed "
"by Greg Ward.)"
msgstr ""
"Модуль также содержит класс :class:`~textwrap.TextWrapper`, который "
"фактически реализует стратегию переноса текста. И класс :class:`~textwrap."
"TextWrapper`, и функции :func:`~textwrap.wrap` и :func:`~textwrap.fill` "
"поддерживают ряд дополнительных ключевых аргументов для точной настройки "
"форматирования; подробности см. в документации модуля. (Предоставлено Грегом "
"Уордом.)"

#: ../../whatsnew/2.3.rst:1512
msgid ""
"The :mod:`!thread` and :mod:`threading` modules now have companion modules, :"
"mod:`!dummy_thread` and :mod:`!dummy_threading`, that provide a do-nothing "
"implementation of the :mod:`!thread` module's interface for platforms where "
"threads are not supported.  The intention is to simplify thread-aware "
"modules (ones that *don't* rely on threads to run) by putting the following "
"code at the top::"
msgstr ""
"Модули :mod:`!thread` и :mod:`threading` теперь имеют сопутствующие модули :"
"mod:`!dummy_thread` и :mod:`!dummy_threading`, которые обеспечивают ничего "
"не делающую реализацию :mod:` Интерфейс модуля !thread` для платформ, где "
"потоки не поддерживаются. Цель состоит в том, чтобы упростить модули, "
"поддерживающие потоки (те, которые *не* полагаются на выполнение потоков), "
"поместив следующий код вверху:"

#: ../../whatsnew/2.3.rst:1519
msgid ""
"try:\n"
"    import threading as _threading\n"
"except ImportError:\n"
"    import dummy_threading as _threading"
msgstr ""
"try:\n"
"    import threading as _threading\n"
"except ImportError:\n"
"    import dummy_threading as _threading"

#: ../../whatsnew/2.3.rst:1524
msgid ""
"In this example, :mod:`!_threading` is used as the module name to make it "
"clear that the module being used is not necessarily the actual :mod:"
"`threading` module. Code can call functions and use classes in :mod:`!"
"_threading` whether or not threads are supported, avoiding an :keyword:`if` "
"statement and making the code slightly clearer.  This module will not "
"magically make multithreaded code run without threads; code that waits for "
"another thread to return or to do something will simply hang forever."
msgstr ""
"В этом примере :mod:`!_threading` используется в качестве имени модуля, "
"чтобы было понятно, что используемый модуль не обязательно является "
"фактическим модулем :mod:`threading`. Код может вызывать функции и "
"использовать классы в :mod:`!_threading` независимо от того, поддерживаются "
"потоки или нет, избегая оператора :keyword:`if` и делая код немного более "
"понятным. Этот модуль не заставит волшебным образом выполнять многопоточный "
"код без потоков; код, который ожидает возврата или выполнения чего-либо "
"другого потока, просто зависнет навсегда."

#: ../../whatsnew/2.3.rst:1532
msgid ""
"The :mod:`time` module's :func:`~time.strptime` function has long been an "
"annoyance because it uses the platform C library's :func:`~time.strptime` "
"implementation, and different platforms sometimes have odd bugs.  Brett "
"Cannon contributed a portable implementation that's written in pure Python "
"and should behave identically on all platforms."
msgstr ""
"Функция :func:`~time.strptime` модуля :mod:`time` уже давно раздражает, "
"поскольку она использует реализацию :func:`~time.strptime` библиотеки C "
"платформы, а на разных платформах иногда возникают странные ошибки. Бретт "
"Кэннон предоставил переносимую реализацию, написанную на чистом Python и "
"которая должна вести себя одинаково на всех платформах."

#: ../../whatsnew/2.3.rst:1538
msgid ""
"The new :mod:`timeit` module helps measure how long snippets of Python code "
"take to execute.  The :file:`timeit.py` file can be run directly from the "
"command line, or the module's :class:`~timeit.Timer` class can be imported "
"and used directly.  Here's a short example that figures out whether it's "
"faster to convert an 8-bit string to Unicode by appending an empty Unicode "
"string to it or by using the :func:`!unicode` function::"
msgstr ""
"Новый модуль :mod:`timeit` помогает измерить, сколько времени требуется для "
"выполнения фрагментов кода Python. Файл :file:`timeit.py` можно запустить "
"непосредственно из командной строки, либо класс :class:`~timeit.Timer` "
"модуля можно импортировать и использовать напрямую. Вот короткий пример, "
"который показывает, быстрее ли преобразовать 8-битную строку в Unicode, "
"добавив к ней пустую строку Unicode или используя функцию :func:`!unicode`::"

#: ../../whatsnew/2.3.rst:1545
msgid ""
"import timeit\n"
"\n"
"timer1 = timeit.Timer('unicode(\"abc\")')\n"
"timer2 = timeit.Timer('\"abc\" + u\"\"')\n"
"\n"
"# Run three trials\n"
"print timer1.repeat(repeat=3, number=100000)\n"
"print timer2.repeat(repeat=3, number=100000)\n"
"\n"
"# On my laptop this outputs:\n"
"# [0.36831796169281006, 0.37441694736480713, 0.35304892063140869]\n"
"# [0.17574405670166016, 0.18193507194519043, 0.17565798759460449]"
msgstr ""
"import timeit\n"
"\n"
"timer1 = timeit.Timer('unicode(\"abc\")')\n"
"timer2 = timeit.Timer('\"abc\" + u\"\"')\n"
"\n"
"# Run three trials\n"
"print timer1.repeat(repeat=3, number=100000)\n"
"print timer2.repeat(repeat=3, number=100000)\n"
"\n"
"# On my laptop this outputs:\n"
"# [0.36831796169281006, 0.37441694736480713, 0.35304892063140869]\n"
"# [0.17574405670166016, 0.18193507194519043, 0.17565798759460449]"

#: ../../whatsnew/2.3.rst:1558
msgid ""
"The :mod:`!Tix` module has received various bug fixes and updates for the "
"current version of the Tix package."
msgstr ""
"Модуль :mod:`!Tix` получил различные исправления ошибок и обновления для "
"текущей версии пакета Tix."

#: ../../whatsnew/2.3.rst:1561
msgid ""
"The :mod:`!Tkinter` module now works with a thread-enabled  version of Tcl. "
"Tcl's threading model requires that widgets only be accessed from the thread "
"in which they're created; accesses from another thread can cause Tcl to "
"panic.  For certain Tcl interfaces, :mod:`!Tkinter` will now automatically "
"avoid this  when a widget is accessed from a different thread by marshalling "
"a command, passing it to the correct thread, and waiting for the results.  "
"Other interfaces can't be handled automatically but :mod:`!Tkinter` will now "
"raise an exception on such an access so that you can at least find out about "
"the problem.  See https://mail.python.org/pipermail/python-dev/2002-"
"December/031107.html for a more detailed explanation of this change.  "
"(Implemented by Martin von Löwis.)"
msgstr ""
"Модуль :mod:`!Tkinter` теперь работает с версией Tcl с поддержкой потоков. "
"Модель потоков Tcl требует, чтобы доступ к виджетам был возможен только из "
"того потока, в котором они созданы; доступ из другого потока может вызвать "
"панику Tcl. Для некоторых интерфейсов Tcl :mod:`!Tkinter` теперь будет "
"автоматически избегать этого, когда к виджету обращаются из другого потока, "
"сортируя команду, передавая ее в правильный поток и ожидая результатов. "
"Другие интерфейсы не могут обрабатываться автоматически, но :mod:`!Tkinter` "
"теперь вызовет исключение при таком доступе, чтобы вы могли хотя бы узнать о "
"проблеме. См. https://mail.python.org/pipermail/python-dev/2002-"
"December/031107.html для более подробного объяснения этого изменения. "
"(Реализован Мартином фон Лёвисом.)"

#: ../../whatsnew/2.3.rst:1572
msgid ""
"Calling Tcl methods through :mod:`!_tkinter` no longer  returns only "
"strings. Instead, if Tcl returns other objects those objects are converted "
"to their Python equivalent, if one exists, or wrapped with a :class:`!"
"_tkinter.Tcl_Obj` object if no Python equivalent exists. This behavior can "
"be controlled through the :meth:`!wantobjects` method of :class:`!tkapp` "
"objects."
msgstr ""
"Вызов методов Tcl через :mod:`!_tkinter` больше не возвращает только строки. "
"Вместо этого, если Tcl возвращает другие объекты, эти объекты преобразуются "
"в их эквивалент Python, если он существует, или обертываются объектом :class:"
"`!_tkinter.Tcl_Obj`, если эквивалента Python не существует. Этим поведением "
"можно управлять с помощью метода :meth:`!wantobjects` объектов :class:`!"
"tkapp`."

#: ../../whatsnew/2.3.rst:1578
msgid ""
"When using :mod:`!_tkinter` through the :mod:`!Tkinter` module (as most "
"Tkinter applications will), this feature is always activated. It should not "
"cause compatibility problems, since Tkinter would always convert string "
"results to Python types where possible."
msgstr ""
"При использовании :mod:`!_tkinter` через модуль :mod:`!Tkinter` (как и "
"большинство приложений Tkinter), эта функция всегда активируется. Это не "
"должно вызывать проблем совместимости, поскольку Tkinter всегда преобразует "
"строковые результаты в типы Python, где это возможно."

#: ../../whatsnew/2.3.rst:1583
msgid ""
"If any incompatibilities are found, the old behavior can be restored by "
"setting the :attr:`!wantobjects` variable in the :mod:`!Tkinter` module to "
"false before creating the first :class:`!tkapp` object. ::"
msgstr ""
"Если обнаружены какие-либо несовместимости, старое поведение можно "
"восстановить, установив для переменной :attr:`!wantobjects` в модуле :mod:`!"
"Tkinter` значение false перед созданием первого объекта :class:`!tkapp`. ::"

#: ../../whatsnew/2.3.rst:1587
msgid ""
"import Tkinter\n"
"Tkinter.wantobjects = 0"
msgstr ""
"import Tkinter\n"
"Tkinter.wantobjects = 0"

#: ../../whatsnew/2.3.rst:1590
msgid "Any breakage caused by this change should be reported as a bug."
msgstr ""
"О любых поломках, вызванных этим изменением, следует сообщать как об ошибке."

#: ../../whatsnew/2.3.rst:1592
msgid ""
"The :mod:`!UserDict` module has a new :class:`!DictMixin` class which "
"defines all dictionary methods for classes that already have a minimum "
"mapping interface.  This greatly simplifies writing classes that need to be "
"substitutable for dictionaries, such as the classes in  the :mod:`shelve` "
"module."
msgstr ""
"Модуль :mod:`!UserDict` имеет новый класс :class:`!DictMixin`, который "
"определяет все словарные методы для классов, которые уже имеют минимальный "
"интерфейс сопоставления. Это значительно упрощает написание классов, которые "
"необходимо заменять словарями, например, классов в модуле :mod:`shelve`."

#: ../../whatsnew/2.3.rst:1598
msgid ""
"Adding the mix-in as a superclass provides the full dictionary interface "
"whenever the class defines :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`!keys`. For example::"
msgstr ""
"Добавление примеси в качестве суперкласса обеспечивает полный интерфейс "
"словаря всякий раз, когда класс определяет :meth:`~object.__getitem__`, :"
"meth:`~object.__setitem__`, :meth:`~object.__delitem__` и :meth :`!ключи`. "
"Например::"

#: ../../whatsnew/2.3.rst:1602
msgid ""
">>> import UserDict\n"
">>> class SeqDict(UserDict.DictMixin):\n"
"...     \"\"\"Dictionary lookalike implemented with lists.\"\"\"\n"
"...     def __init__(self):\n"
"...         self.keylist = []\n"
"...         self.valuelist = []\n"
"...     def __getitem__(self, key):\n"
"...         try:\n"
"...             i = self.keylist.index(key)\n"
"...         except ValueError:\n"
"...             raise KeyError\n"
"...         return self.valuelist[i]\n"
"...     def __setitem__(self, key, value):\n"
"...         try:\n"
"...             i = self.keylist.index(key)\n"
"...             self.valuelist[i] = value\n"
"...         except ValueError:\n"
"...             self.keylist.append(key)\n"
"...             self.valuelist.append(value)\n"
"...     def __delitem__(self, key):\n"
"...         try:\n"
"...             i = self.keylist.index(key)\n"
"...         except ValueError:\n"
"...             raise KeyError\n"
"...         self.keylist.pop(i)\n"
"...         self.valuelist.pop(i)\n"
"...     def keys(self):\n"
"...         return list(self.keylist)\n"
"...\n"
">>> s = SeqDict()\n"
">>> dir(s)      # See that other dictionary methods are implemented\n"
"['__cmp__', '__contains__', '__delitem__', '__doc__', '__getitem__',\n"
" '__init__', '__iter__', '__len__', '__module__', '__repr__',\n"
" '__setitem__', 'clear', 'get', 'has_key', 'items', 'iteritems',\n"
" 'iterkeys', 'itervalues', 'keylist', 'keys', 'pop', 'popitem',\n"
" 'setdefault', 'update', 'valuelist', 'values']"
msgstr ""
">>> import UserDict\n"
">>> class SeqDict(UserDict.DictMixin):\n"
"...     \"\"\"Dictionary lookalike implemented with lists.\"\"\"\n"
"...     def __init__(self):\n"
"...         self.keylist = []\n"
"...         self.valuelist = []\n"
"...     def __getitem__(self, key):\n"
"...         try:\n"
"...             i = self.keylist.index(key)\n"
"...         except ValueError:\n"
"...             raise KeyError\n"
"...         return self.valuelist[i]\n"
"...     def __setitem__(self, key, value):\n"
"...         try:\n"
"...             i = self.keylist.index(key)\n"
"...             self.valuelist[i] = value\n"
"...         except ValueError:\n"
"...             self.keylist.append(key)\n"
"...             self.valuelist.append(value)\n"
"...     def __delitem__(self, key):\n"
"...         try:\n"
"...             i = self.keylist.index(key)\n"
"...         except ValueError:\n"
"...             raise KeyError\n"
"...         self.keylist.pop(i)\n"
"...         self.valuelist.pop(i)\n"
"...     def keys(self):\n"
"...         return list(self.keylist)\n"
"...\n"
">>> s = SeqDict()\n"
">>> dir(s)      # See that other dictionary methods are implemented\n"
"['__cmp__', '__contains__', '__delitem__', '__doc__', '__getitem__',\n"
" '__init__', '__iter__', '__len__', '__module__', '__repr__',\n"
" '__setitem__', 'clear', 'get', 'has_key', 'items', 'iteritems',\n"
" 'iterkeys', 'itervalues', 'keylist', 'keys', 'pop', 'popitem',\n"
" 'setdefault', 'update', 'valuelist', 'values']"

#: ../../whatsnew/2.3.rst:1639
msgid "(Contributed by Raymond Hettinger.)"
msgstr "(Предоставлено Раймондом Хеттингером.)"

#: ../../whatsnew/2.3.rst:1641
msgid ""
"The DOM implementation in :mod:`xml.dom.minidom` can now generate XML output "
"in a particular encoding by providing an optional encoding argument to the :"
"meth:`~xml.dom.minidom.Node.toxml` and :meth:`~xml.dom.minidom.Node."
"toprettyxml` methods of DOM nodes."
msgstr ""
"Реализация DOM в :mod:`xml.dom.minidom` теперь может генерировать выходные "
"данные XML в определенной кодировке, предоставляя необязательный аргумент "
"кодировки для :meth:`~xml.dom.minidom.Node.toxml` и :meth: `~xml.dom.minidom."
"Node.toprettyxml` методы узлов DOM."

#: ../../whatsnew/2.3.rst:1645
msgid ""
"The :mod:`!xmlrpclib` module now supports an XML-RPC extension for handling "
"nil data values such as Python's ``None``.  Nil values are always supported "
"on unmarshalling an XML-RPC response.  To generate requests containing "
"``None``, you must supply a true value for the *allow_none* parameter when "
"creating a :class:`!Marshaller` instance."
msgstr ""
"Модуль :mod:`!xmlrpclib` теперь поддерживает расширение XML-RPC для "
"обработки нулевых значений данных, таких как Python ``None``. Значения Nil "
"всегда поддерживаются при демаршаллинге ответа XML-RPC. Чтобы генерировать "
"запросы, содержащие ``None``, вы должны указать истинное значение для "
"параметра *allow_none* при создании экземпляра :class:`!Marshaller`."

#: ../../whatsnew/2.3.rst:1651
msgid ""
"The new :mod:`!DocXMLRPCServer` module allows writing self-documenting XML-"
"RPC servers. Run it in demo mode (as a program) to see it in action.   "
"Pointing the web browser to the RPC server produces pydoc-style "
"documentation; pointing xmlrpclib to the server allows invoking the actual "
"methods. (Contributed by Brian Quinlan.)"
msgstr ""
"Новый модуль :mod:`!DocXMLRPCServer` позволяет писать самодокументируемые "
"XML-RPC-серверы. Запустите его в демонстрационном режиме (как программу), "
"чтобы увидеть его в действии. При указании веб-браузером сервера RPC "
"создается документация в стиле pydoc; указание xmlrpclib на сервер позволяет "
"вызывать фактические методы. (Предоставлено Брайаном Куинланом.)"

#: ../../whatsnew/2.3.rst:1657
msgid ""
"Support for internationalized domain names (RFCs 3454, 3490, 3491, and 3492) "
"has been added. The \"idna\" encoding can be used to convert between a "
"Unicode domain name and the ASCII-compatible encoding (ACE) of that name. ::"
msgstr ""
"Добавлена ​​поддержка интернационализированных доменных имен (RFC 3454, 3490, "
"3491 и 3492). Кодировку «idna» можно использовать для преобразования "
"доменного имени Unicode в ASCII-совместимую кодировку (ACE) этого имени. ::"

#: ../../whatsnew/2.3.rst:1661
msgid ""
">{}>{}> u\"www.Alliancefrançaise.nu\".encode(\"idna\")\n"
"'www.xn--alliancefranaise-npb.nu'"
msgstr ""
">{}>{}> u\"www.Alliancefrançaise.nu\".encode(\"idna\")\n"
"'www.xn--alliancefranaise-npb.nu'"

#: ../../whatsnew/2.3.rst:1664
msgid ""
"The :mod:`socket` module has also been extended to transparently convert "
"Unicode hostnames to the ACE version before passing them to the C library. "
"Modules that deal with hostnames such as :mod:`!httplib` and :mod:`ftplib`) "
"also support Unicode host names; :mod:`!httplib` also sends HTTP ``Host`` "
"headers using the ACE version of the domain name.  :mod:`urllib` supports "
"Unicode URLs with non-ASCII host names as long as the ``path`` part of the "
"URL is ASCII only."
msgstr ""
"Модуль :mod:`socket` также был расширен для прозрачного преобразования имен "
"хостов Unicode в версию ACE перед передачей их в библиотеку C. Модули, "
"которые работают с именами хостов, например :mod:`!httplib` и :mod:"
"`ftplib`), также поддерживают имена хостов в Юникоде; :mod:`!httplib` также "
"отправляет HTTP-заголовки ``Host``, используя версию доменного имени ACE. :"
"mod:`urllib` поддерживает URL-адреса в формате Unicode с именами хостов, "
"отличными от ASCII, при условии, что часть URL-адреса ``path`` содержит "
"только ASCII."

#: ../../whatsnew/2.3.rst:1672
msgid ""
"To implement this change, the :mod:`stringprep` module, the  "
"``mkstringprep`` tool and the ``punycode`` encoding have been added."
msgstr ""
"Для реализации этого изменения были добавлены модуль :mod:`stringprep`, "
"инструмент ``mkstringprep`` и кодировка ``punycode``."

#: ../../whatsnew/2.3.rst:1679
msgid "Date/Time Type"
msgstr "Тип даты/времени"

#: ../../whatsnew/2.3.rst:1681
msgid ""
"Date and time types suitable for expressing timestamps were added as the :"
"mod:`datetime` module.  The types don't support different calendars or many "
"fancy features, and just stick to the basics of representing time."
msgstr ""
"Типы даты и времени, подходящие для выражения временных меток, были "
"добавлены в виде модуля :mod:`datetime`. Эти типы не поддерживают различные "
"календари или множество необычных функций и просто придерживаются основ "
"представления времени."

#: ../../whatsnew/2.3.rst:1685
msgid ""
"The three primary types are: :class:`~datetime.date`, representing a day, "
"month, and year; :class:`~datetime.time`, consisting of hour, minute, and "
"second; and :class:`~datetime.datetime`, which contains all the attributes "
"of both :class:`~datetime.date` and :class:`~datetime.time`. There's also a :"
"class:`~datetime.timedelta` class representing differences between two "
"points in time, and time zone logic is implemented by classes inheriting "
"from the abstract :class:`~datetime.tzinfo` class."
msgstr ""
"Три основных типа: :class:`~datetime.date`, представляющий день, месяц и "
"год; :class:`~datetime.time`, состоящий из часов, минут и секунд; и :class:"
"`~datetime.datetime`, который содержит все атрибуты как :class:`~datetime."
"date`, так и :class:`~datetime.time`. Также существует класс :class:"
"`~datetime.timedelta`, представляющий разницу между двумя моментами времени, "
"а логика часового пояса реализуется классами, унаследованными от "
"абстрактного :class:`~datetime.tzinfo` класса."

#: ../../whatsnew/2.3.rst:1692
msgid ""
"You can create instances of :class:`~datetime.date` and :class:`~datetime."
"time` by either supplying keyword arguments to the appropriate constructor, "
"e.g. ``datetime.date(year=1972, month=10, day=15)``, or by using one of a "
"number of class methods.  For example, the :meth:`~datetime.date.today` "
"class method returns the current local date."
msgstr ""
"Вы можете создавать экземпляры :class:`~datetime.date` и :class:`~datetime."
"time`, передавая аргументы ключевого слова соответствующему конструктору, "
"например ``datetime.date(year=1972,month=10, day =15)`` или используя один "
"из нескольких методов класса. Например, метод класса :meth:`~datetime.date."
"today` возвращает текущую локальную дату."

#: ../../whatsnew/2.3.rst:1698
msgid ""
"Once created, instances of the date/time classes are all immutable. There "
"are a number of methods for producing formatted strings from objects::"
msgstr ""
"После создания экземпляры классов даты/времени становятся неизменяемыми. "
"Существует несколько методов создания форматированных строк из объектов:"

#: ../../whatsnew/2.3.rst:1701
msgid ""
">>> import datetime\n"
">>> now = datetime.datetime.now()\n"
">>> now.isoformat()\n"
"'2002-12-30T21:27:03.994956'\n"
">>> now.ctime()  # Only available on date, datetime\n"
"'Mon Dec 30 21:27:03 2002'\n"
">>> now.strftime('%Y %d %b')\n"
"'2002 30 Dec'"
msgstr ""
">>> import datetime\n"
">>> now = datetime.datetime.now()\n"
">>> now.isoformat()\n"
"'2002-12-30T21:27:03.994956'\n"
">>> now.ctime()  # Only available on date, datetime\n"
"'Mon Dec 30 21:27:03 2002'\n"
">>> now.strftime('%Y %d %b')\n"
"'2002 30 Dec'"

#: ../../whatsnew/2.3.rst:1710
msgid ""
"The :meth:`~datetime.datetime.replace` method allows modifying one or more "
"fields  of a :class:`~datetime.date` or :class:`~datetime.datetime` "
"instance, returning a new instance::"
msgstr ""
"Метод :meth:`~datetime.datetime.replace` позволяет изменять одно или "
"несколько полей экземпляра :class:`~datetime.date` или :class:`~datetime."
"datetime`, возвращая новый экземпляр::"

#: ../../whatsnew/2.3.rst:1713
msgid ""
">>> d = datetime.datetime.now()\n"
">>> d\n"
"datetime.datetime(2002, 12, 30, 22, 15, 38, 827738)\n"
">>> d.replace(year=2001, hour = 12)\n"
"datetime.datetime(2001, 12, 30, 12, 15, 38, 827738)\n"
">>>"
msgstr ""
">>> d = datetime.datetime.now()\n"
">>> d\n"
"datetime.datetime(2002, 12, 30, 22, 15, 38, 827738)\n"
">>> d.replace(year=2001, hour = 12)\n"
"datetime.datetime(2001, 12, 30, 12, 15, 38, 827738)\n"
">>>"

#: ../../whatsnew/2.3.rst:1720
msgid ""
"Instances can be compared, hashed, and converted to strings (the result is "
"the same as that of :meth:`~datetime.datetime.isoformat`).  :class:"
"`~datetime.date` and :class:`~datetime.datetime` instances can be subtracted "
"from each other, and added to :class:`~datetime.timedelta` instances.  The "
"largest missing feature is that there's no standard library support for "
"parsing strings and getting back a :class:`~datetime.date` or :class:"
"`~datetime.datetime`."
msgstr ""
"Экземпляры можно сравнивать, хэшировать и преобразовывать в строки "
"(результат тот же, что и у :meth:`~datetime.datetime.isoformat`). "
"Экземпляры :class:`~datetime.date` и :class:`~datetime.datetime` можно "
"вычитать друг из друга и добавлять к экземплярам :class:`~datetime."
"timedelta`. Самая большая недостающая функция заключается в том, что "
"стандартная библиотека не поддерживает анализ строк и возврат :class:"
"`~datetime.date` или :class:`~datetime.datetime`."

#: ../../whatsnew/2.3.rst:1727
msgid ""
"For more information, refer to the module's reference documentation. "
"(Contributed by Tim Peters.)"
msgstr ""
"Для получения дополнительной информации обратитесь к справочной документации "
"модуля. (Предоставлено Тимом Питерсом.)"

#: ../../whatsnew/2.3.rst:1734
msgid "The optparse Module"
msgstr "Модуль optparse"

#: ../../whatsnew/2.3.rst:1736
msgid ""
"The :mod:`getopt` module provides simple parsing of command-line arguments.  "
"The new :mod:`optparse` module (originally named Optik) provides more "
"elaborate command-line parsing that follows the Unix conventions, "
"automatically creates the output for :option:`!--help`, and can perform "
"different actions for different options."
msgstr ""
"Модуль :mod:`getopt` обеспечивает простой анализ аргументов командной "
"строки. Новый модуль :mod:`optparse` (первоначально называвшийся Optik) "
"обеспечивает более сложный анализ командной строки, соответствующий "
"соглашениям Unix, автоматически создает выходные данные для :option:`!--"
"help` и может выполнять различные действия для разных параметров. ."

#: ../../whatsnew/2.3.rst:1742
msgid ""
"You start by creating an instance of :class:`~optparse.OptionParser` and "
"telling it what your program's options are. ::"
msgstr ""
"Вы начинаете с создания экземпляра :class:`~optparse.OptionParser` и "
"указания ему параметров вашей программы. ::"

#: ../../whatsnew/2.3.rst:1745
msgid ""
"import sys\n"
"from optparse import OptionParser\n"
"\n"
"op = OptionParser()\n"
"op.add_option('-i', '--input',\n"
"              action='store', type='string', dest='input',\n"
"              help='set input filename')\n"
"op.add_option('-l', '--length',\n"
"              action='store', type='int', dest='length',\n"
"              help='set maximum length of output')"
msgstr ""
"import sys\n"
"from optparse import OptionParser\n"
"\n"
"op = OptionParser()\n"
"op.add_option('-i', '--input',\n"
"              action='store', type='string', dest='input',\n"
"              help='set input filename')\n"
"op.add_option('-l', '--length',\n"
"              action='store', type='int', dest='length',\n"
"              help='set maximum length of output')"

#: ../../whatsnew/2.3.rst:1756
msgid ""
"Parsing a command line is then done by calling the :meth:`~optparse."
"OptionParser.parse_args` method. ::"
msgstr ""
"Затем анализ командной строки выполняется путем вызова метода :meth:"
"`~optparse.OptionParser.parse_args`. ::"

#: ../../whatsnew/2.3.rst:1758
msgid ""
"options, args = op.parse_args(sys.argv[1:])\n"
"print options\n"
"print args"
msgstr ""
"options, args = op.parse_args(sys.argv[1:])\n"
"print options\n"
"print args"

#: ../../whatsnew/2.3.rst:1762
msgid ""
"This returns an object containing all of the option values, and a list of "
"strings containing the remaining arguments."
msgstr ""
"Это возвращает объект, содержащий все значения параметров, и список строк, "
"содержащий оставшиеся аргументы."

#: ../../whatsnew/2.3.rst:1765
msgid ""
"Invoking the script with the various arguments now works as you'd expect it "
"to. Note that the length argument is automatically converted to an integer."
msgstr ""
"Вызов сценария с различными аргументами теперь работает так, как и следовало "
"ожидать. Обратите внимание, что аргумент длины автоматически преобразуется в "
"целое число."

#: ../../whatsnew/2.3.rst:1768
msgid ""
"$ ./python opt.py -i data arg1\n"
"<Values at 0x400cad4c: {'input': 'data', 'length': None}>\n"
"['arg1']\n"
"$ ./python opt.py --input=data --length=4\n"
"<Values at 0x400cad2c: {'input': 'data', 'length': 4}>\n"
"[]\n"
"$"
msgstr ""
"$ ./python opt.py -i data arg1\n"
"<Values at 0x400cad4c: {'input': 'data', 'length': None}>\n"
"['arg1']\n"
"$ ./python opt.py --input=data --length=4\n"
"<Values at 0x400cad2c: {'input': 'data', 'length': 4}>\n"
"[]\n"
"$"

#: ../../whatsnew/2.3.rst:1778
msgid "The help message is automatically generated for you:"
msgstr "Справочное сообщение автоматически генерируется для вас:"

#: ../../whatsnew/2.3.rst:1780
msgid ""
"$ ./python opt.py --help\n"
"usage: opt.py [options]\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  -iINPUT, --input=INPUT\n"
"                        set input filename\n"
"  -lLENGTH, --length=LENGTH\n"
"                        set maximum length of output\n"
"$"
msgstr ""
"$ ./python opt.py --help\n"
"usage: opt.py [options]\n"
"\n"
"options:\n"
"  -h, --help            show this help message and exit\n"
"  -iINPUT, --input=INPUT\n"
"                        set input filename\n"
"  -lLENGTH, --length=LENGTH\n"
"                        set maximum length of output\n"
"$"

#: ../../whatsnew/2.3.rst:1793
msgid "See the module's documentation for more details."
msgstr "Более подробную информацию смотрите в документации модуля."

#: ../../whatsnew/2.3.rst:1796
msgid ""
"Optik was written by Greg Ward, with suggestions from the readers of the "
"Getopt SIG."
msgstr ""
"Optik был написан Грегом Уордом с учетом предложений читателей Getopt SIG."

#: ../../whatsnew/2.3.rst:1805
msgid "Pymalloc: A Specialized Object Allocator"
msgstr "Pymalloc: специализированный распределитель объектов"

#: ../../whatsnew/2.3.rst:1807
msgid ""
"Pymalloc, a specialized object allocator written by Vladimir Marangozov, was "
"a feature added to Python 2.1.  Pymalloc is intended to be faster than the "
"system :c:func:`malloc` and to have less memory overhead for allocation "
"patterns typical of Python programs. The allocator uses C's :c:func:`malloc` "
"function to get large pools of memory and then fulfills smaller memory "
"requests from these pools."
msgstr ""
"Pymalloc, специализированный распределитель объектов, написанный Владимиром "
"Марангозовым, был функцией, добавленной в Python 2.1. Pymalloc должен "
"работать быстрее, чем система :c:func:`malloc`, и иметь меньшие затраты "
"памяти для шаблонов распределения, типичных для программ Python. "
"Распределитель использует функцию C :c:func:`malloc` для получения больших "
"пулов памяти, а затем выполняет меньшие запросы памяти из этих пулов."

#: ../../whatsnew/2.3.rst:1813
msgid ""
"In 2.1 and 2.2, pymalloc was an experimental feature and wasn't enabled by "
"default; you had to explicitly enable it when compiling Python by providing "
"the :option:`!--with-pymalloc` option to the :program:`configure` script.  "
"In 2.3, pymalloc has had further enhancements and is now enabled by default; "
"you'll have to supply :option:`!--without-pymalloc` to disable it."
msgstr ""
"В версиях 2.1 и 2.2 pymalloc был экспериментальной функцией и не был включен "
"по умолчанию; вам нужно было явно включить его при компиляции Python, указав "
"параметр :option:`!--with-pymalloc` для сценария :program:`configure`. В "
"версии 2.3 pymalloc получил дальнейшие улучшения и теперь включен по "
"умолчанию; вам придется указать :option:`!--without-pymalloc`, чтобы "
"отключить его."

#: ../../whatsnew/2.3.rst:1819
msgid ""
"This change is transparent to code written in Python; however, pymalloc may "
"expose bugs in C extensions.  Authors of C extension modules should test "
"their code with pymalloc enabled, because some incorrect code may cause core "
"dumps at runtime."
msgstr ""
"Это изменение прозрачно для кода, написанного на Python; однако pymalloc "
"может выявить ошибки в расширениях C. Авторам модулей расширения C следует "
"тестировать свой код с включенным pymalloc, поскольку некоторый неверный код "
"может вызвать дампы ядра во время выполнения."

#: ../../whatsnew/2.3.rst:1824
msgid ""
"There's one particularly common error that causes problems.  There are a "
"number of memory allocation functions in Python's C API that have previously "
"just been aliases for the C library's :c:func:`malloc` and :c:func:`free`, "
"meaning that if you accidentally called mismatched functions the error "
"wouldn't be noticeable. When the object allocator is enabled, these "
"functions aren't aliases of :c:func:`malloc` and :c:func:`free` any more, "
"and calling the wrong function to free memory may get you a core dump.  For "
"example, if memory was allocated using :c:func:`PyObject_Malloc`, it has to "
"be freed using :c:func:`PyObject_Free`, not :c:func:`free`.  A few modules "
"included with Python fell afoul of this and had to be fixed; doubtless there "
"are more third-party modules that will have the same problem."
msgstr ""
"Есть одна особенно распространенная ошибка, которая вызывает проблемы. В API "
"C Python есть ряд функций распределения памяти, которые ранее были просто "
"псевдонимами для :c:func:`malloc` и :c:func:`free` из библиотеки C, что "
"означает, что если вы случайно вызвали несовпадающие функции, возникнет "
"ошибка. не было бы заметно. Когда распределитель объектов включен, эти "
"функции больше не являются псевдонимами :c:func:`malloc` и :c:func:`free`, и "
"вызов неправильной функции для освобождения памяти может привести к "
"получению дампа ядра. Например, если память была выделена с помощью :c:func:"
"` PyObj ect_Malloc`, ее необходимо освободить с помощью :c:func:` PyObj "
"ect_Free`, а не :c:func:`free`. Несколько модулей, входящих в состав Python, "
"не соответствовали этому, и их пришлось исправлять; несомненно, есть и "
"другие сторонние модули, у которых возникнет такая же проблема."

#: ../../whatsnew/2.3.rst:1836
msgid ""
"As part of this change, the confusing multiple interfaces for allocating "
"memory have been consolidated down into two API families. Memory allocated "
"with one family must not be manipulated with functions from the other "
"family.  There is one family for allocating chunks of memory and another "
"family of functions specifically for allocating Python objects."
msgstr ""
"В рамках этого изменения запутанные многочисленные интерфейсы для "
"распределения памяти были объединены в два семейства API. Память, выделенная "
"одним семейством, не должна использоваться с функциями другого семейства. "
"Существует одно семейство для выделения фрагментов памяти и другое семейство "
"функций, специально предназначенное для выделения объектов Python."

#: ../../whatsnew/2.3.rst:1842
msgid ""
"To allocate and free an undistinguished chunk of memory use the \"raw "
"memory\" family: :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc`, and :c:"
"func:`PyMem_Free`."
msgstr ""
"Чтобы выделить и освободить невыделенный фрагмент памяти, используйте "
"семейство «необработанной памяти»: :c:func:`PyMem_Malloc`, :c:func:"
"`PyMem_Realloc` и :c:func:`PyMem_Free`."

#: ../../whatsnew/2.3.rst:1845
msgid ""
"The \"object memory\" family is the interface to the pymalloc facility "
"described above and is biased towards a large number of \"small\" "
"allocations: :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc`, and :c:"
"func:`PyObject_Free`."
msgstr ""
"Семейство «объектной памяти» представляет собой интерфейс описанного выше "
"средства pymalloc и ориентировано на большое количество «маленьких» "
"выделений: :c:func:` PyObj ect_Malloc`, :c:func:` PyObj ect_Realloc` и : c:"
"func:` PyObj ect_Free`."

#: ../../whatsnew/2.3.rst:1849
msgid ""
"To allocate and free Python objects, use the \"object\" family :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar`, and :c:func:`PyObject_Del`."
msgstr ""
"Чтобы выделить и освободить объекты Python, используйте семейство "
"«объектов» :c:macro:` PyObj ect_New`, :c:macro:` PyObj ect_NewVar` и :c:func:"
"` PyObj ect_Del`."

#: ../../whatsnew/2.3.rst:1852
msgid ""
"Thanks to lots of work by Tim Peters, pymalloc in 2.3 also provides "
"debugging features to catch memory overwrites and doubled frees in both "
"extension modules and in the interpreter itself.  To enable this support, "
"compile a debugging version of the Python interpreter by running :program:"
"`configure` with :option:`!--with-pydebug`."
msgstr ""
"Благодаря большой работе Тима Питерса, pymalloc в версии 2.3 также "
"предоставляет функции отладки для обнаружения перезаписи и двойного "
"освобождения памяти как в модулях расширения, так и в самом интерпретаторе. "
"Чтобы включить эту поддержку, скомпилируйте отладочную версию интерпретатора "
"Python, запустив :program:`configure` с :option:`!--with-pydebug`."

#: ../../whatsnew/2.3.rst:1858
msgid ""
"To aid extension writers, a header file :file:`Misc/pymemcompat.h` is "
"distributed with the source to Python 2.3 that allows Python extensions to "
"use the 2.3 interfaces to memory allocation while compiling against any "
"version of Python since 1.5.2.  You would copy the file from Python's source "
"distribution and bundle it with the source of your extension."
msgstr ""
"В помощь авторам расширений вместе с исходным кодом Python 2.3 "
"распространяется заголовочный файл :file:`Misc/pymemcompat.h`, который "
"позволяет расширениям Python использовать интерфейсы 2.3 для распределения "
"памяти при компиляции с любой версией Python, начиная с 1.5.2. Вы должны "
"скопировать файл из дистрибутива исходного кода Python и связать его с "
"исходным кодом вашего расширения."

#: ../../whatsnew/2.3.rst:1867
msgid "https://hg.python.org/cpython/file/default/Objects/obmalloc.c"
msgstr "https://hg.python.org/cpython/file/default/Objects/obmalloc.c"

#: ../../whatsnew/2.3.rst:1868
msgid ""
"For the full details of the pymalloc implementation, see the comments at the "
"top of the file :file:`Objects/obmalloc.c` in the Python source code. The "
"above link points to the file within the python.org SVN browser."
msgstr ""
"Полную информацию о реализации pymalloc см. в комментариях вверху файла :"
"file:`Objects/obmalloc.c` в исходном коде Python. Приведенная выше ссылка "
"указывает на файл в браузере SVN python.org."

#: ../../whatsnew/2.3.rst:1876
msgid "Build and C API Changes"
msgstr "Изменения API сборки и C"

#: ../../whatsnew/2.3.rst:1878
msgid "Changes to Python's build process and to the C API include:"
msgstr "Изменения в процессе сборки Python и C API включают в себя:"

#: ../../whatsnew/2.3.rst:1880
msgid ""
"The cycle detection implementation used by the garbage collection has proven "
"to be stable, so it's now been made mandatory.  You can no longer compile "
"Python without it, and the :option:`!--with-cycle-gc` switch to :program:"
"`configure` has been removed."
msgstr ""
"Реализация обнаружения циклов, используемая при сборке мусора, оказалась "
"стабильной, поэтому теперь она стала обязательной. Без него вы больше не "
"сможете компилировать Python, а переключатель :option:`!--with-cycle-gc` на :"
"program:`configure` был удален."

#: ../../whatsnew/2.3.rst:1885
msgid ""
"Python can now optionally be built as a shared library (:file:`libpython2.3."
"so`) by supplying :option:`!--enable-shared` when running Python's :program:"
"`configure` script.  (Contributed by Ondrej Palkovsky.)"
msgstr ""
"Теперь Python можно дополнительно собрать как общую библиотеку (:file:"
"`libpython2.3.so`), указав :option:`!--enable-shared` при запуске скрипта "
"Python :program:`configure`. (Предоставлено Андреем Палковским.)"

#: ../../whatsnew/2.3.rst:1889
msgid ""
"The :c:macro:`!DL_EXPORT` and :c:macro:`!DL_IMPORT` macros are now "
"deprecated. Initialization functions for Python extension modules should now "
"be declared using the new macro :c:macro:`PyMODINIT_FUNC`, while the Python "
"core will generally use the :c:macro:`!PyAPI_FUNC` and :c:macro:`!"
"PyAPI_DATA` macros."
msgstr ""
"Макросы :c:macro:`!DL_EXPORT` и :c:macro:`!DL_IMPORT` объявлены устаревшими. "
"Функции инициализации для модулей расширения Python теперь должны быть "
"объявлены с использованием нового макроса :c:macro:`PyMODINIT_FUNC`, в то "
"время как ядро ​​Python обычно будет использовать :c:macro:`!PyAPI_FUNC` и :c:"
"macro:`!PyAPI_DATA` макросы."

#: ../../whatsnew/2.3.rst:1894
msgid ""
"The interpreter can be compiled without any docstrings for the built-in "
"functions and modules by supplying :option:`!--without-doc-strings` to the :"
"program:`configure` script. This makes the Python executable about 10% "
"smaller, but will also mean that you can't get help for Python's built-ins.  "
"(Contributed by Gustavo Niemeyer.)"
msgstr ""
"Интерпретатор можно скомпилировать без каких-либо строк документации для "
"встроенных функций и модулей, указав :option:`!--without-doc-strings` в "
"скрипт :program:`configure`. Это делает исполняемый файл Python примерно на "
"10 % меньше, но также означает, что вы не сможете получить помощь по "
"встроенным модулям Python. (Предоставлено Густаво Нимейером.)"

#: ../../whatsnew/2.3.rst:1900
msgid ""
"The :c:func:`!PyArg_NoArgs` macro is now deprecated, and code that uses it "
"should be changed.  For Python 2.2 and later, the method definition table "
"can specify the :c:macro:`METH_NOARGS` flag, signalling that there are no "
"arguments, and the argument checking can then be removed.  If compatibility "
"with pre-2.2 versions of Python is important, the code could use "
"``PyArg_ParseTuple(args, \"\")`` instead, but this will be slower than "
"using :c:macro:`METH_NOARGS`."
msgstr ""
"Макрос :c:func:`!PyArg_NoArgs` устарел, и код, который его использует, "
"следует изменить. Для Python 2.2 и более поздних версий таблица определения "
"метода может указывать флаг :c:macro:`METH_NOARGS`, сигнализирующий об "
"отсутствии аргументов, после чего проверку аргументов можно удалить. Если "
"важна совместимость с версиями Python до версии 2.2, вместо этого в коде "
"можно использовать PyArg_ParseTuple(args, \"\"), но это будет медленнее, чем "
"использование :c:macro:`METH_NOARGS`."

#: ../../whatsnew/2.3.rst:1907
msgid ""
":c:func:`PyArg_ParseTuple` accepts new format characters for various sizes "
"of unsigned integers: ``B`` for :c:expr:`unsigned char`, ``H`` for :c:expr:"
"`unsigned short int`,  ``I`` for :c:expr:`unsigned int`,  and ``K`` for :c:"
"expr:`unsigned long long`."
msgstr ""
":c:func:`PyArg_ParseTuple` принимает символы нового формата для различных "
"размеров беззнаковых целых чисел: ``B`` для :c:expr:`unsigned char`, ``H`` "
"для :c:expr:`unsigned short int `, ``I`` для :c:expr:`unsigned int` и ``K`` "
"для :c:expr:`unsigned long long`."

#: ../../whatsnew/2.3.rst:1912
msgid ""
"A new function, ``PyObject_DelItemString(mapping, char *key)`` was added as "
"shorthand for ``PyObject_DelItem(mapping, PyString_New(key))``."
msgstr ""
"Новая функция PyObj ect_DelItemString(mapping, char *key)`` была добавлена ​​"
"как сокращение для PyObj ect_DelItem(mapping, PyString_New(key))``."

#: ../../whatsnew/2.3.rst:1915
msgid ""
"File objects now manage their internal string buffer differently, increasing "
"it exponentially when needed.  This results in the benchmark tests in :file:"
"`Lib/test/test_bufio.py` speeding up considerably (from 57 seconds to 1.7 "
"seconds, according to one measurement)."
msgstr ""
"Файловые объекты теперь по-другому управляют своим внутренним строковым "
"буфером, увеличивая его в геометрической прогрессии при необходимости. Это "
"приводит к значительному ускорению тестов производительности в :file:`Lib/"
"test/test_bufio.py` (по данным одного измерения, с 57 секунд до 1,7 секунды)."

#: ../../whatsnew/2.3.rst:1920
msgid ""
"It's now possible to define class and static methods for a C extension type "
"by setting either the :c:macro:`METH_CLASS` or :c:macro:`METH_STATIC` flags "
"in a method's :c:type:`PyMethodDef` structure."
msgstr ""
"Теперь можно определить класс и статические методы для типа расширения C, "
"установив флаги :c:macro:`METH_CLASS` или :c:macro:`METH_STATIC` в "
"структуре :c:type:`PyMethodDef` метода."

#: ../../whatsnew/2.3.rst:1924
msgid ""
"Python now includes a copy of the Expat XML parser's source code, removing "
"any dependence on a system version or local installation of Expat."
msgstr ""
"Python теперь включает копию исходного кода парсера Expat XML, устраняя "
"любую зависимость от версии системы или локальной установки Expat."

#: ../../whatsnew/2.3.rst:1927
msgid ""
"If you dynamically allocate type objects in your extension, you should be "
"aware of a change in the rules relating to the :attr:`~type.__module__` and :"
"attr:`~type.__name__` attributes.  In summary, you will want to ensure the "
"type's dictionary contains a ``'__module__'`` key; making the module name "
"the part of the type name leading up to the final period will no longer have "
"the desired effect.  For more detail, read the API reference documentation "
"or the  source."
msgstr ""
"Если вы динамически выделяете объекты типа в своем расширении, вы должны "
"знать об изменении правил, касающихся атрибутов :attr:`~type.__module__` и :"
"attr:`~type.__name__`. Таким образом, вам нужно убедиться, что словарь типа "
"содержит ключ ``'__module__'``; создание имени модуля частью имени типа, "
"предшествующей последней точке, больше не будет иметь желаемого эффекта. "
"Более подробную информацию можно найти в справочной документации API или "
"исходном коде."

#: ../../whatsnew/2.3.rst:1938
msgid "Port-Specific Changes"
msgstr "Изменения для конкретного порта"

#: ../../whatsnew/2.3.rst:1940
msgid ""
"Support for a port to IBM's OS/2 using the EMX runtime environment was "
"merged into the main Python source tree.  EMX is a POSIX emulation layer "
"over the OS/2 system APIs.  The Python port for EMX tries to support all the "
"POSIX-like capability exposed by the EMX runtime, and mostly succeeds; :func:"
"`!fork` and :func:`fcntl` are restricted by the limitations of the "
"underlying emulation layer.  The standard OS/2 port, which uses IBM's Visual "
"Age compiler, also gained support for case-sensitive import semantics as "
"part of the integration of the EMX port into CVS.  (Contributed by Andrew "
"MacIntyre.)"
msgstr ""
"Поддержка порта на IBM OS/2 с использованием среды выполнения EMX была "
"объединена с основным деревом исходного кода Python. EMX — это уровень "
"эмуляции POSIX поверх системных API OS/2. Порт Python для EMX пытается "
"поддерживать все POSIX-подобные возможности, предоставляемые средой "
"выполнения EMX, и в основном это удается; :func:`!fork` и :func:`fcntl` "
"ограничены ограничениями базового уровня эмуляции. Стандартный порт OS/2, "
"использующий компилятор IBM Visual Age, также получил поддержку семантики "
"импорта с учетом регистра в рамках интеграции порта EMX в CVS. "
"(Предоставлено Эндрю Макинтайром.)"

#: ../../whatsnew/2.3.rst:1949
msgid ""
"On MacOS, most toolbox modules have been weaklinked to improve backward "
"compatibility.  This means that modules will no longer fail to load if a "
"single routine is missing on the current OS version. Instead calling the "
"missing routine will raise an exception. (Contributed by Jack Jansen.)"
msgstr ""
"В MacOS большинство модулей панели инструментов имеют слабые ссылки для "
"улучшения обратной совместимости. Это означает, что модули больше не будут "
"загружаться, если в текущей версии ОС отсутствует хотя бы одна подпрограмма. "
"Вместо этого вызов отсутствующей процедуры вызовет исключение. "
"(Предоставлено Джеком Янсеном.)"

#: ../../whatsnew/2.3.rst:1954
msgid ""
"The RPM spec files, found in the :file:`Misc/RPM/` directory in the Python "
"source distribution, were updated for 2.3.  (Contributed by Sean "
"Reifschneider.)"
msgstr ""
"Файлы спецификаций RPM, находящиеся в каталоге :file:`Misc/RPM/` в "
"дистрибутиве исходного кода Python, были обновлены для версии 2.3. "
"(Предоставлено Шоном Рейфшнайдером.)"

#: ../../whatsnew/2.3.rst:1957
msgid ""
"Other new platforms now supported by Python include AtheOS (http://www."
"atheos.cx/), GNU/Hurd, and OpenVMS."
msgstr ""
"Другие новые платформы, которые теперь поддерживаются Python, включают "
"AtheOS (http://www.atheos.cx/), GNU/Hurd и OpenVMS."

#: ../../whatsnew/2.3.rst:1966
msgid "Other Changes and Fixes"
msgstr "Другие изменения и исправления"

#: ../../whatsnew/2.3.rst:1968
msgid ""
"As usual, there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 523 patches applied and 514 bugs fixed between Python 2.2 and "
"2.3.  Both figures are likely to be underestimates."
msgstr ""
"Как обычно, по дереву исходного кода было разбросано множество других "
"улучшений и исправлений. Поиск в журналах изменений CVS обнаружил, что между "
"Python 2.2 и 2.3 было применено 523 исправления и исправлено 514 ошибок. Обе "
"цифры, скорее всего, занижены."

#: ../../whatsnew/2.3.rst:1973
msgid "Some of the more notable changes are:"
msgstr "Некоторые из наиболее заметных изменений:"

#: ../../whatsnew/2.3.rst:1975
msgid ""
"If the :envvar:`PYTHONINSPECT` environment variable is set, the Python "
"interpreter will enter the interactive prompt after running a Python "
"program, as if Python had been invoked with the :option:`-i` option. The "
"environment variable can be set before running the Python interpreter, or it "
"can be set by the Python program as part of its execution."
msgstr ""
"Если установлена ​​переменная среды :envvar:`PYTHONINSPECT`, интерпретатор "
"Python введет интерактивную подсказку после запуска программы Python, как "
"если бы Python был вызван с опцией :option:`-i`. Переменная среды может быть "
"установлена ​​перед запуском интерпретатора Python или может быть установлена ​​"
"программой Python в ходе ее выполнения."

#: ../../whatsnew/2.3.rst:1981
msgid ""
"The :file:`regrtest.py` script now provides a way to allow \"all resources "
"except *foo*.\"  A resource name passed to the :option:`!-u` option can now "
"be prefixed with a hyphen (``'-'``) to mean \"remove this resource.\"  For "
"example, the option '``-uall,-bsddb``' could be used to enable the use of "
"all resources except ``bsddb``."
msgstr ""
"Сценарий :file:`regrtest.py` теперь позволяет разрешить «все ресурсы, кроме "
"*foo*». Имя ресурса, переданное в параметр :option:`!-u`, теперь может иметь "
"префикс дефиса (``'-'``), что означает «удалить этот ресурс». Например, "
"опция «-uall,-bsddb» может использоваться для включения использования всех "
"ресурсов, кроме «bsddb»."

#: ../../whatsnew/2.3.rst:1987
msgid ""
"The tools used to build the documentation now work under Cygwin as well as "
"Unix."
msgstr ""
"Инструменты, используемые для создания документации, теперь работают как в "
"Cygwin, так и в Unix."

#: ../../whatsnew/2.3.rst:1990
msgid ""
"The ``SET_LINENO`` opcode has been removed.  Back in the mists of time, this "
"opcode was needed to produce line numbers in tracebacks and support trace "
"functions (for, e.g., :mod:`pdb`). Since Python 1.5, the line numbers in "
"tracebacks have been computed using a different mechanism that works with "
"\"python -O\".  For Python 2.3 Michael Hudson implemented a similar scheme "
"to determine when to call the trace function, removing the need for "
"``SET_LINENO`` entirely."
msgstr ""
"Код операции ``SET_LINENO`` был удален. В далеком прошлом этот код операции "
"был необходим для создания номеров строк в обратных трассировках и поддержки "
"функций трассировки (например, для :mod:`pdb`). Начиная с Python 1.5, номера "
"строк в обратных трассировках вычисляются с использованием другого "
"механизма, который работает с «python -O». В Python 2.3 Майкл Хадсон "
"реализовал аналогичную схему, чтобы определить, когда следует вызывать "
"функцию трассировки, полностью устранив необходимость в SET_LINENO."

#: ../../whatsnew/2.3.rst:1998
msgid ""
"It would be difficult to detect any resulting difference from Python code, "
"apart from a slight speed up when Python is run without :option:`-O`."
msgstr ""
"Было бы трудно обнаружить какие-либо отличия от кода Python, за исключением "
"небольшого ускорения, когда Python запускается без :option:`-O`."

#: ../../whatsnew/2.3.rst:2001
msgid ""
"C extensions that access the :attr:`~frame.f_lineno` field of frame objects "
"should instead call ``PyCode_Addr2Line(f->f_code, f->f_lasti)``. This will "
"have the added effect of making the code work as desired under \"python -O\" "
"in earlier versions of Python."
msgstr ""
"Расширения C, которые обращаются к полю :attr:`~frame.f_lineno` объектов "
"фрейма, должны вместо этого вызывать ``PyCode_Addr2Line(f->f_code, f-"
">f_lasti)``. Это будет иметь дополнительный эффект: код будет работать так, "
"как хотелось бы, при использовании «python -O» в более ранних версиях Python."

#: ../../whatsnew/2.3.rst:2006
msgid ""
"A nifty new feature is that trace functions can now assign to the :attr:"
"`~frame.f_lineno` attribute of frame objects, changing the line that will be "
"executed next.  A ``jump`` command has been added to the :mod:`pdb` debugger "
"taking advantage of this new feature. (Implemented by Richie Hindle.)"
msgstr ""
"Отличная новая функция заключается в том, что функции трассировки теперь "
"могут назначать атрибут :attr:`~frame.f_lineno` объектов фрейма, изменяя "
"строку, которая будет выполняться следующей. В отладчик :mod:`pdb` была "
"добавлена ​​команда jump, использующая эту новую функцию. (Реализовано Ричи "
"Хиндлом.)"

#: ../../whatsnew/2.3.rst:2015
msgid "Porting to Python 2.3"
msgstr "Портирование на Python 2.3"

#: ../../whatsnew/2.3.rst:2017
msgid ""
"This section lists previously described changes that may require changes to "
"your code:"
msgstr ""
"В этом разделе перечислены ранее описанные изменения, которые могут "
"потребовать внесения изменений в ваш код:"

#: ../../whatsnew/2.3.rst:2020
msgid ""
":keyword:`yield` is now always a keyword; if it's used as a variable name in "
"your code, a different name must be chosen."
msgstr ""
":keyword:`yield` теперь всегда является ключевым словом; если оно "
"используется в качестве имени переменной в вашем коде, необходимо выбрать "
"другое имя."

#: ../../whatsnew/2.3.rst:2023
msgid ""
"For strings *X* and *Y*, ``X in Y`` now works if *X* is more than one "
"character long."
msgstr ""
"Для строк *X* и *Y* теперь работает ``X в Y``, если длина *X* превышает один "
"символ."

#: ../../whatsnew/2.3.rst:2026
msgid ""
"The :func:`int` type constructor will now return a long integer instead of "
"raising an :exc:`OverflowError` when a string or floating-point number is "
"too large to fit into an integer."
msgstr ""
"Конструктор типа :func:`int` теперь будет возвращать длинное целое число "
"вместо вызова :exc:`OverflowError`, когда строка или число с плавающей "
"запятой слишком велики, чтобы поместиться в целое число."

#: ../../whatsnew/2.3.rst:2030
msgid ""
"If you have Unicode strings that contain 8-bit characters, you must declare "
"the file's encoding (UTF-8, Latin-1, or whatever) by adding a comment to the "
"top of the file.  See section :ref:`section-encodings` for more information."
msgstr ""
"Если у вас есть строки Юникода, содержащие 8-битные символы, вы должны "
"объявить кодировку файла (UTF-8, Latin-1 или любую другую), добавив "
"комментарий в начало файла. Дополнительную информацию смотрите в разделе :"
"ref:`section-encodings`."

#: ../../whatsnew/2.3.rst:2034
msgid ""
"Calling Tcl methods through :mod:`!_tkinter` no longer  returns only "
"strings. Instead, if Tcl returns other objects those objects are converted "
"to their Python equivalent, if one exists, or wrapped with a :class:`!"
"_tkinter.Tcl_Obj` object if no Python equivalent exists."
msgstr ""
"Вызов методов Tcl через :mod:`!_tkinter` больше не возвращает только строки. "
"Вместо этого, если Tcl возвращает другие объекты, эти объекты преобразуются "
"в их эквивалент Python, если он существует, или обертываются объектом :class:"
"`!_tkinter.Tcl_Obj`, если эквивалента Python не существует."

#: ../../whatsnew/2.3.rst:2039
msgid ""
"Large octal and hex literals such as ``0xffffffff`` now trigger a :exc:"
"`FutureWarning`. Currently they're stored as 32-bit numbers and result in a "
"negative value, but in Python 2.4 they'll become positive long integers."
msgstr ""
"Большие восьмеричные и шестнадцатеричные литералы, такие как ``0xffffffff``, "
"теперь вызывают :exc:`FutureWarning`. В настоящее время они хранятся как 32-"
"битные числа и дают отрицательное значение, но в Python 2.4 они станут "
"положительными длинными целыми числами."

#: ../../whatsnew/2.3.rst:2043
msgid ""
"There are a few ways to fix this warning.  If you really need a positive "
"number, just add an ``L`` to the end of the literal.  If you're trying to "
"get a 32-bit integer with low bits set and have previously used an "
"expression such as ``~(1 << 31)``, it's probably clearest to start with all "
"bits set and clear the desired upper bits. For example, to clear just the "
"top bit (bit 31), you could write ``0xffffffffL &~(1L<<31)``."
msgstr ""
"Есть несколько способов исправить это предупреждение. Если вам действительно "
"нужно положительное число, просто добавьте «L» в конец литерала. Если вы "
"пытаетесь получить 32-битное целое число с установленными младшими битами и "
"ранее использовали такое выражение, как ``~(1 << 31)``, вероятно, проще "
"всего начать с установки всех битов и очистить желаемый верхний бит. биты. "
"Например, чтобы очистить только верхний бит (бит 31), вы можете написать "
"``0xffffffffL &~(1L<<31)``."

#: ../../whatsnew/2.3.rst:2050
msgid "You can no longer disable assertions by assigning to ``__debug__``."
msgstr "Вы больше не можете отключить утверждения, назначив их ``__debug__``."

#: ../../whatsnew/2.3.rst:2052
msgid ""
"The Distutils :func:`!setup` function has gained various new keyword "
"arguments such as *depends*.  Old versions of the Distutils will abort if "
"passed unknown keywords.  A solution is to check for the presence of the "
"new :func:`!get_distutil_options` function in your :file:`setup.py` and only "
"uses the new keywords with a version of the Distutils that supports them::"
msgstr ""
"Функция Distutils :func:`!setup` получила различные новые ключевые "
"аргументы, такие как *dependents*. Старые версии Distutils прервутся, если "
"будут переданы неизвестные ключевые слова. Решение состоит в том, чтобы "
"проверить наличие новой функции :func:`!get_distutil_options` в вашем :file:"
"`setup.py` и использовать новые ключевые слова только с той версией "
"Distutils, которая их поддерживает::"

#: ../../whatsnew/2.3.rst:2058
msgid ""
"from distutils import core\n"
"\n"
"kw = {'sources': 'foo.c', ...}\n"
"if hasattr(core, 'get_distutil_options'):\n"
"    kw['depends'] = ['foo.h']\n"
"ext = Extension(**kw)"
msgstr ""
"from distutils import core\n"
"\n"
"kw = {'sources': 'foo.c', ...}\n"
"if hasattr(core, 'get_distutil_options'):\n"
"    kw['depends'] = ['foo.h']\n"
"ext = Extension(**kw)"

#: ../../whatsnew/2.3.rst:2065
msgid ""
"Using ``None`` as a variable name will now result in a :exc:`SyntaxWarning` "
"warning."
msgstr ""
"Использование None в качестве имени переменной теперь приведет к "
"предупреждению :exc:`SyntaxWarning`."

#: ../../whatsnew/2.3.rst:2068
msgid ""
"Names of extension types defined by the modules included with Python now "
"contain the module and a ``'.'`` in front of the type name."
msgstr ""
"Имена типов расширений, определенные модулями, включенными в Python, теперь "
"содержат модуль и ``'.'`` перед именем типа."

#: ../../whatsnew/2.3.rst:2077
msgid "Acknowledgements"
msgstr "Подтверждение"

#: ../../whatsnew/2.3.rst:2079
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Jeff Bauer, Simon Brunning, Brett Cannon, Michael Chermside, Andrew Dalke, "
"Scott David Daniels, Fred L. Drake, Jr., David Fraser,  Kelly Gerber, "
"Raymond Hettinger, Michael Hudson, Chris Lambert, Detlef Lannert, Martin von "
"Löwis, Andrew MacIntyre, Lalo Martins, Chad Netzer, Gustavo Niemeyer, Neal "
"Norwitz, Hans Nowak, Chris Reedy, Francesco Ricciardi, Vinay Sajip, Neil "
"Schemenauer, Roman Suzi, Jason Tishler, Just van Rossum."
msgstr ""
"Автор хотел бы поблагодарить следующих людей за предложения, исправления и "
"помощь в различных черновиках этой статьи: Джеффа Бауэра, Саймона Браннинга, "
"Бретта Кэннона, Майкла Чермсайда, Эндрю Далка, Скотта Дэвида Дэниэлса, Фреда "
"Л. Дрейка-младшего, Дэвид Фрейзер, Келли Гербер, Рэймонд Хеттингер, Майкл "
"Хадсон, Крис Ламберт, Детлеф Ланнерт, Мартин фон Лёвис, Эндрю Макинтайр, "
"Лало Мартинс, Чад Нетцер, Густаво Нимейер, Нил Норвиц, Ганс Новак, Крис "
"Риди, Франческо Риккарди, Винай Саджип, Нил Шеменауэр, Роман Сьюзи, Джейсон "
"Тишлер, Джаст ван Россум."

#: ../../whatsnew/2.3.rst:371
msgid "universal newlines"
msgstr "универсальные переводы строк"

#: ../../whatsnew/2.3.rst:371
msgid "What's new"
msgstr "Что нового"
