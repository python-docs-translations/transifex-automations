# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Roustam Khamidoulline, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../whatsnew/2.0.rst:3
msgid "What's New in Python 2.0"
msgstr "Что нового в Python 2.0"

#: ../../whatsnew/2.0.rst:0
msgid "Author"
msgstr "Автор"

#: ../../whatsnew/2.0.rst:5
msgid "A.M. Kuchling and Moshe Zadka"
msgstr "А. М. Кучлинг и Моше Цадка"

#: ../../whatsnew/2.0.rst:13
msgid "Introduction"
msgstr "Введение"

#: ../../whatsnew/2.0.rst:15
msgid ""
"A new release of Python, version 2.0, was released on October 16, 2000. This "
"article covers the exciting new features in 2.0, highlights some other "
"useful changes, and points out a few incompatible changes that may require "
"rewriting code."
msgstr ""
"Новый выпуск Python версии 2.0 был выпущен 16 октября 2000 года. В этой "
"статье рассматриваются новые замечательные возможности версии 2.0, "
"освещаются некоторые другие полезные изменения и указывается на несколько "
"несовместимых изменений, которые могут потребовать переписывания кода."

#: ../../whatsnew/2.0.rst:20
msgid ""
"Python's development never completely stops between releases, and a steady "
"flow of bug fixes and improvements are always being submitted. A host of "
"minor fixes, a few optimizations, additional docstrings, and better error "
"messages went into 2.0; to list them all would be impossible, but they're "
"certainly significant. Consult the publicly available CVS logs if you want "
"to see the full list.  This progress is due to the five developers working "
"for  PythonLabs are now getting paid to spend their days fixing bugs, and "
"also due to the improved communication resulting  from moving to SourceForge."
msgstr ""
"Разработка Python никогда полностью не прекращается между выпусками, и "
"всегда поступает постоянный поток исправлений ошибок и улучшений. В версию "
"2.0 вошло множество мелких исправлений, несколько оптимизаций, "
"дополнительные строки документации и улучшенные сообщения об ошибках; "
"перечислить их все было бы невозможно, но они, безусловно, значительны. Если "
"вы хотите увидеть полный список, обратитесь к общедоступным журналам CVS. "
"Этот прогресс обусловлен тем, что пятерым разработчикам, работающим в "
"PythonLabs, теперь платят за то, что они тратят свое время на исправление "
"ошибок, а также благодаря улучшению взаимодействия в результате перехода на "
"SourceForge."

#: ../../whatsnew/2.0.rst:33
msgid "What About Python 1.6?"
msgstr "А как насчет Python 1.6?"

#: ../../whatsnew/2.0.rst:35
msgid ""
"Python 1.6 can be thought of as the Contractual Obligations Python release. "
"After the core development team left CNRI in May 2000, CNRI requested that a "
"1.6 release be created, containing all the work on Python that had been "
"performed at CNRI.  Python 1.6 therefore represents the state of the CVS "
"tree as of May 2000, with the most significant new feature being Unicode "
"support.  Development continued after May, of course, so the 1.6 tree "
"received a few fixes to ensure that it's forward-compatible with Python "
"2.0.  1.6 is therefore part of Python's evolution, and not a side branch."
msgstr ""
"Python 1.6 можно рассматривать как версию Python для договорных "
"обязательств. После того, как основная группа разработчиков покинула CNRI в "
"мае 2000 года, CNRI потребовала создать версию 1.6, содержащую всю работу "
"над Python, выполненную в CNRI. Таким образом, Python 1.6 представляет "
"состояние дерева CVS по состоянию на май 2000 года, причем наиболее важной "
"новой функцией является поддержка Unicode. Разумеется, разработка "
"продолжалась и после мая, поэтому дерево версии 1.6 получило несколько "
"исправлений, обеспечивающих его совместимость с Python 2.0. Таким образом, "
"версия 1.6 является частью эволюции Python, а не побочной ветвью."

#: ../../whatsnew/2.0.rst:44
msgid ""
"So, should you take much interest in Python 1.6?  Probably not.  The "
"1.6final and 2.0beta1 releases were made on the same day (September 5, "
"2000), the plan being to finalize Python 2.0 within a month or so.  If you "
"have applications to maintain, there seems little point in breaking things "
"by moving to 1.6, fixing them, and then having another round of breakage "
"within a month by moving to 2.0; you're better off just going straight to "
"2.0.  Most of the really interesting features described in this document are "
"only in 2.0, because a lot of work was done between May and September."
msgstr ""
"Итак, стоит ли вам проявлять большой интерес к Python 1.6? Вероятно, нет. "
"Релизы 1.6final и 2.0beta1 были выпущены в один и тот же день (5 сентября "
"2000 г.), при этом планировалось завершить работу над Python 2.0 в течение "
"месяца или около того. Если у вас есть приложения, которые нужно "
"поддерживать, кажется, нет особого смысла ломать что-то, переходя на версию "
"1.6, исправляя их, а затем в течение месяца устраивая еще один раунд поломок "
"путем перехода на 2.0; вам лучше сразу перейти к 2.0. Большинство "
"действительно интересных функций, описанных в этом документе, присутствуют "
"только в версии 2.0, поскольку в период с мая по сентябрь была проделана "
"большая работа."

#: ../../whatsnew/2.0.rst:57
msgid "New Development Process"
msgstr "Новый процесс разработки"

#: ../../whatsnew/2.0.rst:59
msgid ""
"The most important change in Python 2.0 may not be to the code at all, but "
"to how Python is developed: in May 2000 the Python developers began using "
"the tools made available by SourceForge for storing  source code, tracking "
"bug reports, and managing the queue of patch submissions.  To report bugs or "
"submit patches for Python 2.0, use the bug tracking and patch manager tools "
"available from Python's project page, located at https://sourceforge.net/"
"projects/python/."
msgstr ""
"Самое важное изменение в Python 2.0, возможно, касается вовсе не кода, а "
"способа разработки Python: в мае 2000 года разработчики Python начали "
"использовать инструменты, предоставленные SourceForge, для хранения "
"исходного кода, отслеживания отчетов об ошибках и управления очередью. "
"отправленных патчей. Чтобы сообщить об ошибках или отправить исправления для "
"Python 2.0, используйте инструменты отслеживания ошибок и диспетчера "
"исправлений, доступные на странице проекта Python, расположенной по адресу "
"https://sourceforge.net/projects/python/."

#: ../../whatsnew/2.0.rst:66
msgid ""
"The most important of the services now hosted at SourceForge is the Python "
"CVS tree, the version-controlled repository containing the source code for "
"Python. Previously, there were roughly 7 or so people who had write access "
"to the CVS tree, and all patches had to be inspected and checked in by one "
"of the people on this short list. Obviously, this wasn't very scalable.  By "
"moving the CVS tree to SourceForge, it became possible to grant write access "
"to more people; as of September 2000 there were 27 people able to check in "
"changes, a fourfold increase.  This makes possible large-scale changes that "
"wouldn't be attempted if they'd have to be filtered through the small group "
"of core developers.  For example, one day Peter Schneider-Kamp took it into "
"his head to drop K&R C compatibility and convert the C source for Python to "
"ANSI C. After getting approval on the python-dev mailing list, he launched "
"into a flurry of checkins that lasted about a week, other developers joined "
"in to help, and the job was done.  If there were only 5 people with write "
"access, probably that task would have been viewed as \"nice, but not worth "
"the time and effort needed\" and it would never have gotten done."
msgstr ""
"Самым важным из сервисов, которые сейчас размещены на SourceForge, является "
"дерево CVS Python, репозиторий с контролем версий, содержащий исходный код "
"Python. Раньше около 7 человек имели доступ для записи в дерево CVS, и все "
"исправления должны были проверяться и проверяться одним из людей из этого "
"короткого списка. Очевидно, это было не очень масштабируемо. Переместив "
"дерево CVS в SourceForge, стало возможным предоставить доступ на запись "
"большему количеству людей; по состоянию на сентябрь 2000 г. 27 человек могли "
"проверить изменения, что означает четырехкратное увеличение. Это делает "
"возможными крупномасштабные изменения, которые не были бы предприняты, если "
"бы их приходилось фильтровать через небольшую группу основных разработчиков. "
"Например, однажды Питеру Шнайдер-Кампу пришло в голову отказаться от "
"совместимости с K&R C и преобразовать исходный код C для Python в ANSI C. "
"Получив одобрение в списке рассылки python-dev, он начал шквал проверок, "
"которые продолжались. Примерно через неделю к помощи присоединились другие "
"разработчики, и работа была сделана. Если бы было только 5 человек с "
"доступом на запись, вероятно, эта задача была бы сочтена «хорошей, но не "
"стоящей затраченных времени и усилий» и никогда бы не была выполнена."

#: ../../whatsnew/2.0.rst:83
msgid ""
"The shift to using SourceForge's services has resulted in a remarkable "
"increase in the speed of development.  Patches now get submitted, commented "
"on, revised by people other than the original submitter, and bounced back "
"and forth between people until the patch is deemed worth checking in.  Bugs "
"are tracked in one central location and can be assigned to a specific person "
"for fixing, and we can count the number of open bugs to measure progress.  "
"This didn't come without a cost: developers now have more e-mail to deal "
"with, more mailing lists to follow, and special tools had to be written for "
"the new environment. For example, SourceForge sends default patch and bug "
"notification e-mail messages that are completely unhelpful, so Ka-Ping Yee "
"wrote an HTML screen-scraper that sends more useful messages."
msgstr ""
"Переход к использованию услуг SourceForge привел к значительному увеличению "
"скорости разработки. Патчи теперь отправляются, комментируются, "
"редактируются людьми, не являющимися первоначальными отправителями, и "
"пересылаются между людьми до тех пор, пока патч не будет сочтен "
"заслуживающим проверки. Ошибки отслеживаются в одном центральном месте и "
"могут быть назначены для исправления конкретному человеку. и мы можем "
"подсчитать количество открытых ошибок для измерения прогресса. Это не "
"обошлось без затрат: теперь разработчикам приходится иметь дело с большим "
"количеством электронной почты, нужно следить за большим количеством списков "
"рассылки, а для новой среды пришлось писать специальные инструменты. "
"Например, SourceForge отправляет по электронной почте сообщения об "
"исправлениях и уведомлениях об ошибках по умолчанию, которые совершенно "
"бесполезны, поэтому Ка-Пинг Йи написал программу очистки экрана в формате "
"HTML, которая отправляет более полезные сообщения."

#: ../../whatsnew/2.0.rst:95
msgid ""
"The ease of adding code caused a few initial growing pains, such as code was "
"checked in before it was ready or without getting clear agreement from the "
"developer group.  The approval process that has emerged is somewhat similar "
"to that used by the Apache group. Developers can vote +1, +0, -0, or -1 on a "
"patch; +1 and -1 denote acceptance or rejection, while +0 and -0 mean the "
"developer is mostly indifferent to the change, though with a slight positive "
"or negative slant.  The most significant change from the Apache model is "
"that the voting is essentially advisory, letting Guido van Rossum, who has "
"Benevolent Dictator For Life status, know what the general opinion is. He "
"can still ignore the result of a vote, and approve or reject a change even "
"if the community disagrees with him."
msgstr ""
"Простота добавления кода вызвала несколько проблем на начальном этапе, "
"например, код был проверен до того, как он был готов, или без четкого "
"согласия группы разработчиков. Возникший процесс утверждения чем-то похож на "
"тот, который используется группой Apache. Разработчики могут проголосовать "
"за патч +1, +0, -0 или -1; +1 и -1 означают принятие или отклонение, а +0 и "
"-0 означают, что разработчик в основном безразличен к изменению, хотя и с "
"небольшим положительным или отрицательным уклоном. Самым значительным "
"отличием от модели Apache является то, что голосование по сути носит "
"консультативный характер, позволяя Гвидо ван Россуму, имеющему статус "
"пожизненного великодушного диктатора, знать, каково общее мнение. Он по-"
"прежнему может игнорировать результат голосования и одобрить или отклонить "
"изменение, даже если сообщество с ним не согласно."

#: ../../whatsnew/2.0.rst:106
msgid ""
"Producing an actual patch is the last step in adding a new feature, and is "
"usually easy compared to the earlier task of coming up with a good design. "
"Discussions of new features can often explode into lengthy mailing list "
"threads, making the discussion hard to follow, and no one can read every "
"posting to python-dev.  Therefore, a relatively formal process has been set "
"up to write Python Enhancement Proposals (PEPs), modelled on the internet "
"RFC process.  PEPs are draft documents that describe a proposed new feature, "
"and are continually revised until the community reaches a consensus, either "
"accepting or rejecting the proposal.  Quoting from the introduction to :pep:"
"`1`, \"PEP Purpose and Guidelines\":"
msgstr ""
"Создание актуального патча — это последний шаг в добавлении новой функции, и "
"его обычно легче выполнить по сравнению с предыдущей задачей по созданию "
"хорошего дизайна. Обсуждения новых функций часто могут превращаться в "
"длинные ветки списков рассылки, что затрудняет отслеживание обсуждения, и "
"никто не может прочитать каждое сообщение на python-dev. Поэтому был "
"установлен относительно формальный процесс написания предложений по "
"улучшению Python (PEP), смоделированный на основе интернет-процесса RFC. PEP "
"— это проекты документов, описывающие предлагаемую новую функцию, которые "
"постоянно пересматриваются до тех пор, пока сообщество не достигнет "
"консенсуса, приняв или отклонив это предложение. Цитата из введения к :pep:"
"`1`, «Цель и рекомендации PEP»:"

#: ../../whatsnew/2.0.rst:120
msgid ""
"PEP stands for Python Enhancement Proposal.  A PEP is a design document "
"providing information to the Python community, or describing a new feature "
"for Python.  The PEP should provide a concise technical specification of the "
"feature and a rationale for the feature."
msgstr ""
"PEP означает «Предложение по улучшению Python». PEP — это проектный "
"документ, предоставляющий информацию сообществу Python или описывающий новую "
"функцию Python. PEP должен предоставить краткую техническую спецификацию "
"функции и ее обоснование."

#: ../../whatsnew/2.0.rst:125
msgid ""
"We intend PEPs to be the primary mechanisms for proposing new features, for "
"collecting community input on an issue, and for documenting the design "
"decisions that have gone into Python.  The PEP author is responsible for "
"building consensus within the community and documenting dissenting opinions."
msgstr ""
"Мы предполагаем, что PEP станут основными механизмами для предложения новых "
"функций, сбора мнений сообщества по проблеме и документирования проектных "
"решений, вошедших в Python. Автор PEP отвечает за достижение консенсуса "
"внутри сообщества и документирование несогласных мнений."

#: ../../whatsnew/2.0.rst:130
msgid ""
"Read the rest of :pep:`1` for the details of the PEP editorial process, "
"style, and format.  PEPs are kept in the Python CVS tree on SourceForge, "
"though they're not part of the Python 2.0 distribution, and are also "
"available in HTML form from https://peps.python.org/.  As of September 2000, "
"there are 25 PEPs, ranging from :pep:`201`, \"Lockstep Iteration\", to PEP "
"225, \"Elementwise/Objectwise Operators\"."
msgstr ""
"Прочтите остальную часть :pep:`1` для получения подробной информации о "
"редакционном процессе, стиле и формате PEP. PEP хранятся в дереве Python CVS "
"на SourceForge, хотя они не являются частью дистрибутива Python 2.0, а также "
"доступны в форме HTML на https://peps.python.org/. По состоянию на сентябрь "
"2000 года существует 25 PEP, от :pep:`201`, «Локпоинтовая итерация», до PEP "
"225, «Элементные/объектные операторы»."

#: ../../whatsnew/2.0.rst:141
msgid "Unicode"
msgstr "Юникод"

#: ../../whatsnew/2.0.rst:143
msgid ""
"The largest new feature in Python 2.0 is a new fundamental data type: "
"Unicode strings.  Unicode uses 16-bit numbers to represent characters "
"instead of the 8-bit number used by ASCII, meaning that 65,536 distinct "
"characters can be supported."
msgstr ""
"Самая большая новая функция Python 2.0 — это новый фундаментальный тип "
"данных: строки Unicode. Unicode использует 16-битные числа для представления "
"символов вместо 8-битных чисел, используемых в ASCII, что означает, что "
"может поддерживаться 65 536 различных символов."

#: ../../whatsnew/2.0.rst:148
msgid ""
"The final interface for Unicode support was arrived at through countless "
"often-stormy discussions on the python-dev mailing list, and mostly "
"implemented by Marc-André Lemburg, based on a Unicode string type "
"implementation by Fredrik Lundh.  A detailed explanation of the interface "
"was written up as :pep:`100`, \"Python Unicode Integration\". This article "
"will simply cover the most significant points about the Unicode interfaces."
msgstr ""
"Окончательный интерфейс для поддержки Unicode был создан в результате "
"бесчисленных, часто бурных дискуссий в списке рассылки python-dev и в "
"основном реализован Марком-Андре Лембургом на основе реализации строкового "
"типа Unicode Фредрика Лунда. Подробное объяснение интерфейса было записано "
"как :pep:`100`, «Интеграция Python с Unicode». В этой статье будут "
"рассмотрены наиболее важные моменты, касающиеся интерфейсов Unicode."

#: ../../whatsnew/2.0.rst:155
msgid ""
"In Python source code, Unicode strings are written as ``u\"string\"``.  "
"Arbitrary Unicode characters can be written using a new escape sequence, :"
"samp:`\\\\u{HHHH}`, where *HHHH* is a 4-digit hexadecimal number from 0000 "
"to FFFF.  The existing :samp:`\\\\x{HH}` escape sequence can also be used, "
"and octal escapes can be used for characters up to U+01FF, which is "
"represented by ``\\777``."
msgstr ""
"В исходном коде Python строки Unicode записываются как ``u\"string\"``. "
"Произвольные символы Юникода можно записывать с использованием новой escape-"
"последовательности: :samp:`\\\\u{HHHH}`, где *HHHH* — 4-значное "
"шестнадцатеричное число от 0000 до FFFF. Также можно использовать "
"существующую escape-последовательность :samp:`\\\\x{HH}`, а восьмеричные "
"escape-последовательности можно использовать для символов до U+01FF, что "
"представлено ``\\777``."

#: ../../whatsnew/2.0.rst:161
msgid ""
"Unicode strings, just like regular strings, are an immutable sequence type. "
"They can be indexed and sliced, but not modified in place. Unicode strings "
"have an ``encode( [encoding] )`` method that returns an 8-bit string in the "
"desired encoding.  Encodings are named by strings, such as ``'ascii'``, "
"``'utf-8'``, ``'iso-8859-1'``, or whatever.  A codec API is defined for "
"implementing and registering new encodings that are then available "
"throughout a Python program. If an encoding isn't specified, the default "
"encoding is usually 7-bit ASCII, though it can be changed for your Python "
"installation by calling the ``sys.setdefaultencoding(encoding)`` function in "
"a customized version of :file:`site.py`."
msgstr ""
"Выводит символическую дизассемблирование рассола в файлоподобный объект "
"*out*, по умолчанию используется ``sys.stdout``. *pickle* может быть строкой "
"или файловым объектом. *memo* может быть словарем Python, который будет "
"использоваться в качестве заметки рассола; его можно использовать для "
"выполнения дизассемблирования нескольких пиклов, созданных одним и тем же "
"пиклером. Последовательные уровни, обозначаемые в потоке кодами операций "
"MARK, имеют отступы *indentlevel*. Если для *annotate* задано ненулевое "
"значение, каждый код операции в выходных данных сопровождается кратким "
"описанием. Значение *annotate* используется как подсказка для столбца, с "
"которого должна начинаться аннотация."

#: ../../whatsnew/2.0.rst:172
msgid ""
"Combining 8-bit and Unicode strings always coerces to Unicode, using the "
"default ASCII encoding; the result of ``'a' + u'bc'`` is ``u'abc'``."
msgstr ""
"Объединение 8-битных строк и строк Юникода всегда приводит к Юникоду с "
"использованием кодировки ASCII по умолчанию; результатом ``'a' + u'bc'`` "
"будет ``u'abc'``."

#: ../../whatsnew/2.0.rst:175
msgid ""
"New built-in functions have been added, and existing built-ins modified to "
"support Unicode:"
msgstr ""
"Были добавлены новые встроенные функции, а существующие встроенные изменены "
"для поддержки Unicode:"

#: ../../whatsnew/2.0.rst:178
msgid ""
"``unichr(ch)`` returns a Unicode string 1 character long, containing the "
"character *ch*."
msgstr ""
"``unichr(ch)`` возвращает строку Unicode длиной 1 символ, содержащую символ "
"*ch*."

#: ../../whatsnew/2.0.rst:181
msgid ""
"``ord(u)``, where *u* is a 1-character regular or Unicode string, returns "
"the number of the character as an integer."
msgstr ""
"``ord(u)``, где *u* — 1-символьная обычная строка или строка Юникода, "
"возвращает номер символа в виде целого числа."

#: ../../whatsnew/2.0.rst:184
msgid ""
"``unicode(string [, encoding]  [, errors] )`` creates a Unicode string from "
"an 8-bit string.  ``encoding`` is a string naming the encoding to use. The "
"``errors`` parameter specifies the treatment of characters that are invalid "
"for the current encoding; passing ``'strict'`` as the value causes an "
"exception to be raised on any encoding error, while ``'ignore'`` causes "
"errors to be silently ignored and ``'replace'`` uses U+FFFD, the official "
"replacement character, in case of any problems."
msgstr ""
"``unicode(string [,coding] [, error] )`` создает строку Unicode из 8-битной "
"строки. ``encoding`` — это строка, определяющая используемую кодировку. "
"Параметр ``errors`` определяет обработку символов, недопустимых для текущей "
"кодировки; передача ``'strict'`` в качестве значения приводит к "
"возникновению исключения при любой ошибке кодирования, в то время как "
"``'ignore'`` заставляет ошибки молча игнорироваться, а ``'replace'`` "
"использует U+FFFD, официальная замена персонажа, в случае каких-либо проблем."

#: ../../whatsnew/2.0.rst:192
msgid ""
"The ``exec`` statement, and various built-ins such as ``eval()``, "
"``getattr()``, and ``setattr()`` will also accept Unicode strings as well as "
"regular strings.  (It's possible that the process of fixing this missed some "
"built-ins; if you find a built-in function that accepts strings but doesn't "
"accept Unicode strings at all, please report it as a bug.)"
msgstr ""
"Оператор exec и различные встроенные функции, такие как eval(), getattr() и "
"setattr(), также принимают строки Unicode, а также обычные строки. "
"(Возможно, в процессе исправления этой проблемы были пропущены некоторые "
"встроенные функции; если вы обнаружите встроенную функцию, которая принимает "
"строки, но вообще не принимает строки Unicode, сообщите об этом как об "
"ошибке.)"

#: ../../whatsnew/2.0.rst:198
msgid ""
"A new module, :mod:`unicodedata`, provides an interface to Unicode character "
"properties.  For example, ``unicodedata.category(u'A')`` returns the 2-"
"character string 'Lu', the 'L' denoting it's a letter, and 'u' meaning that "
"it's uppercase. ``unicodedata.bidirectional(u'\\u0660')`` returns 'AN', "
"meaning that U+0660 is an Arabic number."
msgstr ""
"Новый модуль :mod:`unicodedata` предоставляет интерфейс для свойств символов "
"Юникода. Например, ``unicodedata.category(u'A')`` возвращает двухсимвольную "
"строку \"Lu\", где \"L\" обозначает букву, а \"u\" означает, что она "
"заглавная. ``unicodedata.bidirection(u'\\u0660')`` возвращает 'AN', что "
"означает, что U+0660 — арабское число."

#: ../../whatsnew/2.0.rst:204
msgid ""
"The :mod:`codecs` module contains functions to look up existing encodings "
"and register new ones.  Unless you want to implement a new encoding, you'll "
"most often use the ``codecs.lookup(encoding)`` function, which returns a 4-"
"element tuple: ``(encode_func, decode_func, stream_reader, stream_writer)``."
msgstr ""
"Модуль :mod:`codecs` содержит функции для поиска существующих кодировок и "
"регистрации новых. Если вы не хотите реализовать новую кодировку, вы чаще "
"всего будете использовать функцию codecs.lookup(encoding)``, которая "
"возвращает кортеж из 4 элементов: ``(encode_func, decode_func,stream_reader,"
"stream_writer)``."

#: ../../whatsnew/2.0.rst:209
msgid ""
"*encode_func* is a function that takes a Unicode string, and returns a 2-"
"tuple ``(string, length)``.  *string* is an 8-bit string containing a "
"portion (perhaps all) of the Unicode string converted into the given "
"encoding, and *length* tells you how much of the Unicode string was "
"converted."
msgstr ""
"*encode_func* — это функция, которая принимает строку в Юникоде и возвращает "
"кортеж из двух строк ``(строка, длина)``. *строка* — это 8-битная строка, "
"содержащая часть (возможно, всю) строки Юникода, преобразованную в заданную "
"кодировку, а *длина* сообщает вам, какая часть строки Юникода была "
"преобразована."

#: ../../whatsnew/2.0.rst:214
msgid ""
"*decode_func* is the opposite of *encode_func*, taking an 8-bit string and "
"returning a 2-tuple ``(ustring, length)``, consisting of the resulting "
"Unicode string *ustring* and the integer *length* telling how much of the 8-"
"bit string was consumed."
msgstr ""
"*decode_func* является противоположностью *encode_func*, принимает 8-битную "
"строку и возвращает двухкортеж ``(ustring, length)``, состоящий из "
"результирующей строки Unicode *ustring* и целого числа *length*, "
"указывающего, как большая часть 8-битной строки была использована."

#: ../../whatsnew/2.0.rst:219
msgid ""
"*stream_reader* is a class that supports decoding input from a stream. "
"*stream_reader(file_obj)* returns an object that supports the :meth:`!"
"read`, :meth:`!readline`, and :meth:`!readlines` methods.  These methods "
"will all translate from the given encoding and return Unicode strings."
msgstr ""
"*stream_reader* — это класс, который поддерживает декодирование входных "
"данных из потока. *stream_reader(file_obj)* возвращает объект, который "
"поддерживает методы :meth:`!read`, :meth:`!readline` и :meth:`!readlines`. "
"Все эти методы будут переводить данные из заданной кодировки и возвращать "
"строки Юникода."

#: ../../whatsnew/2.0.rst:224
msgid ""
"*stream_writer*, similarly, is a class that supports encoding output to a "
"stream.  *stream_writer(file_obj)* returns an object that supports the :meth:"
"`!write` and :meth:`!writelines` methods.  These methods expect Unicode "
"strings, translating them to the given encoding on output."
msgstr ""
"*stream_writer* аналогично является классом, который поддерживает "
"кодирование вывода в поток. *stream_writer(file_obj)* возвращает объект, "
"который поддерживает методы :meth:`!write` и :meth:`!writelines`. Эти методы "
"ожидают строки Unicode, переводя их в заданную кодировку на выходе."

#: ../../whatsnew/2.0.rst:229
msgid ""
"For example, the following code writes a Unicode string into a file,  "
"encoding it as UTF-8::"
msgstr ""
"Например, следующий код записывает строку Unicode в файл, кодируя ее как "
"UTF-8:"

#: ../../whatsnew/2.0.rst:232
msgid ""
"import codecs\n"
"\n"
"unistr = u'\\u0660\\u2000ab ...'\n"
"\n"
"(UTF8_encode, UTF8_decode,\n"
" UTF8_streamreader, UTF8_streamwriter) = codecs.lookup('UTF-8')\n"
"\n"
"output = UTF8_streamwriter( open( '/tmp/output', 'wb') )\n"
"output.write( unistr )\n"
"output.close()"
msgstr ""
"import codecs\n"
"\n"
"unistr = u'\\u0660\\u2000ab ...'\n"
"\n"
"(UTF8_encode, UTF8_decode,\n"
" UTF8_streamreader, UTF8_streamwriter) = codecs.lookup('UTF-8')\n"
"\n"
"output = UTF8_streamwriter( open( '/tmp/output', 'wb') )\n"
"output.write( unistr )\n"
"output.close()"

#: ../../whatsnew/2.0.rst:243
msgid "The following code would then read UTF-8 input from the file::"
msgstr "Следующий код затем прочитает ввод UTF-8 из файла:"

#: ../../whatsnew/2.0.rst:245
msgid ""
"input = UTF8_streamreader( open( '/tmp/output', 'rb') )\n"
"print repr(input.read())\n"
"input.close()"
msgstr ""
"input = UTF8_streamreader( open( '/tmp/output', 'rb') )\n"
"print repr(input.read())\n"
"input.close()"

#: ../../whatsnew/2.0.rst:249
msgid ""
"Unicode-aware regular expressions are available through the :mod:`re` "
"module, which has a new underlying implementation called SRE written by "
"Fredrik Lundh of Secret Labs AB."
msgstr ""
"Регулярные выражения с поддержкой Unicode доступны через модуль :mod:`re`, "
"который имеет новую базовую реализацию под названием SRE, написанную "
"Фредриком Лундом из Secret Labs AB."

#: ../../whatsnew/2.0.rst:253
msgid ""
"A ``-U`` command line option was added which causes the Python compiler to "
"interpret all string literals as Unicode string literals. This is intended "
"to be used in testing and future-proofing your Python code, since some "
"future version of Python may drop support for 8-bit strings and provide only "
"Unicode strings."
msgstr ""
"Был добавлен параметр командной строки ``-U``, который заставляет компилятор "
"Python интерпретировать все строковые литералы как строковые литералы "
"Unicode. Это предназначено для использования при тестировании и подготовке "
"вашего кода Python к будущему, поскольку некоторые будущие версии Python "
"могут отказаться от поддержки 8-битных строк и предоставлять только строки "
"Unicode."

#: ../../whatsnew/2.0.rst:262
msgid "List Comprehensions"
msgstr "Компоновка списка"

#: ../../whatsnew/2.0.rst:264
msgid ""
"Lists are a workhorse data type in Python, and many programs manipulate a "
"list at some point.  Two common operations on lists are to loop over them, "
"and either pick out the elements that meet a certain criterion, or apply "
"some function to each element.  For example, given a list of strings, you "
"might want to pull out all the strings containing a given substring, or "
"strip off trailing whitespace from each line."
msgstr ""
"Списки — это рабочий тип данных в Python, и многие программы в какой-то "
"момент манипулируют списками. Двумя распространенными операциями со списками "
"являются циклический просмотр их и выбор элементов, соответствующих "
"определенному критерию, или применение некоторой функции к каждому элементу. "
"Например, имея список строк, вы можете захотеть извлечь все строки, "
"содержащие данную подстроку, или удалить конечные пробелы из каждой строки."

#: ../../whatsnew/2.0.rst:271
msgid ""
"The existing :func:`map` and :func:`filter` functions can be used for this "
"purpose, but they require a function as one of their arguments.  This is "
"fine if there's an existing built-in function that can be passed directly, "
"but if there isn't, you have to create a little function to do the required "
"work, and Python's scoping rules make the result ugly if the little function "
"needs additional information.  Take the first example in the previous "
"paragraph, finding all the strings in the list containing a given "
"substring.  You could write the following to do it::"
msgstr ""
"Для этой цели можно использовать существующие функции :func:`map` и :func:"
"`filter`, но они требуют функцию в качестве одного из аргументов. Это "
"нормально, если есть встроенная функция, которую можно передать напрямую, но "
"если ее нет, вам придется создать небольшую функцию для выполнения "
"необходимой работы, а правила области видимости Python делают результат "
"уродливым, если маленькая функция нуждается в Дополнительная информация. "
"Возьмем первый пример из предыдущего абзаца: поиск всех строк в списке, "
"содержащих заданную подстроку. Для этого вы можете написать следующее:"

#: ../../whatsnew/2.0.rst:280
msgid ""
"# Given the list L, make a list of all strings\n"
"# containing the substring S.\n"
"sublist = filter( lambda s, substring=S:\n"
"                     string.find(s, substring) != -1,\n"
"                  L)"
msgstr ""
"# Given the list L, make a list of all strings\n"
"# containing the substring S.\n"
"sublist = filter( lambda s, substring=S:\n"
"                     string.find(s, substring) != -1,\n"
"                  L)"

#: ../../whatsnew/2.0.rst:286
msgid ""
"Because of Python's scoping rules, a default argument is used so that the "
"anonymous function created by the :keyword:`lambda` expression knows what "
"substring is being searched for.  List comprehensions make this cleaner::"
msgstr ""
"Из-за правил области видимости Python используется аргумент по умолчанию, "
"чтобы анонимная функция, созданная выражением :keyword:`lambda`, знала, "
"какая подстрока ищется. Понимание списков делает это чище::"

#: ../../whatsnew/2.0.rst:290
msgid "sublist = [ s for s in L if string.find(s, S) != -1 ]"
msgstr "sublist = [ s for s in L if string.find(s, S) != -1 ]"

#: ../../whatsnew/2.0.rst:292
msgid "List comprehensions have the form::"
msgstr "Понимания списков имеют форму::"

#: ../../whatsnew/2.0.rst:294
msgid ""
"[ expression for expr in sequence1\n"
"             for expr2 in sequence2 ...\n"
"             for exprN in sequenceN\n"
"             if condition ]"
msgstr ""
"[ expression for expr in sequence1\n"
"             for expr2 in sequence2 ...\n"
"             for exprN in sequenceN\n"
"             if condition ]"

#: ../../whatsnew/2.0.rst:299
msgid ""
"The :keyword:`!for`...\\ :keyword:`!in` clauses contain the sequences to be "
"iterated over.  The sequences do not have to be the same length, because "
"they are *not* iterated over in parallel, but from left to right; this is "
"explained more clearly in the following paragraphs.  The elements of the "
"generated list will be the successive values of *expression*.  The final :"
"keyword:`!if` clause is optional; if present, *expression* is only evaluated "
"and added to the result if *condition* is true."
msgstr ""
"Предложения :keyword:`!for`...\\ :keyword:`!in` содержат последовательности, "
"которые необходимо перебрать. Последовательности не обязательно должны быть "
"одинаковой длины, поскольку они *не* повторяются параллельно, а слева "
"направо; более подробно это объясняется в следующих параграфах. Элементами "
"сгенерированного списка будут последовательные значения *выражения*. "
"Последнее предложение :keyword:`!if` не является обязательным; если оно "
"присутствует, *выражение* оценивается и добавляется к результату только в "
"том случае, если *условие* истинно."

#: ../../whatsnew/2.0.rst:307
msgid ""
"To make the semantics very clear, a list comprehension is equivalent to the "
"following Python code::"
msgstr ""
"Чтобы сделать семантику более понятной, понимание списка эквивалентно "
"следующему коду Python:"

#: ../../whatsnew/2.0.rst:310
msgid ""
"for expr1 in sequence1:\n"
"    for expr2 in sequence2:\n"
"    ...\n"
"        for exprN in sequenceN:\n"
"             if (condition):\n"
"                  # Append the value of\n"
"                  # the expression to the\n"
"                  # resulting list."
msgstr ""
"for expr1 in sequence1:\n"
"    for expr2 in sequence2:\n"
"    ...\n"
"        for exprN in sequenceN:\n"
"             if (condition):\n"
"                  # Append the value of\n"
"                  # the expression to the\n"
"                  # resulting list."

#: ../../whatsnew/2.0.rst:319
msgid ""
"This means that when there are multiple :keyword:`!for`...\\ :keyword:`!in` "
"clauses, the resulting list will be equal to the product of the lengths of "
"all the sequences.  If you have two lists of length 3, the output list is 9 "
"elements long::"
msgstr ""
"Это означает, что при наличии нескольких предложений :keyword:`!for`...\\ :"
"keyword:`!in` результирующий список будет равен произведению длин всех "
"последовательностей. Если у вас есть два списка длиной 3, выходной список "
"будет состоять из 9 элементов::"

#: ../../whatsnew/2.0.rst:324
msgid ""
"seq1 = 'abc'\n"
"seq2 = (1,2,3)\n"
">>> [ (x,y) for x in seq1 for y in seq2]\n"
"[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1),\n"
"('c', 2), ('c', 3)]"
msgstr ""
"seq1 = 'abc'\n"
"seq2 = (1,2,3)\n"
">>> [ (x,y) for x in seq1 for y in seq2]\n"
"[('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2), ('b', 3), ('c', 1),\n"
"('c', 2), ('c', 3)]"

#: ../../whatsnew/2.0.rst:330
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if *expression* is "
"creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Чтобы избежать двусмысленности в грамматике Python, если *выражение* создает "
"кортеж, оно должно быть заключено в круглые скобки. Первое понимание списка "
"ниже является синтаксической ошибкой, а второе правильно::"

#: ../../whatsnew/2.0.rst:334
msgid ""
"# Syntax error\n"
"[ x,y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[ (x,y) for x in seq1 for y in seq2]"
msgstr ""
"# Syntax error\n"
"[ x,y for x in seq1 for y in seq2]\n"
"# Correct\n"
"[ (x,y) for x in seq1 for y in seq2]"

#: ../../whatsnew/2.0.rst:339
msgid ""
"The idea of list comprehensions originally comes from the functional "
"programming language Haskell (https://www.haskell.org).  Greg Ewing argued "
"most effectively for adding them to Python and wrote the initial list "
"comprehension patch, which was then discussed for a seemingly endless time "
"on the python-dev mailing list and kept up-to-date by Skip Montanaro."
msgstr ""
"Идея создания списков изначально пришла из функционального языка "
"программирования Haskell (https://www.haskell.org). Грег Юинг наиболее "
"эффективно выступал за добавление их в Python и написал первоначальный патч "
"для понимания списков, который затем обсуждался, казалось бы, бесконечное "
"время в списке рассылки python-dev и обновлялся Скипом Монтанаро."

#: ../../whatsnew/2.0.rst:349
msgid "Augmented Assignment"
msgstr "Дополненное присваивание"

#: ../../whatsnew/2.0.rst:351
msgid ""
"Augmented assignment operators, another long-requested feature, have been "
"added to Python 2.0.  Augmented assignment operators include ``+=``, ``-=``, "
"``*=``, and so forth.  For example, the statement ``a += 2`` increments the "
"value of the variable  ``a`` by 2, equivalent to the slightly lengthier ``a "
"= a + 2``."
msgstr ""
"В Python 2.0 были добавлены расширенные операторы присваивания — еще одна "
"давно запрошенная функция. К расширенным операторам присваивания относятся "
"``+=``, ``-=``, ``*=`` и т. д. Например, оператор ``a += 2`` увеличивает "
"значение переменной ``a`` на 2, что эквивалентно немного более длинному "
"оператору ``a = a + 2``."

#: ../../whatsnew/2.0.rst:356
msgid ""
"The full list of supported assignment operators is ``+=``, ``-=``, ``*=``, "
"``/=``, ``%=``, ``**=``, ``&=``, ``|=``, ``^=``, ``>>=``, and ``<<=``.  "
"Python classes can override the augmented assignment operators by defining "
"methods named :meth:`!__iadd__`, :meth:`!__isub__`, etc.  For example, the "
"following :class:`!Number` class stores a number and supports using += to "
"create a new instance with an incremented value."
msgstr ""
"Полный список поддерживаемых операторов присваивания: ``+=``, ``-=``, "
"``*=``, ``/=``, ``%=``, ``**=`` , ``&=``, ``|=``, ``^=``, ``>>=`` и ``<<=``. "
"Классы Python могут переопределять расширенные операторы присваивания, "
"определяя методы с именами :meth:`!__iadd__`, :meth:`!__isub__` и т. д. "
"Например, следующий класс :class:`!Number` хранит число и поддерживает "
"использование + = для создания нового экземпляра с увеличенным значением."

#: ../../whatsnew/2.0.rst:367
msgid ""
"class Number:\n"
"    def __init__(self, value):\n"
"        self.value = value\n"
"    def __iadd__(self, increment):\n"
"        return Number( self.value + increment)\n"
"\n"
"n = Number(5)\n"
"n += 3\n"
"print n.value"
msgstr ""
"class Number:\n"
"    def __init__(self, value):\n"
"        self.value = value\n"
"    def __iadd__(self, increment):\n"
"        return Number( self.value + increment)\n"
"\n"
"n = Number(5)\n"
"n += 3\n"
"print n.value"

#: ../../whatsnew/2.0.rst:377
msgid ""
"The :meth:`!__iadd__` special method is called with the value of the "
"increment, and should return a new instance with an appropriately modified "
"value; this return value is bound as the new value of the variable on the "
"left-hand side."
msgstr ""
"Специальный метод :meth:`!__iadd__` вызывается со значением приращения и "
"должен возвращать новый экземпляр с соответствующим образом измененным "
"значением; это возвращаемое значение привязано как новое значение переменной "
"в левой части."

#: ../../whatsnew/2.0.rst:381
msgid ""
"Augmented assignment operators were first introduced in the C programming "
"language, and most C-derived languages, such as :program:`awk`, C++, Java, "
"Perl, and PHP also support them.  The augmented assignment patch was "
"implemented by Thomas Wouters."
msgstr ""
"Расширенные операторы присваивания впервые были представлены в языке "
"программирования C, и большинство языков, производных от C, таких как :"
"program:`awk`, C++, Java, Perl и PHP, также поддерживают их. Патч "
"расширенного назначения был реализован Томасом Воутерсом."

#: ../../whatsnew/2.0.rst:390
msgid "String Methods"
msgstr "Методы строк"

#: ../../whatsnew/2.0.rst:392
msgid ""
"Until now string-manipulation functionality was in the :mod:`string` module, "
"which was usually a front-end for the :mod:`!strop` module written in C.  "
"The addition of Unicode posed a difficulty for the :mod:`!strop` module, "
"because the functions would all need to be rewritten in order to accept "
"either 8-bit or Unicode strings.  For functions such as :func:`!string."
"replace`, which takes 3 string arguments, that means eight possible "
"permutations, and correspondingly complicated code."
msgstr ""
"До сих пор функциональность манипуляций со строками находилась в модуле :mod:"
"`string`, который обычно был интерфейсом для модуля :mod:`!strop`, "
"написанного на C. Добавление Unicode создавало трудности для :mod: `!strop`, "
"потому что все функции придется переписать, чтобы они могли принимать 8-"
"битные строки или строки в Юникоде. Для таких функций, как :func:`!string."
"replace`, которые принимают 3 строковых аргумента, это означает восемь "
"возможных перестановок и, соответственно, сложный код."

#: ../../whatsnew/2.0.rst:400
msgid ""
"Instead, Python 2.0 pushes the problem onto the string type, making string "
"manipulation functionality available through methods on both 8-bit strings "
"and Unicode strings.   ::"
msgstr ""
"Вместо этого Python 2.0 переносит проблему на строковый тип, делая функции "
"манипулирования строками доступными через методы как для 8-битных строк, так "
"и для строк Unicode. ::"

#: ../../whatsnew/2.0.rst:404
msgid ""
">>> 'andrew'.capitalize()\n"
"'Andrew'\n"
">>> 'hostname'.replace('os', 'linux')\n"
"'hlinuxtname'\n"
">>> 'moshe'.find('sh')\n"
"2"
msgstr ""
">>> 'andrew'.capitalize()\n"
"'Andrew'\n"
">>> 'hostname'.replace('os', 'linux')\n"
"'hlinuxtname'\n"
">>> 'moshe'.find('sh')\n"
"2"

#: ../../whatsnew/2.0.rst:411
msgid ""
"One thing that hasn't changed, a noteworthy April Fools' joke "
"notwithstanding, is that Python strings are immutable. Thus, the string "
"methods return new strings, and do not modify the string on which they "
"operate."
msgstr ""
"Одна вещь, которая не изменилась, несмотря на примечательную первоапрельскую "
"шутку, заключается в том, что строки Python неизменяемы. Таким образом, "
"строковые методы возвращают новые строки и не изменяют строку, с которой они "
"работают."

#: ../../whatsnew/2.0.rst:415
msgid ""
"The old :mod:`string` module is still around for backwards compatibility, "
"but it mostly acts as a front-end to the new string methods."
msgstr ""
"Старый модуль :mod:`string` все еще существует для обеспечения обратной "
"совместимости, но в основном он действует как интерфейс для новых строковых "
"методов."

#: ../../whatsnew/2.0.rst:418
msgid ""
"Two methods which have no parallel in pre-2.0 versions, although they did "
"exist in JPython for quite some time, are :meth:`!startswith` and :meth:`!"
"endswith`. ``s.startswith(t)`` is equivalent to ``s[:len(t)] == t``, while "
"``s.endswith(t)`` is equivalent to ``s[-len(t):] == t``."
msgstr ""
"Два метода, которые не имеют аналогов в версиях до 2.0, хотя они "
"существовали в JPython довольно долгое время, это :meth:`!startswith` и :"
"meth:`!endswith`. ``s.startswith(t)`` эквивалентен ``s[:len(t)] == t``, а "
"``s.endswith(t)`` эквивалентен ``s[-len( т):] == т``."

#: ../../whatsnew/2.0.rst:423
msgid ""
"One other method which deserves special mention is :meth:`!join`.  The :meth:"
"`!join` method of a string receives one parameter, a sequence of strings, "
"and is equivalent to the :func:`!string.join` function from the old :mod:"
"`string` module, with the arguments reversed. In other words, ``s."
"join(seq)`` is equivalent to the old ``string.join(seq, s)``."
msgstr ""
"Еще один метод, заслуживающий особого упоминания, — это :meth:`!join`. Метод "
"строки :meth:`!join` получает один параметр, последовательность строк, и "
"эквивалентен функции :func:`!string.join` из старого модуля :mod:`string` с "
"аргументами перевернутый. Другими словами, s.join(seq) эквивалентен старому "
"string.join(seq, s)."

#: ../../whatsnew/2.0.rst:433
msgid "Garbage Collection of Cycles"
msgstr "Сбор мусора циклов"

#: ../../whatsnew/2.0.rst:435
msgid ""
"The C implementation of Python uses reference counting to implement garbage "
"collection.  Every Python object maintains a count of the number of "
"references pointing to itself, and adjusts the count as references are "
"created or destroyed.  Once the reference count reaches zero, the object is "
"no longer accessible, since you need to have a reference to an object to "
"access it, and if the count is zero, no references exist any longer."
msgstr ""
"Реализация Python на языке C использует подсчет ссылок для реализации сборки "
"мусора. Каждый объект Python поддерживает подсчет количества ссылок, "
"указывающих на него самого, и корректирует это количество по мере создания "
"или уничтожения ссылок. Как только счетчик ссылок достигает нуля, объект "
"больше не доступен, поскольку для доступа к нему необходима ссылка на "
"объект, а если счетчик равен нулю, ссылки больше не существуют."

#: ../../whatsnew/2.0.rst:442
msgid ""
"Reference counting has some pleasant properties: it's easy to understand and "
"implement, and the resulting implementation is portable, fairly fast, and "
"reacts well with other libraries that implement their own memory handling "
"schemes.  The major problem with reference counting is that it sometimes "
"doesn't realise that objects are no longer accessible, resulting in a memory "
"leak.  This happens when there are cycles of references."
msgstr ""
"Подсчет ссылок имеет несколько приятных свойств: его легко понять и "
"реализовать, а полученная реализация является переносимой, довольно быстрой "
"и хорошо взаимодействует с другими библиотеками, реализующими свои "
"собственные схемы обработки памяти. Основная проблема подсчета ссылок "
"заключается в том, что иногда не осознается, что объекты больше не доступны, "
"что приводит к утечке памяти. Это происходит при наличии циклов ссылок."

#: ../../whatsnew/2.0.rst:449
msgid ""
"Consider the simplest possible cycle,  a class instance which has a "
"reference to itself::"
msgstr ""
"Рассмотрим простейший возможный цикл — экземпляр класса, который имеет "
"ссылку на самого себя:"

#: ../../whatsnew/2.0.rst:452
msgid ""
"instance = SomeClass()\n"
"instance.myself = instance"
msgstr ""
"instance = SomeClass()\n"
"instance.myself = instance"

#: ../../whatsnew/2.0.rst:455
msgid ""
"After the above two lines of code have been executed, the reference count of "
"``instance`` is 2; one reference is from the variable named ``'instance'``, "
"and the other is from the ``myself`` attribute of the instance."
msgstr ""
"После выполнения двух вышеуказанных строк кода счетчик ссылок экземпляра "
"равен 2; одна ссылка взята из переменной с именем ``'instance'``, а другая — "
"из атрибута ``myself`` экземпляра."

#: ../../whatsnew/2.0.rst:459
msgid ""
"If the next line of code is ``del instance``, what happens?  The reference "
"count of ``instance`` is decreased by 1, so it has a reference count of 1; "
"the reference in the ``myself`` attribute still exists.  Yet the instance is "
"no longer accessible through Python code, and it could be deleted.  Several "
"objects can participate in a cycle if they have references to each other, "
"causing all of the objects to be leaked."
msgstr ""
"Если следующей строкой кода будет ``del экземпляр``, что произойдет? Счетчик "
"ссылок экземпляра уменьшается на 1, поэтому его счетчик ссылок равен 1; "
"ссылка в атрибуте ``myself`` все еще существует. Однако экземпляр больше не "
"доступен через код Python, и его можно удалить. В цикле могут участвовать "
"несколько объектов, если они имеют ссылки друг на друга, что приводит к "
"утечке данных обо всех объектах."

#: ../../whatsnew/2.0.rst:466
msgid ""
"Python 2.0 fixes this problem by periodically executing a cycle detection "
"algorithm which looks for inaccessible cycles and deletes the objects "
"involved. A new :mod:`gc` module provides functions to perform a garbage "
"collection, obtain debugging statistics, and tuning the collector's "
"parameters."
msgstr ""
"Python 2.0 решает эту проблему, периодически выполняя алгоритм обнаружения "
"циклов, который ищет недоступные циклы и удаляет задействованные объекты. "
"Новый модуль :mod:`gc` предоставляет функции для выполнения сборки мусора, "
"получения статистики отладки и настройки параметров сборщика."

#: ../../whatsnew/2.0.rst:471
msgid ""
"Running the cycle detection algorithm takes some time, and therefore will "
"result in some additional overhead.  It is hoped that after we've gotten "
"experience with the cycle collection from using 2.0, Python 2.1 will be able "
"to minimize the overhead with careful tuning.  It's not yet obvious how much "
"performance is lost, because benchmarking this is tricky and depends "
"crucially on how often the program creates and destroys objects.  The "
"detection of cycles can be disabled when Python is compiled, if you can't "
"afford even a tiny speed penalty or suspect that the cycle collection is "
"buggy, by specifying the :option:`!--without-cycle-gc` switch when running "
"the :program:`configure` script."
msgstr ""
"Запуск алгоритма обнаружения цикла занимает некоторое время и, "
"следовательно, приведет к некоторым дополнительным накладным расходам. Есть "
"надежда, что после того, как мы получим опыт работы с коллекцией циклов при "
"использовании версии 2.0, Python 2.1 сможет минимизировать накладные расходы "
"за счет тщательной настройки. Пока не очевидно, насколько сильно теряется "
"производительность, потому что эталонное тестирование сложно и во многом "
"зависит от того, как часто программа создает и уничтожает объекты. "
"Обнаружение циклов можно отключить при компиляции Python, если вы не можете "
"позволить себе даже незначительное снижение скорости или подозреваете, что "
"коллекция циклов содержит ошибки, указав переключатель :option:`!--without-"
"cycle-gc` при запуск сценария :program:`configure`."

#: ../../whatsnew/2.0.rst:482
msgid ""
"Several people tackled this problem and contributed to a solution.  An early "
"implementation of the cycle detection approach was written by Toby Kelsey.  "
"The current algorithm was suggested by Eric Tiedemann during a visit to "
"CNRI, and Guido van Rossum and Neil Schemenauer wrote two different "
"implementations, which were later integrated by Neil.  Lots of other people "
"offered suggestions along the way; the March 2000 archives of the python-dev "
"mailing list contain most of the relevant discussion, especially in the "
"threads titled \"Reference cycle collection for Python\" and \"Finalization "
"again\"."
msgstr ""
"Несколько человек взялись за эту проблему и внесли свой вклад в ее решение. "
"Раннюю реализацию подхода обнаружения цикла написал Тоби Келси. Текущий "
"алгоритм был предложен Эриком Тидеманом во время визита в CNRI, а Гвидо ван "
"Россум и Нил Шеменауэр написали две разные реализации, которые позже были "
"интегрированы Нилом. По пути многие другие люди предлагали свои предложения; "
"архивы списка рассылки python-dev за март 2000 года содержат большую часть "
"соответствующих обсуждений, особенно в темах под названием «Сборник "
"эталонных циклов для Python» и «Снова завершение»."

#: ../../whatsnew/2.0.rst:495
msgid "Other Core Changes"
msgstr "Другие основные изменения"

#: ../../whatsnew/2.0.rst:497
msgid ""
"Various minor changes have been made to Python's syntax and built-in "
"functions. None of the changes are very far-reaching, but they're handy "
"conveniences."
msgstr ""
"В синтаксис и встроенные функции Python были внесены различные "
"незначительные изменения. Ни одно из изменений не является слишком далеко "
"идущим, но это удобное удобство."

#: ../../whatsnew/2.0.rst:502
msgid "Minor Language Changes"
msgstr "Незначительные изменения языка"

#: ../../whatsnew/2.0.rst:504
msgid ""
"A new syntax makes it more convenient to call a given function with a tuple "
"of arguments and/or a dictionary of keyword arguments. In Python 1.5 and "
"earlier, you'd use the :func:`!apply` built-in function: ``apply(f, args, "
"kw)`` calls the function :func:`!f` with the argument tuple *args* and the "
"keyword arguments in the dictionary *kw*.  :func:`!apply`  is the same in "
"2.0, but thanks to a patch from Greg Ewing, ``f(*args, **kw)`` is a shorter "
"and clearer way to achieve the same effect.  This syntax is symmetrical with "
"the syntax for defining functions::"
msgstr ""
"Новый синтаксис делает более удобным вызов заданной функции с кортежем "
"аргументов и/или словарем аргументов ключевых слов. В Python 1.5 и более "
"ранних версиях вы должны использовать встроенную функцию :func:`!apply`: "
"``apply(f, args, kw)`` вызывает функцию :func:`!f` с кортежем аргументов * "
"args* и аргументы ключевого слова в словаре *kw*. :func:`!apply` в версии "
"2.0 такой же, но благодаря патчу от Грега Юинга ``f(*args, **kw)`` стал "
"более коротким и понятным способом достижения того же эффекта. Этот "
"синтаксис симметричен синтаксису определения функций::"

#: ../../whatsnew/2.0.rst:513
msgid ""
"def f(*args, **kw):\n"
"    # args is a tuple of positional args,\n"
"    # kw is a dictionary of keyword args\n"
"    ..."
msgstr ""
"def f(*args, **kw):\n"
"    # args is a tuple of positional args,\n"
"    # kw is a dictionary of keyword args\n"
"    ..."

#: ../../whatsnew/2.0.rst:518
msgid ""
"The ``print`` statement can now have its output directed to a file-like "
"object by following the ``print`` with  ``>> file``, similar to the "
"redirection operator in Unix shells. Previously you'd either have to use "
"the :meth:`!write` method of the file-like object, which lacks the "
"convenience and simplicity of ``print``, or you could assign a new value to "
"``sys.stdout`` and then restore the old value.  For sending output to "
"standard error, it's much easier to write this::"
msgstr ""
"Вывод оператора ``print`` теперь может быть направлен на файлоподобный "
"объект, если после ``print`` следовать ``>> file``, аналогично оператору "
"перенаправления в оболочках Unix. Раньше вам приходилось либо использовать "
"метод :meth:`!write` файлового объекта, которому не хватает удобства и "
"простоты ``print``, либо вы могли присвоить новое значение ``sys.stdout``. "
"`` а затем восстановите старое значение. Для отправки вывода в стандартную "
"ошибку гораздо проще написать следующее:"

#: ../../whatsnew/2.0.rst:526
msgid "print >> sys.stderr, \"Warning: action field not supplied\""
msgstr "print >> sys.stderr, «Предупреждение: поле действия не указано»"

#: ../../whatsnew/2.0.rst:528
msgid ""
"Modules can now be renamed on importing them, using the syntax ``import "
"module as name`` or ``from module import name as othername``.  The patch was "
"submitted by Thomas Wouters."
msgstr ""
"Модули теперь можно переименовывать при их импорте, используя синтаксис "
"«импортировать модуль как имя» или «из модуля импортировать имя как другое "
"имя». Патч был представлен Томасом Воутерсом."

#: ../../whatsnew/2.0.rst:532
msgid ""
"A new format style is available when using the ``%`` operator; '%r' will "
"insert the :func:`repr` of its argument.  This was also added from symmetry "
"considerations, this time for symmetry with the existing '%s' format style, "
"which inserts the :func:`str` of its argument.  For example, ``'%r %s' % "
"('abc', 'abc')`` returns a string containing ``'abc' abc``."
msgstr ""
"Новый стиль формата доступен при использовании оператора ``%``; '%r' "
"вставит :func:`repr` своего аргумента. Это также было добавлено из "
"соображений симметрии, на этот раз для симметрии с существующими %s 'стиль "
"формата, который вставляет :func:`str` своего аргумента. Например, ``'%r %s "
"' % ('abc', 'abc')`` возвращает строку, содержащую ``'abc' abc``."

#: ../../whatsnew/2.0.rst:538
msgid ""
"Previously there was no way to implement a class that overrode Python's "
"built-in :keyword:`in` operator and implemented a custom version.  ``obj in "
"seq`` returns true if *obj* is present in the sequence *seq*; Python "
"computes this by simply trying every index of the sequence until either "
"*obj* is found or an :exc:`IndexError` is encountered.  Moshe Zadka "
"contributed a patch which adds a :meth:`!__contains__` magic method for "
"providing a custom implementation for :keyword:`!in`. Additionally, new "
"built-in objects written in C can define what :keyword:`!in` means for them "
"via a new slot in the sequence protocol."
msgstr ""
"Раньше не было возможности реализовать класс, который переопределил бы "
"встроенный в Python оператор :keyword:`in` и реализовал собственную версию. "
"``obj in seq`` возвращает true, если *obj* присутствует в последовательности "
"*seq*; Python вычисляет это, просто перебирая каждый индекс "
"последовательности, пока не будет найден либо *obj*, либо пока не "
"встретится :exc:`IndexError`. Моше Задка предоставил патч, который добавляет "
"магический метод :meth:`!__contains__` для обеспечения пользовательской "
"реализации :keyword:`!in`. Кроме того, новые встроенные объекты, написанные "
"на C, могут определять, что для них означает :keyword:`!in`, через новый "
"слот в протоколе последовательности."

#: ../../whatsnew/2.0.rst:547
msgid ""
"Earlier versions of Python used a recursive algorithm for deleting objects. "
"Deeply nested data structures could cause the interpreter to fill up the C "
"stack and crash; Christian Tismer rewrote the deletion logic to fix this "
"problem.  On a related note, comparing recursive objects recursed infinitely "
"and crashed; Jeremy Hylton rewrote the code to no longer crash, producing a "
"useful result instead.  For example, after this code::"
msgstr ""
"Более ранние версии Python использовали рекурсивный алгоритм удаления "
"объектов. Глубоко вложенные структуры данных могут привести к тому, что "
"интерпретатор заполнит стек C и выйдет из строя; Кристиан Тисмер переписал "
"логику удаления, чтобы решить эту проблему. Кстати, сравнение рекурсивных "
"объектов выполнялось бесконечно и приводило к сбою; Джереми Хилтон переписал "
"код, чтобы он больше не давал сбоев, вместо этого давая полезный результат. "
"Например, после этого кода::"

#: ../../whatsnew/2.0.rst:554
msgid ""
"a = []\n"
"b = []\n"
"a.append(a)\n"
"b.append(b)"
msgstr ""
"a = []\n"
"b = []\n"
"a.append(a)\n"
"b.append(b)"

#: ../../whatsnew/2.0.rst:559
msgid ""
"The comparison ``a==b`` returns true, because the two recursive data "
"structures are isomorphic. See the thread \"trashcan and PR#7\" in the April "
"2000 archives of the python-dev mailing list for the discussion leading up "
"to this implementation, and some useful relevant links.    Note that "
"comparisons can now also raise exceptions. In earlier versions of Python, a "
"comparison operation such as ``cmp(a,b)`` would always produce an answer, "
"even if a user-defined :meth:`!__cmp__` method encountered an error, since "
"the resulting exception would simply be silently swallowed."
msgstr ""
"Сравнение ``a==b`` возвращает true, поскольку две рекурсивные структуры "
"данных изоморфны. См. ветку «мусорная корзина и PR#7» в архивах списка "
"рассылки python-dev за апрель 2000 г., где представлено обсуждение, "
"приведшее к этой реализации, а также некоторые полезные ссылки. Обратите "
"внимание, что сравнения теперь также могут вызывать исключения. В более "
"ранних версиях Python операция сравнения, такая как ``cmp(a,b)``, всегда "
"давала ответ, даже если пользовательский метод :meth:`!__cmp__` обнаруживал "
"ошибку, поскольку результирующее исключение просто молча проглотить."

#: ../../whatsnew/2.0.rst:571
msgid ""
"Work has been done on porting Python to 64-bit Windows on the Itanium "
"processor, mostly by Trent Mick of ActiveState.  (Confusingly, ``sys."
"platform`` is still ``'win32'`` on Win64 because it seems that for ease of "
"porting, MS Visual C++ treats code as 32 bit on Itanium.) PythonWin also "
"supports Windows CE; see the Python CE page at https://pythonce.sourceforge."
"net/ for more information."
msgstr ""
"Работа по портированию Python на 64-разрядную версию Windows на процессоре "
"Itanium была проделана в основном Трентом Миком из ActiveState. (Как ни "
"странно, ``sys.platform`` по-прежнему является ``'win32'`` на Win64, потому "
"что кажется, что для простоты портирования MS Visual C++ рассматривает код "
"на Itanium как 32-битный.) PythonWin также поддерживает Windows CE; "
"дополнительную информацию см. на странице Python CE по адресу https://"
"pythonce.sourceforge.net/."

#: ../../whatsnew/2.0.rst:577
msgid ""
"Another new platform is Darwin/MacOS X; initial support for it is in Python "
"2.0. Dynamic loading works, if you specify \"configure --with-dyld --with-"
"suffix=.x\". Consult the README in the Python source distribution for more "
"instructions."
msgstr ""
"Еще одна новая платформа — Darwin/MacOS X; первоначальная поддержка имеется "
"в Python 2.0. Динамическая загрузка работает, если вы укажете «configure --"
"with-dyld --with-suffix=.x». Дополнительные инструкции см. в README в "
"дистрибутиве исходного кода Python."

#: ../../whatsnew/2.0.rst:581
msgid ""
"An attempt has been made to alleviate one of Python's warts, the often-"
"confusing :exc:`NameError` exception when code refers to a local variable "
"before the variable has been assigned a value.  For example, the following "
"code raises an exception on the ``print`` statement in both 1.5.2 and 2.0; "
"in 1.5.2 a :exc:`NameError` exception is raised, while 2.0 raises a new :exc:"
"`UnboundLocalError` exception. :exc:`UnboundLocalError` is a subclass of :"
"exc:`NameError`, so any existing code that expects :exc:`NameError` to be "
"raised should still work. ::"
msgstr ""
"Была предпринята попытка облегчить одну из проблем Python — часто сбивающее "
"с толку исключение :exc:`NameError`, когда код ссылается на локальную "
"переменную до того, как этой переменной было присвоено значение. Например, "
"следующий код вызывает исключение для оператора print как в 1.5.2, так и в "
"2.0; в версии 1.5.2 возникает исключение :exc:`NameError`, а в версии 2.0 — "
"новое исключение :exc:`UnboundLocalError`. :exc:`UnboundLocalError` является "
"подклассом :exc:`NameError`, поэтому любой существующий код, который ожидает "
"вызова :exc:`NameError`, должен по-прежнему работать. ::"

#: ../../whatsnew/2.0.rst:590
msgid ""
"def f():\n"
"    print \"i=\",i\n"
"    i = i + 1\n"
"f()"
msgstr ""
"def f():\n"
"    print \"i=\",i\n"
"    i = i + 1\n"
"f()"

#: ../../whatsnew/2.0.rst:595
msgid ""
"Two new exceptions, :exc:`TabError` and :exc:`IndentationError`, have been "
"introduced.  They're both subclasses of :exc:`SyntaxError`, and are raised "
"when Python code is found to be improperly indented."
msgstr ""
"Введены два новых исключения: :exc:`TabError` и :exc:`IndentationError`. Оба "
"они являются подклассами :exc:`SyntaxError` и вызываются, когда "
"обнаруживается, что код Python имеет неправильный отступ."

#: ../../whatsnew/2.0.rst:601
msgid "Changes to Built-in Functions"
msgstr "Изменения во встроенных функциях"

#: ../../whatsnew/2.0.rst:603
msgid ""
"A new built-in, ``zip(seq1, seq2, ...)``, has been added.  :func:`zip` "
"returns a list of tuples where each tuple contains the i-th element from "
"each of the argument sequences.  The difference between :func:`zip` and "
"``map(None, seq1, seq2)`` is that :func:`map` pads the sequences with "
"``None`` if the sequences aren't all of the same length, while :func:`zip` "
"truncates the returned list to the length of the shortest argument sequence."
msgstr ""
"Был добавлен новый встроенный zip(seq1, seq2, ...)``. :func:`zip` возвращает "
"список кортежей, каждый из которых содержит i-й элемент из каждой "
"последовательности аргументов. Разница между :func:`zip` и ``map(None, seq1, "
"seq2)`` заключается в том, что :func:`map` дополняет последовательности "
"``None``, если все последовательности не имеют одинаковой длины. , а :func:"
"`zip` усекает возвращаемый список до длины кратчайшей последовательности "
"аргументов."

#: ../../whatsnew/2.0.rst:610
msgid ""
"The :func:`int` and :func:`!long` functions now accept an optional \"base\" "
"parameter when the first argument is a string. ``int('123', 10)`` returns "
"123, while ``int('123', 16)`` returns 291.  ``int(123, 16)`` raises a :exc:"
"`TypeError` exception with the message \"can't convert non-string with "
"explicit base\"."
msgstr ""
"Функции :func:`int` и :func:`!long` теперь принимают необязательный "
"«базовый» параметр, если первым аргументом является строка. ``int('123', "
"10)`` возвращает 123, а ``int('123', 16)`` возвращает 291. ``int(123, 16)`` "
"вызывает исключение :exc:`TypeError` с сообщением «невозможно преобразовать "
"нестроку с явной базой»."

#: ../../whatsnew/2.0.rst:616
msgid ""
"A new variable holding more detailed version information has been added to "
"the :mod:`sys` module.  ``sys.version_info`` is a tuple ``(major, minor, "
"micro, level, serial)`` For example, in a hypothetical 2.0.1beta1, ``sys."
"version_info`` would be ``(2, 0, 1, 'beta', 1)``. *level* is a string such "
"as ``\"alpha\"``, ``\"beta\"``, or ``\"final\"`` for a final release."
msgstr ""
"В модуль :mod:`sys` добавлена ​​новая переменная, содержащая более подробную "
"информацию о версии. ``sys.version_info`` представляет собой кортеж "
"``(основной, минорный, микро, уровень, серийный номер)`` Например, в "
"гипотетической версии 2.0.1beta1 ``sys.version_info`` будет ``(2, 0 , 1, "
"'бета', 1)``. *level* — это строка, например ``\"alpha\"``, ``\"beta\"`` или "
"``\"final\"`` для финальной версии."

#: ../../whatsnew/2.0.rst:622
msgid ""
"Dictionaries have an odd new method, ``setdefault(key, default)``, which "
"behaves similarly to the existing :meth:`!get` method.  However, if the key "
"is missing, :meth:`!setdefault` both returns the value of *default* as :meth:"
"`!get` would do, and also inserts it into the dictionary as the value for "
"*key*.  Thus, the following lines of code::"
msgstr ""
"В словарях появился новый необычный метод ``setdefault(key, default)``, "
"который ведет себя аналогично существующему методу :meth:`!get`. Однако, "
"если ключ отсутствует, :meth:`!setdefault` возвращает значение *default*, "
"как это сделал бы :meth:`!get`, а также вставляет его в словарь как значение "
"для *key*. Таким образом, следующие строки кода:"

#: ../../whatsnew/2.0.rst:628
msgid ""
"if dict.has_key( key ): return dict[key]\n"
"else:\n"
"    dict[key] = []\n"
"    return dict[key]"
msgstr ""
"if dict.has_key( key ): return dict[key]\n"
"else:\n"
"    dict[key] = []\n"
"    return dict[key]"

#: ../../whatsnew/2.0.rst:633
msgid ""
"can be reduced to a single ``return dict.setdefault(key, [])`` statement."
msgstr "можно свести к одному оператору return dict.setdefault(key, [])``."

#: ../../whatsnew/2.0.rst:635
msgid ""
"The interpreter sets a maximum recursion depth in order to catch runaway "
"recursion before filling the C stack and causing a core dump or GPF.. "
"Previously this limit was fixed when you compiled Python, but in 2.0 the "
"maximum recursion depth can be read and modified using :func:`sys."
"getrecursionlimit` and :func:`sys.setrecursionlimit`. The default value is "
"1000, and a rough maximum value for a given platform can be found by running "
"a new script, :file:`Misc/find_recursionlimit.py`."
msgstr ""
"Интерпретатор устанавливает максимальную глубину рекурсии, чтобы поймать "
"неконтролируемую рекурсию перед заполнением стека C и вызовом дампа ядра или "
"GPF. Раньше этот предел фиксировался при компиляции Python, но в версии 2.0 "
"максимальную глубину рекурсии можно прочитать и изменить с помощью :func:"
"`sys.getrecursionlimit` и :func:`sys.setrecursionlimit`. Значение по "
"умолчанию — 1000, а примерное максимальное значение для данной платформы "
"можно найти, запустив новый скрипт :file:`Misc/find_recursionlimit.py`."

#: ../../whatsnew/2.0.rst:647
msgid "Porting to 2.0"
msgstr "Переход на версию 2.0"

#: ../../whatsnew/2.0.rst:649
msgid ""
"New Python releases try hard to be compatible with previous releases, and "
"the record has been pretty good.  However, some changes are considered "
"useful enough, usually because they fix initial design decisions that turned "
"out to be actively mistaken, that breaking backward compatibility can't "
"always be avoided. This section lists the changes in Python 2.0 that may "
"cause old Python code to break."
msgstr ""
"Новые выпуски Python изо всех сил стараются быть совместимыми с предыдущими "
"выпусками, и результаты оказались довольно хорошими. Однако некоторые "
"изменения считаются достаточно полезными, обычно потому, что они исправляют "
"первоначальные проектные решения, которые оказались ошибочными, поэтому "
"нарушения обратной совместимости не всегда можно избежать. В этом разделе "
"перечислены изменения в Python 2.0, которые могут привести к поломке старого "
"кода Python."

#: ../../whatsnew/2.0.rst:656
msgid ""
"The change which will probably break the most code is tightening up the "
"arguments accepted by some methods.  Some methods would take multiple "
"arguments and treat them as a tuple, particularly various list methods such "
"as :meth:`!append` and :meth:`!insert`. In earlier versions of Python, if "
"``L`` is a list, ``L.append( 1,2 )`` appends the tuple ``(1,2)`` to the "
"list.  In Python 2.0 this causes a :exc:`TypeError` exception to be raised, "
"with the message: 'append requires exactly 1 argument; 2 given'.  The fix is "
"to simply add an extra set of parentheses to pass both values as a tuple:  "
"``L.append( (1,2) )``."
msgstr ""
"Изменение, которое, вероятно, больше всего сломает код, — это ужесточение "
"аргументов, принимаемых некоторыми методами. Некоторые методы принимают "
"несколько аргументов и обрабатывают их как кортеж, особенно различные методы "
"списков, такие как :meth:`!append` и :meth:`!insert`. В более ранних версиях "
"Python, если ``L`` является списком, ``L.append( 1,2 )`` добавляет кортеж "
"``(1,2)`` к списку. В Python 2.0 это вызывает исключение :exc:`TypeError` с "
"сообщением: 'append требует ровно 1 аргумент; 2 дано». Решение состоит в "
"том, чтобы просто добавить дополнительный набор круглых скобок для передачи "
"обоих значений в виде кортежа: ``L.append( (1,2))``."

#: ../../whatsnew/2.0.rst:665
msgid ""
"The earlier versions of these methods were more forgiving because they used "
"an old function in Python's C interface to parse their arguments; 2.0 "
"modernizes them to use :c:func:`PyArg_ParseTuple`, the current argument "
"parsing function, which provides more helpful error messages and treats "
"multi-argument calls as errors.  If you absolutely must use 2.0 but can't "
"fix your code, you can edit :file:`Objects/listobject.c` and define the "
"preprocessor symbol ``NO_STRICT_LIST_APPEND`` to preserve the old behaviour; "
"this isn't recommended."
msgstr ""
"Более ранние версии этих методов были более щадящими, поскольку для анализа "
"аргументов они использовали старую функцию из интерфейса Python C; Версия "
"2.0 модернизирует их для использования :c:func:`PyArg_ParseTuple`, текущей "
"функции анализа аргументов, которая выдает более полезные сообщения об "
"ошибках и обрабатывает вызовы с несколькими аргументами как ошибки. Если вам "
"абсолютно необходимо использовать версию 2.0, но вы не можете исправить свой "
"код, вы можете отредактировать :file:`Objects/listobject.c` и определить "
"символ препроцессора ``NO_STRICT_LIST_APPEND``, чтобы сохранить старое "
"поведение; это не рекомендуется."

#: ../../whatsnew/2.0.rst:673
msgid ""
"Some of the functions in the :mod:`socket` module are still forgiving in "
"this way.  For example, ``socket.connect( ('hostname', 25) )`` is the "
"correct form, passing a tuple representing an IP address, but ``socket."
"connect('hostname', 25)`` also works. :meth:`socket.connect_ex <socket."
"socket.connect_ex>` and :meth:`socket.bind <socket.socket.bind>` are "
"similarly easy-going.  2.0alpha1 tightened these functions up, but because "
"the documentation actually used the erroneous multiple argument form, many "
"people wrote code which would break with the stricter checking.  GvR backed "
"out the changes in the face of public reaction, so for the :mod:`socket` "
"module, the documentation was fixed and the multiple argument form is simply "
"marked as deprecated; it *will* be tightened up again in a future Python "
"version."
msgstr ""
"Некоторые функции модуля :mod:`socket` по-прежнему прощают ошибки. Например, "
"``socket.connect(('hostname', 25))`` является правильной формой, передавая "
"кортеж, представляющий IP-адрес, но ``socket.connect('hostname', 25)`` также "
"работает. :meth:`socket.connect_ex <socket.socket.connect_ex>` и :meth:"
"`socket.bind <socket.socket.bind>` одинаково просты в использовании. Версия "
"2.0alpha1 ужесточила эти функции, но поскольку в документации фактически "
"использовалась ошибочная форма с несколькими аргументами, многие люди писали "
"код, который не выдержал бы более строгой проверки. GvR отклонил изменения, "
"несмотря на общественную реакцию, поэтому для модуля :mod:`socket` "
"документация была исправлена, а форма с несколькими аргументами просто "
"помечена как устаревшая; оно *будет* снова исправлено в будущей версии "
"Python."

#: ../../whatsnew/2.0.rst:684
msgid ""
"The ``\\x`` escape in string literals now takes exactly 2 hex digits.  "
"Previously it would consume all the hex digits following the 'x' and take "
"the lowest 8 bits of the result, so ``\\x123456`` was equivalent to "
"``\\x56``."
msgstr ""
"Экранирование ``\\x`` в строковых литералах теперь занимает ровно 2 "
"шестнадцатеричные цифры. Раньше он поглощал все шестнадцатеричные цифры "
"после 'x' и младшие 8 бит результата, поэтому ``\\x123456`` был эквивалентен "
"``\\x56``."

#: ../../whatsnew/2.0.rst:688
msgid ""
"The :exc:`AttributeError` and :exc:`NameError` exceptions have a more "
"friendly error message, whose text will be something like ``'Spam' instance "
"has no attribute 'eggs'`` or ``name 'eggs' is not defined``.  Previously the "
"error message was just the missing attribute name ``eggs``, and code written "
"to take advantage of this fact will break in 2.0."
msgstr ""
"Исключения :exc:`AttributeError` и :exc:`NameError` имеют более понятное "
"сообщение об ошибке, текст которого будет выглядеть примерно так: "
"``'Экземпляр спама не имеет атрибута 'eggs'`` или ``имя 'eggs' не "
"определено``. Раньше в сообщении об ошибке было просто отсутствующее имя "
"атрибута «eggs», и код, написанный с учетом этого факта, не будет работать в "
"версии 2.0."

#: ../../whatsnew/2.0.rst:694
msgid ""
"Some work has been done to make integers and long integers a bit more "
"interchangeable.  In 1.5.2, large-file support was added for Solaris, to "
"allow reading files larger than 2 GiB; this made the :meth:`!tell` method of "
"file objects return a long integer instead of a regular integer.  Some code "
"would subtract two file offsets and attempt to use the result to multiply a "
"sequence or slice a string, but this raised a :exc:`TypeError`.  In 2.0, "
"long integers can be used to multiply or slice a sequence, and it'll behave "
"as you'd intuitively expect it to; ``3L * 'abc'`` produces 'abcabcabc', and "
"``(0,1,2,3)[2L:4L]`` produces (2,3). Long integers can also be used in "
"various contexts where previously only integers were accepted, such as in "
"the :meth:`!seek` method of file objects, and in the formats supported by "
"the ``%`` operator (``%d``, ``%i``, ``%x``, etc.).  For example, ``\"%d\" % "
"2L**64`` will produce the string ``18446744073709551616``."
msgstr ""
"Была проделана некоторая работа, чтобы сделать целые и длинные целые числа "
"более взаимозаменяемыми. В версии 1.5.2 для Solaris была добавлена ​​поддержка "
"больших файлов, позволяющая читать файлы размером более 2 ГиБ; это заставило "
"метод :meth:`!tell` файловых объектов возвращать длинное целое число вместо "
"обычного целого числа. Некоторый код вычитал два смещения файла и пытался "
"использовать результат для умножения последовательности или разрезания "
"строки, но это вызывало ошибку :exc:`TypeError`. В версии 2.0 длинные целые "
"числа можно использовать для умножения или разрезания последовательности, и "
"они будут вести себя так, как вы интуитивно ожидаете; ``3L * 'abc'`` создает "
"'abcabcabc', а ``(0,1,2,3)[2L:4L]`` создает (2,3). Длинные целые числа также "
"можно использовать в различных контекстах, где раньше принимались только "
"целые числа, например, в методе :meth:`!seek` файловых объектов, а также в "
"форматах, поддерживаемых оператором ``%`` (`` %д ``, `` %я ``, `` %х `` и "
"др.). Например, ``\" %д \" % 2L**64`` создаст строку "
"``18446744073709551616``."

#: ../../whatsnew/2.0.rst:708
msgid ""
"The subtlest long integer change of all is that the :func:`str` of a long "
"integer no longer has a trailing 'L' character, though :func:`repr` still "
"includes it.  The 'L' annoyed many people who wanted to print long integers "
"that looked just like regular integers, since they had to go out of their "
"way to chop off the character.  This is no longer a problem in 2.0, but code "
"which does ``str(longval)[:-1]`` and assumes the 'L' is there, will now lose "
"the final digit."
msgstr ""
"Самым тонким изменением длинных целых чисел является то, что :func:`str` "
"длинного целого числа больше не имеет завершающего символа 'L', хотя :func:"
"`repr` по-прежнему включает его. Буква «L» раздражала многих людей, которые "
"хотели печатать длинные целые числа, которые выглядели бы так же, как "
"обычные целые числа, поскольку им приходилось прикладывать все усилия, чтобы "
"отрезать символ. Этой проблемы больше нет в версии 2.0, но код, который "
"выполняет ``str(longval)[:-1]`` и предполагает наличие 'L', теперь потеряет "
"последнюю цифру."

#: ../../whatsnew/2.0.rst:716
msgid ""
"Taking the :func:`repr` of a float now uses a different formatting precision "
"than :func:`str`.  :func:`repr` uses ``%.17g`` format string for C's :func:`!"
"sprintf`, while :func:`str` uses ``%.12g`` as before.  The effect is that :"
"func:`repr` may occasionally show more decimal places than  :func:`str`, for "
"certain numbers.  For example, the number 8.1 can't be represented exactly "
"in binary, so ``repr(8.1)`` is ``'8.0999999999999996'``, while str(8.1) is "
"``'8.1'``."
msgstr ""
"При получении :func:`repr` числа с плавающей запятой теперь используется "
"другая точность форматирования, чем :func:`str`. :func:`repr` использует `` "
"%.17г `` строка формата для C :func:`!sprintf`, тогда как :func:`str` "
"использует `` %.12г `` как и прежде. В результате :func:`repr` может иногда "
"отображать больше десятичных знаков, чем :func:`str`, для определенных "
"чисел. Например, число 8.1 не может быть точно представлено в двоичном виде, "
"поэтому repr(8.1) — это 8.0999999999999996, а str(8.1) — 8.1."

#: ../../whatsnew/2.0.rst:724
msgid ""
"The ``-X`` command-line option, which turned all standard exceptions into "
"strings instead of classes, has been removed; the standard exceptions will "
"now always be classes.  The :mod:`!exceptions` module containing the "
"standard exceptions was translated from Python to a built-in C module, "
"written by Barry Warsaw and Fredrik Lundh."
msgstr ""
"Опция командной строки ``-X``, которая превращала все стандартные исключения "
"в строки вместо классов, была удалена; стандартными исключениями теперь "
"всегда будут классы. Модуль :mod:`!Exceptions`, содержащий стандартные "
"исключения, был переведен с Python во встроенный модуль C, написанный Барри "
"Варшавой и Фредриком Лундом."

#: ../../whatsnew/2.0.rst:740
msgid "Extending/Embedding Changes"
msgstr "Расширение/внедрение изменений"

#: ../../whatsnew/2.0.rst:742
msgid ""
"Some of the changes are under the covers, and will only be apparent to "
"people writing C extension modules or embedding a Python interpreter in a "
"larger application.  If you aren't dealing with Python's C API, you can "
"safely skip this section."
msgstr ""
"Некоторые изменения скрыты и будут заметны только тем, кто пишет модули "
"расширения C или встраивает интерпретатор Python в более крупное приложение. "
"Если вы не имеете дело с C API Python, вы можете смело пропустить этот "
"раздел."

#: ../../whatsnew/2.0.rst:747
msgid ""
"The version number of the Python C API was incremented, so C extensions "
"compiled for 1.5.2 must be recompiled in order to work with 2.0.  On "
"Windows, it's not possible for Python 2.0 to import a third party extension "
"built for Python 1.5.x due to how Windows DLLs work, so Python will raise an "
"exception and the import will fail."
msgstr ""
"Номер версии Python C API был увеличен, поэтому расширения C, "
"скомпилированные для версии 1.5.2, необходимо перекомпилировать, чтобы "
"работать с версией 2.0. В Windows Python 2.0 не может импортировать "
"стороннее расширение, созданное для Python 1.5.x, из-за особенностей работы "
"Windows DLL, поэтому Python вызовет исключение, и импорт завершится неудачно."

#: ../../whatsnew/2.0.rst:753
msgid ""
"Users of Jim Fulton's ExtensionClass module will be pleased to find out that "
"hooks have been added so that ExtensionClasses are now supported by :func:"
"`isinstance` and :func:`issubclass`. This means you no longer have to "
"remember to write code such as ``if type(obj) == myExtensionClass``, but can "
"use the more natural ``if isinstance(obj, myExtensionClass)``."
msgstr ""
"Пользователи модуля ExtensionClass Джима Фултона будут рады узнать, что были "
"добавлены перехватчики, благодаря которым классы ExtensionClass теперь "
"поддерживаются :func:`isinstance` и :func:`issubclass`. Это означает, что "
"вам больше не нужно помнить о написании кода типа ``if type(obj) == "
"myExtensionClass``, а можно использовать более естественный ``if "
"isinstance(obj, myExtensionClass)``."

#: ../../whatsnew/2.0.rst:759
msgid ""
"The :file:`Python/importdl.c` file, which was a mass of #ifdefs to support "
"dynamic loading on many different platforms, was cleaned up and reorganised "
"by Greg Stein.  :file:`importdl.c` is now quite small, and platform-specific "
"code has been moved into a bunch of :file:`Python/dynload_\\*.c` files.  "
"Another cleanup: there were also a number of :file:`my\\*.h` files in the "
"Include/ directory that held various portability hacks; they've been merged "
"into a single file, :file:`Include/pyport.h`."
msgstr ""
"Файл :file:`Python/importdl.c`, который представлял собой массу #ifdefs для "
"поддержки динамической загрузки на многих различных платформах, был очищен и "
"реорганизован Грегом Стейном. :file:`importdl.c` теперь стал довольно "
"маленьким, а код, специфичный для платформы, был перемещен в группу файлов :"
"file:`Python/dynload_\\*.c`. Еще одна очистка: в каталоге Include/ также "
"было несколько файлов :file:`my\\*.h`, содержащих различные хаки по "
"переносимости; они были объединены в один файл :file:`Include/pyport.h`."

#: ../../whatsnew/2.0.rst:767
msgid ""
"Vladimir Marangozov's long-awaited malloc restructuring was completed, to "
"make it easy to have the Python interpreter use a custom allocator instead "
"of C's standard :c:func:`malloc`.  For documentation, read the comments in :"
"file:`Include/pymem.h` and :file:`Include/objimpl.h`.  For the lengthy "
"discussions during which the interface was hammered out, see the web "
"archives of the 'patches' and 'python-dev' lists at python.org."
msgstr ""
"Долгожданная реструктуризация malloc Владимира Марангозова была завершена, "
"чтобы интерпретатор Python мог легко использовать собственный распределитель "
"вместо стандартного C :c:func:`malloc`. Документацию можно найти в "
"комментариях в :file:`Include/pymem.h` и :file:`Include/objimpl.h`. "
"Подробности о длительных обсуждениях, в ходе которых создавался интерфейс, "
"см. в веб-архивах списков «патчей» и «python-dev» на сайте python.org."

#: ../../whatsnew/2.0.rst:774
msgid ""
"Recent versions of the GUSI development environment for MacOS support POSIX "
"threads.  Therefore, Python's POSIX threading support now works on the "
"Macintosh.  Threading support using the user-space GNU ``pth`` library was "
"also contributed."
msgstr ""
"Последние версии среды разработки GUSI для MacOS поддерживают потоки POSIX. "
"Таким образом, поддержка потоков POSIX в Python теперь работает и на "
"Macintosh. Также была реализована поддержка многопоточности с использованием "
"пользовательской библиотеки GNU ``pth``."

#: ../../whatsnew/2.0.rst:779
msgid ""
"Threading support on Windows was enhanced, too.  Windows supports thread "
"locks that use kernel objects only in case of contention; in the common case "
"when there's no contention, they use simpler functions which are an order of "
"magnitude faster.  A threaded version of Python 1.5.2 on NT is twice as slow "
"as an unthreaded version; with the 2.0 changes, the difference is only 10%.  "
"These improvements were contributed by Yakov Markovitch."
msgstr ""
"Поддержка потоков в Windows также была улучшена. Windows поддерживает "
"блокировки потоков, которые используют объекты ядра только в случае "
"конфликта; в обычном случае, когда нет конфликтов, они используют более "
"простые функции, которые работают на порядок быстрее. Поточная версия Python "
"1.5.2 для NT работает в два раза медленнее, чем непоточная версия; с "
"изменениями 2.0 разница составляет всего 10%. Эти улучшения были внесены "
"Яковом Марковичем."

#: ../../whatsnew/2.0.rst:786
msgid ""
"Python 2.0's source now uses only ANSI C prototypes, so compiling Python now "
"requires an ANSI C compiler, and can no longer be done using a compiler that "
"only supports K&R C."
msgstr ""
"Исходный код Python 2.0 теперь использует только прототипы ANSI C, поэтому "
"для компиляции Python теперь требуется компилятор ANSI C, и его больше "
"нельзя выполнить с помощью компилятора, поддерживающего только K&R C."

#: ../../whatsnew/2.0.rst:790
msgid ""
"Previously the Python virtual machine used 16-bit numbers in its bytecode, "
"limiting the size of source files.  In particular, this affected the maximum "
"size of literal lists and dictionaries in Python source; occasionally people "
"who are generating Python code would run into this limit.  A patch by "
"Charles G. Waldman raises the limit from ``2**16`` to ``2**32``."
msgstr ""
"Раньше виртуальная машина Python использовала в своем байт-коде 16-битные "
"числа, что ограничивало размер исходных файлов. В частности, это повлияло на "
"максимальный размер списков букв и словарей в исходном коде Python; иногда "
"люди, генерирующие код Python, сталкиваются с этим пределом. Патч Чарльза Г. "
"Уолдмана увеличивает лимит с «2**16» до «2**32»."

#: ../../whatsnew/2.0.rst:796
msgid ""
"Three new convenience functions intended for adding constants to a module's "
"dictionary at module initialization time were added: :c:func:"
"`PyModule_AddObject`, :c:func:`PyModule_AddIntConstant`, and :c:func:"
"`PyModule_AddStringConstant`.  Each of these functions takes a module "
"object, a null-terminated C string containing the name to be added, and a "
"third argument for the value to be assigned to the name.  This third "
"argument is, respectively, a Python object, a C long, or a C string."
msgstr ""
"Были добавлены три новые удобные функции, предназначенные для добавления "
"констант в словарь модуля во время инициализации модуля: :c:func:"
"`PyModule_AddObject`, :c:func:`PyModule_AddIntConstant` и :c:func:"
"`PyModule_AddStringConstant`. Каждая из этих функций принимает объект "
"модуля, строку C с нулевым завершением, содержащую добавляемое имя, и третий "
"аргумент для значения, которое должно быть присвоено имени. Этот третий "
"аргумент является соответственно объектом Python, длиной C или строкой C."

#: ../../whatsnew/2.0.rst:804
msgid ""
"A wrapper API was added for Unix-style signal handlers. :c:func:"
"`PyOS_getsig` gets a signal handler and :c:func:`PyOS_setsig` will set a new "
"handler."
msgstr ""
"Для обработчиков сигналов в стиле Unix был добавлен API-оболочка. :c:func:"
"`PyOS_getsig` получает обработчик сигнала, а :c:func:`PyOS_setsig` "
"устанавливает новый обработчик."

#: ../../whatsnew/2.0.rst:811
msgid "Distutils: Making Modules Easy to Install"
msgstr "Distutils: упрощение установки модулей"

#: ../../whatsnew/2.0.rst:813
msgid ""
"Before Python 2.0, installing modules was a tedious affair -- there was no "
"way to figure out automatically where Python is installed, or what compiler "
"options to use for extension modules.  Software authors had to go through an "
"arduous ritual of editing Makefiles and configuration files, which only "
"really work on Unix and leave Windows and MacOS unsupported.  Python users "
"faced wildly differing installation instructions which varied between "
"different extension packages, which made administering a Python installation "
"something of  a chore."
msgstr ""
"До Python 2.0 установка модулей была утомительным делом — не было "
"возможности автоматически определить, где установлен Python или какие "
"параметры компилятора использовать для модулей расширения. Авторам "
"программного обеспечения пришлось пройти через трудный ритуал редактирования "
"Make-файлов и файлов конфигурации, которые действительно работают только в "
"Unix и оставляют Windows и MacOS без поддержки. Пользователи Python "
"столкнулись с совершенно разными инструкциями по установке, которые "
"различались в зависимости от пакета расширений, что делало администрирование "
"установки Python довольно сложной задачей."

#: ../../whatsnew/2.0.rst:821
msgid ""
"The SIG for distribution utilities, shepherded by Greg Ward, has created the "
"Distutils, a system to make package installation much easier.  They form the "
"``distutils`` package, a new part of Python's standard library. In the best "
"case, installing a Python module from source will require the same steps: "
"first you simply mean unpack the tarball or zip archive, and the run "
"\"``python setup.py install``\".  The platform will be automatically "
"detected, the compiler will be recognized, C extension modules will be "
"compiled, and the distribution installed into the proper directory.  "
"Optional command-line arguments provide more control over the installation "
"process, the distutils package offers many places to override defaults -- "
"separating the build from the install, building or installing in non-default "
"directories, and more."
msgstr ""
"Группа SIG по распространению утилит под руководством Грега Уорда создала "
"Distutils, систему, значительно упрощающую установку пакетов. Они образуют "
"пакет distutils, новую часть стандартной библиотеки Python. В лучшем случае "
"установка модуля Python из исходного кода потребует тех же шагов: сначала вы "
"просто распаковываете tarball или zip-архив и запускаете «``python setup.py "
"install``». Платформа будет автоматически обнаружена, компилятор будет "
"распознан, модули расширения C будут скомпилированы, а дистрибутив "
"установлен в соответствующий каталог. Необязательные аргументы командной "
"строки обеспечивают больший контроль над процессом установки, пакет "
"distutils предлагает множество мест для переопределения значений по "
"умолчанию — разделение сборки от установки, сборка или установка в "
"каталогах, отличных от стандартных, и многое другое."

#: ../../whatsnew/2.0.rst:833
msgid ""
"In order to use the Distutils, you need to write a :file:`setup.py` script.  "
"For the simple case, when the software contains only .py files, a minimal :"
"file:`setup.py` can be just a few lines long::"
msgstr ""
"Чтобы использовать Distutils, вам необходимо написать скрипт :file:`setup."
"py`. В простом случае, когда программное обеспечение содержит только файлы ."
"py, минимальный файл :file:`setup.py` может состоять всего из нескольких "
"строк::"

#: ../../whatsnew/2.0.rst:837
msgid ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       py_modules = [\"module1\", \"module2\"])"
msgstr ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       py_modules = [\"module1\", \"module2\"])"

#: ../../whatsnew/2.0.rst:841
msgid ""
"The :file:`setup.py` file isn't much more complicated if the software "
"consists of a few packages::"
msgstr ""
"Файл :file:`setup.py` не намного сложнее, если программное обеспечение "
"состоит из нескольких пакетов::"

#: ../../whatsnew/2.0.rst:844
msgid ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       packages = [\"package\", \"package.subpackage\"])"
msgstr ""
"from distutils.core import setup\n"
"setup (name = \"foo\", version = \"1.0\",\n"
"       packages = [\"package\", \"package.subpackage\"])"

#: ../../whatsnew/2.0.rst:848
msgid ""
"A C extension can be the most complicated case; here's an example taken from "
"the PyXML package::"
msgstr ""
"Расширение переменного тока может оказаться самым сложным случаем; вот "
"пример, взятый из пакета PyXML::"

#: ../../whatsnew/2.0.rst:851
msgid ""
"from distutils.core import setup, Extension\n"
"\n"
"expat_extension = Extension('xml.parsers.pyexpat',\n"
"     define_macros = [('XML_NS', None)],\n"
"     include_dirs = [ 'extensions/expat/xmltok',\n"
"                      'extensions/expat/xmlparse' ],\n"
"     sources = [ 'extensions/pyexpat.c',\n"
"                 'extensions/expat/xmltok/xmltok.c',\n"
"                 'extensions/expat/xmltok/xmlrole.c', ]\n"
"       )\n"
"setup (name = \"PyXML\", version = \"0.5.4\",\n"
"       ext_modules =[ expat_extension ] )"
msgstr ""
"from distutils.core import setup, Extension\n"
"\n"
"expat_extension = Extension('xml.parsers.pyexpat',\n"
"     define_macros = [('XML_NS', None)],\n"
"     include_dirs = [ 'extensions/expat/xmltok',\n"
"                      'extensions/expat/xmlparse' ],\n"
"     sources = [ 'extensions/pyexpat.c',\n"
"                 'extensions/expat/xmltok/xmltok.c',\n"
"                 'extensions/expat/xmltok/xmlrole.c', ]\n"
"       )\n"
"setup (name = \"PyXML\", version = \"0.5.4\",\n"
"       ext_modules =[ expat_extension ] )"

#: ../../whatsnew/2.0.rst:864
msgid ""
"The Distutils can also take care of creating source and binary "
"distributions. The \"sdist\" command, run by \"``python setup.py sdist``', "
"builds a source distribution such as :file:`foo-1.0.tar.gz`. Adding new "
"commands isn't difficult, \"bdist_rpm\" and \"bdist_wininst\" commands have "
"already been contributed to create an RPM distribution and a Windows "
"installer for the software, respectively.  Commands to create other "
"distribution formats such as Debian packages and Solaris :file:`.pkg` files "
"are in various stages of development."
msgstr ""
"Distutils также может позаботиться о создании исходных и бинарных "
"дистрибутивов. Команда \"sdist\", запускаемая \"``python setup.py sdist``', "
"создает дистрибутив исходного кода, такой как :file:`foo-1.0.tar.gz`. "
"Добавление новых команд несложно, \"bdist_rpm\" и «bdist_wininst» уже были "
"использованы для создания дистрибутива RPM и установщика Windows для "
"программного обеспечения соответственно. Команды для создания других "
"форматов дистрибутива, таких как пакеты Debian и файлы Solaris :file:`.pkg`, "
"находятся на разных стадиях разработки. ."

#: ../../whatsnew/2.0.rst:873
msgid ""
"All this is documented in a new manual, *Distributing Python Modules*, that "
"joins the basic set of Python documentation."
msgstr ""
"Все это описано в новом руководстве *Распространение модулей Python*, "
"которое дополняет базовый набор документации Python."

#: ../../whatsnew/2.0.rst:880
msgid "XML Modules"
msgstr "XML-модули"

#: ../../whatsnew/2.0.rst:882
msgid ""
"Python 1.5.2 included a simple XML parser in the form of the :mod:`!xmllib` "
"module, contributed by Sjoerd Mullender.  Since 1.5.2's release, two "
"different interfaces for processing XML have become common: SAX2 (version 2 "
"of the Simple API for XML) provides an event-driven interface with some "
"similarities to :mod:`!xmllib`, and the DOM (Document Object Model) provides "
"a tree-based interface, transforming an XML document into a tree of nodes "
"that can be traversed and modified.  Python 2.0 includes a SAX2 interface "
"and a stripped-down DOM interface as part of the :mod:`xml` package. Here we "
"will give a brief overview of these new interfaces; consult the Python "
"documentation or the source code for complete details. The Python XML SIG is "
"also working on improved documentation."
msgstr ""
"Python 1.5.2 включал простой синтаксический анализатор XML в виде модуля :"
"mod:`!xmllib`, созданного Сьёрдом Мюллендером. С момента выпуска 1.5.2 стали "
"распространены два разных интерфейса для обработки XML: SAX2 (версия 2 "
"Simple API для XML) предоставляет управляемый событиями интерфейс, имеющий "
"некоторое сходство с :mod:`!xmllib` и DOM (Document Object Model) "
"предоставляет древовидный интерфейс, преобразующий XML-документ в дерево "
"узлов, которое можно просматривать и изменять. Python 2.0 включает интерфейс "
"SAX2 и урезанный интерфейс DOM как часть пакета :mod:`xml`. Здесь мы дадим "
"краткий обзор этих новых интерфейсов; для получения полной информации "
"обратитесь к документации Python или исходному коду. Python XML SIG также "
"работает над улучшением документации."

#: ../../whatsnew/2.0.rst:896
msgid "SAX2 Support"
msgstr "Поддержка SAX2"

#: ../../whatsnew/2.0.rst:898
msgid ""
"SAX defines an event-driven interface for parsing XML.  To use SAX, you must "
"write a SAX handler class.  Handler classes inherit from various classes "
"provided by SAX, and override various methods that will then be called by "
"the XML parser.  For example, the :meth:`~xml.sax.handler.ContentHandler."
"startElement` and :meth:`~xml.sax.handler.ContentHandler.endElement` methods "
"are called for every starting and end tag encountered by the parser, the :"
"meth:`~xml.sax.handler.ContentHandler.characters` method is called for every "
"chunk of character data, and so forth."
msgstr ""
"SAX определяет управляемый событиями интерфейс для анализа XML. Чтобы "
"использовать SAX, вы должны написать класс-обработчик SAX. Классы-"
"обработчики наследуют различные классы, предоставляемые SAX, и "
"переопределяют различные методы, которые затем будут вызываться анализатором "
"XML. Например, методы :meth:`~xml.sax.handler.ContentHandler.startElement` "
"и :meth:`~xml.sax.handler.ContentHandler.endElement` вызываются для каждого "
"начального и конечного тега, обнаруженного анализатором, Метод :meth:`~xml."
"sax.handler.ContentHandler.characters` вызывается для каждого фрагмента "
"символьных данных и так далее."

#: ../../whatsnew/2.0.rst:906
msgid ""
"The advantage of the event-driven approach is that the whole document "
"doesn't have to be resident in memory at any one time, which matters if you "
"are processing really huge documents.  However, writing the SAX handler "
"class can get very complicated if you're trying to modify the document "
"structure in some elaborate way."
msgstr ""
"Преимущество подхода, управляемого событиями, заключается в том, что весь "
"документ не обязательно должен постоянно находиться в памяти в любой момент "
"времени, что важно, если вы обрабатываете действительно огромные документы. "
"Однако написание класса-обработчика SAX может оказаться очень сложным, если "
"вы пытаетесь каким-то сложным образом изменить структуру документа."

#: ../../whatsnew/2.0.rst:912
msgid ""
"For example, this little example program defines a handler that prints a "
"message for every starting and ending tag, and then parses the file :file:"
"`hamlet.xml` using it::"
msgstr ""
"Например, этот небольшой пример программы определяет обработчик, который "
"печатает сообщение для каждого начального и конечного тега, а затем "
"анализирует файл :file:`hamlet.xml`, используя его::"

#: ../../whatsnew/2.0.rst:916
msgid ""
"from xml import sax\n"
"\n"
"class SimpleHandler(sax.ContentHandler):\n"
"    def startElement(self, name, attrs):\n"
"        print 'Start of element:', name, attrs.keys()\n"
"\n"
"    def endElement(self, name):\n"
"        print 'End of element:', name\n"
"\n"
"# Create a parser object\n"
"parser = sax.make_parser()\n"
"\n"
"# Tell it what handler to use\n"
"handler = SimpleHandler()\n"
"parser.setContentHandler( handler )\n"
"\n"
"# Parse a file!\n"
"parser.parse( 'hamlet.xml' )"
msgstr ""
"from xml import sax\n"
"\n"
"class SimpleHandler(sax.ContentHandler):\n"
"    def startElement(self, name, attrs):\n"
"        print 'Start of element:', name, attrs.keys()\n"
"\n"
"    def endElement(self, name):\n"
"        print 'End of element:', name\n"
"\n"
"# Create a parser object\n"
"parser = sax.make_parser()\n"
"\n"
"# Tell it what handler to use\n"
"handler = SimpleHandler()\n"
"parser.setContentHandler( handler )\n"
"\n"
"# Parse a file!\n"
"parser.parse( 'hamlet.xml' )"

#: ../../whatsnew/2.0.rst:935
msgid ""
"For more information, consult the Python documentation, or the XML HOWTO at "
"https://pyxml.sourceforge.net/topics/howto/xml-howto.html."
msgstr ""
"Для получения дополнительной информации обратитесь к документации Python или "
"XML HOWTO по адресу https://pyxml.sourceforge.net/topics/howto/xml-howto."
"html."

#: ../../whatsnew/2.0.rst:940
msgid "DOM Support"
msgstr "Поддержка DOM"

#: ../../whatsnew/2.0.rst:942
msgid ""
"The Document Object Model is a tree-based representation for an XML "
"document.  A top-level :class:`!Document` instance is the root of the tree, "
"and has a single child which is the top-level :class:`!Element` instance. "
"This :class:`!Element` has children nodes representing character data and "
"any sub-elements, which may have further children of their own, and so "
"forth.  Using the DOM you can traverse the resulting tree any way you like, "
"access element and attribute values, insert and delete nodes, and convert "
"the tree back into XML."
msgstr ""
"Объектная модель документа — это древовидное представление XML-документа. "
"Экземпляр :class:`!Document` верхнего уровня является корнем дерева и имеет "
"единственного дочернего элемента, который является экземпляром :class:`!"
"Element` верхнего уровня. Этот :class:`!Element` имеет дочерние узлы, "
"представляющие символьные данные и любые подэлементы, которые могут иметь "
"собственные дочерние элементы и т.д. Используя DOM, вы можете перемещаться "
"по результирующему дереву любым удобным для вас способом, получать доступ к "
"значениям элементов и атрибутов, вставлять и удалять узлы и преобразовывать "
"дерево обратно в XML."

#: ../../whatsnew/2.0.rst:950
msgid ""
"The DOM is useful for modifying XML documents, because you can create a DOM "
"tree, modify it by adding new nodes or rearranging subtrees, and then "
"produce a new XML document as output.  You can also construct a DOM tree "
"manually and convert it to XML, which can be a more flexible way of "
"producing XML output than simply writing ``<tag1>``...\\ ``</tag1>`` to a "
"file."
msgstr ""
"DOM полезен для изменения документов XML, поскольку вы можете создать дерево "
"DOM, изменить его, добавив новые узлы или переупорядочив поддеревья, а затем "
"создать на выходе новый документ XML. Вы также можете создать дерево DOM "
"вручную и преобразовать его в XML, что может быть более гибким способом "
"создания вывода XML, чем просто запись ``<tag1>``...\\ ``</tag1>`` в файл. ."

#: ../../whatsnew/2.0.rst:956
msgid ""
"The DOM implementation included with Python lives in the :mod:`xml.dom."
"minidom` module.  It's a lightweight implementation of the Level 1 DOM with "
"support for XML namespaces.  The  :func:`!parse` and :func:`!parseString` "
"convenience functions are provided for generating a DOM tree::"
msgstr ""
"Реализация DOM, включенная в Python, находится в модуле :mod:`xml.dom."
"minidom`. Это облегченная реализация DOM уровня 1 с поддержкой пространств "
"имен XML. Для создания дерева DOM предусмотрены удобные функции :func:`!"
"parse` и :func:`!parseString`:"

#: ../../whatsnew/2.0.rst:961
msgid ""
"from xml.dom import minidom\n"
"doc = minidom.parse('hamlet.xml')"
msgstr ""
"from xml.dom import minidom\n"
"doc = minidom.parse('hamlet.xml')"

#: ../../whatsnew/2.0.rst:964
msgid ""
"``doc`` is a :class:`!Document` instance.  :class:`!Document`, like all the "
"other DOM classes such as :class:`!Element` and :class:`Text`, is a subclass "
"of the :class:`!Node` base class.  All the nodes in a DOM tree therefore "
"support certain common methods, such as :meth:`!toxml` which returns a "
"string containing the XML representation of the node and its children.  Each "
"class also has special methods of its own; for example, :class:`!Element` "
"and :class:`!Document` instances have a method to find all child elements "
"with a given tag name. Continuing from the previous 2-line example::"
msgstr ""
"``doc`` — это экземпляр :class:`!Document`. :class:`!Document`, как и все "
"другие классы DOM, такие как :class:`!Element` и :class:`Text`, является "
"подклассом базового класса :class:`!Node`. Таким образом, все узлы в дереве "
"DOM поддерживают определенные общие методы, такие как :meth:`!toxml`, "
"который возвращает строку, содержащую XML-представление узла и его дочерних "
"элементов. Каждый класс также имеет свои собственные методы; например, "
"экземпляры :class:`!Element` и :class:`!Document` имеют метод для поиска "
"всех дочерних элементов с заданным именем тега. Продолжая предыдущий "
"двухстрочный пример:"

#: ../../whatsnew/2.0.rst:973
msgid ""
"perslist = doc.getElementsByTagName( 'PERSONA' )\n"
"print perslist[0].toxml()\n"
"print perslist[1].toxml()"
msgstr ""
"perslist = doc.getElementsByTagName( 'PERSONA' )\n"
"print perslist[0].toxml()\n"
"print perslist[1].toxml()"

#: ../../whatsnew/2.0.rst:977
msgid "For the *Hamlet* XML file, the above few lines output::"
msgstr "Для XML-файла *Hamlet* приведенные выше несколько строк выводят:"

#: ../../whatsnew/2.0.rst:979
msgid ""
"<PERSONA>CLAUDIUS, king of Denmark. </PERSONA>\n"
"<PERSONA>HAMLET, son to the late, and nephew to the present king.</PERSONA>"
msgstr ""
"<ПЕРСОНА>КЛАВДИЙ, король Дании. </ПЕРСОНА> <PERSONA>ГАМЛЕТ, сын покойного и "
"племянник нынешнего короля.</PERSONA>"

#: ../../whatsnew/2.0.rst:982
msgid ""
"The root element of the document is available as ``doc.documentElement``, "
"and its children can be easily modified by deleting, adding, or removing "
"nodes::"
msgstr ""
"Корневой элемент документа доступен как doc.documentElement, а его дочерние "
"элементы можно легко изменить, удалив, добавив или удалив узлы:"

#: ../../whatsnew/2.0.rst:985
msgid ""
"root = doc.documentElement\n"
"\n"
"# Remove the first child\n"
"root.removeChild( root.childNodes[0] )\n"
"\n"
"# Move the new first child to the end\n"
"root.appendChild( root.childNodes[0] )\n"
"\n"
"# Insert the new first child (originally,\n"
"# the third child) before the 20th child.\n"
"root.insertBefore( root.childNodes[0], root.childNodes[20] )"
msgstr ""
"root = doc.documentElement\n"
"\n"
"# Remove the first child\n"
"root.removeChild( root.childNodes[0] )\n"
"\n"
"# Move the new first child to the end\n"
"root.appendChild( root.childNodes[0] )\n"
"\n"
"# Insert the new first child (originally,\n"
"# the third child) before the 20th child.\n"
"root.insertBefore( root.childNodes[0], root.childNodes[20] )"

#: ../../whatsnew/2.0.rst:997
msgid ""
"Again, I will refer you to the Python documentation for a complete listing "
"of the different :class:`!Node` classes and their various methods."
msgstr ""
"Опять же, я отсылаю вас к документации Python для получения полного списка "
"различных классов :class:`!Node` и их различных методов."

#: ../../whatsnew/2.0.rst:1002
msgid "Relationship to PyXML"
msgstr "Отношение к PyXML"

#: ../../whatsnew/2.0.rst:1004
msgid ""
"The XML Special Interest Group has been working on XML-related Python code "
"for a while.  Its code distribution, called PyXML, is available from the "
"SIG's web pages at https://www.python.org/community/sigs/current/xml-sig. "
"The PyXML distribution also used the package name ``xml``.  If you've "
"written programs that used PyXML, you're probably wondering about its "
"compatibility with the 2.0 :mod:`xml` package."
msgstr ""
"Специальная группа по интересам XML уже некоторое время работает над кодом "
"Python, связанным с XML. Его дистрибутив кода, называемый PyXML, доступен на "
"веб-страницах SIG по адресу https://www.python.org/community/sigs/current/"
"xml-sig. В дистрибутиве PyXML также использовалось имя пакета «xml». Если вы "
"писали программы, использующие PyXML, вас, вероятно, интересует его "
"совместимость с пакетом :mod:`xml` 2.0."

#: ../../whatsnew/2.0.rst:1010
msgid ""
"The answer is that Python 2.0's :mod:`xml` package isn't compatible with "
"PyXML, but can be made compatible by installing a recent version PyXML.  "
"Many applications can get by with the XML support that is included with "
"Python 2.0, but more complicated applications will require that the full "
"PyXML package will be installed.  When installed, PyXML versions 0.6.0 or "
"greater will replace the :mod:`xml` package shipped with Python, and will be "
"a strict superset of the standard package, adding a bunch of additional "
"features.  Some of the additional features in PyXML include:"
msgstr ""
"Ответ заключается в том, что пакет :mod:`xml` Python 2.0 несовместим с "
"PyXML, но его можно сделать совместимым, установив последнюю версию PyXML. "
"Многие приложения могут обойтись поддержкой XML, включенной в Python 2.0, но "
"более сложные приложения потребуют установки полного пакета PyXML. После "
"установки PyXML версии 0.6.0 или выше заменит пакет :mod:`xml`, поставляемый "
"с Python, и станет строгой надстройкой стандартного пакета, добавляя "
"множество дополнительных функций. Некоторые из дополнительных функций PyXML "
"включают:"

#: ../../whatsnew/2.0.rst:1019
msgid "4DOM, a full DOM implementation from FourThought, Inc."
msgstr "4DOM, полная реализация DOM от FourThought, Inc."

#: ../../whatsnew/2.0.rst:1021
msgid "The xmlproc validating parser, written by Lars Marius Garshol."
msgstr "Парсер, проверяющий xmlproc, написанный Ларсом Мариусом Гаршолом."

#: ../../whatsnew/2.0.rst:1023
msgid "The :mod:`!sgmlop` parser accelerator module, written by Fredrik Lundh."
msgstr "Модуль ускорения парсера :mod:`!sgmlop`, написанный Фредриком Лундом."

#: ../../whatsnew/2.0.rst:1029
msgid "Module changes"
msgstr "Изменения в модуле"

#: ../../whatsnew/2.0.rst:1031
msgid ""
"Lots of improvements and bugfixes were made to Python's extensive standard "
"library; some of the affected modules include :mod:`readline`, :mod:"
"`ConfigParser <configparser>`, :mod:`cgi`, :mod:`calendar`, :mod:`posix`, :"
"mod:`readline`, :mod:`!xmllib`, :mod:`aifc`, :mod:`chunk` :mod:`wave`, :mod:"
"`random`, :mod:`shelve`, and :mod:`nntplib`.  Consult the CVS logs for the "
"exact patch-by-patch details."
msgstr ""
"В обширную стандартную библиотеку Python было внесено множество улучшений и "
"исправлений; некоторые из затронутых модулей включают :mod:`readline`, :mod:"
"`ConfigParser <configparser>`, :mod:`cgi`, :mod:`calendar`, :mod:`posix`, :"
"mod:`readline` , :mod:`!xmllib`, :mod:`aifc`, :mod:`chunk` :mod:`wave`, :mod:"
"`random`, :mod:`shelve` и :mod:`nntplib` . Обратитесь к журналам CVS для "
"получения точных деталей каждого патча."

#: ../../whatsnew/2.0.rst:1037
msgid ""
"Brian Gallew contributed OpenSSL support for the :mod:`socket` module.  "
"OpenSSL is an implementation of the Secure Socket Layer, which encrypts the "
"data being sent over a socket.  When compiling Python, you can edit :file:"
"`Modules/Setup` to include SSL support, which adds an additional function to "
"the :mod:`socket` module: ``socket.ssl(socket, keyfile, certfile)``, which "
"takes a socket object and returns an SSL socket.  The :mod:`httplib <http>` "
"and :mod:`urllib` modules were also changed to support ``https://`` URLs, "
"though no one has implemented FTP or SMTP over SSL."
msgstr ""
"Брайан Гэллью предоставил поддержку OpenSSL для модуля :mod:`socket`. "
"OpenSSL — это реализация Secure Socket Layer, которая шифрует данные, "
"отправляемые через сокет. При компиляции Python вы можете отредактировать :"
"file:`Modules/Setup`, чтобы включить поддержку SSL, что добавляет "
"дополнительную функцию к модулю :mod:`socket`: ``socket.ssl(socket, keyfile, "
"certfile)``, который принимает объект сокета и возвращает сокет SSL. Модули :"
"mod:`httplib <http>` и :mod:`urllib` также были изменены для поддержки URL-"
"адресов ``https://``, хотя никто не реализовал FTP или SMTP через SSL."

#: ../../whatsnew/2.0.rst:1046
msgid ""
"The :mod:`httplib <http>` module has been rewritten by Greg Stein to support "
"HTTP/1.1."
msgstr ""
"Модуль :mod:`httplib <http>` был переписан Грегом Стейном для поддержки "
"HTTP/1.1."

#: ../../whatsnew/2.0.rst:1048
msgid ""
"Backward compatibility with the 1.5 version of :mod:`!httplib` is provided, "
"though using HTTP/1.1 features such as pipelining will require rewriting "
"code to use a different set of interfaces."
msgstr ""
"Обеспечена обратная совместимость с версией :mod:`!httplib` 1.5, однако "
"использование функций HTTP/1.1, таких как конвейерная обработка, потребует "
"переписывания кода для использования другого набора интерфейсов."

#: ../../whatsnew/2.0.rst:1052
msgid ""
"The :mod:`!Tkinter` module now supports Tcl/Tk version 8.1, 8.2, or 8.3, and "
"support for the older 7.x versions has been dropped.  The Tkinter module now "
"supports displaying Unicode strings in Tk widgets. Also, Fredrik Lundh "
"contributed an optimization which makes operations like ``create_line`` and "
"``create_polygon`` much faster, especially when using lots of coordinates."
msgstr ""
"Модуль :mod:`!Tkinter` теперь поддерживает Tcl/Tk версии 8.1, 8.2 или 8.3, а "
"поддержка более старых версий 7.x прекращена. Модуль Tkinter теперь "
"поддерживает отображение строк Unicode в виджетах Tk. Кроме того, Фредрик "
"Лунд внес оптимизацию, которая делает такие операции, как create_line и "
"create_polygon, намного быстрее, особенно при использовании большого "
"количества координат."

#: ../../whatsnew/2.0.rst:1058
msgid ""
"The :mod:`curses` module has been greatly extended, starting from Oliver "
"Andrich's enhanced version, to provide many additional functions from "
"ncurses and SYSV curses, such as colour, alternative character set support, "
"pads, and mouse support.  This means the module is no longer compatible with "
"operating systems that only have BSD curses, but there don't seem to be any "
"currently maintained OSes that fall into this category."
msgstr ""
"Модуль :mod:`curses` был значительно расширен, начиная с расширенной версии "
"Оливера Андрича, и теперь он предоставляет множество дополнительных функций "
"из ncurses и SYSV Curses, таких как цвет, поддержка альтернативного набора "
"символов, клавиатура и поддержка мыши. Это означает, что модуль больше не "
"совместим с операционными системами, в которых есть только проклятия BSD, "
"но, похоже, в настоящее время не существует ни одной поддерживаемой ОС, "
"подпадающей под эту категорию."

#: ../../whatsnew/2.0.rst:1065
msgid ""
"As mentioned in the earlier discussion of 2.0's Unicode support, the "
"underlying implementation of the regular expressions provided by the :mod:"
"`re` module has been changed.  SRE, a new regular expression engine written "
"by Fredrik Lundh and partially funded by Hewlett Packard, supports matching "
"against both 8-bit strings and Unicode strings."
msgstr ""
"Как упоминалось ранее при обсуждении поддержки Unicode в версии 2.0, базовая "
"реализация регулярных выражений, предоставляемых модулем :mod:`re`, была "
"изменена. SRE, новый механизм регулярных выражений, написанный Фредриком "
"Лундом и частично финансируемый Hewlett Packard, поддерживает сопоставление "
"как с 8-битными строками, так и со строками Unicode."

#: ../../whatsnew/2.0.rst:1075
msgid "New modules"
msgstr "Новые модули"

#: ../../whatsnew/2.0.rst:1077
msgid ""
"A number of new modules were added.  We'll simply list them with brief "
"descriptions; consult the 2.0 documentation for the details of a particular "
"module."
msgstr ""
"Добавлен ряд новых модулей. Мы просто перечислим их с краткими описаниями; "
"обратитесь к документации 2.0 для получения подробной информации о "
"конкретном модуле."

#: ../../whatsnew/2.0.rst:1081
msgid ""
":mod:`atexit`:  For registering functions to be called before the Python "
"interpreter exits. Code that currently sets ``sys.exitfunc`` directly should "
"be changed to  use the :mod:`atexit` module instead, importing :mod:`atexit` "
"and calling :func:`atexit.register` with  the function to be called on exit. "
"(Contributed by Skip Montanaro.)"
msgstr ""
":mod:`atexit`: Для регистрации функций, которые будут вызываться перед "
"выходом интерпретатора Python. Код, который в настоящее время устанавливает "
"``sys.exitfunc`` напрямую, должен быть изменен, чтобы вместо этого "
"использовать модуль :mod:`atexit`, импортируя :mod:`atexit` и вызывая :func:"
"`atexit.register` с вызываемой функцией. на выходе. (Предоставлено Скипом "
"Монтанаро.)"

#: ../../whatsnew/2.0.rst:1087
msgid ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`:  Added as part of the "
"new Unicode support."
msgstr ""
":mod:`codecs`, :mod:`!encodings`, :mod:`unicodedata`: Добавлено как часть "
"новой поддержки Unicode."

#: ../../whatsnew/2.0.rst:1090
msgid ""
":mod:`filecmp`: Supersedes the old :mod:`!cmp`, :mod:`!cmpcache` and :mod:`!"
"dircmp` modules, which have now become deprecated. (Contributed by Gordon "
"MacMillan and Moshe Zadka.)"
msgstr ""
":mod:`filecmp`: Заменяет старые модули :mod:`!cmp`, :mod:`!cmpcache` и :mod:"
"`!dircmp`, которые теперь устарели. (Сообщили Гордон Макмиллан и Моше Задка.)"

#: ../../whatsnew/2.0.rst:1094
msgid ""
":mod:`gettext`: This module provides internationalization (I18N) and "
"localization (L10N) support for Python programs by providing an interface to "
"the GNU gettext message catalog library. (Integrated by Barry Warsaw, from "
"separate contributions by Martin  von Löwis, Peter Funk, and James "
"Henstridge.)"
msgstr ""
":mod:`gettext`: Этот модуль обеспечивает поддержку интернационализации "
"(I18N) и локализации (L10N) для программ Python, предоставляя интерфейс к "
"библиотеке каталога сообщений GNU gettext. (Объединено Барри Варшавой на "
"основе отдельных материалов Мартина фон Лёвиса, Питера Фанка и Джеймса "
"Хенстриджа.)"

#: ../../whatsnew/2.0.rst:1099
msgid ""
":mod:`!linuxaudiodev`: Support for the :file:`/dev/audio` device on Linux, a "
"twin to the existing :mod:`!sunaudiodev` module. (Contributed by Peter "
"Bosch, with fixes by Jeremy Hylton.)"
msgstr ""
":mod:`!linuxaudiodev`: Поддержка устройства :file:`/dev/audio` в Linux, "
"двойника существующего модуля :mod:`!sunaudiodev`. (Представлено Питером "
"Бошем, исправления Джереми Хилтона.)"

#: ../../whatsnew/2.0.rst:1103
msgid ""
":mod:`mmap`: An interface to memory-mapped files on both Windows and Unix.  "
"A file's contents can be mapped directly into memory, at which point it "
"behaves like a mutable string, so its contents can be read and modified.  "
"They can even be passed to functions that expect ordinary strings, such as "
"the :mod:`re` module. (Contributed by Sam Rushing, with some extensions by A."
"M. Kuchling.)"
msgstr ""
":mod:`mmap`: Интерфейс для отображенных в памяти файлов как в Windows, так и "
"в Unix. Содержимое файла может быть отображено непосредственно в память, "
"после чего оно будет вести себя как изменяемая строка, поэтому его "
"содержимое можно будет читать и изменять. Их можно даже передавать функциям, "
"ожидающим обычные строки, например модулю :mod:`re`. (Предоставлено Сэмом "
"Рашингом, с некоторыми дополнениями А. М. Кучлингом.)"

#: ../../whatsnew/2.0.rst:1109
msgid ""
":mod:`!pyexpat`: An interface to the Expat XML parser. (Contributed by Paul "
"Prescod.)"
msgstr ""
":mod:`!pyexpat`: Интерфейс для парсера Expat XML. (Предоставлено Полом "
"Прескодом.)"

#: ../../whatsnew/2.0.rst:1112
msgid ""
":mod:`robotparser <urllib.robotparser>`: Parse a :file:`robots.txt` file, "
"which is used for writing web spiders that politely avoid certain areas of a "
"web site.  The parser accepts the contents of a :file:`robots.txt` file, "
"builds a set of rules from it, and can then answer questions about the "
"fetchability of a given URL.  (Contributed by Skip Montanaro.)"
msgstr ""
":mod:`robotparser <urllib.robotparser>`: анализирует файл :file:`robots."
"txt`, который используется для написания веб-пауков, которые вежливо "
"избегают определенных областей веб-сайта. Анализатор принимает содержимое "
"файла :file:`robots.txt`, строит из него набор правил и затем может отвечать "
"на вопросы о возможности выборки данного URL-адреса. (Предоставлено Скипом "
"Монтанаро.)"

#: ../../whatsnew/2.0.rst:1118
msgid ""
":mod:`tabnanny`: A module/script to  check Python source code for ambiguous "
"indentation. (Contributed by Tim Peters.)"
msgstr ""
":mod:`tabnanny`: Модуль/скрипт для проверки исходного кода Python на наличие "
"неоднозначных отступов. (Предоставлено Тимом Питерсом.)"

#: ../../whatsnew/2.0.rst:1121
msgid ""
":mod:`!UserString`: A base class useful for deriving objects that behave "
"like strings."
msgstr ""
":mod:`!UserString`: Базовый класс, полезный для создания объектов, которые "
"ведут себя как строки."

#: ../../whatsnew/2.0.rst:1124
msgid ""
":mod:`webbrowser`: A module that provides a platform independent way to "
"launch a web browser on a specific URL. For each platform, various browsers "
"are tried in a specific order. The user can alter which browser is launched "
"by setting the *BROWSER* environment variable.  (Originally inspired by Eric "
"S. Raymond's patch to :mod:`urllib` which added similar functionality, but "
"the final module comes from code originally  implemented by Fred Drake as :"
"file:`Tools/idle/BrowserControl.py`, and adapted for the standard library by "
"Fred.)"
msgstr ""
":mod:`webbrowser`: Модуль, который обеспечивает независимый от платформы "
"способ запуска веб-браузера по определенному URL-адресу. Для каждой "
"платформы в определенном порядке опробуются различные браузеры. Пользователь "
"может изменить, какой браузер запускается, установив переменную среды "
"*BROWSER*. (Первоначально вдохновлен патчем Эрика С. Рэймонда для :mod:"
"`urllib`, который добавил аналогичную функциональность, но окончательный "
"модуль основан на коде, первоначально реализованном Фредом Дрейком как :file:"
"`Tools/idle/BrowserControl.py` и адаптированном для стандартная библиотека "
"Фреда.)"

#: ../../whatsnew/2.0.rst:1133
msgid ""
":mod:`_winreg <winreg>`: An interface to the Windows registry.  :mod:`!"
"_winreg` is an adaptation of functions that have been part of PythonWin "
"since 1995, but has now been added to the core  distribution, and enhanced "
"to support Unicode. :mod:`!_winreg` was written by Bill Tutt and Mark "
"Hammond."
msgstr ""
":mod:`_winreg <winreg>`: интерфейс к реестру Windows. :mod:`!_winreg` — это "
"адаптация функций, которые были частью PythonWin с 1995 года, но теперь "
"добавлены в основной дистрибутив и улучшены для поддержки Unicode. :mod:`!"
"_winreg` был написан Биллом Таттом и Марком Хаммондом."

#: ../../whatsnew/2.0.rst:1138
msgid ""
":mod:`zipfile`: A module for reading and writing ZIP-format archives.  These "
"are archives produced by :program:`PKZIP` on DOS/Windows or :program:`zip` "
"on Unix, not to be confused with :program:`gzip`\\ -format files (which are "
"supported by the :mod:`gzip` module) (Contributed by James C. Ahlstrom.)"
msgstr ""
":mod:`zipfile`: Модуль для чтения и записи архивов формата ZIP. Это архивы, "
"созданные :program:`PKZIP` в DOS/Windows или :program:`zip` в Unix, не "
"путать с файлами формата :program:`gzip`\\ (которые поддерживаются :mod:` "
"gzip`) (предоставлен Джеймсом К. Альстромом.)"

#: ../../whatsnew/2.0.rst:1143
msgid ""
":mod:`!imputil`: A module that provides a simpler way for writing customized "
"import hooks, in comparison to the existing :mod:`!ihooks` module.  "
"(Implemented by Greg Stein, with much discussion on python-dev along the "
"way.)"
msgstr ""
":mod:`!imputil`: Модуль, который обеспечивает более простой способ написания "
"настраиваемых перехватчиков импорта по сравнению с существующим модулем :mod:"
"`!ihooks`. (Реализован Грегом Стейном, попутно много обсуждая python-dev.)"

#: ../../whatsnew/2.0.rst:1151
msgid "IDLE Improvements"
msgstr "Улучшения IDLE"

#: ../../whatsnew/2.0.rst:1153
msgid ""
"IDLE is the official Python cross-platform IDE, written using Tkinter. "
"Python 2.0 includes IDLE 0.6, which adds a number of new features and "
"improvements.  A partial list:"
msgstr ""
"IDLE — официальная кроссплатформенная среда разработки Python, написанная с "
"использованием Tkinter. Python 2.0 включает в себя IDLE 0.6, в котором "
"добавлен ряд новых функций и улучшений. Неполный список:"

#: ../../whatsnew/2.0.rst:1157
msgid ""
"UI improvements and optimizations, especially in the area of syntax "
"highlighting and auto-indentation."
msgstr ""
"Улучшения и оптимизация пользовательского интерфейса, особенно в области "
"подсветки синтаксиса и автоматического отступа."

#: ../../whatsnew/2.0.rst:1160
msgid ""
"The class browser now shows more information, such as the top level "
"functions in a module."
msgstr ""
"Браузер классов теперь отображает больше информации, например функции "
"верхнего уровня в модуле."

#: ../../whatsnew/2.0.rst:1163
msgid ""
"Tab width is now a user settable option. When opening an existing Python "
"file, IDLE automatically detects the indentation conventions, and adapts."
msgstr ""
"Ширина табуляции теперь является настраиваемой пользователем опцией. При "
"открытии существующего файла Python IDLE автоматически определяет правила "
"отступов и адаптируется."

#: ../../whatsnew/2.0.rst:1166
msgid ""
"There is now support for calling browsers on various platforms, used to open "
"the Python documentation in a browser."
msgstr ""
"Теперь поддерживается вызов браузеров на различных платформах, используемый "
"для открытия документации Python в браузере."

#: ../../whatsnew/2.0.rst:1169
msgid ""
"IDLE now has a command line, which is largely similar to  the vanilla Python "
"interpreter."
msgstr ""
"В IDLE теперь есть командная строка, которая во многом похожа на стандартный "
"интерпретатор Python."

#: ../../whatsnew/2.0.rst:1172
msgid "Call tips were added in many places."
msgstr "Подсказки по звонкам были добавлены во многих местах."

#: ../../whatsnew/2.0.rst:1174
msgid "IDLE can now be installed as a package."
msgstr "IDLE теперь можно установить как пакет."

#: ../../whatsnew/2.0.rst:1176
msgid "In the editor window, there is now a line/column bar at the bottom."
msgstr "В окне редактора теперь внизу есть строка/столбец."

#: ../../whatsnew/2.0.rst:1178
msgid ""
"Three new keystroke commands: Check module (:kbd:`Alt-F5`), Import module (:"
"kbd:`F5`) and Run script (:kbd:`Ctrl-F5`)."
msgstr ""
"Три новые команды нажатия клавиш: Проверить модуль (:kbd:`Alt-F5`), "
"Импортировать модуль (:kbd:`F5`) и Запустить скрипт (:kbd:`Ctrl-F5`)."

#: ../../whatsnew/2.0.rst:1185
msgid "Deleted and Deprecated Modules"
msgstr "Удаленные и устаревшие модули"

#: ../../whatsnew/2.0.rst:1187
msgid ""
"A few modules have been dropped because they're obsolete, or because there "
"are now better ways to do the same thing.  The :mod:`!stdwin` module is "
"gone; it was for a platform-independent windowing toolkit that's no longer "
"developed."
msgstr ""
"Несколько модулей были исключены, потому что они устарели или потому, что "
"теперь есть лучшие способы сделать то же самое. Модуль :mod:`!stdwin` исчез; "
"это был независимый от платформы набор оконных инструментов, который больше "
"не разрабатывается."

#: ../../whatsnew/2.0.rst:1191
msgid ""
"A number of modules have been moved to the :file:`lib-old` subdirectory: :"
"mod:`!cmp`, :mod:`!cmpcache`, :mod:`!dircmp`, :mod:`!dump`,  :mod:`!find`, :"
"mod:`!grep`, :mod:`!packmail`,  :mod:`!poly`, :mod:`!util`, :mod:`!"
"whatsound`, :mod:`!zmod`.  If you have code which relies on a module  that's "
"been moved to :file:`lib-old`, you can simply add that directory to ``sys."
"path``   to get them back, but you're encouraged to update any code that "
"uses these modules."
msgstr ""
"Ряд модулей были перенесены в подкаталог :file:`lib-old`: :mod:`!cmp`, :mod:"
"`!cmpcache`, :mod:`!dircmp`, :mod:`!dump` , :mod:`!find`, :mod:`!grep`, :mod:"
"`!packmail`, :mod:`!poly`, :mod:`!util`, :mod:`!whatsound`, : мод:`!zmod`. "
"Если у вас есть код, основанный на модуле, который был перемещен в :file:"
"`lib-old`, вы можете просто добавить этот каталог в ``sys.path``, чтобы "
"вернуть их, но вам рекомендуется обновить любой код. который использует эти "
"модули."

#: ../../whatsnew/2.0.rst:1200
msgid "Acknowledgements"
msgstr "Подтверждение"

#: ../../whatsnew/2.0.rst:1202
msgid ""
"The authors would like to thank the following people for offering "
"suggestions on various drafts of this article: David Bolen, Mark Hammond, "
"Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, "
"Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil "
"Schemenauer, and Russ Schmidt."
msgstr ""
"Авторы хотели бы поблагодарить следующих людей за предложения по различным "
"вариантам этой статьи: Дэвида Болена, Марка Хаммонда, Грегга Хаузера, "
"Джереми Хилтона, Фредрика Лунда, Детлефа Ланнерта, Ааза Маруха, Скип "
"Монтанаро, Владимира Марангозова, Тобиаса Ползина, Гвидо. ван Россум, Нил "
"Шеменауэр и Расс Шмидт."
