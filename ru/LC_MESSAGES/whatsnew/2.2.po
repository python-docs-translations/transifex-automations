# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 15:28+0000\n"
"PO-Revision-Date: 2023-05-24 02:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../whatsnew/2.2.rst:3
msgid "What's New in Python 2.2"
msgstr "Что нового в Python 2.2"

#: ../../whatsnew/2.2.rst:0
msgid "Author"
msgstr "Автор"

#: ../../whatsnew/2.2.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.2.rst:13
msgid "Introduction"
msgstr "Введение"

#: ../../whatsnew/2.2.rst:15
msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"В этой статье описываются новые функции Python 2.2.2, выпущенного 14 октября "
"2002 г. Python 2.2.2 — это версия Python 2.2 с исправлением ошибок, "
"первоначально выпущенная 21 декабря 2001 г."

#: ../../whatsnew/2.2.rst:19
msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"Python 2.2 можно рассматривать как «очистку». Некоторые функции, такие как "
"генераторы и итераторы, являются совершенно новыми, но большинство "
"изменений, какими бы значительными и далеко идущими они ни были, направлены "
"на устранение неровностей и темных уголков конструкции языка."

#: ../../whatsnew/2.2.rst:24
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"В этой статье не делается попытка предоставить полную спецификацию новых "
"функций, а вместо этого представлен удобный обзор. Для получения полной "
"информации обратитесь к документации по Python 2.2, например, «Справочник по "
"библиотеке Python <https://docs.python.org/2.2/lib/lib.html>» и «Справочное "
"руководство по Python <https». ://docs.python.org/2.2/ref/ref.html>`_. Если "
"вы хотите понять полную реализацию и обоснование изменения, обратитесь к PEP "
"за конкретной новой функцией."

#: ../../whatsnew/2.2.rst:43
msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "Политические деятели 252 и 253: изменения типа и класса"

#: ../../whatsnew/2.2.rst:45
msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so "
"it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"Самые большие и далеко идущие изменения в Python 2.2 касаются модели "
"объектов и классов Python. Изменения должны быть обратно совместимыми, "
"поэтому вполне вероятно, что ваш код продолжит работать без изменений, но "
"эти изменения открывают некоторые удивительные новые возможности. Прежде чем "
"приступить к самому длинному и сложному разделу этой статьи, я представлю "
"обзор изменений и дам несколько комментариев."

#: ../../whatsnew/2.2.rst:52
msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of "
"the most significant flaws was that it's impossible to subclass Python types "
"implemented in C.  In particular, it's not possible to subclass built-in "
"types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`!UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but "
"there's lots of C code that expects a regular Python list and won't accept "
"a :class:`~collections.UserList` instance."
msgstr ""
"Давным-давно я написал веб-страницу со списком недостатков дизайна Python. "
"Одним из наиболее существенных недостатков было то, что невозможно создать "
"подклассы типов Python, реализованных в C. В частности, невозможно создать "
"подклассы для встроенных типов, поэтому вы не можете просто "
"подклассифицировать, скажем, списки, чтобы добавить один полезный метод. им. "
"Модуль :mod:`!UserList` предоставляет класс, который поддерживает все методы "
"списков и может быть подклассифицирован далее, но существует много кода C, "
"который ожидает обычный список Python и не принимает :class:`~ экземпляр "
"коллекции.UserList`."

#: ../../whatsnew/2.2.rst:61
msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr ""
"Python 2.2 исправляет это и попутно добавляет несколько интересных новых "
"возможностей. Краткое содержание:"

#: ../../whatsnew/2.2.rst:64
msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr ""
"Вы можете подклассифицировать встроенные типы, такие как списки и даже целые "
"числа, и ваши подклассы должны работать везде, где требуется исходный тип."

#: ../../whatsnew/2.2.rst:67
msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr ""
"Теперь можно определять статические методы и методы класса в дополнение к "
"методам экземпляра, доступным в предыдущих версиях Python."

#: ../../whatsnew/2.2.rst:70
msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`~object.__getattr__` can be rewritten to use properties "
"instead, making the resulting code simpler and faster.  As a small side "
"benefit, attributes can now have docstrings, too."
msgstr ""
"Также возможно автоматически вызывать методы при доступе или установке "
"атрибута экземпляра, используя новый механизм под названием :dfn:"
"`properties`. Многие варианты использования :meth:`~object.__getattr__` "
"можно переписать, чтобы вместо этого использовать свойства, что делает "
"результирующий код проще и быстрее. В качестве небольшого дополнительного "
"преимущества теперь атрибуты также могут иметь строки документации."

#: ../../whatsnew/2.2.rst:76
msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr ""
"Список допустимых атрибутов для экземпляра может быть ограничен определенным "
"набором с помощью :dfn:`slots`, что позволяет защититься от опечаток и, "
"возможно, сделать возможным дополнительную оптимизацию в будущих версиях "
"Python."

#: ../../whatsnew/2.2.rst:80
msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the "
"new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being "
"lost."
msgstr ""
"Некоторые пользователи выразили обеспокоенность по поводу всех этих "
"изменений. Конечно, говорят они, новые функции удобны и позволяют "
"использовать всевозможные трюки, которые были невозможны в предыдущих "
"версиях Python, но они также усложняют язык. Некоторые люди говорят, что они "
"всегда рекомендовали Python из-за его простоты, и чувствуют, что его "
"простота теряется."

#: ../../whatsnew/2.2.rst:86
msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"Лично я считаю, что беспокоиться не стоит. Многие из новых функций довольно "
"эзотеричны, и вы можете написать много кода Python, даже не зная о них. "
"Написать простой класс не сложнее, чем когда-либо, поэтому вам не нужно "
"беспокоиться об их изучении или преподавании, если они действительно не "
"нужны. Некоторые очень сложные задачи, которые раньше были возможны только "
"на C, теперь будут возможны на чистом Python, и, на мой взгляд, это все к "
"лучшему."

#: ../../whatsnew/2.2.rst:93
msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will "
"paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"Я не собираюсь описывать каждый отдельный случай и небольшие изменения, "
"необходимые для работы новых функций. Вместо этого в этом разделе будут "
"описаны только общие мазки. Дополнительные источники информации о новой "
"объектной модели Python 2.2 см. в разделе :ref:`sect-rellinks`, «Ссылки по "
"теме»."

#: ../../whatsnew/2.2.rst:100
msgid "Old and New Classes"
msgstr "Старые и новые классы"

#: ../../whatsnew/2.2.rst:102
msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python.  "
"All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"Во-первых, вы должны знать, что в Python 2.2 действительно есть два типа "
"классов: классические классы, или классы старого стиля, и классы нового "
"стиля. Модель классов старого стиля точно такая же, как модель классов в "
"более ранних версиях Python. Все новые возможности, описанные в этом "
"разделе, применимы только к классам нового стиля. Это расхождение не должно "
"длиться вечно; со временем классы старого стиля будут удалены, возможно, в "
"Python 3.0."

#: ../../whatsnew/2.2.rst:109
msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A "
"new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"Так как же определить класс нового стиля? Вы делаете это путем создания "
"подкласса существующего класса нового стиля. Большинство встроенных типов "
"Python, таких как целые числа, списки, словари и даже файлы, теперь являются "
"классами нового стиля. Также был добавлен класс нового стиля с именем :class:"
"`object`, базовый класс для всех встроенных типов, поэтому, если ни один "
"встроенный тип не подходит, вы можете просто создать подкласс :class:"
"`object`::"

#: ../../whatsnew/2.2.rst:121
msgid ""
"This means that :keyword:`class` statements that don't have any base classes "
"are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`!__metaclass__` --- "
"see :pep:`253` for the details --- but it's easier to just subclass :class:"
"`object`.)"
msgstr ""
"Это означает, что операторы :keyword:`class`, не имеющие базовых классов, "
"всегда являются классическими классами Python 2.2. (На самом деле вы также "
"можете изменить это, установив переменную уровня модуля с именем :attr:`!"
"__metaclass__` --- подробности см. в :pep:`253` --- но проще создать "
"подкласс :class:`object` .)"

#: ../../whatsnew/2.2.rst:126
msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named :func:"
"`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions any "
"more, but type objects that behave as factories when called. ::"
msgstr ""
"Объекты типов для встроенных типов доступны как встроенные, им присвоены "
"хитрые имена. В Python всегда были встроенные функции с именами :func:"
"`int`, :func:`float` и :func:`str`. В версии 2.2 они больше не являются "
"функциями, а являются объектами типов, которые при вызове ведут себя как "
"фабрики. ::"

#: ../../whatsnew/2.2.rst:136
msgid ""
"To make the set of types complete, new type objects such as :func:`dict` "
"and :func:`!file` have been added.  Here's a more interesting example, "
"adding a :meth:`!lock` method to file objects::"
msgstr ""
"Чтобы сделать набор типов полным, были добавлены новые объекты типов, такие "
"как :func:`dict` и :func:`!file`. Вот более интересный пример добавления "
"метода :meth:`!lock` к файловым объектам::"

#: ../../whatsnew/2.2.rst:146
msgid ""
"The now-obsolete :mod:`!posixfile` module contained a class that emulated "
"all of a file object's methods and also added a :meth:`!lock` method, but "
"this class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`!LockableFile`."
msgstr ""
"Устаревший модуль :mod:`!posixfile` содержал класс, который эмулировал все "
"методы файлового объекта, а также добавлял метод :meth:`!lock`, но этот "
"класс нельзя было передать внутренним функциям, которые ожидали встроенный "
"файл, что возможно с нашим новым :class:`!LockableFile`."

#: ../../whatsnew/2.2.rst:153
msgid "Descriptors"
msgstr "Дескрипторы"

#: ../../whatsnew/2.2.rst:155
msgid ""
"In previous versions of Python, there was no consistent way to discover what "
"attributes and methods were supported by an object. There were some informal "
"conventions, such as defining :attr:`!__members__` and :attr:`!__methods__` "
"attributes that were lists of names, but often the author of an extension "
"type or a class wouldn't bother to define them.  You could fall back on "
"inspecting the :attr:`~object.__dict__` of an object, but when class "
"inheritance or an arbitrary :meth:`!__getattr__` hook were in use this could "
"still be inaccurate."
msgstr ""
"В предыдущих версиях Python не было единого способа узнать, какие атрибуты и "
"методы поддерживаются объектом. Существовали некоторые неофициальные "
"соглашения, такие как определение атрибутов :attr:`!__members__` и :attr:`!"
"__methods__`, которые представляли собой списки имен, но часто автор типа "
"расширения или класса не утруждал себя их определением. Вы могли бы "
"вернуться к проверке :attr:`~object.__dict__` объекта, но когда "
"использовалось наследование класса или произвольный :meth:`!__getattr__`, "
"это все равно могло быть неточным."

#: ../../whatsnew/2.2.rst:163
msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class "
"methods become possible, as well as more exotic constructs."
msgstr ""
"Основная идея, лежащая в основе новой модели классов, заключается в том, что "
"был формализован API для описания атрибутов объекта с помощью :dfn:"
"`дескрипторов`. Дескрипторы определяют значение атрибута, указывая, является "
"ли это методом или полем. Благодаря дескрипторному API становятся возможными "
"статические методы и методы классов, а также более экзотические конструкции."

#: ../../whatsnew/2.2.rst:169
msgid ""
"Attribute descriptors are objects that live inside class objects, and have a "
"few attributes of their own:"
msgstr ""
"Дескрипторы атрибутов — это объекты, которые живут внутри объектов классов и "
"имеют несколько собственных атрибутов:"

#: ../../whatsnew/2.2.rst:172
msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` — имя атрибута."

#: ../../whatsnew/2.2.rst:174
msgid ":attr:`!__doc__` is the attribute's docstring."
msgstr ""

#: ../../whatsnew/2.2.rst:176
msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr ""
"``__get__(object)`` — это метод, который извлекает значение атрибута из "
"*object*."

#: ../../whatsnew/2.2.rst:179
msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr "``__set__(object, value)`` устанавливает атрибут *object* в *value*."

#: ../../whatsnew/2.2.rst:181
msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr ""
"``__delete__(object, value)`` удаляет атрибут *value* объекта *object*."

#: ../../whatsnew/2.2.rst:183
msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr ""
"Например, когда вы пишете ``obj.x``, Python фактически выполняет следующие "
"шаги:"

#: ../../whatsnew/2.2.rst:189
msgid ""
"For methods, :meth:`!descriptor.__get__` returns a temporary object that's "
"callable, and wraps up the instance and the method to be called on it. This "
"is also why static methods and class methods are now possible; they have "
"descriptors that wrap up just the method, or the method and the class.  As a "
"brief explanation of these new kinds of methods, static methods aren't "
"passed the instance, and therefore resemble regular functions.  Class "
"methods are passed the class of the object, but not the object itself.  "
"Static and class methods are defined like this::"
msgstr ""

#: ../../whatsnew/2.2.rst:207
msgid ""
"The :func:`staticmethod` function takes the function :func:`!f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
"Функция :func:`staticmethod` принимает функцию :func:`!f` и возвращает ее в "
"дескрипторе, чтобы ее можно было сохранить в объекте класса. Вы могли бы "
"ожидать, что для создания таких методов будет специальный синтаксис («def "
"static f», «defstatic f()» или что-то в этом роде), но такой синтаксис еще "
"не определен; это оставлено для будущих версий Python."

#: ../../whatsnew/2.2.rst:213
msgid ""
"More new features, such as slots and properties, are also implemented as new "
"kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"Более новые функции, такие как слоты и свойства, также реализованы как новые "
"виды дескрипторов, и нетрудно написать класс дескриптора, который делает что-"
"то новое. Например, можно было бы написать класс дескриптора, который "
"позволял бы писать предварительные и постусловия в стиле Эйфеля для метода. "
"Класс, использующий эту функцию, может быть определен следующим образом:"

#: ../../whatsnew/2.2.rst:235
msgid ""
"Note that a person using the new :func:`!eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features "
"don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`!eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"Обратите внимание, что человеку, использующему новый :func:`!eiffelmethod`, "
"не обязательно ничего понимать в дескрипторах. Вот почему я думаю, что новые "
"возможности не увеличивают базовую сложность языка. Будет несколько "
"мастеров, которым необходимо знать об этом, чтобы написать :func:`!"
"eiffelmethod`, ZODB или что-то еще, но большинство пользователей просто "
"напишут код поверх полученных библиотек и проигнорируют детали реализации."

#: ../../whatsnew/2.2.rst:244
msgid "Multiple Inheritance: The Diamond Rule"
msgstr "Множественное наследование: правило ромба"

#: ../../whatsnew/2.2.rst:246
msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram "
"taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"Множественное наследование также стало более полезным благодаря изменению "
"правил разрешения имен. Рассмотрим этот набор классов (диаграмма взята из :"
"pep:`253` Гвидо ван Россума):"

#: ../../whatsnew/2.2.rst:264
msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to :"
"meth:`!D.save` will search the classes :class:`!D`, :class:`!B`, and then :"
"class:`!A`, where :meth:`!save` would be found and returned.  :meth:`!C."
"save` would never be found at all.  This is bad, because if :class:`!C`'s :"
"meth:`!save` method is saving some internal state specific to :class:`!C`, "
"not calling it will result in that state never getting saved."
msgstr ""
"Правило поиска для классических классов простое, но не очень умное; базовые "
"классы просматриваются в глубину слева направо. Ссылка на :meth:`!D.save` "
"будет искать классы :class:`!D`, :class:`!B`, а затем :class:`!A`, где :meth:"
"`!save` будет найден и возвращен. :meth:`!C.save` вообще никогда не будет "
"найден. Это плохо, потому что если метод :meth:`!save` :class:`!C` сохраняет "
"какое-то внутреннее состояние, специфичное для :class:`!C`, отказ от его "
"вызова приведет к тому, что это состояние никогда не будет сохранено."

#: ../../whatsnew/2.2.rst:272
msgid ""
"New-style classes follow a different algorithm that's a bit more complicated "
"to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"Классы нового стиля следуют другому алгоритму, который немного сложнее "
"объяснить, но который в данной ситуации работает правильно. (Обратите "
"внимание, что Python 2.3 изменил этот алгоритм на тот, который в большинстве "
"случаев дает те же результаты, но дает более полезные результаты для "
"действительно сложных графов наследования.)"

#: ../../whatsnew/2.2.rst:277
msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`!D`, :class:`!B`, :class:`!A`, :class:`!"
"C`, :class:`!A`]."
msgstr ""
"Перечислите все базовые классы, следуя классическому правилу поиска, и "
"включите класс несколько раз, если он посещается неоднократно. В приведенном "
"выше примере список посещенных классов: [:class:`!D`, :class:`!B`, :class:`!"
"A`, :class:`!C`, :class:`!A. `]."

#: ../../whatsnew/2.2.rst:282
msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`!D`, :class:`!B`, :class:`!C`, :class:`!A`] after "
"dropping duplicates."
msgstr ""
"Просканируйте список на наличие повторяющихся классов. Если таковые имеются, "
"удалите все, кроме одного, оставив *последнее* в списке. В приведенном выше "
"примере список становится [:class:`!D`, :class:`!B`, :class:`!C`, :class:`!"
"A`] после удаления дубликатов."

#: ../../whatsnew/2.2.rst:287
msgid ""
"Following this rule, referring to :meth:`!D.save` will return :meth:`!C."
"save`, which is the behaviour we're after.  This lookup rule is the same as "
"the one followed by Common Lisp.  A new built-in function, :func:`super`, "
"provides a way to get at a class's superclasses without having to "
"reimplement Python's algorithm. The most commonly used form will be  "
"``super(class, obj)``, which returns  a bound superclass object (not the "
"actual class object).  This form will be used in methods to call a method in "
"the superclass; for example, :class:`!D`'s :meth:`!save` method would look "
"like this::"
msgstr ""
"Следуя этому правилу, обращение к :meth:`!D.save` вернет :meth:`!C.save`, "
"что и является искомым поведением. Это правило поиска такое же, как и в "
"Common Lisp. Новая встроенная функция :func:`super` позволяет получить "
"доступ к суперклассам класса без необходимости переопределять алгоритм "
"Python. Наиболее часто используемой формой будет ``super(class, obj)``, "
"которая возвращает связанный объект суперкласса (а не фактический объект "
"класса). Эта форма будет использоваться в методах для вызова метода "
"суперкласса; например, метод :meth:`!save` :class:`!D` будет выглядеть так::"

#: ../../whatsnew/2.2.rst:303
msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often "
"be useful."
msgstr ""
":func:`super` также может возвращать несвязанные объекты суперкласса, когда "
"он вызывается как ``super(class)`` или ``super(class1, class2)``, но это, "
"вероятно, не часто будет полезно."

#: ../../whatsnew/2.2.rst:309
msgid "Attribute Access"
msgstr "Доступ к атрибутам"

#: ../../whatsnew/2.2.rst:311
msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`~object.__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as ``obj."
"get_parent``.  Python 2.2 adds some new ways of controlling attribute access."
msgstr ""
"Значительное количество сложных классов Python определяют перехватчики для "
"доступа к атрибутам, используя :meth:`~object.__getattr__`; чаще всего это "
"делается для удобства, чтобы сделать код более читабельным путем "
"автоматического сопоставления доступа к атрибуту, например obj.parent, с "
"вызовом метода, например obj.get_parent. Python 2.2 добавляет несколько "
"новых способов управления доступом к атрибутам."

#: ../../whatsnew/2.2.rst:317
msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"Во-первых, ``__getattr__(attr_name)`` по-прежнему поддерживается классами "
"нового стиля, и в нем ничего не изменилось. Как и раньше, он будет "
"вызываться, когда будет предпринята попытка доступа к obj.foo и в словаре "
"экземпляра не будет найден атрибут с именем foo."

#: ../../whatsnew/2.2.rst:322
msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`~object.__getattribute__` is *always* called whenever any "
"attribute is accessed, while the old :meth:`~object.__getattr__` is only "
"called if ``foo`` isn't found in the instance's dictionary."
msgstr ""
"Классы нового стиля также поддерживают новый метод "
"``__getattribute__(attr_name)``. Разница между этими двумя методами "
"заключается в том, что :meth:`~object.__getattribute__` вызывается *всегда* "
"всякий раз, когда осуществляется доступ к любому атрибуту, в то время как "
"старый :meth:`~object.__getattr__` вызывается только в том случае, если "
"``foo`` не задан. не найден в словаре экземпляра."

#: ../../whatsnew/2.2.rst:328
msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`!__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of :"
"attr:`~object.__dict__`. :meth:`~object.__getattr__` methods also end up "
"being called by Python when it checks for other methods such as :meth:"
"`~object.__repr__` or :meth:`!__coerce__`, and so have to be written with "
"this in mind. Finally, calling a function on every attribute access results "
"in a sizable performance loss."
msgstr ""
"Однако поддержка :dfn:`properties` в Python 2.2 часто оказывается более "
"простым способом перехвата ссылок на атрибуты. Написание метода :meth:`!"
"__getattr__` сложно, поскольку во избежание рекурсии вы не можете "
"использовать обычный доступ к атрибутам внутри них, и вместо этого вам "
"придется возиться с содержимым :attr:`~object.__dict__`. Методы :meth:"
"`~object.__getattr__` также вызываются Python, когда он проверяет наличие "
"других методов, таких как :meth:`~object.__repr__` или :meth:`!__coerce__`, "
"поэтому их нужно писать с помощью это в виду. Наконец, вызов функции при "
"каждом доступе к атрибуту приводит к значительной потере производительности."

#: ../../whatsnew/2.2.rst:337
msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you "
"want to define a :attr:`!size` attribute that's computed, but also settable, "
"you could write::"
msgstr ""
":class:`property` — это новый встроенный тип, объединяющий три функции, "
"которые получают, устанавливают или удаляют атрибут, а также строку "
"документации. Например, если вы хотите определить атрибут :attr:`!size`, "
"который вычисляется, но также может быть установлен, вы можете написать::"

#: ../../whatsnew/2.2.rst:357
msgid ""
"That is certainly clearer and easier to write than a pair of :meth:`!"
"__getattr__`/:meth:`!__setattr__` methods that check for the :attr:`!size` "
"attribute and handle it specially while retrieving all other attributes from "
"the instance's :attr:`~object.__dict__`.  Accesses to :attr:`!size` are also "
"the only ones which have to perform the work of calling a function, so "
"references to other attributes run at their usual speed."
msgstr ""
"Это, безусловно, понятнее и проще написать, чем пара методов :meth:`!"
"__getattr__`/:meth:`!__setattr__`, которые проверяют наличие атрибута :attr:"
"`!size` и специально обрабатывают его, извлекая все остальные атрибуты из :"
"attr:`~object.__dict__` экземпляра. Доступ к :attr:`!size` также является "
"единственным, который должен выполнять работу по вызову функции, поэтому "
"ссылки на другие атрибуты выполняются с обычной скоростью."

#: ../../whatsnew/2.2.rst:364
msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing ``obj."
"new_attr=1``.   A new-style class can define a class attribute named :attr:"
"`~object.__slots__` to limit the legal attributes  to a particular set of "
"names.  An example will make this clear::"
msgstr ""
"Наконец, можно ограничить список атрибутов, на которые можно ссылаться в "
"объекте, используя новый атрибут класса :attr:`~object.__slots__`. Объекты "
"Python обычно очень динамичны; в любой момент можно определить новый атрибут "
"экземпляра, просто выполнив ``obj.new_attr=1``. Класс нового стиля может "
"определить атрибут класса с именем :attr:`~object.__slots__`, чтобы "
"ограничить допустимые атрибуты определенным набором имен. Пример прояснит "
"это:"

#: ../../whatsnew/2.2.rst:385
msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"Обратите внимание, как вы получаете ошибку :exc:`AttributeError` при попытке "
"назначить атрибут, не указанный в :attr:`~object.__slots__`."

#: ../../whatsnew/2.2.rst:392
msgid "Related Links"
msgstr "Ссылки по теме"

#: ../../whatsnew/2.2.rst:394
msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr ""
"Этот раздел представляет собой краткий обзор новых функций и дает достаточно "
"объяснений, чтобы начать программирование, но многие детали упрощены или "
"проигнорированы. Куда следует обратиться, чтобы получить более полную "
"картину?"

#: ../../whatsnew/2.2.rst:398
msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much "
"more detail about the new features while still remaining quite easy to read."
msgstr ""
":ref:`descriptorhowto` — это подробное введение в функции дескриптора, "
"написанное Гвидо ван Россумом. Если мое описание разожгло ваш аппетит, "
"прочитайте следующее руководство, потому что оно содержит гораздо больше "
"подробностей о новых функциях, но при этом остается довольно простым для "
"чтения."

#: ../../whatsnew/2.2.rst:403
msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is "
"titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  :"
"pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"Далее идут два соответствующих PEP: :pep:`252` и :pep:`253`. :pep:`252` "
"называется «Сделать типы более похожими на классы» и описывает API "
"дескрипторов. :pep:`253` называется «Подтипирование встроенных типов» и "
"описывает изменения в объектах типов, которые позволяют создавать подтипы "
"встроенных объектов. :pep:`253` — это более сложный PEP из двух, и в "
"некоторых моментах необходимые объяснения типов и метатипов могут взорвать "
"вашу голову. Оба PEP были написаны и реализованы Гвидо ван Россумом при "
"существенной помощи остальной команды Zope Corp."

#: ../../whatsnew/2.2.rst:412
msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"Наконец, есть высший авторитет: исходный код. Большая часть механизмов "
"обработки типов находится в :file:`Objects/typeobject.c`, но прибегать к ним "
"следует только после того, как все другие возможности исчерпаны, включая "
"публикацию вопроса в python-list или python-dev."

#: ../../whatsnew/2.2.rst:421
msgid "PEP 234: Iterators"
msgstr "PEP 234: Итераторы"

#: ../../whatsnew/2.2.rst:423
msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr ""
"Еще одним важным дополнением к версии 2.2 является интерфейс итерации как на "
"уровне C, так и на уровне Python. Объекты могут определять, как они могут "
"быть зациклены вызывающими объектами."

#: ../../whatsnew/2.2.rst:426
msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work "
"is to define a :meth:`~object.__getitem__` method that looks something like "
"this::"
msgstr ""
"В версиях Python до 2.1 обычный способ заставить работать элемент for item "
"in obj — определить метод :meth:`~object.__getitem__`, который выглядит "
"примерно так:"

#: ../../whatsnew/2.2.rst:432
msgid ""
":meth:`~object.__getitem__` is more properly used to define an indexing "
"operation on an object so that you can write ``obj[5]`` to retrieve the "
"sixth element.  It's a bit misleading when you're using this only to "
"support :keyword:`for` loops. Consider some file-like object that wants to "
"be looped over; the *index* parameter is essentially meaningless, as the "
"class probably assumes that a series of :meth:`~object.__getitem__` calls "
"will be made with *index* incrementing by one each time.  In other words, "
"the presence of the :meth:`~object.__getitem__` method doesn't mean that "
"using ``file[5]``  to randomly access the sixth element will work, though it "
"really should."
msgstr ""
":meth:`~object.__getitem__` более правильно используется для определения "
"операции индексации объекта, так что вы можете написать ``obj[5]`` для "
"получения шестого элемента. Это немного вводит в заблуждение, когда вы "
"используете это только для поддержки циклов :keyword:`for`. Рассмотрим "
"некоторый объект, похожий на файл, который необходимо обработать в цикле; "
"параметр *index* по сути бессмысленен, поскольку класс, вероятно, "
"предполагает, что будет выполняться серия вызовов :meth:`~object."
"__getitem__` с увеличением *index* на единицу каждый раз. Другими словами, "
"наличие метода :meth:`~object.__getitem__` не означает, что использование "
"``file[5]`` для случайного доступа к шестому элементу будет работать, хотя "
"на самом деле так и должно быть."

#: ../../whatsnew/2.2.rst:442
msgid ""
"In Python 2.2, iteration can be implemented separately, and :meth:`~object."
"__getitem__` methods can be limited to classes that really do support random "
"access.  The basic idea of iterators is  simple.  A new built-in function, "
"``iter(obj)`` or ``iter(C, sentinel)``, is used to get an iterator. "
"``iter(obj)`` returns an iterator for the object *obj*, while ``iter(C, "
"sentinel)`` returns an iterator that will invoke the callable object *C* "
"until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"В Python 2.2 итерация может быть реализована отдельно, а методы :meth:"
"`~object.__getitem__` могут быть ограничены классами, которые действительно "
"поддерживают произвольный доступ. Основная идея итераторов проста. Новая "
"встроенная функция iter(obj) или iter(C, Sentinel) используется для "
"получения итератора. ``iter(obj)`` возвращает итератор для объекта *obj*, а "
"``iter(C, Sentinel)`` возвращает итератор, который будет вызывать вызываемый "
"объект *C* до тех пор, пока он не вернет *sentinel*, сигнализируя, что "
"итератор готов."

#: ../../whatsnew/2.2.rst:450
msgid ""
"Python classes can define an :meth:`!__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator, "
"this method can just return ``self``.  In particular, iterators will usually "
"be their own iterators.  Extension types implemented in C can implement a :c:"
"member:`~PyTypeObject.tp_iter` function in order to return an iterator, and "
"extension types that want to behave as iterators can define a :c:member:"
"`~PyTypeObject.tp_iternext` function."
msgstr ""
"Классы Python могут определять метод :meth:`!__iter__`, который должен "
"создавать и возвращать новый итератор для объекта; если объект является "
"собственным итератором, этот метод может просто вернуть ``self``. В "
"частности, итераторы обычно являются собственными итераторами. Типы "
"расширений, реализованные в C, могут реализовать функцию :c:member:"
"`~PyTypeObject.tp_iter` для возврата итератора, а типы расширений, которые "
"хотят вести себя как итераторы, могут определить :c:member:`~PyTypeObject."
"tp_iternext` функция."

#: ../../whatsnew/2.2.rst:457
msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"Итак, что же на самом деле делают итераторы после всего этого? У них есть "
"один обязательный метод :meth:`next`, который не принимает аргументов и "
"возвращает следующее значение. Когда больше нет возвращаемых значений, "
"вызов :meth:`next` должен вызвать исключение :exc:`StopIteration`. ::"

#: ../../whatsnew/2.2.rst:478
msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`!__iter__` or a :c:"
"member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"В версии 2.2 оператор Python :keyword:`for` больше не ожидает "
"последовательности; он ожидает чего-то, для чего :func:`iter` вернет "
"итератор. Для обратной совместимости и удобства итератор автоматически "
"создается для последовательностей, которые не реализуют слот :meth:`!"
"__iter__` или слот :c:member:`~PyTypeObject.tp_iter`, поэтому ``for i в "
"[1,2] ,3]`` все равно будет работать. Везде, где интерпретатор Python "
"обрабатывает последовательность, он был изменен для использования протокола "
"итератора. Это означает, что вы можете делать такие вещи::"

#: ../../whatsnew/2.2.rst:492
msgid ""
"Iterator support has been added to some of Python's basic types.   Calling :"
"func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr ""
"Поддержка итераторов была добавлена ​​в некоторые базовые типы Python. Вызов :"
"func:`iter` для словаря вернет итератор, который циклически перебирает его "
"ключи::"

#: ../../whatsnew/2.2.rst:512
msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`!iterkeys`, :"
"meth:`!itervalues`, or :meth:`!iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on "
"dictionaries, so ``key in dict`` is now equivalent to ``dict.has_key(key)``."
msgstr ""
"Это просто поведение по умолчанию. Если вы хотите перебрать ключи, значения "
"или пары ключ/значение, вы можете явно вызвать методы :meth:`!iterkeys`, :"
"meth:`!itervalues` или :meth:`!iteritems`, чтобы получить соответствующий "
"итератор. Незначительное изменение: оператор :keyword:`in` теперь работает "
"со словарями, поэтому ``key in dict`` теперь эквивалентен ``dict."
"has_key(key)``."

#: ../../whatsnew/2.2.rst:518
msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each "
"line of a file using code like this::"
msgstr ""
"Файлы также предоставляют итератор, который вызывает метод :meth:`readline` "
"до тех пор, пока в файле не останется строк. Это означает, что теперь вы "
"можете прочитать каждую строку файла, используя такой код:"

#: ../../whatsnew/2.2.rst:526
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol "
"only requires a :meth:`next` method."
msgstr ""
"Обратите внимание, что вы можете двигаться вперед только в итераторе; нет "
"возможности получить предыдущий элемент, сбросить итератор или сделать его "
"копию. Объект-итератор может предоставлять такие дополнительные возможности, "
"но для протокола итератора требуется только метод :meth:`next`."

#: ../../whatsnew/2.2.rst:535
msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - Итераторы"

#: ../../whatsnew/2.2.rst:535
msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly "
"by GvR and Tim Peters."
msgstr ""
"Авторы сценария Ка-Пинг Йи и GvR; реализован командой Python Labs, в "
"основном GvR и Тимом Питерсом."

#: ../../whatsnew/2.2.rst:542
msgid "PEP 255: Simple Generators"
msgstr "PEP 255: Простые генераторы"

#: ../../whatsnew/2.2.rst:544
msgid ""
"Generators are another new feature, one that interacts with the introduction "
"of iterators."
msgstr ""
"Генераторы — еще одна новая функция, связанная с появлением итераторов."

#: ../../whatsnew/2.2.rst:547
msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"Вы, несомненно, знакомы с тем, как работают вызовы функций в Python или C. "
"Когда вы вызываете функцию, она получает частное пространство имен, в "
"котором создаются ее локальные переменные. Когда функция достигает "
"оператора :keyword:`return`, локальные переменные уничтожаются, а полученное "
"значение возвращается вызывающей стороне. Более поздний вызов той же функции "
"получит новый набор локальных переменных. Но что, если бы локальные "
"переменные не удалялись при выходе из функции? Что, если бы вы могли позже "
"возобновить выполнение функции с того места, где она остановилась? Это то, "
"что обеспечивают генераторы; их можно рассматривать как возобновляемые "
"функции."

#: ../../whatsnew/2.2.rst:556
msgid "Here's the simplest example of a generator function::"
msgstr "Вот простейший пример функции-генератора:"

#: ../../whatsnew/2.2.rst:562
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"Для генераторов было введено новое ключевое слово :keyword:`yield`. Любая "
"функция, содержащая оператор :keyword:`!yield`, является функцией-"
"генератором; это обнаруживается компилятором байт-кода Python, который в "
"результате специально компилирует функцию. Поскольку было введено новое "
"ключевое слово, генераторы необходимо явно включить в модуле, включив "
"оператор ``from __future__ importgenerators`` в верхней части исходного кода "
"модуля. В Python 2.3 этот оператор станет ненужным."

#: ../../whatsnew/2.2.rst:570
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`!try` block of a :keyword:"
"`try`...\\ :keyword:`finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"Когда вы вызываете функцию-генератор, она не возвращает ни одного значения; "
"вместо этого он возвращает объект-генератор, поддерживающий протокол "
"итератора. При выполнении оператора :keyword:`yield` генератор выводит "
"значение ``i``, аналогично оператору :keyword:`return`. Большая разница "
"между оператором :keyword:`!yield` и оператором :keyword:`!return` "
"заключается в том, что при достижении :keyword:`!yield` состояние выполнения "
"генератора приостанавливается и локальные переменные сохраняются. При "
"следующем вызове метода генератора ``next()`` функция возобновит выполнение "
"сразу после оператора :keyword:`!yield`. (По сложным причинам оператор :"
"keyword:`!yield` не допускается внутри блока :keyword:`!try` оператора :"
"keyword:`try`...\\ :keyword:`finally`; читайте: pep:`255` для полного "
"объяснения взаимодействия между :keyword:`!yield` и исключениями.)"

#: ../../whatsnew/2.2.rst:583
msgid "Here's a sample usage of the :func:`!generate_ints` generator::"
msgstr "Вот пример использования генератора :func:`!generate_ints`::"

#: ../../whatsnew/2.2.rst:600
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"Вы также можете написать ``for i ingener_ints(5)`` или ``a,b,c "
"=generate_ints(3)``."

#: ../../whatsnew/2.2.rst:603
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"Внутри функции-генератора оператор :keyword:`return` может использоваться "
"только без значения и сигнализирует об окончании обработки значений; после "
"этого генератор не может возвращать дальнейшие значения. :keyword:`!return` "
"со значением, например ``return 5``, является синтаксической ошибкой внутри "
"функции-генератора. Окончание результатов генератора также можно указать, "
"подняв :exc:`StopIteration` вручную или просто позволив потоку выполнения "
"выпасть из нижней части функции."

#: ../../whatsnew/2.2.rst:611
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"Эффекта генераторов можно добиться вручную, написав собственный класс и "
"сохранив все локальные переменные генератора как переменные экземпляра. "
"Например, возврат списка целых чисел можно выполнить, установив для ``self."
"count`` значение 0, а метод :meth:`next` увеличит ``self.count`` и вернет "
"его. Однако для генератора средней сложности написание соответствующего "
"класса было бы гораздо сложнее. :file:`Lib/test/test_generators.py` содержит "
"ряд более интересных примеров. Самый простой реализует обход дерева по "
"порядку с использованием рекурсивных генераторов. ::"

#: ../../whatsnew/2.2.rst:629
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"Два других примера в :file:`Lib/test/test_generators.py` дают решения "
"проблемы N-ферзей (размещение $N$ ферзей на шахматной доске $NxN$ так, чтобы "
"ни один ферзь не угрожал другому) и конского тура ( маршрут, который "
"доставляет коня на каждую клетку шахматной доски $NxN$, не посещая ни одну "
"клетку дважды)."

#: ../../whatsnew/2.2.rst:634
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www2.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www2.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""
"Идея генераторов пришла из других языков программирования, особенно из Icon "
"(https://www2.cs.arizona.edu/icon/), где идея генераторов занимает "
"центральное место. В Icon каждое выражение и вызов функции ведет себя как "
"генератор. Один пример из «Обзора языка программирования значков» по ​​адресу "
"https://www2.cs.arizona.edu/icon/docs/ipd266.htm дает представление о том, "
"как это выглядит:"

#: ../../whatsnew/2.2.rst:644
msgid ""
"In Icon the :func:`!find` function returns the indexes at which the "
"substring \"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` "
"is first assigned a value of 3, but 3 is less than 5, so the comparison "
"fails, and Icon retries it with the second value of 23.  23 is greater than "
"5, so the comparison now succeeds, and the code prints the value 23 to the "
"screen."
msgstr ""
"В Icon функция :func:`!find` возвращает индексы, по которым найдена "
"подстрока \"или\": 3, 23, 33. В операторе :keyword:`if` ``i`` сначала "
"присваивается значение 3, но 3 меньше 5, поэтому сравнение не удается, и "
"Icon повторяет его со вторым значением 23. 23 больше 5, поэтому сравнение "
"теперь завершается успешно, и код выводит значение 23 на экран."

#: ../../whatsnew/2.2.rst:650
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to "
"other functions or stored in a data structure."
msgstr ""
"Python не заходит так далеко, как Icon, в принятии генераторов в качестве "
"центральной концепции. Генераторы считаются новой частью основного языка "
"Python, но их изучение или использование не является обязательным; если они "
"не решают ваших проблем, не стесняйтесь их игнорировать. Одной из новых "
"особенностей интерфейса Python по сравнению с интерфейсом Icon является то, "
"что состояние генератора представлено в виде конкретного объекта "
"(итератора), который можно передавать другим функциям или сохранять в "
"структуре данных."

#: ../../whatsnew/2.2.rst:662
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Простые генераторы"

#: ../../whatsnew/2.2.rst:662
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"Сценарист: Нил Шеменауэр, Тим Питерс, Магнус Ли Хетланд. Реализовано в "
"основном Нилом Шеменауэром и Тимом Питерсом, а другие исправления внесены "
"командой Python Labs."

#: ../../whatsnew/2.2.rst:669
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: объединение длинных и целых чисел"

#: ../../whatsnew/2.2.rst:671
msgid ""
"In recent versions, the distinction between regular integers, which are 32-"
"bit values on most machines, and long integers, which can be of arbitrary "
"size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`!tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"В последних версиях различие между обычными целыми числами, которые на "
"большинстве машин представляют собой 32-битные значения, и длинными целыми "
"числами, которые могут иметь произвольный размер, становилось раздражающим. "
"Например, на платформах, которые поддерживают файлы размером более ``2**32`` "
"байт, метод файловых объектов :meth:`!tell` должен возвращать длинное целое "
"число. Однако были различные части Python, которые ожидали простые целые "
"числа и вызывали ошибку, если вместо них было указано длинное целое число. "
"Например, в Python 1.5 в качестве индекса среза можно было использовать "
"только обычные целые числа, а ``'abc'[1L:]`` вызывало исключение :exc:"
"`TypeError` с сообщением \"индекс среза должен быть int\". ."

#: ../../whatsnew/2.2.rst:681
msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"Python 2.2 будет перемещать значения от коротких к длинным целым числам по "
"мере необходимости. Суффикс «L» больше не нужен для обозначения длинного "
"целочисленного литерала, поскольку теперь компилятор сам выберет "
"соответствующий тип. (Использование суффикса «L» не рекомендуется в будущих "
"версиях Python 2.x, вызывая предупреждение в Python 2.4 и, вероятно, "
"исключено в Python 3.0.) Многие операции, которые раньше вызывали :exc:"
"`OverflowError`, теперь будут возвращать длинное целое число в качестве "
"результата. Например::"

#: ../../whatsnew/2.2.rst:694
msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr ""
"В большинстве случаев целые и длинные целые числа теперь будут "
"обрабатываться одинаково. Вы по-прежнему можете различать их с помощью "
"встроенной функции :func:`type`, но это требуется редко."

#: ../../whatsnew/2.2.rst:702
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - Объединение длинных и целых чисел"

#: ../../whatsnew/2.2.rst:702
msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr ""
"Авторы сценария Моше Задка и Гвидо ван Россум. В основном реализовано Гвидо "
"ван Россумом."

#: ../../whatsnew/2.2.rst:709
msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238: Изменение оператора подразделения"

#: ../../whatsnew/2.2.rst:711
msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"Самое противоречивое изменение в Python 2.2 знаменует начало попыток "
"исправить старый недостаток дизайна, который был в Python с самого начала. В "
"настоящее время оператор деления Python ``/`` ведет себя как оператор "
"деления C, когда ему представлены два целочисленных аргумента: он возвращает "
"целочисленный результат, который усекается, если есть дробная часть. "
"Например, «3/2» равно 1, а не 1,5, а «(-1)/2» равно -1, а не -0,5. Это "
"означает, что результаты деления могут неожиданно различаться в зависимости "
"от типа двух операндов, а поскольку Python является динамически "
"типизированным, может быть сложно определить возможные типы операндов."

#: ../../whatsnew/2.2.rst:721
msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether "
"it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"(Спор идет о том, является ли это *действительно* ошибкой дизайна, и стоит "
"ли ломать существующий код, чтобы это исправить. Это вызвало бесконечные "
"дискуссии на python-dev, а в июле 2001 года вылилось в шквал язвительно-"
"саркастических сообщений на :newsgroup :`comp.lang.python` Я не буду здесь "
"спорить ни за одну из сторон и остановлюсь на описании того, что реализовано "
"в версии 2.2. Прочтите :pep:`238`, чтобы увидеть сводку аргументов и "
"контраргументов.)"

#: ../../whatsnew/2.2.rst:728
msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"Поскольку это изменение может привести к поломке кода, оно вводится очень "
"постепенно. Python 2.2 начинает переход, но переход не будет полным до "
"Python 3.0."

#: ../../whatsnew/2.2.rst:732
msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is "
"0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"Во-первых, я позаимствую некоторую терминологию у :pep:`238`. «Истинное "
"деление» — это деление, с которым знакомо большинство непрограммистов: 3/2 — "
"это 1,5, 1/4 — это 0,25 и так далее. «Деление этажа» — это то, что в "
"настоящее время делает оператор Python ``/``, когда заданы целочисленные "
"операнды; результатом является минимальное значение, возвращаемое истинным "
"делением. «Классическое деление» — это текущее смешанное поведение ``/``; он "
"возвращает результат нижнего деления, когда операнды являются целыми "
"числами, и возвращает результат истинного деления, когда один из операндов "
"является числом с плавающей запятой."

#: ../../whatsnew/2.2.rst:740
msgid "Here are the changes 2.2 introduces:"
msgstr "Вот изменения, которые вносит версия 2.2:"

#: ../../whatsnew/2.2.rst:742
msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and "
"``1.0 // 2.0`` is also 0.0."
msgstr ""
"Новый оператор ``//`` является оператором разделения этажей. (Да, мы знаем, "
"что это похоже на символ комментария C++.) ``//`` *всегда* выполняет деление "
"по этажам независимо от типов своих операндов, поэтому ``1 // 2`` равен 0 и "
"``1.0 // 2.0`` тоже 0.0."

#: ../../whatsnew/2.2.rst:747
msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr ""
"``//`` всегда доступен в Python 2.2; вам не нужно включать его с помощью "
"оператора ``__future__``."

#: ../../whatsnew/2.2.rst:750
msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"При включении в модуль деления импорта from __future__ оператор ``/`` будет "
"изменен и будет возвращать результат истинного деления, поэтому ``1/2`` "
"будет равен 0,5. Без оператора ``__future__`` ``/`` по-прежнему означает "
"классическое деление. Значение ``/`` по умолчанию не изменится до версии "
"Python 3.0."

#: ../../whatsnew/2.2.rst:755
msgid ""
"Classes can define methods called :meth:`~object.__truediv__` and :meth:"
"`~object.__floordiv__` to overload the two division operators.  At the C "
"level, there are also slots in the :c:type:`PyNumberMethods` structure so "
"extension types can define the two operators."
msgstr ""
"Классы могут определять методы :meth:`~object.__truediv__` и :meth:`~object."
"__floordiv__` для перегрузки двух операторов деления. На уровне C в "
"структуре :c:type:`PyNumberMethods` также есть слоты, поэтому типы "
"расширений могут определять два оператора."

#: ../../whatsnew/2.2.rst:760
msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with :option:"
"`!-Q warn` will cause a warning to be issued whenever division is applied to "
"two integers.  You can use this to find code that's affected by the change "
"and fix it.  By default, Python 2.2 will simply perform classic division "
"without a warning; the warning will be turned on by default in Python 2.3."
msgstr ""
"Python 2.2 поддерживает некоторые аргументы командной строки для проверки "
"того, будет ли код работать с измененной семантикой деления. Запуск Python "
"с :option:`!-Q alert` приведет к выдаче предупреждения всякий раз, когда "
"деление применяется к двум целым числам. Вы можете использовать это, чтобы "
"найти код, на который повлияло изменение, и исправить его. По умолчанию "
"Python 2.2 просто выполняет классическое деление без предупреждения; "
"предупреждение будет включено по умолчанию в Python 2.3."

#: ../../whatsnew/2.2.rst:770
msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238` - Смена оператора отдела"

#: ../../whatsnew/2.2.rst:771
msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr ""
"Авторы сценария Моше Задка и Гвидо ван Россум. Реализован Гвидо ван Россум."

#: ../../whatsnew/2.2.rst:777
msgid "Unicode Changes"
msgstr "Изменения в Юникоде"

#: ../../whatsnew/2.2.rst:779
msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"Поддержка Unicode в Python была немного улучшена в версии 2.2. Строки "
"Юникода обычно хранятся в формате UCS-2, как 16-битные целые числа без "
"знака. Python 2.2 также можно скомпилировать для использования 32-битных "
"беззнаковых целых чисел UCS-4 в качестве внутренней кодировки, указав :"
"option:`!--enable-unicode=ucs4` в скрипте configure. (Также можно указать :"
"option:`!--disable-unicode`, чтобы полностью отключить поддержку Unicode.)"

#: ../../whatsnew/2.2.rst:786
msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`!unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than "
"65535 will still cause :func:`!unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode "
"characters\"; consult it for further details."
msgstr ""
"Если интерпретатор создан для использования UCS-4 («широкий Python»), он "
"может обрабатывать символы Юникода от U+000000 до U+110000, поэтому диапазон "
"допустимых значений для функции :func:`!unichr` соответственно "
"расширяется. . При использовании интерпретатора, скомпилированного для "
"использования UCS-2 («узкий Python»), значения, превышающие 65535, все равно "
"приведут к тому, что :func:`!unichr` вызовет исключение :exc:`ValueError`. "
"Все это описано в :pep:`261`, «Поддержка «широких» символов Юникода»; "
"проконсультируйтесь с ним для получения более подробной информации."

#: ../../whatsnew/2.2.rst:794
msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`!encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`!decode` assumes that the string is in "
"the specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""
"Еще одно изменение объяснить проще. С момента своего появления строки "
"Unicode поддерживали метод :meth:`!encode` для преобразования строки в "
"выбранную кодировку, например UTF-8 или Latin-1. Симметричный метод "
"``decode([*encoding*])`` был добавлен к 8-битным строкам (но не к строкам "
"Unicode) в версии 2.2. :meth:`!decode` предполагает, что строка имеет "
"указанную кодировку, и декодирует ее, возвращая все, что возвращает кодек."

#: ../../whatsnew/2.2.rst:801
msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"Благодаря этой новой функции были добавлены кодеки для задач, не связанных "
"напрямую с Unicode. Например, были добавлены кодеки для кодирования uu, "
"кодирования MIME base64 и сжатия с помощью модуля :mod:`zlib`::"

#: ../../whatsnew/2.2.rst:822
msgid ""
"To convert a class instance to Unicode, a :meth:`!__unicode__` method can be "
"defined by a class, analogous to :meth:`!__str__`."
msgstr ""
"Чтобы преобразовать экземпляр класса в Юникод, в классе может быть определен "
"метод :meth:`!__unicode__`, аналогичный :meth:`!__str__`."

#: ../../whatsnew/2.2.rst:825
msgid ""
":meth:`!encode`, :meth:`!decode`, and :meth:`!__unicode__` were implemented "
"by Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`!encode`, :meth:`!decode` и :meth:`!__unicode__` были реализованы "
"Марком-Андре Лембургом. Изменения для внутренней поддержки использования "
"UCS-4 были реализованы Фредриком Лундом и Мартином фон Лёвисом."

#: ../../whatsnew/2.2.rst:832
msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - Поддержка «широких» символов Юникода."

#: ../../whatsnew/2.2.rst:833
msgid "Written by Paul Prescod."
msgstr "Автор сценария Пол Прескод."

#: ../../whatsnew/2.2.rst:839
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: Вложенные области видимости"

#: ../../whatsnew/2.2.rst:841
msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always "
"present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"В Python 2.1 статически вложенные области были добавлены в качестве "
"дополнительной функции, которая включается директивой from __future__ "
"importnested_scopes. В версии 2.2 вложенные области больше не требуют "
"специального включения, и теперь они присутствуют всегда. Оставшаяся часть "
"этого раздела представляет собой копию описания вложенных областей видимости "
"из моего документа «Что нового в Python 2.1»; если вы прочитали его, когда "
"вышла версия 2.1, вы можете пропустить остальную часть этого раздела."

#: ../../whatsnew/2.2.rst:848
msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to "
"Python's scoping rules.  In Python 2.0, at any given time there are at most "
"three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match "
"their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"Самое большое изменение, представленное в Python 2.1 и завершенное в версии "
"2.2, касается правил области действия Python. В Python 2.0 в любой момент "
"времени для поиска имен переменных используется не более трех пространств "
"имен: локальное, на уровне модуля и встроенное пространство имен. Это часто "
"удивляло людей, поскольку не соответствовало их интуитивным ожиданиям. "
"Например, определение вложенной рекурсивной функции не работает::"

#: ../../whatsnew/2.2.rst:862
msgid ""
"The function :func:`!g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"Функция :func:`!g` всегда будет вызывать исключение :exc:`NameError`, "
"поскольку привязка имени ``g`` не находится ни в ее локальном пространстве "
"имен, ни в пространстве имен уровня модуля. На практике это не такая уж "
"большая проблема (как часто вы рекурсивно определяете такие внутренние "
"функции?), но это также делало использование выражения :keyword:`lambda` "
"более неуклюжим, и это было проблемой на практике. В коде, который "
"использует :keyword:`!lambda`, вы часто можете обнаружить, что локальные "
"переменные копируются, передавая их в качестве значений аргументов по "
"умолчанию. ::"

#: ../../whatsnew/2.2.rst:876
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr ""
"В результате читаемость кода Python, написанного в строго функциональном "
"стиле, сильно страдает."

#: ../../whatsnew/2.2.rst:879
msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"Самым значительным изменением в Python 2.2 является то, что для решения этой "
"проблемы в язык добавлена ​​статическая область видимости. Во-первых, аргумент "
"по умолчанию ``name=name`` в приведенном выше примере теперь не нужен. Проще "
"говоря, когда данному имени переменной не присвоено значение внутри функции "
"(присвоением или операторами :keyword:`def`, :keyword:`class` или :keyword:"
"`import`), ссылки на переменная будет искаться в локальном пространстве имен "
"охватывающей области. Более подробное объяснение правил и анализ реализации "
"можно найти в PEP."

#: ../../whatsnew/2.2.rst:888
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"Это изменение может вызвать некоторые проблемы совместимости для кода, в "
"котором одно и то же имя переменной используется как на уровне модуля, так и "
"в качестве локальной переменной внутри функции, содержащей дальнейшие "
"определения функций. Однако это кажется маловероятным, поскольку такой код "
"изначально было бы довольно сложно читать."

#: ../../whatsnew/2.2.rst:894
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"Одним из побочных эффектов изменения является то, что операторы from Module "
"import * и exec стали недопустимыми внутри области функции при определенных "
"условиях. В справочном руководстве Python всегда говорилось, что ``from "
"Module import *`` допустимо только на верхнем уровне модуля, но "
"интерпретатор CPython никогда раньше не применял это. В рамках реализации "
"вложенных областей компилятор, который преобразует исходный код Python в "
"байт-коды, должен генерировать другой код для доступа к переменным в "
"содержащей области. ``from Module import *`` и ``exec`` не позволяют "
"компилятору это выяснить, поскольку они добавляют в локальное пространство "
"имен имена, которые неизвестны во время компиляции. Следовательно, если "
"функция содержит определения функций или выражения :keyword:`lambda` со "
"свободными переменными, компилятор пометит это, вызвав исключение :exc:"
"`SyntaxError`."

#: ../../whatsnew/2.2.rst:907
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "Чтобы сделать предыдущее объяснение более понятным, приведем пример:"

#: ../../whatsnew/2.2.rst:916
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`!g`."
msgstr ""
"Строка 4, содержащая оператор ``exec``, является синтаксической ошибкой, "
"поскольку ``exec`` определит новую локальную переменную с именем ``x``, к "
"значению которой должен обращаться :func:`!g`."

#: ../../whatsnew/2.2.rst:920
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"Это не должно быть большим ограничением, поскольку ``exec`` редко "
"используется в большинстве кодов Python (и когда оно используется, это в "
"любом случае часто является признаком плохого дизайна)."

#: ../../whatsnew/2.2.rst:927
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - Статически вложенные области видимости"

#: ../../whatsnew/2.2.rst:928
msgid "Written and implemented by Jeremy Hylton."
msgstr "Написано и реализовано Джереми Хилтоном."

#: ../../whatsnew/2.2.rst:934
msgid "New and Improved Modules"
msgstr "Новые и улучшенные модули"

#: ../../whatsnew/2.2.rst:936
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module was contributed to the standard "
"library by Fredrik Lundh, providing support for writing XML-RPC clients.  "
"XML-RPC is a simple remote procedure call protocol built on top of HTTP and "
"XML. For example, the following snippet retrieves a list of RSS channels "
"from the O'Reilly Network, and then  lists the recent headlines for one "
"channel::"
msgstr ""
"Модуль :mod:`xmlrpclib <xmlrpc.client>` был добавлен в стандартную "
"библиотеку Фредриком Лундом и обеспечивает поддержку написания клиентов XML-"
"RPC. XML-RPC — это простой протокол удаленного вызова процедур, построенный "
"на основе HTTP и XML. Например, следующий фрагмент извлекает список RSS-"
"каналов из сети O'Reilly, а затем перечисляет последние заголовки для одного "
"канала:"

#: ../../whatsnew/2.2.rst:959
msgid ""
"The :mod:`SimpleXMLRPCServer <xmlrpc.server>` module makes it easy to create "
"straightforward XML-RPC servers.  See http://xmlrpc.scripting.com/ for more "
"information about XML-RPC."
msgstr ""
"Модуль :mod:`SimpleXMLRPCServer <xmlrpc.server>` позволяет легко создавать "
"простые XML-RPC-серверы. См. http://xmlrpc.scripting.com/ для получения "
"дополнительной информации о XML-RPC."

#: ../../whatsnew/2.2.rst:962
msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by :rfc:"
"`2104`. (Contributed by Gerhard Häring.)"
msgstr ""
"Новый модуль :mod:`hmac` реализует алгоритм HMAC, описанный :rfc:`2104`. "
"(Предоставлено Герхардом Херингом.)"

#: ../../whatsnew/2.2.rst:965
msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as :attr:`!memberst_mtime` or :attr:`~time.struct_time.tm_year`. The "
"enhanced functions include :func:`~os.stat`, :func:`~os.fstat`, :func:`~os."
"statvfs`, and :func:`~os.fstatvfs` in the :mod:`os` module, and :func:`~time."
"localtime`, :func:`~time.gmtime`, and :func:`~time.strptime` in the :mod:"
"`time` module."
msgstr ""
"Некоторые функции, которые изначально возвращали длинные кортежи, теперь "
"возвращают псевдопоследовательности, которые по-прежнему ведут себя как "
"кортежи, но также имеют мнемонические атрибуты, такие как :attr:`!"
"memberst_mtime` или :attr:`~time.struct_time.tm_year`. Расширенные функции "
"включают :func:`~os.stat`, :func:`~os.fstat`, :func:`~os.statvfs` и :func:"
"`~os.fstatvfs` в :mod:` os` и :func:`~time.localtime`, :func:`~time.gmtime` "
"и :func:`~time.strptime` в модуле :mod:`time`."

#: ../../whatsnew/2.2.rst:972
msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = os.stat(filename)."
"st_size``."
msgstr ""
"Например, чтобы получить размер файла, используя старые кортежи, вам "
"придется написать что-то вроде ``file_size = os.stat(filename)[stat."
"ST_SIZE]``, но теперь это можно записать более понятно как `` file_size = os."
"stat(filename).st_size``."

#: ../../whatsnew/2.2.rst:976
msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr "Оригинальный патч для этой функции был предоставлен Ником Мэтьюсоном."

#: ../../whatsnew/2.2.rst:978
msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"Профилировщик Python был значительно переработан, и в его выводе были "
"исправлены различные ошибки. (Предоставлено Фредом Л. Дрейком-младшим и "
"Тимом Питерсом.)"

#: ../../whatsnew/2.2.rst:981
msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the :"
"option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
"Модуль :mod:`socket` можно скомпилировать для поддержки IPv6; укажите "
"параметр :option:`!--enable-ipv6` для скрипта настройки Python. (Сообщил "
"Дзюн-итиро «itojun» Хагино.)"

#: ../../whatsnew/2.2.rst:985
msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is "
"for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value is "
"returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""
"В модуль :mod:`struct` были добавлены два новых символа формата для 64-"
"битных целых чисел на платформах, поддерживающих тип C :c:expr:`long long`. "
"``q`` предназначен для 64-битного целого числа со знаком, а ``Q`` — для "
"беззнакового. Значение возвращается в длинном целочисленном типе Python. "
"(Предоставлено Тимом Питерсом.)"

#: ../../whatsnew/2.2.rst:990
msgid ""
"In the interpreter's interactive mode, there's a new built-in function :func:"
"`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to provide "
"interactive help. ``help(object)`` displays any available help text about "
"*object*.  :func:`help` with no argument puts you in an online help utility, "
"where you can enter the names of functions, classes, or modules to read "
"their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's :mod:"
"`pydoc` module.)"
msgstr ""
"В интерактивном режиме интерпретатора имеется новая встроенная функция :func:"
"`help`, которая использует модуль :mod:`pydoc`, представленный в Python 2.1, "
"для предоставления интерактивной справки. ``help(object)`` отображает любой "
"доступный текст справки о *object*. :func:`help` без аргументов переводит "
"вас в онлайн-справочную утилиту, где вы можете ввести имена функций, классов "
"или модулей, чтобы прочитать их справочный текст. (Предоставлено Гвидо ван "
"Россумом с использованием модуля :mod:`pydoc` от Ka-Ping Yee.)"

#: ../../whatsnew/2.2.rst:998
msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` "
"and :func:`re.split` functions have been rewritten in C.  Another "
"contributed patch speeds up certain Unicode character ranges by a factor of "
"two, and a new :meth:`~re.finditer`  method that returns an iterator over "
"all the non-overlapping matches in  a given string.  (SRE is maintained by "
"Fredrik Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
"Различные исправления ошибок и улучшения производительности были внесены в "
"движок SRE, лежащий в основе модуля :mod:`re`. Например, функции :func:`re."
"sub` и :func:`re.split` были переписаны на C. Другой добавленный патч "
"ускоряет определенные диапазоны символов Юникода в два раза, а также новый :"
"meth:` Метод ~re.finditer`, который возвращает итератор по всем "
"непересекающимся совпадениям в заданной строке. (SRE поддерживается "
"Фредриком Лундом. Патч BIGCHARSET был предоставлен Мартином фон Лёвисом.)"

#: ../../whatsnew/2.2.rst:1006
msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib` "
"also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
"Модуль :mod:`smtplib` теперь поддерживает :rfc:`2487`, \"Безопасный SMTP "
"через TLS\", поэтому теперь можно шифровать SMTP-трафик между программой "
"Python и агентом транспорта почты, которому передается сообщение. :mod:"
"`smtplib` также поддерживает аутентификацию SMTP. (Предоставлено Герхардом "
"Херингом.)"

#: ../../whatsnew/2.2.rst:1011
msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
"Модуль :mod:`imaplib`, поддерживаемый Пирсом Лаудером, поддерживает "
"несколько новых расширений: расширение NAMESPACE, определенное в :rfc:"
"`2342`, SORT, GETACL и SETACL. (Сообщили Энтони Бакстер и Мишель Пеллетье.)"

#: ../../whatsnew/2.2.rst:1015
msgid ""
"The :mod:`!rfc822` module's parsing of email addresses is now compliant "
"with :rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* "
"going to be changed to ``rfc2822``.)  A new package, :mod:`email`, has also "
"been added for parsing and generating e-mail messages.  (Contributed by "
"Barry Warsaw, and arising out of his work on Mailman.)"
msgstr ""
"Анализ адресов электронной почты модулем :mod:`!rfc822` теперь совместим с :"
"rfc:`2822`, обновлением :rfc:`822`. (Имя модуля *не* будет изменено на "
"``rfc2822``.) Также был добавлен новый пакет :mod:`email` для анализа и "
"генерации сообщений электронной почты. (Предоставлено Барри Варшавой и "
"возникло в результате его работы над Mailman.)"

#: ../../whatsnew/2.2.rst:1021
msgid ""
"The :mod:`difflib` module now contains a new :class:`!Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, :func:`!"
"ndiff` and :func:`!restore`, which respectively return a delta from two "
"sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
"Модуль :mod:`difflib` теперь содержит новый класс :class:`!Differ` для "
"создания удобочитаемых списков изменений («дельта») между двумя "
"последовательностями строк текста. Есть также две функции-генератора: :func:"
"`!ndiff` и :func:`!restore`, которые соответственно возвращают дельту из "
"двух последовательностей или одну из исходных последовательностей из дельты. "
"(Работа выполнена Дэвидом Гуджером на основе кода ndiff.py Тима Питерса, "
"который затем выполнил генераторизацию.)"

#: ../../whatsnew/2.2.rst:1028
msgid ""
"New constants :const:`!ascii_letters`, :const:`!ascii_lowercase`, and :const:"
"`!ascii_uppercase` were added to the :mod:`string` module.  There were "
"several modules in the standard library that used :const:`!string.letters` "
"to mean the ranges A-Za-z, but that assumption is incorrect when locales are "
"in use, because :const:`!string.letters` varies depending on the set of "
"legal characters defined by the current locale.  The buggy modules have all "
"been fixed to use :const:`!ascii_letters` instead. (Reported by an unknown "
"person; fixed by Fred L. Drake, Jr.)"
msgstr ""
"В модуль :mod:`string` были добавлены новые константы :const:`!"
"ascii_letters`, :const:`!ascii_lowercase` и :const:`!ascii_uppercase`. В "
"стандартной библиотеке было несколько модулей, которые использовали :const:`!"
"string.letters` для обозначения диапазонов A-Za-z, но это предположение "
"неверно, когда используются локали, потому что :const:`!string.letters` "
"варьируется в зависимости от набора допустимых символов, определенных "
"текущей локалью. Все модули с ошибками были исправлены и теперь вместо них "
"используют :const:`!ascii_letters`. (Сообщено неизвестным лицом; исправлено "
"Фредом Л. Дрейком-младшим.)"

#: ../../whatsnew/2.2.rst:1037
msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type "
"databases by the addition of a :class:`~mimetypes.MimeTypes` class, which "
"takes a list of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Модуль :mod:`mimetypes` теперь упрощает использование альтернативных баз "
"данных MIME-типа за счет добавления класса :class:`~mimetypes.MimeTypes`, "
"который принимает список имен файлов для анализа. (Предоставлено Фредом Л. "
"Дрейком-младшим)"

#: ../../whatsnew/2.2.rst:1041
msgid ""
"A :class:`~threading.Timer` class was added to the :mod:`threading` module "
"that allows scheduling an activity to happen at some future time.  "
"(Contributed by Itamar Shtull-Trauring.)"
msgstr ""
"В модуль :mod:`threading` был добавлен класс :class:`~threading.Timer`, "
"который позволяет планировать выполнение действия на некоторое время в "
"будущем. (Предоставлено Итамаром Штулл-Траурингом.)"

#: ../../whatsnew/2.2.rst:1049
msgid "Interpreter Changes and Fixes"
msgstr "Изменения и исправления интерпретатора"

#: ../../whatsnew/2.2.rst:1051
msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"Некоторые изменения касаются только тех, кто работает с интерпретатором "
"Python на уровне C, потому что они пишут модули расширения Python, "
"встраивают интерпретатор или просто взламывают сам интерпретатор. Если вы "
"пишете только код Python, ни одно из описанных здесь изменений не окажет на "
"вас особого влияния."

#: ../../whatsnew/2.2.rst:1056
msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors "
"of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The "
"existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Функции профилирования и трассировки теперь могут быть реализованы на языке "
"C, который может работать с гораздо большей скоростью, чем функции на основе "
"Python, и должен снизить накладные расходы на профилирование и трассировку. "
"Это будет интересно авторам сред разработки на Python. В API Python были "
"добавлены две новые функции C: :c:func:`PyEval_SetProfile` и :c:func:"
"`PyEval_SetTrace`. Существующие функции :func:`sys.setprofile` и :func:`sys."
"settrace` все еще существуют, и они просто были изменены для использования "
"нового интерфейса уровня C. (Предоставлено Фредом Л. Дрейком-младшим)"

#: ../../whatsnew/2.2.rst:1065
msgid ""
"Another low-level API, primarily of interest to implementors of Python "
"debuggers and development tools, was added. :c:func:"
"`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let a caller "
"walk through all the existing interpreter objects; :c:func:"
"`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` allow "
"looping over all the thread states for a given interpreter.  (Contributed by "
"David Beazley.)"
msgstr ""

#: ../../whatsnew/2.2.rst:1072
msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug "
"misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"Интерфейс уровня C для сборщика мусора был изменен, чтобы упростить "
"написание типов расширений, поддерживающих сбор мусора, и отладку "
"неправильного использования функций. Различные функции имеют немного разную "
"семантику, поэтому кучу функций пришлось переименовать. Расширения, "
"использующие старый API, по-прежнему будут компилироваться, но *не* будут "
"участвовать в сборке мусора, поэтому их обновление до версии 2.2 следует "
"рассматривать как довольно высокий приоритет."

#: ../../whatsnew/2.2.rst:1079
msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr ""
"Чтобы обновить модуль расширения до нового API, выполните следующие действия:"

#: ../../whatsnew/2.2.rst:1081
msgid "Rename :c:macro:`!Py_TPFLAGS_GC` to :c:macro:`Py_TPFLAGS_HAVE_GC`."
msgstr ""
"Переименуйте :c:macro:`!Py_TPFLAGS_GC` в :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../whatsnew/2.2.rst:1084
msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr ""
"Используйте :c:func:` PyObj ect_GC_New` или :c:func:` PyObj ect_GC_NewVar` "
"для выделения"

#: ../../whatsnew/2.2.rst:1084
msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "объекты и :c:func:` PyObject_GC_Del` , чтобы освободить их."

#: ../../whatsnew/2.2.rst:1086
msgid ""
"Rename :c:func:`!PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and :c:"
"func:`!PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ""
"Переименуйте :c:func:`! PyObj ect_GC_Init` в :c:func:` PyObj ect_GC_Track` "
"и :c:func:`! PyObject_GC_Fini` в :c:func:` PyObject_GC_UnTrack` ."

#: ../../whatsnew/2.2.rst:1089
msgid "Remove :c:macro:`!PyGC_HEAD_SIZE` from object size calculations."
msgstr "Удалите :c:macro:`!PyGC_HEAD_SIZE` из вычислений размера объекта."

#: ../../whatsnew/2.2.rst:1091
msgid ""
"Remove calls to :c:func:`!PyObject_AS_GC` and :c:func:`!PyObject_FROM_GC`."
msgstr ""
"Удалите вызовы :c:func:`! PyObject_AS_GC` и :c:func:`! PyObject_FROM_GC` ."

#: ../../whatsnew/2.2.rst:1093
msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et`` "
"takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following section.)"
msgstr ""
"В :c:func:`PyArg_ParseTuple` была добавлена ​​новая последовательность формата "
"``et``; ``et`` принимает и параметр, и имя кодировки и преобразует параметр "
"в заданную кодировку, если параметр оказывается строкой Unicode, или "
"оставляет его в покое, если это 8-битная строка, предполагая, что она уже "
"есть. в нужной кодировке. Это отличается от символа формата ``es``, который "
"предполагает, что 8-битные строки находятся в кодировке ASCII Python по "
"умолчанию, и преобразует их в указанную новую кодировку. (Предоставлено М.-"
"А. Лембургом и использовано для поддержки MBCS в Windows, описанной в "
"следующем разделе.)"

#: ../../whatsnew/2.2.rst:1102
msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been "
"added that's simpler and presumably faster.  Instead of specifying a format "
"string, the caller simply gives the minimum and maximum number of arguments "
"expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""
"Была добавлена ​​другая функция анализа аргументов, :c:func:"
"`PyArg_UnpackTuple`, которая проще и, предположительно, быстрее. Вместо "
"указания строки формата вызывающая программа просто передает минимальное и "
"максимальное ожидаемое количество аргументов, а также набор указателей на "
"переменные :c:expr:` PyObject *`, которые будут заполнены значениями "
"аргументов."

#: ../../whatsnew/2.2.rst:1108
msgid ""
"Two new flags :c:macro:`METH_NOARGS` and :c:macro:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses :c:macro:"
"`METH_VARARGS`.  Also, the old :c:macro:`!METH_OLDARGS` style of writing C "
"methods is  now officially deprecated."
msgstr ""
"Два новых флага :c:macro:`METH_NOARGS` и :c:macro:`METH_O` доступны в "
"таблицах определения методов для упрощения реализации методов без аргументов "
"или с одним нетипизированным аргументом. Вызов таких методов более "
"эффективен, чем вызов соответствующего метода, использующего :c:macro:"
"`METH_VARARGS`. Кроме того, старый стиль написания методов C :c:macro:`!"
"METH_OLDARGS` теперь официально признан устаревшим."

#: ../../whatsnew/2.2.rst:1114
msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and :c:func:"
"`PyOS_vsnprintf` were added to provide  cross-platform implementations for "
"the relatively new :c:func:`snprintf` and :c:func:`vsnprintf` C lib APIs. In "
"contrast to the standard :c:func:`sprintf` and :c:func:`!vsprintf` "
"functions, the Python versions check the bounds of the buffer used to "
"protect against buffer overruns. (Contributed by M.-A. Lemburg.)"
msgstr ""
"Две новые функции-оболочки, :c:func:`PyOS_snprintf` и :c:func:"
"`PyOS_vsnprintf`, были добавлены для обеспечения кросс-платформенной "
"реализации относительно новых :c:func:`snprintf` и :c:func:`vsnprintf ` API "
"C lib. В отличие от стандартных функций :c:func:`sprintf` и :c:func:`!"
"vsprintf`, версии Python проверяют границы буфера, используемого для защиты "
"от переполнения буфера. (Сообщил М.-А. Лембург.)"

#: ../../whatsnew/2.2.rst:1121
msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
"Функция :c:func:`_PyTuple_Resize` потеряла неиспользуемый параметр, поэтому "
"теперь она принимает 2 параметра вместо 3. Третий аргумент никогда не "
"использовался, и его можно просто отбросить при портировании кода из более "
"ранних версий на Python 2.2."

#: ../../whatsnew/2.2.rst:1129
msgid "Other Changes and Fixes"
msgstr "Другие изменения и исправления"

#: ../../whatsnew/2.2.rst:1131
msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches "
"and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"Как обычно, по дереву исходного кода было разбросано множество других "
"улучшений и исправлений. Поиск в журналах изменений CVS обнаружил, что между "
"Python 2.1 и 2.2 было применено 527 исправлений и исправлено 683 ошибки; "
"2.2.1 применено 139 патчей и исправлено 143 ошибки; В версии 2.2.2 применено "
"106 патчей и исправлено 82 ошибки. Эти цифры, скорее всего, занижены."

#: ../../whatsnew/2.2.rst:1137
msgid "Some of the more notable changes are:"
msgstr "Некоторые из наиболее заметных изменений:"

#: ../../whatsnew/2.2.rst:1139
msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support "
"MacOS X."
msgstr ""
"Код порта MacOS для Python, поддерживаемый Джеком Янсеном, теперь хранится в "
"основном дереве CVS Python, и для поддержки MacOS X было внесено множество "
"изменений."

#: ../../whatsnew/2.2.rst:1142
msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this "
"(actually, there is the disadvantage that you have to change your PATH to be "
"able to find Python), but it is the basis for creating a full-blown Python "
"application, porting the MacPython IDE, possibly using Python as a standard "
"OSA scripting language and much more.\""
msgstr ""
"Наиболее значительным изменением является возможность сборки Python как "
"фреймворка, доступная путем предоставления опции :option:`!--enable-"
"framework` в скрипте configure при компиляции Python. По словам Джека "
"Янсена, «при этом устанавливается автономная установка Python плюс фреймворк "
"OS X «приклеивается» в :file:`/Library/Frameworks/Python.framework` (или в "
"другое место по выбору). Это дает дополнительную выгоду (на самом деле, есть "
"и недостаток: вам придется изменить PATH, чтобы найти Python), но это "
"является основой для создания полноценного приложения Python, портирования "
"IDE MacPython и, возможно, использования Python в качестве стандартный язык "
"сценариев OSA и многое другое»."

#: ../../whatsnew/2.2.rst:1153
msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as "
"windowing, QuickTime, scripting, etc. have been ported to OS X, but they've "
"been left commented out in :file:`setup.py`.  People who want to experiment "
"with these modules can uncomment them manually."
msgstr ""
"Большинство модулей панели инструментов MacPython, которые взаимодействуют с "
"API-интерфейсами MacOS, такими как работа с окнами, QuickTime, сценарии и т. "
"д., были портированы в OS X, но они остались закомментированы в :file:`setup."
"py`. Люди, желающие поэкспериментировать с этими модулями, могут "
"раскомментировать их вручную."

#: ../../whatsnew/2.2.rst:1176
msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"Аргументы ключевых слов, передаваемые встроенным функциям, которые их не "
"принимают, теперь вызывают исключение :exc:`TypeError` с сообщением "
"\"*функция* не принимает аргументов ключевых слов\"."

#: ../../whatsnew/2.2.rst:1180
msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of "
"the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the :mod:"
"`weakref` module to become a built-in exception."
msgstr ""
"Слабые ссылки, добавленные в Python 2.1 в качестве модуля расширения, теперь "
"являются частью ядра, поскольку они используются при реализации классов "
"нового стиля. Поэтому исключение :exc:`ReferenceError` было перенесено из "
"модуля :mod:`weakref` и стало встроенным исключением."

#: ../../whatsnew/2.2.rst:1185
msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"Новый скрипт :file:`Tools/scripts/cleanfuture.py` Тима Питерса автоматически "
"удаляет устаревшие операторы ``__future__`` из исходного кода Python."

#: ../../whatsnew/2.2.rst:1189
msgid ""
"An additional *flags* argument has been added to the built-in function :func:"
"`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"Во встроенную функцию :func:`compile` был добавлен дополнительный аргумент "
"*flags*, поэтому поведение операторов ``__future__`` теперь можно корректно "
"наблюдать в моделируемых оболочках, например, представленных IDLE и другими "
"разработками. среды. Это описано в :pep:`264`. (Предоставлено Майклом "
"Хадсоном.)"

#: ../../whatsnew/2.2.rst:1195
msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to "
"embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"Новая лицензия, представленная в Python 1.6, не была совместима с GPL. Это "
"исправлено некоторыми незначительными текстовыми изменениями в лицензии 2.2, "
"поэтому теперь снова разрешено встраивать Python в программы под лицензией "
"GPL. Обратите внимание, что сам Python не имеет лицензии GPL, а находится "
"под лицензией, которая по сути эквивалентна лицензии BSD, как и всегда. "
"Изменения лицензии также были применены к выпускам Python 2.0.1 и 2.1.1."

#: ../../whatsnew/2.2.rst:1202
msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default "
"encoding turns out to be an annoyance.  On Unix, the locale's character set "
"is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"При представлении имени файла в Юникоде в Windows Python теперь преобразует "
"его в строку в кодировке MBCS, используемую файловыми API Microsoft. "
"Поскольку MBCS явно используется файловыми API, выбор Python ASCII в "
"качестве кодировки по умолчанию оказывается раздражающим. В Unix "
"используется набор символов локали, если доступен ``locale."
"nl_langinfo(CODESET)``. (Поддержка Windows была предоставлена ​​Марком "
"Хаммондом при содействии Марка-Андре Лембурга. Поддержка Unix была добавлена ​​"
"Мартином фон Лёвисом.)"

#: ../../whatsnew/2.2.rst:1210
msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr ""
"Поддержка больших файлов теперь включена в Windows. (Предоставлено Тимом "
"Питерсом.)"

#: ../../whatsnew/2.2.rst:1212
msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
"Скрипт :file:`Tools/scripts/ftpmirror.py` теперь анализирует файл :file:`."
"netrc`, если он у вас есть. (Предоставлено Майком Ромбергом.)"

#: ../../whatsnew/2.2.rst:1215
msgid ""
"Some features of the object returned by the :func:`!xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in "
"Python 2.3. :class:`!xrange` objects tried to pretend they were full "
"sequence types by supporting slicing, sequence multiplication, and the :"
"keyword:`in` operator, but these features were rarely used and therefore "
"buggy.  The :meth:`!tolist` method and the :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` attributes are also being deprecated.  At the C level, the "
"fourth argument to the :c:func:`!PyRange_New` function, ``repeat``, has also "
"been deprecated."
msgstr ""
"Некоторые функции объекта, возвращаемые функцией :func:`!xrange`, теперь "
"устарели и вызывают предупреждения при доступе к ним; они исчезнут в Python "
"2.3. Объекты :class:`!xrange` пытались притвориться полноценными типами "
"последовательностей, поддерживая срезы, умножение последовательностей и "
"оператор :keyword:`in`, но эти функции использовались редко и поэтому "
"содержали ошибки. Метод :meth:`!tolist` и атрибуты :attr:`!start`, :attr:`!"
"stop` и :attr:`!step` также устарели. На уровне C четвертый аргумент "
"функции :c:func:`!PyRange_New`, ``repeat``, также признан устаревшим."

#: ../../whatsnew/2.2.rst:1224
msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a "
"case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"В реализацию словаря было внесено множество исправлений, в основном для "
"исправления потенциальных дампов ядра, если словарь содержит объекты, "
"которые незаметно изменили свое хэш-значение или мутировали словарь, в "
"котором они содержались. На какое-то время python-dev погрузился в мягкий "
"ритм Майкл Хадсон нашел случай, из-за которого сбрасывалось ядро, Тим Питерс "
"исправил ошибку, Майкл нашел еще один случай, и так по кругу."

#: ../../whatsnew/2.2.rst:1231
msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"В Windows Python теперь можно скомпилировать с помощью Borland C благодаря "
"ряду исправлений, предоставленных Стивеном Хансеном, хотя результат еще не "
"полностью функционален. (Но это *есть* прогресс...)"

#: ../../whatsnew/2.2.rst:1235
msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"Еще одно усовершенствование Windows: компания Wise Solutions щедро "
"предложила PythonLabs использовать свою систему InstallerMaster 8.1. Ранее "
"установщики PythonLabs для Windows использовали Wise 5.0a, который уже начал "
"показывать свой возраст. (Упаковано Тимом Питерсом.)"

#: ../../whatsnew/2.2.rst:1239
msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David "
"Bolen.)"
msgstr ""
"Файлы, заканчивающиеся на ``.pyw``, теперь можно импортировать в Windows. ``."
"pyw`` — это функция только для Windows, используемая для указания того, что "
"сценарий необходимо запустить с использованием PYTHONW.EXE вместо PYTHON."
"EXE, чтобы предотвратить появление консоли DOS для отображения вывода. Этот "
"патч позволяет импортировать такие скрипты, если их можно использовать и в "
"качестве модулей. (Реализовано Дэвидом Боленом.)"

#: ../../whatsnew/2.2.rst:1245
msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by :c:func:"
"`dlopen` using the :func:`sys.getdlopenflags` and :func:`sys.setdlopenflags` "
"functions. (Contributed by Bram Stolk.)"
msgstr ""
"На платформах, где Python использует функцию C :c:func:`dlopen` для загрузки "
"модулей расширения, теперь можно установить флаги, используемые :c:func:"
"`dlopen`, с помощью :func:`sys.getdlopenflags` и: func:`sys.setdlopenflags`. "
"(Предоставлено Брэмом Столком.)"

#: ../../whatsnew/2.2.rst:1250
msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""

#: ../../whatsnew/2.2.rst:1260
msgid "Acknowledgements"
msgstr "Подтверждение"

#: ../../whatsnew/2.2.rst:1262
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack "
"Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, "
"Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van "
"Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"Автор хотел бы поблагодарить следующих людей за предложения, исправления и "
"помощь в различных черновиках этой статьи: Фреда Бреммера, Кейта Бриггса, "
"Эндрю Далка, Фреда Л. Дрейка-младшего, Кэрела Феллингера, Дэвида Гуджера, "
"Марка Хаммонда, Стивена. Хансен, Майкл Хадсон, Джек Янсен, Марк-Андре "
"Лембург, Мартин фон Лёвис, Фредрик Лунд, Майкл Маклэй, Ник Мэтьюсон, Пол "
"Мур, Густаво Нимейер, Дон О’Доннелл, Йоонас Пааласма, Тим Питерс, Йенс "
"Куэйд, Том Рейнхардт, Нил Шеменауэр, Гвидо ван Россум, Грег Уорд, Эдвард "
"Уэлборн."
