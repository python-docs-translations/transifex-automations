# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-29 14:35+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../extending/embedding.rst:8
msgid "Embedding Python in Another Application"
msgstr "Integrar Python noutra aplicação"

#: ../../extending/embedding.rst:10
msgid ""
"The previous chapters discussed how to extend Python, that is, how to extend "
"the functionality of Python by attaching a library of C functions to it.  It "
"is also possible to do it the other way around: enrich your C/C++ "
"application by embedding Python in it.  Embedding provides your application "
"with the ability to implement some of the functionality of your application "
"in Python rather than C or C++. This can be used for many purposes; one "
"example would be to allow users to tailor the application to their needs by "
"writing some scripts in Python.  You can also use it yourself if some of the "
"functionality can be written in Python more easily."
msgstr ""
"Os capítulos anteriores discutiram como estender o Python, ou seja, como "
"estender a funcionalidade do Python anexando uma biblioteca de funções C a "
"ele. Também é possível fazer o contrário: enriquecer a sua aplicação C/C++ "
"integrando Python nela. A integração fornece à sua aplicação a capacidade de "
"implementar algumas das funcionalidades da sua aplicação no Python, em vez "
"de C ou C++. Isto pode ser utilizado para muitos fins; um exemplo seria "
"permitir que os utilizadores personalizem a aplicação de acordo com as suas "
"necessidades, escrevendo alguns scripts em Python. Você também pode usá-lo "
"se algumas das funcionalidades puderem ser escritas em Python com mais "
"facilidade."

#: ../../extending/embedding.rst:20
msgid ""
"Embedding Python is similar to extending it, but not quite.  The difference "
"is that when you extend Python, the main program of the application is still "
"the Python interpreter, while if you embed Python, the main program may have "
"nothing to do with Python --- instead, some parts of the application "
"occasionally call the Python interpreter to run some Python code."
msgstr ""
"Integrar Python é semelhante a estendê-lo, mas não exatamente. A diferença é "
"que, quando se estende Python, o programa principal da aplicação continua a "
"ser o interpretador Python, enquanto que, quando se integra Python, o "
"programa principal pode não ter nada a ver com Python --- em vez disso, "
"algumas partes da aplicação ocasionalmente chamam o interpretador Python "
"para executar algum código Python."

#: ../../extending/embedding.rst:26
msgid ""
"So if you are embedding Python, you are providing your own main program.  "
"One of the things this main program has to do is initialize the Python "
"interpreter.  At the very least, you have to call the function :c:func:"
"`Py_Initialize`.  There are optional calls to pass command line arguments to "
"Python.  Then later you can call the interpreter from any part of the "
"application."
msgstr ""
"Portanto, se estiver a integrar Python, estará a fornecer o seu próprio "
"programa principal. Uma das coisas que este programa principal tem de fazer "
"é inicializar o interpretador Python. No mínimo, terá de chamar a função :c:"
"func:`Py_Initialize`. Existem chamadas opcionais para passar argumentos de "
"linha de comando para Python. Posteriormente, poderá chamar o interpretador "
"a partir de qualquer parte da aplicação."

#: ../../extending/embedding.rst:32
msgid ""
"There are several different ways to call the interpreter: you can pass a "
"string containing Python statements to :c:func:`PyRun_SimpleString`, or you "
"can pass a stdio file pointer and a file name (for identification in error "
"messages only) to :c:func:`PyRun_SimpleFile`.  You can also call the lower-"
"level operations described in the previous chapters to construct and use "
"Python objects."
msgstr ""
"Existem várias maneiras diferentes de chamar o interpretador: pode passar "
"uma string que contém instruções Python para :c:func:`PyRun_SimpleString`, "
"ou pode passar um ponteiro de ficheiro stdio e um nome de ficheiro (apenas "
"para identificação em mensagens de erro) para :c:func:`PyRun_SimpleFile`. "
"Também pode chamar as operações de nível inferior descritas nos capítulos "
"anteriores para construir e usar objetos Python."

#: ../../extending/embedding.rst:41
msgid ":ref:`c-api-index`"
msgstr ":ref:`c-api-index`"

#: ../../extending/embedding.rst:42
msgid ""
"The details of Python's C interface are given in this manual. A great deal "
"of necessary information can be found here."
msgstr ""
"Os detalhes da interface C do Python são fornecidos neste manual. Muitas "
"informações necessárias podem ser encontradas aqui."

#: ../../extending/embedding.rst:49
msgid "Very High Level Embedding"
msgstr "Integração de nível muito alto"

#: ../../extending/embedding.rst:51
msgid ""
"The simplest form of embedding Python is the use of the very high level "
"interface. This interface is intended to execute a Python script without "
"needing to interact with the application directly. This can for example be "
"used to perform some operation on a file. ::"
msgstr ""
"A forma mais simples de integrar Python é utilizar a interface de alto "
"nível. Essa interface serve para executar um script Python sem precisar "
"interagir diretamente com a aplicação. Isto pode ser utilizado, por exemplo, "
"para fazer alguma operação num ficheiro. ::"

#: ../../extending/embedding.rst:56
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* optional but recommended */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    PyRun_SimpleString(\"from time import time,ctime\\n\"\n"
"                       \"print('Today is', ctime(time()))\\n\");\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        exit(120);\n"
"    }\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyStatus status;\n"
"    PyConfig config;\n"
"    PyConfig_InitPythonConfig(&config);\n"
"\n"
"    /* opcional, mas recomendado */\n"
"    status = PyConfig_SetBytesString(&config, &config.program_name, "
"argv[0]);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"\n"
"    status = Py_InitializeFromConfig(&config);\n"
"    if (PyStatus_Exception(status)) {\n"
"        goto exception;\n"
"    }\n"
"    PyConfig_Clear(&config);\n"
"\n"
"    PyRun_SimpleString(\"from time import time,ctime\\n\"\n"
"                       \"print('Hoje é', ctime(time()))\\n\");\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        exit(120);\n"
"    }\n"
"    return 0;\n"
"\n"
"  exception:\n"
"     PyConfig_Clear(&config);\n"
"     Py_ExitStatusException(status);\n"
"}"

#: ../../extending/embedding.rst:92
msgid ""
"``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` should "
"be used in some APIs instead of ``int``. It is not necessary since Python "
"3.13, but we keep it here for backward compatibility. See :ref:`arg-parsing-"
"string-and-buffers` for a description of this macro."
msgstr ""
"``#define PY_SSIZE_T_CLEAN`` era usado para indicar que ``Py_ssize_t`` "
"deveria ser usado em algumas APIs em vez de ``int``. Não é necessário desde "
"o Python 3.13, mas mantemo-lo aqui por compatibilidade retroativa. Consulte :"
"ref:`arg-parsing-string-and-buffers` para uma descrição desta macro."

#: ../../extending/embedding.rst:97
msgid ""
"Setting :c:member:`PyConfig.program_name` should be called before :c:func:"
"`Py_InitializeFromConfig` to inform the interpreter about paths to Python "
"run-time libraries.  Next, the Python interpreter is initialized with :c:"
"func:`Py_Initialize`, followed by the execution of a hard-coded Python "
"script that prints the date and time.  Afterwards, the :c:func:"
"`Py_FinalizeEx` call shuts the interpreter down, followed by the end of the "
"program.  In a real program, you may want to get the Python script from "
"another source, perhaps a text-editor routine, a file, or a database.  "
"Getting the Python code from a file can better be done by using the :c:func:"
"`PyRun_SimpleFile` function, which saves you the trouble of allocating "
"memory space and loading the file contents."
msgstr ""
"A configuração :c:member:`PyConfig.program_name` deve ser chamada antes de :"
"c:func:`Py_InitializeFromConfig` para informar ao interpretador os caminhos "
"para as bibliotecas de tempo de execução do Python. Em seguida, o "
"interpretador Python é inicializado com :c:func:`Py_Initialize`, seguido "
"pela execução de um script Python codificado que imprime a data e a hora. "
"Depois, a chamada :c:func:`Py_FinalizeEx` encerra o interpretador, seguido "
"pelo fim do programa. Num programa real, pode querer obter o script Python "
"de outra fonte, talvez uma rotina de editor de texto, um ficheiro ou uma "
"base de dados. Obter o código Python de um ficheiro pode ser feito de forma "
"mais eficaz utilizando a função :c:func:`PyRun_SimpleFile`, que evita o "
"trabalho de alocar espaço de memória e carregar o conteúdo do ficheiro."

#: ../../extending/embedding.rst:112
msgid "Beyond Very High Level Embedding: An overview"
msgstr "Além da integração de nível muito alto: uma visão geral"

#: ../../extending/embedding.rst:114
msgid ""
"The high level interface gives you the ability to execute arbitrary pieces "
"of Python code from your application, but exchanging data values is quite "
"cumbersome to say the least. If you want that, you should use lower level "
"calls. At the cost of having to write more C code, you can achieve almost "
"anything."
msgstr ""
"A interface de alto nível permite executar trechos arbitrários de código "
"Python a partir da sua aplicação, mas a troca de valores de dados é bastante "
"complicada, para dizer o mínimo. Se quiser fazer isso, deve usar chamadas de "
"nível inferior. Ao custo de ter que escrever mais código C, pode conseguir "
"quase tudo."

#: ../../extending/embedding.rst:119
msgid ""
"It should be noted that extending Python and embedding Python is quite the "
"same activity, despite the different intent. Most topics discussed in the "
"previous chapters are still valid. To show this, consider what the extension "
"code from Python to C really does:"
msgstr ""
"Deve-se observar que estender o Python e integrar o Python são atividades "
"bastante semelhantes, apesar da intenção diferente. A maioria dos tópicos "
"discutidos nos capítulos anteriores ainda é válida. Para mostrar isso, "
"considere o que o código de extensão do Python para C realmente faz:"

#: ../../extending/embedding.rst:124
msgid "Convert data values from Python to C,"
msgstr "Converte valores de dados de Python para C,"

#: ../../extending/embedding.rst:126
msgid "Perform a function call to a C routine using the converted values, and"
msgstr ""
"Executa uma chamada de função para uma rotina C utilizando os valores "
"convertidos e"

#: ../../extending/embedding.rst:128
msgid "Convert the data values from the call from C to Python."
msgstr "Converte os valores dos dados da chamada de C para Python."

#: ../../extending/embedding.rst:130
msgid "When embedding Python, the interface code does:"
msgstr "Ao integrar Python, o código da interface faz o seguinte:"

#: ../../extending/embedding.rst:132
msgid "Convert data values from C to Python,"
msgstr "Converte valores de dados de C para Python,"

#: ../../extending/embedding.rst:134
msgid ""
"Perform a function call to a Python interface routine using the converted "
"values, and"
msgstr ""
"Executa uma chamada de função para uma rotina de interface Python utilizando "
"os valores convertidos e"

#: ../../extending/embedding.rst:137
msgid "Convert the data values from the call from Python to C."
msgstr "Converte os valores dos dados da chamada de Python para C."

#: ../../extending/embedding.rst:139
msgid ""
"As you can see, the data conversion steps are simply swapped to accommodate "
"the different direction of the cross-language transfer. The only difference "
"is the routine that you call between both data conversions. When extending, "
"you call a C routine, when embedding, you call a Python routine."
msgstr ""
"Como pode ver, as etapas de conversão de dados são simplesmente trocadas "
"para acomodar a direção diferente da transferência entre linguagens. A única "
"diferença é a rotina que chama entre ambas as conversões de dados. Ao "
"estender, chama uma rotina C; ao integrar, chama uma rotina Python."

#: ../../extending/embedding.rst:144
msgid ""
"This chapter will not discuss how to convert data from Python to C and vice "
"versa.  Also, proper use of references and dealing with errors is assumed to "
"be understood.  Since these aspects do not differ from extending the "
"interpreter, you can refer to earlier chapters for the required information."
msgstr ""
"Este capítulo não discutirá como converter dados de Python para C e vice-"
"versa. Além disso, presume-se que o uso adequado de referências e o "
"tratamento de erros sejam compreendidos. Como esses aspectos não diferem da "
"extensão do interpretador, pode consultar os capítulos anteriores para obter "
"as informações necessárias."

#: ../../extending/embedding.rst:153
msgid "Pure Embedding"
msgstr "Integração pura"

#: ../../extending/embedding.rst:155
msgid ""
"The first program aims to execute a function in a Python script. Like in the "
"section about the very high level interface, the Python interpreter does not "
"directly interact with the application (but that will change in the next "
"section)."
msgstr ""
"O primeiro programa tem como objetivo executar uma função num script Python. "
"Tal como na secção sobre a interface de alto nível, o interpretador Python "
"não interage diretamente com a aplicação (mas isso irá mudar na próxima "
"secção)."

#: ../../extending/embedding.rst:160
msgid "The code to run a function defined in a Python script is:"
msgstr "O código para executar uma função definida num script Python é:"

#: ../../extending/embedding.rst:162
msgid ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyObject *pName, *pModule, *pFunc;\n"
"    PyObject *pArgs, *pValue;\n"
"    int i;\n"
"\n"
"    if (argc < 3) {\n"
"        fprintf(stderr,\"Usage: call pythonfile funcname [args]\\n\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    Py_Initialize();\n"
"    pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"    /* Error checking of pName left out */\n"
"\n"
"    pModule = PyImport_Import(pName);\n"
"    Py_DECREF(pName);\n"
"\n"
"    if (pModule != NULL) {\n"
"        pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"        /* pFunc is a new reference */\n"
"\n"
"        if (pFunc && PyCallable_Check(pFunc)) {\n"
"            pArgs = PyTuple_New(argc - 3);\n"
"            for (i = 0; i < argc - 3; ++i) {\n"
"                pValue = PyLong_FromLong(atoi(argv[i + 3]));\n"
"                if (!pValue) {\n"
"                    Py_DECREF(pArgs);\n"
"                    Py_DECREF(pModule);\n"
"                    fprintf(stderr, \"Cannot convert argument\\n\");\n"
"                    return 1;\n"
"                }\n"
"                /* pValue reference stolen here: */\n"
"                PyTuple_SetItem(pArgs, i, pValue);\n"
"            }\n"
"            pValue = PyObject_CallObject(pFunc, pArgs);\n"
"            Py_DECREF(pArgs);\n"
"            if (pValue != NULL) {\n"
"                printf(\"Result of call: %ld\\n\", PyLong_AsLong(pValue));\n"
"                Py_DECREF(pValue);\n"
"            }\n"
"            else {\n"
"                Py_DECREF(pFunc);\n"
"                Py_DECREF(pModule);\n"
"                PyErr_Print();\n"
"                fprintf(stderr,\"Call failed\\n\");\n"
"                return 1;\n"
"            }\n"
"        }\n"
"        else {\n"
"            if (PyErr_Occurred())\n"
"                PyErr_Print();\n"
"            fprintf(stderr, \"Cannot find function \\\"%s\\\"\\n\", "
"argv[2]);\n"
"        }\n"
"        Py_XDECREF(pFunc);\n"
"        Py_DECREF(pModule);\n"
"    }\n"
"    else {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Failed to load \\\"%s\\\"\\n\", argv[1]);\n"
"        return 1;\n"
"    }\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        return 120;\n"
"    }\n"
"    return 0;\n"
"}\n"
msgstr ""
"#define PY_SSIZE_T_CLEAN\n"
"#include <Python.h>\n"
"\n"
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    PyObject *pName, *pModule, *pFunc;\n"
"    PyObject *pArgs, *pValue;\n"
"    int i;\n"
"\n"
"    if (argc < 3) {\n"
"        fprintf(stderr,\"Usage: call pythonfile funcname [args]\\n\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    Py_Initialize();\n"
"    pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"    /* Verificação de erros de pName omitida */\n"
"\n"
"    pModule = PyImport_Import(pName);\n"
"    Py_DECREF(pName);\n"
"\n"
"    if (pModule != NULL) {\n"
"        pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"        /* pFunc é uma nova referência */\n"
"\n"
"        if (pFunc && PyCallable_Check(pFunc)) {\n"
"            pArgs = PyTuple_New(argc - 3);\n"
"            for (i = 0; i < argc - 3; ++i) {\n"
"                pValue = PyLong_FromLong(atoi(argv[i + 3]));\n"
"                if (!pValue) {\n"
"                    Py_DECREF(pArgs);\n"
"                    Py_DECREF(pModule);\n"
"                    fprintf(stderr, \"Não é possível converter o "
"argumento\\n\");\n"
"                    return 1;\n"
"                }\n"
"                /* Referência pValue roubada aqui: */\n"
"                PyTuple_SetItem(pArgs, i, pValue);\n"
"            }\n"
"            pValue = PyObject_CallObject(pFunc, pArgs);\n"
"            Py_DECREF(pArgs);\n"
"            if (pValue != NULL) {\n"
"                printf(\"Resultado da chamada: %ld\\n\", "
"PyLong_AsLong(pValue));\n"
"                Py_DECREF(pValue);\n"
"            }\n"
"            else {\n"
"                Py_DECREF(pFunc);\n"
"                Py_DECREF(pModule);\n"
"                PyErr_Print();\n"
"                fprintf(stderr,\"A chamada falhou\\n\");\n"
"                return 1;\n"
"            }\n"
"        }\n"
"        else {\n"
"            if (PyErr_Occurred())\n"
"                PyErr_Print();\n"
"            fprintf(stderr, \"Não é possível encontrar a função \\\"%s\\"
"\"\\n\", argv[2]);\n"
"        }\n"
"        Py_XDECREF(pFunc);\n"
"        Py_DECREF(pModule);\n"
"    }\n"
"    else {\n"
"        PyErr_Print();\n"
"        fprintf(stderr, \"Falhou ao carregar \\\"%s\\\"\\n\", argv[1]);\n"
"        return 1;\n"
"    }\n"
"    if (Py_FinalizeEx() < 0) {\n"
"        return 120;\n"
"    }\n"
"    return 0;\n"
"}\n"

#: ../../extending/embedding.rst:165
msgid ""
"This code loads a Python script using ``argv[1]``, and calls the function "
"named in ``argv[2]``.  Its integer arguments are the other values of the "
"``argv`` array.  If you :ref:`compile and link <compiling>` this program "
"(let's call the finished executable :program:`call`), and use it to execute "
"a Python script, such as:"
msgstr ""
"Este código carrega um script Python utilizando ``argv[1]`` e chama a função "
"nomeada em ``argv[2]``. Os seus argumentos inteiros são os outros valores do "
"array ``argv``. Se você :ref:`compilar e ligar <compiling>` este programa "
"(vamos chamar o executável finalizado de :program:`call`) e usá-lo para "
"executar um script Python, como:"

#: ../../extending/embedding.rst:171
msgid ""
"def multiply(a,b):\n"
"    print(\"Will compute\", a, \"times\", b)\n"
"    c = 0\n"
"    for i in range(0, a):\n"
"        c = c + b\n"
"    return c"
msgstr ""
"def multiply(a,b):\n"
"    print(\"Vai calcular\", a, \"vezes\", b)\n"
"    c = 0\n"
"    for i in range(0, a):\n"
"        c = c + b\n"
"    return c"

#: ../../extending/embedding.rst:180
msgid "then the result should be:"
msgstr "então o resultado deve ser:"

#: ../../extending/embedding.rst:182
msgid ""
"$ call multiply multiply 3 2\n"
"Will compute 3 times 2\n"
"Result of call: 6"
msgstr ""
"$ call multiply multiply 3 2\n"
"Vai calcular 3 vezes 2\n"
"Resultado da chamada: 6"

#: ../../extending/embedding.rst:188
msgid ""
"Although the program is quite large for its functionality, most of the code "
"is for data conversion between Python and C, and for error reporting.  The "
"interesting part with respect to embedding Python starts with ::"
msgstr ""
"Embora o programa seja bastante grande para a sua funcionalidade, a maior "
"parte do código é para conversão de dados entre Python e C e para relatórios "
"de erros. A parte interessante em relação à integração do Python começa "
"com ::"

#: ../../extending/embedding.rst:192
msgid ""
"Py_Initialize();\n"
"pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"/* Error checking of pName left out */\n"
"pModule = PyImport_Import(pName);"
msgstr ""
"Py_Initialize();\n"
"pName = PyUnicode_DecodeFSDefault(argv[1]);\n"
"/* Verificação de erros de pName omitida */\n"
"pModule = PyImport_Import(pName);"

#: ../../extending/embedding.rst:197
msgid ""
"After initializing the interpreter, the script is loaded using :c:func:"
"`PyImport_Import`.  This routine needs a Python string as its argument, "
"which is constructed using the :c:func:`PyUnicode_DecodeFSDefault` data "
"conversion routine. ::"
msgstr ""
"Após inicializar o interpretador, o script é carregado utilizando :c:func:"
"`PyImport_Import`. Esta rotina precisa de uma string Python como argumento, "
"que é construída utilizando a rotina de conversão de dados :c:func:"
"`PyUnicode_DecodeFSDefault`. ::"

#: ../../extending/embedding.rst:202
msgid ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"/* pFunc is a new reference */\n"
"\n"
"if (pFunc && PyCallable_Check(pFunc)) {\n"
"    ...\n"
"}\n"
"Py_XDECREF(pFunc);"
msgstr ""
"pFunc = PyObject_GetAttrString(pModule, argv[2]);\n"
"/* pFunc é uma nova referência */\n"
"\n"
"if (pFunc && PyCallable_Check(pFunc)) {\n"
"    ...\n"
"}\n"
"Py_XDECREF(pFunc);"

#: ../../extending/embedding.rst:210
msgid ""
"Once the script is loaded, the name we're looking for is retrieved using :c:"
"func:`PyObject_GetAttrString`.  If the name exists, and the object returned "
"is callable, you can safely assume that it is a function.  The program then "
"proceeds by constructing a tuple of arguments as normal.  The call to the "
"Python function is then made with::"
msgstr ""
"Depois do script ser carregado, o nome que estamos a procurar é recuperado "
"utilizando :c:func:`PyObject_GetAttrString`. Se o nome existir e o objeto "
"retornado for chamável, você pode presumir com segurança que se trata de uma "
"função. O programa então prossegue construindo um tuplo de argumentos "
"normalmente. A chamada para a função Python é então feita com::"

#: ../../extending/embedding.rst:216
msgid "pValue = PyObject_CallObject(pFunc, pArgs);"
msgstr "pValue = PyObject_CallObject(pFunc, pArgs);"

#: ../../extending/embedding.rst:218
msgid ""
"Upon return of the function, ``pValue`` is either ``NULL`` or it contains a "
"reference to the return value of the function.  Be sure to release the "
"reference after examining the value."
msgstr ""
"Ao retornar da função, ``pValue`` é ``NULL`` ou contém uma referência ao "
"valor de retorno da função. Certifique-se de liberar a referência após "
"examinar o valor."

#: ../../extending/embedding.rst:226
msgid "Extending Embedded Python"
msgstr "Ampliando o Python integrado"

#: ../../extending/embedding.rst:228
msgid ""
"Until now, the embedded Python interpreter had no access to functionality "
"from the application itself.  The Python API allows this by extending the "
"embedded interpreter.  That is, the embedded interpreter gets extended with "
"routines provided by the application. While it sounds complex, it is not so "
"bad.  Simply forget for a while that the application starts the Python "
"interpreter.  Instead, consider the application to be a set of subroutines, "
"and write some glue code that gives Python access to those routines, just "
"like you would write a normal Python extension.  For example::"
msgstr ""
"Até agora, o interpretador Python integrado não tinha acesso às "
"funcionalidades da própria aplicação. A API Python permite isso ao estender "
"o interpretador integrado. Ou seja, o interpretador integrado é estendido "
"com rotinas fornecidas pela aplicação. Embora pareça complexo, não é assim "
"tão difícil. Basta esquecer por um momento que a aplicação inicia o "
"interpretador Python. Em vez disso, considere a aplicação como um conjunto "
"de sub-rotinas e escreva algum código de ligação que dê ao Python acesso a "
"essas rotinas, assim como você escreveria uma extensão Python normal. Por "
"exemplo::"

#: ../../extending/embedding.rst:237
msgid ""
"static int numargs=0;\n"
"\n"
"/* Return the number of arguments of the application command line */\n"
"static PyObject*\n"
"emb_numargs(PyObject *self, PyObject *args)\n"
"{\n"
"    if(!PyArg_ParseTuple(args, \":numargs\"))\n"
"        return NULL;\n"
"    return PyLong_FromLong(numargs);\n"
"}\n"
"\n"
"static PyMethodDef emb_module_methods[] = {\n"
"    {\"numargs\", emb_numargs, METH_VARARGS,\n"
"     \"Return the number of arguments received by the process.\"},\n"
"    {NULL, NULL, 0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef emb_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"emb\",\n"
"    .m_size = 0,\n"
"    .m_methods = emb_module_methods,\n"
"};\n"
"\n"
"static PyObject*\n"
"PyInit_emb(void)\n"
"{\n"
"    return PyModuleDef_Init(&emb_module);\n"
"}"
msgstr ""
"static int numargs=0;\n"
"\n"
"/* Retorna o número de argumentos da linha de comando da aplicação */\n"
"static PyObject*\n"
"emb_numargs(PyObject *self, PyObject *args)\n"
"{\n"
"    if(!PyArg_ParseTuple(args, \":numargs\"))\n"
"        return NULL;\n"
"    return PyLong_FromLong(numargs);\n"
"}\n"
"\n"
"static PyMethodDef emb_module_methods[] = {\n"
"    {\"numargs\", emb_numargs, METH_VARARGS,\n"
"     \"Return the number of arguments received by the process.\"},\n"
"    {NULL, NULL, 0, NULL}\n"
"};\n"
"\n"
"static struct PyModuleDef emb_module = {\n"
"    .m_base = PyModuleDef_HEAD_INIT,\n"
"    .m_name = \"emb\",\n"
"    .m_size = 0,\n"
"    .m_methods = emb_module_methods,\n"
"};\n"
"\n"
"static PyObject*\n"
"PyInit_emb(void)\n"
"{\n"
"    return PyModuleDef_Init(&emb_module);\n"
"}"

#: ../../extending/embedding.rst:267
msgid ""
"Insert the above code just above the :c:func:`main` function. Also, insert "
"the following two statements before the call to :c:func:`Py_Initialize`::"
msgstr ""
"Insira o código acima logo acima da função :c:func:`main`. Além disso, "
"insira as duas instruções a seguir antes da chamada para :c:func:"
"`Py_Initialize`::"

#: ../../extending/embedding.rst:270
msgid ""
"numargs = argc;\n"
"PyImport_AppendInittab(\"emb\", &PyInit_emb);"
msgstr ""
"numargs = argc;\n"
"PyImport_AppendInittab(\"emb\", &PyInit_emb);"

#: ../../extending/embedding.rst:273
msgid ""
"These two lines initialize the ``numargs`` variable, and make the :func:`!"
"emb.numargs` function accessible to the embedded Python interpreter. With "
"these extensions, the Python script can do things like"
msgstr ""
"Estas duas linhas inicializam a variável ``numargs`` e tornam a função :func:"
"`!emb.numargs` acessível ao interpretador Python integrado. Com estas "
"extensões, o script Python pode fazer coisas como"

#: ../../extending/embedding.rst:277
msgid ""
"import emb\n"
"print(\"Number of arguments\", emb.numargs())"
msgstr ""
"import emb\n"
"print(\"Número de argumentos\", emb.numargs())"

#: ../../extending/embedding.rst:282
msgid ""
"In a real application, the methods will expose an API of the application to "
"Python."
msgstr ""
"Numa aplicação real, os métodos irão expor uma API da aplicação ao Python."

#: ../../extending/embedding.rst:292
msgid "Embedding Python in C++"
msgstr "Integrar Python em C++"

#: ../../extending/embedding.rst:294
msgid ""
"It is also possible to embed Python in a C++ program; precisely how this is "
"done will depend on the details of the C++ system used; in general you will "
"need to write the main program in C++, and use the C++ compiler to compile "
"and link your program.  There is no need to recompile Python itself using C+"
"+."
msgstr ""
"Também é possível integrar Python num programa C++; a forma exata como isso "
"é feito dependerá dos detalhes do sistema C++ utilizado; em geral, será "
"necessário escrever o programa principal em C++ e usar o compilador C++ para "
"compilar e ligar o seu programa. Não há necessidade de recompilar o Python "
"utilizando C++."

#: ../../extending/embedding.rst:303
msgid "Compiling and Linking under Unix-like systems"
msgstr "Compilação e ligação em sistemas semelhantes ao Unix"

#: ../../extending/embedding.rst:305
msgid ""
"It is not necessarily trivial to find the right flags to pass to your "
"compiler (and linker) in order to embed the Python interpreter into your "
"application, particularly because Python needs to load library modules "
"implemented as C dynamic extensions (:file:`.so` files) linked against it."
msgstr ""
"Não é necessariamente trivial encontrar as flags certas para passar ao seu "
"compilador (e ligador) a fim de integrar o interpretador Python na sua "
"aplicação, particularmente porque o Python precisa carregar módulos de "
"biblioteca implementados como extensões dinâmicas C (ficheiros :file:`.so`) "
"ligados a ele."

#: ../../extending/embedding.rst:311
msgid ""
"To find out the required compiler and linker flags, you can execute the :"
"file:`python{X.Y}-config` script which is generated as part of the "
"installation process (a :file:`python3-config` script may also be "
"available).  This script has several options, of which the following will be "
"directly useful to you:"
msgstr ""
"Para descobrir as flags necessárias do compilador e do vinculador, pode "
"executar o script :file:`python{X.Y}-config`, que é gerado como parte do "
"processo de instalação (um script :file:`python3-config` também pode estar "
"disponível). Este script tem várias opções, das quais as seguintes serão "
"diretamente úteis para si:"

#: ../../extending/embedding.rst:317
msgid ""
"``pythonX.Y-config --cflags`` will give you the recommended flags when "
"compiling:"
msgstr ""
"``pythonX.Y-config --cflags`` fornecerá as flags recomendadas durante a "
"compilação:"

#: ../../extending/embedding.rst:320
msgid ""
"$ /opt/bin/python3.11-config --cflags\n"
"-I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare  -DNDEBUG "
"-g -fwrapv -O3 -Wall"
msgstr ""
"$ /opt/bin/python3.11-config --cflags\n"
"-I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare  -DNDEBUG "
"-g -fwrapv -O3 -Wall"

#: ../../extending/embedding.rst:325
msgid ""
"``pythonX.Y-config --ldflags --embed`` will give you the recommended flags "
"when linking:"
msgstr ""
"``pythonX.Y-config --ldflags --embed`` fornecerá as flags recomendadas ao "
"ligar:"

#: ../../extending/embedding.rst:328
msgid ""
"$ /opt/bin/python3.11-config --ldflags --embed\n"
"-L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -"
"lpthread -ldl  -lutil -lm"
msgstr ""
"$ /opt/bin/python3.11-config --ldflags --embed\n"
"-L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -"
"lpthread -ldl  -lutil -lm"

#: ../../extending/embedding.rst:334
msgid ""
"To avoid confusion between several Python installations (and especially "
"between the system Python and your own compiled Python), it is recommended "
"that you use the absolute path to :file:`python{X.Y}-config`, as in the "
"above example."
msgstr ""
"Para evitar confusão entre várias instalações do Python (e especialmente "
"entre o Python do sistema e o seu próprio Python compilado), recomenda-se "
"que utilize o caminho absoluto para :file:`python{X.Y}-config`, como no "
"exemplo acima."

#: ../../extending/embedding.rst:339
msgid ""
"If this procedure doesn't work for you (it is not guaranteed to work for all "
"Unix-like platforms; however, we welcome :ref:`bug reports <reporting-"
"bugs>`) you will have to read your system's documentation about dynamic "
"linking and/or examine Python's :file:`Makefile` (use :func:`sysconfig."
"get_makefile_filename` to find its location) and compilation options.  In "
"this case, the :mod:`sysconfig` module is a useful tool to programmatically "
"extract the configuration values that you will want to combine together.  "
"For example:"
msgstr ""
"Se este procedimento não funcionar para si (não é garantido que funcione "
"para todas as plataformas semelhantes ao Unix; no entanto, agradecemos :ref:"
"`relatórios de erros <reporting-bugs>`), terá de ler a documentação do seu "
"sistema sobre ligações dinâmicas e/ou examinar o :file:`Makefile` do Python "
"(use :func:`sysconfig.get_makefile_filename` para encontrar a sua "
"localização) e as opções de compilação. Nesse caso, o módulo :mod:"
"`sysconfig` é uma ferramenta útil para extrair programaticamente os valores "
"de configuração que você deseja combinar. Por exemplo:"

#: ../../extending/embedding.rst:348
msgid ""
">>> import sysconfig\n"
">>> sysconfig.get_config_var('LIBS')\n"
"'-lpthread -ldl  -lutil'\n"
">>> sysconfig.get_config_var('LINKFORSHARED')\n"
"'-Xlinker -export-dynamic'"
msgstr ""
">>> import sysconfig\n"
">>> sysconfig.get_config_var('LIBS')\n"
"'-lpthread -ldl  -lutil'\n"
">>> sysconfig.get_config_var('LINKFORSHARED')\n"
"'-Xlinker -export-dynamic'"
