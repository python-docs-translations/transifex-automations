# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-29 16:28+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../extending/newtypes_tutorial.rst:7
msgid "Defining Extension Types: Tutorial"
msgstr "Definir tipos de extensão: Tutorial"

#: ../../extending/newtypes_tutorial.rst:14
msgid ""
"Python allows the writer of a C extension module to define new types that "
"can be manipulated from Python code, much like the built-in :class:`str` "
"and :class:`list` types.  The code for all extension types follows a "
"pattern, but there are some details that you need to understand before you "
"can get started.  This document is a gentle introduction to the topic."
msgstr ""
"O Python permite que o autor de um módulo de extensão em C defina novos "
"tipos que podem ser manipulados a partir de código Python, tal como os tipos "
"integrados :class:`str` e :class:`list`. O código para todos os tipos de "
"extensão segue um padrão, mas existem alguns detalhes que precisa de "
"entender antes de começar. Este documento é uma introdução suave ao tema."

#: ../../extending/newtypes_tutorial.rst:24
msgid "The Basics"
msgstr "Os Conceitos Básicos"

#: ../../extending/newtypes_tutorial.rst:26
msgid ""
"The :term:`CPython` runtime sees all Python objects as variables of type :c:"
"expr:`PyObject*`, which serves as a \"base type\" for all Python objects. "
"The :c:type:`PyObject` structure itself only contains the object's :term:"
"`reference count` and a pointer to the object's \"type object\". This is "
"where the action is; the type object determines which (C) functions get "
"called by the interpreter when, for instance, an attribute gets looked up on "
"an object, a method called, or it is multiplied by another object.  These C "
"functions are called \"type methods\"."
msgstr ""
"O runtime :term:`CPython` vê todos os objetos Python como variáveis do tipo :"
"c:expr:`PyObject*`, que serve como um \"tipo base\" para todos os objetos "
"Python. A estrutura :c:type:`PyObject` em si contém apenas a :term:`contagem "
"de referências` do objeto e um ponteiro para o \"objeto tipo\" do objeto. É "
"aqui que a ação está; o objeto tipo determina quais funções (C) são chamadas "
"pelo interpretador quando, por exemplo, um atributo é procurado num objeto, "
"um método é chamado, ou é multiplicado por outro objeto. Estas funções C são "
"chamadas \"métodos de tipo\"."

#: ../../extending/newtypes_tutorial.rst:35
msgid ""
"So, if you want to define a new extension type, you need to create a new "
"type object."
msgstr ""
"Portanto, se quiser definir um novo tipo de extensão, precisa de criar um "
"novo objeto tipo."

#: ../../extending/newtypes_tutorial.rst:38
msgid ""
"This sort of thing can only be explained by example, so here's a minimal, "
"but complete, module that defines a new type named :class:`!Custom` inside a "
"C extension module :mod:`!custom`:"
msgstr ""
"Este tipo de coisa só pode ser explicado por exemplo, então aqui está um "
"módulo mínimo, mas completo, que define um novo tipo chamado :class:`!"
"Custom` dentro de um módulo de extensão C :mod:`!custom`:"

#: ../../extending/newtypes_tutorial.rst:43
msgid ""
"What we're showing here is the traditional way of defining *static* "
"extension types.  It should be adequate for most uses.  The C API also "
"allows defining heap-allocated extension types using the :c:func:"
"`PyType_FromSpec` function, which isn't covered in this tutorial."
msgstr ""
"O que estamos a mostrar aqui é a forma tradicional de definir tipos de "
"extensão *estáticos*. Deve ser adequado para a maioria dos usos. A API C "
"também permite definir tipos de extensão alocados na heap usando a função :c:"
"func:`PyType_FromSpec`, que não é abordada neste tutorial."

#: ../../extending/newtypes_tutorial.rst:50
msgid ""
"Now that's quite a bit to take in at once, but hopefully bits will seem "
"familiar from the previous chapter.  This file defines three things:"
msgstr ""
"Agora, isto é bastante coisa para absorver de uma vez, mas esperamos que "
"algumas partes lhe pareçam familiares do capítulo anterior. Este ficheiro "
"define três coisas:"

#: ../../extending/newtypes_tutorial.rst:53
msgid ""
"What a :class:`!Custom` **object** contains: this is the ``CustomObject`` "
"struct, which is allocated once for each :class:`!Custom` instance."
msgstr ""
"O que um **objeto** :class:`!Custom` contém: esta é a estrutura "
"``CustomObject``, que é alocada uma vez para cada instância :class:`!Custom`."

#: ../../extending/newtypes_tutorial.rst:55
msgid ""
"How the :class:`!Custom` **type** behaves: this is the ``CustomType`` "
"struct, which defines a set of flags and function pointers that the "
"interpreter inspects when specific operations are requested."
msgstr ""
"Como o **tipo** :class:`!Custom` se comporta: esta é a estrutura "
"``CustomType``, que define um conjunto de flags e ponteiros de função que o "
"interpretador inspeciona quando operações específicas são solicitadas."

#: ../../extending/newtypes_tutorial.rst:58
msgid ""
"How to initialize the :mod:`!custom` module: this is the ``PyInit_custom`` "
"function and the associated ``custommodule`` struct."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:61
msgid "The first bit is::"
msgstr "A primeira parte é:"

#: ../../extending/newtypes_tutorial.rst:67
msgid ""
"This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory "
"at the start of each object struct and defines a field called ``ob_base`` of "
"type :c:type:`PyObject`, containing a pointer to a type object and a "
"reference count (these can be accessed using the macros :c:macro:`Py_TYPE` "
"and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to "
"abstract away the layout and to enable additional fields in :ref:`debug "
"builds <debug-build>`."
msgstr ""
"Isto é o que um objeto Custom conterá. ``PyObject_HEAD`` é obrigatório no "
"início de cada estrutura de objeto e define um campo chamado ``ob_base`` do "
"tipo :c:type:`PyObject`, contendo um ponteiro para um objeto tipo e uma "
"contagem de referências (estes podem ser acedidos usando as macros :c:macro:"
"`Py_TYPE` e :c:macro:`Py_REFCNT`, respetivamente). A razão para a macro é "
"abstrair o layout e permitir campos adicionais em :ref:`compilações de "
"depuração <debug-build>`."

#: ../../extending/newtypes_tutorial.rst:76
msgid ""
"There is no semicolon above after the :c:macro:`PyObject_HEAD` macro. Be "
"wary of adding one by accident: some compilers will complain."
msgstr ""
"Não há ponto e vírgula acima após a macro :c:macro:`PyObject_HEAD`. Tenha "
"cuidado para não adicionar um por engano: alguns compiladores irão reclamar."

#: ../../extending/newtypes_tutorial.rst:79
msgid ""
"Of course, objects generally store additional data besides the standard "
"``PyObject_HEAD`` boilerplate; for example, here is the definition for "
"standard Python floats::"
msgstr ""
"Claro, os objetos geralmente armazenam dados adicionais além do padrão "
"``PyObject_HEAD``; por exemplo, aqui está a definição para floats Python "
"padrão:"

#: ../../extending/newtypes_tutorial.rst:88
msgid "The second bit is the definition of the type object. ::"
msgstr "A segunda parte é a definição do objeto tipo:"

#: ../../extending/newtypes_tutorial.rst:101
msgid ""
"We recommend using C99-style designated initializers as above, to avoid "
"listing all the :c:type:`PyTypeObject` fields that you don't care about and "
"also to avoid caring about the fields' declaration order."
msgstr ""
"Recomendamos o uso de inicializadores designados no estilo C99 como acima, "
"para evitar listar todos os campos :c:type:`PyTypeObject` que não lhe "
"interessam e também para evitar preocupar-se com a ordem de declaração dos "
"campos."

#: ../../extending/newtypes_tutorial.rst:105
msgid ""
"The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has many "
"more :ref:`fields <type-structs>` than the definition above.  The remaining "
"fields will be filled with zeros by the C compiler, and it's common practice "
"to not specify them explicitly unless you need them."
msgstr ""
"A definição real de :c:type:`PyTypeObject` em :file:`object.h` tem muitos "
"mais :ref:`campos <type-structs>` do que a definição acima. Os campos "
"restantes serão preenchidos com zeros pelo compilador C, e é prática comum "
"não os especificar explicitamente, a menos que precise deles."

#: ../../extending/newtypes_tutorial.rst:110
msgid "We're going to pick it apart, one field at a time::"
msgstr "Vamos analisá-lo, campo a campo:"

#: ../../extending/newtypes_tutorial.rst:114
msgid ""
"This line is mandatory boilerplate to initialize the ``ob_base`` field "
"mentioned above. ::"
msgstr ""
"Esta linha é um código padrão obrigatório para inicializar o campo "
"``ob_base`` mencionado acima."

#: ../../extending/newtypes_tutorial.rst:119
msgid ""
"The name of our type.  This will appear in the default textual "
"representation of our objects and in some error messages, for example:"
msgstr ""
"O nome do nosso tipo. Isto aparecerá na representação textual padrão dos "
"nossos objetos e em algumas mensagens de erro, por exemplo:"

#: ../../extending/newtypes_tutorial.rst:129
msgid ""
"Note that the name is a dotted name that includes both the module name and "
"the name of the type within the module. The module in this case is :mod:`!"
"custom` and the type is :class:`!Custom`, so we set the type name to :class:"
"`!custom.Custom`. Using the real dotted import path is important to make "
"your type compatible with the :mod:`pydoc` and :mod:`pickle` modules. ::"
msgstr ""
"Note que o nome é um nome pontuado que inclui tanto o nome do módulo como o "
"nome do tipo dentro do módulo. O módulo neste caso é :mod:`!custom` e o tipo "
"é :class:`!Custom`, por isso definimos o nome do tipo como :class:`!custom."
"Custom`. Usar o caminho de importação pontuado real é importante para tornar "
"o seu tipo compatível com os módulos :mod:`pydoc` e :mod:`pickle`."

#: ../../extending/newtypes_tutorial.rst:138
msgid ""
"This is so that Python knows how much memory to allocate when creating new :"
"class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is only "
"used for variable-sized objects and should otherwise be zero."
msgstr ""
"Isto é para que o Python saiba quanto memória alocar ao criar novas "
"instâncias :class:`!Custom`. :c:member:`~PyTypeObject.tp_itemsize` é usado "
"apenas para objetos de tamanho variável e deve ser zero nos outros casos."

#: ../../extending/newtypes_tutorial.rst:144
msgid ""
"If you want your type to be subclassable from Python, and your type has the "
"same :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have "
"problems with multiple inheritance.  A Python subclass of your type will "
"have to list your type first in its :attr:`~class.__bases__`, or else it "
"will not be able to call your type's :meth:`~object.__new__` method without "
"getting an error.  You can avoid this problem by ensuring that your type has "
"a larger value for :c:member:`~PyTypeObject.tp_basicsize` than its base type "
"does.  Most of the time, this will be true anyway, because either your base "
"type will be :class:`object`, or else you will be adding data members to "
"your base type, and therefore increasing its size."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:154
msgid "We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::"
msgstr "Definimos as flags da classe para :c:macro:`Py_TPFLAGS_DEFAULT`:"

#: ../../extending/newtypes_tutorial.rst:158
msgid ""
"All types should include this constant in their flags.  It enables all of "
"the members defined until at least Python 3.3.  If you need further members, "
"you will need to OR the corresponding flags."
msgstr ""
"Todos os tipos devem incluir esta constante nas suas flags. Isto ativa todos "
"os membros definidos até pelo menos o Python 3.3. Se precisar de mais "
"membros, precisará de fazer OR com as flags correspondentes."

#: ../../extending/newtypes_tutorial.rst:162
msgid ""
"We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::"
msgstr ""
"Fornecemos uma string de documentação para o tipo em :c:member:"
"`~PyTypeObject.tp_doc`:"

#: ../../extending/newtypes_tutorial.rst:166
msgid ""
"To enable object creation, we have to provide a :c:member:`~PyTypeObject."
"tp_new` handler.  This is the equivalent of the Python method :meth:`~object."
"__new__`, but has to be specified explicitly.  In this case, we can just use "
"the default implementation provided by the API function :c:func:"
"`PyType_GenericNew`. ::"
msgstr ""
"Para permitir a criação de objetos, temos de fornecer um gestor :c:member:"
"`~PyTypeObject.tp_new`. Isto é o equivalente ao método Python :meth:`~object."
"__new__`, mas tem de ser especificado explicitamente.  Neste caso, podemos "
"simplesmente usar a implementação padrão fornecida pela função da API :c:"
"func:`PyType_GenericNew`."

#: ../../extending/newtypes_tutorial.rst:173
msgid ""
"Everything else in the file should be familiar, except for some code in :c:"
"func:`!PyInit_custom`::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:179
msgid ""
"This initializes the :class:`!Custom` type, filling in a number of members "
"to the appropriate default values, including :c:member:`~PyObject.ob_type` "
"that we initially set to ``NULL``. ::"
msgstr ""
"Isto inicializa o tipo :class:`!Custom`, preenchendo vários membros com os "
"valores padrão apropriados, incluindo :c:member:`~PyObject.ob_type` que "
"inicialmente definimos como ``NULL``."

#: ../../extending/newtypes_tutorial.rst:190
msgid ""
"This adds the type to the module dictionary.  This allows us to create :"
"class:`!Custom` instances by calling the :class:`!Custom` class:"
msgstr ""
"Isto adiciona o tipo ao dicionário do módulo. Isto permite-nos criar "
"instâncias :class:`!Custom` chamando a classe :class:`!Custom`:"

#: ../../extending/newtypes_tutorial.rst:198
msgid ""
"That's it!  All that remains is to build it; put the above code in a file "
"called :file:`custom.c` and:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:207
msgid "in a file called :file:`setup.py`; then typing"
msgstr "num ficheiro chamado :file:`setup.py`; depois digite"

#: ../../extending/newtypes_tutorial.rst:213
msgid ""
"at a shell should produce a file :file:`custom.so` in a subdirectory; move "
"to that directory and fire up Python --- you should be able to ``import "
"custom`` and play around with Custom objects."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:217
msgid "That wasn't so hard, was it?"
msgstr "Não foi tão difícil, pois não?"

#: ../../extending/newtypes_tutorial.rst:219
msgid ""
"Of course, the current Custom type is pretty uninteresting. It has no data "
"and doesn't do anything. It can't even be subclassed."
msgstr ""
"Claro, o tipo Custom atual não é muito interessante. Não tem dados e não faz "
"nada. Não pode nem ser subclassificado."

#: ../../extending/newtypes_tutorial.rst:223
msgid ""
"While this documentation showcases the standard :mod:`!distutils` module for "
"building C extensions, it is recommended in real-world use cases to use the "
"newer and better-maintained ``setuptools`` library.  Documentation on how to "
"do this is out of scope for this document and can be found in the `Python "
"Packaging User's Guide <https://packaging.python.org/tutorials/distributing-"
"packages/>`_."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:231
msgid "Adding data and methods to the Basic example"
msgstr "Adicionar dados e métodos ao exemplo básico"

#: ../../extending/newtypes_tutorial.rst:233
msgid ""
"Let's extend the basic example to add some data and methods.  Let's also "
"make the type usable as a base class. We'll create a new module, :mod:`!"
"custom2` that adds these capabilities:"
msgstr ""
"Vamos estender o exemplo básico para adicionar alguns dados e métodos. Vamos "
"também tornar o tipo utilizável como uma classe base. Vamos criar um novo "
"módulo, :mod:`!custom2`, que adiciona estas capacidades:"

#: ../../extending/newtypes_tutorial.rst:240
msgid "This version of the module has a number of changes."
msgstr "Esta versão do módulo tem várias alterações."

#: ../../extending/newtypes_tutorial.rst:242
msgid "We've added an extra include::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:246
msgid ""
"This include provides declarations that we use to handle attributes, as "
"described a bit later."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:249
msgid ""
"The  :class:`!Custom` type now has three data attributes in its C struct, "
"*first*, *last*, and *number*.  The *first* and *last* variables are Python "
"strings containing first and last names.  The *number* attribute is a C "
"integer."
msgstr ""
"O tipo :class:`!Custom` agora tem três atributos de dados na sua estrutura "
"C, *first*, *last*, e *number*. As variáveis *first* e *last* são strings "
"Python que contêm o primeiro e último nomes. O atributo *number* é um "
"inteiro C."

#: ../../extending/newtypes_tutorial.rst:253
msgid "The object structure is updated accordingly::"
msgstr "A estrutura do objeto é atualizada de acordo:"

#: ../../extending/newtypes_tutorial.rst:262
msgid ""
"Because we now have data to manage, we have to be more careful about object "
"allocation and deallocation.  At a minimum, we need a deallocation method::"
msgstr ""
"Como agora temos dados para gerir, temos de ser mais cuidadosos com a "
"alocação e desalocação de objetos. No mínimo, precisamos de um método de "
"desalocação:"

#: ../../extending/newtypes_tutorial.rst:273
msgid "which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::"
msgstr "que é atribuído ao membro :c:member:`~PyTypeObject.tp_dealloc`:"

#: ../../extending/newtypes_tutorial.rst:277
msgid ""
"This method first clears the reference counts of the two Python attributes. :"
"c:func:`Py_XDECREF` correctly handles the case where its argument is "
"``NULL`` (which might happen here if ``tp_new`` failed midway).  It then "
"calls the :c:member:`~PyTypeObject.tp_free` member of the object's type "
"(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that the "
"object's type might not be :class:`!CustomType`, because the object may be "
"an instance of a subclass."
msgstr ""
"Este método primeiro limpa as contagens de referência dos dois atributos "
"Python. :c:func:`Py_XDECREF` trata corretamente o caso em que o seu "
"argumento é ``NULL`` (o que pode acontecer aqui se ``tp_new`` falhar a "
"meio). Depois, chama o membro :c:member:`~PyTypeObject.tp_free` do tipo do "
"objeto (calculado por ``Py_TYPE(self)``) para libertar a memória do objeto. "
"Note que o tipo do objeto pode não ser :class:`!CustomType`, porque o objeto "
"pode ser uma instância de uma subclasse."

#: ../../extending/newtypes_tutorial.rst:286
msgid ""
"The explicit cast to ``destructor`` above is needed because we defined "
"``Custom_dealloc`` to take a ``CustomObject *`` argument, but the "
"``tp_dealloc`` function pointer expects to receive a ``PyObject *`` "
"argument.  Otherwise, the compiler will emit a warning.  This is object-"
"oriented polymorphism, in C!"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:292
msgid ""
"We want to make sure that the first and last names are initialized to empty "
"strings, so we provide a ``tp_new`` implementation::"
msgstr ""
"Queremos garantir que os primeiros e últimos nomes são inicializados para "
"strings vazias, por isso fornecemos uma implementação ``tp_new``:"

#: ../../extending/newtypes_tutorial.rst:316
msgid "and install it in the :c:member:`~PyTypeObject.tp_new` member::"
msgstr "e instalá-lo no membro :c:member:`~PyTypeObject.tp_new`:"

#: ../../extending/newtypes_tutorial.rst:320
msgid ""
"The ``tp_new`` handler is responsible for creating (as opposed to "
"initializing) objects of the type.  It is exposed in Python as the :meth:"
"`~object.__new__` method. It is not required to define a ``tp_new`` member, "
"and indeed many extension types will simply reuse :c:func:"
"`PyType_GenericNew` as done in the first version of the :class:`!Custom` "
"type above.  In this case, we use the ``tp_new`` handler to initialize the "
"``first`` and ``last`` attributes to non-``NULL`` default values."
msgstr ""
"O gestor ``tp_new`` é responsável por criar (em oposição a inicializar) "
"objetos do tipo. É exposto em Python como o método :meth:`~object.__new__`. "
"Não é obrigatório definir um membro ``tp_new``, e de facto muitos tipos de "
"extensão simplesmente reutilizam :c:func:`PyType_GenericNew` como feito na "
"primeira versão do tipo :class:`!Custom` acima. Neste caso, usamos o gestor "
"``tp_new`` para inicializar os atributos ``first`` e ``last`` com valores "
"padrão não-``NULL``."

#: ../../extending/newtypes_tutorial.rst:328
msgid ""
"``tp_new`` is passed the type being instantiated (not necessarily "
"``CustomType``, if a subclass is instantiated) and any arguments passed when "
"the type was called, and is expected to return the instance created.  "
"``tp_new`` handlers always accept positional and keyword arguments, but they "
"often ignore the arguments, leaving the argument handling to initializer (a."
"k.a. ``tp_init`` in C or ``__init__`` in Python) methods."
msgstr ""
"``tp_new`` recebe o tipo que está a ser instanciado (não necessariamente "
"``CustomType``, se uma subclasse for instanciada) e quaisquer argumentos "
"passados quando o tipo foi chamado, e espera-se que retorne a instância "
"criada. Os gestores ``tp_new`` sempre aceitam argumentos posicionais e de "
"palavra-chave, mas muitas vezes ignoram os argumentos, deixando o tratamento "
"dos argumentos para os métodos de inicialização (também conhecidos como "
"``tp_init`` em C ou ``__init__`` em Python)."

#: ../../extending/newtypes_tutorial.rst:336
msgid ""
"``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter will do "
"it itself."
msgstr ""
"``tp_new`` não deve chamar ``tp_init`` explicitamente, pois o interpretador "
"fará isso."

#: ../../extending/newtypes_tutorial.rst:339
msgid ""
"The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc` "
"slot to allocate memory::"
msgstr ""
"A implementação ``tp_new`` chama o slot :c:member:`~PyTypeObject.tp_alloc` "
"para alocar memória:"

#: ../../extending/newtypes_tutorial.rst:344
msgid ""
"Since memory allocation may fail, we must check the :c:member:`~PyTypeObject."
"tp_alloc` result against ``NULL`` before proceeding."
msgstr ""
"Como a alocação de memória pode falhar, devemos verificar o resultado :c:"
"member:`~PyTypeObject.tp_alloc` contra ``NULL`` antes de prosseguir."

#: ../../extending/newtypes_tutorial.rst:348
msgid ""
"We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. "
"Rather :c:func:`PyType_Ready` fills it for us by inheriting it from our base "
"class, which is :class:`object` by default.  Most types use the default "
"allocation strategy."
msgstr ""
"Não preenchemos o slot :c:member:`~PyTypeObject.tp_alloc` nós mesmos. Em vez "
"disso, :c:func:`PyType_Ready` preenche-o para nós herdando-o da nossa classe "
"base, que por defeito é :class:`object`. A maioria dos tipos usa a "
"estratégia de alocação padrão."

#: ../../extending/newtypes_tutorial.rst:354
msgid ""
"If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one "
"that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`~object."
"__new__`), you must *not* try to determine what method to call using method "
"resolution order at runtime.  Always statically determine what type you are "
"going to call, and call its :c:member:`~PyTypeObject.tp_new` directly, or "
"via ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of "
"your type that also inherit from other Python-defined classes may not work "
"correctly. (Specifically, you may not be able to create instances of such "
"subclasses without getting a :exc:`TypeError`.)"
msgstr ""
"Se estiver a criar um :c:member:`~PyTypeObject.tp_new` cooperativo (um que "
"chama o :c:member:`~PyTypeObject.tp_new` de um tipo base ou :meth:`~object."
"__new__`), não deve tentar determinar que método chamar usando a ordem de "
"resolução de métodos em tempo de execução. Deve sempre determinar "
"estaticamente que tipo vai chamar, e chamar o seu :c:member:`~PyTypeObject."
"tp_new` diretamente, ou via ``type->tp_base->tp_new``. Se não o fizer, "
"subclasses Python do seu tipo que também herdam de outras classes definidas "
"em Python podem não funcionar corretamente. (Especificamente, pode não ser "
"capaz de criar instâncias de tais subclasses sem obter um :exc:`TypeError`.)"

#: ../../extending/newtypes_tutorial.rst:364
msgid ""
"We also define an initialization function which accepts arguments to provide "
"initial values for our instance::"
msgstr ""
"Também definimos uma função de inicialização que aceita argumentos para "
"fornecer valores iniciais para a nossa instância:"

#: ../../extending/newtypes_tutorial.rst:393
msgid "by filling the :c:member:`~PyTypeObject.tp_init` slot. ::"
msgstr "preenchendo o slot :c:member:`~PyTypeObject.tp_init`:"

#: ../../extending/newtypes_tutorial.rst:397
msgid ""
"The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the :meth:"
"`~object.__init__` method.  It is used to initialize an object after it's "
"created.  Initializers always accept positional and keyword arguments, and "
"they should return either ``0`` on success or ``-1`` on error."
msgstr ""
"O slot :c:member:`~PyTypeObject.tp_init` é exposto em Python como o método :"
"meth:`~object.__init__`. É usado para inicializar um objeto depois de "
"criado. Os inicializadores sempre aceitam argumentos posicionais e de "
"palavra-chave, e devem retornar ``0`` em caso de sucesso ou ``-1`` em caso "
"de erro."

#: ../../extending/newtypes_tutorial.rst:402
msgid ""
"Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init`` is "
"called at all (for example, the :mod:`pickle` module by default doesn't "
"call :meth:`~object.__init__` on unpickled instances).  It can also be "
"called multiple times.  Anyone can call the :meth:`!__init__` method on our "
"objects.  For this reason, we have to be extra careful when assigning the "
"new attribute values.  We might be tempted, for example to assign the "
"``first`` member like this::"
msgstr ""
"Ao contrário do gestor ``tp_new``, não há garantia de que ``tp_init`` seja "
"chamado (por exemplo, o módulo :mod:`pickle` por defeito não chama :meth:"
"`~object.__init__` em instâncias deserializadas). Também pode ser chamado "
"múltiplas vezes. Qualquer pessoa pode chamar o método :meth:`!__init__` nos "
"nossos objetos. Por esta razão, temos de ser especialmente cuidadosos ao "
"atribuir os novos valores dos atributos. Podemos ser tentados, por exemplo, "
"a atribuir o membro ``first`` assim:"

#: ../../extending/newtypes_tutorial.rst:416
msgid ""
"But this would be risky.  Our type doesn't restrict the type of the "
"``first`` member, so it could be any kind of object.  It could have a "
"destructor that causes code to be executed that tries to access the "
"``first`` member; or that destructor could release the :term:`Global "
"interpreter Lock <GIL>` and let arbitrary code run in other threads that "
"accesses and modifies our object."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:423
msgid ""
"To be paranoid and protect ourselves against this possibility, we almost "
"always reassign members before decrementing their reference counts.  When "
"don't we have to do this?"
msgstr ""
"Para sermos paranoicos e nos protegermos contra esta possibilidade, quase "
"sempre reatribuímos membros antes de decrementar as suas contagens de "
"referência. Quando não precisamos de fazer isto?"

#: ../../extending/newtypes_tutorial.rst:427
msgid "when we absolutely know that the reference count is greater than 1;"
msgstr ""
"quando sabemos absolutamente que a contagem de referência é maior que 1;"

#: ../../extending/newtypes_tutorial.rst:429
msgid ""
"when we know that deallocation of the object [#]_ will neither release the :"
"term:`GIL` nor cause any calls back into our type's code;"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:432
msgid ""
"when decrementing a reference count in a :c:member:`~PyTypeObject."
"tp_dealloc` handler on a type which doesn't support cyclic garbage "
"collection [#]_."
msgstr ""
"quando decrementamos uma contagem de referência num gestor :c:member:"
"`~PyTypeObject.tp_dealloc` de um tipo que não suporta recolha de lixo "
"cíclica [#]_."

#: ../../extending/newtypes_tutorial.rst:435
msgid ""
"We want to expose our instance variables as attributes. There are a number "
"of ways to do that. The simplest way is to define member definitions::"
msgstr ""
"Queremos expor as nossas variáveis de instância como atributos. Há várias "
"formas de fazer isso. A forma mais simples é definir definições de membros:"

#: ../../extending/newtypes_tutorial.rst:448
msgid ""
"and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::"
msgstr "e colocar as definições no slot :c:member:`~PyTypeObject.tp_members`:"

#: ../../extending/newtypes_tutorial.rst:452
msgid ""
"Each member definition has a member name, type, offset, access flags and "
"documentation string.  See the :ref:`Generic-Attribute-Management` section "
"below for details."
msgstr ""
"Cada definição de membro tem um nome de membro, tipo, deslocamento, flags de "
"acesso e string de documentação. Veja a secção :ref:`Generic-Attribute-"
"Management` abaixo para mais detalhes."

#: ../../extending/newtypes_tutorial.rst:456
msgid ""
"A disadvantage of this approach is that it doesn't provide a way to restrict "
"the types of objects that can be assigned to the Python attributes.  We "
"expect the first and last names to be strings, but any Python objects can be "
"assigned. Further, the attributes can be deleted, setting the C pointers to "
"``NULL``.  Even though we can make sure the members are initialized to non-"
"``NULL`` values, the members can be set to ``NULL`` if the attributes are "
"deleted."
msgstr ""
"Uma desvantagem desta abordagem é que não fornece uma forma de restringir os "
"tipos de objetos que podem ser atribuídos aos atributos Python. Esperamos "
"que os primeiros e últimos nomes sejam strings, mas qualquer objeto Python "
"pode ser atribuído. Além disso, os atributos podem ser apagados, definindo "
"os ponteiros C para ``NULL``. Mesmo que possamos garantir que os membros são "
"inicializados com valores não-``NULL``, os membros podem ser definidos para "
"``NULL`` se os atributos forem apagados."

#: ../../extending/newtypes_tutorial.rst:463
msgid ""
"We define a single method, :meth:`!Custom.name()`, that outputs the objects "
"name as the concatenation of the first and last names. ::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:480
msgid ""
"The method is implemented as a C function that takes a :class:`!Custom` (or :"
"class:`!Custom` subclass) instance as the first argument.  Methods always "
"take an instance as the first argument. Methods often take positional and "
"keyword arguments as well, but in this case we don't take any and don't need "
"to accept a positional argument tuple or keyword argument dictionary. This "
"method is equivalent to the Python method:"
msgstr ""
"O método é implementado como uma função C que recebe uma instância :class:`!"
"Custom` (ou uma subclasse de :class:`!Custom`) como primeiro argumento. Os "
"métodos sempre recebem uma instância como primeiro argumento. Os métodos "
"muitas vezes também aceitam argumentos posicionais e de palavra-chave, mas "
"neste caso não aceitamos nenhum e não precisamos de aceitar uma tupla de "
"argumentos posicionais ou um dicionário de argumentos de palavra-chave. Este "
"método é equivalente ao método Python:"

#: ../../extending/newtypes_tutorial.rst:492
msgid ""
"Note that we have to check for the possibility that our :attr:`!first` and :"
"attr:`!last` members are ``NULL``.  This is because they can be deleted, in "
"which case they are set to ``NULL``.  It would be better to prevent deletion "
"of these attributes and to restrict the attribute values to be strings.  "
"We'll see how to do that in the next section."
msgstr ""
"Note que temos de verificar a possibilidade de os nossos membros :attr:`!"
"first` e :attr:`!last` serem ``NULL``. Isto acontece porque podem ser "
"apagados, caso em que são definidos como ``NULL``. Seria melhor prevenir a "
"eliminação destes atributos e restringir os valores dos atributos a serem "
"strings. Veremos como fazer isso na próxima secção."

#: ../../extending/newtypes_tutorial.rst:498
msgid ""
"Now that we've defined the method, we need to create an array of method "
"definitions::"
msgstr ""
"Agora que definimos o método, precisamos de criar um array de definições de "
"métodos:"

#: ../../extending/newtypes_tutorial.rst:508
msgid ""
"(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the "
"method is expecting no arguments other than *self*)"
msgstr ""
"(note que usámos a flag :c:macro:`METH_NOARGS` para indicar que o método não "
"espera argumentos além de *self*)"

#: ../../extending/newtypes_tutorial.rst:511
msgid "and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::"
msgstr "e atribuí-lo ao slot :c:member:`~PyTypeObject.tp_methods`:"

#: ../../extending/newtypes_tutorial.rst:515
msgid ""
"Finally, we'll make our type usable as a base class for subclassing.  We've "
"written our methods carefully so far so that they don't make any assumptions "
"about the type of the object being created or used, so all we need to do is "
"to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::"
msgstr ""
"Finalmente, vamos tornar o nosso tipo utilizável como uma classe base para "
"subclassificação. Escrevemos os nossos métodos com cuidado até agora, de "
"modo a que não façam quaisquer suposições sobre o tipo do objeto que está a "
"ser criado ou usado, por isso tudo o que precisamos de fazer é adicionar a "
"macro :c:macro:`Py_TPFLAGS_BASETYPE` à definição das flags da nossa classe:"

#: ../../extending/newtypes_tutorial.rst:522
msgid ""
"We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update the "
"module name in the :c:type:`PyModuleDef` struct, and update the full class "
"name in the :c:type:`PyTypeObject` struct."
msgstr ""
"Renomeamos :c:func:`!PyInit_custom` para :c:func:`!PyInit_custom2`, "
"atualizamos o nome do módulo na estrutura :c:type:`PyModuleDef`, e "
"atualizamos o nome completo da classe na estrutura :c:type:`PyTypeObject`."

#: ../../extending/newtypes_tutorial.rst:526
msgid "Finally, we update our :file:`setup.py` file to build the new module:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:539
msgid "Providing finer control over data attributes"
msgstr "Fornecer um controlo mais refinado sobre os atributos de dados"

#: ../../extending/newtypes_tutorial.rst:541
msgid ""
"In this section, we'll provide finer control over how the :attr:`!first` "
"and :attr:`!last` attributes are set in the :class:`!Custom` example. In the "
"previous version of our module, the instance variables :attr:`!first` and :"
"attr:`!last` could be set to non-string values or even deleted. We want to "
"make sure that these attributes always contain strings."
msgstr ""
"Nesta secção, vamos fornecer um controlo mais refinado sobre como os "
"atributos :attr:`!first` e :attr:`!last` são definidos no exemplo :class:`!"
"Custom`. Na versão anterior do nosso módulo, as variáveis de instância :attr:"
"`!first` e :attr:`!last` podiam ser definidas para valores não-string ou até "
"apagadas. Queremos garantir que estes atributos contenham sempre strings."

#: ../../extending/newtypes_tutorial.rst:550
msgid ""
"To provide greater control, over the :attr:`!first` and :attr:`!last` "
"attributes, we'll use custom getter and setter functions.  Here are the "
"functions for getting and setting the :attr:`!first` attribute::"
msgstr ""
"Para fornecer um controlo mais refinado sobre os atributos :attr:`!first` e :"
"attr:`!last`, vamos usar funções personalizadas de getter e setter. Aqui "
"estão as funções para obter e definir o atributo :attr:`!first`:"

#: ../../extending/newtypes_tutorial.rst:581
msgid ""
"The getter function is passed a :class:`!Custom` object and a \"closure\", "
"which is a void pointer.  In this case, the closure is ignored.  (The "
"closure supports an advanced usage in which definition data is passed to the "
"getter and setter. This could, for example, be used to allow a single set of "
"getter and setter functions that decide the attribute to get or set based on "
"data in the closure.)"
msgstr ""
"A função getter recebe um objeto :class:`!Custom` e um \"closure\", que é um "
"ponteiro void. Neste caso, o closure é ignorado. (O closure suporta um uso "
"avançado em que dados de definição são passados para o getter e setter. Isto "
"poderia, por exemplo, ser usado para permitir um único conjunto de funções "
"getter e setter que decidem o atributo a obter ou definir com base em dados "
"no closure.)"

#: ../../extending/newtypes_tutorial.rst:587
msgid ""
"The setter function is passed the :class:`!Custom` object, the new value, "
"and the closure.  The new value may be ``NULL``, in which case the attribute "
"is being deleted.  In our setter, we raise an error if the attribute is "
"deleted or if its new value is not a string."
msgstr ""
"A função setter recebe o objeto :class:`!Custom`, o novo valor, e o closure. "
"O novo valor pode ser ``NULL``, caso em que o atributo está a ser apagado. "
"No nosso setter, lançamos um erro se o atributo for apagado ou se o seu novo "
"valor não for uma string."

#: ../../extending/newtypes_tutorial.rst:592
msgid "We create an array of :c:type:`PyGetSetDef` structures::"
msgstr "Criamos um array de estruturas :c:type:`PyGetSetDef`:"

#: ../../extending/newtypes_tutorial.rst:602
msgid "and register it in the :c:member:`~PyTypeObject.tp_getset` slot::"
msgstr "e registá-lo no slot :c:member:`~PyTypeObject.tp_getset`:"

#: ../../extending/newtypes_tutorial.rst:606
msgid ""
"The last item in a :c:type:`PyGetSetDef` structure is the \"closure\" "
"mentioned above.  In this case, we aren't using a closure, so we just pass "
"``NULL``."
msgstr ""
"O último item numa estrutura :c:type:`PyGetSetDef` é o \"closure\" "
"mencionado acima. Neste caso, não estamos a usar um closure, por isso "
"passamos simplesmente ``NULL``."

#: ../../extending/newtypes_tutorial.rst:609
msgid "We also remove the member definitions for these attributes::"
msgstr "Também removemos as definições de membros para estes atributos:"

#: ../../extending/newtypes_tutorial.rst:617
msgid ""
"We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only "
"allow strings [#]_ to be passed::"
msgstr ""
"Também precisamos de atualizar o gestor :c:member:`~PyTypeObject.tp_init` "
"para permitir apenas que strings [#]_ sejam passadas:"

#: ../../extending/newtypes_tutorial.rst:646
msgid ""
"With these changes, we can assure that the ``first`` and ``last`` members "
"are never ``NULL`` so we can remove checks for ``NULL`` values in almost all "
"cases. This means that most of the :c:func:`Py_XDECREF` calls can be "
"converted to :c:func:`Py_DECREF` calls.  The only place we can't change "
"these calls is in the ``tp_dealloc`` implementation, where there is the "
"possibility that the initialization of these members failed in ``tp_new``."
msgstr ""
"Com estas alterações, podemos garantir que os membros ``first`` e ``last`` "
"nunca são ``NULL``, por isso podemos remover as verificações de valores "
"``NULL`` em quase todos os casos. Isto significa que a maioria das chamadas :"
"c:func:`Py_XDECREF` podem ser convertidas em chamadas :c:func:`Py_DECREF`. O "
"único local onde não podemos alterar estas chamadas é na implementação de "
"``tp_dealloc``, onde existe a possibilidade de a inicialização destes "
"membros ter falhado em ``tp_new``."

#: ../../extending/newtypes_tutorial.rst:653
msgid ""
"We also rename the module initialization function and module name in the "
"initialization function, as we did before, and we add an extra definition to "
"the :file:`setup.py` file."
msgstr ""
"Também renomeamos a função de inicialização do módulo e o nome do módulo na "
"função de inicialização, como fizemos antes, e adicionamos uma definição "
"extra ao ficheiro :file:`setup.py`."

#: ../../extending/newtypes_tutorial.rst:659
msgid "Supporting cyclic garbage collection"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:661
msgid ""
"Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that "
"can identify unneeded objects even when their reference counts are not zero. "
"This can happen when objects are involved in cycles.  For example, consider:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:671
msgid ""
"In this example, we create a list that contains itself. When we delete it, "
"it still has a reference from itself. Its reference count doesn't drop to "
"zero. Fortunately, Python's cyclic garbage collector will eventually figure "
"out that the list is garbage and free it."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:676
msgid ""
"In the second version of the :class:`!Custom` example, we allowed any kind "
"of object to be stored in the :attr:`!first` or :attr:`!last` attributes "
"[#]_. Besides, in the second and third versions, we allowed subclassing :"
"class:`!Custom`, and subclasses may add arbitrary attributes.  For any of "
"those two reasons, :class:`!Custom` objects can participate in cycles:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:690
msgid ""
"To allow a :class:`!Custom` instance participating in a reference cycle to "
"be properly detected and collected by the cyclic GC, our :class:`!Custom` "
"type needs to fill two additional slots and to enable a flag that enables "
"these slots:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:697
msgid ""
"First, the traversal method lets the cyclic GC know about subobjects that "
"could participate in cycles::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:717
msgid ""
"For each subobject that can participate in cycles, we need to call the :c:"
"func:`!visit` function, which is passed to the traversal method. The :c:func:"
"`!visit` function takes as arguments the subobject and the extra argument "
"*arg* passed to the traversal method.  It returns an integer value that must "
"be returned if it is non-zero."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:723
msgid ""
"Python provides a :c:func:`Py_VISIT` macro that automates calling visit "
"functions.  With :c:func:`Py_VISIT`, we can minimize the amount of "
"boilerplate in ``Custom_traverse``::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:736
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` implementation must name its "
"arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:739
msgid ""
"Second, we need to provide a method for clearing any subobjects that can "
"participate in cycles::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:750
msgid ""
"Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and "
"safe way to clear data attributes of arbitrary types while decrementing "
"their reference counts.  If you were to call :c:func:`Py_XDECREF` instead on "
"the attribute before setting it to ``NULL``, there is a possibility that the "
"attribute's destructor would call back into code that reads the attribute "
"again (*especially* if there is a reference cycle)."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:758
msgid "You could emulate :c:func:`Py_CLEAR` by writing::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:765
msgid ""
"Nevertheless, it is much easier and less error-prone to always use :c:func:"
"`Py_CLEAR` when deleting an attribute.  Don't try to micro-optimize at the "
"expense of robustness!"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:769
msgid ""
"The deallocator ``Custom_dealloc`` may call arbitrary code when clearing "
"attributes.  It means the circular GC can be triggered inside the function. "
"Since the GC assumes reference count is not zero, we need to untrack the "
"object from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing "
"members. Here is our reimplemented deallocator using :c:func:"
"`PyObject_GC_UnTrack` and ``Custom_clear``::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:784
msgid ""
"Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:788
msgid ""
"That's pretty much it.  If we had written custom :c:member:`~PyTypeObject."
"tp_alloc` or :c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify "
"them for cyclic garbage collection.  Most extensions will use the versions "
"automatically provided."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:794
msgid "Subclassing other types"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:796
msgid ""
"It is possible to create new extension types that are derived from existing "
"types. It is easiest to inherit from the built in types, since an extension "
"can easily use the :c:type:`PyTypeObject` it needs. It can be difficult to "
"share these :c:type:`PyTypeObject` structures between extension modules."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:801
msgid ""
"In this example we will create a :class:`!SubList` type that inherits from "
"the built-in :class:`list` type. The new type will be completely compatible "
"with regular lists, but will have an additional :meth:`!increment` method "
"that increases an internal counter:"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:821
msgid ""
"As you can see, the source code closely resembles the :class:`!Custom` "
"examples in previous sections. We will break down the main differences "
"between them. ::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:829
msgid ""
"The primary difference for derived type objects is that the base type's "
"object structure must be the first value.  The base type will already "
"include the :c:func:`PyObject_HEAD` at the beginning of its structure."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:833
msgid ""
"When a Python object is a :class:`!SubList` instance, its ``PyObject *`` "
"pointer can be safely cast to both ``PyListObject *`` and ``SubListObject "
"*``::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:845
msgid ""
"We see above how to call through to the :meth:`~object.__init__` method of "
"the base type."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:848
msgid ""
"This pattern is important when writing a type with custom :c:member:"
"`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc` members.  "
"The :c:member:`~PyTypeObject.tp_new` handler should not actually create the "
"memory for the object with its :c:member:`~PyTypeObject.tp_alloc`, but let "
"the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:854
msgid ""
"The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject."
"tp_base` specifying the type's concrete base class.  Due to cross-platform "
"compiler issues, you can't fill that field directly with a reference to :c:"
"type:`PyList_Type`; it should be done later in the module initialization "
"function::"
msgstr ""

#: ../../extending/newtypes_tutorial.rst:882
msgid ""
"Before calling :c:func:`PyType_Ready`, the type structure must have the :c:"
"member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an "
"existing type, it is not necessary to fill out the :c:member:`~PyTypeObject."
"tp_alloc` slot with :c:func:`PyType_GenericNew` -- the allocation function "
"from the base type will be inherited."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:888
msgid ""
"After that, calling :c:func:`PyType_Ready` and adding the type object to the "
"module is the same as with the basic :class:`!Custom` examples."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:893
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../extending/newtypes_tutorial.rst:894
msgid ""
"This is true when we know that the object is a basic type, like a string or "
"a float."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:897
msgid ""
"We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler in "
"this example, because our type doesn't support garbage collection."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:900
msgid ""
"We now know that the first and last members are strings, so perhaps we could "
"be less careful about decrementing their reference counts, however, we "
"accept instances of string subclasses.  Even though deallocating normal "
"strings won't call back into our objects, we can't guarantee that "
"deallocating an instance of a string subclass won't call back into our "
"objects."
msgstr ""

#: ../../extending/newtypes_tutorial.rst:906
msgid ""
"Also, even with our attributes restricted to strings instances, the user "
"could pass arbitrary :class:`str` subclasses and therefore still create "
"reference cycles."
msgstr ""
