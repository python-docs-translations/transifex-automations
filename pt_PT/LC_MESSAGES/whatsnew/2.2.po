# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-03 14:13+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../whatsnew/2.2.rst:3
msgid "What's New in Python 2.2"
msgstr "Novidades do Python 2.2"

#: ../../whatsnew/2.2.rst:0
msgid "Author"
msgstr "Autor"

#: ../../whatsnew/2.2.rst:5
msgid "A.M. Kuchling"
msgstr "A.M. Kuchling"

#: ../../whatsnew/2.2.rst:13
msgid "Introduction"
msgstr "Introdução"

#: ../../whatsnew/2.2.rst:15
msgid ""
"This article explains the new features in Python 2.2.2, released on October "
"14, 2002.  Python 2.2.2 is a bugfix release of Python 2.2, originally "
"released on December 21, 2001."
msgstr ""
"Este artigo explica as novas funcionalidades do Python 2.2.2, lançado a 14 "
"de outubro de 2002. O Python 2.2.2 é uma versão de correção de *bugs* do "
"Python 2.2, originalmente lançado a 21 de dezembro de 2001."

#: ../../whatsnew/2.2.rst:19
msgid ""
"Python 2.2 can be thought of as the \"cleanup release\".  There are some "
"features such as generators and iterators that are completely new, but most "
"of the changes, significant and far-reaching though they may be, are aimed "
"at cleaning up irregularities and dark corners of the language design."
msgstr ""
"O Python 2.2 pode ser considerado como a versão de \"limpeza\". Existem "
"algumas funcionalidades, como geradores e iteradores, que são completamente "
"novas, mas a maioria das alterações, embora significativas e abrangentes, "
"visam limpar irregularidades e aspectos obscuros do projeto da linguagem."

#: ../../whatsnew/2.2.rst:24
msgid ""
"This article doesn't attempt to provide a complete specification of the new "
"features, but instead provides a convenient overview.  For full details, you "
"should refer to the documentation for Python 2.2, such as the `Python "
"Library Reference <https://docs.python.org/2.2/lib/lib.html>`_ and the "
"`Python Reference Manual <https://docs.python.org/2.2/ref/ref.html>`_.  If "
"you want to understand the complete implementation and design rationale for "
"a change, refer to the PEP for a particular new feature."
msgstr ""
"Este artigo não tenta fornecer uma especificação completa das novas "
"funcionalidades, mas oferece uma visão geral conveniente. Para detalhes "
"completos, deve consultar a documentação do Python 2.2, como a `Referência "
"da Biblioteca Python <https://docs.python.org/2.2/lib/lib.html>`_ e o "
"`Manual de Referência do Python <https://docs.python.org/2.2/ref/ref."
"html>`_. Se pretender compreender a implementação completa e a justificação "
"de projeto de uma alteração, consulte o PEP da funcionalidade em questão."

#: ../../whatsnew/2.2.rst:43
msgid "PEPs 252 and 253: Type and Class Changes"
msgstr "PEPs 252 e 253: Alterações a Tipos e Classes"

#: ../../whatsnew/2.2.rst:45
msgid ""
"The largest and most far-reaching changes in Python 2.2 are to Python's "
"model of objects and classes.  The changes should be backward compatible, so "
"it's likely that your code will continue to run unchanged, but the changes "
"provide some amazing new capabilities. Before beginning this, the longest "
"and most complicated section of this article, I'll provide an overview of "
"the changes and offer some comments."
msgstr ""
"As maiores e mais abrangentes alterações no Python 2.2 são ao modelo de "
"objetos e classes. As alterações devem ser retrocompatíveis, pelo que é "
"provável que o seu código continue a funcionar sem alterações, mas as "
"alterações fornecem algumas capacidades novas incríveis. Antes de começar "
"esta secção, a mais longa e complexa deste artigo, vou fornecer uma visão "
"geral das alterações e fazer alguns comentários."

#: ../../whatsnew/2.2.rst:52
msgid ""
"A long time ago I wrote a web page listing flaws in Python's design.  One of "
"the most significant flaws was that it's impossible to subclass Python types "
"implemented in C.  In particular, it's not possible to subclass built-in "
"types, so you can't just subclass, say, lists in order to add a single "
"useful method to them. The :mod:`!UserList` module provides a class that "
"supports all of the methods of lists and that can be subclassed further, but "
"there's lots of C code that expects a regular Python list and won't accept "
"a :class:`~collections.UserList` instance."
msgstr ""
"Há muito tempo, escrevi uma página web que listava falhas no projeto do "
"Python. Uma das falhas mais significativas era a impossibilidade de criar "
"subclasses de tipos Python implementados em C. Em particular, não era "
"possível criar subclasses de tipos integrados, pelo que não era possível, "
"por exemplo, criar subclasses de listas para adicionar um único método útil. "
"O módulo :mod:`!UserList` fornece uma classe que suporta todos os métodos de "
"listas e que pode ser subclassificada, mas existe muito código em C que "
"espera uma lista Python normal e não aceita uma instância de :class:"
"`~collections.UserList`."

#: ../../whatsnew/2.2.rst:61
msgid ""
"Python 2.2 fixes this, and in the process adds some exciting new "
"capabilities. A brief summary:"
msgstr ""
"O Python 2.2 resolve isto e, no processo, adiciona algumas capacidades novas "
"e empolgantes. Um breve resumo:"

#: ../../whatsnew/2.2.rst:64
msgid ""
"You can subclass built-in types such as lists and even integers, and your "
"subclasses should work in every place that requires the original type."
msgstr ""
"Pode criar subclasses de tipos integrados, como listas e até inteiros, e as "
"suas subclasses devem funcionar em todos os locais que requerem o tipo "
"original."

#: ../../whatsnew/2.2.rst:67
msgid ""
"It's now possible to define static and class methods, in addition to the "
"instance methods available in previous versions of Python."
msgstr ""
"Agora é possível definir métodos estáticos e de classe, além dos métodos de "
"instância disponíveis em versões anteriores do Python."

#: ../../whatsnew/2.2.rst:70
msgid ""
"It's also possible to automatically call methods on accessing or setting an "
"instance attribute by using a new mechanism called :dfn:`properties`.  Many "
"uses of :meth:`~object.__getattr__` can be rewritten to use properties "
"instead, making the resulting code simpler and faster.  As a small side "
"benefit, attributes can now have docstrings, too."
msgstr ""
"Também é possível chamar automaticamente métodos ao aceder ou definir um "
"atributo de instância usando um novo mecanismo chamado :dfn:`propriedades`. "
"Muitos usos de :meth:`~object.__getattr__` podem ser reescritos para usar "
"propriedades, tornando o código resultante mais simples e rápido. Como "
"benefício adicional, os atributos também podem ter *docstrings*."

#: ../../whatsnew/2.2.rst:76
msgid ""
"The list of legal attributes for an instance can be limited to a particular "
"set using :dfn:`slots`, making it possible to safeguard against typos and "
"perhaps make more optimizations possible in future versions of Python."
msgstr ""
"A lista de atributos legais para uma instância pode ser limitada a um "
"conjunto específico usando :dfn:`slots`, tornando possível proteger contra "
"erros de digitação e possibilitar mais otimizações em versões futuras do "
"Python."

#: ../../whatsnew/2.2.rst:80
msgid ""
"Some users have voiced concern about all these changes.  Sure, they say, the "
"new features are neat and lend themselves to all sorts of tricks that "
"weren't possible in previous versions of Python, but they also make the "
"language more complicated.  Some people have said that they've always "
"recommended Python for its simplicity, and feel that its simplicity is being "
"lost."
msgstr ""
"Alguns utilizadores expressaram preocupação com todas estas alterações. "
"Claro, dizem eles, as novas funcionalidades são interessantes e permitem "
"todo o tipo de truques que não eram possíveis em versões anteriores do "
"Python, mas também tornam a linguagem mais complexa. Algumas pessoas "
"disseram que sempre recomendaram o Python pela sua simplicidade e sentem que "
"essa simplicidade está a ser perdida."

#: ../../whatsnew/2.2.rst:86
msgid ""
"Personally, I think there's no need to worry.  Many of the new features are "
"quite esoteric, and you can write a lot of Python code without ever needed "
"to be aware of them.  Writing a simple class is no more difficult than it "
"ever was, so you don't need to bother learning or teaching them unless "
"they're actually needed.  Some very complicated tasks that were previously "
"only possible from C will now be possible in pure Python, and to my mind "
"that's all for the better."
msgstr ""
"Pessoalmente, acho que não há motivo para preocupação. Muitas das novas "
"funcionalidades são bastante esotéricas, e pode escrever muito código Python "
"sem nunca precisar de as conhecer. Escrever uma classe simples não é mais "
"difícil do que sempre foi, pelo que não precisa de se preocupar em aprender "
"ou ensinar estas funcionalidades a menos que sejam realmente necessárias. "
"Algumas tarefas muito complexas que antes só eram possíveis em C agora são "
"possíveis em Python puro, e, na minha opinião, isso é tudo para melhor."

#: ../../whatsnew/2.2.rst:93
msgid ""
"I'm not going to attempt to cover every single corner case and small change "
"that were required to make the new features work.  Instead this section will "
"paint only the broad strokes.  See section :ref:`sect-rellinks`, \"Related "
"Links\", for further sources of information about Python 2.2's new object "
"model."
msgstr ""
"Não vou tentar abordar todos os casos específicos e pequenas alterações que "
"foram necessárias para fazer as novas funcionalidades funcionarem. Em vez "
"disso, esta secção apresentará apenas os traços gerais. Consulte a secção :"
"ref:`sect-rellinks`, \"Ligações Relacionadas\", para mais fontes de "
"informação sobre o novo modelo de objetos do Python 2.2."

#: ../../whatsnew/2.2.rst:100
msgid "Old and New Classes"
msgstr "Classes Antigas e Novas"

#: ../../whatsnew/2.2.rst:102
msgid ""
"First, you should know that Python 2.2 really has two kinds of classes: "
"classic or old-style classes, and new-style classes.  The old-style class "
"model is exactly the same as the class model in earlier versions of Python.  "
"All the new features described in this section apply only to new-style "
"classes. This divergence isn't intended to last forever; eventually old-"
"style classes will be dropped, possibly in Python 3.0."
msgstr ""
"Primeiro, deve saber que o Python 2.2 tem realmente dois tipos de classes: "
"classes clássicas ou do estilo antigo, e classes do novo estilo. O modelo de "
"classes do estilo antigo é exatamente o mesmo que o modelo de classes em "
"versões anteriores do Python. Todas as novas funcionalidades descritas nesta "
"secção aplicam-se apenas a classes do novo estilo. Esta divergência não é "
"destinada a durar para sempre; eventualmente, as classes do estilo antigo "
"serão removidas, possivelmente no Python 3.0."

#: ../../whatsnew/2.2.rst:109
msgid ""
"So how do you define a new-style class?  You do it by subclassing an "
"existing new-style class.  Most of Python's built-in types, such as "
"integers, lists, dictionaries, and even files, are new-style classes now.  A "
"new-style class named :class:`object`, the base class for all built-in "
"types, has also been added so if no built-in type is suitable, you can just "
"subclass :class:`object`::"
msgstr ""
"Como definir uma classe do novo estilo? Faz-se isso ao criar uma subclasse "
"de uma classe do novo estilo existente. A maioria dos tipos integrados do "
"Python, como inteiros, listas, dicionários e até ficheiros, são agora "
"classes do novo estilo. Foi também adicionada uma classe do novo estilo "
"chamada :class:`object`, a classe base para todos os tipos integrados, pelo "
"que, se nenhum tipo integrado for adequado, pode simplesmente criar uma "
"subclasse de :class:`object`::"

#: ../../whatsnew/2.2.rst:116
msgid ""
"class C(object):\n"
"    def __init__ (self):\n"
"        ...\n"
"    ..."
msgstr ""
"class C(object):\n"
"    def __init__ (self):\n"
"        ...\n"
"    ..."

#: ../../whatsnew/2.2.rst:121
msgid ""
"This means that :keyword:`class` statements that don't have any base classes "
"are always classic classes in Python 2.2.  (Actually you can also change "
"this by setting a module-level variable named :attr:`!__metaclass__` --- "
"see :pep:`253` for the details --- but it's easier to just subclass :class:"
"`object`.)"
msgstr ""
"Isto significa que as instruções :keyword:`class` que não têm classes base "
"são sempre classes clássicas no Python 2.2. (Na verdade, também pode alterar "
"isto ao definir uma variável ao nível do módulo chamada :attr:`!"
"__metaclass__` — consulte o :pep:`253` para mais detalhes — mas é mais fácil "
"simplesmente criar uma subclasse de :class:`object`.)"

#: ../../whatsnew/2.2.rst:126
msgid ""
"The type objects for the built-in types are available as built-ins, named "
"using a clever trick.  Python has always had built-in functions named :func:"
"`int`, :func:`float`, and :func:`str`.  In 2.2, they aren't functions any "
"more, but type objects that behave as factories when called. ::"
msgstr ""
"Os objetos de tipo para os tipos integrados estão disponíveis como "
"integrados, usando um truque engenhoso. O Python sempre teve funções "
"integradas chamadas :func:`int`, :func:`float` e :func:`str`. No Python 2.2, "
"já não são funções, mas objetos de tipo que se comportam como fábricas "
"quando chamados. ::"

#: ../../whatsnew/2.2.rst:131
msgid ""
">>> int\n"
"<type 'int'>\n"
">>> int('123')\n"
"123"
msgstr ""
">>> int\n"
"<type 'int'>\n"
">>> int('123')\n"
"123"

#: ../../whatsnew/2.2.rst:136
msgid ""
"To make the set of types complete, new type objects such as :func:`dict` "
"and :func:`!file` have been added.  Here's a more interesting example, "
"adding a :meth:`!lock` method to file objects::"
msgstr ""
"Para completar o conjunto de tipos, foram adicionados novos objetos de tipo, "
"como :func:`dict` e :func:`!file`. Aqui está um exemplo mais interessante, "
"adicionando um método :meth:`!lock` a objetos de ficheiro::"

#: ../../whatsnew/2.2.rst:140
msgid ""
"class LockableFile(file):\n"
"    def lock (self, operation, length=0, start=0, whence=0):\n"
"        import fcntl\n"
"        return fcntl.lockf(self.fileno(), operation,\n"
"                           length, start, whence)"
msgstr ""
"class LockableFile(file):\n"
"    def lock (self, operation, length=0, start=0, whence=0):\n"
"        import fcntl\n"
"        return fcntl.lockf(self.fileno(), operation,\n"
"                           length, start, whence)"

#: ../../whatsnew/2.2.rst:146
msgid ""
"The now-obsolete :mod:`!posixfile` module contained a class that emulated "
"all of a file object's methods and also added a :meth:`!lock` method, but "
"this class couldn't be passed to internal functions that expected a built-in "
"file, something which is possible with our new :class:`!LockableFile`."
msgstr ""
"O módulo :mod:`!posixfile`, agora obsoleto, continha uma classe que emulava "
"todos os métodos de um objeto de ficheiro e também adicionava um método :"
"meth:`!lock`, mas esta classe não podia ser passada a funções internas que "
"esperavam um ficheiro integrado, algo que é possível com o nosso novo :class:"
"`!LockableFile`."

#: ../../whatsnew/2.2.rst:153
msgid "Descriptors"
msgstr "Descritores"

#: ../../whatsnew/2.2.rst:155
msgid ""
"In previous versions of Python, there was no consistent way to discover what "
"attributes and methods were supported by an object. There were some informal "
"conventions, such as defining :attr:`!__members__` and :attr:`!__methods__` "
"attributes that were lists of names, but often the author of an extension "
"type or a class wouldn't bother to define them.  You could fall back on "
"inspecting the :attr:`~object.__dict__` of an object, but when class "
"inheritance or an arbitrary :meth:`!__getattr__` hook were in use this could "
"still be inaccurate."
msgstr ""
"Em versões anteriores do Python, não havia uma forma consistente de "
"descobrir quais atributos e métodos eram suportados por um objeto. Existiam "
"algumas convenções informais, como definir atributos :attr:`!__members__` e :"
"attr:`!__methods__` que eram listas de nomes, mas muitas vezes o autor de um "
"tipo de extensão ou de uma classe não se dava ao trabalho de os definir. "
"Podia recorrer à inspeção do :attr:`~object.__dict__` de um objeto, mas "
"quando a herança de classes ou um *hook* arbitrário :meth:`!__getattr__` "
"estavam em uso, isto ainda podia ser impreciso."

#: ../../whatsnew/2.2.rst:163
msgid ""
"The one big idea underlying the new class model is that an API for "
"describing the attributes of an object using :dfn:`descriptors` has been "
"formalized. Descriptors specify the value of an attribute, stating whether "
"it's a method or a field.  With the descriptor API, static methods and class "
"methods become possible, as well as more exotic constructs."
msgstr ""
"A grande ideia subjacente ao novo modelo de classes é que uma API para "
"descrever os atributos de um objeto usando :dfn:`descritores` foi "
"formalizada. Os descritores especificam o valor de um atributo, indicando se "
"é um método ou um campo. Com a API de descritores, métodos estáticos e de "
"classe tornam-se possíveis, bem como construções mais exóticas."

#: ../../whatsnew/2.2.rst:169
msgid ""
"Attribute descriptors are objects that live inside class objects, and have a "
"few attributes of their own:"
msgstr ""
"Os descritores de atributos são objetos que residem dentro de objetos de "
"classe e têm alguns atributos próprios:"

#: ../../whatsnew/2.2.rst:172
msgid ":attr:`~definition.__name__` is the attribute's name."
msgstr ":attr:`~definition.__name__` é o nome do atributo."

#: ../../whatsnew/2.2.rst:174
msgid ":attr:`~definition.__doc__` is the attribute's docstring."
msgstr ":attr:`~definition.__doc__` é a *docstring* do atributo."

#: ../../whatsnew/2.2.rst:176
msgid ""
"``__get__(object)`` is a method that retrieves the attribute value from "
"*object*."
msgstr ""
"``__get__(object)`` é um método que recupera o valor do atributo de *object*."

#: ../../whatsnew/2.2.rst:179
msgid "``__set__(object, value)`` sets the attribute on *object* to *value*."
msgstr "``__set__(object, value)`` define o atributo em *object* para *value*."

#: ../../whatsnew/2.2.rst:181
msgid ""
"``__delete__(object, value)`` deletes the *value*  attribute of *object*."
msgstr "``__delete__(object, value)`` elimina o atributo *value* de *object*."

#: ../../whatsnew/2.2.rst:183
msgid ""
"For example, when you write ``obj.x``, the steps that Python actually "
"performs are::"
msgstr ""
"Por exemplo, quando escreve ``obj.x``, os passos que o Python executa são::"

#: ../../whatsnew/2.2.rst:186
msgid ""
"descriptor = obj.__class__.x\n"
"descriptor.__get__(obj)"
msgstr ""
"descriptor = obj.__class__.x\n"
"descriptor.__get__(obj)"

#: ../../whatsnew/2.2.rst:189
msgid ""
"For methods, :meth:`descriptor.__get__ <object.__get__>` returns a temporary "
"object that's callable, and wraps up the instance and the method to be "
"called on it. This is also why static methods and class methods are now "
"possible; they have descriptors that wrap up just the method, or the method "
"and the class.  As a brief explanation of these new kinds of methods, static "
"methods aren't passed the instance, and therefore resemble regular "
"functions.  Class methods are passed the class of the object, but not the "
"object itself.  Static and class methods are defined like this::"
msgstr ""
"Para métodos, :meth:`descriptor.__get__ <object.__get__>` devolve um objeto "
"temporário que é chamável e encapsula a instância e o método a ser chamado "
"nela. Isto também explica por que métodos estáticos e de classe são agora "
"possíveis; eles têm descritores que encapsulam apenas o método, ou o método "
"e a classe. Como breve explicação destes novos tipos de métodos, métodos "
"estáticos não recebem a instância e, portanto, assemelham-se a funções "
"normais. Métodos de classe recebem a classe do objeto, mas não o objeto em "
"si. Métodos estáticos e de classe são definidos assim::"

#: ../../whatsnew/2.2.rst:199
msgid ""
"class C(object):\n"
"    def f(arg1, arg2):\n"
"        ...\n"
"    f = staticmethod(f)\n"
"\n"
"    def g(cls, arg1, arg2):\n"
"        ...\n"
"    g = classmethod(g)"
msgstr ""
"class C(object):\n"
"    def f(arg1, arg2):\n"
"        ...\n"
"    f = staticmethod(f)\n"
"\n"
"    def g(cls, arg1, arg2):\n"
"        ...\n"
"    g = classmethod(g)"

#: ../../whatsnew/2.2.rst:208
msgid ""
"The :func:`staticmethod` function takes the function :func:`!f`, and returns "
"it wrapped up in a descriptor so it can be stored in the class object.  You "
"might expect there to be special syntax for creating such methods (``def "
"static f``, ``defstatic f()``, or something like that) but no such syntax "
"has been defined yet; that's been left for future versions of Python."
msgstr ""
"A função :func:`staticmethod` recebe a função :func:`!f` e devolve-a "
"encapsulada num descritor para que possa ser armazenada no objeto de classe. "
"Pode esperar que exista uma sintaxe especial para criar tais métodos (``def "
"static f``, ``defstatic f()``, ou algo semelhante), mas nenhuma sintaxe "
"desse tipo foi ainda definida; isso foi deixado para versões futuras do "
"Python."

#: ../../whatsnew/2.2.rst:214
msgid ""
"More new features, such as slots and properties, are also implemented as new "
"kinds of descriptors, and it's not difficult to write a descriptor class "
"that does something novel.  For example, it would be possible to write a "
"descriptor class that made it possible to write Eiffel-style preconditions "
"and postconditions for a method.  A class that used this feature might be "
"defined like this::"
msgstr ""
"Mais funcionalidades novas, como *slots* e propriedades, também são "
"implementadas como novos tipos de descritores, e não é difícil escrever uma "
"classe de descritor que faça algo inovador. Por exemplo, seria possível "
"escrever uma classe de descritor que permitisse escrever pré-condições e pós-"
"condições no estilo Eiffel para um método. Uma classe que usasse esta "
"funcionalidade poderia ser definida assim::"

#: ../../whatsnew/2.2.rst:221
msgid ""
"from eiffel import eiffelmethod\n"
"\n"
"class C(object):\n"
"    def f(self, arg1, arg2):\n"
"        # The actual function\n"
"        ...\n"
"    def pre_f(self):\n"
"        # Check preconditions\n"
"        ...\n"
"    def post_f(self):\n"
"        # Check postconditions\n"
"        ...\n"
"\n"
"    f = eiffelmethod(f, pre_f, post_f)"
msgstr ""
"from eiffel import eiffelmethod\n"
"\n"
"class C(object):\n"
"    def f(self, arg1, arg2):\n"
"        # A função real\n"
"        ...\n"
"    def pre_f(self):\n"
"        # Verificar pré-condições\n"
"        ...\n"
"    def post_f(self):\n"
"        # Verificar pós-condições\n"
"        ...\n"
"\n"
"    f = eiffelmethod(f, pre_f, post_f)"

#: ../../whatsnew/2.2.rst:236
msgid ""
"Note that a person using the new :func:`!eiffelmethod` doesn't have to "
"understand anything about descriptors.  This is why I think the new features "
"don't increase the basic complexity of the language. There will be a few "
"wizards who need to know about it in order to write :func:`!eiffelmethod` or "
"the ZODB or whatever, but most users will just write code on top of the "
"resulting libraries and ignore the implementation details."
msgstr ""
"Note que uma pessoa que usa a nova :func:`!eiffelmethod` não precisa de "
"perceber nada sobre descritores. É por isso que acho que as novas "
"funcionalidades não aumentam a complexidade básica da linguagem. Haverá "
"alguns especialistas que precisam de saber sobre isto para escrever :func:`!"
"eiffelmethod` ou o ZODB ou o que for, mas a maioria dos utilizadores "
"simplesmente escreverá código por cima das bibliotecas resultantes e "
"ignorará os detalhes de implementação."

#: ../../whatsnew/2.2.rst:245
msgid "Multiple Inheritance: The Diamond Rule"
msgstr "Herança Múltipla: A Regra do Diamante"

#: ../../whatsnew/2.2.rst:247
msgid ""
"Multiple inheritance has also been made more useful through changing the "
"rules under which names are resolved.  Consider this set of classes (diagram "
"taken from :pep:`253` by Guido van Rossum)::"
msgstr ""
"A herança múltipla também foi tornada mais útil através da alteração das "
"regras pelas quais os nomes são resolvidos. Considere este conjunto de "
"classes (diagrama retirado do :pep:`253` de Guido van Rossum)::"

#: ../../whatsnew/2.2.rst:251
msgid ""
"      class A:\n"
"        ^ ^  def save(self): ...\n"
"       /   \\\n"
"      /     \\\n"
"     /       \\\n"
"    /         \\\n"
"class B     class C:\n"
"    ^         ^  def save(self): ...\n"
"     \\       /\n"
"      \\     /\n"
"       \\   /\n"
"        \\ /\n"
"      class D"
msgstr ""
"      class A:\n"
"        ^ ^  def save(self): ...\n"
"       /   \\\n"
"      /     \\\n"
"     /       \\\n"
"    /         \\\n"
"class B     class C:\n"
"    ^         ^  def save(self): ...\n"
"     \\       /\n"
"      \\     /\n"
"       \\   /\n"
"        \\ /\n"
"      class D"

#: ../../whatsnew/2.2.rst:265
msgid ""
"The lookup rule for classic classes is simple but not very smart; the base "
"classes are searched depth-first, going from left to right.  A reference to :"
"meth:`!D.save` will search the classes :class:`!D`, :class:`!B`, and then :"
"class:`!A`, where :meth:`!save` would be found and returned.  :meth:`!C."
"save` would never be found at all.  This is bad, because if :class:`!C`'s :"
"meth:`!save` method is saving some internal state specific to :class:`!C`, "
"not calling it will result in that state never getting saved."
msgstr ""
"A regra de pesquisa para classes clássicas é simples, mas não muito "
"inteligente; as classes base são pesquisadas em profundidade, da esquerda "
"para a direita. Uma referência a :meth:`!D.save` pesquisará as classes :"
"class:`!D`, :class:`!B` e depois :class:`!A`, onde :meth:`!save` seria "
"encontrado e devolvido. :meth:`!C.save` nunca seria encontrado. Isto é mau, "
"porque se o método :meth:`!save` de :class:`!C` estiver a guardar algum "
"estado interno específico de :class:`!C`, não chamá-lo resultará nesse "
"estado nunca ser guardado."

#: ../../whatsnew/2.2.rst:273
msgid ""
"New-style classes follow a different algorithm that's a bit more complicated "
"to explain, but does the right thing in this situation. (Note that Python "
"2.3 changes this algorithm to one that produces the same results in most "
"cases, but produces more useful results for really complicated inheritance "
"graphs.)"
msgstr ""
"As classes do novo estilo seguem um algoritmo diferente que é um pouco mais "
"complicado de explicar, mas faz a coisa certa nesta situação. (Note que o "
"Python 2.3 altera este algoritmo para um que produz os mesmos resultados na "
"maioria dos casos, mas produz resultados mais úteis para gráficos de herança "
"realmente complicados.)"

#: ../../whatsnew/2.2.rst:278
msgid ""
"List all the base classes, following the classic lookup rule and include a "
"class multiple times if it's visited repeatedly.  In the above example, the "
"list of visited classes is [:class:`!D`, :class:`!B`, :class:`!A`, :class:`!"
"C`, :class:`!A`]."
msgstr ""
"Liste todas as classes base, seguindo a regra de pesquisa clássica e inclua "
"uma classe várias vezes se for visitada repetidamente. No exemplo acima, a "
"lista de classes visitadas é [:class:`!D`, :class:`!B`, :class:`!A`, :class:"
"`!C`, :class:`!A`]."

#: ../../whatsnew/2.2.rst:283
msgid ""
"Scan the list for duplicated classes.  If any are found, remove all but one "
"occurrence, leaving the *last* one in the list.  In the above example, the "
"list becomes [:class:`!D`, :class:`!B`, :class:`!C`, :class:`!A`] after "
"dropping duplicates."
msgstr ""
"Percorra a lista à procura de classes duplicadas. Se forem encontradas, "
"remova todas as ocorrências exceto uma, deixando a *última* na lista. No "
"exemplo acima, a lista torna-se [:class:`!D`, :class:`!B`, :class:`!C`, :"
"class:`!A`] após a remoção de duplicados."

#: ../../whatsnew/2.2.rst:288
msgid ""
"Following this rule, referring to :meth:`!D.save` will return :meth:`!C."
"save`, which is the behaviour we're after.  This lookup rule is the same as "
"the one followed by Common Lisp.  A new built-in function, :func:`super`, "
"provides a way to get at a class's superclasses without having to "
"reimplement Python's algorithm. The most commonly used form will be  "
"``super(class, obj)``, which returns  a bound superclass object (not the "
"actual class object).  This form will be used in methods to call a method in "
"the superclass; for example, :class:`!D`'s :meth:`!save` method would look "
"like this::"
msgstr ""
"Seguindo esta regra, referir :meth:`!D.save` devolverá :meth:`!C.save`, que "
"é o comportamento que procuramos. Esta regra de pesquisa é a mesma seguida "
"pelo Common Lisp. Uma nova função integrada, :func:`super`, fornece uma "
"forma de aceder às superclasses de uma classe sem ter de reimplementar o "
"algoritmo do Python. A forma mais comumente usada será ``super(class, "
"obj)``, que devolve um objeto de superclasse ligado (não o objeto de classe "
"real). Esta forma será usada em métodos para chamar um método na "
"superclasse; por exemplo, o método :meth:`!save` de :class:`!D` seria assim::"

#: ../../whatsnew/2.2.rst:297
msgid ""
"class D (B,C):\n"
"    def save (self):\n"
"        # Call superclass .save()\n"
"        super(D, self).save()\n"
"        # Save D's private information here\n"
"        ..."
msgstr ""
"class D (B,C):\n"
"    def save (self):\n"
"        # Chamar o .save() da superclasse\n"
"        super(D, self).save()\n"
"        # Guardar aqui a informação privada de D\n"
"        ..."

#: ../../whatsnew/2.2.rst:304
msgid ""
":func:`super` can also return unbound superclass objects when called as "
"``super(class)`` or ``super(class1, class2)``, but this probably won't often "
"be useful."
msgstr ""
":func:`super` também pode devolver objetos de superclasse não ligados quando "
"chamada como ``super(class)`` ou ``super(class1, class2)``, mas isto "
"provavelmente não será muito útil."

#: ../../whatsnew/2.2.rst:310
msgid "Attribute Access"
msgstr "Acesso a Atributos"

#: ../../whatsnew/2.2.rst:312
msgid ""
"A fair number of sophisticated Python classes define hooks for attribute "
"access using :meth:`~object.__getattr__`; most commonly this is done for "
"convenience, to make code more readable by automatically mapping an "
"attribute access such as ``obj.parent`` into a method call such as ``obj."
"get_parent``.  Python 2.2 adds some new ways of controlling attribute access."
msgstr ""
"Um número considerável de classes Python sofisticadas define *hooks* para "
"acesso a atributos usando :meth:`~object.__getattr__`; mais comumente, isto "
"é feito por conveniência, para tornar o código mais legível ao mapear "
"automaticamente um acesso a atributo, como ``obj.parent``, numa chamada de "
"método, como ``obj.get_parent``. O Python 2.2 adiciona algumas formas novas "
"de controlar o acesso a atributos."

#: ../../whatsnew/2.2.rst:318
msgid ""
"First, ``__getattr__(attr_name)`` is still supported by new-style classes, "
"and nothing about it has changed.  As before, it will be called when an "
"attempt is made to access ``obj.foo`` and no attribute named ``foo`` is "
"found in the instance's dictionary."
msgstr ""
"Primeiro, ``__getattr__(attr_name)`` ainda é suportado por classes do novo "
"estilo, e nada mudou. Como antes, será chamado quando for feita uma "
"tentativa de aceder a ``obj.foo`` e nenhum atributo chamado ``foo`` for "
"encontrado no dicionário da instância."

#: ../../whatsnew/2.2.rst:323
msgid ""
"New-style classes also support a new method, "
"``__getattribute__(attr_name)``.  The difference between the two methods is "
"that :meth:`~object.__getattribute__` is *always* called whenever any "
"attribute is accessed, while the old :meth:`~object.__getattr__` is only "
"called if ``foo`` isn't found in the instance's dictionary."
msgstr ""
"As classes do novo estilo também suportam um novo método, "
"``__getattribute__(attr_name)``. A diferença entre os dois métodos é que :"
"meth:`~object.__getattribute__` é *sempre* chamado sempre que qualquer "
"atributo é acedido, enquanto o antigo :meth:`~object.__getattr__` só é "
"chamado se ``foo`` não for encontrado no dicionário da instância."

#: ../../whatsnew/2.2.rst:329
msgid ""
"However, Python 2.2's support for :dfn:`properties` will often be a simpler "
"way to trap attribute references.  Writing a :meth:`!__getattr__` method is "
"complicated because to avoid recursion you can't use regular attribute "
"accesses inside them, and instead have to mess around with the contents of :"
"attr:`~object.__dict__`. :meth:`~object.__getattr__` methods also end up "
"being called by Python when it checks for other methods such as :meth:"
"`~object.__repr__` or :meth:`!__coerce__`, and so have to be written with "
"this in mind. Finally, calling a function on every attribute access results "
"in a sizable performance loss."
msgstr ""
"No entanto, o suporte do Python 2.2 para :dfn:`propriedades` será muitas "
"vezes uma forma mais simples de interceptar referências a atributos. "
"Escrever um método :meth:`!__getattr__` é complicado porque, para evitar "
"recursão, não pode usar acessos normais a atributos dentro deles, e em vez "
"disso tem de manipular o conteúdo de :attr:`~object.__dict__`. Os métodos :"
"meth:`~object.__getattr__` também acabam por ser chamados pelo Python quando "
"verifica outros métodos, como :meth:`~object.__repr__` ou :meth:`!"
"__coerce__`, e por isso têm de ser escritos com isto em mente. Finalmente, "
"chamar uma função em cada acesso a atributo resulta numa perda significativa "
"de desempenho."

#: ../../whatsnew/2.2.rst:338
msgid ""
":class:`property` is a new built-in type that packages up three functions "
"that get, set, or delete an attribute, and a docstring.  For example, if you "
"want to define a :attr:`!size` attribute that's computed, but also settable, "
"you could write::"
msgstr ""
":class:`property` é um novo tipo integrado que encapsula três funções que "
"obtêm, definem ou eliminam um atributo, e uma *docstring*. Por exemplo, se "
"pretender definir um atributo :attr:`!size` que é calculado, mas também "
"configurável, pode escrever::"

#: ../../whatsnew/2.2.rst:343
msgid ""
"class C(object):\n"
"    def get_size (self):\n"
"        result = ... computation ...\n"
"        return result\n"
"    def set_size (self, size):\n"
"        ... compute something based on the size\n"
"        and set internal state appropriately ...\n"
"\n"
"    # Define a property.  The 'delete this attribute'\n"
"    # method is defined as None, so the attribute\n"
"    # can't be deleted.\n"
"    size = property(get_size, set_size,\n"
"                    None,\n"
"                    \"Storage size of this instance\")"
msgstr ""
"class C(object):\n"
"    def get_size (self):\n"
"        result = ... cálculo ...\n"
"        return result\n"
"    def set_size (self, size):\n"
"        ... calcular algo com base no tamanho\n"
"        e definir o estado interno apropriadamente ...\n"
"\n"
"    # Definir uma propriedade. O método 'eliminar este atributo'\n"
"    # é definido como None, pelo que o atributo\n"
"    # não pode ser eliminado.\n"
"    size = property(get_size, set_size,\n"
"                    None,\n"
"                    \"Tamanho de armazenamento desta instância\")"

#: ../../whatsnew/2.2.rst:358
msgid ""
"That is certainly clearer and easier to write than a pair of :meth:`!"
"__getattr__`/:meth:`!__setattr__` methods that check for the :attr:`!size` "
"attribute and handle it specially while retrieving all other attributes from "
"the instance's :attr:`~object.__dict__`.  Accesses to :attr:`!size` are also "
"the only ones which have to perform the work of calling a function, so "
"references to other attributes run at their usual speed."
msgstr ""
"Isto é certamente mais claro e fácil de escrever do que um par de métodos :"
"meth:`!__getattr__`/:meth:`!__setattr__` que verificam o atributo :attr:`!"
"size` e o tratam especialmente, enquanto recuperam todos os outros atributos "
"do :attr:`~object.__dict__` da instância. Os acessos a :attr:`!size` são "
"também os únicos que têm de executar o trabalho de chamar uma função, pelo "
"que as referências a outros atributos funcionam à velocidade habitual."

#: ../../whatsnew/2.2.rst:365
msgid ""
"Finally, it's possible to constrain the list of attributes that can be "
"referenced on an object using the new :attr:`~object.__slots__` class "
"attribute. Python objects are usually very dynamic; at any time it's "
"possible to define a new attribute on an instance by just doing ``obj."
"new_attr=1``.   A new-style class can define a class attribute named :attr:"
"`~object.__slots__` to limit the legal attributes  to a particular set of "
"names.  An example will make this clear::"
msgstr ""
"Finalmente, é possível restringir a lista de atributos que podem ser "
"referenciados num objeto usando o novo atributo de classe :attr:`~object."
"__slots__`. Os objetos Python são normalmente muito dinâmicos; a qualquer "
"momento é possível definir um novo atributo numa instância simplesmente "
"fazendo ``obj.new_attr=1``. Uma classe do novo estilo pode definir um "
"atributo de classe chamado :attr:`~object.__slots__` para limitar os "
"atributos legais a um conjunto específico de nomes. Um exemplo tornará isto "
"claro::"

#: ../../whatsnew/2.2.rst:372
msgid ""
">>> class C(object):\n"
"...     __slots__ = ('template', 'name')\n"
"...\n"
">>> obj = C()\n"
">>> print obj.template\n"
"None\n"
">>> obj.template = 'Test'\n"
">>> print obj.template\n"
"Test\n"
">>> obj.newattr = None\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"AttributeError: 'C' object has no attribute 'newattr'"
msgstr ""
">>> class C(object):\n"
"...     __slots__ = ('template', 'name')\n"
"...\n"
">>> obj = C()\n"
">>> print obj.template\n"
"None\n"
">>> obj.template = 'Test'\n"
">>> print obj.template\n"
"Test\n"
">>> obj.newattr = None\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"AttributeError: o objeto 'C' não tem o atributo 'newattr'"

#: ../../whatsnew/2.2.rst:386
msgid ""
"Note how you get an :exc:`AttributeError` on the attempt to assign to an "
"attribute not listed in :attr:`~object.__slots__`."
msgstr ""
"Note como obtém um :exc:`AttributeError` ao tentar atribuir a um atributo "
"não listado em :attr:`~object.__slots__`."

#: ../../whatsnew/2.2.rst:393
msgid "Related Links"
msgstr "Ligações Relacionadas"

#: ../../whatsnew/2.2.rst:395
msgid ""
"This section has just been a quick overview of the new features, giving "
"enough of an explanation to start you programming, but many details have "
"been simplified or ignored.  Where should you go to get a more complete "
"picture?"
msgstr ""
"Esta secção foi apenas uma visão geral rápida das novas funcionalidades, "
"fornecendo explicação suficiente para começar a programar, mas muitos "
"detalhes foram simplificados ou ignorados. Onde deve ir para obter uma "
"imagem mais completa?"

#: ../../whatsnew/2.2.rst:399
msgid ""
"The :ref:`descriptorhowto` is a lengthy tutorial introduction to the "
"descriptor features, written by Guido van Rossum. If my description has "
"whetted your appetite, go read this tutorial next, because it goes into much "
"more detail about the new features while still remaining quite easy to read."
msgstr ""
"O :ref:`descriptorhowto` é uma longa introdução tutorial às funcionalidades "
"de descritores, escrita por Guido van Rossum. Se a minha descrição despertou "
"o seu interesse, leia este tutorial a seguir, porque entra em muito mais "
"detalhe sobre as novas funcionalidades, mantendo-se ainda bastante fácil de "
"ler."

#: ../../whatsnew/2.2.rst:404
msgid ""
"Next, there are two relevant PEPs, :pep:`252` and :pep:`253`.  :pep:`252` is "
"titled \"Making Types Look More Like Classes\", and covers the descriptor "
"API. :pep:`253` is titled \"Subtyping Built-in Types\", and describes the "
"changes to type objects that make it possible to subtype built-in objects.  :"
"pep:`253` is the more complicated PEP of the two, and at a few points the "
"necessary explanations of types and meta-types may cause your head to "
"explode.  Both PEPs were written and implemented by Guido van Rossum, with "
"substantial assistance from the rest of the Zope Corp. team."
msgstr ""
"Em seguida, existem dois PEPs relevantes, :pep:`252` e :pep:`253`. O :pep:"
"`252` tem o título \"Tornar os Tipos Mais Semelhantes a Classes\", e aborda "
"a API de descritores. O :pep:`253` tem o título \"Subtipagem de Tipos "
"Integrados\", e descreve as alterações aos objetos de tipo que tornam "
"possível a subtipagem de objetos integrados. O :pep:`253` é o PEP mais "
"complicado dos dois, e em alguns pontos as explicações necessárias sobre "
"tipos e meta-tipos podem fazer a sua cabeça explodir. Ambos os PEPs foram "
"escritos e implementados por Guido van Rossum, com assistência substancial "
"do resto da equipa da Zope Corp."

#: ../../whatsnew/2.2.rst:413
msgid ""
"Finally, there's the ultimate authority: the source code.  Most of the "
"machinery for the type handling is in :file:`Objects/typeobject.c`, but you "
"should only resort to it after all other avenues have been exhausted, "
"including posting a question to python-list or python-dev."
msgstr ""
"Finalmente, há a autoridade máxima: o código-fonte. A maioria da maquinaria "
"para o tratamento de tipos está em :file:`Objects/typeobject.c`, mas só deve "
"recorrer a ela depois de esgotadas todas as outras vias, incluindo a "
"publicação de uma pergunta na python-list ou python-dev."

#: ../../whatsnew/2.2.rst:422
msgid "PEP 234: Iterators"
msgstr "PEP 234: Iteradores"

#: ../../whatsnew/2.2.rst:424
msgid ""
"Another significant addition to 2.2 is an iteration interface at both the C "
"and Python levels.  Objects can define how they can be looped over by "
"callers."
msgstr ""
"Outra adição significativa ao Python 2.2 é uma interface de iteração tanto "
"ao nível de C como de Python. Os objetos podem definir como podem ser "
"percorridos por quem os chama."

#: ../../whatsnew/2.2.rst:427
msgid ""
"In Python versions up to 2.1, the usual way to make ``for item in obj`` work "
"is to define a :meth:`~object.__getitem__` method that looks something like "
"this::"
msgstr ""
"Nas versões do Python até à 2.1, a forma habitual de fazer ``for item in "
"obj`` funcionar era definir um método :meth:`~object.__getitem__` que se "
"assemelhava a isto::"

#: ../../whatsnew/2.2.rst:430
msgid ""
"def __getitem__(self, index):\n"
"    return <next item>"
msgstr ""
"def __getitem__(self, index):\n"
"    return <próximo item>"

#: ../../whatsnew/2.2.rst:433
msgid ""
":meth:`~object.__getitem__` is more properly used to define an indexing "
"operation on an object so that you can write ``obj[5]`` to retrieve the "
"sixth element.  It's a bit misleading when you're using this only to "
"support :keyword:`for` loops. Consider some file-like object that wants to "
"be looped over; the *index* parameter is essentially meaningless, as the "
"class probably assumes that a series of :meth:`~object.__getitem__` calls "
"will be made with *index* incrementing by one each time.  In other words, "
"the presence of the :meth:`~object.__getitem__` method doesn't mean that "
"using ``file[5]``  to randomly access the sixth element will work, though it "
"really should."
msgstr ""
":meth:`~object.__getitem__` é mais propriamente usado para definir uma "
"operação de indexação num objeto, de modo a que possa escrever ``obj[5]`` "
"para recuperar o sexto elemento. É um pouco enganador quando o usa apenas "
"para suportar ciclos :keyword:`for`. Considere algum objeto semelhante a um "
"ficheiro que pretende ser percorrido; o parâmetro *index* é essencialmente "
"sem significado, pois a classe provavelmente assume que uma série de "
"chamadas :meth:`~object.__getitem__` será feita com *index* a incrementar de "
"um em cada chamada. Em outras palavras, a presença do método :meth:`~object."
"__getitem__` não significa que usar ``file[5]`` para aceder aleatoriamente "
"ao sexto elemento irá funcionar, embora realmente devesse."

#: ../../whatsnew/2.2.rst:443
msgid ""
"In Python 2.2, iteration can be implemented separately, and :meth:`~object."
"__getitem__` methods can be limited to classes that really do support random "
"access.  The basic idea of iterators is  simple.  A new built-in function, "
"``iter(obj)`` or ``iter(C, sentinel)``, is used to get an iterator. "
"``iter(obj)`` returns an iterator for the object *obj*, while ``iter(C, "
"sentinel)`` returns an iterator that will invoke the callable object *C* "
"until it returns *sentinel* to signal that the iterator is done."
msgstr ""
"No Python 2.2, a iteração pode ser implementada separadamente, e os métodos :"
"meth:`~object.__getitem__` podem ser limitados a classes que realmente "
"suportam acesso aleatório. A ideia básica dos iteradores é simples. Uma nova "
"função integrada, ``iter(obj)`` ou ``iter(C, sentinel)``, é usada para obter "
"um iterador. ``iter(obj)`` devolve um iterador para o objeto *obj*, enquanto "
"``iter(C, sentinel)`` devolve um iterador que invocará o objeto chamável *C* "
"até que este devolva *sentinel* para sinalizar que o iterador terminou."

#: ../../whatsnew/2.2.rst:451
msgid ""
"Python classes can define an :meth:`!__iter__` method, which should create "
"and return a new iterator for the object; if the object is its own iterator, "
"this method can just return ``self``.  In particular, iterators will usually "
"be their own iterators.  Extension types implemented in C can implement a :c:"
"member:`~PyTypeObject.tp_iter` function in order to return an iterator, and "
"extension types that want to behave as iterators can define a :c:member:"
"`~PyTypeObject.tp_iternext` function."
msgstr ""
"As classes Python podem definir um método :meth:`!__iter__`, que deve criar "
"e devolver um novo iterador para o objeto; se o objeto for o seu próprio "
"iterador, este método pode simplesmente devolver ``self``. Em particular, os "
"iteradores serão normalmente os seus próprios iteradores. Tipos de extensão "
"implementados em C podem implementar uma função :c:member:`~PyTypeObject."
"tp_iter` para devolver um iterador, e tipos de extensão que pretendam "
"comportar-se como iteradores podem definir uma função :c:member:"
"`~PyTypeObject.tp_iternext`."

#: ../../whatsnew/2.2.rst:458
msgid ""
"So, after all this, what do iterators actually do?  They have one required "
"method, :meth:`next`, which takes no arguments and returns the next value.  "
"When there are no more values to be returned, calling :meth:`next` should "
"raise the :exc:`StopIteration` exception. ::"
msgstr ""
"Então, depois de tudo isto, o que é que os iteradores fazem realmente? Têm "
"um método obrigatório, :meth:`next`, que não recebe argumentos e devolve o "
"próximo valor. Quando não houver mais valores a devolver, chamar :meth:"
"`next` deve gerar a exceção :exc:`StopIteration`. ::"

#: ../../whatsnew/2.2.rst:463
msgid ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> print i\n"
"<iterator object at 0x8116870>\n"
">>> i.next()\n"
"1\n"
">>> i.next()\n"
"2\n"
">>> i.next()\n"
"3\n"
">>> i.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"StopIteration\n"
">>>"
msgstr ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> print i\n"
"<objeto iterador em 0x8116870>\n"
">>> i.next()\n"
"1\n"
">>> i.next()\n"
"2\n"
">>> i.next()\n"
"3\n"
">>> i.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"StopIteration\n"
">>>"

#: ../../whatsnew/2.2.rst:479
msgid ""
"In 2.2, Python's :keyword:`for` statement no longer expects a sequence; it "
"expects something for which :func:`iter` will return an iterator. For "
"backward compatibility and convenience, an iterator is automatically "
"constructed for sequences that don't implement :meth:`!__iter__` or a :c:"
"member:`~PyTypeObject.tp_iter` slot, so ``for i in [1,2,3]`` will still "
"work.  Wherever the Python interpreter loops over a sequence, it's been "
"changed to use the iterator protocol.  This means you can do things like "
"this::"
msgstr ""
"No Python 2.2, a instrução :keyword:`for` já não espera uma sequência; "
"espera algo para o qual :func:`iter` devolverá um iterador. Por "
"compatibilidade retroativa e conveniência, um iterador é automaticamente "
"construído para sequências que não implementam :meth:`!__iter__` ou um "
"*slot* :c:member:`~PyTypeObject.tp_iter`, pelo que ``for i in [1,2,3]`` "
"continuará a funcionar. Sempre que o interpretador Python percorre uma "
"sequência, foi alterado para usar o protocolo de iterador. Isto significa "
"que pode fazer coisas como isto::"

#: ../../whatsnew/2.2.rst:487
msgid ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> a,b,c = i\n"
">>> a,b,c\n"
"(1, 2, 3)"
msgstr ""
">>> L = [1,2,3]\n"
">>> i = iter(L)\n"
">>> a,b,c = i\n"
">>> a,b,c\n"
"(1, 2, 3)"

#: ../../whatsnew/2.2.rst:493
msgid ""
"Iterator support has been added to some of Python's basic types.   Calling :"
"func:`iter` on a dictionary will return an iterator which loops over its "
"keys::"
msgstr ""
"O suporte para iteradores foi adicionado a alguns dos tipos básicos do "
"Python. Chamar :func:`iter` num dicionário devolverá um iterador que "
"percorre as suas chaves::"

#: ../../whatsnew/2.2.rst:496
msgid ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m: print key, m[key]\n"
"...\n"
"Mar 3\n"
"Feb 2\n"
"Aug 8\n"
"Sep 9\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Jan 1\n"
"Apr 4\n"
"Nov 11\n"
"Dec 12\n"
"Oct 10"
msgstr ""
">>> m = {'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,\n"
"...      'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12}\n"
">>> for key in m: print key, m[key]\n"
"...\n"
"Mar 3\n"
"Feb 2\n"
"Aug 8\n"
"Sep 9\n"
"May 5\n"
"Jun 6\n"
"Jul 7\n"
"Jan 1\n"
"Apr 4\n"
"Nov 11\n"
"Dec 12\n"
"Oct 10"

#: ../../whatsnew/2.2.rst:513
msgid ""
"That's just the default behaviour.  If you want to iterate over keys, "
"values, or key/value pairs, you can explicitly call the :meth:`!iterkeys`, :"
"meth:`!itervalues`, or :meth:`!iteritems` methods to get an appropriate "
"iterator. In a minor related change, the :keyword:`in` operator now works on "
"dictionaries, so ``key in dict`` is now equivalent to ``dict.has_key(key)``."
msgstr ""
"Isto é apenas o comportamento predefinido. Se pretender iterar sobre chaves, "
"valores ou pares chave/valor, pode chamar explicitamente os métodos :meth:`!"
"iterkeys`, :meth:`!itervalues` ou :meth:`!iteritems` para obter um iterador "
"apropriado. Numa alteração relacionada menor, o operador :keyword:`in` agora "
"funciona em dicionários, pelo que ``key in dict`` é agora equivalente a "
"``dict.has_key(key)``."

#: ../../whatsnew/2.2.rst:519
msgid ""
"Files also provide an iterator, which calls the :meth:`readline` method "
"until there are no more lines in the file.  This means you can now read each "
"line of a file using code like this::"
msgstr ""
"Os ficheiros também fornecem um iterador, que chama o método :meth:"
"`readline` até não haver mais linhas no ficheiro. Isto significa que agora "
"pode ler cada linha de um ficheiro usando código como este::"

#: ../../whatsnew/2.2.rst:523
msgid ""
"for line in file:\n"
"    # do something for each line\n"
"    ..."
msgstr ""
"for line in file:\n"
"    # fazer algo para cada linha\n"
"    ..."

#: ../../whatsnew/2.2.rst:527
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it. An iterator "
"object could provide such additional capabilities, but the iterator protocol "
"only requires a :meth:`next` method."
msgstr ""
"Note que só pode avançar num iterador; não há forma de obter o elemento "
"anterior, reiniciar o iterador ou fazer uma cópia dele. Um objeto iterador "
"poderia fornecer tais capacidades adicionais, mas o protocolo de iterador só "
"requer um método :meth:`next`."

#: ../../whatsnew/2.2.rst:535
msgid ":pep:`234` - Iterators"
msgstr ":pep:`234` - Iteradores"

#: ../../whatsnew/2.2.rst:536
msgid ""
"Written by Ka-Ping Yee and GvR; implemented  by the Python Labs crew, mostly "
"by GvR and Tim Peters."
msgstr ""
"Escrito por Ka-Ping Yee e GvR; implementado pela equipa Python Labs, "
"maioritariamente por GvR e Tim Peters."

#: ../../whatsnew/2.2.rst:543
msgid "PEP 255: Simple Generators"
msgstr "PEP 255: Geradores Simples"

#: ../../whatsnew/2.2.rst:545
msgid ""
"Generators are another new feature, one that interacts with the introduction "
"of iterators."
msgstr ""
"Os geradores são outra funcionalidade nova, que interage com a introdução de "
"iteradores."

#: ../../whatsnew/2.2.rst:548
msgid ""
"You're doubtless familiar with how function calls work in Python or C.  When "
"you call a function, it gets a private namespace where its local variables "
"are created.  When the function reaches a :keyword:`return` statement, the "
"local variables are destroyed and the resulting value is returned to the "
"caller.  A later call to the same function will get a fresh new set of local "
"variables. But, what if the local variables weren't thrown away on exiting a "
"function? What if you could later resume the function where it left off?  "
"This is what generators provide; they can be thought of as resumable "
"functions."
msgstr ""
"Sem dúvida que está familiarizado com o funcionamento das chamadas de função "
"em Python ou C. Quando chama uma função, esta obtém um *namespace* privado "
"onde as suas variáveis locais são criadas. Quando a função atinge uma "
"instrução :keyword:`return`, as variáveis locais são destruídas e o valor "
"resultante é devolvido ao chamador. Uma chamada posterior à mesma função "
"obterá um novo conjunto de variáveis locais. Mas, e se as variáveis locais "
"não fossem descartadas ao sair de uma função? E se pudesse retomar a função "
"onde parou? Isto é o que os geradores fornecem; podem ser pensados como "
"funções retomáveis."

#: ../../whatsnew/2.2.rst:557
msgid "Here's the simplest example of a generator function::"
msgstr "Aqui está o exemplo mais simples de uma função geradora::"

#: ../../whatsnew/2.2.rst:559
msgid ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"
msgstr ""
"def generate_ints(N):\n"
"    for i in range(N):\n"
"        yield i"

#: ../../whatsnew/2.2.rst:563
msgid ""
"A new keyword, :keyword:`yield`, was introduced for generators.  Any "
"function containing a :keyword:`!yield` statement is a generator function; "
"this is detected by Python's bytecode compiler which compiles the function "
"specially as a result.  Because a new keyword was introduced, generators "
"must be explicitly enabled in a module by including a ``from __future__ "
"import generators`` statement near the top of the module's source code.  In "
"Python 2.3 this statement will become unnecessary."
msgstr ""
"Uma nova palavra-chave, :keyword:`yield`, foi introduzida para os geradores. "
"Qualquer função que contenha uma instrução :keyword:`!yield` é uma função "
"geradora; isto é detetado pelo compilador de *bytecode* do Python, que "
"compila a função de forma especial como resultado. Como uma nova palavra-"
"chave foi introduzida, os geradores devem ser explicitamente ativados num "
"módulo através da inclusão de uma instrução ``from __future__ import "
"generators`` perto do topo do código-fonte do módulo. No Python 2.3, esta "
"instrução tornar-se-á desnecessária."

#: ../../whatsnew/2.2.rst:571
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the :keyword:`yield` statement, the generator outputs the value "
"of ``i``, similar to a :keyword:`return` statement.  The big difference "
"between :keyword:`!yield` and a :keyword:`!return` statement is that on "
"reaching a :keyword:`!yield` the generator's state of execution is suspended "
"and local variables are preserved.  On the next call to the generator's "
"``next()`` method, the function will resume executing immediately after the :"
"keyword:`!yield` statement.  (For complicated reasons, the :keyword:`!yield` "
"statement isn't allowed inside the :keyword:`!try` block of a :keyword:"
"`try`...\\ :keyword:`finally` statement; read :pep:`255` for a full "
"explanation of the interaction between :keyword:`!yield` and exceptions.)"
msgstr ""
"Quando chama uma função geradora, esta não devolve um único valor; em vez "
"disso, devolve um objeto gerador que suporta o protocolo de iterador. Ao "
"executar a instrução :keyword:`yield`, o gerador produz o valor de ``i``, "
"semelhante a uma instrução :keyword:`return`. A grande diferença entre :"
"keyword:`!yield` e uma instrução :keyword:`!return` é que, ao atingir um :"
"keyword:`!yield`, o estado de execução do gerador é suspenso e as variáveis "
"locais são preservadas. Na próxima chamada ao método ``next()`` do gerador, "
"a função retomará a execução imediatamente após a instrução :keyword:`!"
"yield`. (Por razões complicadas, a instrução :keyword:`!yield` não é "
"permitida dentro do bloco :keyword:`!try` de uma instrução :keyword:"
"`try`... :keyword:`finally`; leia o :pep:`255` para uma explicação completa "
"da interação entre :keyword:`!yield` e exceções.)"

#: ../../whatsnew/2.2.rst:584
msgid "Here's a sample usage of the :func:`!generate_ints` generator::"
msgstr "Aqui está um exemplo de uso do gerador :func:`!generate_ints`::"

#: ../../whatsnew/2.2.rst:586
msgid ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<generator object at 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 2, in generate_ints\n"
"StopIteration"
msgstr ""
">>> gen = generate_ints(3)\n"
">>> gen\n"
"<objeto gerador em 0x8117f90>\n"
">>> gen.next()\n"
"0\n"
">>> gen.next()\n"
"1\n"
">>> gen.next()\n"
"2\n"
">>> gen.next()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 2, in generate_ints\n"
"StopIteration"

#: ../../whatsnew/2.2.rst:601
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"Poderia igualmente escrever ``for i in generate_ints(5)``, ou ``a,b,c = "
"generate_ints(3)``."

#: ../../whatsnew/2.2.rst:604
msgid ""
"Inside a generator function, the :keyword:`return` statement can only be "
"used without a value, and signals the end of the procession of values; "
"afterwards the generator cannot return any further values. :keyword:`!"
"return` with a value, such as ``return 5``, is a syntax error inside a "
"generator function.  The end of the generator's results can also be "
"indicated by raising :exc:`StopIteration` manually, or by just letting the "
"flow of execution fall off the bottom of the function."
msgstr ""
"Dentro de uma função geradora, a instrução :keyword:`return` só pode ser "
"usada sem um valor, e sinaliza o fim da sequência de valores; depois disso, "
"o gerador não pode devolver mais valores. :keyword:`!return` com um valor, "
"como ``return 5``, é um erro de sintaxe dentro de uma função geradora. O fim "
"dos resultados do gerador também pode ser indicado ao gerar manualmente uma :"
"exc:`StopIteration`, ou simplesmente deixando o fluxo de execução chegar ao "
"fim da função."

#: ../../whatsnew/2.2.rst:612
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`next` method increment "
"``self.count`` and return it. However, for a moderately complicated "
"generator, writing a corresponding class would be much messier. :file:`Lib/"
"test/test_generators.py` contains a number of more interesting examples.  "
"The simplest one implements an in-order traversal of a tree using generators "
"recursively. ::"
msgstr ""
"Poderia alcançar o efeito dos geradores manualmente ao escrever a sua "
"própria classe e armazenar todas as variáveis locais do gerador como "
"variáveis de instância. Por exemplo, devolver uma lista de inteiros poderia "
"ser feito ao definir ``self.count`` para 0, e tendo o método :meth:`next` a "
"incrementar ``self.count`` e devolvê-lo. No entanto, para um gerador "
"moderadamente complicado, escrever uma classe correspondente seria muito "
"mais confuso. O ficheiro :file:`Lib/test/test_generators.py` contém vários "
"exemplos mais interessantes. O mais simples implementa uma travessia em "
"ordem de uma árvore usando geradores de forma recursiva. ::"

#: ../../whatsnew/2.2.rst:621
msgid ""
"# A recursive generator that generates Tree leaves in in-order.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"
msgstr ""
"# Um gerador recursivo que gera folhas de Árvore em ordem.\n"
"def inorder(t):\n"
"    if t:\n"
"        for x in inorder(t.left):\n"
"            yield x\n"
"        yield t.label\n"
"        for x in inorder(t.right):\n"
"            yield x"

#: ../../whatsnew/2.2.rst:630
msgid ""
"Two other examples in :file:`Lib/test/test_generators.py` produce solutions "
"for the N-Queens problem (placing $N$ queens on an $NxN$ chess board so that "
"no queen threatens another) and the Knight's Tour (a route that takes a "
"knight to every square of an $NxN$ chessboard without visiting any square "
"twice)."
msgstr ""
"Outros dois exemplos em :file:`Lib/test/test_generators.py` produzem "
"soluções para o problema das $N$-Rainhas (colocar $N$ rainhas num tabuleiro "
"de xadrez $NxN$ de modo a que nenhuma rainha ameace outra) e o Passeio do "
"Cavalo (uma rota que leva um cavalo a todas as casas de um tabuleiro de "
"xadrez $NxN$ sem visitar nenhuma casa duas vezes)."

#: ../../whatsnew/2.2.rst:635
msgid ""
"The idea of generators comes from other programming languages, especially "
"Icon (https://www2.cs.arizona.edu/icon/), where the idea of generators is "
"central.  In Icon, every expression and function call behaves like a "
"generator.  One example from \"An Overview of the Icon Programming "
"Language\" at https://www2.cs.arizona.edu/icon/docs/ipd266.htm gives an idea "
"of what this looks like::"
msgstr ""
"A ideia de geradores vem de outras linguagens de programação, especialmente "
"do Icon (https://www2.cs.arizona.edu/icon/), onde a ideia de geradores é "
"central. No Icon, todas as expressões e chamadas de função comportam-se como "
"geradores. Um exemplo de \"Uma Visão Geral da Linguagem de Programação "
"Icon\" em https://www2.cs.arizona.edu/icon/docs/ipd266.htm dá uma ideia de "
"como isto parece::"

#: ../../whatsnew/2.2.rst:642
msgid ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"
msgstr ""
"sentence := \"Store it in the neighboring harbor\"\n"
"if (i := find(\"or\", sentence)) > 5 then write(i)"

#: ../../whatsnew/2.2.rst:645
msgid ""
"In Icon the :func:`!find` function returns the indexes at which the "
"substring \"or\" is found: 3, 23, 33.  In the :keyword:`if` statement, ``i`` "
"is first assigned a value of 3, but 3 is less than 5, so the comparison "
"fails, and Icon retries it with the second value of 23.  23 is greater than "
"5, so the comparison now succeeds, and the code prints the value 23 to the "
"screen."
msgstr ""
"No Icon, a função :func:`!find` devolve os índices nos quais a substring "
"\"or\" é encontrada: 3, 23, 33. Na instrução :keyword:`if`, ``i`` é primeiro "
"atribuído com o valor 3, mas 3 é menor que 5, pelo que a comparação falha, e "
"o Icon tenta novamente com o segundo valor, 23. 23 é maior que 5, pelo que a "
"comparação agora tem sucesso, e o código imprime o valor 23 no ecrã."

#: ../../whatsnew/2.2.rst:651
msgid ""
"Python doesn't go nearly as far as Icon in adopting generators as a central "
"concept.  Generators are considered a new part of the core Python language, "
"but learning or using them isn't compulsory; if they don't solve any "
"problems that you have, feel free to ignore them. One novel feature of "
"Python's interface as compared to Icon's is that a generator's state is "
"represented as a concrete object (the iterator) that can be passed around to "
"other functions or stored in a data structure."
msgstr ""
"O Python não vai tão longe como o Icon na adoção de geradores como um "
"conceito central. Os geradores são considerados uma nova parte da linguagem "
"central do Python, mas aprender ou usá-los não é obrigatório; se não "
"resolverem nenhum problema que tenha, sinta-se à vontade para os ignorar. "
"Uma funcionalidade nova da interface do Python em comparação com a do Icon é "
"que o estado de um gerador é representado como um objeto concreto (o "
"iterador) que pode ser passado para outras funções ou armazenado numa "
"estrutura de dados."

#: ../../whatsnew/2.2.rst:662
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Geradores Simples"

#: ../../whatsnew/2.2.rst:663
msgid ""
"Written by Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implemented "
"mostly by Neil Schemenauer and Tim Peters, with other fixes from the Python "
"Labs crew."
msgstr ""
"Escrito por Neil Schemenauer, Tim Peters e Magnus Lie Hetland. Implementado "
"maioritariamente por Neil Schemenauer e Tim Peters, com outras correções da "
"equipa Python Labs."

#: ../../whatsnew/2.2.rst:670
msgid "PEP 237: Unifying Long Integers and Integers"
msgstr "PEP 237: Unificação de Inteiros Longos e Inteiros"

#: ../../whatsnew/2.2.rst:672
msgid ""
"In recent versions, the distinction between regular integers, which are 32-"
"bit values on most machines, and long integers, which can be of arbitrary "
"size, was becoming an annoyance.  For example, on platforms that support "
"files larger than ``2**32`` bytes, the :meth:`!tell` method of file objects "
"has to return a long integer. However, there were various bits of Python "
"that expected plain integers and would raise an error if a long integer was "
"provided instead.  For example, in Python 1.5, only regular integers could "
"be used as a slice index, and ``'abc'[1L:]`` would raise a :exc:`TypeError` "
"exception with the message 'slice index must be int'."
msgstr ""
"Nas versões recentes, a distinção entre inteiros normais, que são valores de "
"32 bits na maioria das máquinas, e inteiros longos, que podem ser de tamanho "
"arbitrário, estava a tornar-se um incómodo. Por exemplo, em plataformas que "
"suportam ficheiros maiores que ``2**32`` bytes, o método :meth:`!tell` de "
"objetos de ficheiro tem de devolver um inteiro longo. No entanto, existiam "
"várias partes do Python que esperavam inteiros normais e geravam um erro se "
"um inteiro longo fosse fornecido em vez disso. Por exemplo, no Python 1.5, "
"apenas inteiros normais podiam ser usados como índice de *slice*, e "
"``'abc'[1L:]`` gerava uma exceção :exc:`TypeError` com a mensagem 'slice "
"index must be int'."

#: ../../whatsnew/2.2.rst:682
msgid ""
"Python 2.2 will shift values from short to long integers as required. The "
"'L' suffix is no longer needed to indicate a long integer literal, as now "
"the compiler will choose the appropriate type.  (Using the 'L' suffix will "
"be discouraged in future 2.x versions of Python, triggering a warning in "
"Python 2.4, and probably dropped in Python 3.0.)  Many operations that used "
"to raise an :exc:`OverflowError` will now return a long integer as their "
"result.  For example::"
msgstr ""
"O Python 2.2 irá converter valores de inteiros curtos para inteiros longos "
"conforme necessário. O sufixo 'L' já não é necessário para indicar um "
"literal de inteiro longo, pois agora o compilador escolherá o tipo "
"apropriado. (O uso do sufixo 'L' será desencorajado em futuras versões 2.x "
"do Python, gerando um aviso no Python 2.4, e provavelmente removido no "
"Python 3.0.) Muitas operações que costumavam gerar um :exc:`OverflowError` "
"agora devolverão um inteiro longo como resultado. Por exemplo::"

#: ../../whatsnew/2.2.rst:690
msgid ""
">>> 1234567890123\n"
"1234567890123L\n"
">>> 2 ** 64\n"
"18446744073709551616L"
msgstr ""
">>> 1234567890123\n"
"1234567890123L\n"
">>> 2 ** 64\n"
"18446744073709551616L"

#: ../../whatsnew/2.2.rst:695
msgid ""
"In most cases, integers and long integers will now be treated identically.  "
"You can still distinguish them with the :func:`type` built-in function, but "
"that's rarely needed."
msgstr ""
"Na maioria dos casos, inteiros e inteiros longos serão agora tratados de "
"forma idêntica. Ainda pode distinguir entre eles com a função integrada :"
"func:`type`, mas isso é raramente necessário."

#: ../../whatsnew/2.2.rst:702
msgid ":pep:`237` - Unifying Long Integers and Integers"
msgstr ":pep:`237` - Unificação de Inteiros Longos e Inteiros"

#: ../../whatsnew/2.2.rst:703
msgid ""
"Written by Moshe Zadka and Guido van Rossum.  Implemented mostly by Guido "
"van Rossum."
msgstr ""
"Escrito por Moshe Zadka e Guido van Rossum. Implementado maioritariamente "
"por Guido van Rossum."

#: ../../whatsnew/2.2.rst:710
msgid "PEP 238: Changing the Division Operator"
msgstr "PEP 238: Alteração do Operador de Divisão"

#: ../../whatsnew/2.2.rst:712
msgid ""
"The most controversial change in Python 2.2 heralds the start of an effort "
"to fix an old design flaw that's been in Python from the beginning. "
"Currently Python's division operator, ``/``, behaves like C's division "
"operator when presented with two integer arguments: it returns an integer "
"result that's truncated down when there would be a fractional part.  For "
"example, ``3/2`` is 1, not 1.5, and ``(-1)/2`` is -1, not -0.5.  This means "
"that the results of division can vary unexpectedly depending on the type of "
"the two operands and because Python is dynamically typed, it can be "
"difficult to determine the possible types of the operands."
msgstr ""
"A alteração mais controversa no Python 2.2 marca o início de um esforço para "
"corrigir uma antiga falha de projeto que existe no Python desde o início. "
"Atualmente, o operador de divisão do Python, ``/``, comporta-se como o "
"operador de divisão do C quando apresentado com dois argumentos inteiros: "
"devolve um resultado inteiro que é truncado quando há uma parte fracionária. "
"Por exemplo, ``3/2`` é 1, não 1.5, e ``(-1)/2`` é -1, não -0.5. Isto "
"significa que os resultados da divisão podem variar inesperadamente "
"dependendo do tipo dos dois operandos e, como o Python é dinamicamente "
"tipado, pode ser difícil determinar os possíveis tipos dos operandos."

#: ../../whatsnew/2.2.rst:722
msgid ""
"(The controversy is over whether this is *really* a design flaw, and whether "
"it's worth breaking existing code to fix this.  It's caused endless "
"discussions on python-dev, and in July 2001 erupted into a storm of acidly "
"sarcastic postings on :newsgroup:`comp.lang.python`. I won't argue for "
"either side here and will stick to describing what's  implemented in 2.2.  "
"Read :pep:`238` for a summary of arguments and counter-arguments.)"
msgstr ""
"(A controvérsia é sobre se isto é *realmente* uma falha de projeto, e se "
"vale a pena quebrar código existente para corrigi-la. Isto causou discussões "
"intermináveis na python-dev, e em julho de 2001 explodiu numa tempestade de "
"publicações acidamente sarcásticas no :newsgroup:`comp.lang.python`. Não vou "
"argumentar a favor de nenhum dos lados aqui e vou limitar-me a descrever o "
"que está implementado no 2.2. Leia o :pep:`238` para um resumo dos "
"argumentos e contra-argumentos.)"

#: ../../whatsnew/2.2.rst:729
msgid ""
"Because this change might break code, it's being introduced very gradually. "
"Python 2.2 begins the transition, but the switch won't be complete until "
"Python 3.0."
msgstr ""
"Como esta alteração pode quebrar código, está a ser introduzida de forma "
"muito gradual. O Python 2.2 inicia a transição, mas a mudança não estará "
"completa até ao Python 3.0."

#: ../../whatsnew/2.2.rst:733
msgid ""
"First, I'll borrow some terminology from :pep:`238`.  \"True division\" is "
"the division that most non-programmers are familiar with: 3/2 is 1.5, 1/4 is "
"0.25, and so forth.  \"Floor division\" is what Python's ``/`` operator "
"currently does when given integer operands; the result is the floor of the "
"value returned by true division.  \"Classic division\" is the current mixed "
"behaviour of ``/``; it returns the result of floor division when the "
"operands are integers, and returns the result of true division when one of "
"the operands is a floating-point number."
msgstr ""
"Primeiro, vou usar alguma terminologia do :pep:`238`. \"Divisão verdadeira\" "
"é a divisão com que a maioria dos não-programadores está familiarizada: 3/2 "
"é 1.5, 1/4 é 0.25, e assim por diante. \"Divisão por defeito\" é o que o "
"operador ``/`` do Python faz atualmente quando recebe operandos inteiros; o "
"resultado é o valor por defeito do valor devolvido pela divisão verdadeira. "
"\"Divisão clássica\" é o comportamento misto atual de ``/``; devolve o "
"resultado da divisão por defeito quando os operandos são inteiros, e devolve "
"o resultado da divisão verdadeira quando um dos operandos é um número de "
"vírgula flutuante."

#: ../../whatsnew/2.2.rst:741
msgid "Here are the changes 2.2 introduces:"
msgstr "Aqui estão as alterações introduzidas no 2.2:"

#: ../../whatsnew/2.2.rst:743
msgid ""
"A new operator, ``//``, is the floor division operator. (Yes, we know it "
"looks like C++'s comment symbol.)  ``//`` *always* performs floor division "
"no matter what the types of its operands are, so ``1 // 2`` is 0 and "
"``1.0 // 2.0`` is also 0.0."
msgstr ""
"Um novo operador, ``//``, é o operador de divisão por defeito. (Sim, sabemos "
"que parece o símbolo de comentário do C++.) ``//`` *sempre* executa divisão "
"por defeito independentemente dos tipos dos seus operandos, pelo que ``1 // "
"2`` é 0 e ``1.0 // 2.0`` é também 0.0."

#: ../../whatsnew/2.2.rst:748
msgid ""
"``//`` is always available in Python 2.2; you don't need to enable it using "
"a ``__future__`` statement."
msgstr ""
"``//`` está sempre disponível no Python 2.2; não precisa de o ativar usando "
"uma instrução ``__future__``."

#: ../../whatsnew/2.2.rst:751
msgid ""
"By including a ``from __future__ import division`` in a module, the ``/`` "
"operator will be changed to return the result of true division, so ``1/2`` "
"is 0.5.  Without the ``__future__`` statement, ``/`` still means classic "
"division. The default meaning of ``/`` will not change until Python 3.0."
msgstr ""
"Ao incluir ``from __future__ import division`` num módulo, o operador ``/`` "
"será alterado para devolver o resultado da divisão verdadeira, pelo que "
"``1/2`` é 0.5. Sem a instrução ``__future__``, ``/`` ainda significa divisão "
"clássica. O significado predefinido de ``/`` não mudará até ao Python 3.0."

#: ../../whatsnew/2.2.rst:756
msgid ""
"Classes can define methods called :meth:`~object.__truediv__` and :meth:"
"`~object.__floordiv__` to overload the two division operators.  At the C "
"level, there are also slots in the :c:type:`PyNumberMethods` structure so "
"extension types can define the two operators."
msgstr ""
"As classes podem definir métodos chamados :meth:`~object.__truediv__` e :"
"meth:`~object.__floordiv__` para sobrecarregar os dois operadores de "
"divisão. Ao nível de C, também existem *slots* na estrutura :c:type:"
"`PyNumberMethods` para que os tipos de extensão possam definir os dois "
"operadores."

#: ../../whatsnew/2.2.rst:761
msgid ""
"Python 2.2 supports some command-line arguments for testing whether code "
"will work with the changed division semantics.  Running python with :option:"
"`!-Q warn` will cause a warning to be issued whenever division is applied to "
"two integers.  You can use this to find code that's affected by the change "
"and fix it.  By default, Python 2.2 will simply perform classic division "
"without a warning; the warning will be turned on by default in Python 2.3."
msgstr ""
"O Python 2.2 suporta alguns argumentos de linha de comandos para testar se o "
"código funcionará com a semântica de divisão alterada. Executar o Python "
"com :option:`!-Q warn` fará com que seja emitido um aviso sempre que a "
"divisão for aplicada a dois inteiros. Pode usar isto para encontrar código "
"afetado pela alteração e corrigi-lo. Por predefinição, o Python 2.2 "
"executará simplesmente a divisão clássica sem aviso; o aviso será ativado "
"por predefinição no Python 2.3."

#: ../../whatsnew/2.2.rst:771
msgid ":pep:`238` - Changing the Division Operator"
msgstr ":pep:`238` - Alteração do Operador de Divisão"

#: ../../whatsnew/2.2.rst:772
msgid ""
"Written by Moshe Zadka and  Guido van Rossum.  Implemented by Guido van "
"Rossum.."
msgstr ""
"Escrito por Moshe Zadka e Guido van Rossum. Implementado por Guido van "
"Rossum."

#: ../../whatsnew/2.2.rst:778
msgid "Unicode Changes"
msgstr "Alterações ao Unicode"

#: ../../whatsnew/2.2.rst:780
msgid ""
"Python's Unicode support has been enhanced a bit in 2.2.  Unicode strings "
"are usually stored as UCS-2, as 16-bit unsigned integers. Python 2.2 can "
"also be compiled to use UCS-4, 32-bit unsigned integers, as its internal "
"encoding by supplying :option:`!--enable-unicode=ucs4` to the configure "
"script.   (It's also possible to specify :option:`!--disable-unicode` to "
"completely disable Unicode support.)"
msgstr ""
"O suporte a Unicode do Python foi melhorado um pouco no 2.2. As strings "
"Unicode são normalmente armazenadas como UCS-2, como inteiros sem sinal de "
"16 bits. O Python 2.2 também pode ser compilado para usar UCS-4, inteiros "
"sem sinal de 32 bits, como codificação interna, fornecendo a opção :option:"
"`!--enable-unicode=ucs4` ao script de configuração. (Também é possível "
"especificar :option:`!--disable-unicode` para desativar completamente o "
"suporte a Unicode.)"

#: ../../whatsnew/2.2.rst:787
msgid ""
"When built to use UCS-4 (a \"wide Python\"), the interpreter can natively "
"handle Unicode characters from U+000000 to U+110000, so the range of legal "
"values for the :func:`!unichr` function is expanded accordingly.  Using an "
"interpreter compiled to use UCS-2 (a \"narrow Python\"), values greater than "
"65535 will still cause :func:`!unichr` to raise a :exc:`ValueError` "
"exception. This is all described in :pep:`261`, \"Support for 'wide' Unicode "
"characters\"; consult it for further details."
msgstr ""
"Quando compilado para usar UCS-4 (um \"Python largo\"), o interpretador pode "
"lidar nativamente com caracteres Unicode de U+000000 a U+110000, pelo que a "
"gama de valores legais para a função :func:`!unichr` é expandida de acordo. "
"Ao usar um interpretador compilado para usar UCS-2 (um \"Python estreito\"), "
"valores maiores que 65535 ainda farão com que :func:`!unichr` gere uma "
"exceção :exc:`ValueError`. Isto está tudo descrito no :pep:`261`, \"Suporte "
"para caracteres Unicode 'largos'\"; consulte-o para mais detalhes."

#: ../../whatsnew/2.2.rst:795
msgid ""
"Another change is simpler to explain. Since their introduction, Unicode "
"strings have supported an :meth:`!encode` method to convert the string to a "
"selected encoding such as UTF-8 or Latin-1.  A symmetric "
"``decode([*encoding*])`` method has been added to 8-bit strings (though not "
"to Unicode strings) in 2.2. :meth:`!decode` assumes that the string is in "
"the specified encoding and decodes it, returning whatever is returned by the "
"codec."
msgstr ""
"Outra alteração é mais simples de explicar. Desde a sua introdução, as "
"strings Unicode suportam um método :meth:`!encode` para converter a string "
"numa codificação selecionada, como UTF-8 ou Latin-1. Um método simétrico "
"``decode([*encoding*])`` foi adicionado às strings de 8 bits (embora não às "
"strings Unicode) no 2.2. :meth:`!decode` assume que a string está na "
"codificação especificada e descodifica-a, devolvendo o que for devolvido "
"pelo *codec*."

#: ../../whatsnew/2.2.rst:802
msgid ""
"Using this new feature, codecs have been added for tasks not directly "
"related to Unicode.  For example, codecs have been added for uu-encoding, "
"MIME's base64 encoding, and compression with the :mod:`zlib` module::"
msgstr ""
"Usando esta nova funcionalidade, *codecs* foram adicionados para tarefas não "
"diretamente relacionadas com Unicode. Por exemplo, *codecs* foram "
"adicionados para codificação uu, codificação base64 do MIME e compressão com "
"o módulo :mod:`zlib`::"

#: ../../whatsnew/2.2.rst:806
msgid ""
">>> s = \"\"\"Here is a lengthy piece of redundant, overly verbose,\n"
"... and repetitive text.\n"
"... \"\"\"\n"
">>> data = s.encode('zlib')\n"
">>> data\n"
"'x\\x9c\\r\\xc9\\xc1\\r\\x80 \\x10\\x04\\xc0?Ul...'\n"
">>> data.decode('zlib')\n"
"'Here is a lengthy piece of redundant, overly verbose,\\nand repetitive text."
"\\n'\n"
">>> print s.encode('uu')\n"
"begin 666 <data>\n"
"M2&5R92!I<R!A(&QE;F=T:'D@<&EE8V4@;V8@<F5D=6YD86YT+\"!O=F5R;'D@\n"
">=F5R8F]S92P*86YD(')E<&5T:71I=F4@=&5X=\"X*\n"
"\n"
"end\n"
">>> \"sheesh\".encode('rot-13')\n"
"'furrfu'"
msgstr ""
">>> s = \"\"\"Aqui está um longo texto redundante, excessivamente prolixo,\n"
"... e repetitivo.\n"
"... \"\"\"\n"
">>> data = s.encode('zlib')\n"
">>> data\n"
"'x\\x9c\\r\\xc9\\xc1\\r\\x80 \\x10\\x04\\xc0?Ul...'\n"
">>> data.decode('zlib')\n"
"'Aqui está um longo texto redundante, excessivamente prolixo,\\ne repetitivo."
"\\n'\n"
">>> print s.encode('uu')\n"
"begin 666 <data>\n"
"M2&5R92!I<R!A(&QE;F=T:'D@<&EE8V4@;V8@<F5D=6YD86YT+\"!O=F5R;'D@\n"
">=F5R8F]S92P*86YD(')E<&5T:71I=F4@=&5X=\"X*\n"
"\n"
"end\n"
">>> \"caramba\".encode('rot-13')\n"
"'penzno'"

#: ../../whatsnew/2.2.rst:823
msgid ""
"To convert a class instance to Unicode, a :meth:`!__unicode__` method can be "
"defined by a class, analogous to :meth:`!__str__`."
msgstr ""
"Para converter uma instância de classe para Unicode, um método :meth:`!"
"__unicode__` pode ser definido por uma classe, de forma análoga a :meth:`!"
"__str__`."

#: ../../whatsnew/2.2.rst:826
msgid ""
":meth:`!encode`, :meth:`!decode`, and :meth:`!__unicode__` were implemented "
"by Marc-André Lemburg.  The changes to support using UCS-4 internally were "
"implemented by Fredrik Lundh and Martin von Löwis."
msgstr ""
":meth:`!encode`, :meth:`!decode` e :meth:`!__unicode__` foram implementados "
"por Marc-André Lemburg. As alterações para suportar o uso interno de UCS-4 "
"foram implementadas por Fredrik Lundh e Martin von Löwis."

#: ../../whatsnew/2.2.rst:833
msgid ":pep:`261` - Support for 'wide' Unicode characters"
msgstr ":pep:`261` - Suporte para caracteres Unicode 'largos'"

#: ../../whatsnew/2.2.rst:834
msgid "Written by Paul Prescod."
msgstr "Escrito por Paul Prescod."

#: ../../whatsnew/2.2.rst:840
msgid "PEP 227: Nested Scopes"
msgstr "PEP 227: Âmbitos Aninhados"

#: ../../whatsnew/2.2.rst:842
msgid ""
"In Python 2.1, statically nested scopes were added as an optional feature, "
"to be enabled by a ``from __future__ import nested_scopes`` directive.  In "
"2.2 nested scopes no longer need to be specially enabled, and are now always "
"present.  The rest of this section is a copy of the description of nested "
"scopes from my \"What's New in Python 2.1\" document; if you read it when "
"2.1 came out, you can skip the rest of this section."
msgstr ""
"No Python 2.1, os âmbitos aninhados estáticos foram adicionados como uma "
"funcionalidade opcional, para ser ativada por uma diretiva ``from __future__ "
"import nested_scopes``. No Python 2.2, os âmbitos aninhados já não precisam "
"de ser ativados especialmente e estão agora sempre presentes. O resto desta "
"secção é uma cópia da descrição dos âmbitos aninhados do meu documento "
"\"Novidades do Python 2.1\"; se o leu quando o 2.1 foi lançado, pode saltar "
"o resto desta secção."

#: ../../whatsnew/2.2.rst:849
msgid ""
"The largest change introduced in Python 2.1, and made complete in 2.2, is to "
"Python's scoping rules.  In Python 2.0, at any given time there are at most "
"three namespaces used to look up variable names: local, module-level, and "
"the built-in namespace.  This often surprised people because it didn't match "
"their intuitive expectations.  For example, a nested recursive function "
"definition doesn't work::"
msgstr ""
"A maior alteração introduzida no Python 2.1, e completada no 2.2, é às "
"regras de âmbito do Python. No Python 2.0, em qualquer momento, existiam no "
"máximo três *namespaces* para procurar nomes de variáveis: local, ao nível "
"do módulo e o *namespace* integrado. Isto muitas vezes surpreendia as "
"pessoas porque não correspondia às suas expetativas intuitivas. Por exemplo, "
"uma definição de função recursiva aninhada não funcionava::"

#: ../../whatsnew/2.2.rst:856
msgid ""
"def f():\n"
"    ...\n"
"    def g(value):\n"
"        ...\n"
"        return g(value-1) + 1\n"
"    ..."
msgstr ""
"def f():\n"
"    ...\n"
"    def g(valor):\n"
"        ...\n"
"        return g(valor-1) + 1\n"
"    ..."

#: ../../whatsnew/2.2.rst:863
msgid ""
"The function :func:`!g` will always raise a :exc:`NameError` exception, "
"because the binding of the name ``g`` isn't in either its local namespace or "
"in the module-level namespace.  This isn't much of a problem in practice "
"(how often do you recursively define interior functions like this?), but "
"this also made using the :keyword:`lambda` expression clumsier, and this was "
"a problem in practice. In code which uses :keyword:`!lambda` you can often "
"find local variables being copied by passing them as the default values of "
"arguments. ::"
msgstr ""
"A função :func:`!g` irá sempre gerar uma exceção :exc:`NameError`, porque a "
"ligação do nome ``g`` não está no seu *namespace* local nem no *namespace* "
"ao nível do módulo. Isto não é um grande problema na prática (com que "
"frequência define funções interiores recursivas assim?), mas isto também "
"tornava o uso da expressão :keyword:`lambda` mais complicado, o que era um "
"problema real. Em código que usa :keyword:`!lambda`, é comum encontrar "
"variáveis locais copiadas ao passá-las como valores predefinidos de "
"argumentos. ::"

#: ../../whatsnew/2.2.rst:871
msgid ""
"def find(self, name):\n"
"    \"Return list of any entries equal to 'name'\"\n"
"    L = filter(lambda x, name=name: x == name,\n"
"               self.list_attribute)\n"
"    return L"
msgstr ""
"def find(self, nome):\n"
"    \"Devolve uma lista de entradas iguais a 'nome'\"\n"
"    L = filter(lambda x, nome=nome: x == nome,\n"
"               self.list_attribute)\n"
"    return L"

#: ../../whatsnew/2.2.rst:877
msgid ""
"The readability of Python code written in a strongly functional style "
"suffers greatly as a result."
msgstr ""
"A legibilidade do código Python escrito num estilo fortemente funcional fica "
"muito comprometida."

#: ../../whatsnew/2.2.rst:880
msgid ""
"The most significant change to Python 2.2 is that static scoping has been "
"added to the language to fix this problem.  As a first effect, the "
"``name=name`` default argument is now unnecessary in the above example.  Put "
"simply, when a given variable name is not assigned a value within a function "
"(by an assignment, or the :keyword:`def`, :keyword:`class`, or :keyword:"
"`import` statements), references to the variable will be looked up in the "
"local namespace of the enclosing scope.  A more detailed explanation of the "
"rules, and a dissection of the implementation, can be found in the PEP."
msgstr ""
"A alteração mais significativa no Python 2.2 é a adição de âmbitos estáticos "
"à linguagem para resolver este problema. Como primeiro efeito, o argumento "
"predefinido ``name=name`` já não é necessário no exemplo acima. Em resumo, "
"quando um nome de variável não recebe um valor dentro de uma função (por "
"atribuição, ou através das instruções :keyword:`def`, :keyword:`class`, ou :"
"keyword:`import`), as referências à variável serão procuradas no *namespace* "
"local do âmbito que a contém. Uma explicação mais detalhada das regras e uma "
"análise da implementação podem ser encontradas no PEP."

#: ../../whatsnew/2.2.rst:889
msgid ""
"This change may cause some compatibility problems for code where the same "
"variable name is used both at the module level and as a local variable "
"within a function that contains further function definitions. This seems "
"rather unlikely though, since such code would have been pretty confusing to "
"read in the first place."
msgstr ""
"Esta alteração pode causar alguns problemas de compatibilidade em código "
"onde o mesmo nome de variável é usado ao nível do módulo e como variável "
"local dentro de uma função que contém outras definições de funções. No "
"entanto, isto parece pouco provável, pois esse tipo de código já seria "
"confuso de ler."

#: ../../whatsnew/2.2.rst:895
msgid ""
"One side effect of the change is that the ``from module import *`` and "
"``exec`` statements have been made illegal inside a function scope under "
"certain conditions.  The Python reference manual has said all along that "
"``from module import *`` is only legal at the top level of a module, but the "
"CPython interpreter has never enforced this before.  As part of the "
"implementation of nested scopes, the compiler which turns Python source into "
"bytecodes has to generate different code to access variables in a containing "
"scope.  ``from module import *`` and ``exec`` make it impossible for the "
"compiler to figure this out, because they add names to the local namespace "
"that are unknowable at compile time. Therefore, if a function contains "
"function definitions or :keyword:`lambda` expressions with free variables, "
"the compiler will flag this by raising a :exc:`SyntaxError` exception."
msgstr ""
"Um efeito secundário desta alteração é que as instruções ``from module "
"import *`` e ``exec`` foram tornadas ilegais dentro de um âmbito de função "
"em certas condições. O manual de referência do Python sempre afirmou que "
"``from module import *`` só é legal ao nível superior de um módulo, mas o "
"interpretador CPython nunca impôs esta regra. Como parte da implementação "
"dos âmbitos aninhados, o compilador que converte o código-fonte Python em "
"*bytecodes* tem de gerar código diferente para aceder a variáveis num âmbito "
"contido. As instruções ``from module import *`` e ``exec`` tornam impossível "
"para o compilador determinar isto, pois adicionam nomes ao *namespace* local "
"que são desconhecidos em tempo de compilação. Portanto, se uma função "
"contiver definições de funções ou expressões :keyword:`lambda` com variáveis "
"livres, o compilador irá sinalizar isto ao gerar uma exceção :exc:"
"`SyntaxError`."

#: ../../whatsnew/2.2.rst:908
msgid "To make the preceding explanation a bit clearer, here's an example::"
msgstr "Para tornar a explicação anterior mais clara, aqui está um exemplo::"

#: ../../whatsnew/2.2.rst:910
msgid ""
"x = 1\n"
"def f():\n"
"    # The next line is a syntax error\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"
msgstr ""
"x = 1\n"
"def f():\n"
"    # A linha seguinte é um erro de sintaxe\n"
"    exec 'x=2'\n"
"    def g():\n"
"        return x"

#: ../../whatsnew/2.2.rst:917
msgid ""
"Line 4 containing the ``exec`` statement is a syntax error, since ``exec`` "
"would define a new local variable named ``x`` whose value should be accessed "
"by :func:`!g`."
msgstr ""
"A linha 4 que contém a instrução ``exec`` é um erro de sintaxe, pois "
"``exec`` definiria uma nova variável local chamada ``x`` cujo valor seria "
"acedido por :func:`!g`."

#: ../../whatsnew/2.2.rst:921
msgid ""
"This shouldn't be much of a limitation, since ``exec`` is rarely used in "
"most Python code (and when it is used, it's often a sign of a poor design "
"anyway)."
msgstr ""
"Isto não deve ser uma grande limitação, pois ``exec`` é raramente usado na "
"maior parte do código Python (e quando é usado, é muitas vezes sinal de um "
"mau projeto)."

#: ../../whatsnew/2.2.rst:928
msgid ":pep:`227` - Statically Nested Scopes"
msgstr ":pep:`227` - Âmbitos Aninhados Estáticos"

#: ../../whatsnew/2.2.rst:929
msgid "Written and implemented by Jeremy Hylton."
msgstr "Escrito e implementado por Jeremy Hylton."

#: ../../whatsnew/2.2.rst:935
msgid "New and Improved Modules"
msgstr "Módulos Novos e Melhorados"

#: ../../whatsnew/2.2.rst:937
msgid ""
"The :mod:`xmlrpclib <xmlrpc.client>` module was contributed to the standard "
"library by Fredrik Lundh, providing support for writing XML-RPC clients.  "
"XML-RPC is a simple remote procedure call protocol built on top of HTTP and "
"XML. For example, the following snippet retrieves a list of RSS channels "
"from the O'Reilly Network, and then  lists the recent headlines for one "
"channel::"
msgstr ""
"O módulo :mod:`xmlrpclib <xmlrpc.client>` foi contribuído para a biblioteca "
"padrão por Fredrik Lundh, fornecendo suporte para escrever clientes XML-RPC. "
"XML-RPC é um protocolo simples de chamada de procedimento remoto construído "
"sobre HTTP e XML. Por exemplo, o seguinte trecho de código obtém uma lista "
"de canais RSS da O'Reilly Network e, em seguida, lista os títulos recentes "
"de um canal::"

#: ../../whatsnew/2.2.rst:943
msgid ""
"import xmlrpclib\n"
"s = xmlrpclib.Server(\n"
"      'http://www.oreillynet.com/meerkat/xml-rpc/server.php')\n"
"channels = s.meerkat.getChannels()\n"
"# channels is a list of dictionaries, like this:\n"
"# [{'id': 4, 'title': 'Freshmeat Daily News'}\n"
"#  {'id': 190, 'title': '32Bits Online'},\n"
"#  {'id': 4549, 'title': '3DGamers'}, ... ]\n"
"\n"
"# Get the items for one channel\n"
"items = s.meerkat.getItems( {'channel': 4} )\n"
"\n"
"# 'items' is another list of dictionaries, like this:\n"
"# [{'link': 'http://freshmeat.net/releases/52719/',\n"
"#   'description': 'A utility which converts HTML to XSL FO.',\n"
"#   'title': 'html2fo 0.3 (Default)'}, ... ]"
msgstr ""
"import xmlrpclib\n"
"s = xmlrpclib.Server(\n"
"      'http://www.oreillynet.com/meerkat/xml-rpc/server.php')\n"
"channels = s.meerkat.getChannels()\n"
"# channels é uma lista de dicionários, como esta:\n"
"# [{'id': 4, 'title': 'Notícias Diárias do Freshmeat'}\n"
"#  {'id': 190, 'title': '32Bits Online'},\n"
"#  {'id': 4549, 'title': '3DGamers'}, ... ]\n"
"\n"
"# Obter os itens para um canal\n"
"items = s.meerkat.getItems( {'channel': 4} )\n"
"\n"
"# 'items' é outra lista de dicionários, como esta:\n"
"# [{'link': 'http://freshmeat.net/releases/52719/',\n"
"#   'description': 'Uma utilidade que converte HTML para XSL FO.',\n"
"#   'title': 'html2fo 0.3 (Predefinição)'}, ... ]"

#: ../../whatsnew/2.2.rst:960
msgid ""
"The :mod:`SimpleXMLRPCServer <xmlrpc.server>` module makes it easy to create "
"straightforward XML-RPC servers.  See http://xmlrpc.scripting.com/ for more "
"information about XML-RPC."
msgstr ""
"O módulo :mod:`SimpleXMLRPCServer <xmlrpc.server>` facilita a criação de "
"servidores XML-RPC diretos. Consulte http://xmlrpc.scripting.com/ para mais "
"informações sobre XML-RPC."

#: ../../whatsnew/2.2.rst:963
msgid ""
"The new :mod:`hmac` module implements the HMAC algorithm described by :rfc:"
"`2104`. (Contributed by Gerhard Häring.)"
msgstr ""
"O novo módulo :mod:`hmac` implementa o algoritmo HMAC descrito na :rfc:"
"`2104`. (Contribuído por Gerhard Häring.)"

#: ../../whatsnew/2.2.rst:966
msgid ""
"Several functions that originally returned lengthy tuples now return pseudo-"
"sequences that still behave like tuples but also have mnemonic attributes "
"such as :attr:`!memberst_mtime` or :attr:`~time.struct_time.tm_year`. The "
"enhanced functions include :func:`~os.stat`, :func:`~os.fstat`, :func:`~os."
"statvfs`, and :func:`~os.fstatvfs` in the :mod:`os` module, and :func:`~time."
"localtime`, :func:`~time.gmtime`, and :func:`~time.strptime` in the :mod:"
"`time` module."
msgstr ""
"Várias funções que originalmente devolviam tuplos longos agora devolvem "
"pseudo-sequências que ainda se comportam como tuplos, mas também têm "
"atributos mnemónicos como :attr:`!memberst_mtime` ou :attr:`~time."
"struct_time.tm_year`. As funções melhoradas incluem :func:`~os.stat`, :func:"
"`~os.fstat`, :func:`~os.statvfs` e :func:`~os.fstatvfs` no módulo :mod:`os`, "
"e :func:`~time.localtime`, :func:`~time.gmtime` e :func:`~time.strptime` no "
"módulo :mod:`time`."

#: ../../whatsnew/2.2.rst:973
msgid ""
"For example, to obtain a file's size using the old tuples, you'd end up "
"writing something like ``file_size = os.stat(filename)[stat.ST_SIZE]``, but "
"now this can be written more clearly as ``file_size = os.stat(filename)."
"st_size``."
msgstr ""
"Por exemplo, para obter o tamanho de um ficheiro usando os tuplos antigos, "
"acabaria por escrever algo como ``file_size = os.stat(filename)[stat."
"ST_SIZE]``, mas agora isto pode ser escrito de forma mais clara como "
"``file_size = os.stat(filename).st_size``."

#: ../../whatsnew/2.2.rst:977
msgid "The original patch for this feature was contributed by Nick Mathewson."
msgstr ""
"O *patch* original para esta funcionalidade foi contribuído por Nick "
"Mathewson."

#: ../../whatsnew/2.2.rst:979
msgid ""
"The Python profiler has been extensively reworked and various errors in its "
"output have been corrected.  (Contributed by Fred L. Drake, Jr. and Tim "
"Peters.)"
msgstr ""
"O perfilador do Python foi extensivamente refeito e vários erros na sua "
"saída foram corrigidos. (Contribuído por Fred L. Drake, Jr. e Tim Peters.)"

#: ../../whatsnew/2.2.rst:982
msgid ""
"The :mod:`socket` module can be compiled to support IPv6; specify the :"
"option:`!--enable-ipv6` option to Python's configure script.  (Contributed "
"by Jun-ichiro \"itojun\" Hagino.)"
msgstr ""
"O módulo :mod:`socket` pode ser compilado para suportar IPv6; especifique a "
"opção :option:`!--enable-ipv6` no script de configuração do Python. "
"(Contribuído por Jun-ichiro \"itojun\" Hagino.)"

#: ../../whatsnew/2.2.rst:986
msgid ""
"Two new format characters were added to the :mod:`struct` module for 64-bit "
"integers on platforms that support the C :c:expr:`long long` type.  ``q`` is "
"for a signed 64-bit integer, and ``Q`` is for an unsigned one.  The value is "
"returned in Python's long integer type.  (Contributed by Tim Peters.)"
msgstr ""
"Dois novos caracteres de formato foram adicionados ao módulo :mod:`struct` "
"para inteiros de 64 bits em plataformas que suportam o tipo C :c:expr:`long "
"long`. ``q`` é para um inteiro de 64 bits com sinal, e ``Q`` é para um sem "
"sinal. O valor é devolvido no tipo de inteiro longo do Python. (Contribuído "
"por Tim Peters.)"

#: ../../whatsnew/2.2.rst:991
msgid ""
"In the interpreter's interactive mode, there's a new built-in function :func:"
"`help` that uses the :mod:`pydoc` module introduced in Python 2.1 to provide "
"interactive help. ``help(object)`` displays any available help text about "
"*object*.  :func:`help` with no argument puts you in an online help utility, "
"where you can enter the names of functions, classes, or modules to read "
"their help text. (Contributed by Guido van Rossum, using Ka-Ping Yee's :mod:"
"`pydoc` module.)"
msgstr ""
"No modo interativo do interpretador, existe uma nova função integrada :func:"
"`help` que usa o módulo :mod:`pydoc`, introduzido no Python 2.1, para "
"fornecer ajuda interativa. ``help(object)`` mostra qualquer texto de ajuda "
"disponível sobre *object*. :func:`help` sem argumentos coloca-o numa "
"utilidade de ajuda *online*, onde pode introduzir os nomes de funções, "
"classes ou módulos para ler o seu texto de ajuda. (Contribuído por Guido van "
"Rossum, usando o módulo :mod:`pydoc` de Ka-Ping Yee.)"

#: ../../whatsnew/2.2.rst:999
msgid ""
"Various bugfixes and performance improvements have been made to the SRE "
"engine underlying the :mod:`re` module.  For example, the :func:`re.sub` "
"and :func:`re.split` functions have been rewritten in C.  Another "
"contributed patch speeds up certain Unicode character ranges by a factor of "
"two, and a new :meth:`~re.finditer`  method that returns an iterator over "
"all the non-overlapping matches in  a given string.  (SRE is maintained by "
"Fredrik Lundh.  The BIGCHARSET patch was contributed by Martin von Löwis.)"
msgstr ""
"Várias correções de *bugs* e melhorias de desempenho foram feitas no motor "
"SRE subjacente ao módulo :mod:`re`. Por exemplo, as funções :func:`re.sub` "
"e :func:`re.split` foram reescritas em C. Outro *patch* contribuído acelera "
"certos intervalos de caracteres Unicode por um fator de dois, e um novo "
"método :meth:`~re.finditer` que devolve um iterador sobre todas as "
"correspondências não sobrepostas numa string dada. (O SRE é mantido por "
"Fredrik Lundh. O *patch* BIGCHARSET foi contribuído por Martin von Löwis.)"

#: ../../whatsnew/2.2.rst:1007
msgid ""
"The :mod:`smtplib` module now supports :rfc:`2487`, \"Secure SMTP over "
"TLS\", so it's now possible to encrypt the SMTP traffic between a Python "
"program and the mail transport agent being handed a message.  :mod:`smtplib` "
"also supports SMTP authentication.  (Contributed by Gerhard Häring.)"
msgstr ""
"O módulo :mod:`smtplib` agora suporta :rfc:`2487`, \"SMTP Seguro sobre "
"TLS\", pelo que é agora possível encriptar o tráfego SMTP entre um programa "
"Python e o agente de transporte de correio que recebe uma mensagem. O "
"módulo :mod:`smtplib` também suporta autenticação SMTP. (Contribuído por "
"Gerhard Häring.)"

#: ../../whatsnew/2.2.rst:1012
msgid ""
"The :mod:`imaplib` module, maintained by Piers Lauder, has support for "
"several new extensions: the NAMESPACE extension defined in :rfc:`2342`, "
"SORT, GETACL and SETACL.  (Contributed by Anthony Baxter and Michel "
"Pelletier.)"
msgstr ""
"O módulo :mod:`imaplib`, mantido por Piers Lauder, tem suporte para várias "
"novas extensões: a extensão NAMESPACE definida na :rfc:`2342`, SORT, GETACL "
"e SETACL. (Contribuído por Anthony Baxter e Michel Pelletier.)"

#: ../../whatsnew/2.2.rst:1016
msgid ""
"The :mod:`!rfc822` module's parsing of email addresses is now compliant "
"with :rfc:`2822`, an update to :rfc:`822`.  (The module's name is *not* "
"going to be changed to ``rfc2822``.)  A new package, :mod:`email`, has also "
"been added for parsing and generating e-mail messages.  (Contributed by "
"Barry Warsaw, and arising out of his work on Mailman.)"
msgstr ""
"A análise de endereços de e-mail do módulo :mod:`!rfc822` agora está em "
"conformidade com a :rfc:`2822`, uma atualização da :rfc:`822`. (O nome do "
"módulo *não* será alterado para ``rfc2822``.) Um novo pacote, :mod:`email`, "
"também foi adicionado para analisar e gerar mensagens de e-mail. "
"(Contribuído por Barry Warsaw, e resultante do seu trabalho no Mailman.)"

#: ../../whatsnew/2.2.rst:1022
msgid ""
"The :mod:`difflib` module now contains a new :class:`!Differ` class for "
"producing human-readable lists of changes (a \"delta\") between two "
"sequences of lines of text.  There are also two generator functions, :func:`!"
"ndiff` and :func:`!restore`, which respectively return a delta from two "
"sequences, or one of the original sequences from a delta. (Grunt work "
"contributed by David Goodger, from ndiff.py code by Tim Peters who then did "
"the generatorization.)"
msgstr ""
"O módulo :mod:`difflib` agora contém uma nova classe :class:`!Differ` para "
"produzir listas legíveis de alterações (um \"delta\") entre duas sequências "
"de linhas de texto. Também existem duas funções geradoras, :func:`!ndiff` e :"
"func:`!restore`, que devolvem respetivamente um delta a partir de duas "
"sequências, ou uma das sequências originais a partir de um delta. (Trabalho "
"árduo contribuído por David Goodger, a partir de código ndiff.py de Tim "
"Peters, que depois fez a conversão para geradores.)"

#: ../../whatsnew/2.2.rst:1029
msgid ""
"New constants :const:`!ascii_letters`, :const:`!ascii_lowercase`, and :const:"
"`!ascii_uppercase` were added to the :mod:`string` module.  There were "
"several modules in the standard library that used :const:`!string.letters` "
"to mean the ranges A-Za-z, but that assumption is incorrect when locales are "
"in use, because :const:`!string.letters` varies depending on the set of "
"legal characters defined by the current locale.  The buggy modules have all "
"been fixed to use :const:`!ascii_letters` instead. (Reported by an unknown "
"person; fixed by Fred L. Drake, Jr.)"
msgstr ""
"Novas constantes :const:`!ascii_letters`, :const:`!ascii_lowercase` e :const:"
"`!ascii_uppercase` foram adicionadas ao módulo :mod:`string`. Existiam "
"vários módulos na biblioteca padrão que usavam :const:`!string.letters` para "
"significar os intervalos A-Za-z, mas essa suposição é incorreta quando "
"locales estão em uso, porque :const:`!string.letters` varia dependendo do "
"conjunto de caracteres legais definido pelo locale atual. Os módulos com "
"*bugs* foram todos corrigidos para usar :const:`!ascii_letters` em vez "
"disso. (Reportado por uma pessoa desconhecida; corrigido por Fred L. Drake, "
"Jr.)"

#: ../../whatsnew/2.2.rst:1038
msgid ""
"The :mod:`mimetypes` module now makes it easier to use alternative MIME-type "
"databases by the addition of a :class:`~mimetypes.MimeTypes` class, which "
"takes a list of filenames to be parsed.  (Contributed by Fred L. Drake, Jr.)"
msgstr ""
"O módulo :mod:`mimetypes` agora facilita o uso de bases de dados de tipos "
"MIME alternativas através da adição de uma classe :class:`~mimetypes."
"MimeTypes`, que recebe uma lista de nomes de ficheiros a serem analisados. "
"(Contribuído por Fred L. Drake, Jr.)"

#: ../../whatsnew/2.2.rst:1042
msgid ""
"A :class:`~threading.Timer` class was added to the :mod:`threading` module "
"that allows scheduling an activity to happen at some future time.  "
"(Contributed by Itamar Shtull-Trauring.)"
msgstr ""
"Uma classe :class:`~threading.Timer` foi adicionada ao módulo :mod:"
"`threading`, que permite agendar uma atividade para ocorrer num momento "
"futuro. (Contribuído por Itamar Shtull-Trauring.)"

#: ../../whatsnew/2.2.rst:1050
msgid "Interpreter Changes and Fixes"
msgstr "Alterações e Correções do Interpretador"

#: ../../whatsnew/2.2.rst:1052
msgid ""
"Some of the changes only affect people who deal with the Python interpreter "
"at the C level because they're writing Python extension modules, embedding "
"the interpreter, or just hacking on the interpreter itself. If you only "
"write Python code, none of the changes described here will affect you very "
"much."
msgstr ""
"Algumas das alterações só afetam pessoas que trabalham com o interpretador "
"Python ao nível de C, porque estão a escrever módulos de extensão Python, a "
"incorporar o interpretador ou simplesmente a modificá-lo. Se só escreve "
"código Python, nenhuma das alterações aqui descritas o afetará muito."

#: ../../whatsnew/2.2.rst:1057
msgid ""
"Profiling and tracing functions can now be implemented in C, which can "
"operate at much higher speeds than Python-based functions and should reduce "
"the overhead of profiling and tracing.  This  will be of interest to authors "
"of development environments for Python.  Two new C functions were added to "
"Python's API, :c:func:`PyEval_SetProfile` and :c:func:`PyEval_SetTrace`. The "
"existing :func:`sys.setprofile` and :func:`sys.settrace` functions still "
"exist, and have simply been changed to use the new C-level interface.  "
"(Contributed by Fred L. Drake, Jr.)"
msgstr ""
"Funções de perfilagem e rastreio podem agora ser implementadas em C, o que "
"pode operar a velocidades muito mais altas do que funções baseadas em Python "
"e deve reduzir a sobrecarga de perfilagem e rastreio. Isto será do interesse "
"de autores de ambientes de desenvolvimento para Python. Duas novas funções "
"em C foram adicionadas à API do Python, :c:func:`PyEval_SetProfile` e :c:"
"func:`PyEval_SetTrace`. As funções existentes :func:`sys.setprofile` e :func:"
"`sys.settrace` ainda existem e foram simplesmente alteradas para usar a nova "
"interface ao nível de C. (Contribuído por Fred L. Drake, Jr.)"

#: ../../whatsnew/2.2.rst:1066
msgid ""
"Another low-level API, primarily of interest to implementers of Python "
"debuggers and development tools, was added. :c:func:"
"`PyInterpreterState_Head` and :c:func:`PyInterpreterState_Next` let a caller "
"walk through all the existing interpreter objects; :c:func:"
"`PyInterpreterState_ThreadHead` and :c:func:`PyThreadState_Next` allow "
"looping over all the thread states for a given interpreter.  (Contributed by "
"David Beazley.)"
msgstr ""
"Outra API de baixo nível, principalmente de interesse para implementadores "
"de depuradores e ferramentas de desenvolvimento Python, foi adicionada. :c:"
"func:`PyInterpreterState_Head` e :c:func:`PyInterpreterState_Next` permitem "
"que um chamador percorra todos os objetos do interpretador existentes; :c:"
"func:`PyInterpreterState_ThreadHead` e :c:func:`PyThreadState_Next` permitem "
"percorrer todos os estados de *thread* para um determinado interpretador. "
"(Contribuído por David Beazley.)"

#: ../../whatsnew/2.2.rst:1073
msgid ""
"The C-level interface to the garbage collector has been changed to make it "
"easier to write extension types that support garbage collection and to debug "
"misuses of the functions. Various functions have slightly different "
"semantics, so a bunch of functions had to be renamed.  Extensions that use "
"the old API will still compile but will *not* participate in garbage "
"collection, so updating them for 2.2 should be considered fairly high "
"priority."
msgstr ""
"A interface ao nível de C para o recolhedor de lixo foi alterada para "
"facilitar a escrita de tipos de extensão que suportam recolha de lixo e para "
"depurar usos incorretos das funções. Várias funções têm semânticas "
"ligeiramente diferentes, pelo que um conjunto de funções teve de ser "
"renomeado. Extensões que usam a API antiga ainda compilarão, mas *não* "
"participarão na recolha de lixo, pelo que atualizá-las para o 2.2 deve ser "
"considerado uma prioridade bastante alta."

#: ../../whatsnew/2.2.rst:1080
msgid ""
"To upgrade an extension module to the new API, perform the following steps:"
msgstr ""
"Para atualizar um módulo de extensão para a nova API, execute os seguintes "
"passos:"

#: ../../whatsnew/2.2.rst:1082
msgid "Rename :c:macro:`!Py_TPFLAGS_GC` to :c:macro:`Py_TPFLAGS_HAVE_GC`."
msgstr "Renomeie :c:macro:`!Py_TPFLAGS_GC` para :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../whatsnew/2.2.rst:1084
msgid ""
"Use :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar` to allocate"
msgstr ""
"Use :c:func:`PyObject_GC_New` ou :c:func:`PyObject_GC_NewVar` para alocar"

#: ../../whatsnew/2.2.rst:1085
msgid "objects, and :c:func:`PyObject_GC_Del` to deallocate them."
msgstr "objetos, e :c:func:`PyObject_GC_Del` para os desalocar."

#: ../../whatsnew/2.2.rst:1087
msgid ""
"Rename :c:func:`!PyObject_GC_Init` to :c:func:`PyObject_GC_Track` and :c:"
"func:`!PyObject_GC_Fini` to :c:func:`PyObject_GC_UnTrack`."
msgstr ""
"Renomeie :c:func:`!PyObject_GC_Init` para :c:func:`PyObject_GC_Track` e :c:"
"func:`!PyObject_GC_Fini` para :c:func:`PyObject_GC_UnTrack`."

#: ../../whatsnew/2.2.rst:1090
msgid "Remove :c:macro:`!PyGC_HEAD_SIZE` from object size calculations."
msgstr "Remova :c:macro:`!PyGC_HEAD_SIZE` dos cálculos de tamanho de objeto."

#: ../../whatsnew/2.2.rst:1092
msgid ""
"Remove calls to :c:func:`!PyObject_AS_GC` and :c:func:`!PyObject_FROM_GC`."
msgstr ""
"Remova chamadas a :c:func:`!PyObject_AS_GC` e :c:func:`!PyObject_FROM_GC`."

#: ../../whatsnew/2.2.rst:1094
msgid ""
"A new ``et`` format sequence was added to :c:func:`PyArg_ParseTuple`; ``et`` "
"takes both a parameter and an encoding name, and converts the parameter to "
"the given encoding if the parameter turns out to be a Unicode string, or "
"leaves it alone if it's an 8-bit string, assuming it to already be in the "
"desired encoding.  This differs from the ``es`` format character, which "
"assumes that 8-bit strings are in Python's default ASCII encoding and "
"converts them to the specified new encoding. (Contributed by M.-A. Lemburg, "
"and used for the MBCS support on Windows described in the following section.)"
msgstr ""
"Uma nova sequência de formato ``et`` foi adicionada a :c:func:"
"`PyArg_ParseTuple`; ``et`` recebe tanto um parâmetro como um nome de "
"codificação, e converte o parâmetro para a codificação dada se o parâmetro "
"for uma string Unicode, ou deixa-o como está se for uma string de 8 bits, "
"assumindo que já está na codificação desejada. Isto difere do carácter de "
"formato ``es``, que assume que as strings de 8 bits estão na codificação "
"ASCII predefinida do Python e as converte para a nova codificação "
"especificada. (Contribuído por M.-A. Lemburg, e usado para o suporte MBCS no "
"Windows descrita na secção seguinte.)"

#: ../../whatsnew/2.2.rst:1103
msgid ""
"A different argument parsing function, :c:func:`PyArg_UnpackTuple`, has been "
"added that's simpler and presumably faster.  Instead of specifying a format "
"string, the caller simply gives the minimum and maximum number of arguments "
"expected, and a set of pointers to :c:expr:`PyObject*` variables that will "
"be filled in with argument values."
msgstr ""
"Uma função de análise de argumentos diferente, :c:func:`PyArg_UnpackTuple`, "
"foi adicionada, que é mais simples e presumivelmente mais rápida. Em vez de "
"especificar uma string de formato, o chamador simplesmente indica o número "
"mínimo e máximo de argumentos esperados, e um conjunto de ponteiros para "
"variáveis :c:expr:`PyObject*` que serão preenchidas com os valores dos "
"argumentos."

#: ../../whatsnew/2.2.rst:1109
msgid ""
"Two new flags :c:macro:`METH_NOARGS` and :c:macro:`METH_O` are available in "
"method definition tables to simplify implementation of methods with no "
"arguments or a single untyped argument. Calling such methods is more "
"efficient than calling a corresponding method that uses :c:macro:"
"`METH_VARARGS`.  Also, the old :c:macro:`!METH_OLDARGS` style of writing C "
"methods is  now officially deprecated."
msgstr ""
"Dois novos *flags* :c:macro:`METH_NOARGS` e :c:macro:`METH_O` estão "
"disponíveis em tabelas de definição de métodos para simplificar a "
"implementação de métodos sem argumentos ou com um único argumento não "
"tipado. Chamar tais métodos é mais eficiente do que chamar um método "
"correspondente que usa :c:macro:`METH_VARARGS`. Além disso, o antigo estilo :"
"c:macro:`!METH_OLDARGS` de escrever métodos em C está agora oficialmente "
"obsoleto."

#: ../../whatsnew/2.2.rst:1115
msgid ""
"Two new wrapper functions, :c:func:`PyOS_snprintf` and :c:func:"
"`PyOS_vsnprintf` were added to provide  cross-platform implementations for "
"the relatively new :c:func:`snprintf` and :c:func:`vsnprintf` C lib APIs. In "
"contrast to the standard :c:func:`sprintf` and :c:func:`!vsprintf` "
"functions, the Python versions check the bounds of the buffer used to "
"protect against buffer overruns. (Contributed by M.-A. Lemburg.)"
msgstr ""
"Duas novas funções de encapsulamento, :c:func:`PyOS_snprintf` e :c:func:"
"`PyOS_vsnprintf`, foram adicionadas para fornecer implementações "
"multiplataforma para as APIs relativamente novas :c:func:`snprintf` e :c:"
"func:`vsnprintf` da biblioteca C. Em contraste com as funções padrão :c:func:"
"`sprintf` e :c:func:`!vsprintf`, as versões do Python verificam os limites "
"do *buffer* usado para proteger contra transbordamentos de *buffer*. "
"(Contribuído por M.-A. Lemburg.)"

#: ../../whatsnew/2.2.rst:1122
msgid ""
"The :c:func:`_PyTuple_Resize` function has lost an unused parameter, so now "
"it takes 2 parameters instead of 3.  The third argument was never used, and "
"can simply be discarded when porting code from earlier versions to Python "
"2.2."
msgstr ""
"A função :c:func:`_PyTuple_Resize` perdeu um parâmetro não utilizado, pelo "
"que agora recebe 2 parâmetros em vez de 3. O terceiro argumento nunca foi "
"usado e pode simplesmente ser descartado ao portar código de versões "
"anteriores para o Python 2.2."

#: ../../whatsnew/2.2.rst:1130
msgid "Other Changes and Fixes"
msgstr "Outras Alterações e Correções"

#: ../../whatsnew/2.2.rst:1132
msgid ""
"As usual there were a bunch of other improvements and bugfixes scattered "
"throughout the source tree.  A search through the CVS change logs finds "
"there were 527 patches applied and 683 bugs fixed between Python 2.1 and "
"2.2; 2.2.1 applied 139 patches and fixed 143 bugs; 2.2.2 applied 106 patches "
"and fixed 82 bugs.  These figures are likely to be underestimates."
msgstr ""
"Como habitual, houve um conjunto de outras melhorias e correções de *bugs* "
"espalhadas por toda a árvore de origem. Uma pesquisa nos registos de "
"alterações do CVS revela que foram aplicados 527 *patches* e corrigidos 683 "
"*bugs* entre o Python 2.1 e o 2.2; o 2.2.1 aplicou 139 *patches* e corrigiu "
"143 *bugs*; o 2.2.2 aplicou 106 *patches* e corrigiu 82 *bugs*. Estes "
"números são provavelmente subestimados."

#: ../../whatsnew/2.2.rst:1138
msgid "Some of the more notable changes are:"
msgstr "Algumas das alterações mais notáveis são:"

#: ../../whatsnew/2.2.rst:1140
msgid ""
"The code for the MacOS port for Python, maintained by Jack Jansen, is now "
"kept in the main Python CVS tree, and many changes have been made to support "
"MacOS X."
msgstr ""
"O código para a portagem do Python para MacOS, mantido por Jack Jansen, está "
"agora guardado na árvore principal do CVS do Python, e muitas alterações "
"foram feitas para suportar o MacOS X."

#: ../../whatsnew/2.2.rst:1143
msgid ""
"The most significant change is the ability to build Python as a framework, "
"enabled by supplying the :option:`!--enable-framework` option to the "
"configure script when compiling Python.  According to Jack Jansen, \"This "
"installs a self-contained Python installation plus the OS X framework "
"\"glue\" into :file:`/Library/Frameworks/Python.framework` (or another "
"location of choice). For now there is little immediate added benefit to this "
"(actually, there is the disadvantage that you have to change your PATH to be "
"able to find Python), but it is the basis for creating a full-blown Python "
"application, porting the MacPython IDE, possibly using Python as a standard "
"OSA scripting language and much more.\""
msgstr ""
"A alteração mais significativa é a capacidade de compilar o Python como um "
"*framework*, ativada fornecendo a opção :option:`!--enable-framework` ao "
"script de configuração ao compilar o Python. Segundo Jack Jansen, \"Isto "
"instala uma instalação autónoma do Python mais a \"cola\" do *framework* OS "
"X em :file:`/Library/Frameworks/Python.framework` (ou outro local à "
"escolha). Por enquanto, há pouco benefício imediato nisto (na verdade, há a "
"desvantagem de ter de alterar o seu PATH para poder encontrar o Python), mas "
"é a base para criar uma aplicação Python completa, portar o IDE MacPython, "
"possivelmente usar o Python como uma linguagem de *scripting* OSA padrão e "
"muito mais.\""

#: ../../whatsnew/2.2.rst:1154
msgid ""
"Most of the MacPython toolbox modules, which interface to MacOS APIs such as "
"windowing, QuickTime, scripting, etc. have been ported to OS X, but they've "
"been left commented out in :file:`setup.py`.  People who want to experiment "
"with these modules can uncomment them manually."
msgstr ""
"A maioria dos módulos da caixa de ferramentas MacPython, que servem de "
"interface para APIs do MacOS, como janelas, QuickTime, *scripting*, etc., "
"foram portados para o OS X, mas foram deixados comentados em :file:`setup."
"py`. Pessoas que pretendam experimentar estes módulos podem descomentá-los "
"manualmente."

#: ../../whatsnew/2.2.rst:1177
msgid ""
"Keyword arguments passed to built-in functions that don't take them now "
"cause a :exc:`TypeError` exception to be raised, with the message "
"\"*function* takes no keyword arguments\"."
msgstr ""
"Argumentos nomeados passados a funções integradas que não os aceitam agora "
"geram uma exceção :exc:`TypeError`, com a mensagem \"*function* não aceita "
"argumentos nomeados\"."

#: ../../whatsnew/2.2.rst:1181
msgid ""
"Weak references, added in Python 2.1 as an extension module, are now part of "
"the core because they're used in the implementation of new-style classes.  "
"The :exc:`ReferenceError` exception has therefore moved from the :mod:"
"`weakref` module to become a built-in exception."
msgstr ""
"Referências fracas, adicionadas no Python 2.1 como um módulo de extensão, "
"agora fazem parte do núcleo porque são usadas na implementação de classes do "
"novo estilo. A exceção :exc:`ReferenceError` foi, portanto, movida do "
"módulo :mod:`weakref` para se tornar uma exceção integrada."

#: ../../whatsnew/2.2.rst:1186
msgid ""
"A new script, :file:`Tools/scripts/cleanfuture.py` by Tim Peters, "
"automatically removes obsolete ``__future__`` statements from Python source "
"code."
msgstr ""
"Um novo script, :file:`Tools/scripts/cleanfuture.py` de Tim Peters, remove "
"automaticamente instruções ``__future__`` obsoletas do código-fonte Python."

#: ../../whatsnew/2.2.rst:1190
msgid ""
"An additional *flags* argument has been added to the built-in function :func:"
"`compile`, so the behaviour of ``__future__`` statements can now be "
"correctly observed in simulated shells, such as those presented by IDLE and "
"other development environments.  This is described in :pep:`264`. "
"(Contributed by Michael Hudson.)"
msgstr ""
"Um argumento adicional *flags* foi adicionado à função integrada :func:"
"`compile`, pelo que o comportamento das instruções ``__future__`` pode agora "
"ser observado corretamente em *shells* simulados, como os apresentados pelo "
"IDLE e outros ambientes de desenvolvimento. Isto está descrito no :pep:"
"`264`. (Contribuído por Michael Hudson.)"

#: ../../whatsnew/2.2.rst:1196
msgid ""
"The new license introduced with Python 1.6 wasn't GPL-compatible.  This is "
"fixed by some minor textual changes to the 2.2 license, so it's now legal to "
"embed Python inside a GPLed program again.  Note that Python itself is not "
"GPLed, but instead is under a license that's essentially equivalent to the "
"BSD license, same as it always was.  The license changes were also applied "
"to the Python 2.0.1 and 2.1.1 releases."
msgstr ""
"A nova licença introduzida com o Python 1.6 não era compatível com a GPL. "
"Isto foi corrigido com algumas alterações textuais menores na licença do "
"2.2, pelo que é agora legal incorporar o Python dentro de um programa GPL "
"novamente. Note que o Python em si não está sob a GPL, mas sim sob uma "
"licença que é essencialmente equivalente à licença BSD, como sempre foi. As "
"alterações à licença também foram aplicadas às versões Python 2.0.1 e 2.1.1."

#: ../../whatsnew/2.2.rst:1203
msgid ""
"When presented with a Unicode filename on Windows, Python will now convert "
"it to an MBCS encoded string, as used by the Microsoft file APIs.  As MBCS "
"is explicitly used by the file APIs, Python's choice of ASCII as the default "
"encoding turns out to be an annoyance.  On Unix, the locale's character set "
"is used if ``locale.nl_langinfo(CODESET)`` is available.  (Windows support "
"was contributed by Mark Hammond with assistance from Marc-André Lemburg. "
"Unix support was added by Martin von Löwis.)"
msgstr ""
"Quando apresentado com um nome de ficheiro Unicode no Windows, o Python "
"agora o converterá para uma string codificada em MBCS, como usado pelas APIs "
"de ficheiros da Microsoft. Como o MBCS é explicitamente usado pelas APIs de "
"ficheiros, a escolha do Python de ASCII como codificação predefinida revela-"
"se um incómodo. No Unix, o conjunto de caracteres do locale é usado se "
"``locale.nl_langinfo(CODESET)`` estiver disponível. (O suporte para Windows "
"foi contribuído por Mark Hammond com assistência de Marc-André Lemburg. O "
"suporte para Unix foi adicionado por Martin von Löwis.)"

#: ../../whatsnew/2.2.rst:1211
msgid ""
"Large file support is now enabled on Windows.  (Contributed by Tim Peters.)"
msgstr ""
"O suporte a ficheiros grandes está agora ativado no Windows. (Contribuído "
"por Tim Peters.)"

#: ../../whatsnew/2.2.rst:1213
msgid ""
"The :file:`Tools/scripts/ftpmirror.py` script now parses a :file:`.netrc` "
"file, if you have one. (Contributed by Mike Romberg.)"
msgstr ""
"O script :file:`Tools/scripts/ftpmirror.py` agora analisa um ficheiro :file:"
"`.netrc`, se tiver um. (Contribuído por Mike Romberg.)"

#: ../../whatsnew/2.2.rst:1216
msgid ""
"Some features of the object returned by the :func:`!xrange` function are now "
"deprecated, and trigger warnings when they're accessed; they'll disappear in "
"Python 2.3. :class:`!xrange` objects tried to pretend they were full "
"sequence types by supporting slicing, sequence multiplication, and the :"
"keyword:`in` operator, but these features were rarely used and therefore "
"buggy.  The :meth:`!tolist` method and the :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` attributes are also being deprecated.  At the C level, the "
"fourth argument to the :c:func:`!PyRange_New` function, ``repeat``, has also "
"been deprecated."
msgstr ""
"Algumas funcionalidades do objeto devolvido pela função :func:`!xrange` "
"estão agora obsoletas e geram avisos quando acedidas; desaparecerão no "
"Python 2.3. Os objetos :class:`!xrange` tentavam fazer-se passar por tipos "
"de sequência completos, suportando *slicing*, multiplicação de sequências e "
"o operador :keyword:`in`, mas estas funcionalidades eram raramente usadas e, "
"por isso, problemáticas. O método :meth:`!tolist` e os atributos :attr:`!"
"start`, :attr:`!stop` e :attr:`!step` também estão a ser descontinuados. Ao "
"nível de C, o quarto argumento da função :c:func:`!PyRange_New`, ``repeat``, "
"também foi descontinuado."

#: ../../whatsnew/2.2.rst:1225
msgid ""
"There were a bunch of patches to the dictionary implementation, mostly to "
"fix potential core dumps if a dictionary contains objects that sneakily "
"changed their hash value, or mutated the dictionary they were contained in. "
"For a while python-dev fell into a gentle rhythm of Michael Hudson finding a "
"case that dumped core, Tim Peters fixing the bug, Michael finding another "
"case, and round and round it went."
msgstr ""
"Foram aplicados vários *patches* à implementação de dicionários, "
"principalmente para corrigir possíveis *core dumps* se um dicionário "
"contiver objetos que alterem sub-repticiamente o seu valor de *hash*, ou que "
"modifiquem o dicionário no qual estão contidos. Durante algum tempo, a lista "
"python-dev entrou num ritmo suave: Michael Hudson encontrava um caso que "
"provocava *core dump*, Tim Peters corrigia o *bug*, Michael encontrava outro "
"caso, e assim sucessivamente."

#: ../../whatsnew/2.2.rst:1232
msgid ""
"On Windows, Python can now be compiled with Borland C thanks to a number of "
"patches contributed by Stephen Hansen, though the result isn't fully "
"functional yet.  (But this *is* progress...)"
msgstr ""
"No Windows, o Python pode agora ser compilado com Borland C graças a vários "
"*patches* contribuídos por Stephen Hansen, embora o resultado ainda não "
"esteja totalmente funcional. (Mas isto *é* progresso...)"

#: ../../whatsnew/2.2.rst:1236
msgid ""
"Another Windows enhancement: Wise Solutions generously offered PythonLabs "
"use of their InstallerMaster 8.1 system.  Earlier PythonLabs Windows "
"installers used Wise 5.0a, which was beginning to show its age.  (Packaged "
"up by Tim Peters.)"
msgstr ""
"Outra melhoria para Windows: a Wise Solutions ofereceu generosamente à "
"PythonLabs o uso do seu sistema InstallerMaster 8.1. Os instaladores Windows "
"anteriores da PythonLabs usavam o Wise 5.0a, que já começava a mostrar a sua "
"idade. (Empacotado por Tim Peters.)"

#: ../../whatsnew/2.2.rst:1240
msgid ""
"Files ending in ``.pyw`` can now be imported on Windows. ``.pyw`` is a "
"Windows-only thing, used to indicate that a script needs to be run using "
"PYTHONW.EXE instead of PYTHON.EXE in order to prevent a DOS console from "
"popping up to display the output.  This patch makes it possible to import "
"such scripts, in case they're also usable as modules.  (Implemented by David "
"Bolen.)"
msgstr ""
"Ficheiros que terminam em ``.pyw`` podem agora ser importados no Windows. ``."
"pyw`` é uma coisa exclusiva do Windows, usada para indicar que um *script* "
"precisa de ser executado usando PYTHONW.EXE em vez de PYTHON.EXE para evitar "
"que uma consola DOS apareça para mostrar a saída. Este *patch* torna "
"possível importar tais *scripts*, caso também sejam úteis como módulos. "
"(Implementado por David Bolen.)"

#: ../../whatsnew/2.2.rst:1246
msgid ""
"On platforms where Python uses the C :c:func:`dlopen` function  to load "
"extension modules, it's now possible to set the flags used  by :c:func:"
"`dlopen` using the :func:`sys.getdlopenflags` and :func:`sys.setdlopenflags` "
"functions. (Contributed by Bram Stolk.)"
msgstr ""
"Em plataformas onde o Python usa a função C :c:func:`dlopen` para carregar "
"módulos de extensão, agora é possível definir os *flags* usados por :c:func:"
"`dlopen` usando as funções :func:`sys.getdlopenflags` e :func:`sys."
"setdlopenflags`. (Contribuído por Bram Stolk.)"

#: ../../whatsnew/2.2.rst:1251
msgid ""
"The :func:`pow` built-in function no longer supports 3 arguments when "
"floating-point numbers are supplied. ``pow(x, y, z)`` returns ``(x**y) % "
"z``, but this is never useful for floating-point numbers, and the final "
"result varies unpredictably depending on the platform.  A call such as "
"``pow(2.0, 8.0, 7.0)`` will now raise a :exc:`TypeError` exception."
msgstr ""
"A função integrada :func:`pow` já não suporta 3 argumentos quando são "
"fornecidos números de vírgula flutuante. ``pow(x, y, z)`` devolve ``(x**y) % "
"z``, mas isto nunca é útil para números de vírgula flutuante, e o resultado "
"final varia imprevisivelmente dependendo da plataforma. Uma chamada como "
"``pow(2.0, 8.0, 7.0)`` agora gera uma exceção :exc:`TypeError`."

#: ../../whatsnew/2.2.rst:1261
msgid "Acknowledgements"
msgstr "Agradecimentos"

#: ../../whatsnew/2.2.rst:1263
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel "
"Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack "
"Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, "
"Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas "
"Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van "
"Rossum, Greg Ward, Edward Welbourne."
msgstr ""
"O autor gostaria de agradecer às seguintes pessoas por oferecerem sugestões, "
"correções e assistência em vários rascunhos deste artigo: Fred Bremmer, "
"Keith Briggs, Andrew Dalke, Fred L. Drake, Jr., Carel Fellinger, David "
"Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack Jansen, Marc-"
"André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, Nick "
"Mathewson, Paul Moore, Gustavo Niemeyer, Don O'Donnell, Joonas Paalasma, Tim "
"Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van Rossum, Greg "
"Ward, Edward Welbourne."
