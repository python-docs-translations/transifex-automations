# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-31 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/executionmodel.rst:6
msgid "Execution model"
msgstr "Modelo de execução"

#: ../../reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "Estrutura de um programa"

#: ../../reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Um programa Python é construído a partir de blocos de código. Um :dfn:"
"`bloco` é uma parte do texto de um programa Python que é executado como uma "
"unidade. Os seguintes são blocos: um módulo, um corpo de função e uma "
"definição de classe. Cada comando digitado interativamente é um bloco. Um "
"ficheiro de *script* (um ficheiro fornecido como entrada padrão ao "
"interpretador ou especificado como argumento de linha de comandos ao "
"interpretador) é um bloco de código. Um comando de *script* (um comando "
"especificado na linha de comandos do interpretador com a opção :option:`-c`) "
"é um bloco de código. Um módulo executado como *script* de nível superior "
"(como módulo ``__main__``) a partir da linha de comandos usando um "
"argumento :option:`-m` também é um bloco de código. O argumento de string "
"passado às funções integradas :func:`eval` e :func:`exec` é um bloco de "
"código."

#: ../../reference/executionmodel.rst:33
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Um bloco de código é executado num :dfn:`*frame* de execução`. Um *frame* "
"contém alguma informação administrativa (usada para depuração) e determina "
"onde e como a execução continua após a conclusão da execução do bloco de "
"código."

#: ../../reference/executionmodel.rst:40
msgid "Naming and binding"
msgstr "Nomeação e ligação"

#: ../../reference/executionmodel.rst:49
msgid "Binding of names"
msgstr "Ligação de nomes"

#: ../../reference/executionmodel.rst:55
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:`Nomes` referem-se a objetos. Os nomes são introduzidos por operações "
"de ligação de nomes."

#: ../../reference/executionmodel.rst:59
msgid "The following constructs bind names:"
msgstr "As seguintes construções ligam nomes:"

#: ../../reference/executionmodel.rst:61
msgid "formal parameters to functions,"
msgstr "parâmetros formais de funções,"

#: ../../reference/executionmodel.rst:62
msgid "class definitions,"
msgstr "definições de classe,"

#: ../../reference/executionmodel.rst:63
msgid "function definitions,"
msgstr "definições de função,"

#: ../../reference/executionmodel.rst:64
msgid "assignment expressions,"
msgstr "expressões de atribuição,"

#: ../../reference/executionmodel.rst:65
msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ""
":ref:`alvos <assignment>` que são identificadores se ocorrerem numa "
"atribuição:"

#: ../../reference/executionmodel.rst:68
msgid ":keyword:`for` loop header,"
msgstr "cabeçalho do ciclo :keyword:`for`,"

#: ../../reference/executionmodel.rst:69
msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""
"depois de :keyword:`!as` numa instrução :keyword:`with`, cláusula :keyword:"
"`except`, cláusula :keyword:`except* <except_star>`, ou no padrão *as-"
"pattern* em correspondência de padrões estrutural,"

#: ../../reference/executionmodel.rst:71
msgid "in a capture pattern in structural pattern matching"
msgstr "num padrão de captura em correspondência de padrões estrutural"

#: ../../reference/executionmodel.rst:73
msgid ":keyword:`import` statements."
msgstr "instruções :keyword:`import`."

#: ../../reference/executionmodel.rst:74
msgid ":keyword:`type` statements."
msgstr "instruções :keyword:`type`."

#: ../../reference/executionmodel.rst:75
msgid ":ref:`type parameter lists <type-params>`."
msgstr ":ref:`listas de parâmetros de tipo <type-params>`...."

#: ../../reference/executionmodel.rst:77
msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"A instrução :keyword:`!import` da forma ``from ... import *`` liga todos os "
"nomes definidos no módulo importado, exceto aqueles que começam com um "
"sublinhado. Esta forma só pode ser usada ao nível do módulo."

#: ../../reference/executionmodel.rst:81
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Um alvo que ocorre numa instrução :keyword:`del` também é considerado ligado "
"para este propósito (embora a semântica real seja desligar o nome)."

#: ../../reference/executionmodel.rst:84
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Cada instrução de atribuição ou importação ocorre dentro de um bloco "
"definido por uma definição de classe ou função ou ao nível do módulo (o "
"bloco de código de nível superior)."

#: ../../reference/executionmodel.rst:89
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :term:`free variable`."
msgstr ""
"Se um nome for ligado num bloco, é uma variável local desse bloco, a menos "
"que seja declarado como :keyword:`nonlocal` ou :keyword:`global`. Se um nome "
"for ligado ao nível do módulo, é uma variável global. (As variáveis do bloco "
"de código do módulo são locais e globais.) Se uma variável for usada num "
"bloco de código, mas não for definida lá, é uma :term:`variável livre`."

#: ../../reference/executionmodel.rst:95
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Cada ocorrência de um nome no texto do programa refere-se à :dfn:`ligação` "
"desse nome estabelecida pelas seguintes regras de resolução de nomes."

#: ../../reference/executionmodel.rst:101
msgid "Resolution of names"
msgstr "Resolução de nomes"

#: ../../reference/executionmodel.rst:105
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
"Um :dfn:`âmbito` define a visibilidade de um nome dentro de um bloco. Se uma "
"variável local for definida num bloco, o seu âmbito inclui esse bloco. Se a "
"definição ocorrer num bloco de função, o âmbito estende-se a quaisquer "
"blocos contidos no bloco de definição, a menos que um bloco contido "
"introduza uma ligação diferente para o nome."

#: ../../reference/executionmodel.rst:113
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"Quando um nome é usado num bloco de código, é resolvido usando o âmbito "
"envolvente mais próximo. O conjunto de todos esses âmbitos visíveis para um "
"bloco de código é chamado de :dfn:`ambiente` do bloco."

#: ../../reference/executionmodel.rst:121
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Quando um nome não é encontrado, é levantada uma exceção :exc:`NameError`. "
"Se o âmbito atual for um âmbito de função e o nome se referir a uma variável "
"local que ainda não foi ligada a um valor no ponto onde o nome é usado, é "
"levantada uma exceção :exc:`UnboundLocalError`. :exc:`UnboundLocalError` é "
"uma subclasse de :exc:`NameError`."

#: ../../reference/executionmodel.rst:127
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations. See :ref:`the FAQ entry on "
"UnboundLocalError <faq-unboundlocalerror>` for examples."
msgstr ""
"Se uma operação de ligação de nome ocorrer em qualquer lugar dentro de um "
"bloco de código, todas as utilizações do nome dentro do bloco são tratadas "
"como referências ao bloco atual. Isto pode levar a erros quando um nome é "
"usado dentro de um bloco antes de ser ligado. Esta regra é subtil. Python "
"não tem declarações e permite que operações de ligação de nomes ocorram em "
"qualquer lugar dentro de um bloco de código. As variáveis locais de um bloco "
"de código podem ser determinadas analisando todo o texto do bloco em busca "
"de operações de ligação de nomes. Consulte a :ref:`entrada da FAQ sobre "
"UnboundLocalError <faq-unboundlocalerror>` para exemplos."

#: ../../reference/executionmodel.rst:136
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched next. If the names are also "
"not found in the builtins namespace, new variables are created in the global "
"namespace. The global statement must precede all uses of the listed names."
msgstr ""
"Se a instrução :keyword:`global` ocorrer dentro de um bloco, todas as "
"utilizações dos nomes especificados na instrução referem-se às ligações "
"desses nomes no espaço de nomes de nível superior. Os nomes são resolvidos "
"no espaço de nomes de nível superior pesquisando o espaço de nomes global, "
"ou seja, o espaço de nomes do módulo que contém o bloco de código, e o "
"espaço de nomes *builtins*, o espaço de nomes do módulo :mod:`builtins`. O "
"espaço de nomes global é pesquisado primeiro. Se os nomes não forem "
"encontrados lá, o espaço de nomes *builtins* é pesquisado a seguir. Se os "
"nomes também não forem encontrados no espaço de nomes *builtins*, novas "
"variáveis são criadas no espaço de nomes global. A instrução global deve "
"preceder todas as utilizações dos nomes listados."

#: ../../reference/executionmodel.rst:146
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"A instrução :keyword:`global` tem o mesmo âmbito que uma operação de ligação "
"de nome no mesmo bloco. Se o âmbito envolvente mais próximo para uma "
"variável livre contiver uma instrução global, a variável livre é tratada "
"como global."

#: ../../reference/executionmodel.rst:152
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope. :ref:`Type parameters <type-params>` cannot be "
"rebound with the :keyword:`!nonlocal` statement."
msgstr ""
"A instrução :keyword:`nonlocal` faz com que os nomes correspondentes se "
"refiram a variáveis anteriormente ligadas no âmbito da função envolvente "
"mais próxima. Uma :exc:`SyntaxError` é levantada em tempo de compilação se o "
"nome dado não existir em nenhum âmbito de função envolvente. :ref:"
"`Parâmetros de tipo <type-params>` não podem ser religados com a instrução :"
"keyword:`!nonlocal`."

#: ../../reference/executionmodel.rst:160
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"O espaço de nomes para um módulo é criado automaticamente na primeira vez "
"que um módulo é importado. O módulo principal para um *script* é sempre "
"chamado :mod:`__main__`."

#: ../../reference/executionmodel.rst:163
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods. This includes comprehensions and generator "
"expressions, but it does not include :ref:`annotation scopes <annotation-"
"scopes>`, which have access to their enclosing class scopes. This means that "
"the following will fail::"
msgstr ""
"Os blocos de definição de classe e os argumentos para :func:`exec` e :func:"
"`eval` são especiais no contexto da resolução de nomes. Uma definição de "
"classe é uma instrução executável que pode usar e definir nomes. Estas "
"referências seguem as regras normais para resolução de nomes, com a exceção "
"de que variáveis locais não ligadas são procuradas no espaço de nomes "
"global. O espaço de nomes da definição de classe torna-se o dicionário de "
"atributos da classe. O âmbito dos nomes definidos num bloco de classe é "
"limitado ao bloco de classe; não se estende aos blocos de código dos "
"métodos. Isto inclui *comprehensions* e expressões geradoras, mas não "
"inclui :ref:`âmbitos de anotação <annotation-scopes>`, que têm acesso aos "
"seus âmbitos de classe envolventes. Isto significa que o seguinte falhará::"

#: ../../reference/executionmodel.rst:176
msgid ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"
msgstr ""
"class A:\n"
"    a = 42\n"
"    b = list(a + i for i in range(10))"

#: ../../reference/executionmodel.rst:180
msgid "However, the following will succeed::"
msgstr "No entanto, o seguinte terá sucesso::"

#: ../../reference/executionmodel.rst:182
msgid ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"
msgstr ""
"class A:\n"
"    type Alias = Nested\n"
"    class Nested: pass\n"
"\n"
"print(A.Alias.__value__)  # <type 'A.Nested'>"

#: ../../reference/executionmodel.rst:191
msgid "Annotation scopes"
msgstr "Âmbitos de anotação"

#: ../../reference/executionmodel.rst:193
msgid ""
":term:`Annotations <annotation>`, :ref:`type parameter lists <type-params>` "
"and :keyword:`type` statements introduce *annotation scopes*, which behave "
"mostly like function scopes, but with some exceptions discussed below."
msgstr ""
":term:`Anotações <annotation>`, :ref:`listas de parâmetros de tipo <type-"
"params>` e instruções :keyword:`type` introduzem *âmbitos de anotação*, que "
"se comportam maioritariamente como âmbitos de função, mas com algumas "
"exceções discutidas abaixo."

#: ../../reference/executionmodel.rst:198
msgid "Annotation scopes are used in the following contexts:"
msgstr "Os âmbitos de anotação são usados nos seguintes contextos:"

#: ../../reference/executionmodel.rst:200
msgid ":term:`Function annotations <function annotation>`."
msgstr ":term:`Anotações de função <function annotation>`."

#: ../../reference/executionmodel.rst:201
msgid ":term:`Variable annotations <variable annotation>`."
msgstr ":term:`Anotações de variável <variable annotation>`."

#: ../../reference/executionmodel.rst:202
msgid ""
"Type parameter lists for :ref:`generic type aliases <generic-type-aliases>`."
msgstr ""
"Listas de parâmetros de tipo para :ref:`aliases de tipo genérico <generic-"
"type-aliases>`."

#: ../../reference/executionmodel.rst:203
msgid ""
"Type parameter lists for :ref:`generic functions <generic-functions>`. A "
"generic function's annotations are executed within the annotation scope, but "
"its defaults and decorators are not."
msgstr ""
"Listas de parâmetros de tipo para :ref:`funções genéricas <generic-"
"functions>`. As anotações de uma função genérica são executadas dentro do "
"âmbito de anotação, mas os seus valores predefinidos e decoradores não são."

#: ../../reference/executionmodel.rst:206
msgid ""
"Type parameter lists for :ref:`generic classes <generic-classes>`. A generic "
"class's base classes and keyword arguments are executed within the "
"annotation scope, but its decorators are not."
msgstr ""
"Listas de parâmetros de tipo para :ref:`classes genéricas <generic-"
"classes>`. As classes base e argumentos de palavra-chave de uma classe "
"genérica são executados dentro do âmbito de anotação, mas os seus "
"decoradores não são."

#: ../../reference/executionmodel.rst:209
msgid ""
"The bounds, constraints, and default values for type parameters (:ref:"
"`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"Os limites, restrições e valores predefinidos para parâmetros de tipo (:ref:"
"`avaliados de forma preguiçosa <lazy-evaluation>`)."

#: ../../reference/executionmodel.rst:211
msgid "The value of type aliases (:ref:`lazily evaluated <lazy-evaluation>`)."
msgstr ""
"O valor de *aliases* de tipo (:ref:`avaliados de forma preguiçosa <lazy-"
"evaluation>`)."

#: ../../reference/executionmodel.rst:213
msgid "Annotation scopes differ from function scopes in the following ways:"
msgstr ""
"Os âmbitos de anotação diferem dos âmbitos de função nas seguintes formas:"

#: ../../reference/executionmodel.rst:215
msgid ""
"Annotation scopes have access to their enclosing class namespace. If an "
"annotation scope is immediately within a class scope, or within another "
"annotation scope that is immediately within a class scope, the code in the "
"annotation scope can use names defined in the class scope as if it were "
"executed directly within the class body. This contrasts with regular "
"functions defined within classes, which cannot access names defined in the "
"class scope."
msgstr ""
"Os âmbitos de anotação têm acesso ao espaço de nomes da classe envolvente. "
"Se um âmbito de anotação estiver imediatamente dentro de um âmbito de "
"classe, ou dentro de outro âmbito de anotação que esteja imediatamente "
"dentro de um âmbito de classe, o código no âmbito de anotação pode usar "
"nomes definidos no âmbito da classe como se fosse executado diretamente "
"dentro do corpo da classe. Isto contrasta com funções regulares definidas "
"dentro de classes, que não podem aceder a nomes definidos no âmbito da "
"classe."

#: ../../reference/executionmodel.rst:221
msgid ""
"Expressions in annotation scopes cannot contain :keyword:`yield`, ``yield "
"from``, :keyword:`await`, or :token:`:= <python-grammar:"
"assignment_expression>` expressions. (These expressions are allowed in other "
"scopes contained within the annotation scope.)"
msgstr ""
"Expressões em âmbitos de anotação não podem conter :keyword:`yield`, ``yield "
"from``, :keyword:`await`, ou expressões :token:`:= <python-grammar:"
"assignment_expression>`. (Estas expressões são permitidas em outros âmbitos "
"contidos dentro do âmbito de anotação.)"

#: ../../reference/executionmodel.rst:225
msgid ""
"Names defined in annotation scopes cannot be rebound with :keyword:"
"`nonlocal` statements in inner scopes. This includes only type parameters, "
"as no other syntactic elements that can appear within annotation scopes can "
"introduce new names."
msgstr ""
"Nomes definidos em âmbitos de anotação não podem ser religados com "
"instruções :keyword:`nonlocal` em âmbitos internos. Isto inclui apenas "
"parâmetros de tipo, uma vez que nenhum outro elemento sintático que possa "
"aparecer dentro de âmbitos de anotação pode introduzir novos nomes."

#: ../../reference/executionmodel.rst:228
msgid ""
"While annotation scopes have an internal name, that name is not reflected in "
"the :term:`qualified name` of objects defined within the scope. Instead, "
"the :attr:`~definition.__qualname__` of such objects is as if the object "
"were defined in the enclosing scope."
msgstr ""
"Embora os âmbitos de anotação tenham um nome interno, esse nome não é "
"refletido no :term:`nome qualificado` dos objetos definidos dentro do "
"âmbito. Em vez disso, o :attr:`~definition.__qualname__` de tais objetos é "
"como se o objeto fosse definido no âmbito envolvente."

#: ../../reference/executionmodel.rst:233
msgid "Annotation scopes were introduced in Python 3.12 as part of :pep:`695`."
msgstr ""
"Os âmbitos de anotação foram introduzidos no Python 3.12 como parte do :pep:"
"`695`."

#: ../../reference/executionmodel.rst:236
msgid ""
"Annotation scopes are also used for type parameter defaults, as introduced "
"by :pep:`696`."
msgstr ""
"Os âmbitos de anotação também são usados para valores predefinidos de "
"parâmetros de tipo, como introduzido pelo :pep:`696`."

#: ../../reference/executionmodel.rst:240
msgid ""
"Annotation scopes are now also used for annotations, as specified in :pep:"
"`649` and :pep:`749`."
msgstr ""
"Os âmbitos de anotação são agora também usados para anotações, como "
"especificado no :pep:`649` e :pep:`749`."

#: ../../reference/executionmodel.rst:247
msgid "Lazy evaluation"
msgstr "Avaliação preguiçosa"

#: ../../reference/executionmodel.rst:249
msgid ""
"Most annotation scopes are *lazily evaluated*. This includes annotations, "
"the values of type aliases created through the :keyword:`type` statement, "
"and the bounds, constraints, and default values of type variables created "
"through the :ref:`type parameter syntax <type-params>`. This means that they "
"are not evaluated when the type alias or type variable is created, or when "
"the object carrying annotations is created. Instead, they are only evaluated "
"when necessary, for example when the ``__value__`` attribute on a type alias "
"is accessed."
msgstr ""
"A maioria dos âmbitos de anotação são *avaliados de forma preguiçosa*. Isto "
"inclui anotações, os valores de *aliases* de tipo criados através da "
"instrução :keyword:`type`, e os limites, restrições e valores predefinidos "
"de variáveis de tipo criadas através da :ref:`sintaxe de parâmetros de tipo "
"<type-params>`. Isto significa que não são avaliados quando o *alias* de "
"tipo ou a variável de tipo é criada, ou quando o objeto que transporta "
"anotações é criado. Em vez disso, são avaliados apenas quando necessário, "
"por exemplo, quando o atributo ``__value__`` num *alias* de tipo é acedido."

#: ../../reference/executionmodel.rst:258
msgid "Example:"
msgstr "Exemplo:"

#: ../../reference/executionmodel.rst:260
msgid ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: division by zero"
msgstr ""
">>> type Alias = 1/0\n"
">>> Alias.__value__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: divisão por zero\n"
">>> def func[T: 1/0](): pass\n"
">>> T = func.__type_params__[0]\n"
">>> T.__bound__\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ZeroDivisionError: divisão por zero"

#: ../../reference/executionmodel.rst:274
msgid ""
"Here the exception is raised only when the ``__value__`` attribute of the "
"type alias or the ``__bound__`` attribute of the type variable is accessed."
msgstr ""
"Aqui, a exceção é levantada apenas quando o atributo ``__value__`` do "
"*alias* de tipo ou o atributo ``__bound__`` da variável de tipo é acedido."

#: ../../reference/executionmodel.rst:278
msgid ""
"This behavior is primarily useful for references to types that have not yet "
"been defined when the type alias or type variable is created. For example, "
"lazy evaluation enables creation of mutually recursive type aliases::"
msgstr ""
"Este comportamento é principalmente útil para referências a tipos que ainda "
"não foram definidos quando o *alias* de tipo ou a variável de tipo é criada. "
"Por exemplo, a avaliação preguiçosa permite a criação de *aliases* de tipo "
"mutuamente recursivos::"

#: ../../reference/executionmodel.rst:282
msgid ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"
msgstr ""
"from typing import Literal\n"
"\n"
"type SimpleExpr = int | Parenthesized\n"
"type Parenthesized = tuple[Literal[\"(\"], Expr, Literal[\")\"]]\n"
"type Expr = SimpleExpr | tuple[SimpleExpr, Literal[\"+\", \"-\"], Expr]"

#: ../../reference/executionmodel.rst:288
msgid ""
"Lazily evaluated values are evaluated in :ref:`annotation scope <annotation-"
"scopes>`, which means that names that appear inside the lazily evaluated "
"value are looked up as if they were used in the immediately enclosing scope."
msgstr ""
"Valores avaliados de forma preguiçosa são avaliados em :ref:`âmbitos de "
"anotação <annotation-scopes>`, o que significa que os nomes que aparecem "
"dentro do valor avaliado de forma preguiçosa são procurados como se fossem "
"usados no âmbito envolvente imediato."

#: ../../reference/executionmodel.rst:297
msgid "Builtins and restricted execution"
msgstr "*Builtins* e execução restrita"

#: ../../reference/executionmodel.rst:303
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"Os utilizadores não devem tocar em ``__builtins__``; é estritamente um "
"detalhe de implementação. Utilizadores que pretendam substituir valores no "
"espaço de nomes *builtins* devem :keyword:`import` o módulo :mod:`builtins` "
"e modificar os seus atributos apropriadamente."

#: ../../reference/executionmodel.rst:308
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"O espaço de nomes *builtins* associado à execução de um bloco de código é "
"encontrado procurando o nome ``__builtins__`` no seu espaço de nomes global; "
"isto deve ser um dicionário ou um módulo (no último caso, o dicionário do "
"módulo é usado). Por predefinição, quando no módulo :mod:`__main__`, "
"``__builtins__`` é o módulo integrado :mod:`builtins`; quando em qualquer "
"outro módulo, ``__builtins__`` é um *alias* para o dicionário do módulo :mod:"
"`builtins`."

#: ../../reference/executionmodel.rst:320
msgid "Interaction with dynamic features"
msgstr "Interação com funcionalidades dinâmicas"

#: ../../reference/executionmodel.rst:322
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"A resolução de nomes de variáveis livres ocorre em tempo de execução, não em "
"tempo de compilação. Isto significa que o seguinte código irá imprimir 42::"

#: ../../reference/executionmodel.rst:325
msgid ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"
msgstr ""
"i = 10\n"
"def f():\n"
"    print(i)\n"
"i = 42\n"
"f()"

#: ../../reference/executionmodel.rst:333
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"As funções :func:`eval` e :func:`exec` não têm acesso ao ambiente completo "
"para resolver nomes. Os nomes podem ser resolvidos nos espaços de nomes "
"locais e globais do chamador. Variáveis livres não são resolvidas no espaço "
"de nomes envolvente mais próximo, mas no espaço de nomes global. [#]_ As "
"funções :func:`exec` e :func:`eval` têm argumentos opcionais para substituir "
"o espaço de nomes global e local. Se apenas um espaço de nomes for "
"especificado, é usado para ambos."

#: ../../reference/executionmodel.rst:347
msgid "Exceptions"
msgstr "Exceções"

#: ../../reference/executionmodel.rst:358
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"As exceções são um meio de interromper o fluxo normal de controlo de um "
"bloco de código para tratar erros ou outras condições excecionais. Uma "
"exceção é *levantada* no ponto onde o erro é detetado; pode ser *tratada* "
"pelo bloco de código envolvente ou por qualquer bloco de código que invoque, "
"direta ou indiretamente, o bloco de código onde o erro ocorreu."

#: ../../reference/executionmodel.rst:364
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"O interpretador Python levanta uma exceção quando deteta um erro em tempo de "
"execução (como divisão por zero). Um programa Python também pode levantar "
"explicitamente uma exceção com a instrução :keyword:`raise`. Os "
"manipuladores de exceção são especificados com a instrução :keyword:"
"`try` ... :keyword:`except`. A cláusula :keyword:`finally` de tal instrução "
"pode ser usada para especificar código de limpeza que não trata a exceção, "
"mas é executado quer uma exceção tenha ocorrido ou não no código precedente."

#: ../../reference/executionmodel.rst:374
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Python usa o modelo de \"terminação\" para tratamento de erros: um "
"manipulador de exceção pode descobrir o que aconteceu e continuar a execução "
"num nível exterior, mas não pode reparar a causa do erro e tentar novamente "
"a operação falhada (exceto reentrando no código problemático desde o início)."

#: ../../reference/executionmodel.rst:381
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"Quando uma exceção não é tratada, o interpretador termina a execução do "
"programa ou retorna para o seu ciclo principal interativo. Em qualquer dos "
"casos, imprime um *traceback* da pilha, exceto quando a exceção é :exc:"
"`SystemExit`."

#: ../../reference/executionmodel.rst:385
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"As exceções são identificadas por instâncias de classe. A cláusula :keyword:"
"`except` é selecionada dependendo da classe da instância: deve referenciar a "
"classe da instância ou uma :term:`classe base não virtual <abstract base "
"class>` da mesma. A instância pode ser recebida pelo manipulador e pode "
"transportar informações adicionais sobre a condição excepcional."

#: ../../reference/executionmodel.rst:393
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"As mensagens de exceção não fazem parte da API do Python. O seu conteúdo "
"pode mudar de uma versão do Python para a seguinte sem aviso prévio e não "
"devem ser usadas por código que será executado em múltiplas versões do "
"interpretador."

#: ../../reference/executionmodel.rst:397
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Veja também a descrição da instrução :keyword:`try` na secção :ref:`try` e "
"da instrução :keyword:`raise` na secção :ref:`raise`."

#: ../../reference/executionmodel.rst:404
msgid "Runtime Components"
msgstr "Componentes de tempo de execução"

#: ../../reference/executionmodel.rst:407
msgid "General Computing Model"
msgstr "Modelo de computação geral"

#: ../../reference/executionmodel.rst:409
msgid ""
"Python's execution model does not operate in a vacuum.  It runs on a host "
"machine and through that host's runtime environment, including its operating "
"system (OS), if there is one.  When a program runs, the conceptual layers of "
"how it runs on the host look something like this:"
msgstr ""
"O modelo de execução do Python não opera no vazio. Ele é executado numa "
"máquina hospedeira e através do ambiente de execução dessa máquina, "
"incluindo o seu sistema operativo (SO), se houver um. Quando um programa é "
"executado, as camadas conceptuais de como ele é executado na máquina "
"hospedeira parecem algo como isto:"

#: ../../reference/executionmodel.rst:0
msgid "**host machine**"
msgstr "**máquina hospedeira**"

#: ../../reference/executionmodel.rst:0
msgid "**process** (global resources)"
msgstr "**processo** (recursos globais)"

#: ../../reference/executionmodel.rst:0
msgid "**thread** (runs machine code)"
msgstr "**thread** (executa código de máquina)"

#: ../../reference/executionmodel.rst:419
msgid ""
"Each process represents a program running on the host.  Think of each "
"process itself as the data part of its program.  Think of the process' "
"threads as the execution part of the program.  This distinction will be "
"important to understand the conceptual Python runtime."
msgstr ""
"Cada processo representa um programa em execução na máquina hospedeira. "
"Pense em cada processo como a parte de dados do seu programa. Pense nas "
"*threads* do processo como a parte de execução do programa. Esta distinção "
"será importante para entender o tempo de execução conceitual do Python."

#: ../../reference/executionmodel.rst:424
msgid ""
"The process, as the data part, is the execution context in which the program "
"runs.  It mostly consists of the set of resources assigned to the program by "
"the host, including memory, signals, file handles, sockets, and environment "
"variables."
msgstr ""
"O processo, como parte de dados, é o contexto de execução no qual o programa "
"é executado. Consiste principalmente no conjunto de recursos atribuídos ao "
"programa pela máquina hospedeira, incluindo memória, sinais, *handles* de "
"ficheiros, *sockets* e variáveis de ambiente."

#: ../../reference/executionmodel.rst:429
msgid ""
"Processes are isolated and independent from one another.  (The same is true "
"for hosts.)  The host manages the process' access to its assigned resources, "
"in addition to coordinating between processes."
msgstr ""
"Os processos são isolados e independentes uns dos outros. (O mesmo é verdade "
"para as máquinas hospedeiras.) A máquina hospedeira gere o acesso do "
"processo aos seus recursos atribuídos, além de coordenar entre processos."

#: ../../reference/executionmodel.rst:433
msgid ""
"Each thread represents the actual execution of the program's machine code, "
"running relative to the resources assigned to the program's process.  It's "
"strictly up to the host how and when that execution takes place."
msgstr ""
"Cada *thread* representa a execução real do código de máquina do programa, "
"executando em relação aos recursos atribuídos ao processo do programa. Cabe "
"estritamente à máquina hospedeira como e quando essa execução ocorre."

#: ../../reference/executionmodel.rst:438
msgid ""
"From the point of view of Python, a program always starts with exactly one "
"thread.  However, the program may grow to run in multiple simultaneous "
"threads.  Not all hosts support multiple threads per process, but most do.  "
"Unlike processes, threads in a process are not isolated and independent from "
"one another.  Specifically, all threads in a process share all of the "
"process' resources."
msgstr ""
"Do ponto de vista do Python, um programa sempre começa com exatamente uma "
"*thread*. No entanto, o programa pode crescer para ser executado em várias "
"*threads* simultâneas. Nem todas as máquinas hospedeiras suportam várias "
"*threads* por processo, mas a maioria suporta. Ao contrário dos processos, "
"as *threads* num processo não são isoladas nem independentes umas das "
"outras. Especificamente, todas as *threads* num processo partilham todos os "
"recursos do processo."

#: ../../reference/executionmodel.rst:445
msgid ""
"The fundamental point of threads is that each one does *run* independently, "
"at the same time as the others.  That may be only conceptually at the same "
"time (\"concurrently\") or physically (\"in parallel\").  Either way, the "
"threads effectively run at a non-synchronized rate."
msgstr ""
"O ponto fundamental das *threads* é que cada uma *executa* "
"independentemente, ao mesmo tempo que as outras. Isso pode ser apenas "
"conceitualmente ao mesmo tempo (\"concorrentemente\") ou fisicamente (\"em "
"paralelo\"). De qualquer forma, as *threads* executam efetivamente a uma "
"taxa não sincronizada."

#: ../../reference/executionmodel.rst:453
msgid ""
"That non-synchronized rate means none of the process' memory is guaranteed "
"to stay consistent for the code running in any given thread.  Thus multi-"
"threaded programs must take care to coordinate access to intentionally "
"shared resources.  Likewise, they must take care to be absolutely diligent "
"about not accessing any *other* resources in multiple threads; otherwise two "
"threads running at the same time might accidentally interfere with each "
"other's use of some shared data.  All this is true for both Python programs "
"and the Python runtime."
msgstr ""
"Essa taxa não sincronizada significa que nenhuma da memória do processo é "
"garantida como consistente para o código em execução em qualquer *thread* "
"dada. Assim, programas com várias *threads* devem tomar cuidado para "
"coordenar o acesso a recursos compartilhados intencionalmente. Da mesma "
"forma, devem tomar cuidado para serem absolutamente diligentes em não "
"acessar quaisquer *outros* recursos em várias *threads*; caso contrário, "
"duas *threads* executando ao mesmo tempo podem interferir acidentalmente no "
"uso uma da outra de alguns dados compartilhados. Tudo isto é verdadeiro "
"tanto para programas Python quanto para o tempo de execução do Python."

#: ../../reference/executionmodel.rst:463
msgid ""
"The cost of this broad, unstructured requirement is the tradeoff for the "
"kind of raw concurrency that threads provide.  The alternative to the "
"required discipline generally means dealing with non-deterministic bugs and "
"data corruption."
msgstr ""
"O custo deste requisito amplo e não estruturado é a compensação pelo tipo de "
"concorrência bruta que as *threads* fornecem. A alternativa à disciplina "
"necessária geralmente significa lidar com erros não determinísticos e "
"corrupção de dados."

#: ../../reference/executionmodel.rst:469
msgid "Python Runtime Model"
msgstr "Modelo de tempo de execução do Python"

#: ../../reference/executionmodel.rst:471
msgid ""
"The same conceptual layers apply to each Python program, with some extra "
"data layers specific to Python:"
msgstr ""
"As mesmas camadas conceptuais aplicam-se a cada programa Python, com algumas "
"camadas de dados adicionais específicas do Python:"

#: ../../reference/executionmodel.rst:0
msgid "Python global runtime (*state*)"
msgstr "Tempo de execução global do Python (*estado*)"

#: ../../reference/executionmodel.rst:0
msgid "Python interpreter (*state*)"
msgstr "Interpretador do Python (*estado*)"

#: ../../reference/executionmodel.rst:0
msgid "**thread** (runs Python bytecode and \"C-API\")"
msgstr "**thread** (executa *bytecode* Python e \"C-API\")"

#: ../../reference/executionmodel.rst:0
msgid "Python thread *state*"
msgstr "Estado da *thread* Python"

#: ../../reference/executionmodel.rst:481
msgid ""
"At the conceptual level: when a Python program starts, it looks exactly like "
"that diagram, with one of each.  The runtime may grow to include multiple "
"interpreters, and each interpreter may grow to include multiple thread "
"states."
msgstr ""
"Ao nível conceitual: quando um programa Python começa, parece exatamente com "
"esse diagrama, com um de cada. O tempo de execução pode crescer para incluir "
"vários interpretadores, e cada interpretador pode crescer para incluir "
"vários estados de *thread*."

#: ../../reference/executionmodel.rst:488
msgid ""
"A Python implementation won't necessarily implement the runtime layers "
"distinctly or even concretely.  The only exception is places where distinct "
"layers are directly specified or exposed to users, like through the :mod:"
"`threading` module."
msgstr ""
"Uma implementação do Python não implementará necessariamente as camadas de "
"tempo de execução de forma distinta ou mesmo concreta. A única exceção são "
"os locais onde camadas distintas são especificadas diretamente ou expostas "
"aos utilizadores, como através do módulo :mod:`threading`."

#: ../../reference/executionmodel.rst:495
msgid ""
"The initial interpreter is typically called the \"main\" interpreter. Some "
"Python implementations, like CPython, assign special roles to the main "
"interpreter."
msgstr ""
"O interpretador inicial é tipicamente chamado de interpretador "
"\"principal\". Algumas implementações do Python, como o CPython, atribuem "
"papéis especiais ao interpretador principal."

#: ../../reference/executionmodel.rst:499
msgid ""
"Likewise, the host thread where the runtime was initialized is known as the "
"\"main\" thread.  It may be different from the process' initial thread, "
"though they are often the same.  In some cases \"main thread\" may be even "
"more specific and refer to the initial thread state. A Python runtime might "
"assign specific responsibilities to the main thread, such as handling "
"signals."
msgstr ""
"Da mesma forma, a *thread* hospedeira onde o tempo de execução foi "
"inicializado é conhecida como a *thread* \"principal\". Pode ser diferente "
"da *thread* inicial do processo, embora muitas vezes sejam a mesma. Em "
"alguns casos, \"*thread* principal\" pode ser ainda mais específica e "
"referir-se ao estado inicial da *thread*. Um tempo de execução do Python "
"pode atribuir responsabilidades específicas à *thread* principal, como o "
"tratamento de sinais."

#: ../../reference/executionmodel.rst:506
msgid ""
"As a whole, the Python runtime consists of the global runtime state, "
"interpreters, and thread states.  The runtime ensures all that state stays "
"consistent over its lifetime, particularly when used with multiple host "
"threads."
msgstr ""
"No seu conjunto, o tempo de execução do Python consiste no estado global do "
"tempo de execução, interpretadores e estados de *thread*. O tempo de "
"execução garante que todo esse estado permanece consistente ao longo do seu "
"tempo de vida, especialmente quando usado com várias *threads* hospedeiras."

#: ../../reference/executionmodel.rst:511
msgid ""
"The global runtime, at the conceptual level, is just a set of interpreters.  "
"While those interpreters are otherwise isolated and independent from one "
"another, they may share some data or other resources.  The runtime is "
"responsible for managing these global resources safely.  The actual nature "
"and management of these resources is implementation-specific.  Ultimately, "
"the external utility of the global runtime is limited to managing "
"interpreters."
msgstr ""
"O tempo de execução global, ao nível conceitual, é apenas um conjunto de "
"interpretadores. Embora esses interpretadores sejam, de outra forma, "
"isolados e independentes uns dos outros, podem partilhar alguns dados ou "
"outros recursos. O tempo de execução é responsável por gerir esses recursos "
"globais de forma segura. A natureza e gestão reais desses recursos são "
"específicas da implementação. Em última análise, a utilidade externa do "
"tempo de execução global é limitada à gestão de interpretadores."

#: ../../reference/executionmodel.rst:519
msgid ""
"In contrast, an \"interpreter\" is conceptually what we would normally think "
"of as the (full-featured) \"Python runtime\".  When machine code executing "
"in a host thread interacts with the Python runtime, it calls into Python in "
"the context of a specific interpreter."
msgstr ""
"Em contraste, um \"interpretador\" é conceitualmente o que normalmente "
"pensaríamos como o tempo de execução \"Python\" (com todas as "
"funcionalidades). Quando o código de máquina em execução numa *thread* "
"hospedeira interage com o tempo de execução do Python, chama o Python no "
"contexto de um interpretador específico."

#: ../../reference/executionmodel.rst:526
msgid ""
"The term \"interpreter\" here is not the same as the \"bytecode "
"interpreter\", which is what regularly runs in threads, executing compiled "
"Python code."
msgstr ""
"O termo \"interpretador\" aqui não é o mesmo que o \"interpretador de "
"*bytecode*\", que é o que normalmente é executado em *threads*, executando "
"código Python compilado."

#: ../../reference/executionmodel.rst:530
msgid ""
"In an ideal world, \"Python runtime\" would refer to what we currently call "
"\"interpreter\".  However, it's been called \"interpreter\" at least since "
"introduced in 1997 (`CPython:a027efa5b`_)."
msgstr ""
"Num mundo ideal, \"tempo de execução do Python\" referir-se-ia ao que "
"atualmente chamamos de \"interpretador\". No entanto, tem sido chamado de "
"\"interpretador\" pelo menos desde que foi introduzido em 1997 (`CPython:"
"a027efa5b`_)."

#: ../../reference/executionmodel.rst:536
msgid ""
"Each interpreter completely encapsulates all of the non-process-global, non-"
"thread-specific state needed for the Python runtime to work. Notably, the "
"interpreter's state persists between uses.  It includes fundamental data "
"like :data:`sys.modules`.  The runtime ensures multiple threads using the "
"same interpreter will safely share it between them."
msgstr ""
"Cada interpretador encapsula completamente todo o estado não global do "
"processo e não específico da *thread* necessário para o funcionamento do "
"tempo de execução do Python. Notavelmente, o estado do interpretador "
"persiste entre usos. Inclui dados fundamentais como :data:`sys.modules`. O "
"tempo de execução garante que várias *threads* que usam o mesmo "
"interpretador o partilharão de forma segura."

#: ../../reference/executionmodel.rst:543
msgid ""
"A Python implementation may support using multiple interpreters at the same "
"time in the same process.  They are independent and isolated from one "
"another.  For example, each interpreter has its own :data:`sys.modules`."
msgstr ""
"Uma implementação do Python pode suportar o uso de vários interpretadores ao "
"mesmo tempo no mesmo processo. Eles são independentes e isolados uns dos "
"outros. Por exemplo, cada interpretador tem o seu próprio :data:`sys."
"modules`."

#: ../../reference/executionmodel.rst:548
msgid ""
"For thread-specific runtime state, each interpreter has a set of thread "
"states, which it manages, in the same way the global runtime contains a set "
"of interpreters.  It can have thread states for as many host threads as it "
"needs.  It may even have multiple thread states for the same host thread, "
"though that isn't as common."
msgstr ""
"Para o estado de tempo de execução específico da *thread*, cada "
"interpretador tem um conjunto de estados de *thread*, que gere, da mesma "
"forma que o tempo de execução global contém um conjunto de interpretadores. "
"Pode ter estados de *thread* para quantas *threads* hospedeiras forem "
"necessárias. Pode até ter vários estados de *thread* para a mesma *thread* "
"hospedeira, embora isso não seja tão comum."

#: ../../reference/executionmodel.rst:554
msgid ""
"Each thread state, conceptually, has all the thread-specific runtime data an "
"interpreter needs to operate in one host thread.  The thread state includes "
"the current raised exception and the thread's Python call stack.  It may "
"include other thread-specific resources."
msgstr ""
"Cada estado de *thread*, conceitualmente, tem todos os dados de tempo de "
"execução específicos da *thread* de que um interpretador necessita para "
"operar numa *thread* hospedeira. O estado da *thread* inclui a exceção "
"atualmente levantada e a pilha de chamadas Python da *thread*. Pode incluir "
"outros recursos específicos da *thread*."

#: ../../reference/executionmodel.rst:561
msgid ""
"The term \"Python thread\" can sometimes refer to a thread state, but "
"normally it means a thread created using the :mod:`threading` module."
msgstr ""
"O termo \"*thread* Python\" pode, por vezes, referir-se a um estado de "
"*thread*, mas normalmente significa uma *thread* criada usando o módulo :mod:"
"`threading`."

#: ../../reference/executionmodel.rst:564
msgid ""
"Each thread state, over its lifetime, is always tied to exactly one "
"interpreter and exactly one host thread.  It will only ever be used in that "
"thread and with that interpreter."
msgstr ""
"Cada estado de *thread*, ao longo da sua vida útil, está sempre ligado a "
"exatamente um interpretador e exatamente uma *thread* hospedeira. Só será "
"usado nessa *thread* e com esse interpretador."

#: ../../reference/executionmodel.rst:568
msgid ""
"Multiple thread states may be tied to the same host thread, whether for "
"different interpreters or even the same interpreter.  However, for any given "
"host thread, only one of the thread states tied to it can be used by the "
"thread at a time."
msgstr ""
"Vários estados de *thread* podem estar ligados à mesma *thread* hospedeira, "
"quer para diferentes interpretadores ou até para o mesmo interpretador. No "
"entanto, para qualquer *thread* hospedeira, apenas um dos estados de "
"*thread* ligados a ela pode ser usado pela *thread* de cada vez."

#: ../../reference/executionmodel.rst:573
msgid ""
"Thread states are isolated and independent from one another and don't share "
"any data, except for possibly sharing an interpreter and objects or other "
"resources belonging to that interpreter."
msgstr ""
"Os estados de *thread* são isolados e independentes uns dos outros e não "
"partilham quaisquer dados, exceto possivelmente partilhando um interpretador "
"e objetos ou outros recursos pertencentes a esse interpretador."

#: ../../reference/executionmodel.rst:577
msgid ""
"Once a program is running, new Python threads can be created using the :mod:"
"`threading` module (on platforms and Python implementations that support "
"threads).  Additional processes can be created using the :mod:`os`, :mod:"
"`subprocess`, and :mod:`multiprocessing` modules. Interpreters can be "
"created and used with the :mod:`~concurrent.interpreters` module.  "
"Coroutines (async) can be run using :mod:`asyncio` in each interpreter, "
"typically only in a single thread (often the main thread)."
msgstr ""
"Uma vez que um programa está em execução, novas *threads* Python podem ser "
"criadas usando o módulo :mod:`threading` (em plataformas e implementações do "
"Python que suportam *threads*). Processos adicionais podem ser criados "
"usando os módulos :mod:`os`, :mod:`subprocess` e :mod:`multiprocessing`. "
"Interpretadores podem ser criados e usados com o módulo :mod:`~concurrent."
"interpreters`. Corrotinas (assíncronas) podem ser executadas usando :mod:"
"`asyncio` em cada interpretador, tipicamente apenas numa única *thread* "
"(muitas vezes a *thread* principal)."

#: ../../reference/executionmodel.rst:588
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../reference/executionmodel.rst:589
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"Esta limitação ocorre porque o código que é executado por estas operações "
"não está disponível no momento em que o módulo é compilado."

#: ../../reference/executionmodel.rst:8
msgid "execution model"
msgstr "modelo de execução"

#: ../../reference/executionmodel.rst:8
msgid "code"
msgstr "código"

#: ../../reference/executionmodel.rst:8 ../../reference/executionmodel.rst:17
msgid "block"
msgstr "bloco"

#: ../../reference/executionmodel.rst:31 ../../reference/executionmodel.rst:299
msgid "execution"
msgstr "execução"

#: ../../reference/executionmodel.rst:31
msgid "frame"
msgstr "*frame*"

#: ../../reference/executionmodel.rst:42
msgid "namespace"
msgstr "espaço de nomes"

#: ../../reference/executionmodel.rst:42 ../../reference/executionmodel.rst:103
msgid "scope"
msgstr "âmbitos"

#: ../../reference/executionmodel.rst:51
msgid "name"
msgstr "nome"

#: ../../reference/executionmodel.rst:51
msgid "binding"
msgstr "ligação"

#: ../../reference/executionmodel.rst:57
msgid "from"
msgstr "de"

#: ../../reference/executionmodel.rst:57
msgid "import statement"
msgstr "instrução de importação"

#: ../../reference/executionmodel.rst:87
msgid "free"
msgstr "livre"

#: ../../reference/executionmodel.rst:87
msgid "variable"
msgstr "variável"

#: ../../reference/executionmodel.rst:111
msgid "environment"
msgstr "ambiente"

#: ../../reference/executionmodel.rst:117
msgid "NameError (built-in exception)"
msgstr "NameError (exceção integrada)"

#: ../../reference/executionmodel.rst:117
msgid "UnboundLocalError"
msgstr "UnboundLocalError"

#: ../../reference/executionmodel.rst:158
msgid "module"
msgstr "módulo"

#: ../../reference/executionmodel.rst:158
msgid "__main__"
msgstr "__main__"

#: ../../reference/executionmodel.rst:299
msgid "restricted"
msgstr "restrita"

#: ../../reference/executionmodel.rst:349
msgid "exception"
msgstr "exceção"

#: ../../reference/executionmodel.rst:351
msgid "raise an exception"
msgstr "levantar uma exceção"

#: ../../reference/executionmodel.rst:351
msgid "handle an exception"
msgstr "tratar uma exceção"

#: ../../reference/executionmodel.rst:351
msgid "exception handler"
msgstr "manipulador de exceção"

#: ../../reference/executionmodel.rst:351
msgid "errors"
msgstr "erros"

#: ../../reference/executionmodel.rst:351
msgid "error handling"
msgstr "tratamento de erros"

#: ../../reference/executionmodel.rst:372
msgid "termination model"
msgstr "modelo de terminação"

#: ../../reference/executionmodel.rst:379
msgid "SystemExit (built-in exception)"
msgstr "SystemExit (exceção integrada)"
