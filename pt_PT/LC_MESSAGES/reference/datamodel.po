# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-25 14:58+0000\n"
"PO-Revision-Date: 2025-09-15 01:05+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/datamodel.rst:6
msgid "Data model"
msgstr "Modelo de dados"

#: ../../reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "Objetos, valores e tipos"

#: ../../reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. Even code "
"is represented by objects."
msgstr ""

#: ../../reference/datamodel.rst:31
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The :keyword:`is` operator compares the identity of two "
"objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""
"Cada objeto tem uma identidade, um tipo e um valor. A *identidade* de um "
"objeto nunca muda depois de criada; pode pensar nela como o endereço do "
"objeto na memória. O operador :keyword:`is` compara a identidade de dois "
"objetos; a função :func:`id` retorna um número inteiro que representa a sua "
"identidade."

#: ../../reference/datamodel.rst:38
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr ""
"Para CPython, ``id(x)`` é o endereço de memória onde ``x`` está armazenado."

#: ../../reference/datamodel.rst:40
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""
"O tipo de um objeto determina as operações que o objeto suporta (por "
"exemplo, «tem comprimento?») e também define os valores possíveis para "
"objetos desse tipo. A função :func:`type` retorna o tipo de um objeto (que é "
"um objeto em si). Tal como a sua identidade, o :dfn:`tipo` de um objeto "
"também é imutável. [#]_"

#: ../../reference/datamodel.rst:46
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""
"O *valor* de alguns objetos pode mudar. Objetos cujo valor pode mudar são "
"chamados de *mutáveis*; objetos cujo valor é imutável depois de criados são "
"chamados de *imutáveis*. (O valor de um objeto contêiner imutável que contém "
"uma referência a um objeto mutável pode mudar quando o valor deste último é "
"alterado; no entanto, o contêiner ainda é considerado imutável, porque a "
"coleção de objetos que ele contém não pode ser alterada. Portanto, "
"imutabilidade não é exatamente o mesmo que ter um valor imutável, é algo "
"mais sutil.) A mutabilidade de um objeto é determinada pelo seu tipo; por "
"exemplo, números, strings e tuplas são imutáveis, enquanto dicionários e "
"listas são mutáveis."

#: ../../reference/datamodel.rst:61
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""
"Os objetos nunca são explicitamente destruídos; no entanto, quando se tornam "
"inacessíveis, podem ser recolhidos pelo garbage collector. Uma implementação "
"pode adiar a recolha de lixo ou omitir completamente — a qualidade da "
"implementação depende de como a recolha de lixo é implementada, desde que "
"nenhum objeto ainda acessível seja recolhido."

#: ../../reference/datamodel.rst:69
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""
"Atualmente, o CPython usa um esquema de contagem de referências com detecção "
"(opcional) retardada de lixo ligado ciclicamente, que recolhe a maioria dos "
"objetos assim que eles se tornam inacessíveis, mas não garante a recolha de "
"lixo contendo referências circulares. Consulte a documentação do módulo :mod:"
"`gc` para obter informações sobre como controlar a recolha de lixo cíclico. "
"Outras implementações agem de maneira diferente e o CPython pode mudar. Não "
"dependa da finalização imediata de objetos quando eles se tornam "
"inacessíveis (portanto, você deve sempre fechar os ficheiros explicitamente)."

#: ../../reference/datamodel.rst:78
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a :keyword:`try`...\\ :keyword:`except` statement "
"may keep objects alive."
msgstr ""
"Observe que o uso dos recursos de rastreamento ou depuração da implementação "
"pode manter objetos ativos que normalmente seriam coletáveis. Observe também "
"que capturar uma exceção com uma instrução :keyword:`try`...\\ :keyword:"
"`except` pode manter objetos ativos."

#: ../../reference/datamodel.rst:83
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`!close` method. Programs are strongly recommended "
"to explicitly close such objects.  The :keyword:`try`...\\ :keyword:"
"`finally` statement and the :keyword:`with` statement provide convenient "
"ways to do this."
msgstr ""
"Alguns objetos contêm referências a recursos \"externos\", como ficheiros "
"abertos ou janelas. Entende-se que esses recursos são liberados quando o "
"objeto é coletado pelo garbage collector, mas como a coleta de lixo não é "
"garantida, esses objetos também fornecem uma maneira explícita de liberar o "
"recurso externo, geralmente um método :meth:`!close`. É altamente "
"recomendável que os programas fechem explicitamente esses objetos. As "
"instruções :keyword:`try`...\\ :keyword:`finally` e :keyword:`with` fornecem "
"maneiras convenientes de fazer isso."

#: ../../reference/datamodel.rst:93
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""
"Alguns objetos contêm referências a outros objetos; estes são chamados de "
"*contentores*. Exemplos de contentores são tuplas, listas e dicionários. As "
"referências fazem parte do valor de um contentor. Na maioria dos casos, "
"quando falamos sobre o valor de um contentor, estamos a referir-nos aos "
"valores, e não às identidades dos objetos contidos; no entanto, quando "
"falamos sobre a mutabilidade de um contentor, apenas as identidades dos "
"objetos imediatamente contidos são referidas. Portanto, se um contentor "
"imutável (como uma tupla) contém uma referência a um objeto mutável, o seu "
"valor muda se esse objeto mutável for alterado."

#: ../../reference/datamodel.rst:102
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed. For example, after ``a = 1; b = 1``, *a* and *b* may or may not "
"refer to the same object with the value one, depending on the "
"implementation. This is because :class:`int` is an immutable type, so the "
"reference to ``1`` can be reused. This behaviour depends on the "
"implementation used, so should not be relied upon, but is something to be "
"aware of when making use of object identity tests. However, after ``c = []; "
"d = []``, *c* and *d* are guaranteed to refer to two different, unique, "
"newly created empty lists. (Note that ``e = f = []`` assigns the *same* "
"object to both *e* and *f*.)"
msgstr ""
"Os tipos afetam quase todos os aspetos do comportamento dos objetos. Até "
"mesmo a importância da identidade dos objetos é afetada, em certo sentido: "
"para tipos imutáveis, operações que calculam novos valores podem, na "
"verdade, retornar uma referência a qualquer objeto existente com o mesmo "
"tipo e valor, enquanto que para objetos mutáveis isso não é permitido. Por "
"exemplo, após ``a = 1; b = 1``, *a* e *b* podem ou não se referir ao mesmo "
"objeto com o valor um, dependendo da implementação. Isso ocorre porque :"
"class:`int` é um tipo imutável, portanto a referência a ``1`` pode ser "
"reutilizada. Este comportamento depende da implementação utilizada, portanto "
"não se deve confiar nele, mas é algo a se ter em mente ao fazer uso de "
"testes de identidade de objetos. No entanto, após ``c = []; d = []``, *c* e "
"*d* garantidamente referem-se a duas listas vazias diferentes, únicas e "
"recém-criadas. (Observe que ``e = f = []`` atribui o *mesmo* objeto a *e* e "
"*f*.)"

#: ../../reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "A hierarquia de tipos padrão"

#: ../../reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""
"Abaixo está uma lista dos tipos incorporados ao Python. Módulos de extensão "
"(escritos em C, Java ou outras linguagens, dependendo da implementação) "
"podem definir tipos adicionais. Versões futuras do Python podem adicionar "
"tipos à hierarquia de tipos (por exemplo, números racionais, matrizes de "
"inteiros armazenadas de forma eficiente, etc.), embora tais adições sejam "
"frequentemente fornecidas através da biblioteca padrão."

#: ../../reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""
"Algumas das descrições de tipos abaixo contêm um parágrafo que lista "
"«atributos especiais». Estes são atributos que fornecem acesso à "
"implementação e não se destinam a uso geral. A sua definição pode mudar no "
"futuro."

#: ../../reference/datamodel.rst:146 ../../reference/datamodel.rst:148
msgid "None"
msgstr "Nenhum"

#: ../../reference/datamodel.rst:150
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""
"Este tipo tem um único valor. Existe um único objeto com este valor. Este "
"objeto é acessado através do nome incorporado ``None``. É usado para "
"significar a ausência de um valor em muitas situações, por exemplo, é "
"retornado de funções que não retornam explicitamente nada. O seu valor "
"verdadeiro é falso."

#: ../../reference/datamodel.rst:157 ../../reference/datamodel.rst:159
msgid "NotImplemented"
msgstr "Não implementado"

#: ../../reference/datamodel.rst:161
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name :data:`NotImplemented`. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  It should not be evaluated in a boolean context."
msgstr ""
"Este tipo tem um único valor. Existe um único objeto com este valor. Este "
"objeto é acessado através do nome incorporado :data:`NotImplemented`. "
"Métodos numéricos e métodos de comparação avançados devem retornar este "
"valor se não implementarem a operação para os operandos fornecidos. (O "
"interpretador tentará então a operação refletida, ou algum outro recurso "
"alternativo, dependendo do operador.) Não deve ser avaliado num contexto "
"booleano."

#: ../../reference/datamodel.rst:168
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""
"Consulte :ref:`implementing-the-arithmetic-operations` para obter mais "
"detalhes."

#: ../../reference/datamodel.rst:172
msgid ""
"Evaluating :data:`NotImplemented` in a boolean context is deprecated. While "
"it currently evaluates as true, it will emit a :exc:`DeprecationWarning`. It "
"will raise a :exc:`TypeError` in a future version of Python."
msgstr ""

#: ../../reference/datamodel.rst:179 ../../reference/datamodel.rst:180
msgid "Ellipsis"
msgstr "Elipse"

#: ../../reference/datamodel.rst:184
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"Este tipo tem um único valor. Existe um único objeto com este valor. Este "
"objeto é acessado através do literal ``...`` ou do nome incorporado "
"``Ellipsis``. O seu valor verdadeiro é verdadeiro."

#: ../../reference/datamodel.rst:190
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../../reference/datamodel.rst:194
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""
"Estes são criados por literais numéricos e devolvidos como resultados por "
"operadores aritméticos e funções aritméticas incorporadas. Os objetos "
"numéricos são imutáveis; uma vez criados, o seu valor nunca muda. Os números "
"Python estão, naturalmente, fortemente relacionados com os números "
"matemáticos, mas estão sujeitos às limitações da representação numérica nos "
"computadores."

#: ../../reference/datamodel.rst:200
msgid ""
"The string representations of the numeric classes, computed by :meth:"
"`~object.__repr__` and :meth:`~object.__str__`, have the following "
"properties:"
msgstr ""
"As representações de cadeia das classes numéricas, calculadas por :meth:"
"`~object.__repr__` e :meth:`~object.__str__`, têm as seguintes propriedades:"

#: ../../reference/datamodel.rst:204
msgid ""
"They are valid numeric literals which, when passed to their class "
"constructor, produce an object having the value of the original numeric."
msgstr ""
"São literais numéricos válidos que, quando passados para o construtor da sua "
"classe, produzem um objeto com o valor do numérico original."

#: ../../reference/datamodel.rst:208
msgid "The representation is in base 10, when possible."
msgstr "A representação é na base 10, quando possível."

#: ../../reference/datamodel.rst:210
msgid ""
"Leading zeros, possibly excepting a single zero before a decimal point, are "
"not shown."
msgstr ""
"Os zeros à esquerda, com exceção, possivelmente, de um único zero antes do "
"ponto decimal, não são apresentados."

#: ../../reference/datamodel.rst:213
msgid ""
"Trailing zeros, possibly excepting a single zero after a decimal point, are "
"not shown."
msgstr ""
"Os zeros à direita, com possível exceção de um único zero após a vírgula "
"decimal, não são exibidos."

#: ../../reference/datamodel.rst:216
msgid "A sign is shown only when the number is negative."
msgstr "Um sinal é mostrado apenas quando o número é negativo."

#: ../../reference/datamodel.rst:218
msgid ""
"Python distinguishes between integers, floating-point numbers, and complex "
"numbers:"
msgstr ""
"Python distingue entre números inteiros, números de ponto flutuante e "
"números complexos:"

#: ../../reference/datamodel.rst:223
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../../reference/datamodel.rst:227
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""
"Estes representam elementos do conjunto matemático dos números inteiros "
"(positivos e negativos)."

#: ../../reference/datamodel.rst:233
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""
"As regras para representação de números inteiros têm como objetivo fornecer "
"a interpretação mais significativa das operações de deslocamento e máscara "
"envolvendo números inteiros negativos."

#: ../../reference/datamodel.rst:236
msgid "There are two types of integers:"
msgstr "Existem dois tipos de números inteiros:"

#: ../../reference/datamodel.rst:238
msgid "Integers (:class:`int`)"
msgstr "Números inteiros (:class:`int`)"

#: ../../reference/datamodel.rst:239
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""
"Estes representam números num intervalo ilimitado, sujeitos apenas à memória "
"(virtual) disponível. Para efeitos de operações de deslocamento e máscara, "
"assume-se uma representação binária, e os números negativos são "
"representados numa variante do complemento de 2, o que dá a ilusão de uma "
"sequência infinita de bits de sinal que se estende para a esquerda."

#: ../../reference/datamodel.rst:245
msgid "Booleans (:class:`bool`)"
msgstr "Booleanos (:class:`bool`)"

#: ../../reference/datamodel.rst:251
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or "
"``\"True\"`` are returned, respectively."
msgstr ""
"Estes representam os valores verdadeiros Falso e Verdadeiro. Os dois objetos "
"que representam os valores ``False`` e ``True`` são os únicos objetos "
"booleanos. O tipo booleano é um subtipo do tipo inteiro, e os valores "
"booleanos comportam-se como os valores 0 e 1, respetivamente, em quase todos "
"os contextos, com a exceção de que, quando convertidos para uma string, as "
"strings ``\"False\"`` ou ``\"True\"`` são devolvidas, respetivamente."

#: ../../reference/datamodel.rst:259
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../../reference/datamodel.rst:267
msgid ""
"These represent machine-level double precision floating-point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating-point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating-point numbers."
msgstr ""
"Estes representam números de ponto flutuante de precisão dupla ao nível da "
"máquina. Você está à mercê da arquitetura da máquina subjacente (e da "
"implementação em C ou Java) para o intervalo aceito e o tratamento de "
"estouro. O Python não suporta números de ponto flutuante de precisão "
"simples; a economia no uso do processador e da memória, que geralmente é a "
"razão para usá-los, é ofuscada pela sobrecarga do uso de objetos no Python, "
"portanto, não há motivo para complicar a linguagem com dois tipos de números "
"de ponto flutuante."

#: ../../reference/datamodel.rst:277
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../../reference/datamodel.rst:283
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating-point numbers.  The same caveats apply as for floating-point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""
"Estes representam números complexos como um par de números de ponto "
"flutuante de precisão dupla ao nível da máquina. Aplicam-se as mesmas "
"advertências que para os números de ponto flutuante. As partes real e "
"imaginária de um número complexo ``z`` podem ser recuperadas através dos "
"atributos somente leitura ``z.real`` e ``z.imag``."

#: ../../reference/datamodel.rst:290
msgid "Sequences"
msgstr "Sequências"

#: ../../reference/datamodel.rst:299
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``. Some "
"sequences, including built-in sequences, interpret negative subscripts by "
"adding the sequence length. For example, ``a[-2]`` equals ``a[n-2]``, the "
"second to last item of sequence a with length ``n``."
msgstr ""
"Estes representam conjuntos ordenados finitos indexados por números não "
"negativos. A função incorporada :func:`len` retorna o número de itens de uma "
"sequência. Quando o comprimento de uma sequência é *n*, o conjunto de "
"índices contém os números 0, 1, ..., *n*-1. O item *i* da sequência *a* é "
"selecionado por ``a[i]``. Algumas sequências, incluindo sequências "
"incorporadas, interpretam subscritos negativos adicionando o comprimento da "
"sequência. Por exemplo, ``a[-2]`` é igual a ``a[n-2]``, o penúltimo item da "
"sequência a com comprimento ``n``."

#: ../../reference/datamodel.rst:309
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type. The comment above about negative indexes also "
"applies to negative slice positions."
msgstr ""
"As sequências também suportam divisão: ``a[i:j]`` seleciona todos os itens "
"com índice *k* tal que *i* ``<=`` *k* ``<`` *j*. Quando usada como uma "
"expressão, uma divisão é uma sequência do mesmo tipo. O comentário acima "
"sobre índices negativos também se aplica a posições de divisão negativas."

#: ../../reference/datamodel.rst:314
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"Algumas sequências também suportam \"divisão estendida\" com um terceiro "
"parâmetro \"step\": ``a[i:j:k]`` seleciona todos os itens de *a* com índice "
"*x* onde ``x = i + n*k``, *n* ``>=`` ``0`` e *i* ``<=`` *x* ``<`` *j*."

#: ../../reference/datamodel.rst:318
msgid "Sequences are distinguished according to their mutability:"
msgstr "As sequências são diferenciadas de acordo com a sua mutabilidade:"

#: ../../reference/datamodel.rst:322
msgid "Immutable sequences"
msgstr "Sequências imutáveis"

#: ../../reference/datamodel.rst:328
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""
"Um objeto de um tipo de sequência imutável não pode ser alterado depois de "
"criado. (Se o objeto contiver referências a outros objetos, esses outros "
"objetos podem ser mutáveis e podem ser alterados; no entanto, a coleção de "
"objetos referenciados diretamente por um objeto imutável não pode ser "
"alterada.)"

#: ../../reference/datamodel.rst:333
msgid "The following types are immutable sequences:"
msgstr "Os seguintes tipos são sequências imutáveis:"

#: ../../reference/datamodel.rst:338
msgid "Strings"
msgstr "Strings"

#: ../../reference/datamodel.rst:346
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:expr:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""
"Uma string é uma sequência de valores que representam pontos de código "
"Unicode. Todos os pontos de código no intervalo ``U+0000 - U+10FFFF`` podem "
"ser representados numa string. O Python não tem um tipo :c:expr:`char`; em "
"vez disso, cada ponto de código na string é representado como um objeto "
"string com comprimento ``1``. A função incorporada :func:`ord` converte um "
"ponto de código da sua forma de string para um inteiro no intervalo ``0 - "
"10FFFF``; :func:`chr` converte um inteiro no intervalo ``0 - 10FFFF`` para o "
"objeto string de comprimento correspondente ``1``. :meth:`str.encode` pode "
"ser usado para converter um :class:`str` em :class:`bytes` usando a "
"codificação de texto fornecida, e :meth:`bytes.decode` pode ser usado para "
"fazer o contrário."

#: ../../reference/datamodel.rst:358
msgid "Tuples"
msgstr "Tuplos"

#: ../../reference/datamodel.rst:364
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""
"Os itens de uma tupla são objetos Python arbitrários. Tuplas de dois ou mais "
"itens são formadas por listas de expressões separadas por vírgulas. Uma "
"tupla de um item (um «singleton») pode ser formada anexando uma vírgula a "
"uma expressão (uma expressão por si só não cria uma tupla, uma vez que os "
"parênteses devem ser utilizáveis para agrupar expressões). Uma tupla vazia "
"pode ser formada por um par de parênteses vazios."

#: ../../reference/datamodel.rst:371
msgid "Bytes"
msgstr "Bytes"

#: ../../reference/datamodel.rst:374
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes` constructor can be used to create "
"bytes objects.  Also, bytes objects can be decoded to strings via the :meth:"
"`~bytes.decode` method."
msgstr ""
"Um objeto bytes é uma matriz imutável. Os itens são bytes de 8 bits, "
"representados por inteiros no intervalo 0 <= x < 256. Literais bytes (como "
"``b'abc'``) e o construtor :func:`bytes` incorporado podem ser usados para "
"criar objetos bytes. Além disso, os objetos bytes podem ser descodificados "
"para strings através do método :meth:`~bytes.decode`."

#: ../../reference/datamodel.rst:382
msgid "Mutable sequences"
msgstr "Sequências mutáveis"

#: ../../reference/datamodel.rst:391
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""
"As sequências mutáveis podem ser alteradas após serem criadas. As notações "
"de subscrição e segmentação podem ser usadas como alvo de atribuições e "
"instruções :keyword:`del` (excluir)."

#: ../../reference/datamodel.rst:399
msgid ""
"The :mod:`collections` and :mod:`array` module provide additional examples "
"of mutable sequence types."
msgstr ""
"Os módulos :mod:`collections` e :mod:`array` fornecem exemplos adicionais de "
"tipos de sequências mutáveis."

#: ../../reference/datamodel.rst:402
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "Atualmente, existem dois tipos de sequências mutáveis intrínsecas:"

#: ../../reference/datamodel.rst:404
msgid "Lists"
msgstr "Listas"

#: ../../reference/datamodel.rst:407
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"Os itens de uma lista são objetos Python arbitrários. As listas são formadas "
"colocando-se uma lista de expressões separadas por vírgulas entre colchetes. "
"(Observe que não há casos especiais necessários para formar listas de "
"comprimento 0 ou 1.)"

#: ../../reference/datamodel.rst:411
msgid "Byte Arrays"
msgstr "Matrizes de bytes"

#: ../../reference/datamodel.rst:414
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"Um objeto bytearray é uma matriz mutável. Eles são criados pelo construtor :"
"func:`bytearray` integrado. Além de serem mutáveis (e, portanto, não "
"hasháveis), as matrizes de bytes fornecem a mesma interface e funcionalidade "
"que os objetos :class:`bytes` imutáveis."

#: ../../reference/datamodel.rst:421
msgid "Set types"
msgstr "Tipos definidos"

#: ../../reference/datamodel.rst:427
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""
"Estes representam conjuntos finitos e não ordenados de objetos únicos e "
"imutáveis. Como tal, não podem ser indexados por nenhum índice. No entanto, "
"podem ser iterados, e a função incorporada :func:`len` retorna o número de "
"itens num conjunto. Os usos comuns para conjuntos são testes rápidos de "
"pertença, remoção de duplicatas de uma sequência e cálculo de operações "
"matemáticas, como interseção, união, diferença e diferença simétrica."

#: ../../reference/datamodel.rst:434
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""
"Para elementos de conjunto, aplicam-se as mesmas regras de imutabilidade que "
"para chaves de dicionário. Observe que os tipos numéricos obedecem às regras "
"normais para comparação numérica: se dois números forem iguais (por exemplo, "
"``1`` e ``1.0``), apenas um deles pode estar contido num conjunto."

#: ../../reference/datamodel.rst:439
msgid "There are currently two intrinsic set types:"
msgstr "Atualmente, existem dois tipos de conjuntos intrínsecos:"

#: ../../reference/datamodel.rst:442
msgid "Sets"
msgstr "Conjuntos"

#: ../../reference/datamodel.rst:445
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""

#: ../../reference/datamodel.rst:450
msgid "Frozen sets"
msgstr "Conjuntos congelados"

#: ../../reference/datamodel.rst:453
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""
"Estes representam um conjunto imutável. São criados pelo construtor :func:"
"`frozenset` incorporado. Como um frozenset é imutável e :term:`hashable`, "
"pode ser usado novamente como um elemento de outro conjunto ou como uma "
"chave de dicionário."

#: ../../reference/datamodel.rst:460
msgid "Mappings"
msgstr "Mapeamentos"

#: ../../reference/datamodel.rst:467
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""
"Estes representam conjuntos finitos de objetos indexados por conjuntos de "
"índices arbitrários. A notação de subscrito ``a[k]`` seleciona o item "
"indexado por ``k`` do mapeamento ``a``; isto pode ser usado em expressões e "
"como destino de atribuições ou instruções :keyword:`del`. A função "
"incorporada :func:`len` retorna o número de itens num mapeamento."

#: ../../reference/datamodel.rst:473
msgid "There is currently a single intrinsic mapping type:"
msgstr "Atualmente, existe um único tipo de mapeamento intrínseco:"

#: ../../reference/datamodel.rst:477
msgid "Dictionaries"
msgstr "Dicionários"

#: ../../reference/datamodel.rst:481
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""
"Estes representam conjuntos finitos de objetos indexados por valores quase "
"arbitrários. Os únicos tipos de valores não aceitáveis como chaves são "
"valores que contêm listas ou dicionários ou outros tipos mutáveis que são "
"comparados por valor em vez de por identidade de objeto, pois a "
"implementação eficiente de dicionários requer que o valor hash de uma chave "
"permaneça constante. Os tipos numéricos usados para chaves obedecem às "
"regras normais de comparação numérica: se dois números forem iguais (por "
"exemplo, ``1`` e ``1.0``), eles podem ser usados de forma intercambiável "
"para indexar a mesma entrada do dicionário."

#: ../../reference/datamodel.rst:490
msgid ""
"Dictionaries preserve insertion order, meaning that keys will be produced in "
"the same order they were added sequentially over the dictionary. Replacing "
"an existing key does not change the order, however removing a key and re-"
"inserting it will add it to the end instead of keeping its old place."
msgstr ""
"Os dicionários preservam a ordem de inserção, o que significa que as chaves "
"serão produzidas na mesma ordem em que foram adicionadas sequencialmente ao "
"dicionário. Substituir uma chave existente não altera a ordem, no entanto, "
"remover uma chave e reinseri-la irá adicioná-la ao final, em vez de manter a "
"sua posição anterior."

#: ../../reference/datamodel.rst:495
msgid ""
"Dictionaries are mutable; they can be created by the ``{}`` notation (see "
"section :ref:`dict`)."
msgstr ""
"Os dicionários são mutáveis; podem ser criados pela notação ``{}`` (consulte "
"a secção :ref:`dict`)."

#: ../../reference/datamodel.rst:502
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""
"Os módulos de extensão :mod:`dbm.ndbm` e :mod:`dbm.gnu` fornecem exemplos "
"adicionais de tipos de mapeamento, assim como o módulo :mod:`collections`."

#: ../../reference/datamodel.rst:506
msgid ""
"Dictionaries did not preserve insertion order in versions of Python before "
"3.6. In CPython 3.6, insertion order was preserved, but it was considered an "
"implementation detail at that time rather than a language guarantee."
msgstr ""
"Os dicionários não preservavam a ordem de inserção nas versões do Python "
"anteriores à 3.6. No CPython 3.6, a ordem de inserção era preservada, mas "
"era considerada um detalhe de implementação na época, e não uma garantia da "
"linguagem."

#: ../../reference/datamodel.rst:513
msgid "Callable types"
msgstr "Tipos chamáveis"

#: ../../reference/datamodel.rst:521
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""
"Estes são os tipos aos quais a operação de chamada de função (consulte a "
"secção :ref:`calls`) pode ser aplicada:"

#: ../../reference/datamodel.rst:528
msgid "User-defined functions"
msgstr "Funções definidas pelo utilizador"

#: ../../reference/datamodel.rst:535
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""
"Um objeto de função definido pelo utilizador é criado por uma definição de "
"função (consulte a secção :ref:`function`). Deve ser chamado com uma lista "
"de argumentos contendo o mesmo número de itens que a lista de parâmetros "
"formais da função."

#: ../../reference/datamodel.rst:541 ../../reference/datamodel.rst:1399
#: ../../reference/datamodel.rst:1598
msgid "Special read-only attributes"
msgstr "Atributos especiais somente leitura"

#: ../../reference/datamodel.rst:551 ../../reference/datamodel.rst:586
#: ../../reference/datamodel.rst:1167
msgid "Attribute"
msgstr "Atributo"

#: ../../reference/datamodel.rst:552 ../../reference/datamodel.rst:587
#: ../../reference/datamodel.rst:1168
msgid "Meaning"
msgstr "Significado"

#: ../../reference/datamodel.rst:555
msgid ""
"A reference to the :class:`dictionary <dict>` that holds the function's :ref:"
"`global variables <naming>` -- the global namespace of the module in which "
"the function was defined."
msgstr ""
"Uma referência ao :class:`dicionário <dict>` que contém as :ref:`variáveis "
"globais <naming>` da função -- o espaço de nomes global do módulo no qual a "
"função foi definida."

#: ../../reference/datamodel.rst:560
msgid ""
"``None`` or a :class:`tuple` of cells that contain bindings for the names "
"specified in the :attr:`~codeobject.co_freevars` attribute of the "
"function's :attr:`code object <function.__code__>`."
msgstr ""
"``None`` ou um :class:`tuple` de células que contêm ligações para os nomes "
"especificados no atributo :attr:`~codeobject.co_freevars` do :attr:`objeto "
"de código <function.__code__>` da função."

#: ../../reference/datamodel.rst:564
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to get "
"the value of the cell, as well as set the value."
msgstr ""
"Um objeto célula possui o atributo ``cell_contents``. Ele pode ser usado "
"para obter o valor da célula, bem como definir o valor."

#: ../../reference/datamodel.rst:568 ../../reference/datamodel.rst:1640
msgid "Special writable attributes"
msgstr "Atributos especiais graváveis"

#: ../../reference/datamodel.rst:581
msgid "Most of these attributes check the type of the assigned value:"
msgstr "A maioria destes atributos verifica o tipo do valor atribuído:"

#: ../../reference/datamodel.rst:590
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""
"A string de documentação da função ou ``None``, se não estiver disponível."

#: ../../reference/datamodel.rst:593
msgid ""
"The function's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""
"O nome da função. Veja também: :attr:`__name__ attributes <definition."
"__name__>`."

#: ../../reference/datamodel.rst:597
msgid ""
"The function's :term:`qualified name`. See also: :attr:`__qualname__ "
"attributes <definition.__qualname__>`."
msgstr ""
"O :term:`nome qualificado` da função. Veja também: :attr:`atributos "
"__qualname__ <definition.__qualname__>`."

#: ../../reference/datamodel.rst:603
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""
"O nome do módulo em que a função foi definida ou ``None`` se não estiver "
"disponível."

#: ../../reference/datamodel.rst:607
msgid ""
"A :class:`tuple` containing default :term:`parameter` values for those "
"parameters that have defaults, or ``None`` if no parameters have a default "
"value."
msgstr ""
"Uma :class:`tuple` contendo valores :term:`parâmetros` padrão para os "
"parâmetros que têm valores padrão, ou ``None`` se nenhum parâmetro tiver um "
"valor padrão."

#: ../../reference/datamodel.rst:612
msgid ""
"The :ref:`code object <code-objects>` representing the compiled function "
"body."
msgstr ""
"O :ref:`objeto código <code-objects>` que representa o corpo da função "
"compilada."

#: ../../reference/datamodel.rst:616
msgid ""
"The namespace supporting arbitrary function attributes. See also: :attr:"
"`__dict__ attributes <object.__dict__>`."
msgstr ""
"O namespace que suporta atributos de função arbitrários. Veja também: :attr:"
"`__dict__ attributes <object.__dict__>`."

#: ../../reference/datamodel.rst:620
msgid ""
"A :class:`dictionary <dict>` containing annotations of :term:`parameters "
"<parameter>`. The keys of the dictionary are the parameter names, and "
"``'return'`` for the return annotation, if provided. See also: :ref:"
"`annotations-howto`."
msgstr ""

#: ../../reference/datamodel.rst:627
msgid ""
"A :class:`dictionary <dict>` containing defaults for keyword-only :term:"
"`parameters <parameter>`."
msgstr ""
"A :class:`dicionário <dict>` contendo padrões para :term:`parâmetros "
"<parameter>` apenas com nomeados."

#: ../../reference/datamodel.rst:631
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic function <generic-functions>`."
msgstr ""
"Uma :class:`tuple` contendo os :ref:`parâmetros de tipo <type-params>` de "
"uma :ref:`função genérica <generic-functions>`."

#: ../../reference/datamodel.rst:636
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes."
msgstr ""
"Os objetos de função também suportam a obtenção e definição de atributos "
"arbitrários, que podem ser usados, por exemplo, para anexar metadados às "
"funções. A notação de ponto de atributo regular é usada para obter e definir "
"esses atributos."

#: ../../reference/datamodel.rst:642
msgid ""
"CPython's current implementation only supports function attributes on user-"
"defined functions. Function attributes on :ref:`built-in functions <builtin-"
"functions>` may be supported in the future."
msgstr ""
"A implementação atual do CPython provê apenas atributos de função em funções "
"definidas pelo utilizador. Atributos de função em :ref:`funções integradas "
"<builtin-functions>` podem ser suportados no futuro."

#: ../../reference/datamodel.rst:647
msgid ""
"Additional information about a function's definition can be retrieved from "
"its :ref:`code object <code-objects>` (accessible via the :attr:`~function."
"__code__` attribute)."
msgstr ""
"Informações adicionais sobre a definição de uma função podem ser obtidas de "
"seu :ref:`objeto código <code-objects>` (acessível através do atributo :attr:"
"`~function.__code__`)."

#: ../../reference/datamodel.rst:655
msgid "Instance methods"
msgstr "Métodos de instância"

#: ../../reference/datamodel.rst:662
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""
"Um objeto de método de instância combina uma classe, uma instância de classe "
"e qualquer objeto chamável (normalmente uma função definida pelo utilizador)."

#: ../../reference/datamodel.rst:672 ../../reference/datamodel.rst:1736
msgid "Special read-only attributes:"
msgstr "Atributos especiais somente leitura:"

#: ../../reference/datamodel.rst:677
msgid ""
"Refers to the class instance object to which the method is :ref:`bound "
"<method-binding>`"
msgstr ""
"Refere-se ao objeto instância da classe ao qual o método é :ref:`vinculado "
"<method-binding>`"

#: ../../reference/datamodel.rst:681
msgid "Refers to the original :ref:`function object <user-defined-funcs>`"
msgstr "Refere-se ao :ref:`objeto função <user-defined-funcs>` original"

#: ../../reference/datamodel.rst:684
msgid ""
"The method's documentation (same as :attr:`method.__func__.__doc__ <function."
"__doc__>`). A :class:`string <str>` if the original function had a "
"docstring, else ``None``."
msgstr ""
"A documentação do método (igual a :attr:`method.__func__.__doc__ <function."
"__doc__>`). Um :class:`string <str>` se a função original tivesse uma "
"docstring, caso contrário ``None``."

#: ../../reference/datamodel.rst:690
msgid ""
"The name of the method (same as :attr:`method.__func__.__name__ <function."
"__name__>`)"
msgstr ""
"O nome do método (mesmo que :attr:`method.__func__.__name__ <function."
"__name__>`)"

#: ../../reference/datamodel.rst:694
msgid ""
"The name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""
"O nome do módulo em que o método foi definido ou ``None`` se não estiver "
"disponível."

#: ../../reference/datamodel.rst:697
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying :ref:`function object <user-defined-funcs>`."
msgstr ""
"Os métodos também suportam o acesso (mas não a definição) aos atributos "
"arbitrários da função no objeto de função subjacente :ref:`function object "
"<user-defined-funcs>`."

#: ../../reference/datamodel.rst:700
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined :ref:`function object <user-defined-funcs>` or a :class:"
"`classmethod` object."
msgstr ""
"Objetos de método definidos pelo utilizador podem ser criados ao obter um "
"atributo de uma classe (talvez através de uma instância dessa classe), se "
"esse atributo for um objeto :ref:`função <user-defined-funcs>` definido pelo "
"utilizador ou um objeto :class:`classmethod`."

#: ../../reference/datamodel.rst:707
msgid ""
"When an instance method object is created by retrieving a user-defined :ref:"
"`function object <user-defined-funcs>` from a class via one of its "
"instances, its :attr:`~method.__self__` attribute is the instance, and the "
"method object is said to be *bound*.  The new method's :attr:`~method."
"__func__` attribute is the original function object."
msgstr ""
"Quando um objeto de método de instância é criado recuperando um objeto de "
"função definido pelo utilizador :ref:`function object <user-defined-funcs>` "
"de uma classe através de uma das suas instâncias, o seu atributo :attr:"
"`~method.__self__` é a instância, e o objeto de método é considerado "
"*vinculado*. O atributo :attr:`~method.__func__` do novo método é o objeto "
"de função original."

#: ../../reference/datamodel.rst:713
msgid ""
"When an instance method object is created by retrieving a :class:"
"`classmethod` object from a class or instance, its :attr:`~method.__self__` "
"attribute is the class itself, and its :attr:`~method.__func__` attribute is "
"the function object underlying the class method."
msgstr ""
"Quando um objeto de método de instância é criado recuperando um objeto :"
"class:`classmethod` de uma classe ou instância, o seu atributo :attr:"
"`~method.__self__` é a própria classe, e o seu atributo :attr:`~method."
"__func__` é o objeto de função subjacente ao método de classe."

#: ../../reference/datamodel.rst:718
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`~method.__func__`) is called, inserting the class instance (:attr:`~method."
"__self__`) in front of the argument list.  For instance, when :class:`!C` is "
"a class which contains a definition for a function :meth:`!f`, and ``x`` is "
"an instance of :class:`!C`, calling ``x.f(1)`` is equivalent to calling ``C."
"f(x, 1)``."
msgstr ""
"Quando um objeto de método de instância é chamado, a função subjacente (:"
"attr:`~method.__func__`) é chamada, inserindo a instância da classe (:attr:"
"`~method.__self__`) na frente da lista de argumentos. Por exemplo, quando :"
"class:`!C` é uma classe que contém uma definição para uma função :meth:`!f`, "
"e ``x`` é uma instância de :class:`!C`, chamar ``x.f(1)`` é equivalente a "
"chamar ``C.f(x, 1)``."

#: ../../reference/datamodel.rst:725
msgid ""
"When an instance method object is derived from a :class:`classmethod` "
"object, the \"class instance\" stored in :attr:`~method.__self__` will "
"actually be the class itself, so that calling either ``x.f(1)`` or ``C."
"f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is the underlying "
"function."
msgstr ""
"Quando um objeto de método de instância é derivado de um objeto :class:"
"`classmethod`, a \"instância de classe\" armazenada em :attr:`~method."
"__self__` será, na verdade, a própria classe, de modo que chamar ``x.f(1)`` "
"ou ``C.f(1)`` é equivalente a chamar ``f(C,1)``, onde ``f`` é a função "
"subjacente."

#: ../../reference/datamodel.rst:730
msgid ""
"It is important to note that user-defined functions which are attributes of "
"a class instance are not converted to bound methods; this *only* happens "
"when the function is an attribute of the class."
msgstr ""
"É importante observar que as funções definidas pelo utilizador que são "
"atributos de uma instância de classe não são convertidas em métodos "
"vinculados; isso *só* acontece quando a função é um atributo da classe."

#: ../../reference/datamodel.rst:737
msgid "Generator functions"
msgstr "Funções geradoras"

#: ../../reference/datamodel.rst:743
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an :term:`iterator` object which can be used to "
"execute the body of the function:  calling the iterator's :meth:`iterator."
"__next__` method will cause the function to execute until it provides a "
"value using the :keyword:`!yield` statement.  When the function executes a :"
"keyword:`return` statement or falls off the end, a :exc:`StopIteration` "
"exception is raised and the iterator will have reached the end of the set of "
"values to be returned."
msgstr ""
"Uma função ou método que usa a instrução :keyword:`yield` (consulte a "
"secção :ref:`yield`) é chamada de :dfn:`função geradora`. Quando chamada, "
"essa função sempre retorna um objeto :term:`iterador` que pode ser usado "
"para executar o corpo da função: chamar o método :meth:`iterator.__next__` "
"do iterador fará com que a função seja executada até fornecer um valor "
"usando a instrução :keyword:`!yield`. Quando a função executa uma instrução :"
"keyword:`return` ou chega ao fim, uma exceção :exc:`StopIteration` é "
"levantada e o iterador terá chegado ao fim do conjunto de valores a serem "
"retornados."

#: ../../reference/datamodel.rst:755
msgid "Coroutine functions"
msgstr "Funções de corrotina"

#: ../../reference/datamodel.rst:760
msgid ""
"A function or method which is defined using :keyword:`async def` is called "
"a :dfn:`coroutine function`.  Such a function, when called, returns a :term:"
"`coroutine` object.  It may contain :keyword:`await` expressions, as well "
"as :keyword:`async with` and :keyword:`async for` statements. See also the :"
"ref:`coroutine-objects` section."
msgstr ""
"Uma função ou método definido usando :keyword:`async def` é chamado de :dfn:"
"`função corrotina`. Quando chamada, essa função retorna um objeto :term:"
"`corrotina`. Ela pode conter expressões :keyword:`await`, bem como "
"instruções :keyword:`async with` e :keyword:`async for`. Consulte também a "
"secção :ref:`coroutine-objects`."

#: ../../reference/datamodel.rst:768
msgid "Asynchronous generator functions"
msgstr "Funções geradoras assíncronas"

#: ../../reference/datamodel.rst:774
msgid ""
"A function or method which is defined using :keyword:`async def` and which "
"uses the :keyword:`yield` statement is called a :dfn:`asynchronous generator "
"function`.  Such a function, when called, returns an :term:`asynchronous "
"iterator` object which can be used in an :keyword:`async for` statement to "
"execute the body of the function."
msgstr ""
"Uma função ou método definido usando :keyword:`async def` e que usa a "
"instrução :keyword:`yield` é chamado de :dfn:`função geradora assíncrona`. "
"Quando chamada, essa função retorna um objeto :term:`iterador assíncrono` "
"que pode ser usado em uma instrução :keyword:`async for` para executar o "
"corpo da função."

#: ../../reference/datamodel.rst:780
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__ <object."
"__anext__>` method will return an :term:`awaitable` which when awaited will "
"execute until it provides a value using the :keyword:`yield` expression.  "
"When the function executes an empty :keyword:`return` statement or falls off "
"the end, a :exc:`StopAsyncIteration` exception is raised and the "
"asynchronous iterator will have reached the end of the set of values to be "
"yielded."
msgstr ""
"Chamar o método :meth:`aiterator.__anext__ <object.__anext__>` do iterador "
"assíncrono retornará um :term:`awaitable` que, quando aguardado, será "
"executado até fornecer um valor usando a expressão :keyword:`yield`. Quando "
"a função executa uma instrução :keyword:`return` vazia ou chega ao fim, uma "
"exceção :exc:`StopAsyncIteration` é levantada e o iterador assíncrono terá "
"chegado ao fim do conjunto de valores a serem produzidos."

#: ../../reference/datamodel.rst:793
msgid "Built-in functions"
msgstr "Funções integradas"

#: ../../reference/datamodel.rst:800
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes:"
msgstr ""
"Um objeto de função incorporado é um invólucro em torno de uma função C. "
"Exemplos de funções incorporadas são: :func:`len` e :func:`math.sin` (:mod:"
"`math` é um módulo incorporado padrão). O número e o tipo dos argumentos são "
"determinados pela função C. Atributos especiais somente leitura:"

#: ../../reference/datamodel.rst:805
msgid ""
":attr:`!__doc__` is the function's documentation string, or ``None`` if "
"unavailable. See :attr:`function.__doc__`."
msgstr ""
":attr:`!__doc__` é a string de documentação da função, ou ``None`` se não "
"estiver disponível. Consulte :attr:`function.__doc__`."

#: ../../reference/datamodel.rst:807
msgid ""
":attr:`!__name__` is the function's name. See :attr:`function.__name__`."
msgstr ""
":attr:`!__name__` é o nome da função. Consulte :attr:`function.__name__`."

#: ../../reference/datamodel.rst:808
msgid ":attr:`!__self__` is set to ``None`` (but see the next item)."
msgstr ":attr:`!__self__` é definido como ``None`` (mas veja o próximo item)."

#: ../../reference/datamodel.rst:809
msgid ""
":attr:`!__module__` is the name of the module the function was defined in or "
"``None`` if unavailable. See :attr:`function.__module__`."
msgstr ""
":attr:`!__module__` é o nome do módulo em que a função foi definida ou "
"``None`` se não estiver disponível. Consulte :attr:`function.__module__`."

#: ../../reference/datamodel.rst:817
msgid "Built-in methods"
msgstr "Métodos incorporados"

#: ../../reference/datamodel.rst:824
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`!__self__` is set to the object denoted by *alist*. (The attribute has "
"the same semantics as it does with :attr:`other instance methods <method."
"__self__>`.)"
msgstr ""
"Na verdade, trata-se de um disfarce diferente de uma função incorporada, "
"desta vez contendo um objeto passado para a função C como um argumento extra "
"implícito. Um exemplo de um método incorporado é ``alist.append()``, "
"assumindo que *alist* é um objeto de lista. Neste caso, o atributo especial "
"somente leitura :attr:`!__self__` é definido para o objeto denotado por "
"*alist*. (O atributo tem a mesma semântica que tem com :attr:`outros métodos "
"de instância <method.__self__>`.)"

#: ../../reference/datamodel.rst:834
msgid "Classes"
msgstr "Classes"

#: ../../reference/datamodel.rst:836
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`~object.__new__`.  The arguments of the call are passed to :"
"meth:`!__new__` and, in the typical case, to :meth:`~object.__init__` to "
"initialize the new instance."
msgstr ""
"As classes são chamáveis. Esses objetos normalmente atuam como fábricas para "
"novas instâncias de si mesmos, mas variações são possíveis para tipos de "
"classe que substituem :meth:`~object.__new__`. Os argumentos da chamada são "
"passados para :meth:`!__new__` e, no caso típico, para :meth:`~object."
"__init__` para inicializar a nova instância."

#: ../../reference/datamodel.rst:844
msgid "Class Instances"
msgstr "Instâncias de classe"

#: ../../reference/datamodel.rst:846
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`~object.__call__` method in their class."
msgstr ""
"As instâncias de classes arbitrárias podem ser tornadas chamáveis definindo "
"um método :meth:`~object.__call__` na sua classe."

#: ../../reference/datamodel.rst:853
msgid "Modules"
msgstr "Módulos"

#: ../../reference/datamodel.rst:859
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement, or by calling functions such as :func:`importlib."
"import_module` and built-in :func:`__import__`.  A module object has a "
"namespace implemented by a :class:`dictionary <dict>` object (this is the "
"dictionary referenced by the :attr:`~function.__globals__` attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m."
"__dict__[\"x\"]``. A module object does not contain the code object used to "
"initialize the module (since it isn't needed once the initialization is "
"done)."
msgstr ""
"Módulos são uma unidade organizacional básica do código Python, e são "
"criados pelo :ref:`sistema de importação <importsystem>` quando invocado "
"pela instrução :keyword:`import`, ou chamando funções como :func:`importlib."
"import_module` e a integrada :func:`__import__`. Um objeto módulo tem um "
"espaço de nomes implementado por um objeto :class:`dicionário <dict>` (este "
"é o dicionário referenciado pelo atributo :attr:`~function.__globals__` das "
"funções definidas no módulo). As referências de atributos são traduzidas "
"para pesquisas neste dicionário, por exemplo, ``m.x`` é equivalente a ``m."
"__dict__[\"x\"]``. Um objeto módulo não contém o objeto código usado para "
"inicializar o módulo (uma vez que não é necessário depois que a "
"inicialização é concluída)."

#: ../../reference/datamodel.rst:872
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"A atribuição de atributos atualiza o dicionário do namespace do módulo, por "
"exemplo, ``m.x = 1`` é equivalente a ``m.__dict__[\"x\"] = 1``."

#: ../../reference/datamodel.rst:890
msgid "Import-related attributes on module objects"
msgstr "Atributos relacionados à importação em objetos de módulo"

#: ../../reference/datamodel.rst:892
msgid ""
"Module objects have the following attributes that relate to the :ref:`import "
"system <importsystem>`. When a module is created using the machinery "
"associated with the import system, these attributes are filled in based on "
"the module's :term:`spec <module spec>`, before the :term:`loader` executes "
"and loads the module."
msgstr ""
"Os objetos do módulo têm os seguintes atributos relacionados ao :ref:"
"`sistema de importação <importsystem>`. Quando um módulo é criado usando o "
"mecanismo associado ao sistema de importação, esses atributos são "
"preenchidos com base na :term:`especificação <module spec>` do módulo, antes "
"que o :term:`carregador` execute e carregue o módulo."

#: ../../reference/datamodel.rst:898
msgid ""
"To create a module dynamically rather than using the import system, it's "
"recommended to use :func:`importlib.util.module_from_spec`, which will set "
"the various import-controlled attributes to appropriate values. It's also "
"possible to use the :class:`types.ModuleType` constructor to create modules "
"directly, but this technique is more error-prone, as most attributes must be "
"manually set on the module object after it has been created when using this "
"approach."
msgstr ""
"Para criar um módulo dinamicamente em vez de usar o sistema de importação, "
"recomenda-se usar :func:`importlib.util.module_from_spec`, que definirá os "
"vários atributos controlados pela importação para valores apropriados. "
"Também é possível usar o construtor :class:`types.ModuleType` para criar "
"módulos diretamente, mas essa técnica é mais propensa a erros, pois a "
"maioria dos atributos deve ser definida manualmente no objeto do módulo após "
"a sua criação ao usar essa abordagem."

#: ../../reference/datamodel.rst:908
msgid ""
"With the exception of :attr:`~module.__name__`, it is **strongly** "
"recommended that you rely on :attr:`~module.__spec__` and its attributes "
"instead of any of the other individual attributes listed in this subsection. "
"Note that updating an attribute on :attr:`!__spec__` will not update the "
"corresponding attribute on the module itself:"
msgstr ""
"Com exceção de :attr:`~module.__name__`, é **altamente** recomendável que se "
"utilize :attr:`~module.__spec__` e os seus atributos em vez de qualquer "
"outro atributo individual listado nesta subsecção. Note que atualizar um "
"atributo em :attr:`!__spec__` não atualizará o atributo correspondente no "
"próprio módulo:"

#: ../../reference/datamodel.rst:914
msgid ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"
msgstr ""
">>> import typing\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'typing')\n"
">>> typing.__spec__.name = 'spelling'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('typing', 'spelling')\n"
">>> typing.__name__ = 'keyboard_smashing'\n"
">>> typing.__name__, typing.__spec__.name\n"
"('keyboard_smashing', 'spelling')"

#: ../../reference/datamodel.rst:928
msgid ""
"The name used to uniquely identify the module in the import system. For a "
"directly executed module, this will be set to ``\"__main__\"``."
msgstr ""
"O nome usado para identificar exclusivamente o módulo no sistema de "
"importação. Para um módulo executado diretamente, isso será definido como "
"``\"__main__\"``."

#: ../../reference/datamodel.rst:931
msgid ""
"This attribute must be set to the fully qualified name of the module. It is "
"expected to match the value of :attr:`module.__spec__.name <importlib."
"machinery.ModuleSpec.name>`."
msgstr ""
"Este atributo deve ser definido como o nome totalmente qualificado do "
"módulo. Espera-se que corresponda ao valor de :attr:`module.__spec__.name "
"<importlib.machinery.ModuleSpec.name>`."

#: ../../reference/datamodel.rst:937
msgid "A record of the module's import-system-related state."
msgstr ""
"Um registo do estado do módulo relacionado com o sistema de importação."

#: ../../reference/datamodel.rst:939
msgid ""
"Set to the :class:`module spec <importlib.machinery.ModuleSpec>` that was "
"used when importing the module. See :ref:`module-specs` for more details."
msgstr ""
"Defina para a :class:`especificação do módulo <importlib.machinery."
"ModuleSpec>` que foi utilizada ao importar o módulo. Consulte :ref:`module-"
"specs` para obter mais detalhes."

#: ../../reference/datamodel.rst:946
msgid "The :term:`package` a module belongs to."
msgstr "O :term:`pacote` ao qual um módulo pertence."

#: ../../reference/datamodel.rst:948
msgid ""
"If the module is top-level (that is, not a part of any specific package) "
"then the attribute should be set to ``''`` (the empty string). Otherwise, it "
"should be set to the name of the module's package (which can be equal to :"
"attr:`module.__name__` if the module itself is a package). See :pep:`366` "
"for further details."
msgstr ""
"Se o módulo for de nível superior (ou seja, não fizer parte de nenhum pacote "
"específico), o atributo deve ser definido como ``''`` (a string vazia). Caso "
"contrário, deve ser definido como o nome do pacote do módulo (que pode ser "
"igual a :attr:`module.__name__` se o próprio módulo for um pacote). "
"Consulte :pep:`366` para obter mais detalhes."

#: ../../reference/datamodel.rst:954
msgid ""
"This attribute is used instead of :attr:`~module.__name__` to calculate "
"explicit relative imports for main modules. It defaults to ``None`` for "
"modules created dynamically using the :class:`types.ModuleType` constructor; "
"use :func:`importlib.util.module_from_spec` instead to ensure the attribute "
"is set to a :class:`str`."
msgstr ""
"Este atributo é usado em vez de :attr:`~module.__name__` para calcular "
"importações relativas explícitas para módulos principais. O padrão é "
"``None`` para módulos criados dinamicamente usando o construtor :class:"
"`types.ModuleType`; use :func:`importlib.util.module_from_spec` em vez disso "
"para garantir que o atributo seja definido como :class:`str`."

#: ../../reference/datamodel.rst:960
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.parent "
"<importlib.machinery.ModuleSpec.parent>` instead of :attr:`!module."
"__package__`. :attr:`__package__` is now only used as a fallback if :attr:`!"
"__spec__.parent` is not set, and this fallback path is deprecated."
msgstr ""
"É **altamente** recomendável usar :attr:`module.__spec__.parent <importlib."
"machinery.ModuleSpec.parent>` em vez de :attr:`!module.__package__`. :attr:"
"`__package__` agora é usado apenas como um recurso alternativo se :attr:`!"
"__spec__.parent` não estiver definido, e esse caminho alternativo está "
"obsoleto."

#: ../../reference/datamodel.rst:966 ../../reference/datamodel.rst:1007
msgid ""
"This attribute now defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor. Previously the attribute "
"was optional."
msgstr ""
"Este atributo agora tem como padrão ``None`` para módulos criados "
"dinamicamente usando o construtor :class:`types.ModuleType`. Anteriormente, "
"o atributo era opcional."

#: ../../reference/datamodel.rst:971
msgid ""
"The value of :attr:`!__package__` is expected to be the same as :attr:"
"`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. :attr:"
"`__package__` is now only used as a fallback during import resolution if :"
"attr:`!__spec__.parent` is not defined."
msgstr ""
"Espera-se que o valor de :attr:`!__package__` seja o mesmo que :attr:"
"`__spec__.parent <importlib.machinery.ModuleSpec.parent>`. :attr:"
"`__package__` agora é usado apenas como um recurso alternativo durante a "
"resolução da importação, se :attr:`!__spec__.parent` não estiver definido."

#: ../../reference/datamodel.rst:977
msgid ""
":exc:`ImportWarning` is raised if an import resolution falls back to :attr:`!"
"__package__` instead of :attr:`__spec__.parent <importlib.machinery."
"ModuleSpec.parent>`."
msgstr ""
":exc:`ImportWarning` é gerado se uma resolução de importação recuar para :"
"attr:`!__package__` em vez de :attr:`__spec__.parent <importlib.machinery."
"ModuleSpec.parent>`."

#: ../../reference/datamodel.rst:982
msgid ""
"Raise :exc:`DeprecationWarning` instead of :exc:`ImportWarning` when falling "
"back to :attr:`!__package__` during import resolution."
msgstr ""
"Levante :exc:`DeprecationWarning` em vez de :exc:`ImportWarning` ao recorrer "
"a :attr:`!__package__` durante a resolução da importação."

#: ../../reference/datamodel.rst:986
msgid ""
":attr:`!__package__` will cease to be set or taken into consideration by the "
"import system or standard library."
msgstr ""
":attr:`!__package__` deixará de ser definido ou considerado pelo sistema de "
"importação ou pela biblioteca padrão."

#: ../../reference/datamodel.rst:992
msgid ""
"The :term:`loader` object that the import machinery used to load the module."
msgstr ""
"O objeto :term:`loader` que o mecanismo de importação usou para carregar o "
"módulo."

#: ../../reference/datamodel.rst:994
msgid ""
"This attribute is mostly useful for introspection, but can be used for "
"additional loader-specific functionality, for example getting data "
"associated with a loader."
msgstr ""
"Este atributo é útil principalmente para introspecção, mas pode ser usado "
"para funcionalidades adicionais específicas do carregador, por exemplo, "
"obter dados associados a um carregador."

#: ../../reference/datamodel.rst:998
msgid ""
":attr:`!__loader__` defaults to ``None`` for modules created dynamically "
"using the :class:`types.ModuleType` constructor; use :func:`importlib.util."
"module_from_spec` instead to ensure the attribute is set to a :term:`loader` "
"object."
msgstr ""
":attr:`!__loader__` tem como padrão ``None`` para módulos criados "
"dinamicamente usando o construtor :class:`types.ModuleType`; use :func:"
"`importlib.util.module_from_spec` em vez disso para garantir que o atributo "
"seja definido como um objeto :term:`loader`."

#: ../../reference/datamodel.rst:1003
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` instead of :attr:`!module."
"__loader__`."
msgstr ""
"É **altamente** recomendável que utilize :attr:`module.__spec__.loader "
"<importlib.machinery.ModuleSpec.loader>` em vez de :attr:`!module."
"__loader__`."

#: ../../reference/datamodel.rst:1012
msgid ""
"Setting :attr:`!__loader__` on a module while failing to set :attr:`!"
"__spec__.loader` is deprecated. In Python 3.16, :attr:`!__loader__` will "
"cease to be set or taken into consideration by the import system or the "
"standard library."
msgstr ""
"Definir :attr:`!__loader__` num módulo sem definir :attr:`!__spec__.loader` "
"está obsoleto. No Python 3.16, :attr:`!__loader__` deixará de ser definido "
"ou considerado pelo sistema de importação ou pela biblioteca padrão."

#: ../../reference/datamodel.rst:1020
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations "
"where the package's submodules will be found. Non-package modules should not "
"have a :attr:`!__path__` attribute. See :ref:`package-path-rules` for more "
"details."
msgstr ""
"Uma (possivelmente vazia) :term:`sequência` de cadeias que enumeram os "
"locais onde os submódulos do pacote serão encontrados. Os módulos que não "
"pertencem ao pacote não devem ter um atributo :attr:`!__path__`. Consulte :"
"ref:`package-path-rules` para obter mais detalhes."

#: ../../reference/datamodel.rst:1025
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__."
"submodule_search_locations <importlib.machinery.ModuleSpec."
"submodule_search_locations>` instead of :attr:`!module.__path__`."
msgstr ""
"É **altamente** recomendável que utilize :attr:`module.__spec__."
"submodule_search_locations <importlib.machinery.ModuleSpec."
"submodule_search_locations>` em vez de :attr:`!module.__path__`."

#: ../../reference/datamodel.rst:1032
msgid ""
":attr:`!__file__` and :attr:`!__cached__` are both optional attributes that "
"may or may not be set. Both attributes should be a :class:`str` when they "
"are available."
msgstr ""
":attr:`!__file__` e :attr:`!__cached__` são atributos opcionais que podem ou "
"não ser definidos. Ambos os atributos devem ser do tipo :class:`str` quando "
"estiverem disponíveis."

#: ../../reference/datamodel.rst:1036
msgid ""
":attr:`!__file__` indicates the pathname of the file from which the module "
"was loaded (if loaded from a file), or the pathname of the shared library "
"file for extension modules loaded dynamically from a shared library. It "
"might be missing for certain types of modules, such as C modules that are "
"statically linked into the interpreter, and the :ref:`import system "
"<importsystem>` may opt to leave it unset if it has no semantic meaning (for "
"example, a module loaded from a database)."
msgstr ""
":attr:`!__file__` indica o nome do caminho do ficheiro a partir do qual o "
"módulo foi carregado (se carregado a partir de um ficheiro) ou o nome do "
"caminho do ficheiro da biblioteca partilhada para módulos de extensão "
"carregados dinamicamente a partir de uma biblioteca partilhada. Pode estar "
"ausente para certos tipos de módulos, como módulos C que são ligados "
"estaticamente ao interpretador, e o :ref:`import system <importsystem>` pode "
"optar por deixá-lo sem definição se não tiver significado semântico (por "
"exemplo, um módulo carregado a partir de uma base de dados)."

#: ../../reference/datamodel.rst:1044
msgid ""
"If :attr:`!__file__` is set then the :attr:`!__cached__` attribute might "
"also be set,  which is the path to any compiled version of the code (for "
"example, a byte-compiled file). The file does not need to exist to set this "
"attribute; the path can simply point to where the compiled file *would* "
"exist (see :pep:`3147`)."
msgstr ""
"Se :attr:`!__file__` estiver definido, então o atributo :attr:`!__cached__` "
"também poderá estar definido, que é o caminho para qualquer versão compilada "
"do código (por exemplo, um ficheiro compilado em bytes). O ficheiro não "
"precisa de existir para definir este atributo; o caminho pode simplesmente "
"apontar para onde o ficheiro compilado *existiria* (consulte :pep:`3147`)."

#: ../../reference/datamodel.rst:1050
msgid ""
"Note that :attr:`!__cached__` may be set even if :attr:`!__file__` is not "
"set.  However, that scenario is quite atypical.  Ultimately, the :term:"
"`loader` is what makes use of the module spec provided by the :term:`finder` "
"(from which :attr:`!__file__` and :attr:`!__cached__` are derived).  So if a "
"loader can load from a cached module but otherwise does not load from a "
"file, that atypical scenario may be appropriate."
msgstr ""
"Note que :attr:`!__cached__` pode ser definido mesmo que :attr:`!__file__` "
"não esteja definido. No entanto, esse cenário é bastante atípico. Em última "
"análise, o :term:`loader` é o que utiliza a especificação do módulo "
"fornecida pelo :term:`finder` (do qual :attr:`!__file__` e :attr:`!"
"__cached__` são derivados). Portanto, se um carregador pode carregar a "
"partir de um módulo em cache, mas não carrega a partir de um ficheiro, esse "
"cenário atípico pode ser apropriado."

#: ../../reference/datamodel.rst:1057
msgid ""
"It is **strongly** recommended that you use :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` instead of :attr:`!module."
"__cached__`."
msgstr ""
"É **altamente** recomendável que utilize :attr:`module.__spec__.cached "
"<importlib.machinery.ModuleSpec.cached>` em vez de :attr:`!module."
"__cached__`."

#: ../../reference/datamodel.rst:1061
msgid ""
"Setting :attr:`!__cached__` on a module while failing to set :attr:`!"
"__spec__.cached` is deprecated. In Python 3.15, :attr:`!__cached__` will "
"cease to be set or taken into consideration by the import system or standard "
"library."
msgstr ""
"Definir :attr:`!__cached__` num módulo sem definir :attr:`!__spec__.cached` "
"está obsoleto. No Python 3.15, :attr:`!__cached__` deixará de ser definido "
"ou considerado pelo sistema de importação ou pela biblioteca padrão."

#: ../../reference/datamodel.rst:1068
msgid "Other writable attributes on module objects"
msgstr "Outros atributos graváveis em objetos de módulo"

#: ../../reference/datamodel.rst:1070
msgid ""
"As well as the import-related attributes listed above, module objects also "
"have the following writable attributes:"
msgstr ""
"Além dos atributos relacionados à importação listados acima, os objetos do "
"módulo também têm os seguintes atributos graváveis:"

#: ../../reference/datamodel.rst:1075
msgid ""
"The module's documentation string, or ``None`` if unavailable. See also: :"
"attr:`__doc__ attributes <definition.__doc__>`."
msgstr ""
"A string de documentação do módulo, ou ``None`` se não estiver disponível. "
"Veja também: :attr:`__doc__ attributes <definition.__doc__>`."

#: ../../reference/datamodel.rst:1080
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during module body execution.  For best practices on working with :"
"attr:`__annotations__`, please see :ref:`annotations-howto`."
msgstr ""

#: ../../reference/datamodel.rst:1086
msgid "Module dictionaries"
msgstr "Dicionários de módulos"

#: ../../reference/datamodel.rst:1088
msgid "Module objects also have the following special read-only attribute:"
msgstr ""
"Os objetos do módulo também têm o seguinte atributo especial somente leitura:"

#: ../../reference/datamodel.rst:1093
msgid ""
"The module's namespace as a dictionary object. Uniquely among the attributes "
"listed here, :attr:`!__dict__` cannot be accessed as a global variable from "
"within a module; it can only be accessed as an attribute on module objects."
msgstr ""
"O namespace do módulo como um objeto dicionário. Diferentemente dos "
"atributos listados aqui, :attr:`!__dict__` não pode ser acessado como uma "
"variável global de dentro de um módulo; ele só pode ser acessado como um "
"atributo em objetos de módulo."

#: ../../reference/datamodel.rst:1099
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""
"Devido à forma como o CPython limpa os dicionários de módulos, o dicionário "
"do módulo será limpo quando o módulo sair do escopo, mesmo que o dicionário "
"ainda tenha referências ativas. Para evitar isso, copie o dicionário ou "
"mantenha o módulo enquanto usa o seu dicionário diretamente."

#: ../../reference/datamodel.rst:1108
msgid "Custom classes"
msgstr "Classes personalizadas"

#: ../../reference/datamodel.rst:1110
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found at :ref:`python_2.3_mro`."
msgstr ""
"Os tipos de classes personalizadas são normalmente criados por definições de "
"classe (consulte a secção :ref:`class`). Uma classe tem um namespace "
"implementado por um objeto dicionário. As referências de atributos de classe "
"são traduzidas para pesquisas neste dicionário, por exemplo, ``C.x`` é "
"traduzido para ``C.__dict__[\"x\"]`` (embora existam vários ganchos que "
"permitem outros meios de localizar atributos). Quando o nome do atributo não "
"é encontrado lá, a pesquisa do atributo continua nas classes base. Essa "
"pesquisa nas classes base usa a ordem de resolução de métodos C3, que se "
"comporta corretamente mesmo na presença de estruturas de herança «diamante», "
"onde há vários caminhos de herança que levam de volta a um ancestral comum. "
"Detalhes adicionais sobre o C3 MRO usado pelo Python podem ser encontrados "
"em :ref:`python_2.3_mro`."

#: ../../reference/datamodel.rst:1131
msgid ""
"When a class attribute reference (for class :class:`!C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`~method.__self__` attribute is :class:`!C`. When it would yield a :"
"class:`staticmethod` object, it is transformed into the object wrapped by "
"the static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""
"Quando uma referência a um atributo de classe (para a classe :class:`!C`, "
"por exemplo) produziria um objeto de método de classe, ela é transformada "
"num objeto de método de instância cujo atributo :attr:`~method.__self__` é :"
"class:`!C`. Quando produziria um objeto :class:`staticmethod`, ela é "
"transformada no objeto envolvido pelo objeto de método estático. Consulte a "
"secção :ref:`descriptors` para ver outra forma em que os atributos "
"recuperados de uma classe podem diferir daqueles realmente contidos no seu :"
"attr:`~object.__dict__`."

#: ../../reference/datamodel.rst:1142
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""
"As atribuições de atributos de classe atualizam o dicionário da classe, "
"nunca o dicionário de uma classe base."

#: ../../reference/datamodel.rst:1147
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""
"Um objeto de classe pode ser chamado (ver acima) para produzir uma instância "
"de classe (ver abaixo)."

#: ../../reference/datamodel.rst:1150 ../../reference/datamodel.rst:1305
msgid "Special attributes"
msgstr "Atributos especiais"

#: ../../reference/datamodel.rst:1171
msgid ""
"The class's name. See also: :attr:`__name__ attributes <definition."
"__name__>`."
msgstr ""
"O nome da classe. Veja também: :attr:`atributos __name__ <definition."
"__name__>`."

#: ../../reference/datamodel.rst:1175
msgid ""
"The class's :term:`qualified name`. See also: :attr:`__qualname__ attributes "
"<definition.__qualname__>`."
msgstr ""
"O :term:`nome qualificado` da classe. Veja também: :attr:`atributos "
"__qualname__ <definition.__qualname__>`."

#: ../../reference/datamodel.rst:1179
msgid "The name of the module in which the class was defined."
msgstr "The name of the module in which the class was defined."

#: ../../reference/datamodel.rst:1182
msgid ""
"A :class:`mapping proxy <types.MappingProxyType>` providing a read-only view "
"of the class's namespace. See also: :attr:`__dict__ attributes <object."
"__dict__>`."
msgstr ""
"Um :class:`proxy de mapeamento <types.MappingProxyType>` que fornece uma "
"visão somente leitura do namespace da classe. Veja também: :attr:`atributos "
"__dict__ <object.__dict__>`. "

#: ../../reference/datamodel.rst:1187
msgid ""
"A :class:`tuple` containing the class's bases. In most cases, for a class "
"defined as ``class X(A, B, C)``, ``X.__bases__`` will be exactly equal to "
"``(A, B, C)``."
msgstr ""
"Uma :class:`tuple` contendo as bases da classe. Na maioria dos casos, para "
"uma classe definida como ``class X(A, B, C)``, ``X.__bases__`` será "
"exatamente igual a ``(A, B, C)``."

#: ../../reference/datamodel.rst:1194
msgid ""
"The single base class in the inheritance chain that is responsible for the "
"memory layout of instances. This attribute corresponds to :c:member:"
"`~PyTypeObject.tp_base` at the C level."
msgstr ""
"A única classe base na cadeia de herança que é responsável pelo layout de "
"memória das instâncias. Este atributo corresponde a :c:member:`~PyTypeObject."
"tp_base` ao nível de C."

#: ../../reference/datamodel.rst:1199
msgid ""
"The class's documentation string, or ``None`` if undefined. Not inherited by "
"subclasses."
msgstr ""
"A string de documentação da classe, ou ``None`` se não estiver definida. Não "
"é herdada por subclasses."

#: ../../reference/datamodel.rst:1203
msgid ""
"A dictionary containing :term:`variable annotations <variable annotation>` "
"collected during class body execution. For best practices on working with :"
"attr:`!__annotations__`, please see :ref:`annotations-howto`."
msgstr ""

#: ../../reference/datamodel.rst:1210
msgid ""
"Accessing the :attr:`!__annotations__` attribute of a class object directly "
"may yield incorrect results in the presence of metaclasses. In addition, the "
"attribute may not exist for some classes. Use :func:`inspect."
"get_annotations` to retrieve class annotations safely."
msgstr ""

#: ../../reference/datamodel.rst:1217
msgid ""
"A :class:`tuple` containing the :ref:`type parameters <type-params>` of a :"
"ref:`generic class <generic-classes>`."
msgstr ""
"Uma :class:`tuple` contendo os :ref:`parâmetros de tipo <type-params>` de "
"uma :ref:`classe genérica <generic-classes>`. "

#: ../../reference/datamodel.rst:1223
msgid ""
"A :class:`tuple` containing names of attributes of this class which are "
"assigned through ``self.X`` from any function in its body."
msgstr ""
"Uma :class:`tuple` contendo os nomes dos atributos desta classe que são "
"atribuídos através de ``self.X`` em qualquer função no seu corpo."

#: ../../reference/datamodel.rst:1229
msgid ""
"The line number of the first line of the class definition, including "
"decorators. Setting the :attr:`__module__` attribute removes the :attr:`!"
"__firstlineno__` item from the type's dictionary."
msgstr ""

#: ../../reference/datamodel.rst:1237
msgid ""
"The :class:`tuple` of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""
"A :class:`tuple` de classes que são consideradas ao procurar classes base "
"durante a resolução de métodos."

#: ../../reference/datamodel.rst:1242
msgid "Special methods"
msgstr "Métodos especiais"

#: ../../reference/datamodel.rst:1244
msgid ""
"In addition to the special attributes described above, all Python classes "
"also have the following two methods available:"
msgstr ""
"Além dos atributos especiais descritos acima, todas as classes Python também "
"têm os seguintes dois métodos disponíveis:"

#: ../../reference/datamodel.rst:1249
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~type.__mro__`."
msgstr ""

#: ../../reference/datamodel.rst:1255
msgid ""
"Each class keeps a list of weak references to its immediate subclasses. This "
"method returns a list of all those references still alive. The list is in "
"definition order. Example:"
msgstr ""
"Cada classe mantém uma lista de referências fracas às suas subclasses "
"imediatas. Este método retorna uma lista de todas essas referências ainda "
"ativas. A lista está na ordem de definição. Exemplo:"

#: ../../reference/datamodel.rst:1259
msgid ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"
msgstr ""
">>> class A: pass\n"
">>> class B(A): pass\n"
">>> A.__subclasses__()\n"
"[<class 'B'>]"

#: ../../reference/datamodel.rst:1267
msgid "Class instances"
msgstr "Instâncias de classe"

#: ../../reference/datamodel.rst:1275
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`~method.__self__` attribute is the instance.  "
"Static method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`~object.__dict__`.  If no "
"class attribute is found, and the object's class has a :meth:`~object."
"__getattr__` method, that is called to satisfy the lookup."
msgstr ""

#: ../../reference/datamodel.rst:1291
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`~object.__setattr__` or :"
"meth:`~object.__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"A atribuição e eliminação de atributos atualizam o dicionário da instância, "
"nunca o dicionário de uma classe. Se a classe tiver um método :meth:`~object."
"__setattr__` ou :meth:`~object.__delattr__`, este é chamado em vez de "
"atualizar diretamente o dicionário da instância."

#: ../../reference/datamodel.rst:1301
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""
"As instâncias de classe podem comportar-se como números, sequências ou "
"mapeamentos se tiverem métodos com certos nomes especiais. Consulte a "
"secção :ref:`specialnames`."

#: ../../reference/datamodel.rst:1313
msgid "The class to which a class instance belongs."
msgstr "A classe a que uma instância de classe pertence."

#: ../../reference/datamodel.rst:1317
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes. Not all instances have a :attr:`!__dict__` attribute; see the "
"section on :ref:`slots` for more details."
msgstr ""
"Um dicionário ou outro objeto de mapeamento usado para armazenar os "
"atributos (graváveis) de um objeto. Nem todas as instâncias têm um atributo :"
"attr:`!__dict__`; consulte a secção :ref:`slots` para mais detalhes."

#: ../../reference/datamodel.rst:1323
msgid "I/O objects (also known as file objects)"
msgstr "Objetos de E/S (também conhecidos como objetos de ficheiro)"

#: ../../reference/datamodel.rst:1338
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""
"Um objeto :term:`ficheiro` representa um ficheiro aberto. Existem vários "
"atalhos para criar objetos de ficheiro: a função integrada :func:`open`, bem "
"como :func:`os.popen`, :func:`os.fdopen` e o método :meth:`~socket.socket."
"makefile` de objetos de socket (e possivelmente por outras funções ou "
"métodos fornecidos por módulos de extensão)."

#: ../../reference/datamodel.rst:1344
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""
"Os objetos ``sys.stdin``, ``sys.stdout`` e ``sys.stderr`` são inicializados "
"para objetos de ficheiro correspondentes aos fluxos de entrada, saída e erro "
"padrão do interpretador; todos estão abertos em modo de texto e, portanto, "
"seguem a interface definida pela classe abstrata :class:`io.TextIOBase`."

#: ../../reference/datamodel.rst:1352
msgid "Internal types"
msgstr "Tipos internos"

#: ../../reference/datamodel.rst:1358
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""
"Alguns tipos usados internamente pelo interpretador são expostos ao "
"utilizador. A sua definição pode mudar em versões futuras do interpretador, "
"mas são mencionados aqui para completude."

#: ../../reference/datamodel.rst:1366
msgid "Code objects"
msgstr "Objetos de código"

#: ../../reference/datamodel.rst:1370
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""
"Os objetos de código representam código Python executável *compilado em "
"bytes*, ou :term:`bytecode`. A diferença entre um objeto de código e um "
"objeto de função é que o objeto de função contém uma referência explícita "
"aos globais da função (o módulo no qual foi definida), enquanto um objeto de "
"código não contém contexto; além disso, os valores dos argumentos "
"predefinidos são armazenados no objeto de função, não no objeto de código "
"(porque representam valores calculados em tempo de execução). Ao contrário "
"dos objetos de função, os objetos de código são imutáveis e não contêm "
"referências (diretas ou indiretas) a objetos mutáveis."

#: ../../reference/datamodel.rst:1404
msgid "The function name"
msgstr "O nome da função"

#: ../../reference/datamodel.rst:1407
msgid "The fully qualified function name"
msgstr "O nome qualificado da função"

#: ../../reference/datamodel.rst:1412
msgid ""
"The total number of positional :term:`parameters <parameter>` (including "
"positional-only parameters and parameters with default values) that the "
"function has"
msgstr ""
"O número total de :term:`parâmetros <parameter>` posicionais (incluindo "
"parâmetros apenas posicionais e parâmetros com valores predefinidos) que a "
"função tem"

#: ../../reference/datamodel.rst:1417
msgid ""
"The number of positional-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"O número de :term:`parâmetros <parameter>` apenas posicionais (incluindo "
"argumentos com valores predefinidos) que a função tem"

#: ../../reference/datamodel.rst:1421
msgid ""
"The number of keyword-only :term:`parameters <parameter>` (including "
"arguments with default values) that the function has"
msgstr ""
"O número de :term:`parâmetros <parameter>` apenas nomeados (incluindo "
"argumentos com valores predefinidos) que a função tem"

#: ../../reference/datamodel.rst:1425
msgid ""
"The number of :ref:`local variables <naming>` used by the function "
"(including parameters)"
msgstr ""
"O número de :ref:`variáveis locais <naming>` usadas pela função (incluindo "
"parâmetros)"

#: ../../reference/datamodel.rst:1429
msgid ""
"A :class:`tuple` containing the names of the local variables in the function "
"(starting with the parameter names)"
msgstr ""
"Uma :class:`tuple` contendo os nomes das variáveis locais na função "
"(começando com os nomes dos parâmetros)"

#: ../../reference/datamodel.rst:1433
msgid ""
"A :class:`tuple` containing the names of :ref:`local variables <naming>` "
"that are referenced from at least one :term:`nested scope` inside the "
"function"
msgstr ""
"Uma :class:`tuple` contendo os nomes das :ref:`variáveis locais <naming>` "
"que são referenciadas a partir de pelo menos um :term:`âmbitos aninhados` "
"dentro da função"

#: ../../reference/datamodel.rst:1437
msgid ""
"A :class:`tuple` containing the names of :term:`free (closure) variables "
"<closure variable>` that a :term:`nested scope` references in an outer "
"scope. See also :attr:`function.__closure__`."
msgstr ""
"Uma :class:`tuple` contendo os nomes das :term:`variáveis livres (closure) "
"<closure variable>` que um :term:`âmbitos aninhados` referencia num âmbito "
"exterior. Veja também :attr:`function.__closure__`."

#: ../../reference/datamodel.rst:1441
msgid "Note: references to global and builtin names are *not* included."
msgstr ""
"Nota: as referências a nomes globais e integrados *não* estão incluídas."

#: ../../reference/datamodel.rst:1444
msgid ""
"A string representing the sequence of :term:`bytecode` instructions in the "
"function"
msgstr ""
"Uma string que representa a sequência de instruções :term:`bytecode` na "
"função"

#: ../../reference/datamodel.rst:1448
msgid ""
"A :class:`tuple` containing the literals used by the :term:`bytecode` in the "
"function"
msgstr ""
"Uma :class:`tuple` contendo os literais usados pelo :term:`bytecode` na "
"função"

#: ../../reference/datamodel.rst:1452
msgid ""
"A :class:`tuple` containing the names used by the :term:`bytecode` in the "
"function"
msgstr ""
"Uma :class:`tuple` contendo os nomes usados pelo :term:`bytecode` na função"

#: ../../reference/datamodel.rst:1456
msgid "The name of the file from which the code was compiled"
msgstr "O nome do ficheiro a partir do qual o código foi compilado"

#: ../../reference/datamodel.rst:1459
msgid "The line number of the first line of the function"
msgstr "O número da linha da primeira linha da função"

#: ../../reference/datamodel.rst:1462
msgid ""
"A string encoding the mapping from :term:`bytecode` offsets to line numbers. "
"For details, see the source code of the interpreter."
msgstr ""
"Uma string que codifica o mapeamento dos deslocamentos de :term:`bytecode` "
"para números de linha. Para mais detalhes, consulte o código-fonte do "
"interpretador."

#: ../../reference/datamodel.rst:1465
msgid ""
"This attribute of code objects is deprecated, and may be removed in Python "
"3.15."
msgstr ""
"Este atributo de objetos de código está obsoleto e pode ser removido no "
"Python 3.15."

#: ../../reference/datamodel.rst:1470
msgid "The required stack size of the code object"
msgstr "O tamanho de pilha necessário do objeto de código"

#: ../../reference/datamodel.rst:1473
msgid ""
"An :class:`integer <int>` encoding a number of flags for the interpreter."
msgstr ""
"Um :class:`inteiro <int>` que codifica um número de flags para o "
"interpretador."

#: ../../reference/datamodel.rst:1478
msgid ""
"The following flag bits are defined for :attr:`~codeobject.co_flags`: bit "
"``0x04`` is set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator. See :ref:"
"`inspect-module-co-flags` for details on the semantics of each flags that "
"might be present."
msgstr ""
"Os seguintes bits de flag estão definidos para :attr:`~codeobject.co_flags`: "
"o bit ``0x04`` está definido se a função usar a sintaxe ``*arguments`` para "
"aceitar um número arbitrário de argumentos posicionais; o bit ``0x08`` está "
"definido se a função usar a sintaxe ``**keywords`` para aceitar argumentos "
"nomeados arbitrários; o bit ``0x20`` está definido se a função for um "
"gerador. Consulte :ref:`inspect-module-co-flags` para detalhes sobre a "
"semântica de cada flag que pode estar presente."

#: ../../reference/datamodel.rst:1486
msgid ""
"Future feature declarations (for example, ``from __future__ import "
"division``) also use bits in :attr:`~codeobject.co_flags` to indicate "
"whether a code object was compiled with a particular feature enabled. See :"
"attr:`~__future__._Feature.compiler_flag`."
msgstr ""
"As declarações de funcionalidades futuras (por exemplo, ``from __future__ "
"import division``) também usam bits em :attr:`~codeobject.co_flags` para "
"indicar se um objeto de código foi compilado com uma funcionalidade "
"específica ativada. Veja :attr:`~__future__._Feature.compiler_flag`."

#: ../../reference/datamodel.rst:1490
msgid ""
"Other bits in :attr:`~codeobject.co_flags` are reserved for internal use."
msgstr ""
"Outros bits em :attr:`~codeobject.co_flags` estão reservados para uso "
"interno."

#: ../../reference/datamodel.rst:1494
msgid ""
"If a code object represents a function, the first item in :attr:`~codeobject."
"co_consts` is the documentation string of the function, or ``None`` if "
"undefined."
msgstr ""

#: ../../reference/datamodel.rst:1499
msgid "Methods on code objects"
msgstr "Métodos em objetos de código"

#: ../../reference/datamodel.rst:1503
msgid ""
"Returns an iterable over the source code positions of each :term:`bytecode` "
"instruction in the code object."
msgstr ""
"Retorna um iterável sobre as posições do código-fonte de cada instrução :"
"term:`bytecode` no objeto de código."

#: ../../reference/datamodel.rst:1506
msgid ""
"The iterator returns :class:`tuple`\\s containing the ``(start_line, "
"end_line, start_column, end_column)``. The *i-th* tuple corresponds to the "
"position of the source code that compiled to the *i-th* code unit. Column "
"information is 0-indexed utf-8 byte offsets on the given source line."
msgstr ""
"O iterador retorna :class:`tuple` contendo ``(start_line, end_line, "
"start_column, end_column)``. A *i-ésima* tupla corresponde à posição do "
"código-fonte que foi compilado para a *i-ésima* unidade de código. A "
"informação de coluna é um deslocamento de bytes UTF-8 indexado a 0 na linha "
"de origem dada."

#: ../../reference/datamodel.rst:1512
msgid ""
"This positional information can be missing. A non-exhaustive lists of cases "
"where this may happen:"
msgstr ""
"Esta informação posicional pode estar em falta. Uma lista não exaustiva de "
"casos em que isto pode acontecer:"

#: ../../reference/datamodel.rst:1515
msgid "Running the interpreter with :option:`-X` ``no_debug_ranges``."
msgstr "Executar o interpretador com :option:`-X` ``no_debug_ranges``."

#: ../../reference/datamodel.rst:1516
msgid ""
"Loading a pyc file compiled while using :option:`-X` ``no_debug_ranges``."
msgstr ""
"Carregar um ficheiro pyc compilado enquanto se usava :option:`-X` "
"``no_debug_ranges``."

#: ../../reference/datamodel.rst:1517
msgid "Position tuples corresponding to artificial instructions."
msgstr "Tuplas de posição correspondentes a instruções artificiais."

#: ../../reference/datamodel.rst:1518
msgid ""
"Line and column numbers that can't be represented due to implementation "
"specific limitations."
msgstr ""
"Números de linha e coluna que não podem ser representados devido a "
"limitações específicas da implementação."

#: ../../reference/datamodel.rst:1521
msgid ""
"When this occurs, some or all of the tuple elements can be :const:`None`."
msgstr ""
"Quando isto ocorre, alguns ou todos os elementos da tupla podem ser :const:"
"`None`."

#: ../../reference/datamodel.rst:1527
msgid ""
"This feature requires storing column positions in code objects which may "
"result in a small increase of disk usage of compiled Python files or "
"interpreter memory usage. To avoid storing the extra information and/or "
"deactivate printing the extra traceback information, the :option:`-X` "
"``no_debug_ranges`` command line flag or the :envvar:`PYTHONNODEBUGRANGES` "
"environment variable can be used."
msgstr ""
"Esta funcionalidade requer armazenar posições de coluna em objetos de "
"código, o que pode resultar num pequeno aumento do uso de disco de ficheiros "
"Python compilados ou da memória do interpretador. Para evitar armazenar a "
"informação extra e/ou desativar a impressão da informação extra de "
"traceback, pode ser usada a flag de linha de comando :option:`-X` "
"``no_debug_ranges`` ou a variável de ambiente :envvar:`PYTHONNODEBUGRANGES`."

#: ../../reference/datamodel.rst:1536
msgid ""
"Returns an iterator that yields information about successive ranges of :term:"
"`bytecode`\\s. Each item yielded is a ``(start, end, lineno)`` :class:"
"`tuple`:"
msgstr ""
"Retorna um iterador que fornece informações sobre intervalos sucessivos de :"
"term:`bytecode`. Cada item fornecido é uma :class:`tuple` ``(start, end, "
"lineno)``:"

#: ../../reference/datamodel.rst:1540
msgid ""
"``start`` (an :class:`int`) represents the offset (inclusive) of the start "
"of the :term:`bytecode` range"
msgstr ""
"``start`` (um :class:`int`) representa o deslocamento (inclusivo) do início "
"do intervalo de :term:`bytecode`"

#: ../../reference/datamodel.rst:1542
msgid ""
"``end`` (an :class:`int`) represents the offset (exclusive) of the end of "
"the :term:`bytecode` range"
msgstr ""
"``end`` (um :class:`int`) representa o deslocamento (exclusivo) do fim do "
"intervalo de :term:`bytecode`"

#: ../../reference/datamodel.rst:1544
msgid ""
"``lineno`` is an :class:`int` representing the line number of the :term:"
"`bytecode` range, or ``None`` if the bytecodes in the given range have no "
"line number"
msgstr ""
"``lineno`` é um :class:`int` que representa o número da linha do intervalo "
"de :term:`bytecode`, ou ``None`` se os bytecodes no intervalo dado não "
"tiverem número de linha"

#: ../../reference/datamodel.rst:1548
msgid "The items yielded will have the following properties:"
msgstr "Os itens fornecidos terão as seguintes propriedades:"

#: ../../reference/datamodel.rst:1550
msgid "The first range yielded will have a ``start`` of 0."
msgstr "O primeiro intervalo fornecido terá um ``start`` de 0."

#: ../../reference/datamodel.rst:1551
msgid ""
"The ``(start, end)`` ranges will be non-decreasing and consecutive. That is, "
"for any pair of :class:`tuple`\\s, the ``start`` of the second will be equal "
"to the ``end`` of the first."
msgstr ""
"Os intervalos ``(start, end)`` serão não decrescentes e consecutivos. Isto "
"é, para qualquer par de :class:`tuple`, o ``start`` da segunda será igual ao "
"``end`` da primeira."

#: ../../reference/datamodel.rst:1554
msgid "No range will be backwards: ``end >= start`` for all triples."
msgstr ""
"Nenhum intervalo será invertido: ``end >= start`` para todas as triplas."

#: ../../reference/datamodel.rst:1555
msgid ""
"The last :class:`tuple` yielded will have ``end`` equal to the size of the :"
"term:`bytecode`."
msgstr ""
"A última :class:`tuple` fornecida terá ``end`` igual ao tamanho do :term:"
"`bytecode`."

#: ../../reference/datamodel.rst:1558
msgid ""
"Zero-width ranges, where ``start == end``, are allowed. Zero-width ranges "
"are used for lines that are present in the source code, but have been "
"eliminated by the :term:`bytecode` compiler."
msgstr ""
"Intervalos de largura zero, onde ``start == end``, são permitidos. "
"Intervalos de largura zero são usados para linhas que estão presentes no "
"código-fonte, mas que foram eliminadas pelo compilador de :term:`bytecode`."

#: ../../reference/datamodel.rst:1566
msgid ":pep:`626` - Precise line numbers for debugging and other tools."
msgstr ""
":pep:`626` - Números de linha precisos para depuração e outras ferramentas."

#: ../../reference/datamodel.rst:1567
msgid "The PEP that introduced the :meth:`!co_lines` method."
msgstr "O PEP que introduziu o método :meth:`!co_lines`."

#: ../../reference/datamodel.rst:1571
msgid ""
"Return a copy of the code object with new values for the specified fields."
msgstr ""
"Retorna uma cópia do objeto de código com novos valores para os campos "
"especificados."

#: ../../reference/datamodel.rst:1573
msgid ""
"Code objects are also supported by the generic function :func:`copy.replace`."
msgstr ""
"Os objetos de código também são suportados pela função genérica :func:`copy."
"replace`."

#: ../../reference/datamodel.rst:1581
msgid "Frame objects"
msgstr "Objetos de quadro"

#: ../../reference/datamodel.rst:1585
msgid ""
"Frame objects represent execution frames.  They may occur in :ref:`traceback "
"objects <traceback-objects>`, and are also passed to registered trace "
"functions."
msgstr ""
"Os objetos de quadro representam quadros de execução. Podem ocorrer em "
"objetos :ref:`traceback <traceback-objects>`, e também são passados para "
"funções de rastreio registadas."

#: ../../reference/datamodel.rst:1603
msgid ""
"Points to the previous stack frame (towards the caller), or ``None`` if this "
"is the bottom stack frame"
msgstr ""
"Aponta para o quadro de pilha anterior (em direção ao chamador), ou ``None`` "
"se este for o quadro de pilha inferior"

#: ../../reference/datamodel.rst:1607
msgid ""
"The :ref:`code object <code-objects>` being executed in this frame. "
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"f_code\"``."
msgstr ""
"O :ref:`objeto de código <code-objects>` que está a ser executado neste "
"quadro. Aceder a este atributo levanta um :ref:`evento de auditoria "
"<auditing>` ``object.__getattr__`` com os argumentos ``obj`` e "
"``\"f_code\"``."

#: ../../reference/datamodel.rst:1612
msgid ""
"The mapping used by the frame to look up :ref:`local variables <naming>`. If "
"the frame refers to an :term:`optimized scope`, this may return a write-"
"through proxy object."
msgstr ""
"O mapeamento usado pelo quadro para procurar :ref:`variáveis locais "
"<naming>`. Se o quadro se referir a um :term:`âmbitos otimizado`, isto pode "
"retornar um objeto proxy de escrita."

#: ../../reference/datamodel.rst:1617
msgid "Return a proxy for optimized scopes."
msgstr "Retorna um proxy para âmbitos otimizados."

#: ../../reference/datamodel.rst:1621
msgid ""
"The dictionary used by the frame to look up :ref:`global variables <naming>`"
msgstr ""
"O dicionário usado pelo quadro para procurar :ref:`variáveis globais "
"<naming>`"

#: ../../reference/datamodel.rst:1625
msgid ""
"The dictionary used by the frame to look up :ref:`built-in (intrinsic) names "
"<naming>`"
msgstr ""
"O dicionário usado pelo quadro para procurar :ref:`nomes integrados "
"(intrínsecos) <naming>`"

#: ../../reference/datamodel.rst:1629
msgid ""
"The \"precise instruction\" of the frame object (this is an index into the :"
"term:`bytecode` string of the :ref:`code object <code-objects>`)"
msgstr ""
"A \"instrução precisa\" do objeto de quadro (este é um índice na string de :"
"term:`bytecode` do :ref:`objeto de código <code-objects>`)"

#: ../../reference/datamodel.rst:1645
msgid ""
"If not ``None``, this is a function called for various events during code "
"execution (this is used by debuggers). Normally an event is triggered for "
"each new source line (see :attr:`~frame.f_trace_lines`)."
msgstr ""
"Se não for ``None``, esta é uma função chamada para vários eventos durante a "
"execução do código (isto é usado por depuradores). Normalmente, um evento é "
"disparado para cada nova linha de origem (consulte :attr:`~frame."
"f_trace_lines`)."

#: ../../reference/datamodel.rst:1650
msgid ""
"Set this attribute to :const:`False` to disable triggering a tracing event "
"for each source line."
msgstr ""
"Defina este atributo para :const:`False` para desativar o disparo de um "
"evento de rastreio para cada linha de origem."

#: ../../reference/datamodel.rst:1654
msgid ""
"Set this attribute to :const:`True` to allow per-opcode events to be "
"requested. Note that this may lead to undefined interpreter behaviour if "
"exceptions raised by the trace function escape to the function being traced."
msgstr ""
"Defina este atributo para :const:`True` para permitir que eventos por opcode "
"sejam solicitados. Note que isto pode levar a um comportamento indefinido do "
"interpretador se exceções levantadas pela função de rastreio escaparem para "
"a função que está a ser rastreada."

#: ../../reference/datamodel.rst:1660
msgid ""
"The current line number of the frame -- writing to this from within a trace "
"function jumps to the given line (only for the bottom-most frame).  A "
"debugger can implement a Jump command (aka Set Next Statement) by writing to "
"this attribute."
msgstr ""
"O número da linha atual do quadro — escrever neste atributo a partir de uma "
"função de rastreio salta para a linha dada (apenas para o quadro mais "
"inferior). Um depurador pode implementar um comando Jump (também conhecido "
"como Definir Próxima Instrução) escrevendo neste atributo."

#: ../../reference/datamodel.rst:1666
msgid "Frame object methods"
msgstr "Métodos de objetos de quadro"

#: ../../reference/datamodel.rst:1668
msgid "Frame objects support one method:"
msgstr "Os objetos de quadro suportam um método:"

#: ../../reference/datamodel.rst:1672
msgid ""
"This method clears all references to :ref:`local variables <naming>` held by "
"the frame.  Also, if the frame belonged to a :term:`generator`, the "
"generator is finalized.  This helps break reference cycles involving frame "
"objects (for example when catching an :ref:`exception <bltin-exceptions>` "
"and storing its :ref:`traceback <traceback-objects>` for later use)."
msgstr ""
"Este método limpa todas as referências a :ref:`variáveis locais <naming>` "
"mantidas pelo quadro. Além disso, se o quadro pertencer a um :term:"
"`gerador`, o gerador é finalizado. Isto ajuda a quebrar ciclos de referência "
"envolvendo objetos de quadro (por exemplo, ao capturar uma :ref:`exceção "
"<bltin-exceptions>` e armazenar o seu :ref:`traceback <traceback-objects>` "
"para uso posterior)."

#: ../../reference/datamodel.rst:1678
msgid ""
":exc:`RuntimeError` is raised if the frame is currently executing or "
"suspended."
msgstr ""
"É levantada uma exceção :exc:`RuntimeError` se o quadro estiver atualmente "
"em execução ou suspenso."

#: ../../reference/datamodel.rst:1683
msgid ""
"Attempting to clear a suspended frame raises :exc:`RuntimeError` (as has "
"always been the case for executing frames)."
msgstr ""
"Tentar limpar um quadro suspenso levanta :exc:`RuntimeError` (como sempre "
"foi o caso para quadros em execução)."

#: ../../reference/datamodel.rst:1691
msgid "Traceback objects"
msgstr "Objetos de traceback"

#: ../../reference/datamodel.rst:1704
msgid ""
"Traceback objects represent the stack trace of an :ref:`exception <tut-"
"errors>`. A traceback object is implicitly created when an exception occurs, "
"and may also be explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"Os objetos de traceback representam o rastreio de pilha de uma :ref:`exceção "
"<tut-errors>`. Um objeto de traceback é criado implicitamente quando ocorre "
"uma exceção e também pode ser criado explicitamente chamando :class:`types."
"TracebackType`."

#: ../../reference/datamodel.rst:1709
msgid "Traceback objects can now be explicitly instantiated from Python code."
msgstr ""
"Os objetos de traceback agora podem ser instanciados explicitamente a partir "
"de código Python."

#: ../../reference/datamodel.rst:1712
msgid ""
"For implicitly created tracebacks, when the search for an exception handler "
"unwinds the execution stack, at each unwound level a traceback object is "
"inserted in front of the current traceback.  When an exception handler is "
"entered, the stack trace is made available to the program. (See section :ref:"
"`try`.) It is accessible as the third item of the tuple returned by :func:"
"`sys.exc_info`, and as the :attr:`~BaseException.__traceback__` attribute of "
"the caught exception."
msgstr ""
"Para tracebacks criados implicitamente, quando a pesquisa de um manipulador "
"de exceção desempilha a pilha de execução, em cada nível desempilhado, um "
"objeto de traceback é inserido à frente do traceback atual. Quando um "
"manipulador de exceção é acionado, o rastreio de pilha é disponibilizado "
"para o programa. (Consulte a secção :ref:`try`.) É acessível como o terceiro "
"item da tupla retornada por :func:`sys.exc_info`, e como o atributo :attr:"
"`~BaseException.__traceback__` da exceção capturada."

#: ../../reference/datamodel.rst:1721
msgid ""
"When the program contains no suitable handler, the stack trace is written "
"(nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as :data:`sys."
"last_traceback`."
msgstr ""
"Quando o programa não contém um manipulador adequado, o rastreio de pilha é "
"escrito (bem formatado) para o fluxo de erro padrão; se o interpretador for "
"interativo, também é disponibilizado ao utilizador como :data:`sys."
"last_traceback`."

#: ../../reference/datamodel.rst:1726
msgid ""
"For explicitly created tracebacks, it is up to the creator of the traceback "
"to determine how the :attr:`~traceback.tb_next` attributes should be linked "
"to form a full stack trace."
msgstr ""
"Para tracebacks criados explicitamente, cabe ao criador do traceback "
"determinar como os atributos :attr:`~traceback.tb_next` devem ser ligados "
"para formar um rastreio de pilha completo."

#: ../../reference/datamodel.rst:1741
msgid ""
"Points to the execution :ref:`frame <frame-objects>` of the current level."
msgstr ""
"Aponta para o :ref:`quadro <frame-objects>` de execução do nível atual."

#: ../../reference/datamodel.rst:1744
msgid ""
"Accessing this attribute raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"tb_frame\"``."
msgstr ""
"Aceder a este atributo levanta um :ref:`evento de auditoria <auditing>` "
"``object.__getattr__`` com os argumentos ``obj`` e ``\"tb_frame\"``."

#: ../../reference/datamodel.rst:1749
msgid "Gives the line number where the exception occurred"
msgstr "Indica o número da linha onde a exceção ocorreu"

#: ../../reference/datamodel.rst:1752
msgid "Indicates the \"precise instruction\"."
msgstr "Indica a \"instrução precisa\"."

#: ../../reference/datamodel.rst:1754
msgid ""
"The line number and last instruction in the traceback may differ from the "
"line number of its :ref:`frame object <frame-objects>` if the exception "
"occurred in a :keyword:`try` statement with no matching except clause or "
"with a :keyword:`finally` clause."
msgstr ""
"O número da linha e a última instrução no traceback podem diferir do número "
"da linha do seu :ref:`objeto de quadro <frame-objects>` se a exceção ocorreu "
"numa instrução :keyword:`try` sem uma cláusula except correspondente ou com "
"uma cláusula :keyword:`finally`."

#: ../../reference/datamodel.rst:1765
msgid ""
"The special writable attribute :attr:`!tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None`` if "
"there is no next level."
msgstr ""
"O atributo gravável especial :attr:`!tb_next` é o próximo nível no rastreio "
"de pilha (em direção ao quadro onde a exceção ocorreu), ou ``None`` se não "
"houver um próximo nível."

#: ../../reference/datamodel.rst:1769
msgid "This attribute is now writable"
msgstr "Este atributo agora é gravável"

#: ../../reference/datamodel.rst:1774
msgid "Slice objects"
msgstr "Objetos de fatia"

#: ../../reference/datamodel.rst:1778
msgid ""
"Slice objects are used to represent slices for :meth:`~object.__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"Os objetos de fatia são usados para representar fatias para os métodos :meth:"
"`~object.__getitem__`. Também são criados pela função integrada :func:"
"`slice`."

#: ../../reference/datamodel.rst:1787
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"Atributos especiais somente leitura: :attr:`~slice.start` é o limite "
"inferior; :attr:`~slice.stop` é o limite superior; :attr:`~slice.step` é o "
"valor do passo; cada um é ``None`` se omitido. Estes atributos podem ter "
"qualquer tipo."

#: ../../reference/datamodel.rst:1791
msgid "Slice objects support one method:"
msgstr "Os objetos de fatia suportam um método:"

#: ../../reference/datamodel.rst:1795
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""
"Este método recebe um único argumento inteiro *length* e calcula informações "
"sobre a fatia que o objeto de fatia descreveria se aplicado a uma sequência "
"de *length* itens. Retorna uma tupla de três inteiros; respetivamente, estes "
"são os índices *start* e *stop* e o comprimento do *step* ou passo da fatia. "
"Índices em falta ou fora dos limites são tratados de uma forma consistente "
"com fatias regulares."

#: ../../reference/datamodel.rst:1804
msgid "Static method objects"
msgstr "Objetos de método estático"

#: ../../reference/datamodel.rst:1806
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are also callable. Static "
"method objects are created by the built-in :func:`staticmethod` constructor."
msgstr ""
"Os objetos de método estático fornecem uma forma de evitar a transformação "
"de objetos de função em objetos de método descrita acima. Um objeto de "
"método estático é um invólucro em torno de qualquer outro objeto, geralmente "
"um objeto de método definido pelo utilizador. Quando um objeto de método "
"estático é recuperado de uma classe ou de uma instância de classe, o objeto "
"realmente retornado é o objeto envolvido, que não está sujeito a qualquer "
"transformação adicional. Os objetos de método estático também são chamáveis. "
"Os objetos de método estático são criados pelo construtor integrado :func:"
"`staticmethod`."

#: ../../reference/datamodel.rst:1816
msgid "Class method objects"
msgstr "Objetos de método de classe"

#: ../../reference/datamodel.rst:1818
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under :ref:`\"instance methods\" <instance-"
"methods>`. Class method objects are created by the built-in :func:"
"`classmethod` constructor."
msgstr ""
"Um objeto de método de classe, tal como um objeto de método estático, é um "
"invólucro em torno de outro objeto que altera a forma como esse objeto é "
"recuperado de classes e instâncias de classe. O comportamento dos objetos de "
"método de classe após essa recuperação é descrito acima, em :ref:`\"métodos "
"de instância\" <instance-methods>`. Os objetos de método de classe são "
"criados pelo construtor integrado :func:`classmethod`."

#: ../../reference/datamodel.rst:1828
msgid "Special method names"
msgstr "Nomes de métodos especiais"

#: ../../reference/datamodel.rst:1834
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`~object.__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` "
"is roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""
"Uma classe pode implementar certas operações que são invocadas por sintaxe "
"especial (como operações aritméticas ou indexação e fatiamento) definindo "
"métodos com nomes especiais. Esta é a abordagem do Python para :dfn:"
"`sobrecarga de operadores`, permitindo que as classes definam o seu próprio "
"comportamento em relação aos operadores da linguagem. Por exemplo, se uma "
"classe definir um método chamado :meth:`~object.__getitem__`, e ``x`` for "
"uma instância dessa classe, então ``x[i]`` é aproximadamente equivalente a "
"``type(x).__getitem__(x, i)``. Exceto onde mencionado, as tentativas de "
"executar uma operação levantam uma exceção quando nenhum método apropriado "
"está definido (tipicamente :exc:`AttributeError` ou :exc:`TypeError`)."

#: ../../reference/datamodel.rst:1845
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets :meth:`~object."
"__iter__` to ``None``, the class is not iterable, so calling :func:`iter` on "
"its instances will raise a :exc:`TypeError` (without falling back to :meth:"
"`~object.__getitem__`). [#]_"
msgstr ""
"Definir um método especial para ``None`` indica que a operação "
"correspondente não está disponível. Por exemplo, se uma classe definir :meth:"
"`~object.__iter__` para ``None``, a classe não é iterável, então chamar :"
"func:`iter` nas suas instâncias levantará uma :exc:`TypeError` (sem recuar "
"para :meth:`~object.__getitem__`). [#]_"

#: ../../reference/datamodel.rst:1851
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""

#: ../../reference/datamodel.rst:1862
msgid "Basic customization"
msgstr "Personalização básica"

#: ../../reference/datamodel.rst:1868
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""
"Chamado para criar uma nova instância da classe *cls*. :meth:`__new__` é um "
"método estático (com um caso especial, por isso não é necessário declará-lo "
"como tal) que recebe a classe da qual uma instância foi solicitada como seu "
"primeiro argumento. Os argumentos restantes são aqueles passados para a "
"expressão do construtor do objeto (a chamada à classe). O valor de retorno "
"de :meth:`__new__` deve ser a nova instância do objeto (geralmente uma "
"instância de *cls*)."

#: ../../reference/datamodel.rst:1875
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super().__new__(cls[, ...])`` "
"with appropriate arguments and then modifying the newly created instance as "
"necessary before returning it."
msgstr ""
"As implementações típicas criam uma nova instância da classe invocando o "
"método :meth:`__new__` da superclasse usando ``super().__new__(cls[, ...])`` "
"com os argumentos apropriados e, em seguida, modificam a instância recém-"
"criada, se necessário, antes de a retornar."

#: ../../reference/datamodel.rst:1880
msgid ""
"If :meth:`__new__` is invoked during object construction and it returns an "
"instance of *cls*, then the new instance’s :meth:`__init__` method will be "
"invoked like ``__init__(self[, ...])``, where *self* is the new instance and "
"the remaining arguments are the same as were passed to the object "
"constructor."
msgstr ""
"Se :meth:`__new__` for invocado durante a construção do objeto e retornar "
"uma instância de *cls*, então o método :meth:`__init__` da nova instância "
"será invocado como ``__init__(self[, ...])``, onde *self* é a nova instância "
"e os argumentos restantes são os mesmos que foram passados ao construtor do "
"objeto."

#: ../../reference/datamodel.rst:1885
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"Se :meth:`__new__` não retornar uma instância de *cls*, então o método :meth:"
"`__init__` da nova instância não será invocado."

#: ../../reference/datamodel.rst:1888
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` é destinado principalmente a permitir que subclasses de "
"tipos imutáveis (como int, str ou tuple) personalizem a criação de "
"instâncias. Também é comumente substituído em metaclasses personalizadas "
"para personalizar a criação de classes."

#: ../../reference/datamodel.rst:1897
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``super().__init__([args...])``."
msgstr ""
"Chamado após a instância ter sido criada (por :meth:`__new__`), mas antes de "
"ser retornada ao chamador. Os argumentos são aqueles passados para a "
"expressão do construtor da classe. Se uma classe base tiver um método :meth:"
"`__init__`, o método :meth:`__init__` da classe derivada, se existir, deve "
"chamá-lo explicitamente para garantir a inicialização adequada da parte da "
"classe base da instância; por exemplo: ``super().__init__([args...])``."

#: ../../reference/datamodel.rst:1904
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customize "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""
"Porque :meth:`__new__` e :meth:`__init__` trabalham em conjunto na "
"construção de objetos (:meth:`__new__` para criá-lo e :meth:`__init__` para "
"personalizá-lo), nenhum valor diferente de ``None`` pode ser retornado por :"
"meth:`__init__`; fazê-lo causará uma :exc:`TypeError` a ser levantada em "
"tempo de execução."

#: ../../reference/datamodel.rst:1917
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"finalizer or (improperly) a destructor.  If a base class has a :meth:"
"`__del__` method, the derived class's :meth:`__del__` method, if any, must "
"explicitly call it to ensure proper deletion of the base class part of the "
"instance."
msgstr ""
"Chamado quando a instância está prestes a ser destruída. Isto também é "
"chamado de finalizador ou (impropriamente) de destrutor. Se uma classe base "
"tiver um método :meth:`__del__`, o método :meth:`__del__` da classe "
"derivada, se existir, deve chamá-lo explicitamente para garantir a "
"eliminação adequada da parte da classe base da instância."

#: ../../reference/datamodel.rst:1923
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  "
"This is called object *resurrection*.  It is implementation-dependent "
"whether :meth:`__del__` is called a second time when a resurrected object is "
"about to be destroyed; the current :term:`CPython` implementation only calls "
"it once."
msgstr ""
"É possível (embora não recomendado!) que o método :meth:`__del__` adie a "
"destruição da instância criando uma nova referência a ela. Isto é chamado de "
"*ressurreição* de objeto. É dependente da implementação se :meth:`__del__` é "
"chamado uma segunda vez quando um objeto ressuscitado está prestes a ser "
"destruído; a implementação atual do :term:`CPython` chama-o apenas uma vez."

#: ../../reference/datamodel.rst:1930
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits. :class:`weakref.finalize` "
"provides a straightforward way to register a cleanup function to be called "
"when an object is garbage collected."
msgstr ""
"Não é garantido que os métodos :meth:`__del__` sejam chamados para objetos "
"que ainda existam quando o interpretador termina. :class:`weakref.finalize` "
"fornece uma forma direta de registar uma função de limpeza para ser chamada "
"quando um objeto é recolhido pelo garbage collector."

#: ../../reference/datamodel.rst:1937
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero."
msgstr ""
"``del x`` não chama diretamente ``x.__del__()`` — o primeiro decrementa a "
"contagem de referências para ``x`` em um, e o último é chamado apenas quando "
"a contagem de referências de ``x`` atinge zero."

#: ../../reference/datamodel.rst:1942
msgid ""
"It is possible for a reference cycle to prevent the reference count of an "
"object from going to zero.  In this case, the cycle will be later detected "
"and deleted by the :term:`cyclic garbage collector <garbage collection>`.  A "
"common cause of reference cycles is when an exception has been caught in a "
"local variable.  The frame's locals then reference the exception, which "
"references its own traceback, which references the locals of all frames "
"caught in the traceback."
msgstr ""
"É possível que um ciclo de referência impeça que a contagem de referências "
"de um objeto chegue a zero. Neste caso, o ciclo será detetado e eliminado "
"mais tarde pelo :term:`garbage collector cíclico <garbage collection>`. Uma "
"causa comum de ciclos de referência é quando uma exceção foi capturada numa "
"variável local. Os locais do quadro referenciam então a exceção, que "
"referencia o seu próprio traceback, que referencia os locais de todos os "
"quadros capturados no traceback."

#: ../../reference/datamodel.rst:1952
msgid "Documentation for the :mod:`gc` module."
msgstr "Documentação para o módulo :mod:`gc`."

#: ../../reference/datamodel.rst:1956
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
"Devido às circunstâncias precárias sob as quais os métodos :meth:`__del__` "
"são invocados, as exceções que ocorrem durante a sua execução são ignoradas, "
"e um aviso é impresso em ``sys.stderr`` em vez disso. Em particular:"

#: ../../reference/datamodel.rst:1960
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the resource "
"may already be taken by the code that gets interrupted to execute :meth:"
"`__del__`."
msgstr ""
":meth:`__del__` pode ser invocado quando qualquer código está a ser "
"executado, incluindo a partir de qualquer thread arbitrário. Se :meth:"
"`__del__` precisar de obter um bloqueio ou invocar qualquer outro recurso "
"bloqueante, pode causar um impasse, pois o recurso pode já estar a ser usado "
"pelo código que é interrompido para executar :meth:`__del__`."

#: ../../reference/datamodel.rst:1966
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python guarantees "
"that globals whose name begins with a single underscore are deleted from "
"their module before other globals are deleted; if no other references to "
"such globals exist, this may help in assuring that imported modules are "
"still available at the time when the :meth:`__del__` method is called."
msgstr ""
":meth:`__del__` pode ser executado durante o encerramento do interpretador. "
"Como consequência, as variáveis globais que precisa de aceder (incluindo "
"outros módulos) podem já ter sido eliminadas ou definidas para ``None``. O "
"Python garante que os globais cujos nomes começam com um sublinhado único "
"são eliminados do seu módulo antes de outros globais serem eliminados; se "
"não existirem outras referências a tais globais, isto pode ajudar a garantir "
"que os módulos importados ainda estão disponíveis no momento em que o "
"método :meth:`__del__` é chamado."

#: ../../reference/datamodel.rst:1981
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""
"Chamado pela função integrada :func:`repr` para calcular a representação de "
"string \"oficial\" de um objeto. Sempre que possível, isto deve parecer uma "
"expressão Python válida que poderia ser usada para recriar um objeto com o "
"mesmo valor (dado um ambiente apropriado). Se isto não for possível, deve "
"ser retornada uma string da forma ``<...some useful description...>``. O "
"valor de retorno deve ser um objeto string. Se uma classe definir :meth:"
"`__repr__` mas não :meth:`__str__`, então :meth:`__repr__` também é usado "
"quando uma representação de string \"informal\" de instâncias dessa classe é "
"necessária."

#: ../../reference/datamodel.rst:1990
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous. A default implementation "
"is provided by the :class:`object` class itself."
msgstr ""
"Isto é tipicamente usado para depuração, por isso é importante que a "
"representação seja rica em informações e inequívoca. Uma implementação "
"predefinida é fornecida pela própria classe :class:`object`."

#: ../../reference/datamodel.rst:2002
msgid ""
"Called by :func:`str(object) <str>`, the default :meth:`__format__` "
"implementation, and the built-in function :func:`print`, to compute the "
"\"informal\" or nicely printable string representation of an object.  The "
"return value must be a :ref:`str <textseq>` object."
msgstr ""
"Chamado por :func:`str(object) <str>`, a implementação predefinida de :meth:"
"`__format__` e a função integrada :func:`print`, para calcular a "
"representação de string \"informal\" ou bem imprimível de um objeto. O valor "
"de retorno deve ser um objeto :ref:`str <textseq>`."

#: ../../reference/datamodel.rst:2007
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""
"Este método difere de :meth:`object.__repr__` no sentido em que não há a "
"expectativa de que :meth:`__str__` retorne uma expressão Python válida: pode "
"ser usada uma representação mais conveniente ou concisa."

#: ../../reference/datamodel.rst:2011
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""
"A implementação predefinida definida pelo tipo integrado :class:`object` "
"chama :meth:`object.__repr__`."

#: ../../reference/datamodel.rst:2021
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string representation "
"of an object. This should return a :class:`bytes` object. The :class:"
"`object` class itself does not provide this method."
msgstr ""
"Chamado por :ref:`bytes <func-bytes>` para calcular uma representação de "
"string de bytes de um objeto. Isto deve retornar um objeto :class:`bytes`. A "
"própria classe :class:`object` não fornece este método."

#: ../../reference/datamodel.rst:2033
msgid ""
"Called by the :func:`format` built-in function, and by extension, evaluation "
"of :ref:`formatted string literals <f-strings>` and the :meth:`str.format` "
"method, to produce a \"formatted\" string representation of an object. The "
"*format_spec* argument is a string that contains a description of the "
"formatting options desired. The interpretation of the *format_spec* argument "
"is up to the type implementing :meth:`__format__`, however most classes will "
"either delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
"Chamado pela função integrada :func:`format` e, por extensão, pela avaliação "
"de :ref:`literais de string formatadas <f-strings>` e pelo método :meth:`str."
"format`, para produzir uma representação de string \"formatada\" de um "
"objeto. O argumento *format_spec* é uma string que contém uma descrição das "
"opções de formatação desejadas. A interpretação do argumento *format_spec* é "
"da responsabilidade do tipo que implementa :meth:`__format__`, no entanto, a "
"maioria das classes delegará a formatação a um dos tipos integrados ou usará "
"uma sintaxe de opção de formatação semelhante."

#: ../../reference/datamodel.rst:2043
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""
"Consulte :ref:`formatspec` para uma descrição da sintaxe de formatação "
"padrão."

#: ../../reference/datamodel.rst:2045
msgid "The return value must be a string object."
msgstr "O valor de retorno deve ser um objeto string."

#: ../../reference/datamodel.rst:2047
msgid ""
"The default implementation by the :class:`object` class should be given an "
"empty *format_spec* string. It delegates to :meth:`__str__`."
msgstr ""
"A implementação predefinida pela classe :class:`object` deve ser dada uma "
"string *format_spec* vazia. Ela delega para :meth:`__str__`."

#: ../../reference/datamodel.rst:2050
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"O método __format__ da própria ``object`` levanta uma :exc:`TypeError` se "
"for passada qualquer string não vazia."

#: ../../reference/datamodel.rst:2054
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(x), '')``."
msgstr ""
"``object.__format__(x, '')`` agora é equivalente a ``str(x)`` em vez de "
"``format(str(x), '')``."

#: ../../reference/datamodel.rst:2070
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""
"Estes são os chamados métodos de \"comparação rica\". A correspondência "
"entre símbolos de operadores e nomes de métodos é a seguinte: ``x<y`` chama "
"``x.__lt__(y)``, ``x<=y`` chama ``x.__le__(y)``, ``x==y`` chama ``x."
"__eq__(y)``, ``x!=y`` chama ``x.__ne__(y)``, ``x>y`` chama ``x.__gt__(y)``, "
"e ``x>=y`` chama ``x.__ge__(y)``."

#: ../../reference/datamodel.rst:2076
msgid ""
"A rich comparison method may return the singleton :data:`NotImplemented` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""
"Um método de comparação rica pode retornar o singleton :data:"
"`NotImplemented` se não implementar a operação para um dado par de "
"argumentos. Por convenção, ``False`` e ``True`` são retornados para uma "
"comparação bem-sucedida. No entanto, estes métodos podem retornar qualquer "
"valor, por isso, se o operador de comparação for usado num contexto booleano "
"(por exemplo, na condição de uma instrução ``if``), o Python chamará :func:"
"`bool` no valor para determinar se o resultado é verdadeiro ou falso."

#: ../../reference/datamodel.rst:2083
msgid ""
"By default, ``object`` implements :meth:`__eq__` by using ``is``, returning :"
"data:`NotImplemented` in the case of a false comparison: ``True if x is y "
"else NotImplemented``. For :meth:`__ne__`, by default it delegates to :meth:"
"`__eq__` and inverts the result unless it is :data:`!NotImplemented`.  There "
"are no other implied relationships among the comparison operators or default "
"implementations; for example, the truth of ``(x<y or x==y)`` does not imply "
"``x<=y``. To automatically generate ordering operations from a single root "
"operation, see :func:`functools.total_ordering`."
msgstr ""
"Por predefinição, ``object`` implementa :meth:`__eq__` usando ``is``, "
"retornando :data:`NotImplemented` no caso de uma comparação falsa: ``True if "
"x is y else NotImplemented``. Para :meth:`__ne__`, por predefinição, delega "
"para :meth:`__eq__` e inverte o resultado, a menos que seja :data:`!"
"NotImplemented`. Não existem outras relações implícitas entre os operadores "
"de comparação ou implementações predefinidas; por exemplo, a verdade de "
"``(x<y or x==y)`` não implica ``x<=y``. Para gerar automaticamente operações "
"de ordenação a partir de uma única operação raiz, consulte :func:`functools."
"total_ordering`."

#: ../../reference/datamodel.rst:2092
msgid ""
"By default, the :class:`object` class provides implementations consistent "
"with :ref:`expressions-value-comparisons`: equality compares according to "
"object identity, and order comparisons raise :exc:`TypeError`. Each default "
"method may generate these results directly, but may also return :data:"
"`NotImplemented`."
msgstr ""
"Por predefinição, a classe :class:`object` fornece implementações "
"consistentes com :ref:`expressions-value-comparisons`: a igualdade compara "
"de acordo com a identidade do objeto, e as comparações de ordem levantam :"
"exc:`TypeError`. Cada método predefinido pode gerar estes resultados "
"diretamente, mas também pode retornar :data:`NotImplemented`."

#: ../../reference/datamodel.rst:2098
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""
"Consulte o parágrafo sobre :meth:`__hash__` para algumas notas importantes "
"sobre a criação de objetos :term:`hashable` que suportam operações de "
"comparação personalizadas e são utilizáveis como chaves de dicionário."

#: ../../reference/datamodel.rst:2102
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and the right operand's type is a direct or indirect "
"subclass of the left operand's type, the reflected method of the right "
"operand has priority, otherwise the left operand's method has priority.  "
"Virtual subclassing is not considered."
msgstr ""
"Não existem versões com argumentos trocados destes métodos (para serem "
"usadas quando o argumento da esquerda não suporta a operação, mas o da "
"direita suporta); em vez disso, :meth:`__lt__` e :meth:`__gt__` são reflexos "
"um do outro, :meth:`__le__` e :meth:`__ge__` são reflexos um do outro, e :"
"meth:`__eq__` e :meth:`__ne__` são os seus próprios reflexos. Se os "
"operandos forem de tipos diferentes, e o tipo do operando da direita for uma "
"subclasse direta ou indireta do tipo do operando da esquerda, o método "
"refletido do operando da direita tem prioridade; caso contrário, o método do "
"operando da esquerda tem prioridade. A subclassificação virtual não é "
"considerada."

#: ../../reference/datamodel.rst:2113
msgid ""
"When no appropriate method returns any value other than :data:"
"`NotImplemented`, the ``==`` and ``!=`` operators will fall back to ``is`` "
"and ``is not``, respectively."
msgstr ""
"Quando nenhum método apropriado retornar qualquer valor diferente de :data:"
"`NotImplemented`, os operadores ``==`` e ``!=`` recuarão para ``is`` e ``is "
"not``, respetivamente."

#: ../../reference/datamodel.rst:2122
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  The ``__hash__()`` method should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of "
"the object that also play a part in comparison of objects by packing them "
"into a tuple and hashing the tuple. Example::"
msgstr ""
"Chamado pela função integrada :func:`hash` e para operações em membros de "
"coleções com hash, incluindo :class:`set`, :class:`frozenset` e :class:"
"`dict`. O método ``__hash__()`` deve retornar um inteiro. A única "
"propriedade obrigatória é que objetos que comparam como iguais tenham o "
"mesmo valor de hash; é aconselhável misturar os valores de hash dos "
"componentes do objeto que também desempenham um papel na comparação de "
"objetos, empacotando-os numa tupla e fazendo hash da tupla. Exemplo::"

#: ../../reference/datamodel.rst:2130
msgid ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"
msgstr ""
"def __hash__(self):\n"
"    return hash((self.name, self.nick, self.color))"

#: ../../reference/datamodel.rst:2135
msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` trunca o valor retornado do método :meth:`__hash__` "
"personalizado de um objeto para o tamanho de um :c:type:`Py_ssize_t`. Isto é "
"tipicamente 8 bytes em builds de 64 bits e 4 bytes em builds de 32 bits. Se "
"o :meth:`__hash__` de um objeto tiver de interoperar em builds de diferentes "
"tamanhos de bits, certifique-se de verificar a largura em todos os builds "
"suportados. Uma forma fácil de fazer isto é com ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."

#: ../../reference/datamodel.rst:2143
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of :term:`hashable` collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the "
"wrong hash bucket)."
msgstr ""
"Se uma classe não definir um método :meth:`__eq__`, também não deve definir "
"uma operação :meth:`__hash__`; se definir :meth:`__eq__` mas não :meth:"
"`__hash__`, as suas instâncias não serão utilizáveis como itens em coleções "
"com hash. Se uma classe definir objetos mutáveis e implementar um método :"
"meth:`__eq__`, não deve implementar :meth:`__hash__`, uma vez que a "
"implementação de coleções :term:`hashable` exige que o valor de hash de uma "
"chave seja imutável (se o valor de hash do objeto mudar, ele estará no "
"contentor de hash errado)."

#: ../../reference/datamodel.rst:2152
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default (inherited from the :class:`object` class); with them, all objects "
"compare unequal (except with themselves) and ``x.__hash__()`` returns an "
"appropriate value such that ``x == y`` implies both that ``x is y`` and "
"``hash(x) == hash(y)``."
msgstr ""

#: ../../reference/datamodel.rst:2157
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.abc.Hashable)``."
msgstr ""
"Uma classe que substitui :meth:`__eq__` e não define :meth:`__hash__` terá o "
"seu :meth:`__hash__` implicitamente definido como ``None``. Quando o método :"
"meth:`__hash__` de uma classe é ``None``, as instâncias dessa classe geram "
"uma exceção :exc:`TypeError` apropriada quando um programa tenta obter o seu "
"valor de hash, e também são corretamente identificadas como não hashable "
"quando se verifica ``isinstance(obj, collections.abc.Hashable)``."

#: ../../reference/datamodel.rst:2164
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""
"Se uma classe que substitui :meth:`__eq__` precisar de reter a implementação "
"de :meth:`__hash__` de uma classe pai, o interpretador deve ser informado "
"explicitamente através da definição ``__hash__ = <ParentClass>.__hash__``."

#: ../../reference/datamodel.rst:2168
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"Se uma classe que não substitui :meth:`__eq__` pretender suprimir o suporte "
"a hash, deve incluir ``__hash__ = None`` na definição da classe. Uma classe "
"que define o seu próprio :meth:`__hash__` e que explicitamente levanta uma :"
"exc:`TypeError` seria incorretamente identificada como hashable por uma "
"chamada ``isinstance(obj, collections.abc.Hashable)``."

#: ../../reference/datamodel.rst:2177
msgid ""
"By default, the :meth:`__hash__` values of str and bytes objects are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"Por predefinição, os valores de :meth:`__hash__` dos objetos str e bytes são "
"\"salificados\" com um valor aleatório imprevisível. Embora permaneçam "
"constantes dentro de um processo Python individual, não são previsíveis "
"entre invocações repetidas do Python."

#: ../../reference/datamodel.rst:2182
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully chosen inputs that exploit the worst case performance of a dict "
"insertion, *O*\\ (*n*\\ :sup:`2`) complexity.  See http://ocert.org/"
"advisories/ocert-2011-003.html for details."
msgstr ""
"Isto destina-se a fornecer proteção contra um ataque de negação de serviço "
"causado por entradas cuidadosamente escolhidas que exploram o pior "
"desempenho de inserção num dicionário, com complexidade *O*\\ (*n*\\ :sup:"
"`2`). Consulte http://ocert.org/advisories/ocert-2011-003.html para mais "
"detalhes."

#: ../../reference/datamodel.rst:2187
msgid ""
"Changing hash values affects the iteration order of sets. Python has never "
"made guarantees about this ordering (and it typically varies between 32-bit "
"and 64-bit builds)."
msgstr ""
"Alterar valores de hash afeta a ordem de iteração dos conjuntos. O Python "
"nunca garantiu esta ordem (e tipicamente varia entre compilações de 32-bit e "
"64-bit)."

#: ../../reference/datamodel.rst:2191
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Veja também :envvar:`PYTHONHASHSEED`."

#: ../../reference/datamodel.rst:2193
msgid "Hash randomization is enabled by default."
msgstr "A aleatorização de hash está ativada por predefinição."

#: ../../reference/datamodel.rst:2201
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`~object.__len__` is called, if it is defined, and the object "
"is considered true if its result is nonzero.  If a class defines neither :"
"meth:`!__len__` nor :meth:`!__bool__` (which is true of the :class:`object` "
"class itself), all its instances are considered true."
msgstr ""
"Chamado para implementar o teste de valor lógico e a operação integrada "
"``bool()``; deve devolver ``False`` ou ``True``. Quando este método não está "
"definido, :meth:`~object.__len__` é chamado, se estiver definido, e o objeto "
"é considerado verdadeiro se o seu resultado for não nulo. Se uma classe não "
"definir :meth:`!__len__` nem :meth:`!__bool__` (o que é verdade para a "
"classe :class:`object` em si), todas as suas instâncias são consideradas "
"verdadeiras."

#: ../../reference/datamodel.rst:2212
msgid "Customizing attribute access"
msgstr "Personalização do acesso a atributos"

#: ../../reference/datamodel.rst:2214
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""
"Os seguintes métodos podem ser definidos para personalizar o significado do "
"acesso a atributos (utilização, atribuição ou eliminação de ``x.name``) para "
"instâncias de classe."

#: ../../reference/datamodel.rst:2222
msgid ""
"Called when the default attribute access fails with an :exc:`AttributeError` "
"(either :meth:`__getattribute__` raises an :exc:`AttributeError` because "
"*name* is not an instance attribute or an attribute in the class tree for "
"``self``; or :meth:`__get__` of a *name* property raises :exc:"
"`AttributeError`).  This method should either return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception. The :class:"
"`object` class itself does not provide this method."
msgstr ""
"Chamado quando o acesso predefinido a um atributo falha com uma :exc:"
"`AttributeError` (ou :meth:`__getattribute__` levanta uma :exc:"
"`AttributeError` porque *name* não é um atributo de instância ou um atributo "
"na árvore de classes para ``self``; ou :meth:`__get__` de uma propriedade "
"*name* levanta :exc:`AttributeError`). Este método deve devolver o valor do "
"atributo (calculado) ou levantar uma exceção :exc:`AttributeError`. A "
"classe :class:`object` em si não fornece este método."

#: ../../reference/datamodel.rst:2230
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can take total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""
"Note que se o atributo for encontrado através do mecanismo normal, :meth:"
"`__getattr__` não é chamado. (Esta é uma assimetria intencional entre :meth:"
"`__getattr__` e :meth:`__setattr__`.) Isto é feito por razões de eficiência "
"e porque, de outra forma, :meth:`__getattr__` não teria forma de aceder a "
"outros atributos da instância. Note que, pelo menos para variáveis de "
"instância, pode obter controlo total não inserindo quaisquer valores no "
"dicionário de atributos da instância (mas inserindo-os noutro objeto). Veja "
"o método :meth:`__getattribute__` abaixo para uma forma de obter controlo "
"total sobre o acesso a atributos."

#: ../../reference/datamodel.rst:2243
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""
"Chamado incondicionalmente para implementar acessos a atributos para "
"instâncias da classe. Se a classe também definir :meth:`__getattr__`, este "
"último não será chamado a menos que :meth:`__getattribute__` o chame "
"explicitamente ou levante uma :exc:`AttributeError`. Este método deve "
"devolver o valor do atributo (calculado) ou levantar uma exceção :exc:"
"`AttributeError`. Para evitar recursão infinita neste método, a sua "
"implementação deve sempre chamar o método da classe base com o mesmo nome "
"para aceder a quaisquer atributos de que necessite, por exemplo, ``object."
"__getattribute__(self, name)``."

#: ../../reference/datamodel.rst:2254
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or :ref:`built-in "
"functions <builtin-functions>`. See :ref:`special-lookup`."
msgstr ""
"Este método pode ainda ser contornado ao procurar métodos especiais como "
"resultado de invocação implícita através da sintaxe da linguagem ou :ref:"
"`funções integradas <builtin-functions>`. Veja :ref:`special-lookup`."

#: ../../reference/datamodel.rst:2259 ../../reference/datamodel.rst:2261
msgid ""
"For certain sensitive attribute accesses, raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Para certos acessos sensíveis a atributos, levanta um :ref:`evento de "
"auditoria <auditing>` ``object.__getattr__`` com os argumentos ``obj`` e "
"``name``."

#: ../../reference/datamodel.rst:2268
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""
"Chamado quando é tentada uma atribuição de atributo. Isto é chamado em vez "
"do mecanismo normal (ou seja, armazenar o valor no dicionário da instância). "
"*name* é o nome do atributo, *value* é o valor a atribuir."

#: ../../reference/datamodel.rst:2272
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""
"Se :meth:`__setattr__` pretender atribuir a um atributo de instância, deve "
"chamar o método da classe base com o mesmo nome, por exemplo, ``object."
"__setattr__(self, name, value)``."

#: ../../reference/datamodel.rst:2276 ../../reference/datamodel.rst:2278
msgid ""
"For certain sensitive attribute assignments, raises an :ref:`auditing event "
"<auditing>` ``object.__setattr__`` with arguments ``obj``, ``name``, "
"``value``."
msgstr ""
"Para certas atribuições sensíveis de atributos, levanta um :ref:`evento de "
"auditoria <auditing>` ``object.__setattr__`` com os argumentos ``obj``, "
"``name``, ``value``."

#: ../../reference/datamodel.rst:2285
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""
"Semelhante a :meth:`__setattr__`, mas para eliminação de atributos em vez de "
"atribuição. Isto só deve ser implementado se ``del obj.name`` for "
"significativo para o objeto."

#: ../../reference/datamodel.rst:2288 ../../reference/datamodel.rst:2290
msgid ""
"For certain sensitive attribute deletions, raises an :ref:`auditing event "
"<auditing>` ``object.__delattr__`` with arguments ``obj`` and ``name``."
msgstr ""
"Para certas eliminações sensíveis de atributos, levanta um :ref:`evento de "
"auditoria <auditing>` ``object.__delattr__`` com os argumentos ``obj`` e "
"``name``."

#: ../../reference/datamodel.rst:2297
msgid ""
"Called when :func:`dir` is called on the object. An iterable must be "
"returned. :func:`dir` converts the returned iterable to a list and sorts it."
msgstr ""
"Chamado quando :func:`dir` é chamado no objeto. Deve ser devolvido um "
"iterável. A função :func:`dir` converte o iterável devolvido para uma lista "
"e ordena-a."

#: ../../reference/datamodel.rst:2302
msgid "Customizing module attribute access"
msgstr "Personalização do acesso a atributos de módulo"

#: ../../reference/datamodel.rst:2312
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to customize "
"access to module attributes. The ``__getattr__`` function at the module "
"level should accept one argument which is the name of an attribute and "
"return the computed value or raise an :exc:`AttributeError`. If an attribute "
"is not found on a module object through the normal lookup, i.e. :meth:"
"`object.__getattribute__`, then ``__getattr__`` is searched in the module "
"``__dict__`` before raising an :exc:`AttributeError`. If found, it is called "
"with the attribute name and the result is returned."
msgstr ""
"Os nomes especiais ``__getattr__`` e ``__dir__`` também podem ser usados "
"para personalizar o acesso a atributos de módulo. A função ``__getattr__`` "
"ao nível do módulo deve aceitar um argumento, que é o nome de um atributo, e "
"devolver o valor calculado ou levantar uma :exc:`AttributeError`. Se um "
"atributo não for encontrado num objeto de módulo através da pesquisa normal, "
"ou seja, :meth:`object.__getattribute__`, então ``__getattr__`` é procurado "
"no ``__dict__`` do módulo antes de levantar uma :exc:`AttributeError`. Se "
"for encontrado, é chamado com o nome do atributo e o resultado é devolvido."

#: ../../reference/datamodel.rst:2321
msgid ""
"The ``__dir__`` function should accept no arguments, and return an iterable "
"of strings that represents the names accessible on module. If present, this "
"function overrides the standard :func:`dir` search on a module."
msgstr ""
"A função ``__dir__`` não deve aceitar argumentos e deve devolver um iterável "
"de strings que representam os nomes acessíveis no módulo. Se presente, esta "
"função substitui a pesquisa padrão de :func:`dir` num módulo."

#: ../../reference/datamodel.rst:2327
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of a "
"module object to a subclass of :class:`types.ModuleType`. For example::"
msgstr ""
"Para uma personalização mais fina do comportamento do módulo (definição de "
"atributos, propriedades, etc.), pode definir-se o atributo ``__class__`` de "
"um objeto de módulo para uma subclasse de :class:`types.ModuleType`. Por "
"exemplo::"

#: ../../reference/datamodel.rst:2331
msgid ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Setting {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"
msgstr ""
"import sys\n"
"from types import ModuleType\n"
"\n"
"class VerboseModule(ModuleType):\n"
"    def __repr__(self):\n"
"        return f'Verbose {self.__name__}'\n"
"\n"
"    def __setattr__(self, attr, value):\n"
"        print(f'Definindo {attr}...')\n"
"        super().__setattr__(attr, value)\n"
"\n"
"sys.modules[__name__].__class__ = VerboseModule"

#: ../../reference/datamodel.rst:2345
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only affect "
"lookups made using the attribute access syntax -- directly accessing the "
"module globals (whether by code within the module, or via a reference to the "
"module's globals dictionary) is unaffected."
msgstr ""
"Definir ``__getattr__`` do módulo e definir ``__class__`` do módulo afeta "
"apenas pesquisas feitas usando a sintaxe de acesso a atributos — aceder "
"diretamente aos globais do módulo (seja por código dentro do módulo, ou "
"através de uma referência ao dicionário de globais do módulo) não é afetado."

#: ../../reference/datamodel.rst:2350
msgid "``__class__`` module attribute is now writable."
msgstr "O atributo ``__class__`` do módulo é agora gravável."

#: ../../reference/datamodel.rst:2353
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "Atributos de módulo ``__getattr__`` e ``__dir__``."

#: ../../reference/datamodel.rst:2358
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - Módulo __getattr__ e __dir__"

#: ../../reference/datamodel.rst:2359
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "Descreve as funções ``__getattr__`` e ``__dir__`` em módulos."

#: ../../reference/datamodel.rst:2365
msgid "Implementing Descriptors"
msgstr "Implementação de Descritores"

#: ../../reference/datamodel.rst:2367
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property in "
"the owner class' :attr:`~object.__dict__`.  The :class:`object` class itself "
"does not implement any of these protocols."
msgstr ""
"Os seguintes métodos aplicam-se apenas quando uma instância da classe que "
"contém o método (uma chamada *classe descritora*) aparece numa *classe "
"proprietária* (o descritor deve estar no dicionário da classe proprietária "
"ou no dicionário da classe de um dos seus pais). Nos exemplos abaixo, \"o "
"atributo\" refere-se ao atributo cujo nome é a chave da propriedade no :attr:"
"`~object.__dict__` da classe proprietária. A classe :class:`object` em si "
"não implementa nenhum destes protocolos."

#: ../../reference/datamodel.rst:2377
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). The optional "
"*owner* argument is the owner class, while *instance* is the instance that "
"the attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*."
msgstr ""
"Chamado para obter o atributo da classe proprietária (acesso a atributo de "
"classe) ou de uma instância dessa classe (acesso a atributo de instância). O "
"argumento opcional *owner* é a classe proprietária, enquanto *instance* é a "
"instância através da qual o atributo foi acedido, ou ``None`` quando o "
"atributo é acedido através da *classe proprietária*."

#: ../../reference/datamodel.rst:2383
msgid ""
"This method should return the computed attribute value or raise an :exc:"
"`AttributeError` exception."
msgstr ""
"Este método deve devolver o valor do atributo calculado ou levantar uma "
"exceção :exc:`AttributeError`."

#: ../../reference/datamodel.rst:2386
msgid ""
":PEP:`252` specifies that :meth:`__get__` is callable with one or two "
"arguments.  Python's own built-in descriptors support this specification; "
"however, it is likely that some third-party tools have descriptors that "
"require both arguments.  Python's own :meth:`__getattribute__` "
"implementation always passes in both arguments whether they are required or "
"not."
msgstr ""
"A :PEP:`252` especifica que :meth:`__get__` pode ser chamado com um ou dois "
"argumentos. Os descritores integrados do Python suportam esta especificação; "
"no entanto, é provável que algumas ferramentas de terceiros tenham "
"descritores que requerem ambos os argumentos. A implementação do :meth:"
"`__getattribute__` do Python passa sempre ambos os argumentos, "
"independentemente de serem requeridos ou não."

#: ../../reference/datamodel.rst:2395
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""
"Chamado para definir o atributo numa instância *instance* da classe "
"proprietária para um novo valor, *value*."

#: ../../reference/datamodel.rst:2398
msgid ""
"Note, adding :meth:`__set__` or :meth:`__delete__` changes the kind of "
"descriptor to a \"data descriptor\".  See :ref:`descriptor-invocation` for "
"more details."
msgstr ""
"Note que adicionar :meth:`__set__` ou :meth:`__delete__` altera o tipo de "
"descritor para um \"descritor de dados\". Veja :ref:`descriptor-invocation` "
"para mais detalhes."

#: ../../reference/datamodel.rst:2404
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""
"Chamado para eliminar o atributo numa instância *instance* da classe "
"proprietária."

#: ../../reference/datamodel.rst:2406
msgid ""
"Instances of descriptors may also have the :attr:`!__objclass__` attribute "
"present:"
msgstr ""
"As instâncias de descritores também podem ter o atributo :attr:`!"
"__objclass__` presente:"

#: ../../reference/datamodel.rst:2411
msgid ""
"The attribute :attr:`!__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""
"O atributo :attr:`!__objclass__` é interpretado pelo módulo :mod:`inspect` "
"como especificando a classe onde este objeto foi definido (definir isto "
"apropriadamente pode ajudar na introspeção em tempo de execução de atributos "
"de classe dinâmicos). Para objetos chamáveis, pode indicar que uma instância "
"do tipo dado (ou de uma subclasse) é esperada ou requerida como o primeiro "
"argumento posicional (por exemplo, o CPython define este atributo para "
"métodos não ligados que são implementados em C)."

#: ../../reference/datamodel.rst:2422
msgid "Invoking Descriptors"
msgstr "Invocação de Descritores"

#: ../../reference/datamodel.rst:2424
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`~object.__get__`, :meth:`~object.__set__`, and :meth:"
"`~object.__delete__`. If any of those methods are defined for an object, it "
"is said to be a descriptor."
msgstr ""
"Em geral, um descritor é um atributo de objeto com \"comportamento de "
"ligação\", cujo acesso ao atributo foi substituído por métodos no protocolo "
"do descritor: :meth:`~object.__get__`, :meth:`~object.__set__` e :meth:"
"`~object.__delete__`. Se algum desses métodos for definido para um objeto, "
"diz-se que é um descritor."

#: ../../reference/datamodel.rst:2430
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""
"O comportamento predefinido para o acesso a atributos é obter, definir ou "
"eliminar o atributo do dicionário de um objeto. Por exemplo, ``a.x`` tem uma "
"cadeia de pesquisa que começa com ``a.__dict__['x']``, depois ``type(a)."
"__dict__['x']``, e continua através das classes base de ``type(a)``, "
"excluindo metaclasses."

#: ../../reference/datamodel.rst:2435
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""
"No entanto, se o valor pesquisado for um objeto que define um dos métodos de "
"descritor, então o Python pode substituir o comportamento predefinido e "
"invocar o método do descritor em vez disso. Onde isto ocorre na cadeia de "
"precedência depende de quais métodos de descritor foram definidos e como "
"foram chamados."

#: ../../reference/datamodel.rst:2440
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""
"O ponto de partida para a invocação de um descritor é uma ligação, ``a.x``. "
"Como os argumentos são montados depende de ``a``:"

#: ../../reference/datamodel.rst:2443
msgid "Direct Call"
msgstr "Chamada Direta"

#: ../../reference/datamodel.rst:2444
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""
"A chamada mais simples e menos comum é quando o código do utilizador invoca "
"diretamente um método de descritor: ``x.__get__(a)``."

#: ../../reference/datamodel.rst:2447
msgid "Instance Binding"
msgstr "Ligação de Instância"

#: ../../reference/datamodel.rst:2448
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"Se ligar a uma instância de objeto, ``a.x`` é transformado na chamada: "
"``type(a).__dict__['x'].__get__(a, type(a))``."

#: ../../reference/datamodel.rst:2451
msgid "Class Binding"
msgstr "Ligação de Classe"

#: ../../reference/datamodel.rst:2452
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""
"Se ligar a uma classe, ``A.x`` é transformado na chamada: ``A.__dict__['x']."
"__get__(None, A)``."

#: ../../reference/datamodel.rst:2455
msgid "Super Binding"
msgstr "Ligação Super"

#: ../../reference/datamodel.rst:2456
msgid ""
"A dotted lookup such as ``super(A, a).x`` searches ``a.__class__.__mro__`` "
"for a base class ``B`` following ``A`` and then returns ``B.__dict__['x']."
"__get__(a, A)``.  If not a descriptor, ``x`` is returned unchanged."
msgstr ""
"Uma pesquisa pontuada como ``super(A, a).x`` pesquisa ``a.__class__."
"__mro__`` por uma classe base ``B`` que segue ``A`` e depois devolve ``B."
"__dict__['x'].__get__(a, A)``. Se não for um descritor, ``x`` é devolvido "
"inalterado."

#: ../../reference/datamodel.rst:2493
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`~object.__get__`, :meth:`~object.__set__` and :meth:"
"`~object.__delete__`.  If it does not define :meth:`!__get__`, then "
"accessing the attribute will return the descriptor object itself unless "
"there is a value in the object's instance dictionary.  If the descriptor "
"defines :meth:`!__set__` and/or :meth:`!__delete__`, it is a data "
"descriptor; if it defines neither, it is a non-data descriptor.  Normally, "
"data descriptors define both :meth:`!__get__` and :meth:`!__set__`, while "
"non-data descriptors have just the :meth:`!__get__` method.  Data "
"descriptors with :meth:`!__get__` and :meth:`!__set__` (and/or :meth:`!"
"__delete__`) defined always override a redefinition in an instance "
"dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"Para ligações de instância, a precedência da invocação do descritor depende "
"de quais métodos do descritor estão definidos. Um descritor pode definir "
"qualquer combinação de :meth:`~object.__get__`, :meth:`~object.__set__` e :"
"meth:`~object.__delete__`. Se não definir :meth:`!__get__`, então aceder ao "
"atributo devolverá o próprio objeto descritor, a menos que exista um valor "
"no dicionário da instância do objeto. Se o descritor definir :meth:`!"
"__set__` e/ou :meth:`!__delete__`, é um descritor de dados; se não definir "
"nenhum, é um descritor não de dados. Normalmente, os descritores de dados "
"definem tanto :meth:`!__get__` como :meth:`!__set__`, enquanto os "
"descritores não de dados têm apenas o método :meth:`!__get__`. Os "
"descritores de dados com :meth:`!__get__` e :meth:`!__set__` (e/ou :meth:`!"
"__delete__`) definidos substituem sempre uma redefinição no dicionário da "
"instância. Em contraste, os descritores não de dados podem ser substituídos "
"pelas instâncias."

#: ../../reference/datamodel.rst:2508
msgid ""
"Python methods (including those decorated with :deco:`staticmethod` and :"
"deco:`classmethod`) are implemented as non-data descriptors.  Accordingly, "
"instances can redefine and override methods.  This allows individual "
"instances to acquire behaviors that differ from other instances of the same "
"class."
msgstr ""
"Os métodos Python (incluindo aqueles decorados com :deco:`staticmethod` e :"
"deco:`classmethod`) são implementados como descritores não de dados. "
"Consequentemente, as instâncias podem redefinir e substituir métodos. Isto "
"permite que instâncias individuais adquiram comportamentos diferentes de "
"outras instâncias da mesma classe."

#: ../../reference/datamodel.rst:2514
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
"A função :func:`property` é implementada como um descritor de dados. "
"Consequentemente, as instâncias não podem substituir o comportamento de uma "
"propriedade."

#: ../../reference/datamodel.rst:2521
msgid "__slots__"
msgstr "__slots__"

#: ../../reference/datamodel.rst:2523
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties) "
"and deny the creation of :attr:`~object.__dict__` and *__weakref__* (unless "
"explicitly declared in *__slots__* or available in a parent.)"
msgstr ""
"O *__slots__* permite-nos declarar explicitamente membros de dados (como "
"propriedades) e negar a criação de :attr:`~object.__dict__` e *__weakref__* "
"(a menos que sejam declarados explicitamente em *__slots__* ou estejam "
"disponíveis numa classe pai)."

#: ../../reference/datamodel.rst:2527
msgid ""
"The space saved over using :attr:`~object.__dict__` can be significant. "
"Attribute lookup speed can be significantly improved as well."
msgstr ""
"O espaço poupado em relação ao uso de :attr:`~object.__dict__` pode ser "
"significativo. A velocidade de pesquisa de atributos também pode ser "
"significativamente melhorada."

#: ../../reference/datamodel.rst:2532
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of :attr:"
"`~object.__dict__` and *__weakref__* for each instance."
msgstr ""
"Esta variável de classe pode ser atribuída a uma string, iterável, ou "
"sequência de strings com nomes de variáveis usados pelas instâncias. "
"*__slots__* reserva espaço para as variáveis declaradas e impede a criação "
"automática de :attr:`~object.__dict__` e *__weakref__* para cada instância."

#: ../../reference/datamodel.rst:2541
msgid "Notes on using *__slots__*:"
msgstr "Notas sobre o uso de *__slots__*:"

#: ../../reference/datamodel.rst:2543
msgid ""
"When inheriting from a class without *__slots__*, the :attr:`~object."
"__dict__` and *__weakref__* attribute of the instances will always be "
"accessible."
msgstr ""
"Ao herdar de uma classe sem *__slots__*, os atributos :attr:`~object."
"__dict__` e *__weakref__* das instâncias serão sempre acessíveis."

#: ../../reference/datamodel.rst:2547
msgid ""
"Without a :attr:`~object.__dict__` variable, instances cannot be assigned "
"new variables not listed in the *__slots__* definition.  Attempts to assign "
"to an unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"Sem uma variável :attr:`~object.__dict__`, não é possível atribuir novas "
"variáveis não listadas na definição de *__slots__* às instâncias. Tentativas "
"de atribuir a um nome de variável não listado levantam uma :exc:"
"`AttributeError`. Se for desejada a atribuição dinâmica de novas variáveis, "
"então adicione ``'__dict__'`` à sequência de strings na declaração de "
"*__slots__*."

#: ../../reference/datamodel.rst:2554
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support :mod:`weak references <weakref>` to its "
"instances. If weak reference support is needed, then add ``'__weakref__'`` "
"to the sequence of strings in the *__slots__* declaration."
msgstr ""
"Sem uma variável *__weakref__* para cada instância, as classes que definem "
"*__slots__* não suportam :mod:`referências fracas <weakref>` às suas "
"instâncias. Se for necessário suporte para referências fracas, então "
"adicione ``'__weakref__'`` à sequência de strings na declaração de "
"*__slots__*."

#: ../../reference/datamodel.rst:2560
msgid ""
"*__slots__* are implemented at the class level by creating :ref:`descriptors "
"<descriptors>` for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""
"O *__slots__* é implementado ao nível da classe através da criação de :ref:"
"`descritores <descriptors>` para cada nome de variável. Como resultado, os "
"atributos de classe não podem ser usados para definir valores predefinidos "
"para variáveis de instância definidas por *__slots__*; caso contrário, o "
"atributo de classe substituiria a atribuição do descritor."

#: ../../reference/datamodel.rst:2566
msgid ""
"The action of a *__slots__* declaration is not limited to the class where it "
"is defined.  *__slots__* declared in parents are available in child classes. "
"However, instances of a child subclass will get a :attr:`~object.__dict__` "
"and *__weakref__* unless the subclass also defines *__slots__* (which should "
"only contain names of any *additional* slots)."
msgstr ""
"A ação de uma declaração *__slots__* não se limita à classe onde é definida. "
"Os *__slots__* declarados em classes pai estão disponíveis nas classes "
"filho. No entanto, as instâncias de uma subclasse filho obterão um :attr:"
"`~object.__dict__` e *__weakref__* a menos que a subclasse também defina "
"*__slots__* (que deve conter apenas nomes de *slots adicionais*)."

#: ../../reference/datamodel.rst:2572
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""
"Se uma classe definir um slot também definido numa classe base, a variável "
"de instância definida pelo slot da classe base torna-se inacessível (exceto "
"obtendo o seu descritor diretamente da classe base). Isto torna o "
"significado do programa indefinido. No futuro, pode ser adicionada uma "
"verificação para evitar isto."

#: ../../reference/datamodel.rst:2577
msgid ""
":exc:`TypeError` will be raised if nonempty *__slots__* are defined for a "
"class derived from a :c:member:`\"variable-length\" built-in type "
"<PyTypeObject.tp_itemsize>` such as :class:`int`, :class:`bytes`, and :class:"
"`tuple`."
msgstr ""
"Uma exceção :exc:`TypeError` será levantada se *__slots__* não vazios forem "
"definidos para uma classe derivada de um tipo integrado de :c:member:"
"\"comprimento variável\" <PyTypeObject.tp_itemsize>`, como :class:`int`, :"
"class:`bytes` e :class:`tuple`."

#: ../../reference/datamodel.rst:2582
msgid "Any non-string :term:`iterable` may be assigned to *__slots__*."
msgstr "Qualquer :term:`iterável` não string pode ser atribuído a *__slots__*."

#: ../../reference/datamodel.rst:2584
msgid ""
"If a :class:`dictionary <dict>` is used to assign *__slots__*, the "
"dictionary keys will be used as the slot names. The values of the dictionary "
"can be used to provide per-attribute docstrings that will be recognised by :"
"func:`inspect.getdoc` and displayed in the output of :func:`help`."
msgstr ""
"Se um :class:`dicionário <dict>` for usado para atribuir *__slots__*, as "
"chaves do dicionário serão usadas como nomes dos slots. Os valores do "
"dicionário podem ser usados para fornecer docstrings por atributo que serão "
"reconhecidos por :func:`inspect.getdoc` e exibidos na saída de :func:`help`."

#: ../../reference/datamodel.rst:2589
msgid ""
":attr:`~object.__class__` assignment works only if both classes have the "
"same *__slots__*."
msgstr ""
"A atribuição de :attr:`~object.__class__` só funciona se ambas as classes "
"tiverem o mesmo *__slots__*."

#: ../../reference/datamodel.rst:2592
msgid ""
":ref:`Multiple inheritance <tut-multiple>` with multiple slotted parent "
"classes can be used, but only one parent is allowed to have attributes "
"created by slots (the other bases must have empty slot layouts) - violations "
"raise :exc:`TypeError`."
msgstr ""
"A :ref:`herança múltipla <tut-multiple>` com múltiplas classes pai com slots "
"pode ser usada, mas apenas um pai pode ter atributos criados por slots (as "
"outras bases devem ter layouts de slots vazios) — violações levantam uma :"
"exc:`TypeError`."

#: ../../reference/datamodel.rst:2598
msgid ""
"If an :term:`iterator` is used for *__slots__* then a :term:`descriptor` is "
"created for each of the iterator's values. However, the *__slots__* "
"attribute will be an empty iterator."
msgstr ""
"Se um :term:`iterador` for usado para *__slots__*, então um :term:"
"`descritor` é criado para cada um dos valores do iterador. No entanto, o "
"atributo *__slots__* será um iterador vazio."

#: ../../reference/datamodel.rst:2606
msgid "Customizing class creation"
msgstr "Personalização da criação de classes"

#: ../../reference/datamodel.rst:2608
msgid ""
"Whenever a class inherits from another class, :meth:`~object."
"__init_subclass__` is called on the parent class. This way, it is possible "
"to write classes which change the behavior of subclasses. This is closely "
"related to class decorators, but where class decorators only affect the "
"specific class they're applied to, ``__init_subclass__`` solely applies to "
"future subclasses of the class defining the method."
msgstr ""
"Sempre que uma classe herda de outra classe, :meth:`~object."
"__init_subclass__` é chamado na classe pai. Desta forma, é possível escrever "
"classes que alteram o comportamento das subclasses. Isto está intimamente "
"relacionado com decoradores de classe, mas enquanto os decoradores de classe "
"afetam apenas a classe específica a que são aplicados, ``__init_subclass__`` "
"aplica-se apenas a subclasses futuras da classe que define o método."

#: ../../reference/datamodel.rst:2617
msgid ""
"This method is called whenever the containing class is subclassed. *cls* is "
"then the new subclass. If defined as a normal instance method, this method "
"is implicitly converted to a class method."
msgstr ""
"Este método é chamado sempre que a classe contêiner é subclassificada. *cls* "
"é então a nova subclasse. Se definido como um método de instância normal, "
"este método é implicitamente convertido num método de classe."

#: ../../reference/datamodel.rst:2621
msgid ""
"Keyword arguments which are given to a new class are passed to the parent "
"class's ``__init_subclass__``. For compatibility with other classes using "
"``__init_subclass__``, one should take out the needed keyword arguments and "
"pass the others over to the base class, as in::"
msgstr ""
"Os argumentos nomeados fornecidos a uma nova classe são passados para o "
"``__init_subclass__`` da classe pai. Para compatibilidade com outras classes "
"que usam ``__init_subclass__``, deve-se extrair os argumentos nomeados "
"necessários e passar os restantes para a classe base, como em::"

#: ../../reference/datamodel.rst:2627
msgid ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"
msgstr ""
"class Philosopher:\n"
"    def __init_subclass__(cls, /, default_name, **kwargs):\n"
"        super().__init_subclass__(**kwargs)\n"
"        cls.default_name = default_name\n"
"\n"
"class AustralianPhilosopher(Philosopher, default_name=\"Bruce\"):\n"
"    pass"

#: ../../reference/datamodel.rst:2635
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but "
"raises an error if it is called with any arguments."
msgstr ""
"A implementação predefinida ``object.__init_subclass__`` não faz nada, mas "
"levanta um erro se for chamada com argumentos."

#: ../../reference/datamodel.rst:2640
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. The "
"actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"A dica de metaclasse ``metaclass`` é consumida pelo restante da maquinaria "
"de tipo e nunca é passada para implementações de ``__init_subclass__``. A "
"metaclasse real (em vez da dica explícita) pode ser acedida como "
"``type(cls)``."

#: ../../reference/datamodel.rst:2648
msgid ""
"When a class is created, :meth:`type.__new__` scans the class variables and "
"makes callbacks to those with a :meth:`~object.__set_name__` hook."
msgstr ""

#: ../../reference/datamodel.rst:2653
msgid ""
"Automatically called at the time the owning class *owner* is created. The "
"object has been assigned to *name* in that class::"
msgstr ""
"Chamado automaticamente no momento em que a classe proprietária *owner* é "
"criada. O objeto foi atribuído a *name* nessa classe::"

#: ../../reference/datamodel.rst:2656
msgid ""
"class A:\n"
"    x = C()  # Automatically calls: x.__set_name__(A, 'x')"
msgstr ""
"class A:\n"
"    x = C()  # Chama automaticamente: x.__set_name__(A, 'x')"

#: ../../reference/datamodel.rst:2659
msgid ""
"If the class variable is assigned after the class is created, :meth:"
"`__set_name__` will not be called automatically. If needed, :meth:"
"`__set_name__` can be called directly::"
msgstr ""
"Se a variável de classe for atribuída após a criação da classe, :meth:"
"`__set_name__` não será chamado automaticamente. Se necessário, :meth:"
"`__set_name__` pode ser chamado diretamente::"

#: ../../reference/datamodel.rst:2663
msgid ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # The hook is not called\n"
"c.__set_name__(A, 'x')   # Manually invoke the hook"
msgstr ""
"class A:\n"
"   pass\n"
"\n"
"c = C()\n"
"A.x = c                  # O gancho não é chamado\n"
"c.__set_name__(A, 'x')   # Invocar manualmente o gancho"

#: ../../reference/datamodel.rst:2670
msgid "See :ref:`class-object-creation` for more details."
msgstr "Veja :ref:`class-object-creation` para mais detalhes."

#: ../../reference/datamodel.rst:2678
msgid "Metaclasses"
msgstr "Metaclasses"

#: ../../reference/datamodel.rst:2685
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"Por predefinição, as classes são construídas usando :func:`type`. O corpo da "
"classe é executado num novo espaço de nomes e o nome da classe é ligado "
"localmente ao resultado de ``type(name, bases, namespace)``."

#: ../../reference/datamodel.rst:2689
msgid ""
"The class creation process can be customized by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"O processo de criação de classes pode ser personalizado passando o argumento "
"nomeado ``metaclass`` na linha de definição da classe, ou herdando de uma "
"classe existente que inclua tal argumento. No exemplo seguinte, tanto "
"``MyClass`` como ``MySubclass`` são instâncias de ``Meta``::"

#: ../../reference/datamodel.rst:2694
msgid ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"
msgstr ""
"class Meta(type):\n"
"    pass\n"
"\n"
"class MyClass(metaclass=Meta):\n"
"    pass\n"
"\n"
"class MySubclass(MyClass):\n"
"    pass"

#: ../../reference/datamodel.rst:2703
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""
"Quaisquer outros argumentos nomeados especificados na definição da classe "
"são passados para todas as operações de metaclasse descritas abaixo."

#: ../../reference/datamodel.rst:2706
msgid "When a class definition is executed, the following steps occur:"
msgstr ""
"Quando uma definição de classe é executada, ocorrem os seguintes passos:"

#: ../../reference/datamodel.rst:2708
msgid "MRO entries are resolved;"
msgstr "As entradas MRO são resolvidas;"

#: ../../reference/datamodel.rst:2709
msgid "the appropriate metaclass is determined;"
msgstr "a metaclasse apropriada é determinada;"

#: ../../reference/datamodel.rst:2710
msgid "the class namespace is prepared;"
msgstr "o espaço de nomes da classe é preparado;"

#: ../../reference/datamodel.rst:2711
msgid "the class body is executed;"
msgstr "o corpo da classe é executado;"

#: ../../reference/datamodel.rst:2712
msgid "the class object is created."
msgstr "o objeto da classe é criado."

#: ../../reference/datamodel.rst:2716
msgid "Resolving MRO entries"
msgstr "Resolução de entradas MRO"

#: ../../reference/datamodel.rst:2720
msgid ""
"If a base that appears in a class definition is not an instance of :class:"
"`type`, then an :meth:`!__mro_entries__` method is searched on the base. If "
"an :meth:`!__mro_entries__` method is found, the base is substituted with "
"the result of a call to :meth:`!__mro_entries__` when creating the class. "
"The method is called with the original bases tuple passed to the *bases* "
"parameter, and must return a tuple of classes that will be used instead of "
"the base. The returned tuple may be empty: in these cases, the original base "
"is ignored."
msgstr ""
"Se uma base que aparece numa definição de classe não for uma instância de :"
"class:`type`, então um método :meth:`!__mro_entries__` é procurado na base. "
"Se um método :meth:`!__mro_entries__` for encontrado, a base é substituída "
"pelo resultado de uma chamada a :meth:`!__mro_entries__` ao criar a classe. "
"O método é chamado com o tuplo de bases original passado ao parâmetro "
"*bases*, e deve devolver um tuplo de classes que será usado em vez da base. "
"O tuplo devolvido pode estar vazio: nestes casos, a base original é ignorada."

#: ../../reference/datamodel.rst:2731
msgid ":func:`types.resolve_bases`"
msgstr ":func:`types.resolve_bases`"

#: ../../reference/datamodel.rst:2732
msgid "Dynamically resolve bases that are not instances of :class:`type`."
msgstr "Resolve dinamicamente bases que não são instâncias de :class:`type`."

#: ../../reference/datamodel.rst:2734
msgid ":func:`types.get_original_bases`"
msgstr ":func:`types.get_original_bases`"

#: ../../reference/datamodel.rst:2735
msgid ""
"Retrieve a class's \"original bases\" prior to modifications by :meth:"
"`~object.__mro_entries__`."
msgstr ""
"Obtém as \"bases originais\" de uma classe antes de modificações por :meth:"
"`~object.__mro_entries__`."

#: ../../reference/datamodel.rst:2738
msgid ":pep:`560`"
msgstr ":pep:`560`"

#: ../../reference/datamodel.rst:2739
msgid "Core support for typing module and generic types."
msgstr "Suporte central para o módulo typing e tipos genéricos."

#: ../../reference/datamodel.rst:2743
msgid "Determining the appropriate metaclass"
msgstr "Determinação da metaclasse apropriada"

#: ../../reference/datamodel.rst:2747
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr ""
"A metaclasse apropriada para uma definição de classe é determinada da "
"seguinte forma:"

#: ../../reference/datamodel.rst:2749
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used;"
msgstr ""
"se não forem fornecidas bases nem metaclasse explícita, então :func:`type` é "
"usado;"

#: ../../reference/datamodel.rst:2750
msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass;"
msgstr ""
"se uma metaclasse explícita for fornecida e *não* for uma instância de :func:"
"`type`, então é usada diretamente como a metaclasse;"

#: ../../reference/datamodel.rst:2752
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used."
msgstr ""
"se uma instância de :func:`type` for fornecida como metaclasse explícita, ou "
"se bases forem definidas, então a metaclasse mais derivada é usada."

#: ../../reference/datamodel.rst:2755
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""
"A metaclasse mais derivada é selecionada a partir da metaclasse especificada "
"explicitamente (se houver) e das metaclasses (ou seja, ``type(cls)``) de "
"todas as classes base especificadas. A metaclasse mais derivada é aquela que "
"é um subtipo de *todas* estas metaclasses candidatas. Se nenhuma das "
"metaclasses candidatas cumprir esse critério, então a definição da classe "
"falhará com ``TypeError``."

#: ../../reference/datamodel.rst:2765
msgid "Preparing the class namespace"
msgstr "Preparação do espaço de nomes da classe"

#: ../../reference/datamodel.rst:2770
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition). The "
"``__prepare__`` method should be implemented as a :func:`classmethod "
"<classmethod>`. The namespace returned by ``__prepare__`` is passed in to "
"``__new__``, but when the final class object is created the namespace is "
"copied into a new ``dict``."
msgstr ""
"Depois de identificada a metaclasse apropriada, o espaço de nomes da classe "
"é preparado. Se a metaclasse tiver um atributo ``__prepare__``, este é "
"chamado como ``namespace = metaclass.__prepare__(name, bases, **kwds)`` "
"(onde os argumentos nomeados adicionais, se houver, vêm da definição da "
"classe). O método ``__prepare__`` deve ser implementado como um :func:"
"`classmethod <classmethod>`. O espaço de nomes devolvido por ``__prepare__`` "
"é passado para ``__new__``, mas quando o objeto da classe final é criado, o "
"espaço de nomes é copiado para um novo ``dict``."

#: ../../reference/datamodel.rst:2779
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty ordered mapping."
msgstr ""
"Se a metaclasse não tiver um atributo ``__prepare__``, então o espaço de "
"nomes da classe é inicializado como um mapeamento ordenado vazio."

#: ../../reference/datamodel.rst:2784
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Metaclasses em Python 3000"

#: ../../reference/datamodel.rst:2785
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Introduziu o gancho de espaço de nomes ``__prepare__``"

#: ../../reference/datamodel.rst:2789
msgid "Executing the class body"
msgstr "Execução do corpo da classe"

#: ../../reference/datamodel.rst:2794
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""
"O corpo da classe é executado (aproximadamente) como ``exec(body, globals(), "
"namespace)``. A diferença chave em relação a uma chamada normal a :func:"
"`exec` é que o âmbito léxico permite que o corpo da classe (incluindo "
"quaisquer métodos) faça referência a nomes dos âmbitos atual e exterior "
"quando a definição da classe ocorre dentro de uma função."

#: ../../reference/datamodel.rst:2800
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, or through the implicit lexically scoped ``__class__`` "
"reference described in the next section."
msgstr ""
"No entanto, mesmo quando a definição da classe ocorre dentro da função, os "
"métodos definidos dentro da classe ainda não conseguem ver nomes definidos "
"no âmbitos da classe. As variáveis de classe devem ser acedidas através do "
"primeiro parâmetro de métodos de instância ou de classe, ou através da "
"referência ``__class__`` implicitamente com âmbito léxico descrita na "
"próxima secção."

#: ../../reference/datamodel.rst:2809
msgid "Creating the class object"
msgstr "Criação do objeto da classe"

#: ../../reference/datamodel.rst:2816
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""
"Depois de o espaço de nomes da classe ter sido preenchido através da "
"execução do corpo da classe, o objeto da classe é criado chamando "
"``metaclass(name, bases, namespace, **kwds)`` (as palavras-chave adicionais "
"passadas aqui são as mesmas que as passadas para ``__prepare__``)."

#: ../../reference/datamodel.rst:2821
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""
"Este objeto de classe é aquele que será referenciado pela forma de zero "
"argumentos de :func:`super`. ``__class__`` é uma referência de fechamento "
"implícita criada pelo compilador se algum método no corpo da classe se "
"referir a ``__class__`` ou ``super``. Isto permite que a forma de zero "
"argumentos de :func:`super` identifique corretamente a classe a ser definida "
"com base no âmbito léxico, enquanto a classe ou instância usada para fazer a "
"chamada atual é identificada com base no primeiro argumento passado ao "
"método."

#: ../../reference/datamodel.rst:2831
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the metaclass "
"as a ``__classcell__`` entry in the class namespace. If present, this must "
"be propagated up to the ``type.__new__`` call in order for the class to be "
"initialised correctly. Failing to do so will result in a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"No CPython 3.6 e posteriores, a célula ``__class__`` é passada para a "
"metaclasse como uma entrada ``__classcell__`` no espaço de nomes da classe. "
"Se estiver presente, esta deve ser propagada até à chamada ``type.__new__`` "
"para que a classe seja inicializada corretamente. Falhar ao fazê-lo "
"resultará num :exc:`RuntimeError` no Python 3.8."

#: ../../reference/datamodel.rst:2837
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customization "
"steps are invoked after creating the class object:"
msgstr ""
"Ao usar a metaclasse predefinida :class:`type`, ou qualquer metaclasse que "
"eventualmente chame ``type.__new__``, os seguintes passos adicionais de "
"personalização são invocados após a criação do objeto da classe:"

#: ../../reference/datamodel.rst:2841
msgid ""
"The ``type.__new__`` method collects all of the attributes in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"O método ``type.__new__`` recolhe todos os atributos no espaço de nomes da "
"classe que definem um método :meth:`~object.__set_name__`;"

#: ../../reference/datamodel.rst:2843
msgid ""
"Those ``__set_name__`` methods are called with the class being defined and "
"the assigned name of that particular attribute;"
msgstr ""
"Esses métodos ``__set_name__`` são chamados com a classe a ser definida e o "
"nome atribuído a esse atributo específico;"

#: ../../reference/datamodel.rst:2845
msgid ""
"The :meth:`~object.__init_subclass__` hook is called on the immediate parent "
"of the new class in its method resolution order."
msgstr ""
"O gancho :meth:`~object.__init_subclass__` é chamado no pai imediato da nova "
"classe na sua ordem de resolução de métodos."

#: ../../reference/datamodel.rst:2848
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""
"Depois de o objeto da classe ser criado, é passado aos decoradores de classe "
"incluídos na definição da classe (se houver) e o objeto resultante é ligado "
"no espaço de nomes local como a classe definida."

#: ../../reference/datamodel.rst:2852
msgid ""
"When a new class is created by ``type.__new__``, the object provided as the "
"namespace parameter is copied to a new ordered mapping and the original "
"object is discarded. The new copy is wrapped in a read-only proxy, which "
"becomes the :attr:`~type.__dict__` attribute of the class object."
msgstr ""
"Quando uma nova classe é criada por ``type.__new__``, o objeto fornecido "
"como parâmetro de espaço de nomes é copiado para um novo mapeamento ordenado "
"e o objeto original é descartado. A nova cópia é envolvida num proxy de "
"apenas leitura, que se torna o atributo :attr:`~type.__dict__` do objeto da "
"classe."

#: ../../reference/datamodel.rst:2859
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - Novo super"

#: ../../reference/datamodel.rst:2860
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "Descreve a referência de fechamento implícita ``__class__``"

#: ../../reference/datamodel.rst:2864
msgid "Uses for metaclasses"
msgstr "Usos para metaclasses"

#: ../../reference/datamodel.rst:2866
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include enum, logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""
"Os usos potenciais para metaclasses são ilimitados. Algumas ideias que têm "
"sido exploradas incluem enumerações, registo, verificação de interfaces, "
"delegação automática, criação automática de propriedades, proxies, "
"frameworks, e bloqueio/sincronização automática de recursos."

#: ../../reference/datamodel.rst:2873
msgid "Customizing instance and subclass checks"
msgstr "Personalização de verificações de instância e subclasse"

#: ../../reference/datamodel.rst:2875
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"Os seguintes métodos são usados para substituir o comportamento predefinido "
"das funções integradas :func:`isinstance` e :func:`issubclass`."

#: ../../reference/datamodel.rst:2878
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""
"Em particular, a metaclasse :class:`abc.ABCMeta` implementa estes métodos de "
"forma a permitir a adição de Classes Base Abstratas (ABCs) como \"classes "
"base virtuais\" a qualquer classe ou tipo (incluindo tipos integrados), "
"incluindo outras ABCs."

#: ../../reference/datamodel.rst:2885
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""
"Devolve verdadeiro se *instance* deve ser considerada uma instância (direta "
"ou indireta) de *class*. Se definido, é chamado para implementar "
"``isinstance(instance, class)``."

#: ../../reference/datamodel.rst:2892
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""
"Devolve verdadeiro se *subclass* deve ser considerada uma subclasse (direta "
"ou indireta) de *class*. Se definido, é chamado para implementar "
"``issubclass(subclass, class)``."

#: ../../reference/datamodel.rst:2897
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""
"Note que estes métodos são pesquisados no tipo (metaclasse) de uma classe. "
"Não podem ser definidos como métodos de classe na classe real. Isto é "
"consistente com a pesquisa de métodos especiais que são chamados em "
"instâncias, apenas neste caso a instância é ela própria uma classe."

#: ../../reference/datamodel.rst:2904
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - Introdução de Classes Base Abstratas"

#: ../../reference/datamodel.rst:2905
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~type.__instancecheck__` and :meth:"
"`~type.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""
"Inclui a especificação para personalizar o comportamento de :func:"
"`isinstance` e :func:`issubclass` através de :meth:`~type.__instancecheck__` "
"e :meth:`~type.__subclasscheck__`, com motivação para esta funcionalidade no "
"contexto da adição de Classes Base Abstratas (veja o módulo :mod:`abc`) à "
"linguagem."

#: ../../reference/datamodel.rst:2913
msgid "Emulating generic types"
msgstr "Emulação de tipos genéricos"

#: ../../reference/datamodel.rst:2915
msgid ""
"When using :term:`type annotations<annotation>`, it is often useful to "
"*parameterize* a :term:`generic type` using Python's square-brackets "
"notation. For example, the annotation ``list[int]`` might be used to signify "
"a :class:`list` in which all the elements are of type :class:`int`."
msgstr ""
"Ao usar :term:`anotações de tipo<annotation>`, é muitas vezes útil "
"*parametrizar* um :term:`tipo genérico` usando a notação de parênteses retos "
"do Python. Por exemplo, a anotação ``list[int]`` pode ser usada para "
"significar uma :class:`list` em que todos os elementos são do tipo :class:"
"`int`."

#: ../../reference/datamodel.rst:2922
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Dicas de Tipo"

#: ../../reference/datamodel.rst:2923
msgid "Introducing Python's framework for type annotations"
msgstr "Introdução ao framework do Python para anotações de tipo"

#: ../../reference/datamodel.rst:2925
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Tipos de Alias Genéricos<types-genericalias>`"

#: ../../reference/datamodel.rst:2926
msgid "Documentation for objects representing parameterized generic classes"
msgstr ""
"Documentação para objetos que representam classes genéricas parametrizadas"

#: ../../reference/datamodel.rst:2928
msgid ""
":ref:`Generics`, :ref:`user-defined generics<user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`genéricos definidos pelo utilizador<user-defined-"
"generics>` e :class:`typing.Generic`"

#: ../../reference/datamodel.rst:2929
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Documentação sobre como implementar classes genéricas que podem ser "
"parametrizadas em tempo de execução e compreendidas por verificadores de "
"tipo estáticos."

#: ../../reference/datamodel.rst:2932
msgid ""
"A class can *generally* only be parameterized if it defines the special "
"class method ``__class_getitem__()``."
msgstr ""
"Uma classe pode, *geralmente*, ser parametrizada apenas se definir o método "
"especial de classe ``__class_getitem__()``."

#: ../../reference/datamodel.rst:2937
msgid ""
"Return an object representing the specialization of a generic class by type "
"arguments found in *key*."
msgstr ""
"Devolve um objeto que representa a especialização de uma classe genérica por "
"argumentos de tipo encontrados em *key*."

#: ../../reference/datamodel.rst:2940
msgid ""
"When defined on a class, ``__class_getitem__()`` is automatically a class "
"method. As such, there is no need for it to be decorated with :deco:"
"`classmethod` when it is defined."
msgstr ""
"Quando definido numa classe, ``__class_getitem__()`` é automaticamente um "
"método de classe. Como tal, não é necessário decorá-lo com :deco:"
"`classmethod` quando é definido."

#: ../../reference/datamodel.rst:2946
msgid "The purpose of *__class_getitem__*"
msgstr "O propósito de *__class_getitem__*"

#: ../../reference/datamodel.rst:2948
msgid ""
"The purpose of :meth:`~object.__class_getitem__` is to allow runtime "
"parameterization of standard-library generic classes in order to more easily "
"apply :term:`type hints<type hint>` to these classes."
msgstr ""
"O propósito de :meth:`~object.__class_getitem__` é permitir a parametrização "
"em tempo de execução de classes genéricas da biblioteca padrão, de forma a "
"aplicar mais facilmente :term:`dicas de tipo<type hint>` a estas classes."

#: ../../reference/datamodel.rst:2952
msgid ""
"To implement custom generic classes that can be parameterized at runtime and "
"understood by static type-checkers, users should either inherit from a "
"standard library class that already implements :meth:`~object."
"__class_getitem__`, or inherit from :class:`typing.Generic`, which has its "
"own implementation of ``__class_getitem__()``."
msgstr ""
"Para implementar classes genéricas personalizadas que possam ser "
"parametrizadas em tempo de execução e compreendidas por verificadores de "
"tipo estáticos, os utilizadores devem herdar de uma classe da biblioteca "
"padrão que já implemente :meth:`~object.__class_getitem__`, ou herdar de :"
"class:`typing.Generic`, que tem a sua própria implementação de "
"``__class_getitem__()``."

#: ../../reference/datamodel.rst:2958
msgid ""
"Custom implementations of :meth:`~object.__class_getitem__` on classes "
"defined outside of the standard library may not be understood by third-party "
"type-checkers such as mypy. Using ``__class_getitem__()`` on any class for "
"purposes other than type hinting is discouraged."
msgstr ""
"Implementações personalizadas de :meth:`~object.__class_getitem__` em "
"classes definidas fora da biblioteca padrão podem não ser compreendidas por "
"verificadores de tipo de terceiros, como o mypy. O uso de "
"``__class_getitem__()`` em qualquer classe para fins que não sejam dicas de "
"tipo é desencorajado."

#: ../../reference/datamodel.rst:2968
msgid "*__class_getitem__* versus *__getitem__*"
msgstr "*__class_getitem__* versus *__getitem__*"

#: ../../reference/datamodel.rst:2970
msgid ""
"Usually, the :ref:`subscription<subscriptions>` of an object using square "
"brackets will call the :meth:`~object.__getitem__` instance method defined "
"on the object's class. However, if the object being subscribed is itself a "
"class, the class method :meth:`~object.__class_getitem__` may be called "
"instead. ``__class_getitem__()`` should return a :ref:`GenericAlias<types-"
"genericalias>` object if it is properly defined."
msgstr ""
"Normalmente, a :ref:`subscription<subscriptions>` de um objeto usando "
"colchetes chama o método de instância :meth:`~object.__getitem__` definido "
"na classe do objeto. No entanto, se o objeto a ser subscrito for ele próprio "
"uma classe, o método de classe :meth:`~object.__class_getitem__` pode ser "
"chamado em vez disso. ``__class_getitem__()`` deve devolver um objeto :ref:"
"`GenericAlias<types-genericalias>` se estiver corretamente definido."

#: ../../reference/datamodel.rst:2977
msgid ""
"Presented with the :term:`expression` ``obj[x]``, the Python interpreter "
"follows something like the following process to decide whether :meth:"
"`~object.__getitem__` or :meth:`~object.__class_getitem__` should be called::"
msgstr ""
"Perante a :term:`expressão` ``obj[x]``, o interpretador Python segue um "
"processo semelhante ao seguinte para decidir se deve chamar :meth:`~object."
"__getitem__` ou :meth:`~object.__class_getitem__`:"

#: ../../reference/datamodel.rst:2982
msgid ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Return the result of the expression 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # If the class of obj defines __getitem__,\n"
"    # call class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Else, if obj is a class and defines __class_getitem__,\n"
"    # call obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Else, raise an exception\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"'{class_of_obj.__name__}' object is not subscriptable\"\n"
"        )"
msgstr ""
"from inspect import isclass\n"
"\n"
"def subscribe(obj, x):\n"
"    \"\"\"Devolve o resultado da expressão 'obj[x]'\"\"\"\n"
"\n"
"    class_of_obj = type(obj)\n"
"\n"
"    # Se a classe de obj definir __getitem__,\n"
"    # chama class_of_obj.__getitem__(obj, x)\n"
"    if hasattr(class_of_obj, '__getitem__'):\n"
"        return class_of_obj.__getitem__(obj, x)\n"
"\n"
"    # Caso contrário, se obj for uma classe e definir __class_getitem__,\n"
"    # chama obj.__class_getitem__(x)\n"
"    elif isclass(obj) and hasattr(obj, '__class_getitem__'):\n"
"        return obj.__class_getitem__(x)\n"
"\n"
"    # Caso contrário, levanta uma exceção\n"
"    else:\n"
"        raise TypeError(\n"
"            f\"O objeto '{class_of_obj.__name__}' não suporta subscrição\"\n"
"        )"

#: ../../reference/datamodel.rst:3005
msgid ""
"In Python, all classes are themselves instances of other classes. The class "
"of a class is known as that class's :term:`metaclass`, and most classes have "
"the :class:`type` class as their metaclass. :class:`type` does not define :"
"meth:`~object.__getitem__`, meaning that expressions such as ``list[int]``, "
"``dict[str, float]`` and ``tuple[str, bytes]`` all result in :meth:`~object."
"__class_getitem__` being called::"
msgstr ""
"Em Python, todas as classes são elas próprias instâncias de outras classes. "
"A classe de uma classe é conhecida como a :term:`metaclasse` dessa classe, e "
"a maioria das classes tem a classe :class:`type` como sua metaclasse. :class:"
"`type` não define :meth:`~object.__getitem__`, o que significa que "
"expressões como ``list[int]``, ``dict[str, float]`` e ``tuple[str, bytes]`` "
"resultam na chamada de :meth:`~object.__class_getitem__`:"

#: ../../reference/datamodel.rst:3012
msgid ""
">>> # list has class \"type\" as its metaclass, like most classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" calls \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ returns a GenericAlias object:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"
msgstr ""
">>> # list tem a classe \"type\" como sua metaclasse, como a maioria das "
"classes:\n"
">>> type(list)\n"
"<class 'type'>\n"
">>> type(dict) == type(list) == type(tuple) == type(str) == type(bytes)\n"
"True\n"
">>> # \"list[int]\" chama \"list.__class_getitem__(int)\"\n"
">>> list[int]\n"
"list[int]\n"
">>> # list.__class_getitem__ devolve um objeto GenericAlias:\n"
">>> type(list[int])\n"
"<class 'types.GenericAlias'>"

#: ../../reference/datamodel.rst:3024
msgid ""
"However, if a class has a custom metaclass that defines :meth:`~object."
"__getitem__`, subscribing the class may result in different behaviour. An "
"example of this can be found in the :mod:`enum` module::"
msgstr ""
"No entanto, se uma classe tiver uma metaclasse personalizada que defina :"
"meth:`~object.__getitem__`, subscrever a classe pode resultar em "
"comportamento diferente. Um exemplo disto pode ser encontrado no módulo :mod:"
"`enum`:"

#: ../../reference/datamodel.rst:3028
msgid ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"A breakfast menu\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # Enum classes have a custom metaclass:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta defines __getitem__,\n"
">>> # so __class_getitem__ is not called,\n"
">>> # and the result is not a GenericAlias object:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"
msgstr ""
">>> from enum import Enum\n"
">>> class Menu(Enum):\n"
"...     \"\"\"Um menu de pequeno-almoço\"\"\"\n"
"...     SPAM = 'spam'\n"
"...     BACON = 'bacon'\n"
"...\n"
">>> # As classes Enum têm uma metaclasse personalizada:\n"
">>> type(Menu)\n"
"<class 'enum.EnumMeta'>\n"
">>> # EnumMeta define __getitem__,\n"
">>> # então __class_getitem__ não é chamado,\n"
">>> # e o resultado não é um objeto GenericAlias:\n"
">>> Menu['SPAM']\n"
"<Menu.SPAM: 'spam'>\n"
">>> type(Menu['SPAM'])\n"
"<enum 'Menu'>"

#: ../../reference/datamodel.rst:3047
msgid ":pep:`560` - Core Support for typing module and generic types"
msgstr ":pep:`560` - Suporte central para o módulo typing e tipos genéricos"

#: ../../reference/datamodel.rst:3048
msgid ""
"Introducing :meth:`~object.__class_getitem__`, and outlining when a :ref:"
"`subscription<subscriptions>` results in ``__class_getitem__()`` being "
"called instead of :meth:`~object.__getitem__`"
msgstr ""
"Apresentação de :meth:`~object.__class_getitem__`, e descrição de quando "
"uma :ref:`subscription<subscriptions>` resulta na chamada de "
"``__class_getitem__()`` em vez de :meth:`~object.__getitem__`"

#: ../../reference/datamodel.rst:3056
msgid "Emulating callable objects"
msgstr "Emulação de objetos chamáveis"

#: ../../reference/datamodel.rst:3063
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` roughly translates to ``type(x).__call__(x, "
"arg1, ...)``. The :class:`object` class itself does not provide this method."
msgstr ""
"Chamado quando a instância é \"chamada\" como uma função; se este método "
"estiver definido, ``x(arg1, arg2, ...)`` é aproximadamente traduzido para "
"``type(x).__call__(x, arg1, ...)``. A classe :class:`object` em si não "
"fornece este método."

#: ../../reference/datamodel.rst:3071
msgid "Emulating container types"
msgstr "Emulação de tipos de contentor"

#: ../../reference/datamodel.rst:3073
msgid ""
"The following methods can be defined to implement container objects. None of "
"them are provided by the :class:`object` class itself. Containers usually "
"are :term:`sequences <sequence>` (such as :class:`lists <list>` or :class:"
"`tuples <tuple>`) or :term:`mappings <mapping>` (like :term:`dictionaries "
"<dictionary>`), but can represent other containers as well.  The first set "
"of methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or :"
"class:`slice` objects, which define a range of items.  It is also "
"recommended that mappings provide the methods :meth:`!keys`, :meth:`!"
"values`, :meth:`!items`, :meth:`!get`, :meth:`!clear`, :meth:`!setdefault`, :"
"meth:`!pop`, :meth:`!popitem`, :meth:`!copy`, and :meth:`!update` behaving "
"similar to those for Python's standard :class:`dictionary <dict>` objects.  "
"The :mod:`collections.abc` module provides a :class:`~collections.abc."
"MutableMapping` :term:`abstract base class` to help create those methods "
"from a base set of :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__`, and :meth:`!keys`."
msgstr ""
"Os seguintes métodos podem ser definidos para implementar objetos contentor. "
"Nenhum deles é fornecido pela classe :class:`object` em si. Os contentores "
"são geralmente :term:`sequências<sequence>` (como :class:`lists <list>` ou :"
"class:`tuples <tuple>`) ou :term:`mappings <mapping>` (como :term:"
"`dictionaries <dictionary>`), mas podem representar outros tipos de "
"contentores. O primeiro conjunto de métodos é usado para emular uma "
"sequência ou um mapeamento; a diferença é que, para uma sequência, as chaves "
"permitidas devem ser os inteiros *k* para os quais ``0 <= k < N``, onde *N* "
"é o comprimento da sequência, ou objetos :class:`slice`, que definem um "
"intervalo de itens. Também é recomendado que os mapeamentos forneçam os "
"métodos :meth:`!keys`, :meth:`!values`, :meth:`!items`, :meth:`!get`, :meth:"
"`!clear`, :meth:`!setdefault`, :meth:`!pop`, :meth:`!popitem`, :meth:`!copy` "
"e :meth:`!update`, comportando-se de forma semelhante aos objetos :class:"
"`dictionary <dict>` padrão do Python. O módulo :mod:`collections.abc` "
"fornece uma :term:`classe base abstrata` :class:`~collections.abc."
"MutableMapping` para ajudar a criar esses métodos a partir de um conjunto "
"base de :meth:`~object.__getitem__`, :meth:`~object.__setitem__`, :meth:"
"`~object.__delitem__` e :meth:`!keys`."

#: ../../reference/datamodel.rst:3092
msgid ""
"Mutable sequences should provide methods :meth:`~sequence.append`, :meth:"
"`~sequence.clear`, :meth:`~sequence.count`, :meth:`~sequence.extend`, :meth:"
"`~sequence.index`, :meth:`~sequence.insert`, :meth:`~sequence.pop`, :meth:"
"`~sequence.remove`, and :meth:`~sequence.reverse`, like Python standard :"
"class:`list` objects. Finally, sequence types should implement addition "
"(meaning concatenation) and multiplication (meaning repetition) by defining "
"the methods :meth:`~object.__add__`, :meth:`~object.__radd__`, :meth:"
"`~object.__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` and :"
"meth:`~object.__imul__` described below; they should not define other "
"numerical operators."
msgstr ""
"As sequências mutáveis devem fornecer os métodos :meth:`~sequence.append`, :"
"meth:`~sequence.clear`, :meth:`~sequence.count`, :meth:`~sequence.extend`, :"
"meth:`~sequence.index`, :meth:`~sequence.insert`, :meth:`~sequence.pop`, :"
"meth:`~sequence.remove` e :meth:`~sequence.reverse`, como os objetos :class:"
"`list` padrão do Python. Finalmente, os tipos de sequência devem implementar "
"adição (significando concatenação) e multiplicação (significando repetição) "
"definindo os métodos :meth:`~object.__add__`, :meth:`~object.__radd__`, :"
"meth:`~object.__iadd__`, :meth:`~object.__mul__`, :meth:`~object.__rmul__` "
"e :meth:`~object.__imul__` descritos abaixo; não devem definir outros "
"operadores numéricos."

#: ../../reference/datamodel.rst:3104
msgid ""
"It is recommended that both mappings and sequences implement the :meth:"
"`~object.__contains__` method to allow efficient use of the ``in`` operator; "
"for mappings, ``in`` should search the mapping's keys; for sequences, it "
"should search through the values.  It is further recommended that both "
"mappings and sequences implement the :meth:`~object.__iter__` method to "
"allow efficient iteration through the container; for mappings, :meth:`!"
"__iter__` should iterate through the object's keys; for sequences, it should "
"iterate through the values."
msgstr ""
"Recomenda-se que tanto mapeamentos como sequências implementem o método :"
"meth:`~object.__contains__` para permitir o uso eficiente do operador "
"``in``; para mapeamentos, ``in`` deve procurar nas chaves do mapeamento; "
"para sequências, deve procurar nos valores. Recomenda-se ainda que tanto "
"mapeamentos como sequências implementem o método :meth:`~object.__iter__` "
"para permitir uma iteração eficiente através do contentor; para "
"mapeamentos, :meth:`!__iter__` deve iterar através das chaves do objeto; "
"para sequências, deve iterar através dos valores."

#: ../../reference/datamodel.rst:3119
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`~object.__bool__` method and whose :meth:`!__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""
"Chamado para implementar a função integrada :func:`len`. Deve devolver o "
"comprimento do objeto, um inteiro ``>=`` 0. Além disso, um objeto que não "
"define um método :meth:`~object.__bool__` e cujo método :meth:`!__len__` "
"devolve zero é considerado falso num contexto booleano."

#: ../../reference/datamodel.rst:3126
msgid ""
"In CPython, the length is required to be at most :data:`sys.maxsize`. If the "
"length is larger than :data:`!sys.maxsize` some features (such as :func:"
"`len`) may raise :exc:`OverflowError`.  To prevent raising :exc:`!"
"OverflowError` by truth value testing, an object must define a :meth:"
"`~object.__bool__` method."
msgstr ""
"No CPython, o comprimento é limitado a :data:`sys.maxsize`. Se o comprimento "
"for maior que :data:`!sys.maxsize`, algumas funcionalidades (como :func:"
"`len`) podem levantar uma exceção :exc:`OverflowError`. Para evitar que :exc:"
"`!OverflowError` seja levantada durante um teste de valor lógico, um objeto "
"deve definir um método :meth:`~object.__bool__`."

#: ../../reference/datamodel.rst:3135
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. The return value may also be :data:"
"`NotImplemented`, which is treated the same as if the ``__length_hint__`` "
"method didn't exist at all. This method is purely an optimization and is "
"never required for correctness."
msgstr ""
"Chamado para implementar :func:`operator.length_hint`. Deve devolver um "
"comprimento estimado para o objeto (que pode ser maior ou menor que o "
"comprimento real). O comprimento deve ser um inteiro ``>=`` 0. O valor "
"devolvido também pode ser :data:`NotImplemented`, que é tratado da mesma "
"forma como se o método ``__length_hint__`` não existisse. Este método é "
"puramente uma otimização e nunca é obrigatório para a correção."

#: ../../reference/datamodel.rst:3149
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""
"O fatiamento é feito exclusivamente com os seguintes três métodos. Uma "
"chamada como:"

#: ../../reference/datamodel.rst:3151
msgid "a[1:2] = b"
msgstr "a[1:2] = b"

#: ../../reference/datamodel.rst:3153
msgid "is translated to ::"
msgstr "é traduzido para:"

#: ../../reference/datamodel.rst:3155
msgid "a[slice(1, 2, None)] = b"
msgstr "a[slice(1, 2, None)] = b"

#: ../../reference/datamodel.rst:3157
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr ""
"e assim por diante. Os itens de fatia em falta são sempre preenchidos com "
"``None``."

#: ../../reference/datamodel.rst:3162
msgid ""
"Called to implement evaluation of ``self[key]``. For :term:`sequence` types, "
"the accepted keys should be integers. Optionally, they may support :class:"
"`slice` objects as well.  Negative index support is also optional. If *key* "
"is of an inappropriate type, :exc:`TypeError` may be raised; if *key* is a "
"value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. For :"
"term:`mapping` types, if *key* is missing (not in the container), :exc:"
"`KeyError` should be raised."
msgstr ""
"Chamado para implementar a avaliação de ``self[key]``. Para tipos :term:"
"`sequência`, as chaves aceites devem ser inteiros. Opcionalmente, podem "
"também suportar objetos :class:`slice`. O suporte para índices negativos "
"também é opcional. Se *key* for de um tipo inadequado, pode ser levantada "
"uma exceção :exc:`TypeError`; se *key* for um valor fora do conjunto de "
"índices para a sequência (após qualquer interpretação especial de valores "
"negativos), deve ser levantada uma exceção :exc:`IndexError`. Para tipos :"
"term:`mapeamento`, se *key* estiver em falta (não estiver no contentor), "
"deve ser levantada uma exceção :exc:`KeyError`."

#: ../../reference/datamodel.rst:3174
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
"Os ciclos :keyword:`for` esperam que uma exceção :exc:`IndexError` seja "
"levantada para índices ilegais, de forma a permitir a deteção adequada do "
"fim da sequência."

#: ../../reference/datamodel.rst:3179
msgid ""
"When :ref:`subscripting<subscriptions>` a *class*, the special class method :"
"meth:`~object.__class_getitem__` may be called instead of ``__getitem__()``. "
"See :ref:`classgetitem-versus-getitem` for more details."
msgstr ""
"Ao :ref:`subscripting<subscriptions>` uma *classe*, o método especial de "
"classe :meth:`~object.__class_getitem__` pode ser chamado em vez de "
"``__getitem__()``. Veja :ref:`classgetitem-versus-getitem` para mais "
"detalhes."

#: ../../reference/datamodel.rst:3187
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"Chamado para implementar a atribuição a ``self[key]``. A mesma nota aplica-"
"se a :meth:`__getitem__`. Isto só deve ser implementado para mapeamentos se "
"os objetos suportarem alterações aos valores das chaves, ou se novas chaves "
"puderem ser adicionadas, ou para sequências se os elementos puderem ser "
"substituídos. As mesmas exceções devem ser levantadas para valores de *key* "
"impróprios, como no método :meth:`__getitem__`."

#: ../../reference/datamodel.rst:3196
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""
"Chamado para implementar a eliminação de ``self[key]``. A mesma nota aplica-"
"se a :meth:`__getitem__`. Isto só deve ser implementado para mapeamentos se "
"os objetos suportarem a remoção de chaves, ou para sequências se os "
"elementos puderem ser removidos da sequência. As mesmas exceções devem ser "
"levantadas para valores de *key* impróprios, como no método :meth:"
"`__getitem__`."

#: ../../reference/datamodel.rst:3205
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""
"Chamado por :class:`dict`\\ .\\ :meth:`__getitem__` para implementar "
"``self[key]`` para subclasses de dicionário quando a chave não está no "
"dicionário."

#: ../../reference/datamodel.rst:3211
msgid ""
"This method is called when an :term:`iterator` is required for a container. "
"This method should return a new iterator object that can iterate over all "
"the objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"Este método é chamado quando um :term:`iterador` é necessário para um "
"contentor. Este método deve devolver um novo objeto iterador que pode iterar "
"sobre todos os objetos no contentor. Para mapeamentos, deve iterar sobre as "
"chaves do contentor."

#: ../../reference/datamodel.rst:3219
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""
"Chamado (se presente) pela função integrada :func:`reversed` para "
"implementar iteração reversa. Deve devolver um novo objeto iterador que "
"itera sobre todos os objetos no contentor em ordem inversa."

#: ../../reference/datamodel.rst:3223
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""
"Se o método :meth:`__reversed__` não for fornecido, a função integrada :func:"
"`reversed` recorrerá ao uso do protocolo de sequência (:meth:`__len__` e :"
"meth:`__getitem__`). Os objetos que suportam o protocolo de sequência só "
"devem fornecer :meth:`__reversed__` se puderem fornecer uma implementação "
"mais eficiente do que a fornecida por :func:`reversed`."

#: ../../reference/datamodel.rst:3230
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a container. However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be iterable."
msgstr ""
"Os operadores de teste de pertença (:keyword:`in` e :keyword:`not in`) são "
"normalmente implementados como uma iteração através de um contentor. No "
"entanto, os objetos contentor podem fornecer o seguinte método especial com "
"uma implementação mais eficiente, que também não requer que o objeto seja "
"iterável."

#: ../../reference/datamodel.rst:3237
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""
"Chamado para implementar operadores de teste de pertença. Deve devolver "
"verdadeiro se *item* estiver em *self*, falso caso contrário. Para objetos "
"de mapeamento, isto deve considerar as chaves do mapeamento em vez dos "
"valores ou dos pares chave-item."

#: ../../reference/datamodel.rst:3241
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""
"Para objetos que não definem :meth:`__contains__`, o teste de pertença tenta "
"primeiro a iteração através de :meth:`__iter__`, depois o antigo protocolo "
"de iteração de sequência através de :meth:`__getitem__`, veja :ref:`esta "
"secção na referência da linguagem <membership-test-details>`."

#: ../../reference/datamodel.rst:3250
msgid "Emulating numeric types"
msgstr "Emulação de tipos numéricos"

#: ../../reference/datamodel.rst:3252
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""
"Os seguintes métodos podem ser definidos para emular objetos numéricos. "
"Métodos correspondentes a operações que não são suportadas pelo tipo "
"específico de número implementado (por exemplo, operações bit a bit para "
"números não inteiros) devem ser deixados indefinidos."

#: ../../reference/datamodel.rst:3278
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to "
"evaluate the expression ``x + y``, where *x* is an instance of a class that "
"has an :meth:`__add__` method, ``type(x).__add__(x, y)`` is called.  The :"
"meth:`__divmod__` method should be the equivalent to using :meth:"
"`__floordiv__` and :meth:`__mod__`; it should not be related to :meth:"
"`__truediv__`.  Note that :meth:`__pow__` should be defined to accept an "
"optional third argument if the ternary version of the built-in :func:`pow` "
"function is to be supported."
msgstr ""

#: ../../reference/datamodel.rst:3289
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return :data:`NotImplemented`."
msgstr ""
"Se um desses métodos não suportar a operação com os argumentos fornecidos, "
"deve devolver :data:`NotImplemented`."

#: ../../reference/datamodel.rst:3312
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, :func:"
"`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands.  These functions are only called if the left operand does not "
"support the corresponding operation [#]_ and the operands are of different "
"types. [#]_ For instance, to evaluate the expression ``x - y``, where *y* is "
"an instance of a class that has an :meth:`__rsub__` method, ``type(y)."
"__rsub__(y, x)`` is called if ``type(x).__sub__(x, y)`` returns :data:"
"`NotImplemented`."
msgstr ""

#: ../../reference/datamodel.rst:3324
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""

#: ../../reference/datamodel.rst:3329
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides a different implementation of the reflected method "
"for the operation, this method will be called before the left operand's non-"
"reflected method. This behavior allows subclasses to override their "
"ancestors' operations."
msgstr ""
"Se o tipo do operando direito for uma subclasse do tipo do operando esquerdo "
"e essa subclasse fornecer uma implementação diferente do método refletido "
"para a operação, este método será chamado antes do método não refletido do "
"operando esquerdo. Este comportamento permite que as subclasses substituam "
"as operações dos seus ancestrais."

#: ../../reference/datamodel.rst:3350
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, "
"``>>=``, ``&=``, ``^=``, ``|=``).  These methods should attempt to do the "
"operation in-place (modifying *self*) and return the result (which could be, "
"but does not have to be, *self*).  If a specific method is not defined, or "
"if that method returns :data:`NotImplemented`, the augmented assignment "
"falls back to the normal methods.  For instance, if *x* is an instance of a "
"class with an :meth:`__iadd__` method, ``x += y`` is equivalent to ``x = x."
"__iadd__(y)`` . If :meth:`__iadd__` does not exist, or if ``x.__iadd__(y)`` "
"returns :data:`!NotImplemented`, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of the "
"data model."
msgstr ""
"Estes métodos são chamados para implementar as atribuições aritméticas "
"aumentadas (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``). Estes métodos devem "
"tentar realizar a operação no local (modificando *self*) e devolver o "
"resultado (que pode ser, mas não tem de ser, *self*). Se um método "
"específico não estiver definido, ou se esse método devolver :data:"
"`NotImplemented`, a atribuição aumentada recorre aos métodos normais. Por "
"exemplo, se *x* for uma instância de uma classe com um método :meth:"
"`__iadd__`, ``x += y`` é equivalente a ``x = x.__iadd__(y)``. Se :meth:"
"`__iadd__` não existir, ou se ``x.__iadd__(y)`` devolver :data:`!"
"NotImplemented`, ``x.__add__(y)`` e ``y.__radd__(x)`` são considerados, como "
"na avaliação de ``x + y``. Em certas situações, a atribuição aumentada pode "
"resultar em erros inesperados (veja :ref:`faq-augmented-assignment-tuple-"
"error`), mas este comportamento faz de facto parte do modelo de dados."

#: ../../reference/datamodel.rst:3373
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""
"Chamado para implementar as operações aritméticas unárias (``-``, ``+``, :"
"func:`abs` e ``~``)."

#: ../../reference/datamodel.rst:3386
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` and :"
"func:`float`.  Should return a value of the appropriate type."
msgstr ""
"Chamado para implementar as funções integradas :func:`complex`, :func:`int` "
"e :func:`float`. Deve devolver um valor do tipo apropriado."

#: ../../reference/datamodel.rst:3393
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""
"Chamado para implementar :func:`operator.index`, e sempre que o Python "
"necessitar de converter o objeto numérico para um objeto inteiro sem perda "
"de dados (como em fatiamento, ou nas funções integradas :func:`bin`, :func:"
"`hex` e :func:`oct`). A presença deste método indica que o objeto numérico é "
"de um tipo inteiro. Deve devolver um inteiro."

#: ../../reference/datamodel.rst:3399
msgid ""
"If :meth:`__int__`, :meth:`__float__` and :meth:`__complex__` are not "
"defined then corresponding built-in functions :func:`int`, :func:`float` "
"and :func:`complex` fall back to :meth:`__index__`."
msgstr ""
"Se :meth:`__int__`, :meth:`__float__` e :meth:`__complex__` não estiverem "
"definidos, as funções integradas correspondentes :func:`int`, :func:`float` "
"e :func:`complex` recorrem a :meth:`__index__`."

#: ../../reference/datamodel.rst:3411
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and :func:`~math.ceil`. "
"Unless *ndigits* is passed to :meth:`!__round__` all these methods should "
"return the value of the object truncated to an :class:`~numbers.Integral` "
"(typically an :class:`int`)."
msgstr ""
"Chamado para implementar a função integrada :func:`round` e as funções :mod:"
"`math` :func:`~math.trunc`, :func:`~math.floor` e :func:`~math.ceil`. A "
"menos que *ndigits* seja passado para :meth:`!__round__`, todos estes "
"métodos devem devolver o valor do objeto truncado para um :class:`~numbers."
"Integral` (tipicamente um :class:`int`)."

#: ../../reference/datamodel.rst:3417
msgid ""
"The built-in function :func:`int` falls back to :meth:`__trunc__` if "
"neither :meth:`__int__` nor :meth:`__index__` is defined."
msgstr ""

#: ../../reference/datamodel.rst:3420
msgid "The delegation of :func:`int` to :meth:`__trunc__` is deprecated."
msgstr ""

#: ../../reference/datamodel.rst:3427
msgid "With Statement Context Managers"
msgstr "Gestores de Contexto com a Instrução With"

#: ../../reference/datamodel.rst:3429
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`!with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""
"Um :dfn:`gestor de contexto` é um objeto que define o contexto de execução a "
"ser estabelecido ao executar uma instrução :keyword:`with`. O gestor de "
"contexto trata da entrada e saída do contexto de execução desejado para a "
"execução do bloco de código. Os gestores de contexto são normalmente "
"invocados usando a instrução :keyword:`!with` (descrita na secção :ref:"
"`with`), mas também podem ser usados invocando diretamente os seus métodos."

#: ../../reference/datamodel.rst:3440
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""
"Usos típicos de gestores de contexto incluem guardar e restaurar vários "
"tipos de estado global, bloquear e desbloquear recursos, fechar ficheiros "
"abertos, etc."

#: ../../reference/datamodel.rst:3443
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`. "
"The :class:`object` class itself does not provide the context manager "
"methods."
msgstr ""
"Para mais informações sobre gestores de contexto, veja :ref:"
"`typecontextmanager`. A classe :class:`object` em si não fornece os métodos "
"de gestor de contexto."

#: ../../reference/datamodel.rst:3449
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`!as` clause of the statement, if any."
msgstr ""
"Entrar no contexto de execução relacionado com este objeto. A instrução :"
"keyword:`with` ligará o valor de retorno deste método ao(s) alvo(s) "
"especificado(s) na cláusula :keyword:`!as` da instrução, se existir algum."

#: ../../reference/datamodel.rst:3456
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""
"Sair do contexto de execução relacionado com este objeto. Os parâmetros "
"descrevem a exceção que causou a saída do contexto. Se o contexto foi saído "
"sem uma exceção, todos os três argumentos serão :const:`None`."

#: ../../reference/datamodel.rst:3460
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""
"Se uma exceção for fornecida e o método pretender suprimir a exceção (ou "
"seja, evitar que seja propagada), deve devolver um valor verdadeiro. Caso "
"contrário, a exceção será processada normalmente ao sair deste método."

#: ../../reference/datamodel.rst:3464
msgid ""
"Note that :meth:`~object.__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
"Note que os métodos :meth:`~object.__exit__` não devem relançar a exceção "
"passada; esta é a responsabilidade do chamador."

#: ../../reference/datamodel.rst:3470
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - A instrução 'with'"

#: ../../reference/datamodel.rst:3471
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"A especificação, contexto e exemplos para a instrução :keyword:`with` do "
"Python."

#: ../../reference/datamodel.rst:3478
msgid "Customizing positional arguments in class pattern matching"
msgstr ""
"Personalização de argumentos posicionais em correspondência de padrões de "
"classe"

#: ../../reference/datamodel.rst:3480
msgid ""
"When using a class name in a pattern, positional arguments in the pattern "
"are not allowed by default, i.e. ``case MyClass(x, y)`` is typically invalid "
"without special support in ``MyClass``. To be able to use that kind of "
"pattern, the class needs to define a *__match_args__* attribute."
msgstr ""
"Ao usar um nome de classe num padrão, os argumentos posicionais no padrão "
"não são permitidos por predefinição, ou seja, ``case MyClass(x, y)`` é "
"tipicamente inválido sem suporte especial em ``MyClass``. Para poder usar "
"esse tipo de padrão, a classe precisa definir um atributo *__match_args__*."

#: ../../reference/datamodel.rst:3487
msgid ""
"This class variable can be assigned a tuple of strings. When this class is "
"used in a class pattern with positional arguments, each positional argument "
"will be converted into a keyword argument, using the corresponding value in "
"*__match_args__* as the keyword. The absence of this attribute is equivalent "
"to setting it to ``()``."
msgstr ""
"Esta variável de classe pode ser atribuída a um tuplo de strings. Quando "
"esta classe é usada num padrão de classe com argumentos posicionais, cada "
"argumento posicional será convertido num argumento de palavra-chave, usando "
"o valor correspondente em *__match_args__* como palavra-chave. A ausência "
"deste atributo é equivalente a defini-lo como ``()``."

#: ../../reference/datamodel.rst:3493
msgid ""
"For example, if ``MyClass.__match_args__`` is ``(\"left\", \"center\", "
"\"right\")`` that means that ``case MyClass(x, y)`` is equivalent to ``case "
"MyClass(left=x, center=y)``. Note that the number of arguments in the "
"pattern must be smaller than or equal to the number of elements in "
"*__match_args__*; if it is larger, the pattern match attempt will raise a :"
"exc:`TypeError`."
msgstr ""
"Por exemplo, se ``MyClass.__match_args__`` for ``(\"left\", \"center\", "
"\"right\")``, isso significa que ``case MyClass(x, y)`` é equivalente a "
"``case MyClass(left=x, center=y)``. Note que o número de argumentos no "
"padrão deve ser menor ou igual ao número de elementos em *__match_args__*; "
"se for maior, a tentativa de correspondência de padrão levantará uma "
"exceção :exc:`TypeError`."

#: ../../reference/datamodel.rst:3503
msgid ":pep:`634` - Structural Pattern Matching"
msgstr ":pep:`634` - Correspondência de Padrões Estruturais"

#: ../../reference/datamodel.rst:3504
msgid "The specification for the Python ``match`` statement."
msgstr "A especificação para a instrução ``match`` do Python."

#: ../../reference/datamodel.rst:3510
msgid "Emulating buffer types"
msgstr "Emulação de tipos de buffer"

#: ../../reference/datamodel.rst:3512
msgid ""
"The :ref:`buffer protocol <bufferobjects>` provides a way for Python objects "
"to expose efficient access to a low-level memory array. This protocol is "
"implemented by builtin types such as :class:`bytes` and :class:`memoryview`, "
"and third-party libraries may define additional buffer types."
msgstr ""
"O :ref:`protocolo de buffer<bufferobjects>` fornece uma forma de os objetos "
"Python exporem acesso eficiente a um array de memória de baixo nível. Este "
"protocolo é implementado por tipos integrados como :class:`bytes` e :class:"
"`memoryview`, e bibliotecas de terceiros podem definir tipos de buffer "
"adicionais."

#: ../../reference/datamodel.rst:3517
msgid ""
"While buffer types are usually implemented in C, it is also possible to "
"implement the protocol in Python."
msgstr ""
"Embora os tipos de buffer sejam geralmente implementados em C, também é "
"possível implementar o protocolo em Python."

#: ../../reference/datamodel.rst:3522
msgid ""
"Called when a buffer is requested from *self* (for example, by the :class:"
"`memoryview` constructor). The *flags* argument is an integer representing "
"the kind of buffer requested, affecting for example whether the returned "
"buffer is read-only or writable. :class:`inspect.BufferFlags` provides a "
"convenient way to interpret the flags. The method must return a :class:"
"`memoryview` object."
msgstr ""
"Chamado quando um buffer é solicitado de *self* (por exemplo, pelo "
"construtor :class:`memoryview`). O argumento *flags* é um inteiro que "
"representa o tipo de buffer solicitado, afetando, por exemplo, se o buffer "
"devolvido é apenas de leitura ou gravável. :class:`inspect.BufferFlags` "
"fornece uma forma conveniente de interpretar as flags. O método deve "
"devolver um objeto :class:`memoryview`."

#: ../../reference/datamodel.rst:3531
msgid ""
"Called when a buffer is no longer needed. The *buffer* argument is a :class:"
"`memoryview` object that was previously returned by :meth:`~object."
"__buffer__`. The method must release any resources associated with the "
"buffer. This method should return ``None``. Buffer objects that do not need "
"to perform any cleanup are not required to implement this method."
msgstr ""
"Chamado quando um buffer já não é necessário. O argumento *buffer* é um "
"objeto :class:`memoryview` que foi previamente devolvido por :meth:`~object."
"__buffer__`. O método deve libertar quaisquer recursos associados ao buffer. "
"Este método deve devolver ``None``. Objetos de buffer que não precisam de "
"realizar qualquer limpeza não são obrigados a implementar este método."

#: ../../reference/datamodel.rst:3542
msgid ":pep:`688` - Making the buffer protocol accessible in Python"
msgstr ":pep:`688` - Tornar o protocolo de buffer acessível em Python"

#: ../../reference/datamodel.rst:3543
msgid ""
"Introduces the Python ``__buffer__`` and ``__release_buffer__`` methods."
msgstr "Introduz os métodos Python ``__buffer__`` e ``__release_buffer__``."

#: ../../reference/datamodel.rst:3545
msgid ":class:`collections.abc.Buffer`"
msgstr ":class:`collections.abc.Buffer`"

#: ../../reference/datamodel.rst:3546
msgid "ABC for buffer types."
msgstr "ABC para tipos de buffer."

#: ../../reference/datamodel.rst:3551
msgid "Special method lookup"
msgstr "Pesquisa de métodos especiais"

#: ../../reference/datamodel.rst:3553
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"Para classes personalizadas, as invocações implícitas de métodos especiais "
"só são garantidas como funcionando corretamente se definidas no tipo de um "
"objeto, não no dicionário de instância do objeto. Esse comportamento é a "
"razão pela qual o seguinte código levanta uma exceção:"

#: ../../reference/datamodel.rst:3558
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"
msgstr ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> c.__len__ = lambda: 5\n"
">>> len(c)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: object of type 'C' has no len()"

#: ../../reference/datamodel.rst:3568
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`~object.__hash__` and :meth:`~object.__repr__` that are "
"implemented by all objects, including type objects. If the implicit lookup "
"of these methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"A racionalidade por trás deste comportamento está relacionada com vários "
"métodos especiais, como :meth:`~object.__hash__` e :meth:`~object.__repr__`, "
"que são implementados por todos os objetos, incluindo objetos de tipo. Se a "
"pesquisa implícita destes métodos usasse o processo de pesquisa "
"convencional, falhariam quando invocados no próprio objeto de tipo:"

#: ../../reference/datamodel.rst:3575
msgid ""
">>> 1 .__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"
msgstr ""
">>> 1.__hash__() == hash(1)\n"
"True\n"
">>> int.__hash__() == hash(int)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: descriptor '__hash__' of 'int' object needs an argument"

#: ../../reference/datamodel.rst:3582
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""
"Tentar incorretamente invocar um método não ligado de uma classe desta forma "
"é por vezes referido como 'confusão de metaclasse', e é evitado contornando "
"a instância ao pesquisar métodos especiais:"

#: ../../reference/datamodel.rst:3586
msgid ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"
msgstr ""
">>> type(1).__hash__(1) == hash(1)\n"
"True\n"
">>> type(int).__hash__(int) == hash(int)\n"
"True"

#: ../../reference/datamodel.rst:3591
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`~object.__getattribute__` method even of the object's metaclass::"
msgstr ""
"Além de contornar quaisquer atributos de instância em prol da correção, a "
"pesquisa implícita de métodos especiais geralmente também contorna o método :"
"meth:`~object.__getattribute__`, mesmo da metaclasse do objeto:"

#: ../../reference/datamodel.rst:3595
msgid ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Explicit lookup via instance\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Explicit lookup via type\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Implicit lookup\n"
"10"
msgstr ""
">>> class Meta(type):\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Metaclass getattribute invoked\")\n"
"...         return type.__getattribute__(*args)\n"
"...\n"
">>> class C(object, metaclass=Meta):\n"
"...     def __len__(self):\n"
"...         return 10\n"
"...     def __getattribute__(*args):\n"
"...         print(\"Class getattribute invoked\")\n"
"...         return object.__getattribute__(*args)\n"
"...\n"
">>> c = C()\n"
">>> c.__len__()                 # Pesquisa explícita via instância\n"
"Class getattribute invoked\n"
"10\n"
">>> type(c).__len__(c)          # Pesquisa explícita via tipo\n"
"Metaclass getattribute invoked\n"
"10\n"
">>> len(c)                      # Pesquisa implícita\n"
"10"

#: ../../reference/datamodel.rst:3617
msgid ""
"Bypassing the :meth:`~object.__getattribute__` machinery in this fashion "
"provides significant scope for speed optimisations within the interpreter, "
"at the cost of some flexibility in the handling of special methods (the "
"special method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"Contornar a maquinaria :meth:`~object.__getattribute__` desta forma fornece "
"um âmbito significativo para otimizações de velocidade dentro do "
"interpretador, à custa de alguma flexibilidade no tratamento de métodos "
"especiais (o método especial *deve* ser definido no próprio objeto de classe "
"para ser invocado consistentemente pelo interpretador)."

#: ../../reference/datamodel.rst:3628
msgid "Coroutines"
msgstr "Corrotinas"

#: ../../reference/datamodel.rst:3632
msgid "Awaitable Objects"
msgstr "Objetos Aguardáveis"

#: ../../reference/datamodel.rst:3634
msgid ""
"An :term:`awaitable` object generally implements an :meth:`~object."
"__await__` method. :term:`Coroutine objects <coroutine>` returned from :"
"keyword:`async def` functions are awaitable."
msgstr ""
"Um objeto :term:`aguardável` implementa geralmente um método :meth:`~object."
"__await__`. Os :term:`objetos corrotina<coroutine>` devolvidos por funções :"
"keyword:`async def` são aguardáveis."

#: ../../reference/datamodel.rst:3640
msgid ""
"The :term:`generator iterator` objects returned from generators decorated "
"with :func:`types.coroutine` are also awaitable, but they do not implement :"
"meth:`~object.__await__`."
msgstr ""
"Os objetos :term:`iterador de gerador` devolvidos por geradores decorados "
"com :func:`types.coroutine` também são aguardáveis, mas não implementam :"
"meth:`~object.__await__`."

#: ../../reference/datamodel.rst:3646
msgid ""
"Must return an :term:`iterator`.  Should be used to implement :term:"
"`awaitable` objects.  For instance, :class:`asyncio.Future` implements this "
"method to be compatible with the :keyword:`await` expression. The :class:"
"`object` class itself is not awaitable and does not provide this method."
msgstr ""
"Deve devolver um :term:`iterador`. Deve ser usado para implementar objetos :"
"term:`aguardáveis`. Por exemplo, :class:`asyncio.Future` implementa este "
"método para ser compatível com a expressão :keyword:`await`. A classe :class:"
"`object` em si não é aguardável e não fornece este método."

#: ../../reference/datamodel.rst:3654
msgid ""
"The language doesn't place any restriction on the type or value of the "
"objects yielded by the iterator returned by ``__await__``, as this is "
"specific to the implementation of the asynchronous execution framework (e."
"g. :mod:`asyncio`) that will be managing the :term:`awaitable` object."
msgstr ""
"A linguagem não impõe quaisquer restrições ao tipo ou valor dos objetos "
"produzidos pelo iterador devolvido por ``__await__``, pois isto é específico "
"da implementação do framework de execução assíncrona (por exemplo, :mod:"
"`asyncio`) que irá gerir o objeto :term:`aguardável`."

#: ../../reference/datamodel.rst:3662
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` para informações adicionais sobre objetos aguardáveis."

#: ../../reference/datamodel.rst:3668
msgid "Coroutine Objects"
msgstr "Objetos corrotina"

#: ../../reference/datamodel.rst:3670
msgid ""
":term:`Coroutine objects <coroutine>` are :term:`awaitable` objects. A "
"coroutine's execution can be controlled by calling :meth:`~object.__await__` "
"and iterating over the result.  When the coroutine has finished executing "
"and returns, the iterator raises :exc:`StopIteration`, and the exception's :"
"attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  Coroutines "
"should not directly raise unhandled :exc:`StopIteration` exceptions."
msgstr ""
"Os :term:`objetos corrotina<coroutine>` são objetos :term:`aguardáveis`. A "
"execução de uma corrotina pode ser controlada chamando :meth:`~object."
"__await__` e iterando sobre o resultado. Quando a corrotina terminar a "
"execução e devolver um valor, o iterador levanta :exc:`StopIteration`, e o "
"atributo :attr:`~StopIteration.value` da exceção contém o valor de retorno. "
"Se a corrotina levantar uma exceção, esta é propagada pelo iterador. As "
"corrotinas não devem levantar diretamente exceções :exc:`StopIteration` não "
"tratadas."

#: ../../reference/datamodel.rst:3678
msgid ""
"Coroutines also have the methods listed below, which are analogous to those "
"of generators (see :ref:`generator-methods`).  However, unlike generators, "
"coroutines do not directly support iteration."
msgstr ""
"As corrotinas também têm os métodos listados abaixo, que são análogos aos "
"dos geradores (veja :ref:`generator-methods`). No entanto, ao contrário dos "
"geradores, as corrotinas não suportam diretamente iteração."

#: ../../reference/datamodel.rst:3682
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "É um :exc:`RuntimeError` aguardar uma corrotina mais do que uma vez."

#: ../../reference/datamodel.rst:3688
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, this "
"is equivalent to advancing the iterator returned by :meth:`~object."
"__await__`.  If *value* is not ``None``, this method delegates to the :meth:"
"`~generator.send` method of the iterator that caused the coroutine to "
"suspend.  The result (return value, :exc:`StopIteration`, or other "
"exception) is the same as when iterating over the :meth:`!__await__` return "
"value, described above."
msgstr ""
"Inicia ou retoma a execução da corrotina. Se *value* for ``None``, isto é "
"equivalente a avançar o iterador devolvido por :meth:`~object.__await__`. Se "
"*value* não for ``None``, este método delega ao método :meth:`~generator."
"send` do iterador que causou a suspensão da corrotina. O resultado (valor de "
"retorno, :exc:`StopIteration` ou outra exceção) é o mesmo que ao iterar "
"sobre o valor de retorno de :meth:`!__await__`, descrito acima."

#: ../../reference/datamodel.rst:3699
msgid ""
"Raises the specified exception in the coroutine.  This method delegates to "
"the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception is "
"raised at the suspension point.  The result (return value, :exc:"
"`StopIteration`, or other exception) is the same as when iterating over the :"
"meth:`~object.__await__` return value, described above.  If the exception is "
"not caught in the coroutine, it propagates back to the caller."
msgstr ""
"Levanta a exceção especificada na corrotina. Este método delega ao método :"
"meth:`~generator.throw` do iterador que causou a suspensão da corrotina, se "
"tiver tal método. Caso contrário, a exceção é levantada no ponto de "
"suspensão. O resultado (valor de retorno, :exc:`StopIteration` ou outra "
"exceção) é o mesmo que ao iterar sobre o valor de retorno de :meth:`~object."
"__await__`, descrito acima. Se a exceção não for capturada na corrotina, "
"propaga-se de volta para o chamador."

#: ../../reference/datamodel.rst:3710
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"A segunda assinatura \\(type\\[, value\\[, traceback\\]\\]\\) está obsoleta "
"e pode ser removida numa versão futura do Python."

#: ../../reference/datamodel.rst:3715
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has such "
"a method.  Then it raises :exc:`GeneratorExit` at the suspension point, "
"causing the coroutine to immediately clean itself up. Finally, the coroutine "
"is marked as having finished executing, even if it was never started."
msgstr ""
"Faz com que a corrotina se limpe e termine. Se a corrotina estiver suspensa, "
"este método primeiro delega ao método :meth:`~generator.close` do iterador "
"que causou a suspensão da corrotina, se tiver tal método. Depois, levanta :"
"exc:`GeneratorExit` no ponto de suspensão, fazendo com que a corrotina se "
"limpe imediatamente. Finalmente, a corrotina é marcada como tendo terminado "
"a execução, mesmo que nunca tenha sido iniciada."

#: ../../reference/datamodel.rst:3723
msgid ""
"Coroutine objects are automatically closed using the above process when they "
"are about to be destroyed."
msgstr ""
"Os objetos corrotina são automaticamente fechados usando o processo acima "
"quando estão prestes a ser destruídos."

#: ../../reference/datamodel.rst:3729
msgid "Asynchronous Iterators"
msgstr "Iteradores Assíncronos"

#: ../../reference/datamodel.rst:3731
msgid ""
"An *asynchronous iterator* can call asynchronous code in its ``__anext__`` "
"method."
msgstr ""
"Um *iterador assíncrono* pode chamar código assíncrono no seu método "
"``__anext__``."

#: ../../reference/datamodel.rst:3734
msgid ""
"Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr ""
"Os iteradores assíncronos podem ser usados numa instrução :keyword:`async "
"for`."

#: ../../reference/datamodel.rst:3736 ../../reference/datamodel.rst:3785
msgid "The :class:`object` class itself does not provide these methods."
msgstr "A classe :class:`object` em si não fornece estes métodos."

#: ../../reference/datamodel.rst:3741
msgid "Must return an *asynchronous iterator* object."
msgstr "Deve devolver um objeto *iterador assíncrono*."

#: ../../reference/datamodel.rst:3745
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is over."
msgstr ""
"Deve devolver um objeto *aguardável* resultando no próximo valor do "
"iterador. Deve levantar um erro :exc:`StopAsyncIteration` quando a iteração "
"terminar."

#: ../../reference/datamodel.rst:3748
msgid "An example of an asynchronous iterable object::"
msgstr "Um exemplo de um objeto iterável assíncrono:"

#: ../../reference/datamodel.rst:3750
msgid ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"
msgstr ""
"class Reader:\n"
"    async def readline(self):\n"
"        ...\n"
"\n"
"    def __aiter__(self):\n"
"        return self\n"
"\n"
"    async def __anext__(self):\n"
"        val = await self.readline()\n"
"        if val == b'':\n"
"            raise StopAsyncIteration\n"
"        return val"

#: ../../reference/datamodel.rst:3765
msgid ""
"Prior to Python 3.7, :meth:`~object.__aiter__` could return an *awaitable* "
"that would resolve to an :term:`asynchronous iterator <asynchronous "
"iterator>`."
msgstr ""
"Antes do Python 3.7, :meth:`~object.__aiter__` podia devolver um objeto "
"*aguardável* que se resolveria num :term:`iterador assíncrono<asynchronous "
"iterator>`."

#: ../../reference/datamodel.rst:3770
msgid ""
"Starting with Python 3.7, :meth:`~object.__aiter__` must return an "
"asynchronous iterator object.  Returning anything else will result in a :exc:"
"`TypeError` error."
msgstr ""
"A partir do Python 3.7, :meth:`~object.__aiter__` deve devolver um objeto "
"iterador assíncrono. Devolver qualquer outra coisa resultará num erro :exc:"
"`TypeError`."

#: ../../reference/datamodel.rst:3778
msgid "Asynchronous Context Managers"
msgstr "Gestores de Contexto Assíncronos"

#: ../../reference/datamodel.rst:3780
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"Um *gestor de contexto assíncrono* é um *gestor de contexto* que é capaz de "
"suspender a execução nos seus métodos ``__aenter__`` e ``__aexit__``."

#: ../../reference/datamodel.rst:3783
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr ""
"Os gestores de contexto assíncronos podem ser usados numa instrução :keyword:"
"`async with`."

#: ../../reference/datamodel.rst:3789
msgid ""
"Semantically similar to :meth:`~object.__enter__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Semanticamente semelhante a :meth:`~object.__enter__`, a única diferença é "
"que deve devolver um objeto *aguardável*."

#: ../../reference/datamodel.rst:3794
msgid ""
"Semantically similar to :meth:`~object.__exit__`, the only difference being "
"that it must return an *awaitable*."
msgstr ""
"Semanticamente semelhante a :meth:`~object.__exit__`, a única diferença é "
"que deve devolver um objeto *aguardável*."

#: ../../reference/datamodel.rst:3797
msgid "An example of an asynchronous context manager class::"
msgstr "Um exemplo de uma classe de gestor de contexto assíncrono:"

#: ../../reference/datamodel.rst:3799
msgid ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('entering context')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('exiting context')"
msgstr ""
"class AsyncContextManager:\n"
"    async def __aenter__(self):\n"
"        await log('a entrar no contexto')\n"
"\n"
"    async def __aexit__(self, exc_type, exc, tb):\n"
"        await log('a sair do contexto')"

#: ../../reference/datamodel.rst:3810
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../reference/datamodel.rst:3811
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"É *possível*, em alguns casos, alterar o tipo de um objeto, sob certas "
"condições controladas. No entanto, geralmente não é uma boa ideia, pois pode "
"levar a comportamentos muito estranhos se não for tratado corretamente."

#: ../../reference/datamodel.rst:3815
msgid ""
"The :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:`~object."
"__reversed__`, :meth:`~object.__contains__`, :meth:`~object."
"__class_getitem__` and :meth:`~os.PathLike.__fspath__` methods have special "
"handling for this. Others will still raise a :exc:`TypeError`, but may do so "
"by relying on the behavior that ``None`` is not callable."
msgstr ""
"Os métodos :meth:`~object.__hash__`, :meth:`~object.__iter__`, :meth:"
"`~object.__reversed__`, :meth:`~object.__contains__`, :meth:`~object."
"__class_getitem__` e :meth:`~os.PathLike.__fspath__` têm um tratamento "
"especial para isto. Outros métodos ainda levantarão uma exceção :exc:"
"`TypeError`, mas podem fazê-lo baseando-se no comportamento de que ``None`` "
"não é chamável."

#: ../../reference/datamodel.rst:3822
msgid ""
"\"Does not support\" here means that the class has no such method, or the "
"method returns :data:`NotImplemented`.  Do not set the method to ``None`` if "
"you want to force fallback to the right operand's reflected method—that will "
"instead have the opposite effect of explicitly *blocking* such fallback."
msgstr ""
"\"Não suporta\" aqui significa que a classe não tem tal método, ou o método "
"devolve :data:`NotImplemented`. Não defina o método como ``None`` se "
"pretender forçar a recorrência ao método refletido do operando direito — "
"isso terá, em vez disso, o efeito oposto de *bloquear explicitamente* essa "
"recorrência."

#: ../../reference/datamodel.rst:3828
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method -- such as :meth:`~object.__add__` -- fails then the overall "
"operation is not supported, which is why the reflected method is not called."
msgstr ""

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:148
#: ../../reference/datamodel.rst:159 ../../reference/datamodel.rst:180
#: ../../reference/datamodel.rst:192 ../../reference/datamodel.rst:225
#: ../../reference/datamodel.rst:246 ../../reference/datamodel.rst:261
#: ../../reference/datamodel.rst:279 ../../reference/datamodel.rst:292
#: ../../reference/datamodel.rst:324 ../../reference/datamodel.rst:359
#: ../../reference/datamodel.rst:384 ../../reference/datamodel.rst:405
#: ../../reference/datamodel.rst:423 ../../reference/datamodel.rst:443
#: ../../reference/datamodel.rst:451 ../../reference/datamodel.rst:462
#: ../../reference/datamodel.rst:479 ../../reference/datamodel.rst:515
#: ../../reference/datamodel.rst:530 ../../reference/datamodel.rst:657
#: ../../reference/datamodel.rst:795 ../../reference/datamodel.rst:819
#: ../../reference/datamodel.rst:855 ../../reference/datamodel.rst:1122
#: ../../reference/datamodel.rst:1269 ../../reference/datamodel.rst:1296
#: ../../reference/datamodel.rst:1368 ../../reference/datamodel.rst:1476
#: ../../reference/datamodel.rst:1583 ../../reference/datamodel.rst:1693
#: ../../reference/datamodel.rst:2118 ../../reference/datamodel.rst:3145
msgid "object"
msgstr "objeto"

#: ../../reference/datamodel.rst:14 ../../reference/datamodel.rst:122
msgid "data"
msgstr "dados"

#: ../../reference/datamodel.rst:22 ../../reference/datamodel.rst:292
#: ../../reference/datamodel.rst:339 ../../reference/datamodel.rst:423
#: ../../reference/datamodel.rst:462 ../../reference/datamodel.rst:795
#: ../../reference/datamodel.rst:1325 ../../reference/datamodel.rst:1776
#: ../../reference/datamodel.rst:2019 ../../reference/datamodel.rst:2025
#: ../../reference/datamodel.rst:2118 ../../reference/datamodel.rst:2680
#: ../../reference/datamodel.rst:3115 ../../reference/datamodel.rst:3273
#: ../../reference/datamodel.rst:3308 ../../reference/datamodel.rst:3322
#: ../../reference/datamodel.rst:3371 ../../reference/datamodel.rst:3381
#: ../../reference/datamodel.rst:3409
msgid "built-in function"
msgstr "função incorporada"

#: ../../reference/datamodel.rst:22
msgid "id"
msgstr "identificador"

#: ../../reference/datamodel.rst:22 ../../reference/datamodel.rst:122
#: ../../reference/datamodel.rst:2680
msgid "type"
msgstr "tipo"

#: ../../reference/datamodel.rst:22
msgid "identity of an object"
msgstr "identidade de um objeto"

#: ../../reference/datamodel.rst:22
msgid "value of an object"
msgstr "valor de um objeto"

#: ../../reference/datamodel.rst:22
msgid "type of an object"
msgstr "tipo de um objeto"

#: ../../reference/datamodel.rst:22
msgid "mutable object"
msgstr "objeto mutável"

#: ../../reference/datamodel.rst:22
msgid "immutable object"
msgstr "objeto imutável"

#: ../../reference/datamodel.rst:56
msgid "garbage collection"
msgstr "recolha de lixo"

#: ../../reference/datamodel.rst:56
msgid "reference counting"
msgstr "contagem de referências"

#: ../../reference/datamodel.rst:56
msgid "unreachable object"
msgstr "objeto inacessível"

#: ../../reference/datamodel.rst:91 ../../reference/datamodel.rst:1122
msgid "container"
msgstr "contentor"

#: ../../reference/datamodel.rst:122
msgid "hierarchy"
msgstr "hierarquia"

#: ../../reference/datamodel.rst:122
msgid "extension"
msgstr "extensão"

#: ../../reference/datamodel.rst:122 ../../reference/datamodel.rst:396
#: ../../reference/datamodel.rst:397 ../../reference/datamodel.rst:498
#: ../../reference/datamodel.rst:855 ../../reference/datamodel.rst:875
#: ../../reference/datamodel.rst:1325
msgid "module"
msgstr "módulo"

#: ../../reference/datamodel.rst:122 ../../reference/datamodel.rst:261
#: ../../reference/datamodel.rst:795
msgid "C"
msgstr "C"

#: ../../reference/datamodel.rst:122 ../../reference/datamodel.rst:261
#: ../../reference/datamodel.rst:795
msgid "language"
msgstr "linguagem"

#: ../../reference/datamodel.rst:135 ../../reference/datamodel.rst:1122
#: ../../reference/datamodel.rst:1140 ../../reference/datamodel.rst:1269
#: ../../reference/datamodel.rst:1289
msgid "attribute"
msgstr "atributo"

#: ../../reference/datamodel.rst:135
msgid "special"
msgstr "especial"

#: ../../reference/datamodel.rst:135
msgid "generic"
msgstr "genérico"

#: ../../reference/datamodel.rst:180
msgid "..."
msgstr "..."

#: ../../reference/datamodel.rst:180
msgid "ellipsis literal"
msgstr "literal de reticências"

#: ../../reference/datamodel.rst:192 ../../reference/datamodel.rst:1296
msgid "numeric"
msgstr "numérico"

#: ../../reference/datamodel.rst:225 ../../reference/datamodel.rst:231
#: ../../reference/datamodel.rst:339
msgid "integer"
msgstr "inteiro"

#: ../../reference/datamodel.rst:231
msgid "representation"
msgstr "representação"

#: ../../reference/datamodel.rst:246
msgid "Boolean"
msgstr "Booleano"

#: ../../reference/datamodel.rst:246
msgid "False"
msgstr "Falso"

#: ../../reference/datamodel.rst:246
msgid "True"
msgstr "Verdadeiro"

#: ../../reference/datamodel.rst:261
msgid "floating-point"
msgstr "ponto flutuante"

#: ../../reference/datamodel.rst:261 ../../reference/datamodel.rst:279
msgid "number"
msgstr "número"

#: ../../reference/datamodel.rst:261
msgid "Java"
msgstr "Java"

#: ../../reference/datamodel.rst:279 ../../reference/datamodel.rst:3381
msgid "complex"
msgstr "complex"

#: ../../reference/datamodel.rst:292 ../../reference/datamodel.rst:423
#: ../../reference/datamodel.rst:462 ../../reference/datamodel.rst:3115
msgid "len"
msgstr "len"

#: ../../reference/datamodel.rst:292 ../../reference/datamodel.rst:1296
msgid "sequence"
msgstr "sequência"

#: ../../reference/datamodel.rst:292
msgid "index operation"
msgstr "operação de índice"

#: ../../reference/datamodel.rst:292
msgid "item selection"
msgstr "seleção de item"

#: ../../reference/datamodel.rst:292 ../../reference/datamodel.rst:384
#: ../../reference/datamodel.rst:462
msgid "subscription"
msgstr "subscrição"

#: ../../reference/datamodel.rst:307 ../../reference/datamodel.rst:384
msgid "slicing"
msgstr "fatiamento"

#: ../../reference/datamodel.rst:324
msgid "immutable sequence"
msgstr "sequência imutável"

#: ../../reference/datamodel.rst:324
msgid "immutable"
msgstr "imutável"

#: ../../reference/datamodel.rst:335 ../../reference/datamodel.rst:1994
#: ../../reference/datamodel.rst:2025
msgid "string"
msgstr "string"

#: ../../reference/datamodel.rst:335
msgid "immutable sequences"
msgstr "sequências imutáveis"

#: ../../reference/datamodel.rst:339
msgid "chr"
msgstr "chr"

#: ../../reference/datamodel.rst:339
msgid "ord"
msgstr "ord"

#: ../../reference/datamodel.rst:339
msgid "character"
msgstr "caractere"

#: ../../reference/datamodel.rst:339
msgid "Unicode"
msgstr "Unicode"

#: ../../reference/datamodel.rst:359
msgid "tuple"
msgstr "tupla"

#: ../../reference/datamodel.rst:359
msgid "singleton"
msgstr "singleton"

#: ../../reference/datamodel.rst:359
msgid "empty"
msgstr "vazio"

#: ../../reference/datamodel.rst:372 ../../reference/datamodel.rst:2019
msgid "bytes"
msgstr "bytes"

#: ../../reference/datamodel.rst:372
msgid "byte"
msgstr "byte"

#: ../../reference/datamodel.rst:384
msgid "mutable sequence"
msgstr "sequência mutável"

#: ../../reference/datamodel.rst:384
msgid "mutable"
msgstr "mutável"

#: ../../reference/datamodel.rst:384 ../../reference/datamodel.rst:1140
#: ../../reference/datamodel.rst:1289
msgid "assignment"
msgstr "atribuição"

#: ../../reference/datamodel.rst:384 ../../reference/datamodel.rst:855
#: ../../reference/datamodel.rst:1730 ../../reference/datamodel.rst:1912
#: ../../reference/datamodel.rst:3436
msgid "statement"
msgstr "instrução"

#: ../../reference/datamodel.rst:396
msgid "array"
msgstr "array"

#: ../../reference/datamodel.rst:397
msgid "collections"
msgstr "collections"

#: ../../reference/datamodel.rst:405
msgid "list"
msgstr "lista"

#: ../../reference/datamodel.rst:412
msgid "bytearray"
msgstr "bytearray"

#: ../../reference/datamodel.rst:423
msgid "set type"
msgstr "tipo de conjunto"

#: ../../reference/datamodel.rst:443
msgid "set"
msgstr "conjunto"

#: ../../reference/datamodel.rst:451
msgid "frozenset"
msgstr "frozenset"

#: ../../reference/datamodel.rst:462 ../../reference/datamodel.rst:1296
msgid "mapping"
msgstr "mapeamento"

#: ../../reference/datamodel.rst:479 ../../reference/datamodel.rst:1122
#: ../../reference/datamodel.rst:2118
msgid "dictionary"
msgstr "dicionário"

#: ../../reference/datamodel.rst:498
msgid "dbm.ndbm"
msgstr "dbm.ndbm"

#: ../../reference/datamodel.rst:498
msgid "dbm.gnu"
msgstr "dbm.gnu"

#: ../../reference/datamodel.rst:515
msgid "callable"
msgstr "chamável"

#: ../../reference/datamodel.rst:515 ../../reference/datamodel.rst:530
#: ../../reference/datamodel.rst:739 ../../reference/datamodel.rst:757
#: ../../reference/datamodel.rst:770 ../../reference/datamodel.rst:795
msgid "function"
msgstr "função"

#: ../../reference/datamodel.rst:515 ../../reference/datamodel.rst:1122
#: ../../reference/datamodel.rst:1145 ../../reference/datamodel.rst:3061
msgid "call"
msgstr "chamada"

#: ../../reference/datamodel.rst:515
msgid "invocation"
msgstr "invocação"

#: ../../reference/datamodel.rst:515
msgid "argument"
msgstr "argumento"

#: ../../reference/datamodel.rst:530 ../../reference/datamodel.rst:657
msgid "user-defined"
msgstr "definido pelo utilizador"

#: ../../reference/datamodel.rst:530
msgid "user-defined function"
msgstr "função definida pelo utilizador"

#: ../../reference/datamodel.rst:543
msgid "__closure__ (function attribute)"
msgstr "__closure__ (atributo da função)"

#: ../../reference/datamodel.rst:543
msgid "__globals__ (function attribute)"
msgstr "__globals__ (atributo da função)"

#: ../../reference/datamodel.rst:543
msgid "global"
msgstr "global"

#: ../../reference/datamodel.rst:543 ../../reference/datamodel.rst:875
msgid "namespace"
msgstr "espaço de nomes"

#: ../../reference/datamodel.rst:570
msgid "__doc__ (function attribute)"
msgstr "__doc__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__name__ (function attribute)"
msgstr "__name__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__module__ (function attribute)"
msgstr "__module__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__dict__ (function attribute)"
msgstr "__dict__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__defaults__ (function attribute)"
msgstr "__defaults__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__code__ (function attribute)"
msgstr "__code__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__annotations__ (function attribute)"
msgstr "__annotations__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__kwdefaults__ (function attribute)"
msgstr "__kwdefaults__ (atributo da função)"

#: ../../reference/datamodel.rst:570
msgid "__type_params__ (function attribute)"
msgstr "__type_params__ (atributo da função)"

#: ../../reference/datamodel.rst:657 ../../reference/datamodel.rst:819
msgid "method"
msgstr "método"

#: ../../reference/datamodel.rst:657
msgid "user-defined method"
msgstr "método definido pelo utilizador"

#: ../../reference/datamodel.rst:665
msgid "__func__ (method attribute)"
msgstr "__func__ (atributo do método)"

#: ../../reference/datamodel.rst:665
msgid "__self__ (method attribute)"
msgstr "__self__ (atributo do método)"

#: ../../reference/datamodel.rst:665
msgid "__doc__ (method attribute)"
msgstr "__doc__ (atributo do método)"

#: ../../reference/datamodel.rst:665
msgid "__name__ (method attribute)"
msgstr "__name__ (atributo do método)"

#: ../../reference/datamodel.rst:665
msgid "__module__ (method attribute)"
msgstr "__module__ (atributo do método)"

#: ../../reference/datamodel.rst:739 ../../reference/datamodel.rst:1476
msgid "generator"
msgstr "gerador"

#: ../../reference/datamodel.rst:739
msgid "iterator"
msgstr "iterador"

#: ../../reference/datamodel.rst:757 ../../reference/datamodel.rst:3624
msgid "coroutine"
msgstr "corrotina"

#: ../../reference/datamodel.rst:770
msgid "asynchronous generator"
msgstr "gerador assíncrono"

#: ../../reference/datamodel.rst:770
msgid "asynchronous iterator"
msgstr "iterador assíncrono"

#: ../../reference/datamodel.rst:819
msgid "built-in method"
msgstr "método incorporado"

#: ../../reference/datamodel.rst:819
msgid "built-in"
msgstr "incorporado"

#: ../../reference/datamodel.rst:855
msgid "import"
msgstr "importar"

#: ../../reference/datamodel.rst:875
msgid "__name__ (module attribute)"
msgstr "__name__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__spec__ (module attribute)"
msgstr "__spec__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__package__ (module attribute)"
msgstr "__package__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__loader__ (module attribute)"
msgstr "__loader__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__path__ (module attribute)"
msgstr "__path__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__file__ (module attribute)"
msgstr "__file__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__cached__ (module attribute)"
msgstr "__cached__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__doc__ (module attribute)"
msgstr "__doc__ (atributo do módulo)"

#: ../../reference/datamodel.rst:875
msgid "__annotations__ (module attribute)"
msgstr "__annotations__ (atributo do módulo)"

#: ../../reference/datamodel.rst:1090
msgid "__dict__ (module attribute)"
msgstr "__dict__ (atributo do módulo)"

#: ../../reference/datamodel.rst:1122 ../../reference/datamodel.rst:1140
#: ../../reference/datamodel.rst:1269 ../../reference/datamodel.rst:1895
#: ../../reference/datamodel.rst:2791
msgid "class"
msgstr "classe"

#: ../../reference/datamodel.rst:1122 ../../reference/datamodel.rst:1269
#: ../../reference/datamodel.rst:1289
msgid "class instance"
msgstr "instância de classe"

#: ../../reference/datamodel.rst:1122 ../../reference/datamodel.rst:1269
#: ../../reference/datamodel.rst:3061
msgid "instance"
msgstr "instância"

#: ../../reference/datamodel.rst:1122 ../../reference/datamodel.rst:1145
msgid "class object"
msgstr "objeto de classe"

#: ../../reference/datamodel.rst:1152
msgid "__name__ (class attribute)"
msgstr "__name__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__module__ (class attribute)"
msgstr "__module__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__dict__ (class attribute)"
msgstr "__dict__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__bases__ (class attribute)"
msgstr "__bases__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__base__ (class attribute)"
msgstr "__base__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__doc__ (class attribute)"
msgstr "__doc__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__annotations__ (class attribute)"
msgstr "__annotations__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__type_params__ (class attribute)"
msgstr "__type_params__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__static_attributes__ (class attribute)"
msgstr "__static_attributes__ (atributo da classe)"

#: ../../reference/datamodel.rst:1152
msgid "__firstlineno__ (class attribute)"
msgstr "__firstlineno__ (atributo da classe)"

#: ../../reference/datamodel.rst:1307
msgid "__dict__ (instance attribute)"
msgstr "__dict__ (atributo da instância)"

#: ../../reference/datamodel.rst:1307
msgid "__class__ (instance attribute)"
msgstr "__class__ (atributo da instância)"

#: ../../reference/datamodel.rst:1325
msgid "open"
msgstr "abrir"

#: ../../reference/datamodel.rst:1325
msgid "io"
msgstr "io"

#: ../../reference/datamodel.rst:1325
msgid "popen() (in module os)"
msgstr "popen() (no módulo os)"

#: ../../reference/datamodel.rst:1325
msgid "makefile() (socket method)"
msgstr "makefile() (método socket)"

#: ../../reference/datamodel.rst:1325
msgid "sys.stdin"
msgstr "sys.stdin"

#: ../../reference/datamodel.rst:1325
msgid "sys.stdout"
msgstr "sys.stdout"

#: ../../reference/datamodel.rst:1325
msgid "sys.stderr"
msgstr "sys.stderr"

#: ../../reference/datamodel.rst:1325
msgid "stdio"
msgstr "stdio"

#: ../../reference/datamodel.rst:1325
msgid "stdin (in module sys)"
msgstr "stdin (no módulo sys)"

#: ../../reference/datamodel.rst:1325
msgid "stdout (in module sys)"
msgstr "stdout (no módulo sys)"

#: ../../reference/datamodel.rst:1325
msgid "stderr (in module sys)"
msgstr "stderr (no módulo sys)"

#: ../../reference/datamodel.rst:1354
msgid "internal type"
msgstr "tipo interno"

#: ../../reference/datamodel.rst:1354
msgid "types, internal"
msgstr "tipos internos"

#: ../../reference/datamodel.rst:1368
msgid "bytecode"
msgstr "*bytecode*"

#: ../../reference/datamodel.rst:1368
msgid "code"
msgstr "código"

#: ../../reference/datamodel.rst:1368
msgid "code object"
msgstr "objeto código"

#: ../../reference/datamodel.rst:1379
msgid "co_argcount (code object attribute)"
msgstr "co_argcount (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_posonlyargcount (code object attribute)"
msgstr "co_posonlyargcount (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_kwonlyargcount (code object attribute)"
msgstr "co_kwonlyargcount (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_code (code object attribute)"
msgstr "co_code (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_consts (code object attribute)"
msgstr "co_consts (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_filename (code object attribute)"
msgstr "co_filename (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_firstlineno (code object attribute)"
msgstr "co_firstlineno (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_flags (code object attribute)"
msgstr "co_flags (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_lnotab (code object attribute)"
msgstr "co_lnotab (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_name (code object attribute)"
msgstr "co_name (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_names (code object attribute)"
msgstr "co_names (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_nlocals (code object attribute)"
msgstr "co_nlocals (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_stacksize (code object attribute)"
msgstr "co_stacksize (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_varnames (code object attribute)"
msgstr "co_varnames (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_cellvars (code object attribute)"
msgstr "co_cellvars (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_freevars (code object attribute)"
msgstr "co_freevars (atributo do objeto código)"

#: ../../reference/datamodel.rst:1379
msgid "co_qualname (code object attribute)"
msgstr "co_qualname (atributo do objeto código)"

#: ../../reference/datamodel.rst:1492
msgid "documentation string"
msgstr "string de documentação"

#: ../../reference/datamodel.rst:1583
msgid "frame"
msgstr "frame"

#: ../../reference/datamodel.rst:1589
msgid "f_back (frame attribute)"
msgstr "f_back (atributo do frame)"

#: ../../reference/datamodel.rst:1589
msgid "f_code (frame attribute)"
msgstr "f_code (atributo do frame)"

#: ../../reference/datamodel.rst:1589
msgid "f_globals (frame attribute)"
msgstr "f_globals (atributo do frame)"

#: ../../reference/datamodel.rst:1589
msgid "f_locals (frame attribute)"
msgstr "f_locals (atributo do frame)"

#: ../../reference/datamodel.rst:1589
msgid "f_lasti (frame attribute)"
msgstr "f_lasti (atributo do frame)"

#: ../../reference/datamodel.rst:1589
msgid "f_builtins (frame attribute)"
msgstr "f_builtins (atributo do frame)"

#: ../../reference/datamodel.rst:1633
msgid "f_trace (frame attribute)"
msgstr "f_trace (atributo do frame)"

#: ../../reference/datamodel.rst:1633
msgid "f_trace_lines (frame attribute)"
msgstr "f_trace_lines (atributo do frame)"

#: ../../reference/datamodel.rst:1633
msgid "f_trace_opcodes (frame attribute)"
msgstr "f_trace_opcodes (atributo do frame)"

#: ../../reference/datamodel.rst:1633
msgid "f_lineno (frame attribute)"
msgstr "f_lineno (atributo do frame)"

#: ../../reference/datamodel.rst:1693
msgid "traceback"
msgstr "traceback"

#: ../../reference/datamodel.rst:1693
msgid "stack"
msgstr "pilha"

#: ../../reference/datamodel.rst:1693
msgid "trace"
msgstr "traço"

#: ../../reference/datamodel.rst:1693
msgid "exception"
msgstr "exceção"

#: ../../reference/datamodel.rst:1693
msgid "handler"
msgstr "gestor"

#: ../../reference/datamodel.rst:1693
msgid "execution"
msgstr "execução"

#: ../../reference/datamodel.rst:1693
msgid "exc_info (in module sys)"
msgstr "exc_info (no módulo sys)"

#: ../../reference/datamodel.rst:1693
msgid "last_traceback (in module sys)"
msgstr "last_traceback (no módulo sys)"

#: ../../reference/datamodel.rst:1693
msgid "sys.exc_info"
msgstr "sys.exc_info"

#: ../../reference/datamodel.rst:1693
msgid "sys.exception"
msgstr "sys.exception"

#: ../../reference/datamodel.rst:1693
msgid "sys.last_traceback"
msgstr "sys.last_traceback"

#: ../../reference/datamodel.rst:1730
msgid "tb_frame (traceback attribute)"
msgstr "tb_frame (atributo do traceback)"

#: ../../reference/datamodel.rst:1730
msgid "tb_lineno (traceback attribute)"
msgstr "tb_lineno (atributo do traceback)"

#: ../../reference/datamodel.rst:1730
msgid "tb_lasti (traceback attribute)"
msgstr "tb_lasti (atributo do traceback)"

#: ../../reference/datamodel.rst:1730
msgid "try"
msgstr "try"

#: ../../reference/datamodel.rst:1760
msgid "tb_next (traceback attribute)"
msgstr "tb_next (atributo do traceback)"

#: ../../reference/datamodel.rst:1776 ../../reference/datamodel.rst:3145
msgid "slice"
msgstr "fatia"

#: ../../reference/datamodel.rst:1782
msgid "start (slice object attribute)"
msgstr "start (atributo do objeto fatia)"

#: ../../reference/datamodel.rst:1782
msgid "stop (slice object attribute)"
msgstr "stop (atributo do objeto fatia)"

#: ../../reference/datamodel.rst:1782
msgid "step (slice object attribute)"
msgstr "step (atributo do objeto fatia)"

#: ../../reference/datamodel.rst:1830
msgid "operator"
msgstr "operator"

#: ../../reference/datamodel.rst:1830
msgid "overloading"
msgstr "sobrecarga"

#: ../../reference/datamodel.rst:1830
msgid "__getitem__() (mapping object method)"
msgstr "__getitem__() (método do objeto mapeamento)"

#: ../../reference/datamodel.rst:1866
msgid "subclassing"
msgstr "subclassificação"

#: ../../reference/datamodel.rst:1866
msgid "immutable types"
msgstr "tipos imutáveis"

#: ../../reference/datamodel.rst:1895
msgid "constructor"
msgstr "construtor"

#: ../../reference/datamodel.rst:1912
msgid "destructor"
msgstr "destrutor"

#: ../../reference/datamodel.rst:1912
msgid "finalizer"
msgstr "finalizador"

#: ../../reference/datamodel.rst:1912
msgid "del"
msgstr "del"

#: ../../reference/datamodel.rst:1976
msgid "repr() (built-in function)"
msgstr "repr() (função incorporada)"

#: ../../reference/datamodel.rst:1976
msgid "__repr__() (object method)"
msgstr "__repr__() (método do objeto)"

#: ../../reference/datamodel.rst:1994
msgid "__str__() (object method)"
msgstr "__str__() (método do objeto)"

#: ../../reference/datamodel.rst:1994
msgid "format() (built-in function)"
msgstr "format() (função incorporada)"

#: ../../reference/datamodel.rst:1994
msgid "print() (built-in function)"
msgstr "print() (função incorporada)"

#: ../../reference/datamodel.rst:2025
msgid "__format__() (object method)"
msgstr "__format__() (método do objeto)"

#: ../../reference/datamodel.rst:2025
msgid "conversion"
msgstr "conversão"

#: ../../reference/datamodel.rst:2025
msgid "print"
msgstr "imprimir"

#: ../../reference/datamodel.rst:2067
msgid "comparisons"
msgstr "comparações"

#: ../../reference/datamodel.rst:2118
msgid "hash"
msgstr "hash"

#: ../../reference/datamodel.rst:2199
msgid "__len__() (mapping object method)"
msgstr "__len__() (método do objeto mapeamento)"

#: ../../reference/datamodel.rst:2304
msgid "__getattr__ (module attribute)"
msgstr "__getattr__ (atributo do módulo)"

#: ../../reference/datamodel.rst:2304
msgid "__dir__ (module attribute)"
msgstr "__dir__ (atributo do módulo)"

#: ../../reference/datamodel.rst:2304
msgid "__class__ (module attribute)"
msgstr "__class__ (atributo do módulo)"

#: ../../reference/datamodel.rst:2680
msgid "metaclass"
msgstr "metaclasse"

#: ../../reference/datamodel.rst:2680
msgid "= (equals)"
msgstr "= (igual)"

#: ../../reference/datamodel.rst:2680
msgid "class definition"
msgstr "definição de classe"

#: ../../reference/datamodel.rst:2744
msgid "metaclass hint"
msgstr "dica de metaclasse"

#: ../../reference/datamodel.rst:2767
msgid "__prepare__ (metaclass method)"
msgstr "__prepare__ (método da metaclasse)"

#: ../../reference/datamodel.rst:2791
msgid "body"
msgstr "corpo"

#: ../../reference/datamodel.rst:2811
msgid "__class__ (method cell)"
msgstr "__class__ (célula do método)"

#: ../../reference/datamodel.rst:2811
msgid "__classcell__ (class namespace entry)"
msgstr "__classcell__ (entrada do espaço de nomes da classe)"

#: ../../reference/datamodel.rst:3115
msgid "__bool__() (object method)"
msgstr "__bool__() (método do objeto)"

#: ../../reference/datamodel.rst:3273 ../../reference/datamodel.rst:3308
msgid "divmod"
msgstr "divmod"

#: ../../reference/datamodel.rst:3273 ../../reference/datamodel.rst:3308
#: ../../reference/datamodel.rst:3322
msgid "pow"
msgstr "pow"

#: ../../reference/datamodel.rst:3371
msgid "abs"
msgstr "abs"

#: ../../reference/datamodel.rst:3381
msgid "int"
msgstr "int"

#: ../../reference/datamodel.rst:3381
msgid "float"
msgstr "float"

#: ../../reference/datamodel.rst:3409
msgid "round"
msgstr "round"

#: ../../reference/datamodel.rst:3436
msgid "with"
msgstr "with"

#: ../../reference/datamodel.rst:3436
msgid "context manager"
msgstr "gestor de contexto"
