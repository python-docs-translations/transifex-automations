# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-05 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../reference/expressions.rst:6
msgid "Expressions"
msgstr "Expressões"

#: ../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""
"Este capítulo explica o significado dos elementos das expressões em Python."

#: ../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**Notas de Sintaxe:** Neste e nos capítulos seguintes, será usada a notação "
"BNF estendida para descrever a sintaxe, não a análise léxica. Quando (uma "
"alternativa de) uma regra sintática tem a forma"

#: ../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"e não são dadas semânticas, a semântica desta forma de ``name`` é a mesma "
"que para ``othername``."

#: ../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "Conversões aritméticas"

#: ../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common real type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"Quando a descrição de um operador aritmético abaixo usa a frase \"os "
"argumentos numéricos são convertidos para um tipo real comum\", isto "
"significa que a implementação do operador para tipos integrados funciona da "
"seguinte forma:"

#: ../../reference/expressions.rst:34
msgid "If both arguments are complex numbers, no conversion is performed;"
msgstr ""
"Se ambos os argumentos forem números complexos, não é efetuada nenhuma "
"conversão;"

#: ../../reference/expressions.rst:36
msgid ""
"if either argument is a complex or a floating-point number, the other is "
"converted to a floating-point number;"
msgstr ""
"se algum dos argumentos for um número complexo ou de vírgula flutuante, o "
"outro é convertido para um número de vírgula flutuante;"

#: ../../reference/expressions.rst:38
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""
"caso contrário, ambos devem ser inteiros e não é necessária nenhuma "
"conversão."

#: ../../reference/expressions.rst:40
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Algumas regras adicionais aplicam-se a certos operadores (por exemplo, uma "
"string como argumento esquerdo do operador '%'). As extensões devem definir "
"o seu próprio comportamento de conversão."

#: ../../reference/expressions.rst:48
msgid "Atoms"
msgstr "Átomos"

#: ../../reference/expressions.rst:52
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Os átomos são os elementos mais básicos das expressões. Os átomos mais "
"simples são identificadores ou literais. As formas delimitadas por "
"parênteses, parênteses retos ou chavetas também são categorizadas "
"sintaticamente como átomos. A sintaxe para átomos é:"

#: ../../reference/expressions.rst:65
msgid "Identifiers (Names)"
msgstr "Identificadores (Nomes)"

#: ../../reference/expressions.rst:69
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"Um identificador que ocorre como um átomo é um nome. Consulte a secção :ref:"
"`identifiers` para a definição léxica e a secção :ref:`naming` para a "
"documentação sobre nomeação e ligação."

#: ../../reference/expressions.rst:75
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"Quando o nome está ligado a um objeto, a avaliação do átomo produz esse "
"objeto. Quando um nome não está ligado, uma tentativa de o avaliar levanta "
"uma exceção :exc:`NameError`."

#: ../../reference/expressions.rst:86
msgid "Private name mangling"
msgstr "Transformação de nomes privados"

#: ../../reference/expressions.rst:88
msgid ""
"When an identifier that textually occurs in a class definition begins with "
"two or more underscore characters and does not end in two or more "
"underscores, it is considered a :dfn:`private name` of that class."
msgstr ""
"Quando um identificador que ocorre textualmente numa definição de classe "
"começa com dois ou mais caracteres de sublinhado e não termina com dois ou "
"mais sublinhados, é considerado um :dfn:`nome privado` dessa classe."

#: ../../reference/expressions.rst:94
msgid "The :ref:`class specifications <class>`."
msgstr "As :ref:`especificações de classe <class>`."

#: ../../reference/expressions.rst:96
msgid ""
"More precisely, private names are transformed to a longer form before code "
"is generated for them.  If the transformed name is longer than 255 "
"characters, implementation-defined truncation may happen."
msgstr ""
"Mais precisamente, os nomes privados são transformados numa forma mais longa "
"antes de ser gerado código para eles. Se o nome transformado tiver mais de "
"255 caracteres, pode ocorrer truncagem definida pela implementação."

#: ../../reference/expressions.rst:100
msgid ""
"The transformation is independent of the syntactical context in which the "
"identifier is used but only the following private identifiers are mangled:"
msgstr ""
"A transformação é independente do contexto sintático em que o identificador "
"é usado, mas apenas os seguintes identificadores privados são transformados:"

#: ../../reference/expressions.rst:103
msgid ""
"Any name used as the name of a variable that is assigned or read or any name "
"of an attribute being accessed."
msgstr ""
"Qualquer nome usado como nome de uma variável que é atribuída ou lida, ou "
"qualquer nome de um atributo que está a ser acedido."

#: ../../reference/expressions.rst:106
msgid ""
"The :attr:`~definition.__name__` attribute of nested functions, classes, and "
"type aliases is however not mangled."
msgstr ""
"O atributo :attr:`~definition.__name__` de funções aninhadas, classes e "
"apelidos de tipo não é, no entanto, transformado."

#: ../../reference/expressions.rst:109
msgid ""
"The name of imported modules, e.g., ``__spam`` in ``import __spam``. If the "
"module is part of a package (i.e., its name contains a dot), the name is "
"*not* mangled, e.g., the ``__foo`` in ``import __foo.bar`` is not mangled."
msgstr ""
"O nome de módulos importados, por exemplo, ``__spam`` em ``import __spam``. "
"Se o módulo fizer parte de um pacote (ou seja, se o seu nome contiver um "
"ponto), o nome *não* é transformado, por exemplo, o ``__foo`` em ``import "
"__foo.bar`` não é transformado."

#: ../../reference/expressions.rst:114
msgid ""
"The name of an imported member, e.g., ``__f`` in ``from spam import __f``."
msgstr ""
"O nome de um membro importado, por exemplo, ``__f`` em ``from spam import "
"__f``."

#: ../../reference/expressions.rst:116
msgid "The transformation rule is defined as follows:"
msgstr "A regra de transformação é definida da seguinte forma:"

#: ../../reference/expressions.rst:118
msgid ""
"The class name, with leading underscores removed and a single leading "
"underscore inserted, is inserted in front of the identifier, e.g., the "
"identifier ``__spam`` occurring in a class named ``Foo``, ``_Foo`` or "
"``__Foo`` is transformed to ``_Foo__spam``."
msgstr ""
"O nome da classe, com os sublinhados iniciais removidos e um único "
"sublinhado inserido no início, é inserido antes do identificador, por "
"exemplo, o identificador ``__spam`` que ocorre numa classe chamada ``Foo``, "
"``_Foo`` ou ``__Foo`` é transformado em ``_Foo__spam``."

#: ../../reference/expressions.rst:123
msgid ""
"If the class name consists only of underscores, the transformation is the "
"identity, e.g., the identifier ``__spam`` occurring in a class named ``_`` "
"or ``__`` is left as is."
msgstr ""
"Se o nome da classe for constituído apenas por sublinhados, a transformação "
"é a identidade, por exemplo, o identificador ``__spam`` que ocorre numa "
"classe chamada ``_`` ou ``__`` permanece inalterado."

#: ../../reference/expressions.rst:130
msgid "Literals"
msgstr "Literais"

#: ../../reference/expressions.rst:134
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr "Python suporta literais de strings, bytes e vários literais numéricos:"

#: ../../reference/expressions.rst:141
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating-point number, complex number) with the given value.  The "
"value may be approximated in the case of floating-point and imaginary "
"(complex) literals. See section :ref:`literals` for details. See section :"
"ref:`string-concatenation` for details on ``strings``."
msgstr ""
"A avaliação de um literal produz um objeto do tipo dado (string, bytes, "
"inteiro, número de vírgula flutuante, número complexo) com o valor dado. O "
"valor pode ser aproximado no caso de literais de vírgula flutuante e "
"imaginários (complexos). Consulte a secção :ref:`literals` para mais "
"detalhes. Consulte a secção :ref:`string-concatenation` para detalhes sobre "
"``strings``."

#: ../../reference/expressions.rst:153
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Todos os literais correspondem a tipos de dados imutáveis, pelo que a "
"identidade do objeto é menos importante do que o seu valor. Várias "
"avaliações de literais com o mesmo valor (seja a mesma ocorrência no texto "
"do programa ou uma ocorrência diferente) podem obter o mesmo objeto ou um "
"objeto diferente com o mesmo valor."

#: ../../reference/expressions.rst:163
msgid "String literal concatenation"
msgstr "Concatenação de literais de strings"

#: ../../reference/expressions.rst:165
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation::"
msgstr ""
"Vários literais de strings ou bytes adjacentes (delimitados por espaços em "
"branco), possivelmente usando convenções de aspas diferentes, são "
"permitidos, e o seu significado é o mesmo que a sua concatenação::"

#: ../../reference/expressions.rst:169
msgid ""
">>> \"hello\" 'world'\n"
"\"helloworld\""
msgstr ""
">>> \"olá\" 'mundo'\n"
"\"olámundo\""

#: ../../reference/expressions.rst:172
msgid "Formally:"
msgstr "Formalmente:"

#: ../../reference/expressions.rst:179
msgid ""
"This feature is defined at the syntactical level, so it only works with "
"literals. To concatenate string expressions at run time, the '+' operator "
"may be used::"
msgstr ""
"Esta funcionalidade é definida ao nível sintático, pelo que só funciona com "
"literais. Para concatenar expressões de strings em tempo de execução, pode "
"ser usado o operador '+'::"

#: ../../reference/expressions.rst:182
msgid ""
">>> greeting = \"Hello\"\n"
">>> space = \" \"\n"
">>> name = \"Blaise\"\n"
">>> print(greeting + space + name)   # not: print(greeting space name)\n"
"Hello Blaise"
msgstr ""
">>> saudacao = \"Olá\"\n"
">>> espaco = \" \"\n"
">>> nome = \"Blaise\"\n"
">>> print(saudacao + espaco + nome)   # não: print(saudacao espaco nome)\n"
"Olá Blaise"

#: ../../reference/expressions.rst:188
msgid ""
"Literal concatenation can freely mix raw strings, triple-quoted strings, and "
"formatted string literals. For example::"
msgstr ""
"A concatenação de literais pode misturar livremente strings brutas, strings "
"com triplas aspas e literais de strings formatadas. Por exemplo::"

#: ../../reference/expressions.rst:192
msgid ""
">>> \"Hello\" r', ' f\"{name}!\"\n"
"\"Hello, Blaise!\""
msgstr ""
">>> \"Olá\" r', ' f\"{nome}!\"\n"
"\"Olá, Blaise!\""

#: ../../reference/expressions.rst:195
msgid ""
"This feature can be used to reduce the number of backslashes needed, to "
"split long strings conveniently across long lines, or even to add comments "
"to parts of strings. For example::"
msgstr ""
"Esta funcionalidade pode ser usada para reduzir o número de barras "
"invertidas necessárias, dividir strings longas convenientemente por várias "
"linhas, ou até adicionar comentários a partes de strings. Por exemplo::"

#: ../../reference/expressions.rst:199
msgid ""
"re.compile(\"[A-Za-z_]\"       # letter or underscore\n"
"           \"[A-Za-z0-9_]*\"   # letter, digit or underscore\n"
"          )"
msgstr ""
"re.compile(\"[A-Za-z_]\"       # letra ou sublinhado\n"
"           \"[A-Za-z0-9_]*\"   # letra, dígito ou sublinhado\n"
"          )"

#: ../../reference/expressions.rst:203
msgid ""
"However, bytes literals may only be combined with other byte literals; not "
"with string literals of any kind. Also, template string literals may only be "
"combined with other template string literals::"
msgstr ""
"No entanto, literais de bytes só podem ser combinados com outros literais de "
"bytes; não com literais de strings de qualquer tipo. Além disso, literais de "
"strings de modelo só podem ser combinados com outros literais de strings de "
"modelo::"

#: ../../reference/expressions.rst:208
msgid ""
">>> t\"Hello\" t\"{name}!\"\n"
"Template(strings=('Hello', '!'), interpolations=(...))"
msgstr ""
">>> t\"Olá\" t\"{nome}!\"\n"
"Template(strings=('Olá', '!'), interpolations=(...))"

#: ../../reference/expressions.rst:215
msgid "Parenthesized forms"
msgstr "Formas entre parênteses"

#: ../../reference/expressions.rst:221
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""
"Uma forma entre parênteses é uma lista de expressões opcional delimitada por "
"parênteses:"

#: ../../reference/expressions.rst:226
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"Uma lista de expressões entre parênteses produz o que essa lista de "
"expressões produz: se a lista contiver pelo menos uma vírgula, produz um "
"tuplo; caso contrário, produz a expressão única que constitui a lista de "
"expressões."

#: ../../reference/expressions.rst:232
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Um par de parênteses vazio produz um objeto de tuplo vazio. Como os tuplos "
"são imutáveis, aplicam-se as mesmas regras que para os literais (ou seja, "
"duas ocorrências do tuplo vazio podem ou não produzir o mesmo objeto)."

#: ../../reference/expressions.rst:240
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma.  The exception is the empty tuple, for which parentheses *are* "
"required --- allowing unparenthesized \"nothing\" in expressions would cause "
"ambiguities and allow common typos to pass uncaught."
msgstr ""
"Note que os tuplos não são formados pelos parênteses, mas sim pelo uso da "
"vírgula. A exceção é o tuplo vazio, para o qual os parênteses *são* "
"obrigatórios — permitir \"nada\" sem parênteses em expressões causaria "
"ambiguidades e permitiria que erros comuns passassem despercebidos."

#: ../../reference/expressions.rst:249
msgid "Displays for lists, sets and dictionaries"
msgstr "Exibições para listas, conjuntos e dicionários"

#: ../../reference/expressions.rst:253
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Para construir uma lista, um conjunto ou um dicionário, Python fornece uma "
"sintaxe especial chamada \"exibições\", cada uma em duas variantes:"

#: ../../reference/expressions.rst:256
msgid "either the container contents are listed explicitly, or"
msgstr "ou os conteúdos do contentor são listados explicitamente, ou"

#: ../../reference/expressions.rst:258
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"são calculados através de um conjunto de instruções de iteração e filtragem, "
"chamado :dfn:`compreensão`."

#: ../../reference/expressions.rst:266
msgid "Common syntax elements for comprehensions are:"
msgstr "Os elementos sintáticos comuns para compreensões são:"

#: ../../reference/expressions.rst:274
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"A compreensão consiste numa expressão única seguida de pelo menos uma "
"cláusula :keyword:`!for` e zero ou mais cláusulas :keyword:`!for` ou :"
"keyword:`!if`. Neste caso, os elementos do novo contentor são aqueles que "
"seriam produzidos ao considerar cada uma das cláusulas :keyword:`!for` ou :"
"keyword:`!if` como um bloco, aninhando da esquerda para a direita, e "
"avaliando a expressão para produzir um elemento cada vez que o bloco mais "
"interno é atingido."

#: ../../reference/expressions.rst:281
msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"No entanto, à exceção da expressão iterável na cláusula :keyword:`!for` mais "
"à esquerda, a compreensão é executada num âmbito aninhado implicitamente "
"separado. Isto garante que os nomes atribuídos na lista de destino não "
"\"vazam\" para o âmbito envolvente."

#: ../../reference/expressions.rst:285
msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"A expressão iterável na cláusula :keyword:`!for` mais à esquerda é avaliada "
"diretamente no âmbito envolvente e depois passada como argumento para o "
"âmbitos aninhado implicitamente. As cláusulas :keyword:`!for` subsequentes e "
"qualquer condição de filtro na cláusula :keyword:`!for` mais à esquerda não "
"podem ser avaliadas no âmbito envolvente, pois podem depender dos valores "
"obtidos do iterável mais à esquerda. Por exemplo: ``[x*y for x in range(10) "
"for y in range(x, x+10)]``."

#: ../../reference/expressions.rst:292
msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"Para garantir que a compreensão resulte sempre num contentor do tipo "
"apropriado, as expressões ``yield`` e ``yield from`` são proibidas no âmbito "
"aninhado implicitamente."

#: ../../reference/expressions.rst:299
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions."
msgstr ""
"Desde o Python 3.6, numa função :keyword:`async def`, pode ser usada uma "
"cláusula :keyword:`!async for` para iterar sobre um :term:`iterador "
"assíncrono`. Uma compreensão numa função :keyword:`!async def` pode "
"consistir num cláusula :keyword:`!for` ou :keyword:`!async for` após a "
"expressão inicial, pode conter cláusulas adicionais :keyword:`!for` ou :"
"keyword:`!async for`, e pode também usar expressões :keyword:`await`."

#: ../../reference/expressions.rst:306
msgid ""
"If a comprehension contains :keyword:`!async for` clauses, or if it "
"contains :keyword:`!await` expressions or other asynchronous comprehensions "
"anywhere except the iterable expression in the leftmost :keyword:`!for` "
"clause, it is called an :dfn:`asynchronous comprehension`. An asynchronous "
"comprehension may suspend the execution of the coroutine function in which "
"it appears. See also :pep:`530`."
msgstr ""
"Se uma compreensão contiver cláusulas :keyword:`!async for`, ou se contiver "
"expressões :keyword:`!await` ou outras compreensões assíncronas em qualquer "
"local exceto na expressão iterável na cláusula :keyword:`!for` mais à "
"esquerda, é chamada de :dfn:`compreensão assíncrona`. Uma compreensão "
"assíncrona pode suspender a execução da função de corrotina em que aparece. "
"Consulte também :pep:`530`."

#: ../../reference/expressions.rst:313
msgid "Asynchronous comprehensions were introduced."
msgstr "As compreensões assíncronas foram introduzidas."

#: ../../reference/expressions.rst:316 ../../reference/expressions.rst:495
msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr ""
"``yield`` e ``yield from`` proibidos no âmbito aninhado implicitamente."

#: ../../reference/expressions.rst:319
msgid ""
"Asynchronous comprehensions are now allowed inside comprehensions in "
"asynchronous functions. Outer comprehensions implicitly become asynchronous."
msgstr ""
"As compreensões assíncronas são agora permitidas dentro de compreensões em "
"funções assíncronas. As compreensões externas tornam-se implicitamente "
"assíncronas."

#: ../../reference/expressions.rst:328
msgid "List displays"
msgstr "Exibições de listas"

#: ../../reference/expressions.rst:338
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"Uma exibição de lista é uma série possivelmente vazia de expressões "
"delimitada por parênteses retos:"

#: ../../reference/expressions.rst:344
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Uma exibição de lista produz um novo objeto de lista, cujos conteúdos são "
"especificados por uma lista de expressões ou uma compreensão. Quando é "
"fornecida uma lista de expressões separadas por vírgulas, os seus elementos "
"são avaliados da esquerda para a direita e colocados no objeto de lista "
"nessa ordem. Quando é fornecida uma compreensão, a lista é construída a "
"partir dos elementos resultantes da compreensão."

#: ../../reference/expressions.rst:354
msgid "Set displays"
msgstr "Exibições de conjuntos"

#: ../../reference/expressions.rst:363
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"Uma exibição de conjunto é denotada por chavetas e distinguível das "
"exibições de dicionário pela ausência de dois-pontos a separar chaves e "
"valores:"

#: ../../reference/expressions.rst:369
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Uma exibição de conjunto produz um novo objeto de conjunto mutável, cujos "
"conteúdos são especificados por uma sequência de expressões ou uma "
"compreensão. Quando é fornecida uma lista de expressões separadas por "
"vírgulas, os seus elementos são avaliados da esquerda para a direita e "
"adicionados ao objeto de conjunto. Quando é fornecida uma compreensão, o "
"conjunto é construído a partir dos elementos resultantes da compreensão."

#: ../../reference/expressions.rst:375
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"Um conjunto vazio não pode ser construído com ``{}``; este literal constrói "
"um dicionário vazio."

#: ../../reference/expressions.rst:382
msgid "Dictionary displays"
msgstr "Exibições de dicionários"

#: ../../reference/expressions.rst:393
msgid ""
"A dictionary display is a possibly empty series of dict items (key/value "
"pairs) enclosed in curly braces:"
msgstr ""
"Uma exibição de dicionário é uma série possivelmente vazia de itens de "
"dicionário (pares chave/valor) delimitada por chavetas:"

#: ../../reference/expressions.rst:402
msgid "A dictionary display yields a new dictionary object."
msgstr "Uma exibição de dicionário produz um novo objeto de dicionário."

#: ../../reference/expressions.rst:404
msgid ""
"If a comma-separated sequence of dict items is given, they are evaluated "
"from left to right to define the entries of the dictionary: each key object "
"is used as a key into the dictionary to store the corresponding value.  This "
"means that you can specify the same key multiple times in the dict item "
"list, and the final dictionary's value for that key will be the last one "
"given."
msgstr ""
"Se for fornecida uma sequência de itens de dicionário separados por "
"vírgulas, estes são avaliados da esquerda para a direita para definir as "
"entradas do dicionário: cada objeto de chave é usado como chave no "
"dicionário para armazenar o valor correspondente. Isto significa que pode "
"especificar a mesma chave várias vezes na lista de itens do dicionário, e o "
"valor final do dicionário para essa chave será o último fornecido."

#: ../../reference/expressions.rst:414
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier dict items "
"and earlier dictionary unpackings."
msgstr ""
"Um duplo asterisco ``**`` denota :dfn:`desempacotamento de dicionário`. O "
"seu operando deve ser um :term:`mapeamento`. Cada item do mapeamento é "
"adicionado ao novo dicionário. Valores posteriores substituem valores já "
"definidos por itens de dicionário anteriores e desempacotamentos de "
"dicionário anteriores."

#: ../../reference/expressions.rst:419
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""
"Desempacotamento em exibições de dicionário, originalmente proposto por :pep:"
"`448`."

#: ../../reference/expressions.rst:422
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"Uma compreensão de dicionário, ao contrário das compreensões de listas e "
"conjuntos, necessita de duas expressões separadas por dois-pontos, seguidas "
"das cláusulas habituais \"for\" e \"if\". Quando a compreensão é executada, "
"os elementos de chave e valor resultantes são inseridos no novo dicionário "
"pela ordem em que são produzidos."

#: ../../reference/expressions.rst:430
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last value (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"As restrições aos tipos dos valores de chave estão listadas anteriormente na "
"secção :ref:`types`. (Resumindo, o tipo de chave deve ser :term:`hashable`, "
"o que exclui todos os objetos mutáveis.) Conflitos entre chaves duplicadas "
"não são detetados; o último valor (o mais à direita no texto da exibição) "
"armazenado para um determinado valor de chave prevalece."

#: ../../reference/expressions.rst:436
msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"Antes do Python 3.8, nas compreensões de dicionário, a ordem de avaliação da "
"chave e do valor não estava bem definida. No CPython, o valor era avaliado "
"antes da chave. A partir do 3.8, a chave é avaliada antes do valor, como "
"proposto por :pep:`572`."

#: ../../reference/expressions.rst:446
msgid "Generator expressions"
msgstr "Expressões geradoras"

#: ../../reference/expressions.rst:453
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""
"Uma expressão geradora é uma notação compacta de gerador entre parênteses:"

#: ../../reference/expressions.rst:458
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Uma expressão geradora produz um novo objeto gerador. A sua sintaxe é a "
"mesma que para as compreensões, exceto que está delimitada por parênteses em "
"vez de parênteses retos ou chavetas."

#: ../../reference/expressions.rst:462
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, and the :term:"
"`iterator` is immediately created for that iterable, so that an error "
"produced while creating the iterator will be emitted at the point where the "
"generator expression is defined, rather than at the point where the first "
"value is retrieved. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"As variáveis usadas na expressão geradora são avaliadas de forma preguiçosa "
"quando o método :meth:`~generator.__next__` é chamado para o objeto gerador "
"(da mesma forma que os geradores normais). No entanto, a expressão iterável "
"na cláusula :keyword:`!for` mais à esquerda é avaliada imediatamente, e o :"
"term:`iterador` é criado imediatamente para esse iterável, de modo que um "
"erro produzido ao criar o iterador será emitido no ponto em que a expressão "
"geradora é definida, em vez de no ponto em que o primeiro valor é obtido. As "
"cláusulas :keyword:`!for` subsequentes e qualquer condição de filtro na "
"cláusula :keyword:`!for` mais à esquerda não podem ser avaliadas no âmbito "
"envolvente, pois podem depender dos valores obtidos do iterável mais à "
"esquerda. Por exemplo: ``(x*y for x in range(10) for y in range(x, x+10))``."

#: ../../reference/expressions.rst:474
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"Os parênteses podem ser omitidos em chamadas com apenas um argumento. "
"Consulte a secção :ref:`calls` para mais detalhes."

#: ../../reference/expressions.rst:477
msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"Para evitar interferir com a operação esperada da expressão geradora, as "
"expressões ``yield`` e ``yield from`` são proibidas no gerador definido "
"implicitamente."

#: ../../reference/expressions.rst:481
msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Se uma expressão geradora contiver cláusulas :keyword:`!async for` ou "
"expressões :keyword:`await`, é chamada de :dfn:`expressão geradora "
"assíncrona`. Uma expressão geradora assíncrona devolve um novo objeto "
"gerador assíncrono, que é um iterador assíncrono (consulte :ref:`async-"
"iterators`)."

#: ../../reference/expressions.rst:487
msgid "Asynchronous generator expressions were introduced."
msgstr "As expressões geradoras assíncronas foram introduzidas."

#: ../../reference/expressions.rst:490
msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"Antes do Python 3.7, as expressões geradoras assíncronas só podiam aparecer "
"em corrotinas :keyword:`async def`. A partir do 3.7, qualquer função pode "
"usar expressões geradoras assíncronas."

#: ../../reference/expressions.rst:502
msgid "Yield expressions"
msgstr "Expressões yield"

#: ../../reference/expressions.rst:515
msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"A expressão yield é usada ao definir uma função :term:`geradora` ou uma "
"função :term:`geradora assíncrona` e, portanto, só pode ser usada no corpo "
"de uma definição de função. O uso de uma expressão yield no corpo de uma "
"função faz com que essa função seja uma função geradora, e usá-la no corpo "
"de uma função :keyword:`async def` faz com que essa função de corrotina seja "
"uma função geradora assíncrona. Por exemplo::"

#: ../../reference/expressions.rst:522
msgid ""
"def gen():  # defines a generator function\n"
"    yield 123\n"
"\n"
"async def agen(): # defines an asynchronous generator function\n"
"    yield 123"
msgstr ""
"def gen():  # define uma função geradora\n"
"    yield 123\n"
"\n"
"async def agen(): # define uma função geradora assíncrona\n"
"    yield 123"

#: ../../reference/expressions.rst:528
msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"Devido aos seus efeitos laterais no âmbito contido, as expressões ``yield`` "
"não são permitidas como parte dos âmbitos implicitamente definidos usados "
"para implementar compreensões e expressões geradoras."

#: ../../reference/expressions.rst:532
msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Expressões yield proibidas nos âmbitos aninhados implicitamente usados para "
"implementar compreensões e expressões geradoras."

#: ../../reference/expressions.rst:536
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"As funções geradoras são descritas abaixo, enquanto as funções geradoras "
"assíncronas são descritas separadamente na secção :ref:`asynchronous-"
"generator-functions`."

#: ../../reference/expressions.rst:540
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"yield_list` to the generator's caller, or ``None`` if :token:`~python-"
"grammar:yield_list` is omitted. By suspended, we mean that all local state "
"is retained, including the current bindings of local variables, the "
"instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""
"Quando uma função geradora é chamada, devolve um iterador conhecido como "
"gerador. Esse gerador controla então a execução da função geradora. A "
"execução começa quando um dos métodos do gerador é chamado. Nesse momento, a "
"execução procede até à primeira expressão yield, onde é novamente suspensa, "
"devolvendo o valor de :token:`~python-grammar:yield_list` ao chamador do "
"gerador, ou ``None`` se :token:`~python-grammar:yield_list` for omitido. Por "
"suspensa, entende-se que todo o estado local é retido, incluindo as ligações "
"atuais de variáveis locais, o ponteiro de instrução, a pilha de avaliação "
"interna e o estado de qualquer tratamento de exceções. Quando a execução é "
"retomada ao chamar um dos métodos do gerador, a função pode prosseguir "
"exatamente como se a expressão yield fosse apenas outra chamada externa. O "
"valor da expressão yield após a retomada depende do método que retomou a "
"execução. Se for usado :meth:`~generator.__next__` (normalmente através de "
"um :keyword:`for` ou da função integrada :func:`next`), o resultado é :const:"
"`None`. Caso contrário, se for usado :meth:`~generator.send`, o resultado "
"será o valor passado para esse método."

#: ../../reference/expressions.rst:560
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Tudo isto torna as funções geradoras bastante semelhantes a corrotinas; "
"produzem vários valores, têm mais do que um ponto de entrada e a sua "
"execução pode ser suspensa. A única diferença é que uma função geradora não "
"pode controlar onde a execução deve continuar após produzir um valor; o "
"controlo é sempre transferido para o chamador do gerador."

#: ../../reference/expressions.rst:566
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"As expressões yield são permitidas em qualquer lugar numa construção :"
"keyword:`try`. Se o gerador não for retomado antes de ser finalizado (ao "
"atingir uma contagem de referências zero ou ao ser recolhido pelo recolhedor "
"de lixo), o método :meth:`~generator.close` do iterador do gerador será "
"chamado, permitindo que quaisquer cláusulas :keyword:`finally` pendentes "
"sejam executadas."

#: ../../reference/expressions.rst:575
msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"Quando ``yield from <expr>`` é usado, a expressão fornecida deve ser um "
"iterável. Os valores produzidos ao iterar esse iterável são passados "
"diretamente para o chamador dos métodos do gerador atual. Quaisquer valores "
"passados com :meth:`~generator.send` e quaisquer exceções passadas com :meth:"
"`~generator.throw` são passados para o iterador subjacente se este tiver os "
"métodos apropriados. Se não for o caso, então :meth:`~generator.send` "
"levantará :exc:`AttributeError` ou :exc:`TypeError`, enquanto :meth:"
"`~generator.throw` levantará simplesmente a exceção passada imediatamente."

#: ../../reference/expressions.rst:584
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"Quando o iterador subjacente está completo, o atributo :attr:`~StopIteration."
"value` da instância :exc:`StopIteration` levantada torna-se o valor da "
"expressão yield. Pode ser definido explicitamente ao levantar :exc:"
"`StopIteration`, ou automaticamente quando o subiterador é um gerador (ao "
"devolver um valor do subgerador)."

#: ../../reference/expressions.rst:590
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"Adicionado ``yield from <expr>`` para delegar o fluxo de controlo a um "
"subiterador."

#: ../../reference/expressions.rst:593
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Os parênteses podem ser omitidos quando a expressão yield é a única "
"expressão do lado direito de uma instrução de atribuição."

#: ../../reference/expressions.rst:598
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Geradores Simples"

#: ../../reference/expressions.rst:599
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"A proposta para adicionar geradores e a instrução :keyword:`yield` ao Python."

#: ../../reference/expressions.rst:601
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - Corrotinas através de Geradores Melhorados"

#: ../../reference/expressions.rst:602
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"A proposta para melhorar a API e a sintaxe dos geradores, tornando-os "
"utilizáveis como corrotinas simples."

#: ../../reference/expressions.rst:605
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - Sintaxe para Delegação a um Subgerador"

#: ../../reference/expressions.rst:606
msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr ""
"A proposta para introduzir a sintaxe :token:`~python-grammar:yield_from`, "
"facilitando a delegação a subgeradores."

#: ../../reference/expressions.rst:609
msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - Geradores Assíncronos"

#: ../../reference/expressions.rst:610
msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"A proposta que expandiu a :pep:`492` ao adicionar capacidades de gerador a "
"funções de corrotina."

#: ../../reference/expressions.rst:617
msgid "Generator-iterator methods"
msgstr "Métodos do iterador-gerador"

#: ../../reference/expressions.rst:619
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"Esta subsecção descreve os métodos de um iterador de gerador. Podem ser "
"usados para controlar a execução de uma função geradora."

#: ../../reference/expressions.rst:622
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Note que chamar qualquer um dos métodos do gerador abaixo quando o gerador "
"já está em execução levanta uma exceção :exc:`ValueError`."

#: ../../reference/expressions.rst:630
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:yield_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""
"Inicia a execução de uma função geradora ou retoma-a na última expressão "
"yield executada. Quando uma função geradora é retomada com o método :meth:"
"`~generator.__next__`, a expressão yield atual avalia sempre para :const:"
"`None`. A execução continua então para a próxima expressão yield, onde o "
"gerador é novamente suspenso, e o valor de :token:`~python-grammar:"
"yield_list` é devolvido ao chamador de :meth:`__next__`. Se o gerador sair "
"sem produzir outro valor, é levantada uma exceção :exc:`StopIteration`."

#: ../../reference/expressions.rst:639
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Este método é normalmente chamado implicitamente, por exemplo, por um ciclo :"
"keyword:`for` ou pela função integrada :func:`next`."

#: ../../reference/expressions.rst:645
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Retoma a execução e \"envia\" um valor para a função geradora. O argumento "
"*value* torna-se o resultado da expressão yield atual. O método :meth:`send` "
"devolve o próximo valor produzido pelo gerador, ou levanta :exc:"
"`StopIteration` se o gerador sair sem produzir outro valor. Quando :meth:"
"`send` é chamado para iniciar o gerador, deve ser chamado com :const:`None` "
"como argumento, porque não existe uma expressão yield que possa receber o "
"valor."

#: ../../reference/expressions.rst:657
msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"Levanta uma exceção no ponto onde o gerador foi pausado e devolve o próximo "
"valor produzido pela função geradora. Se o gerador sair sem produzir outro "
"valor, é levantada uma exceção :exc:`StopIteration`. Se a função geradora "
"não capturar a exceção passada, ou levantar uma exceção diferente, essa "
"exceção propaga-se para o chamador."

#: ../../reference/expressions.rst:663
msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr ""
"Em uso típico, isto é chamado com uma única instância de exceção, de forma "
"semelhante à palavra-chave :keyword:`raise`."

#: ../../reference/expressions.rst:666
msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""
"Para compatibilidade retroativa, no entanto, a segunda assinatura é "
"suportada, seguindo uma convenção de versões mais antigas do Python. O "
"argumento *type* deve ser uma classe de exceção, e *value* deve ser uma "
"instância de exceção. Se o *value* não for fornecido, o construtor *type* é "
"chamado para obter uma instância. Se *traceback* for fornecido, é definido "
"na exceção; caso contrário, qualquer atributo :attr:`~BaseException."
"__traceback__` existente armazenado em *value* pode ser limpo."

#: ../../reference/expressions.rst:677 ../../reference/expressions.rst:863
msgid ""
"The second signature \\(type\\[, value\\[, traceback\\]\\]\\) is deprecated "
"and may be removed in a future version of Python."
msgstr ""
"A segunda assinatura \\(type\\[, value\\[, traceback\\]\\]\\) está obsoleta "
"e pode ser removida numa versão futura do Python."

#: ../../reference/expressions.rst:685
msgid ""
"Raises a :exc:`GeneratorExit` exception at the point where the generator "
"function was paused (equivalent to calling ``throw(GeneratorExit)``). The "
"exception is raised by the yield expression where the generator was paused. "
"If the generator function catches the exception and returns a value, this "
"value is returned from :meth:`close`.  If the generator function is already "
"closed, or raises :exc:`GeneratorExit` (by not catching the exception), :"
"meth:`close` returns :const:`None`.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  If the generator has already exited due to an "
"exception or normal exit, :meth:`close` returns :const:`None` and has no "
"other effect."
msgstr ""
"Levanta uma exceção :exc:`GeneratorExit` no ponto onde a função geradora foi "
"pausada (equivalente a chamar ``throw(GeneratorExit)``). A exceção é "
"levantada pela expressão yield onde o gerador foi pausado. Se a função "
"geradora capturar a exceção e devolver um valor, este valor é devolvido por :"
"meth:`close`. Se a função geradora já estiver fechada, ou levantar :exc:"
"`GeneratorExit` (ao não capturar a exceção), :meth:`close` devolve :const:"
"`None`. Se o gerador produzir um valor, é levantada uma exceção :exc:"
"`RuntimeError`. Se o gerador levantar qualquer outra exceção, esta é "
"propagada para o chamador. Se o gerador já tiver saído devido a uma exceção "
"ou saída normal, :meth:`close` devolve :const:`None` e não tem outro efeito."

#: ../../reference/expressions.rst:699
msgid ""
"If a generator returns a value upon being closed, the value is returned by :"
"meth:`close`."
msgstr ""
"Se um gerador devolver um valor ao ser fechado, o valor é devolvido por :"
"meth:`close`."

#: ../../reference/expressions.rst:705
msgid "Examples"
msgstr "Exemplos"

#: ../../reference/expressions.rst:707
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Segue-se um exemplo simples que demonstra o comportamento dos geradores e "
"das funções geradoras::"

#: ../../reference/expressions.rst:710
msgid ""
">>> def echo(value=None):\n"
"...     print(\"Execution starts when 'next()' is called for the first time."
"\")\n"
"...     try:\n"
"...         while True:\n"
"...             try:\n"
"...                 value = (yield value)\n"
"...             except Exception as e:\n"
"...                 value = e\n"
"...     finally:\n"
"...         print(\"Don't forget to clean up when 'close()' is called.\")\n"
"...\n"
">>> generator = echo(1)\n"
">>> print(next(generator))\n"
"Execution starts when 'next()' is called for the first time.\n"
"1\n"
">>> print(next(generator))\n"
"None\n"
">>> print(generator.send(2))\n"
"2\n"
">>> generator.throw(TypeError, \"spam\")\n"
"TypeError('spam',)\n"
">>> generator.close()\n"
"Don't forget to clean up when 'close()' is called."
msgstr ""
">>> def eco(valor=None):\n"
"...     print(\"A execução começa quando 'next()' é chamado pela primeira "
"vez.\")\n"
"...     try:\n"
"...         while True:\n"
"...             try:\n"
"...                 valor = (yield valor)\n"
"...             except Exception as e:\n"
"...                 valor = e\n"
"...     finally:\n"
"...         print(\"Não se esqueça de limpar quando 'close()' é chamado.\")\n"
"...\n"
">>> gerador = eco(1)\n"
">>> print(next(gerador))\n"
"A execução começa quando 'next()' é chamado pela primeira vez.\n"
"1\n"
">>> print(next(gerador))\n"
"None\n"
">>> print(gerador.send(2))\n"
"2\n"
">>> gerador.throw(TypeError, \"spam\")\n"
"TypeError('spam',)\n"
">>> gerador.close()\n"
"Não se esqueça de limpar quando 'close()' é chamado."

#: ../../reference/expressions.rst:734
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"Para exemplos que usam ``yield from``, consulte :ref:`pep-380` em \"O que há "
"de novo no Python\"."

#: ../../reference/expressions.rst:740
msgid "Asynchronous generator functions"
msgstr "Funções geradoras assíncronas"

#: ../../reference/expressions.rst:742
msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"A presença de uma expressão yield numa função ou método definido usando :"
"keyword:`async def` define ainda mais a função como uma função :term:"
"`geradora assíncrona`."

#: ../../reference/expressions.rst:746
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"Quando uma função geradora assíncrona é chamada, devolve um iterador "
"assíncrono conhecido como objeto gerador assíncrono. Esse objeto controla "
"então a execução da função geradora. Um objeto gerador assíncrono é "
"tipicamente usado numa instrução :keyword:`async for` numa função de "
"corrotina, de forma análoga a como um objeto gerador seria usado numa "
"instrução :keyword:`for`."

#: ../../reference/expressions.rst:753
msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"yield_list` to the awaiting coroutine. As with a generator, suspension means "
"that all local state is retained, including the current bindings of local "
"variables, the instruction pointer, the internal evaluation stack, and the "
"state of any exception handling. When the execution is resumed by awaiting "
"on the next object returned by the asynchronous generator's methods, the "
"function can proceed exactly as if the yield expression were just another "
"external call. The value of the yield expression after resuming depends on "
"the method which resumed the execution.  If :meth:`~agen.__anext__` is used "
"then the result is :const:`None`. Otherwise, if :meth:`~agen.asend` is used, "
"then the result will be the value passed in to that method."
msgstr ""
"A chamada a um dos métodos do gerador assíncrono devolve um objeto :term:"
"`awaitable`, e a execução começa quando este objeto é aguardado. Nesse "
"momento, a execução prossegue para a primeira expressão yield, onde é "
"novamente suspensa, devolvendo o valor de :token:`~python-grammar:"
"yield_list` para a corrotina que aguarda. Tal como num gerador, a suspensão "
"significa que todo o estado local é retido, incluindo as ligações atuais de "
"variáveis locais, o ponteiro de instrução, a pilha de avaliação interna e o "
"estado de qualquer tratamento de exceções. Quando a execução é retomada ao "
"aguardar o próximo objeto devolvido pelos métodos do gerador assíncrono, a "
"função pode prosseguir exatamente como se a expressão yield fosse apenas "
"outra chamada externa. O valor da expressão yield após a retomada depende do "
"método que retomou a execução. Se for usado :meth:`~agen.__anext__`, o "
"resultado é :const:`None`. Caso contrário, se for usado :meth:`~agen.asend`, "
"o resultado será o valor passado para esse método."

#: ../../reference/expressions.rst:768
msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"Se um gerador assíncrono sair prematuramente devido a um :keyword:`break`, "
"ao cancelamento da tarefa chamadora, ou a outras exceções, o código de "
"limpeza assíncrono do gerador será executado e pode levantar exceções ou "
"aceder a variáveis de contexto num contexto inesperado — possivelmente após "
"o tempo de vida das tarefas das quais depende, ou durante o encerramento do "
"ciclo de eventos quando o gancho de recolha de lixo do gerador assíncrono é "
"chamado. Para evitar isto, o chamador deve fechar explicitamente o gerador "
"assíncrono ao chamar o método :meth:`~agen.aclose` para finalizar o gerador "
"e, eventualmente, desligá-lo do ciclo de eventos."

#: ../../reference/expressions.rst:778
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"Numa função geradora assíncrona, as expressões yield são permitidas em "
"qualquer lugar numa construção :keyword:`try`. No entanto, se um gerador "
"assíncrono não for retomado antes de ser finalizado (ao atingir uma contagem "
"de referências zero ou ao ser recolhido pelo recolhedor de lixo), então uma "
"expressão yield dentro de uma construção :keyword:`!try` pode resultar numa "
"falha na execução de cláusulas :keyword:`finally` pendentes. Neste caso, é "
"da responsabilidade do ciclo de eventos ou do escalonador que executa o "
"gerador assíncrono chamar o método :meth:`~agen.aclose` do iterador do "
"gerador assíncrono e executar o objeto de corrotina resultante, permitindo "
"assim que quaisquer cláusulas :keyword:`!finally` pendentes sejam executadas."

#: ../../reference/expressions.rst:789
msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"Para tratar da finalização ao terminar o ciclo de eventos, um ciclo de "
"eventos deve definir uma função *finalizer* que recebe um iterador de "
"gerador assíncrono e, presumivelmente, chama :meth:`~agen.aclose` e executa "
"a corrotina. Este *finalizer* pode ser registado chamando :func:`sys."
"set_asyncgen_hooks`. Quando iterado pela primeira vez, um iterador de "
"gerador assíncrono armazenará o *finalizer* registado para ser chamado "
"durante a finalização. Para um exemplo de referência de um método "
"*finalizer*, consulte a implementação de ``asyncio.Loop.shutdown_asyncgens`` "
"em :source:`Lib/asyncio/base_events.py`."

#: ../../reference/expressions.rst:798
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"A expressão ``yield from <expr>`` é um erro de sintaxe quando usada numa "
"função geradora assíncrona."

#: ../../reference/expressions.rst:805
msgid "Asynchronous generator-iterator methods"
msgstr "Métodos do iterador-gerador assíncrono"

#: ../../reference/expressions.rst:807
msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"Esta subsecção descreve os métodos de um iterador de gerador assíncrono, que "
"são usados para controlar a execução de uma função geradora."

#: ../../reference/expressions.rst:816
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:yield_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""
"Devolve um objeto aguardável que, quando executado, inicia a execução do "
"gerador assíncrono ou retoma-a na última expressão yield executada. Quando "
"uma função geradora assíncrona é retomada com um método :meth:`~agen."
"__anext__`, a expressão yield atual avalia sempre para :const:`None` no "
"objeto aguardável devolvido, que, quando executado, continuará para a "
"próxima expressão yield. O valor de :token:`~python-grammar:yield_list` da "
"expressão yield é o valor da exceção :exc:`StopIteration` levantada pela "
"corrotina concluída. Se o gerador assíncrono sair sem produzir outro valor, "
"o objeto aguardável levanta, em vez disso, uma exceção :exc:"
"`StopAsyncIteration`, sinalizando que a iteração assíncrona foi concluída."

#: ../../reference/expressions.rst:828
msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr ""
"Este método é normalmente chamado implicitamente por um ciclo :keyword:"
"`async for`."

#: ../../reference/expressions.rst:834
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"Devolve um objeto aguardável que, quando executado, retoma a execução do "
"gerador assíncrono. Tal como o método :meth:`~generator.send` para um "
"gerador, este \"envia\" um valor para a função geradora assíncrona, e o "
"argumento *value* torna-se o resultado da expressão yield atual. O objeto "
"aguardável devolvido pelo método :meth:`asend` devolverá o próximo valor "
"produzido pelo gerador como o valor da exceção :exc:`StopIteration` "
"levantada, ou levanta :exc:`StopAsyncIteration` se o gerador assíncrono sair "
"sem produzir outro valor. Quando :meth:`asend` é chamado para iniciar o "
"gerador assíncrono, deve ser chamado com :const:`None` como argumento, "
"porque não existe uma expressão yield que possa receber o valor."

#: ../../reference/expressions.rst:851
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Devolve um objeto aguardável que levanta uma exceção do tipo ``type`` no "
"ponto onde o gerador assíncrono foi pausado e devolve o próximo valor "
"produzido pela função geradora como valor da exceção :exc:`StopIteration` "
"levantada. Se o gerador assíncrono sair sem produzir outro valor, o objeto "
"aguardável levanta uma exceção :exc:`StopAsyncIteration`. Se a função "
"geradora não capturar a exceção passada ou levantar uma exceção diferente, "
"essa exceção propaga-se para o chamador do objeto aguardável."

#: ../../reference/expressions.rst:872
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Devolve um objeto aguardável que, quando executado, lança uma exceção :exc:"
"`GeneratorExit` na função geradora assíncrona no ponto onde estava pausada. "
"Se a função geradora assíncrona sair corretamente, já estiver fechada ou "
"levantar :exc:`GeneratorExit` (ao não capturar a exceção), então o objeto "
"aguardável devolvido levantará uma exceção :exc:`StopIteration`. Qualquer "
"objeto aguardável devolvido por chamadas subsequentes ao gerador assíncrono "
"levantará uma exceção :exc:`StopAsyncIteration`. Se o gerador assíncrono "
"produzir um valor, é levantada uma exceção :exc:`RuntimeError` pelo objeto "
"aguardável. Se o gerador assíncrono levantar qualquer outra exceção, esta é "
"propagada para o chamador do objeto aguardável. Se o gerador assíncrono já "
"tiver saído devido a uma exceção ou saída normal, então chamadas adicionais "
"a :meth:`aclose` devolverão um objeto aguardável que não faz nada."

#: ../../reference/expressions.rst:888
msgid "Primaries"
msgstr "Primários"

#: ../../reference/expressions.rst:892
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Os primários representam as operações mais fortemente ligadas da linguagem. "
"A sua sintaxe é:"

#: ../../reference/expressions.rst:902
msgid "Attribute references"
msgstr "Referências a atributos"

#: ../../reference/expressions.rst:908
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""
"Uma referência a um atributo é um primário seguido de um ponto e um nome:"

#: ../../reference/expressions.rst:918
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier. The type and value produced is "
"determined by the object.  Multiple evaluations of the same attribute "
"reference may yield different objects."
msgstr ""
"O primário deve ser avaliado como um objeto de um tipo que suporta "
"referências a atributos, o que a maioria dos objetos faz. Este objeto é "
"então solicitado a produzir o atributo cujo nome é o identificador. O tipo e "
"o valor produzidos são determinados pelo objeto. Várias avaliações da mesma "
"referência a atributo podem produzir objetos diferentes."

#: ../../reference/expressions.rst:924
msgid ""
"This production can be customized by overriding the :meth:`~object."
"__getattribute__` method or the :meth:`~object.__getattr__` method.  The :"
"meth:`!__getattribute__` method is called first and either returns a value "
"or raises :exc:`AttributeError` if the attribute is not available."
msgstr ""
"Esta produção pode ser personalizada substituindo o método :meth:`~object."
"__getattribute__` ou o método :meth:`~object.__getattr__`. O método :meth:`!"
"__getattribute__` é chamado primeiro e devolve um valor ou levanta :exc:"
"`AttributeError` se o atributo não estiver disponível."

#: ../../reference/expressions.rst:930
msgid ""
"If an :exc:`AttributeError` is raised and the object has a :meth:`!"
"__getattr__` method, that method is called as a fallback."
msgstr ""
"Se for levantada uma exceção :exc:`AttributeError` e o objeto tiver um "
"método :meth:`!__getattr__`, esse método é chamado como recurso alternativo."

#: ../../reference/expressions.rst:936
msgid "Subscriptions"
msgstr "Subscritos"

#: ../../reference/expressions.rst:951
msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"A subscrita de uma instância de uma :ref:`classe contentora <sequence-"
"types>` geralmente seleciona um elemento do contentor. A subscrita de uma :"
"term:`classe genérica <generic type>` geralmente devolve um objeto :ref:"
"`GenericAlias <types-genericalias>`. "

#: ../../reference/expressions.rst:959
msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr ""
"Quando um objeto é subscrito, o interpretador avalia o primário e a lista de "
"expressões."

#: ../../reference/expressions.rst:962
msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"O primário deve ser avaliado como um objeto que suporta subscrita. Um objeto "
"pode suportar subscrita através da definição de um ou ambos os métodos :meth:"
"`~object.__getitem__` e :meth:`~object.__class_getitem__`. Quando o primário "
"é subscrito, o resultado avaliado da lista de expressões é passado para um "
"destes métodos. Para mais detalhes sobre quando ``__class_getitem__`` é "
"chamado em vez de ``__getitem__``, consulte :ref:`classgetitem-versus-"
"getitem`."

#: ../../reference/expressions.rst:969
msgid ""
"If the expression list contains at least one comma, or if any of the "
"expressions are starred, the expression list will evaluate to a :class:"
"`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr ""
"Se a lista de expressões contiver pelo menos uma vírgula, ou se alguma das "
"expressões for precedida por asterisco, a lista de expressões será avaliada "
"como um :class:`tuple` contendo os itens da lista de expressões. Caso "
"contrário, a lista de expressões será avaliada como o valor do único membro "
"da lista."

#: ../../reference/expressions.rst:974
msgid "Expressions in an expression list may be starred. See :pep:`646`."
msgstr ""
"As expressões numa lista de expressões podem ser precedidas por asterisco. "
"Consulte :pep:`646`."

#: ../../reference/expressions.rst:977
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr ""
"Para objetos integrados, existem dois tipos de objetos que suportam "
"subscrita através de :meth:`~object.__getitem__`:"

#: ../../reference/expressions.rst:980
msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"Mapeamentos. Se o primário for um :term:`mapeamento`, a lista de expressões "
"deve ser avaliada como um objeto cujo valor é uma das chaves do mapeamento, "
"e a subscrita seleciona o valor no mapeamento que corresponde a essa chave. "
"Um exemplo de uma classe de mapeamento integrada é a classe :class:`dict`."

#: ../../reference/expressions.rst:984
msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"Sequências. Se o primário for uma :term:`sequência`, a lista de expressões "
"deve ser avaliada como um :class:`int` ou um :class:`slice` (como discutido "
"na secção seguinte). Exemplos de classes de sequência integradas incluem as "
"classes :class:`str`, :class:`list` e :class:`tuple`."

#: ../../reference/expressions.rst:989
msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`~object."
"__getitem__` method, subclasses overriding this method will need to "
"explicitly add that support."
msgstr ""
"A sintaxe formal não faz nenhuma provisão especial para índices negativos "
"em :term:`sequências <sequence>`. No entanto, todas as sequências integradas "
"fornecem um método :meth:`~object.__getitem__` que interpreta índices "
"negativos adicionando o comprimento da sequência ao índice, de modo que, por "
"exemplo, ``x[-1]`` seleciona o último item de ``x``. O valor resultante deve "
"ser um inteiro não negativo menor que o número de itens na sequência, e a "
"subscrita seleciona o item cujo índice é esse valor (contando a partir de "
"zero). Como o suporte para índices negativos e fatiamento ocorre no método :"
"meth:`~object.__getitem__` do objeto, subclasses que substituem este método "
"precisarão adicionar explicitamente esse suporte."

#: ../../reference/expressions.rst:1003
msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ""
"Uma :class:`string <str>` é um tipo especial de sequência cujos itens são "
"*caracteres*. Um carácter não é um tipo de dados separado, mas uma string de "
"exatamente um carácter."

#: ../../reference/expressions.rst:1011
msgid "Slicings"
msgstr "Fatiamentos"

#: ../../reference/expressions.rst:1025
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Um fatiamento seleciona um intervalo de itens num objeto de sequência (por "
"exemplo, uma string, tuplo ou lista). Os fatiamentos podem ser usados como "
"expressões ou como alvos em instruções de atribuição ou :keyword:`del`. A "
"sintaxe para um fatiamento:"

#: ../../reference/expressions.rst:1038
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Existe ambiguidade na sintaxe formal aqui: qualquer coisa que pareça uma "
"lista de expressões também parece uma lista de fatias, de modo que qualquer "
"subscrita pode ser interpretada como um fatiamento. Em vez de complicar "
"ainda mais a sintaxe, isto é desambiguado definindo que, neste caso, a "
"interpretação como subscrita tem prioridade sobre a interpretação como "
"fatiamento (este é o caso se a lista de fatias não contiver nenhuma fatia "
"própria)."

#: ../../reference/expressions.rst:1050
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`~object.__getitem__` method as normal subscription) with a "
"key that is constructed from the slice list, as follows.  If the slice list "
"contains at least one comma, the key is a tuple containing the conversion of "
"the slice items; otherwise, the conversion of the lone slice item is the "
"key.  The conversion of a slice item that is an expression is that "
"expression.  The conversion of a proper slice is a slice object (see "
"section :ref:`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :"
"attr:`~slice.step` attributes are the values of the expressions given as "
"lower bound, upper bound and stride, respectively, substituting ``None`` for "
"missing expressions."
msgstr ""
"A semântica para um fatiamento é a seguinte. O primário é indexado (usando o "
"mesmo método :meth:`~object.__getitem__` como na subscrita normal) com uma "
"chave que é construída a partir da lista de fatias, da seguinte forma. Se a "
"lista de fatias contiver pelo menos uma vírgula, a chave é um tuplo contendo "
"a conversão dos itens da fatia; caso contrário, a conversão do único item da "
"fatia é a chave. A conversão de um item de fatia que é uma expressão é essa "
"expressão. A conversão de uma fatia própria é um objeto de fatia (consulte a "
"secção :ref:`types`) cujos atributos :attr:`~slice.start`, :attr:`~slice."
"stop` e :attr:`~slice.step` são os valores das expressões dadas como limite "
"inferior, limite superior e passo, respetivamente, substituindo ``None`` por "
"expressões em falta."

#: ../../reference/expressions.rst:1074
msgid "Calls"
msgstr "Chamadas"

#: ../../reference/expressions.rst:1076
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Uma chamada invoca um objeto chamável (por exemplo, uma :term:`função`) com "
"uma série possivelmente vazia de :term:`argumentos <argument>`:"

#: ../../reference/expressions.rst:1093
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Uma vírgula final opcional pode estar presente após os argumentos "
"posicionais e de palavra-chave, mas não afeta a semântica."

#: ../../reference/expressions.rst:1099
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`~object.__call__` method "
"are callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"O primário deve ser avaliado como um objeto chamável (funções definidas pelo "
"utilizador, funções integradas, métodos de objetos integrados, objetos de "
"classe, métodos de instâncias de classe e todos os objetos que tenham um "
"método :meth:`~object.__call__` são chamáveis). Todas as expressões de "
"argumento são avaliadas antes de a chamada ser tentada. Consulte a secção :"
"ref:`function` para a sintaxe das listas formais de :term:`parâmetros`."

#: ../../reference/expressions.rst:1107
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the argument is placed in the slot, filling it (even if the expression is "
"``None``, it fills the slot).  When all arguments have been processed, the "
"slots that are still unfilled are filled with the corresponding default "
"value from the function definition.  (Default values are calculated, once, "
"when the function is defined; thus, a mutable object such as a list or "
"dictionary used as default value will be shared by all calls that don't "
"specify an argument value for the corresponding slot; this should usually be "
"avoided.)  If there are any unfilled slots for which no default value is "
"specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of "
"filled slots is used as the argument list for the call."
msgstr ""
"Se argumentos de palavra-chave estiverem presentes, são primeiro convertidos "
"em argumentos posicionais, da seguinte forma. Primeiro, é criada uma lista "
"de slots não preenchidos para os parâmetros formais. Se houver N argumentos "
"posicionais, são colocados nos primeiros N slots. Em seguida, para cada "
"argumento de palavra-chave, o identificador é usado para determinar o slot "
"correspondente (se o identificador for o mesmo que o nome do primeiro "
"parâmetro formal, o primeiro slot é usado, e assim por diante). Se o slot já "
"estiver preenchido, é levantada uma exceção :exc:`TypeError`. Caso "
"contrário, o argumento é colocado no slot, preenchendo-o (mesmo que a "
"expressão seja ``None``, preenche o slot). Quando todos os argumentos "
"tiverem sido processados, os slots que ainda estiverem vazios são "
"preenchidos com o valor padrão correspondente da definição da função. (Os "
"valores padrão são calculados uma vez, quando a função é definida; assim, um "
"objeto mutável como uma lista ou dicionário usado como valor padrão será "
"partilhado por todas as chamadas que não especifiquem um valor de argumento "
"para o slot correspondente; isto deve geralmente ser evitado.) Se houver "
"slots não preenchidos para os quais não é especificado nenhum valor padrão, "
"é levantada uma exceção :exc:`TypeError`. Caso contrário, a lista de slots "
"preenchidos é usada como a lista de argumentos para a chamada."

#: ../../reference/expressions.rst:1127
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"Uma implementação pode fornecer funções integradas cujos parâmetros "
"posicionais não têm nomes, mesmo que sejam 'nomeados' para fins de "
"documentação, e que, portanto, não podem ser fornecidos por palavra-chave. "
"No CPython, este é o caso de funções implementadas em C que usam :c:func:"
"`PyArg_ParseTuple` para analisar os seus argumentos."

#: ../../reference/expressions.rst:1133
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"Se houver mais argumentos posicionais do que slots de parâmetros formais, é "
"levantada uma exceção :exc:`TypeError`, a menos que esteja presente um "
"parâmetro formal usando a sintaxe ``*identifier``; neste caso, esse "
"parâmetro formal recebe um tuplo contendo os argumentos posicionais em "
"excesso (ou um tuplo vazio se não houver argumentos posicionais em excesso)."

#: ../../reference/expressions.rst:1139
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Se algum argumento de palavra-chave não corresponder a um nome de parâmetro "
"formal, é levantada uma exceção :exc:`TypeError`, a menos que esteja "
"presente um parâmetro formal usando a sintaxe ``**identifier``; neste caso, "
"esse parâmetro formal recebe um dicionário contendo os argumentos de palavra-"
"chave em excesso (usando as palavras-chave como chaves e os valores dos "
"argumentos como valores correspondentes), ou um dicionário vazio (novo) se "
"não houver argumentos de palavra-chave em excesso."

#: ../../reference/expressions.rst:1150
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Se a sintaxe ``*expression`` aparecer na chamada da função, ``expression`` "
"deve ser avaliada como um :term:`iterável`. Os elementos destes iteráveis "
"são tratados como se fossem argumentos posicionais adicionais. Para a "
"chamada ``f(x1, x2, *y, x3, x4)``, se *y* for avaliado como uma sequência "
"*y1*, ..., *yM*, isto é equivalente a uma chamada com M+4 argumentos "
"posicionais *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."

#: ../../reference/expressions.rst:1157
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"Uma consequência disto é que, embora a sintaxe ``*expression`` possa "
"aparecer *depois* de argumentos de palavra-chave explícitos, é processada "
"*antes* dos argumentos de palavra-chave (e quaisquer argumentos "
"``**expression`` — veja abaixo). Por exemplo::"

#: ../../reference/expressions.rst:1161
msgid ""
">>> def f(a, b):\n"
"...     print(a, b)\n"
"...\n"
">>> f(b=1, *(2,))\n"
"2 1\n"
">>> f(a=1, *(2,))\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: f() got multiple values for keyword argument 'a'\n"
">>> f(1, *(2,))\n"
"1 2"
msgstr ""
">>> def f(a, b):\n"
"...     print(a, b)\n"
"...\n"
">>> f(b=1, *(2,))\n"
"2 1\n"
">>> f(a=1, *(2,))\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: f() recebeu múltiplos valores para o argumento de palavra-chave "
"'a'\n"
">>> f(1, *(2,))\n"
"1 2"

#: ../../reference/expressions.rst:1173
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not often arise."
msgstr ""
"É incomum que tanto argumentos de palavra-chave como a sintaxe "
"``*expression`` sejam usados na mesma chamada, pelo que, na prática, esta "
"confusão não surge frequentemente."

#: ../../reference/expressions.rst:1179
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""
"Se a sintaxe ``**expression`` aparecer na chamada da função, ``expression`` "
"deve ser avaliada como um :term:`mapeamento`, cujos conteúdos são tratados "
"como argumentos de palavra-chave adicionais. Se um parâmetro correspondente "
"a uma chave já tiver recebido um valor (por um argumento de palavra-chave "
"explícito ou de outro desempacotamento), é levantada uma exceção :exc:"
"`TypeError`."

#: ../../reference/expressions.rst:1185
msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""
"Quando ``**expression`` é usado, cada chave neste mapeamento deve ser uma "
"string. Cada valor do mapeamento é atribuído ao primeiro parâmetro formal "
"elegível para atribuição de palavra-chave cujo nome é igual à chave. Uma "
"chave não precisa de ser um identificador Python (por exemplo, ``\"max-temp "
"°F\"`` é aceitável, embora não corresponda a nenhum parâmetro formal que "
"possa ser declarado). Se não houver correspondência com um parâmetro formal, "
"o par chave-valor é recolhido pelo parâmetro ``**``, se existir um; caso "
"contrário, é levantada uma exceção :exc:`TypeError`."

#: ../../reference/expressions.rst:1195
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Parâmetros formais que usam a sintaxe ``*identifier`` ou ``**identifier`` "
"não podem ser usados como slots de argumentos posicionais ou como nomes de "
"argumentos de palavra-chave."

#: ../../reference/expressions.rst:1198
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"As chamadas de função aceitam qualquer número de desempacotamentos ``*`` e "
"``**``, argumentos posicionais podem seguir desempacotamentos iteráveis "
"(``*``), e argumentos de palavra-chave podem seguir desempacotamentos de "
"dicionário (``**``). Originalmente proposto por :pep:`448`."

#: ../../reference/expressions.rst:1204
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Uma chamada sempre devolve algum valor, possivelmente ``None``, a menos que "
"levante uma exceção. A forma como este valor é calculado depende do tipo do "
"objeto chamável."

#: ../../reference/expressions.rst:1208
msgid "If it is---"
msgstr "Se for ---"

#: ../../reference/expressions.rst:1210
msgid "a user-defined function:"
msgstr "uma função definida pelo utilizador:"

#: ../../reference/expressions.rst:1217
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call.  If execution reaches the end of the code block "
"without executing a :keyword:`return` statement, the return value is "
"``None``."
msgstr ""
"O bloco de código da função é executado, passando-lhe a lista de argumentos. "
"A primeira coisa que o bloco de código faz é ligar os parâmetros formais aos "
"argumentos; isto é descrito na secção :ref:`function`. Quando o bloco de "
"código executa uma instrução :keyword:`return`, isto especifica o valor de "
"retorno da chamada da função. Se a execução atingir o fim do bloco de código "
"sem executar uma instrução :keyword:`return`, o valor de retorno é ``None``."

#: ../../reference/expressions.rst:1224
msgid "a built-in function or method:"
msgstr "uma função ou método integrado:"

#: ../../reference/expressions.rst:1235
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"O resultado depende do interpretador; consulte :ref:`built-in-funcs` para as "
"descrições das funções e métodos integrados."

#: ../../reference/expressions.rst:1238
msgid "a class object:"
msgstr "um objeto de classe:"

#: ../../reference/expressions.rst:1243
msgid "A new instance of that class is returned."
msgstr "É devolvida uma nova instância dessa classe."

#: ../../reference/expressions.rst:1245
msgid "a class instance method:"
msgstr "um método de instância de classe:"

#: ../../reference/expressions.rst:1251
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"A função definida pelo utilizador correspondente é chamada, com uma lista de "
"argumentos que é uma unidade maior que a lista de argumentos da chamada: a "
"instância torna-se o primeiro argumento."

#: ../../reference/expressions.rst:1255
msgid "a class instance:"
msgstr "uma instância de classe:"

#: ../../reference/expressions.rst:1260
msgid ""
"The class must define a :meth:`~object.__call__` method; the effect is then "
"the same as if that method was called."
msgstr ""
"A classe deve definir um método :meth:`~object.__call__`; o efeito é então o "
"mesmo que se esse método fosse chamado."

#: ../../reference/expressions.rst:1268 ../../reference/expressions.rst:2082
msgid "Await expression"
msgstr "Expressão await"

#: ../../reference/expressions.rst:1270
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Suspende a execução de uma :term:`corrotina` num objeto :term:`aguardável`. "
"Só pode ser usada dentro de uma :term:`função de corrotina`."

#: ../../reference/expressions.rst:1282
msgid "The power operator"
msgstr "O operador de potência"

#: ../../reference/expressions.rst:1288
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"O operador de potência liga-se mais fortemente do que os operadores unários "
"à sua esquerda; liga-se menos fortemente do que os operadores unários à sua "
"direita. A sintaxe é:"

#: ../../reference/expressions.rst:1294
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Assim, numa sequência sem parênteses de operadores de potência e unários, os "
"operadores são avaliados da direita para a esquerda (isto não restringe a "
"ordem de avaliação dos operandos): ``-1**2`` resulta em ``-1``."

#: ../../reference/expressions.rst:1298
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"O operador de potência tem a mesma semântica que a função integrada :func:"
"`pow`, quando chamada com dois argumentos: produz o argumento esquerdo "
"elevado à potência do argumento direito. Os argumentos numéricos são "
"primeiro convertidos para um tipo comum, e o resultado é desse tipo."

#: ../../reference/expressions.rst:1303
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"Para operandos inteiros, o resultado tem o mesmo tipo que os operandos, a "
"menos que o segundo argumento seja negativo; nesse caso, todos os argumentos "
"são convertidos para float e é devolvido um resultado float. Por exemplo, "
"``10**2`` devolve ``100``, mas ``10**-2`` devolve ``0.01``."

#: ../../reference/expressions.rst:1308
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Elevar ``0.0`` a uma potência negativa resulta numa exceção :exc:"
"`ZeroDivisionError`. Elevar um número negativo a uma potência fracionária "
"resulta num número :class:`complex`. (Em versões anteriores, levantava uma "
"exceção :exc:`ValueError`.)"

#: ../../reference/expressions.rst:1312
msgid ""
"This operation can be customized using the special :meth:`~object.__pow__` "
"and :meth:`~object.__rpow__` methods."
msgstr ""
"Esta operação pode ser personalizada usando os métodos especiais :meth:"
"`~object.__pow__` e :meth:`~object.__rpow__`."

#: ../../reference/expressions.rst:1318
msgid "Unary arithmetic and bitwise operations"
msgstr "Operações aritméticas e bitwise unárias"

#: ../../reference/expressions.rst:1324
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Todas as operações aritméticas e bitwise unárias têm a mesma prioridade:"

#: ../../reference/expressions.rst:1335
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`~object.__neg__` "
"special method."
msgstr ""
"O operador unário ``-`` (menos) devolve a negação do seu argumento numérico; "
"a operação pode ser substituída com o método especial :meth:`~object."
"__neg__`."

#: ../../reference/expressions.rst:1343
msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`~object.__pos__` special method."
msgstr ""
"O operador unário ``+`` (mais) devolve o seu argumento numérico inalterado; "
"a operação pode ser substituída com o método especial :meth:`~object."
"__pos__`."

#: ../../reference/expressions.rst:1350
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`~object.__invert__` special method."
msgstr ""
"O operador unário ``~`` (inverter) devolve a inversão bitwise do seu "
"argumento inteiro. A inversão bitwise de ``x`` é definida como ``-(x+1)``. "
"Aplica-se apenas a números inteiros ou a objetos personalizados que "
"substituam o método especial :meth:`~object.__invert__`."

#: ../../reference/expressions.rst:1359
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"Nos três casos, se o argumento não tiver o tipo adequado, é levantada uma "
"exceção :exc:`TypeError`."

#: ../../reference/expressions.rst:1366
msgid "Binary arithmetic operations"
msgstr "Operações aritméticas binárias"

#: ../../reference/expressions.rst:1370
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"As operações aritméticas binárias têm os níveis de prioridade convencionais. "
"Note que algumas destas operações também se aplicam a certos tipos não "
"numéricos. Além do operador de potência, existem apenas dois níveis, um para "
"operadores multiplicativos e outro para operadores aditivos:"

#: ../../reference/expressions.rst:1385
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common real type and then multiplied together.  In the "
"latter case, sequence repetition is performed; a negative repetition factor "
"yields an empty sequence."
msgstr ""
"O operador ``*`` (multiplicação) devolve o produto dos seus argumentos. Os "
"argumentos devem ser ambos números, ou um argumento deve ser um inteiro e o "
"outro deve ser uma sequência. No primeiro caso, os números são convertidos "
"para um tipo real comum e depois multiplicados. No segundo caso, é realizada "
"a repetição da sequência; um fator de repetição negativo produz uma "
"sequência vazia."

#: ../../reference/expressions.rst:1391
msgid ""
"This operation can be customized using the special :meth:`~object.__mul__` "
"and :meth:`~object.__rmul__` methods."
msgstr ""
"Esta operação pode ser personalizada usando os métodos especiais :meth:"
"`~object.__mul__` e :meth:`~object.__rmul__`."

#: ../../reference/expressions.rst:1394 ../../reference/expressions.rst:1471
#: ../../reference/expressions.rst:1486
msgid ""
"If only one operand is a complex number, the other operand is converted to a "
"floating-point number."
msgstr ""
"Se apenas um operando for um número complexo, o outro operando é convertido "
"para um número de vírgula flutuante."

#: ../../reference/expressions.rst:1402
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"O operador ``@`` (at) destina-se a ser usado para multiplicação de matrizes. "
"Nenhum tipo integrado do Python implementa este operador."

#: ../../reference/expressions.rst:1405
msgid ""
"This operation can be customized using the special :meth:`~object."
"__matmul__` and :meth:`~object.__rmatmul__` methods."
msgstr ""
"Esta operação pode ser personalizada usando os métodos especiais :meth:"
"`~object.__matmul__` e :meth:`~object.__rmatmul__`."

#: ../../reference/expressions.rst:1416
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Os operadores ``/`` (divisão) e ``//`` (divisão inteira) devolvem o "
"quociente dos seus argumentos. Os argumentos numéricos são primeiro "
"convertidos para um tipo comum. A divisão de inteiros produz um float, "
"enquanto a divisão inteira de inteiros resulta num inteiro; o resultado é o "
"da divisão matemática com a função 'floor' aplicada ao resultado. A divisão "
"por zero levanta a exceção :exc:`ZeroDivisionError`."

#: ../../reference/expressions.rst:1423
msgid ""
"The division operation can be customized using the special :meth:`~object."
"__truediv__` and :meth:`~object.__rtruediv__` methods. The floor division "
"operation can be customized using the special :meth:`~object.__floordiv__` "
"and :meth:`~object.__rfloordiv__` methods."
msgstr ""
"A operação de divisão pode ser personalizada usando os métodos especiais :"
"meth:`~object.__truediv__` e :meth:`~object.__rtruediv__`. A operação de "
"divisão inteira pode ser personalizada usando os métodos especiais :meth:"
"`~object.__floordiv__` e :meth:`~object.__rfloordiv__`."

#: ../../reference/expressions.rst:1432
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating-point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"O operador ``%`` (módulo) devolve o resto da divisão do primeiro argumento "
"pelo segundo. Os argumentos numéricos são primeiro convertidos para um tipo "
"comum. Um argumento direito zero levanta a exceção :exc:`ZeroDivisionError`. "
"Os argumentos podem ser números de vírgula flutuante, por exemplo, "
"``3.14%0.7`` é igual a ``0.34`` (uma vez que ``3.14`` é igual a ``4*0.7 + "
"0.34``). O operador módulo devolve sempre um resultado com o mesmo sinal que "
"o seu segundo operando (ou zero); o valor absoluto do resultado é "
"estritamente menor que o valor absoluto do segundo operando [#]_."

#: ../../reference/expressions.rst:1441
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Os operadores de divisão inteira e módulo estão conectados pela seguinte "
"identidade: ``x == (x//y)*y + (x%y)``. A divisão inteira e o módulo também "
"estão conectados com a função integrada :func:`divmod`: ``divmod(x, y) == "
"(x//y, x%y)``. [#]_."

#: ../../reference/expressions.rst:1446
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"Além de realizar a operação de módulo em números, o operador ``%`` também é "
"sobrecarregado por objetos de string para realizar formatação de strings no "
"estilo antigo (também conhecida como interpolação). A sintaxe para "
"formatação de strings é descrita na Referência da Biblioteca Python, secção :"
"ref:`old-string-formatting`."

#: ../../reference/expressions.rst:1451
msgid ""
"The *modulo* operation can be customized using the special :meth:`~object."
"__mod__` and :meth:`~object.__rmod__` methods."
msgstr ""
"A operação *módulo* pode ser personalizada usando os métodos especiais :meth:"
"`~object.__mod__` e :meth:`~object.__rmod__`."

#: ../../reference/expressions.rst:1454
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating-point number using the :func:`abs` function if appropriate."
msgstr ""
"O operador de divisão inteira, o operador módulo e a função :func:`divmod` "
"não estão definidos para números complexos. Em vez disso, converta para um "
"número de vírgula flutuante usando a função :func:`abs`, se apropriado."

#: ../../reference/expressions.rst:1463
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common real type "
"and then added together. In the latter case, the sequences are concatenated."
msgstr ""
"O operador ``+`` (adição) devolve a soma dos seus argumentos. Os argumentos "
"devem ser ambos números ou ambas sequências do mesmo tipo. No primeiro caso, "
"os números são convertidos para um tipo real comum e depois somados. No "
"segundo caso, as sequências são concatenadas."

#: ../../reference/expressions.rst:1468
msgid ""
"This operation can be customized using the special :meth:`~object.__add__` "
"and :meth:`~object.__radd__` methods."
msgstr ""
"Esta operação pode ser personalizada usando os métodos especiais :meth:"
"`~object.__add__` e :meth:`~object.__radd__`."

#: ../../reference/expressions.rst:1480
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common real type."
msgstr ""
"O operador ``-`` (subtração) devolve a diferença dos seus argumentos. Os "
"argumentos numéricos são primeiro convertidos para um tipo real comum."

#: ../../reference/expressions.rst:1483
msgid ""
"This operation can be customized using the special :meth:`~object.__sub__` "
"and :meth:`~object.__rsub__` methods."
msgstr ""
"Esta operação pode ser personalizada usando os métodos especiais :meth:"
"`~object.__sub__` e :meth:`~object.__rsub__`."

#: ../../reference/expressions.rst:1494
msgid "Shifting operations"
msgstr "Operações de deslocamento"

#: ../../reference/expressions.rst:1501
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""
"As operações de deslocamento têm prioridade inferior às operações "
"aritméticas:"

#: ../../reference/expressions.rst:1506
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Estes operadores aceitam inteiros como argumentos. Deslocam o primeiro "
"argumento para a esquerda ou direita pelo número de bits dado pelo segundo "
"argumento."

#: ../../reference/expressions.rst:1509
msgid ""
"The left shift operation can be customized using the special :meth:`~object."
"__lshift__` and :meth:`~object.__rlshift__` methods. The right shift "
"operation can be customized using the special :meth:`~object.__rshift__` "
"and :meth:`~object.__rrshift__` methods."
msgstr ""
"A operação de deslocamento à esquerda pode ser personalizada usando os "
"métodos especiais :meth:`~object.__lshift__` e :meth:`~object.__rlshift__`. "
"A operação de deslocamento à direita pode ser personalizada usando os "
"métodos especiais :meth:`~object.__rshift__` e :meth:`~object.__rrshift__`."

#: ../../reference/expressions.rst:1516
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"Um deslocamento à direita por *n* bits é definido como divisão inteira por "
"``pow(2,n)``. Um deslocamento à esquerda por *n* bits é definido como "
"multiplicação por ``pow(2,n)``."

#: ../../reference/expressions.rst:1523
msgid "Binary bitwise operations"
msgstr "Operações bitwise binárias"

#: ../../reference/expressions.rst:1527
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""
"Cada uma das três operações bitwise tem um nível de prioridade diferente:"

#: ../../reference/expressions.rst:1538
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`~object."
"__and__` or :meth:`~object.__rand__` special methods."
msgstr ""
"O operador ``&`` devolve o AND bitwise dos seus argumentos, que devem ser "
"inteiros ou um deles deve ser um objeto personalizado que substitua os "
"métodos especiais :meth:`~object.__and__` ou :meth:`~object.__rand__`."

#: ../../reference/expressions.rst:1547
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`~object.__xor__` or :meth:`~object.__rxor__` special methods."
msgstr ""
"O operador ``^`` devolve o XOR bitwise (OR exclusivo) dos seus argumentos, "
"que devem ser inteiros ou um deles deve ser um objeto personalizado que "
"substitua os métodos especiais :meth:`~object.__xor__` ou :meth:`~object."
"__rxor__`."

#: ../../reference/expressions.rst:1556
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`~object.__or__` or :meth:`~object.__ror__` special methods."
msgstr ""
"O operador ``|`` devolve o OR bitwise (inclusivo) dos seus argumentos, que "
"devem ser inteiros ou um deles deve ser um objeto personalizado que "
"substitua os métodos especiais :meth:`~object.__or__` ou :meth:`~object."
"__ror__`."

#: ../../reference/expressions.rst:1564
msgid "Comparisons"
msgstr "Comparações"

#: ../../reference/expressions.rst:1576
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"Ao contrário de C, todas as operações de comparação em Python têm a mesma "
"prioridade, que é inferior à de qualquer operação aritmética, de "
"deslocamento ou bitwise. Também ao contrário de C, expressões como ``a < b < "
"c`` têm a interpretação que é convencional em matemática:"

#: ../../reference/expressions.rst:1586
msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"As comparações produzem valores booleanos: ``True`` ou ``False``. Métodos "
"de :dfn:`comparação rica` personalizados podem devolver valores não "
"booleanos. Neste caso, o Python chamará :func:`bool` nesse valor em "
"contextos booleanos."

#: ../../reference/expressions.rst:1592
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"As comparações podem ser encadeadas arbitrariamente, por exemplo, ``x < y <= "
"z`` é equivalente a ``x < y and y <= z``, exceto que ``y`` é avaliado apenas "
"uma vez (mas em ambos os casos ``z`` não é avaliado se ``x < y`` for falso)."

#: ../../reference/expressions.rst:1596
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Formalmente, se *a*, *b*, *c*, ..., *y*, *z* são expressões e *op1*, "
"*op2*, ..., *opN* são operadores de comparação, então ``a op1 b op2 c ... y "
"opN z`` é equivalente a ``a op1 b and b op2 c and ... y opN z``, exceto que "
"cada expressão é avaliada no máximo uma vez."

#: ../../reference/expressions.rst:1601
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Note que ``a op1 b op2 c`` não implica qualquer tipo de comparação entre *a* "
"e *c*, de modo que, por exemplo, ``x < y > z`` é perfeitamente legal (embora "
"talvez não seja bonito)."

#: ../../reference/expressions.rst:1608
msgid "Value comparisons"
msgstr "Comparações de valor"

#: ../../reference/expressions.rst:1610
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Os operadores ``<``, ``>``, ``==``, ``>=``, ``<=`` e ``!=`` comparam os "
"valores de dois objetos. Os objetos não precisam de ter o mesmo tipo."

#: ../../reference/expressions.rst:1613
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"O capítulo :ref:`objects` afirma que os objetos têm um valor (além do tipo e "
"identidade). O valor de um objeto é um conceito bastante abstrato em Python: "
"por exemplo, não existe um método de acesso canónico para o valor de um "
"objeto. Além disso, não há nenhum requisito de que o valor de um objeto deva "
"ser construído de uma forma particular, por exemplo, composto por todos os "
"seus atributos de dados. Os operadores de comparação implementam uma noção "
"particular do que é o valor de um objeto. Pode-se pensar neles como "
"definindo o valor de um objeto indiretamente, por meio da sua implementação "
"de comparação."

#: ../../reference/expressions.rst:1622
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`~object.__lt__`, described in :ref:`customization`."
msgstr ""
"Como todos os tipos são (direta ou indiretamente) subtipos de :class:"
"`object`, eles herdam o comportamento de comparação padrão de :class:"
"`object`. Os tipos podem personalizar o seu comportamento de comparação "
"implementando métodos de :dfn:`comparação rica`, como :meth:`~object."
"__lt__`, descritos em :ref:`customization`."

#: ../../reference/expressions.rst:1628
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"O comportamento padrão para comparação de igualdade (``==`` e ``!=``) é "
"baseado na identidade dos objetos. Assim, a comparação de igualdade de "
"instâncias com a mesma identidade resulta em igualdade, e a comparação de "
"igualdade de instâncias com identidades diferentes resulta em desigualdade. "
"Uma motivação para este comportamento padrão é o desejo de que todos os "
"objetos devam ser reflexivos (ou seja, ``x is y`` implica ``x == y``)."

#: ../../reference/expressions.rst:1635
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"Uma comparação de ordem padrão (``<``, ``>``, ``<=`` e ``>=``) não é "
"fornecida; uma tentativa levanta :exc:`TypeError`. Uma motivação para este "
"comportamento padrão é a falta de um invariante semelhante ao da igualdade."

#: ../../reference/expressions.rst:1639
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"O comportamento da comparação de igualdade padrão, em que instâncias com "
"identidades diferentes são sempre desiguais, pode contrastar com o que os "
"tipos que têm uma definição sensata de valor de objeto e igualdade baseada "
"em valor precisarão. Tais tipos precisarão de personalizar o seu "
"comportamento de comparação, e de facto, vários tipos integrados já o "
"fizeram."

#: ../../reference/expressions.rst:1645
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"A lista seguinte descreve o comportamento de comparação dos tipos integrados "
"mais importantes."

#: ../../reference/expressions.rst:1648
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Os números de tipos numéricos integrados (:ref:`typesnumeric`) e dos tipos "
"da biblioteca padrão :class:`fractions.Fraction` e :class:`decimal.Decimal` "
"podem ser comparados dentro e entre os seus tipos, com a restrição de que os "
"números complexos não suportam comparação de ordem. Dentro dos limites dos "
"tipos envolvidos, comparam-se matematicamente (algoritmicamente) corretos "
"sem perda de precisão."

#: ../../reference/expressions.rst:1655
msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Os valores não-número ``float('NaN')`` e ``decimal.Decimal('NaN')`` são "
"especiais. Qualquer comparação ordenada de um número com um valor não-número "
"é falsa. Uma implicação contra-intuitiva é que os valores não-número não são "
"iguais a si mesmos. Por exemplo, se ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` e ``x == x`` são todos falsos, enquanto ``x != x`` é verdadeiro. Este "
"comportamento está em conformidade com o IEEE 754."

#: ../../reference/expressions.rst:1662
msgid ""
"``None`` and :data:`NotImplemented` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` e :data:`NotImplemented` são singletons. A :PEP:`8` aconselha que "
"as comparações para singletons devem ser sempre feitas com ``is`` ou ``is "
"not``, nunca com os operadores de igualdade."

#: ../../reference/expressions.rst:1666
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Sequências binárias (instâncias de :class:`bytes` ou :class:`bytearray`) "
"podem ser comparadas dentro e entre os seus tipos. Comparam-se "
"lexicograficamente usando os valores numéricos dos seus elementos."

#: ../../reference/expressions.rst:1670
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Strings (instâncias de :class:`str`) comparam-se lexicograficamente usando "
"os pontos de código Unicode numéricos (o resultado da função integrada :func:"
"`ord`) dos seus caracteres. [#]_"

#: ../../reference/expressions.rst:1674
msgid "Strings and binary sequences cannot be directly compared."
msgstr "Strings e sequências binárias não podem ser comparadas diretamente."

#: ../../reference/expressions.rst:1676
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Sequências (instâncias de :class:`tuple`, :class:`list` ou :class:`range`) "
"só podem ser comparadas dentro de cada um dos seus tipos, com a restrição de "
"que os ranges não suportam comparação de ordem. A comparação de igualdade "
"entre estes tipos resulta em desigualdade, e a comparação de ordem entre "
"estes tipos levanta :exc:`TypeError`."

#: ../../reference/expressions.rst:1682
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"As sequências comparam-se lexicograficamente usando a comparação de "
"elementos correspondentes. Os contentores integrados assumem tipicamente que "
"objetos idênticos são iguais a si mesmos. Isto permite-lhes ignorar testes "
"de igualdade para objetos idênticos, melhorando o desempenho e mantendo os "
"seus invariantes internos."

#: ../../reference/expressions.rst:1687
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"A comparação lexicográfica entre coleções integradas funciona da seguinte "
"forma:"

#: ../../reference/expressions.rst:1689
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"Para que duas coleções sejam consideradas iguais, devem ser do mesmo tipo, "
"ter o mesmo comprimento, e cada par de elementos correspondentes deve ser "
"igual (por exemplo, ``[1,2] == (1,2)`` é falso porque o tipo não é o mesmo)."

#: ../../reference/expressions.rst:1694
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"As coleções que suportam comparação de ordem são ordenadas da mesma forma "
"que os seus primeiros elementos desiguais (por exemplo, ``[1,2,x] <= [1,2,"
"y]`` tem o mesmo valor que ``x <= y``). Se um elemento correspondente não "
"existir, a coleção mais curta é ordenada primeiro (por exemplo, ``[1,2] < "
"[1,2,3]`` é verdadeiro)."

#: ../../reference/expressions.rst:1700
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""
"Mapeamentos (instâncias de :class:`dict`) são iguais se e somente se tiverem "
"pares ``(key, value)`` iguais. A comparação de igualdade das chaves e "
"valores reforça a reflexividade."

#: ../../reference/expressions.rst:1704
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Comparações de ordem (``<``, ``>``, ``<=`` e ``>=``) levantam :exc:"
"`TypeError`."

#: ../../reference/expressions.rst:1706
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Conjuntos (instâncias de :class:`set` ou :class:`frozenset`) podem ser "
"comparados dentro e entre os seus tipos."

#: ../../reference/expressions.rst:1709
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"Eles definem operadores de comparação de ordem para significar testes de "
"subconjunto e superconjunto. Essas relações não definem ordenações totais "
"(por exemplo, os dois conjuntos ``{1,2}`` e ``{2,3}`` não são iguais, nem "
"subconjuntos um do outro, nem superconjuntos um do outro). Assim, os "
"conjuntos não são argumentos apropriados para funções que dependem de "
"ordenação total (por exemplo, :func:`min`, :func:`max` e :func:`sorted` "
"produzem resultados indefinidos quando dada uma lista de conjuntos como "
"entrada)."

#: ../../reference/expressions.rst:1717
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "A comparação de conjuntos reforça a reflexividade dos seus elementos."

#: ../../reference/expressions.rst:1719
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"A maioria dos outros tipos integrados não tem métodos de comparação "
"implementados, pelo que herdam o comportamento de comparação padrão."

#: ../../reference/expressions.rst:1722
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"As classes definidas pelo utilizador que personalizam o seu comportamento de "
"comparação devem seguir algumas regras de consistência, se possível:"

#: ../../reference/expressions.rst:1725
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"A comparação de igualdade deve ser reflexiva. Em outras palavras, objetos "
"idênticos devem ser considerados iguais:"

#: ../../reference/expressions.rst:1728
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` implica ``x == y``"

#: ../../reference/expressions.rst:1730
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"A comparação deve ser simétrica. Em outras palavras, as seguintes expressões "
"devem ter o mesmo resultado:"

#: ../../reference/expressions.rst:1733
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` e ``y == x``"

#: ../../reference/expressions.rst:1735
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` e ``y != x``"

#: ../../reference/expressions.rst:1737
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` e ``y > x``"

#: ../../reference/expressions.rst:1739
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` e ``y >= x``"

#: ../../reference/expressions.rst:1741
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"A comparação deve ser transitiva. Os seguintes exemplos (não exaustivos) "
"ilustram isso:"

#: ../../reference/expressions.rst:1744
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` implica ``x > z``"

#: ../../reference/expressions.rst:1746
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y and y <= z`` implica ``x < z``"

#: ../../reference/expressions.rst:1748
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"A comparação inversa deve resultar na negação booleana. Em outras palavras, "
"as seguintes expressões devem ter o mesmo resultado:"

#: ../../reference/expressions.rst:1751
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` e ``not x != y``"

#: ../../reference/expressions.rst:1753
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` e ``not x >= y`` (para ordenação total)"

#: ../../reference/expressions.rst:1755
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` e ``not x <= y`` (para ordenação total)"

#: ../../reference/expressions.rst:1757
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"As duas últimas expressões aplicam-se a coleções totalmente ordenadas (por "
"exemplo, a sequências, mas não a conjuntos ou mapeamentos). Consulte também "
"o decorador :func:`~functools.total_ordering`."

#: ../../reference/expressions.rst:1761
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"O resultado de :func:`hash` deve ser consistente com a igualdade. Objetos "
"que são iguais devem ter o mesmo valor de hash ou ser marcados como não "
"hashable."

#: ../../reference/expressions.rst:1765
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"O Python não impõe estas regras de consistência. De facto, os valores não-"
"número são um exemplo de não seguimento destas regras."

#: ../../reference/expressions.rst:1774
msgid "Membership test operations"
msgstr "Operações de teste de pertence"

#: ../../reference/expressions.rst:1776
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Os operadores :keyword:`in` e :keyword:`not in` testam a pertence. ``x in "
"s`` avalia para ``True`` se *x* for um membro de *s*, e ``False`` caso "
"contrário. ``x not in s`` devolve a negação de ``x in s``. Todos os tipos de "
"sequências e conjuntos integrados suportam isto, bem como dicionários, para "
"os quais :keyword:`!in` testa se o dicionário tem uma determinada chave. "
"Para tipos de contentores como lista, tuplo, conjunto, frozenset, dicionário "
"ou collections.deque, a expressão ``x in y`` é equivalente a ``any(x is e or "
"x == e for e in y)``."

#: ../../reference/expressions.rst:1784
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"Para os tipos string e bytes, ``x in y`` é ``True`` se e somente se *x* for "
"uma substring de *y*. Um teste equivalente é ``y.find(x) != -1``. Strings "
"vazias são sempre consideradas como uma substring de qualquer outra string, "
"pelo que ``\"\" in \"abc\"`` devolverá ``True``."

#: ../../reference/expressions.rst:1789
msgid ""
"For user-defined classes which define the :meth:`~object.__contains__` "
"method, ``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true "
"value, and ``False`` otherwise."
msgstr ""
"Para classes definidas pelo utilizador que definem o método :meth:`~object."
"__contains__`, ``x in y`` devolve ``True`` se ``y.__contains__(x)`` devolver "
"um valor verdadeiro, e ``False`` caso contrário."

#: ../../reference/expressions.rst:1793
msgid ""
"For user-defined classes which do not define :meth:`~object.__contains__` "
"but do define :meth:`~object.__iter__`, ``x in y`` is ``True`` if some value "
"``z``, for which the expression ``x is z or x == z`` is true, is produced "
"while iterating over ``y``. If an exception is raised during the iteration, "
"it is as if :keyword:`in` raised that exception."
msgstr ""
"Para classes definidas pelo utilizador que não definem :meth:`~object."
"__contains__`, mas definem :meth:`~object.__iter__`, ``x in y`` é ``True`` "
"se algum valor ``z``, para o qual a expressão ``x is z or x == z`` é "
"verdadeira, for produzido enquanto se itera sobre ``y``. Se uma exceção for "
"levantada durante a iteração, é como se :keyword:`in` tivesse levantado essa "
"exceção."

#: ../../reference/expressions.rst:1799
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`~object.__getitem__`, ``x in y`` is ``True`` if and only if there is a non-"
"negative integer index *i* such that ``x is y[i] or x == y[i]``, and no "
"lower integer index raises the :exc:`IndexError` exception.  (If any other "
"exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Por último, é testado o protocolo de iteração antigo: se uma classe definir :"
"meth:`~object.__getitem__`, ``x in y`` é ``True`` se e somente se existir um "
"índice inteiro não negativo *i* tal que ``x is y[i] or x == y[i]``, e nenhum "
"índice inteiro inferior levante a exceção :exc:`IndexError`. (Se qualquer "
"outra exceção for levantada, é como se :keyword:`in` tivesse levantado essa "
"exceção)."

#: ../../reference/expressions.rst:1811
msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"O operador :keyword:`not in` é definido como tendo o valor lógico inverso "
"de :keyword:`in`."

#: ../../reference/expressions.rst:1824
msgid "Identity comparisons"
msgstr "Comparações de identidade"

#: ../../reference/expressions.rst:1826
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Os operadores :keyword:`is` e :keyword:`is not` testam a identidade de um "
"objeto: ``x is y`` é verdadeiro se e somente se *x* e *y* forem o mesmo "
"objeto. A identidade de um objeto é determinada usando a função :meth:`id`. "
"``x is not y`` produz o valor lógico inverso. [#]_"

#: ../../reference/expressions.rst:1838
msgid "Boolean operations"
msgstr "Operações booleanas"

#: ../../reference/expressions.rst:1849
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`~object."
"__bool__` method."
msgstr ""
"No contexto de operações booleanas, e também quando expressões são usadas "
"por instruções de controlo de fluxo, os seguintes valores são interpretados "
"como falsos: ``False``, ``None``, zero numérico de todos os tipos, e strings "
"e contentores vazios (incluindo strings, tuplos, listas, dicionários, "
"conjuntos e frozensets). Todos os outros valores são interpretados como "
"verdadeiros. Objetos definidos pelo utilizador podem personalizar o seu "
"valor lógico fornecendo um método :meth:`~object.__bool__`."

#: ../../reference/expressions.rst:1858
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"O operador :keyword:`not` devolve ``True`` se o seu argumento for falso, "
"``False`` caso contrário."

#: ../../reference/expressions.rst:1863
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"A expressão ``x and y`` avalia primeiro *x*; se *x* for falso, o seu valor é "
"devolvido; caso contrário, *y* é avaliado e o valor resultante é devolvido."

#: ../../reference/expressions.rst:1868
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"A expressão ``x or y`` avalia primeiro *x*; se *x* for verdadeiro, o seu "
"valor é devolvido; caso contrário, *y* é avaliado e o valor resultante é "
"devolvido."

#: ../../reference/expressions.rst:1871
msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Note que nem :keyword:`and` nem :keyword:`or` restringem o valor e o tipo "
"que devolvem a ``False`` e ``True``, mas sim devolvem o último argumento "
"avaliado. Isto é por vezes útil, por exemplo, se ``s`` for uma string que "
"deve ser substituída por um valor padrão se estiver vazia, a expressão ``s "
"or 'foo'`` produz o valor desejado. Porque :keyword:`not` tem de criar um "
"novo valor, devolve um valor booleano independentemente do tipo do seu "
"argumento (por exemplo, ``not 'foo'`` produz ``False`` em vez de ``''``)."

#: ../../reference/expressions.rst:1890
msgid "Assignment expressions"
msgstr "Expressões de atribuição"

#: ../../reference/expressions.rst:1895
msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"Uma expressão de atribuição (por vezes também chamada \"expressão nomeada\" "
"ou \"walrus\") atribui uma :token:`~python-grammar:expression` a um :token:"
"`~python-grammar:identifier`, enquanto também devolve o valor da :token:"
"`~python-grammar:expression`."

#: ../../reference/expressions.rst:1900
msgid "One common use case is when handling matched regular expressions:"
msgstr ""
"Um caso de uso comum é ao lidar com expressões regulares correspondentes:"

#: ../../reference/expressions.rst:1902
msgid ""
"if matching := pattern.search(data):\n"
"    do_something(matching)"
msgstr ""
"if correspondencia := pattern.search(dados):\n"
"    fazer_algo(correspondencia)"

#: ../../reference/expressions.rst:1907
msgid "Or, when processing a file stream in chunks:"
msgstr "Ou, ao processar um fluxo de ficheiro em blocos:"

#: ../../reference/expressions.rst:1909
msgid ""
"while chunk := file.read(9000):\n"
"    process(chunk)"
msgstr ""
"while bloco := ficheiro.read(9000):\n"
"    processar(bloco)"

#: ../../reference/expressions.rst:1914
msgid ""
"Assignment expressions must be surrounded by parentheses when used as "
"expression statements and when used as sub-expressions in slicing, "
"conditional, lambda, keyword-argument, and comprehension-if expressions and "
"in ``assert``, ``with``, and ``assignment`` statements. In all other places "
"where they can be used, parentheses are not required, including in ``if`` "
"and ``while`` statements."
msgstr ""
"As expressões de atribuição devem ser envolvidas por parênteses quando "
"usadas como instruções de expressão e quando usadas como sub-expressões em "
"fatiamento, expressões condicionais, lambda, argumentos de palavra-chave, e "
"expressões if de compreensão, e em instruções ``assert``, ``with``, e "
"``assignment``. Em todos os outros locais onde podem ser usadas, os "
"parênteses não são necessários, incluindo em instruções ``if`` e ``while``."

#: ../../reference/expressions.rst:1922
msgid "See :pep:`572` for more details about assignment expressions."
msgstr "Consulte :pep:`572` para mais detalhes sobre expressões de atribuição."

#: ../../reference/expressions.rst:1929
msgid "Conditional expressions"
msgstr "Expressões condicionais"

#: ../../reference/expressions.rst:1941
msgid ""
"A conditional expression (sometimes called a \"ternary operator\") is an "
"alternative to the if-else statement. As it is an expression, it returns a "
"value and can appear as a sub-expression."
msgstr ""
"Uma expressão condicional (por vezes chamada \"operador ternário\") é uma "
"alternativa à instrução if-else. Como é uma expressão, devolve um valor e "
"pode aparecer como uma sub-expressão."

#: ../../reference/expressions.rst:1945
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"A expressão ``x if C else y`` avalia primeiro a condição, *C* em vez de *x*. "
"Se *C* for verdadeiro, *x* é avaliado e o seu valor é devolvido; caso "
"contrário, *y* é avaliado e o seu valor é devolvido."

#: ../../reference/expressions.rst:1949
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "Consulte :pep:`308` para mais detalhes sobre expressões condicionais."

#: ../../reference/expressions.rst:1956
msgid "Lambdas"
msgstr "Lambdas"

#: ../../reference/expressions.rst:1967
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"As expressões lambda (por vezes chamadas formas lambda) são usadas para "
"criar funções anónimas. A expressão ``lambda parameters: expression`` produz "
"um objeto função. O objeto sem nome comporta-se como um objeto função "
"definido com:"

#: ../../reference/expressions.rst:1971
msgid ""
"def <lambda>(parameters):\n"
"    return expression"
msgstr ""
"def <lambda>(parâmetros):\n"
"    return expressão"

#: ../../reference/expressions.rst:1976
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"Consulte a secção :ref:`function` para a sintaxe das listas de parâmetros. "
"Note que funções criadas com expressões lambda não podem conter instruções "
"ou anotações."

#: ../../reference/expressions.rst:1984
msgid "Expression lists"
msgstr "Listas de expressões"

#: ../../reference/expressions.rst:2000
msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"Exceto quando faz parte de uma exibição de lista ou conjunto, uma lista de "
"expressões contendo pelo menos uma vírgula produz um tuplo. O comprimento do "
"tuplo é o número de expressões na lista. As expressões são avaliadas da "
"esquerda para a direita."

#: ../../reference/expressions.rst:2009
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"Um asterisco ``*`` denota :dfn:`desempacotamento iterável`. O seu operando "
"deve ser um :term:`iterável`. O iterável é expandido numa sequência de "
"itens, que são incluídos no novo tuplo, lista ou conjunto, no local do "
"desempacotamento."

#: ../../reference/expressions.rst:2014
msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"Desempacotamento iterável em listas de expressões, originalmente proposto "
"por :pep:`448`."

#: ../../reference/expressions.rst:2017
msgid "Any item in an expression list may be starred. See :pep:`646`."
msgstr ""
"Qualquer item numa lista de expressões pode ser precedido por asterisco. "
"Consulte :pep:`646`."

#: ../../reference/expressions.rst:2022
msgid ""
"A trailing comma is required only to create a one-item tuple, such as ``1,"
"``; it is optional in all other cases. A single expression without a "
"trailing comma doesn't create a tuple, but rather yields the value of that "
"expression. (To create an empty tuple, use an empty pair of parentheses: "
"``()``.)"
msgstr ""
"Uma vírgula final é necessária apenas para criar um tuplo de um item, como "
"``1,``; é opcional em todos os outros casos. Uma expressão única sem uma "
"vírgula final não cria um tuplo, mas sim devolve o valor dessa expressão. "
"(Para criar um tuplo vazio, use um par de parênteses vazio: ``()``.)"

#: ../../reference/expressions.rst:2033
msgid "Evaluation order"
msgstr "Ordem de avaliação"

#: ../../reference/expressions.rst:2037
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"O Python avalia expressões da esquerda para a direita. Note que, ao avaliar "
"uma atribuição, o lado direito é avaliado antes do lado esquerdo."

#: ../../reference/expressions.rst:2040
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"Nas linhas seguintes, as expressões serão avaliadas na ordem aritmética dos "
"seus sufixos::"

#: ../../reference/expressions.rst:2043
msgid ""
"expr1, expr2, expr3, expr4\n"
"(expr1, expr2, expr3, expr4)\n"
"{expr1: expr2, expr3: expr4}\n"
"expr1 + expr2 * (expr3 - expr4)\n"
"expr1(expr2, expr3, *expr4, **expr5)\n"
"expr3, expr4 = expr1, expr2"
msgstr ""
"expr1, expr2, expr3, expr4\n"
"(expr1, expr2, expr3, expr4)\n"
"{expr1: expr2, expr3: expr4}\n"
"expr1 + expr2 * (expr3 - expr4)\n"
"expr1(expr2, expr3, *expr4, **expr5)\n"
"expr3, expr4 = expr1, expr2"

#: ../../reference/expressions.rst:2054
msgid "Operator precedence"
msgstr "Precedência de operadores"

#: ../../reference/expressions.rst:2059
msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation and conditional expressions, which "
"group from right to left)."
msgstr ""
"A tabela seguinte resume a precedência de operadores em Python, desde a mais "
"alta precedência (mais vinculativa) até à mais baixa precedência (menos "
"vinculativa). Operadores na mesma caixa têm a mesma precedência. A menos que "
"a sintaxe seja explicitamente dada, os operadores são binários. Operadores "
"na mesma caixa agrupam-se da esquerda para a direita (exceto para "
"exponenciação e expressões condicionais, que agrupam da direita para a "
"esquerda)."

#: ../../reference/expressions.rst:2065
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Note que comparações, testes de pertence e testes de identidade têm todos a "
"mesma precedência e têm uma característica de encadeamento da esquerda para "
"a direita, como descrito na secção :ref:`comparisons`."

#: ../../reference/expressions.rst:2071
msgid "Operator"
msgstr "Operador"

#: ../../reference/expressions.rst:2071
msgid "Description"
msgstr "Descrição"

#: ../../reference/expressions.rst:2073
msgid "``(expressions...)``,"
msgstr "``(expressions...)``,"

#: ../../reference/expressions.rst:2075
msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"

#: ../../reference/expressions.rst:2073
msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Ligação ou expressão entre parênteses, exibição de lista, exibição de "
"dicionário, exibição de conjunto"

#: ../../reference/expressions.rst:2079
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../../reference/expressions.rst:2079
msgid "Subscription, slicing, call, attribute reference"
msgstr "Subscrito, fatiamento, chamada, referência a atributo"

#: ../../reference/expressions.rst:2082
msgid ":keyword:`await x <await>`"
msgstr ":keyword:`await x <await>`"

#: ../../reference/expressions.rst:2084
msgid "``**``"
msgstr "``**``"

#: ../../reference/expressions.rst:2084
msgid "Exponentiation [#]_"
msgstr "Exponenciação [#]_"

#: ../../reference/expressions.rst:2086
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../../reference/expressions.rst:2086
msgid "Positive, negative, bitwise NOT"
msgstr "Positivo, negativo, NOT bit a bit"

#: ../../reference/expressions.rst:2088
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../../reference/expressions.rst:2088
msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr ""
"Multiplicação, multiplicação de matrizes, divisão, divisão inteira, resto "
"[#]_"

#: ../../reference/expressions.rst:2092
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../../reference/expressions.rst:2092
msgid "Addition and subtraction"
msgstr "Adição e subtração"

#: ../../reference/expressions.rst:2094
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../../reference/expressions.rst:2094
msgid "Shifts"
msgstr "Deslocamentos"

#: ../../reference/expressions.rst:2096
msgid "``&``"
msgstr "``&``"

#: ../../reference/expressions.rst:2096
msgid "Bitwise AND"
msgstr "AND bit a bit"

#: ../../reference/expressions.rst:2098
msgid "``^``"
msgstr "``^``"

#: ../../reference/expressions.rst:2098
msgid "Bitwise XOR"
msgstr "XOR bit a bit"

#: ../../reference/expressions.rst:2100
msgid "``|``"
msgstr "``|``"

#: ../../reference/expressions.rst:2100
msgid "Bitwise OR"
msgstr "OR bit a bit"

#: ../../reference/expressions.rst:2102
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../../reference/expressions.rst:2102
msgid "Comparisons, including membership tests and identity tests"
msgstr "Comparações, incluindo testes de pertence e testes de identidade"

#: ../../reference/expressions.rst:2106
msgid ":keyword:`not x <not>`"
msgstr ":keyword:`not x <not>`"

#: ../../reference/expressions.rst:2106
msgid "Boolean NOT"
msgstr "NOT booleano"

#: ../../reference/expressions.rst:2108
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../../reference/expressions.rst:2108
msgid "Boolean AND"
msgstr "AND booleano"

#: ../../reference/expressions.rst:2110
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../../reference/expressions.rst:2110
msgid "Boolean OR"
msgstr "OR booleano"

#: ../../reference/expressions.rst:2112
msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

#: ../../reference/expressions.rst:2112
msgid "Conditional expression"
msgstr "Expressão condicional"

#: ../../reference/expressions.rst:2114
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../../reference/expressions.rst:2114
msgid "Lambda expression"
msgstr "Expressão lambda"

#: ../../reference/expressions.rst:2116
msgid "``:=``"
msgstr "``:=``"

#: ../../reference/expressions.rst:2116
msgid "Assignment expression"
msgstr "Expressão de atribuição"

#: ../../reference/expressions.rst:2121
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../reference/expressions.rst:2122
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"Embora ``abs(x%y) < abs(y)`` seja verdadeiro matematicamente, para floats "
"pode não ser verdadeiro numericamete devido a arredondamentos. Por exemplo, "
"e assumindo uma plataforma em que um float do Python é um número de dupla "
"precisão IEEE 754, para que ``-1e-100 % 1e100`` tenha o mesmo sinal que "
"``1e100``, o resultado calculado é ``-1e-100 + 1e100``, que é numericamete "
"exatamente igual a ``1e100``. A função :func:`math.fmod` devolve um "
"resultado cujo sinal corresponde ao sinal do primeiro argumento, e assim "
"devolve ``-1e-100`` neste caso. Qual abordagem é mais apropriada depende da "
"aplicação."

#: ../../reference/expressions.rst:2131
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Se x estiver muito próximo de um múltiplo inteiro exato de y, é possível que "
"``x//y`` seja uma unidade maior que ``(x-x%y)//y`` devido a arredondamentos. "
"Nestes casos, o Python devolve o último resultado, a fim de preservar que "
"``divmod(x,y)[0] * y + x % y`` esteja muito próximo de ``x``."

#: ../../reference/expressions.rst:2136
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"O padrão Unicode distingue entre :dfn:`pontos de código` (por exemplo, "
"U+0041) e :dfn:`caracteres abstratos` (por exemplo, \"LETRA MAIÚSCULA LATINA "
"A\"). Embora a maioria dos caracteres abstratos em Unicode sejam "
"representados usando apenas um ponto de código, há um número de caracteres "
"abstratos que também podem ser representados usando uma sequência de mais de "
"um ponto de código. Por exemplo, o carácter abstrato \"LETRA MAIÚSCULA "
"LATINA C COM CEDILHA\" pode ser representado como um único :dfn:`carácter "
"pré-composto` na posição de código U+00C7, ou como uma sequência de um :dfn:"
"`carácter base` na posição de código U+0043 (LETRA MAIÚSCULA LATINA C), "
"seguido de um :dfn:`carácter de combinação` na posição de código U+0327 "
"(CEDILHA DE COMBINAÇÃO)."

#: ../../reference/expressions.rst:2147
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Os operadores de comparação em strings comparam ao nível dos pontos de "
"código Unicode. Isto pode ser contra-intuitivo para os humanos. Por exemplo, "
"``\"\\u00C7\" == \"\\u0043\\u0327\"`` é ``False``, embora ambas as strings "
"representem o mesmo carácter abstrato \"LETRA MAIÚSCULA LATINA C COM "
"CEDILHA\"."

#: ../../reference/expressions.rst:2152
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Para comparar strings ao nível de caracteres abstratos (ou seja, de uma "
"forma intuitiva para os humanos), use :func:`unicodedata.normalize`."

#: ../../reference/expressions.rst:2155
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"Devido à recolha automática de lixo, listas livres e à natureza dinâmica dos "
"descritores, pode notar comportamentos aparentemente invulgares em certos "
"usos do operador :keyword:`is`, como aqueles que envolvem comparações entre "
"métodos de instância ou constantes. Consulte a sua documentação para mais "
"informações."

#: ../../reference/expressions.rst:2160
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"O operador de potência ``**`` liga-se menos fortemente do que um operador "
"unário aritmético ou bit a bit à sua direita, ou seja, ``2**-1`` é ``0.5``."

#: ../../reference/expressions.rst:2163
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"O operador ``%`` também é usado para formatação de strings; aplica-se a "
"mesma precedência."

#: ../../reference/expressions.rst:8 ../../reference/expressions.rst:448
#: ../../reference/expressions.rst:504 ../../reference/expressions.rst:1840
#: ../../reference/expressions.rst:1880 ../../reference/expressions.rst:1931
#: ../../reference/expressions.rst:1958 ../../reference/expressions.rst:1986
msgid "expression"
msgstr "expressão"

#: ../../reference/expressions.rst:8
msgid "BNF"
msgstr "BNF"

#: ../../reference/expressions.rst:28 ../../reference/expressions.rst:1320
#: ../../reference/expressions.rst:1368
msgid "arithmetic"
msgstr "aritmética"

#: ../../reference/expressions.rst:28
msgid "conversion"
msgstr "conversão"

#: ../../reference/expressions.rst:50
msgid "atom"
msgstr "átomo"

#: ../../reference/expressions.rst:67 ../../reference/expressions.rst:81
msgid "name"
msgstr "nome"

#: ../../reference/expressions.rst:67
msgid "identifier"
msgstr "identificador"

#: ../../reference/expressions.rst:73 ../../reference/expressions.rst:625
#: ../../reference/expressions.rst:680 ../../reference/expressions.rst:811
#: ../../reference/expressions.rst:866 ../../reference/expressions.rst:913
#: ../../reference/expressions.rst:1357 ../../reference/expressions.rst:1410
#: ../../reference/expressions.rst:1514
msgid "exception"
msgstr "exceção"

#: ../../reference/expressions.rst:73
msgid "NameError"
msgstr "NameError"

#: ../../reference/expressions.rst:81
msgid "mangling"
msgstr "transformação"

#: ../../reference/expressions.rst:81
msgid "private"
msgstr "privado"

#: ../../reference/expressions.rst:81
msgid "names"
msgstr "nomes"

#: ../../reference/expressions.rst:132
msgid "literal"
msgstr "literal"

#: ../../reference/expressions.rst:149 ../../reference/expressions.rst:427
msgid "immutable"
msgstr "imutável"

#: ../../reference/expressions.rst:149
msgid "data"
msgstr "dados"

#: ../../reference/expressions.rst:149
msgid "type"
msgstr "tipo"

#: ../../reference/expressions.rst:149 ../../reference/expressions.rst:330
#: ../../reference/expressions.rst:356 ../../reference/expressions.rst:384
#: ../../reference/expressions.rst:427 ../../reference/expressions.rst:448
#: ../../reference/expressions.rst:613 ../../reference/expressions.rst:801
#: ../../reference/expressions.rst:913 ../../reference/expressions.rst:942
#: ../../reference/expressions.rst:1019 ../../reference/expressions.rst:1063
#: ../../reference/expressions.rst:1211 ../../reference/expressions.rst:1225
#: ../../reference/expressions.rst:1239 ../../reference/expressions.rst:1246
#: ../../reference/expressions.rst:1805 ../../reference/expressions.rst:1998
msgid "object"
msgstr "objeto"

#: ../../reference/expressions.rst:217
msgid "parenthesized form"
msgstr "forma entre parênteses"

#: ../../reference/expressions.rst:217 ../../reference/expressions.rst:448
#: ../../reference/expressions.rst:1063
msgid "() (parentheses)"
msgstr "() (parênteses)"

#: ../../reference/expressions.rst:217
msgid "tuple display"
msgstr "exibição de tuplo"

#: ../../reference/expressions.rst:230 ../../reference/expressions.rst:330
msgid "empty"
msgstr "vazio"

#: ../../reference/expressions.rst:230 ../../reference/expressions.rst:942
#: ../../reference/expressions.rst:1019 ../../reference/expressions.rst:1998
msgid "tuple"
msgstr "tuplo"

#: ../../reference/expressions.rst:236 ../../reference/expressions.rst:2020
msgid "comma"
msgstr "vírgula"

#: ../../reference/expressions.rst:236 ../../reference/expressions.rst:330
#: ../../reference/expressions.rst:356 ../../reference/expressions.rst:384
#: ../../reference/expressions.rst:1013 ../../reference/expressions.rst:1063
#: ../../reference/expressions.rst:1986
msgid ", (comma)"
msgstr ", (vírgula)"

#: ../../reference/expressions.rst:251 ../../reference/expressions.rst:330
#: ../../reference/expressions.rst:356 ../../reference/expressions.rst:384
msgid "comprehensions"
msgstr "compreensões"

#: ../../reference/expressions.rst:261
msgid "for"
msgstr "para"

#: ../../reference/expressions.rst:261 ../../reference/expressions.rst:296
msgid "in comprehensions"
msgstr "em compreensões"

#: ../../reference/expressions.rst:261 ../../reference/expressions.rst:1931
msgid "if"
msgstr "se"

#: ../../reference/expressions.rst:261
msgid "async for"
msgstr "para assíncrono"

#: ../../reference/expressions.rst:296 ../../reference/expressions.rst:1264
msgid "await"
msgstr "aguardar"

#: ../../reference/expressions.rst:330 ../../reference/expressions.rst:913
#: ../../reference/expressions.rst:942 ../../reference/expressions.rst:1019
#: ../../reference/expressions.rst:1986
msgid "list"
msgstr "lista"

#: ../../reference/expressions.rst:330 ../../reference/expressions.rst:356
#: ../../reference/expressions.rst:384
msgid "display"
msgstr "exibição"

#: ../../reference/expressions.rst:330 ../../reference/expressions.rst:938
msgid "[] (square brackets)"
msgstr "[] (parênteses retos)"

#: ../../reference/expressions.rst:330
msgid "list expression"
msgstr "expressão de lista"

#: ../../reference/expressions.rst:330 ../../reference/expressions.rst:356
#: ../../reference/expressions.rst:1986
msgid "expression list"
msgstr "lista de expressões"

#: ../../reference/expressions.rst:356
msgid "set"
msgstr "conjunto"

#: ../../reference/expressions.rst:356 ../../reference/expressions.rst:384
msgid "{} (curly brackets)"
msgstr "{} (chavetas)"

#: ../../reference/expressions.rst:356
msgid "set expression"
msgstr "expressão de conjunto"

#: ../../reference/expressions.rst:384 ../../reference/expressions.rst:410
#: ../../reference/expressions.rst:942
msgid "dictionary"
msgstr "dicionário"

#: ../../reference/expressions.rst:384
msgid "key"
msgstr "chave"

#: ../../reference/expressions.rst:384
msgid "value"
msgstr "valor"

#: ../../reference/expressions.rst:384
msgid "key/value pair"
msgstr "par chave/valor"

#: ../../reference/expressions.rst:384
msgid "dictionary expression"
msgstr "expressão de dicionário"

#: ../../reference/expressions.rst:384 ../../reference/expressions.rst:1013
#: ../../reference/expressions.rst:1958
msgid ": (colon)"
msgstr ": (dois pontos)"

#: ../../reference/expressions.rst:384
msgid "in dictionary expressions"
msgstr "em expressões de dicionário"

#: ../../reference/expressions.rst:384 ../../reference/expressions.rst:410
msgid "in dictionary displays"
msgstr "em exibições de dicionário"

#: ../../reference/expressions.rst:410 ../../reference/expressions.rst:1146
#: ../../reference/expressions.rst:2005
msgid "unpacking"
msgstr "desempacotamento"

#: ../../reference/expressions.rst:410 ../../reference/expressions.rst:1176
#: ../../reference/expressions.rst:1284
msgid "**"
msgstr "**"

#: ../../reference/expressions.rst:427
msgid "hashable"
msgstr "hashável"

#: ../../reference/expressions.rst:448 ../../reference/expressions.rst:504
#: ../../reference/expressions.rst:613
msgid "generator"
msgstr "gerador"

#: ../../reference/expressions.rst:448
msgid "generator expression"
msgstr "expressão geradora"

#: ../../reference/expressions.rst:504 ../../reference/expressions.rst:1264
msgid "keyword"
msgstr "palavra-chave"

#: ../../reference/expressions.rst:504 ../../reference/expressions.rst:702
msgid "yield"
msgstr "yield"

#: ../../reference/expressions.rst:504 ../../reference/expressions.rst:572
msgid "from"
msgstr "de"

#: ../../reference/expressions.rst:504 ../../reference/expressions.rst:1211
#: ../../reference/expressions.rst:1225 ../../reference/expressions.rst:1958
msgid "function"
msgstr "função"

#: ../../reference/expressions.rst:558
msgid "coroutine"
msgstr "corrotina"

#: ../../reference/expressions.rst:572
msgid "yield from expression"
msgstr "expressão yield from"

#: ../../reference/expressions.rst:625
msgid "StopIteration"
msgstr "StopIteration"

#: ../../reference/expressions.rst:680 ../../reference/expressions.rst:866
msgid "GeneratorExit"
msgstr "GeneratorExit"

#: ../../reference/expressions.rst:702
msgid "examples"
msgstr "exemplos"

#: ../../reference/expressions.rst:801
msgid "asynchronous-generator"
msgstr "gerador assíncrono"

#: ../../reference/expressions.rst:811
msgid "StopAsyncIteration"
msgstr "StopAsyncIteration"

#: ../../reference/expressions.rst:890
msgid "primary"
msgstr "primário"

#: ../../reference/expressions.rst:904
msgid "attribute"
msgstr "atributo"

#: ../../reference/expressions.rst:904
msgid "reference"
msgstr "referência"

#: ../../reference/expressions.rst:904
msgid ". (dot)"
msgstr ". (ponto)"

#: ../../reference/expressions.rst:904
msgid "attribute reference"
msgstr "referência a atributo"

#: ../../reference/expressions.rst:913
msgid "AttributeError"
msgstr "AttributeError"

#: ../../reference/expressions.rst:913
msgid "module"
msgstr "módulo"

#: ../../reference/expressions.rst:938
msgid "subscription"
msgstr "subscrito"

#: ../../reference/expressions.rst:942 ../../reference/expressions.rst:1019
#: ../../reference/expressions.rst:1805
msgid "sequence"
msgstr "sequência"

#: ../../reference/expressions.rst:942
msgid "mapping"
msgstr "mapeamento"

#: ../../reference/expressions.rst:942 ../../reference/expressions.rst:999
#: ../../reference/expressions.rst:1019
msgid "string"
msgstr "string"

#: ../../reference/expressions.rst:942 ../../reference/expressions.rst:999
msgid "item"
msgstr "item"

#: ../../reference/expressions.rst:999
msgid "character"
msgstr "carácter"

#: ../../reference/expressions.rst:1013
msgid "slicing"
msgstr "fatiamento"

#: ../../reference/expressions.rst:1013
msgid "slice"
msgstr "fatia"

#: ../../reference/expressions.rst:1045
msgid "start (slice object attribute)"
msgstr "início (atributo do objeto fatia)"

#: ../../reference/expressions.rst:1045
msgid "stop (slice object attribute)"
msgstr "fim (atributo do objeto fatia)"

#: ../../reference/expressions.rst:1045
msgid "step (slice object attribute)"
msgstr "passo (atributo do objeto fatia)"

#: ../../reference/expressions.rst:1063
msgid "callable"
msgstr "chamável"

#: ../../reference/expressions.rst:1063 ../../reference/expressions.rst:1211
#: ../../reference/expressions.rst:1225 ../../reference/expressions.rst:1239
#: ../../reference/expressions.rst:1246 ../../reference/expressions.rst:1256
msgid "call"
msgstr "chamada"

#: ../../reference/expressions.rst:1063
msgid "argument"
msgstr "argumento"

#: ../../reference/expressions.rst:1063 ../../reference/expressions.rst:1096
msgid "call semantics"
msgstr "semântica de chamada"

#: ../../reference/expressions.rst:1063
msgid "argument list"
msgstr "lista de argumentos"

#: ../../reference/expressions.rst:1063
msgid "= (equals)"
msgstr "= (igual)"

#: ../../reference/expressions.rst:1063 ../../reference/expressions.rst:1146
#: ../../reference/expressions.rst:1176
msgid "in function calls"
msgstr "em chamadas de função"

#: ../../reference/expressions.rst:1096
msgid "parameter"
msgstr "parâmetro"

#: ../../reference/expressions.rst:1146 ../../reference/expressions.rst:1381
#: ../../reference/expressions.rst:2005
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../reference/expressions.rst:1211
msgid "user-defined"
msgstr "definido pelo utilizador"

#: ../../reference/expressions.rst:1211
msgid "user-defined function"
msgstr "função definida pelo utilizador"

#: ../../reference/expressions.rst:1225
msgid "built-in function"
msgstr "função integrada"

#: ../../reference/expressions.rst:1225
msgid "method"
msgstr "método"

#: ../../reference/expressions.rst:1225
msgid "built-in method"
msgstr "método integrado"

#: ../../reference/expressions.rst:1239
msgid "class"
msgstr "classe"

#: ../../reference/expressions.rst:1239
msgid "class object"
msgstr "objeto de classe"

#: ../../reference/expressions.rst:1246
msgid "class instance"
msgstr "instância de classe"

#: ../../reference/expressions.rst:1246 ../../reference/expressions.rst:1256
msgid "instance"
msgstr "instância"

#: ../../reference/expressions.rst:1256
msgid "__call__() (object method)"
msgstr "__call__() (método de objeto)"

#: ../../reference/expressions.rst:1284
msgid "power"
msgstr "potência"

#: ../../reference/expressions.rst:1284 ../../reference/expressions.rst:1320
#: ../../reference/expressions.rst:1368 ../../reference/expressions.rst:1496
#: ../../reference/expressions.rst:1525 ../../reference/expressions.rst:1840
msgid "operation"
msgstr "operação"

#: ../../reference/expressions.rst:1284 ../../reference/expressions.rst:1329
#: ../../reference/expressions.rst:1338 ../../reference/expressions.rst:1346
#: ../../reference/expressions.rst:1381 ../../reference/expressions.rst:1398
#: ../../reference/expressions.rst:1410 ../../reference/expressions.rst:1428
#: ../../reference/expressions.rst:1458 ../../reference/expressions.rst:1475
#: ../../reference/expressions.rst:1496 ../../reference/expressions.rst:1534
#: ../../reference/expressions.rst:1542 ../../reference/expressions.rst:1551
#: ../../reference/expressions.rst:1566 ../../reference/expressions.rst:1805
#: ../../reference/expressions.rst:1814 ../../reference/expressions.rst:1856
#: ../../reference/expressions.rst:1861 ../../reference/expressions.rst:1866
#: ../../reference/expressions.rst:1931 ../../reference/expressions.rst:2056
msgid "operator"
msgstr "operator"

#: ../../reference/expressions.rst:1320
msgid "unary"
msgstr "unário"

#: ../../reference/expressions.rst:1320 ../../reference/expressions.rst:1525
#: ../../reference/expressions.rst:1534 ../../reference/expressions.rst:1542
#: ../../reference/expressions.rst:1551
msgid "bitwise"
msgstr "bit a bit"

#: ../../reference/expressions.rst:1329
msgid "negation"
msgstr "negação"

#: ../../reference/expressions.rst:1329
msgid "minus"
msgstr "menos"

#: ../../reference/expressions.rst:1329 ../../reference/expressions.rst:1475
msgid "- (minus)"
msgstr "- (menos)"

#: ../../reference/expressions.rst:1329 ../../reference/expressions.rst:1338
msgid "unary operator"
msgstr "operador unário"

#: ../../reference/expressions.rst:1338
msgid "plus"
msgstr "mais"

#: ../../reference/expressions.rst:1338 ../../reference/expressions.rst:1458
msgid "+ (plus)"
msgstr "+ (mais)"

#: ../../reference/expressions.rst:1346
msgid "inversion"
msgstr "inversão"

#: ../../reference/expressions.rst:1346
msgid "~ (tilde)"
msgstr "~ (til)"

#: ../../reference/expressions.rst:1357
msgid "TypeError"
msgstr "TypeError"

#: ../../reference/expressions.rst:1368 ../../reference/expressions.rst:1525
msgid "binary"
msgstr "binário"

#: ../../reference/expressions.rst:1381
msgid "multiplication"
msgstr "multiplicação"

#: ../../reference/expressions.rst:1398
msgid "matrix multiplication"
msgstr "multiplicação de matrizes"

#: ../../reference/expressions.rst:1398
msgid "@ (at)"
msgstr "@ (arroba)"

#: ../../reference/expressions.rst:1410
msgid "ZeroDivisionError"
msgstr "ZeroDivisionError"

#: ../../reference/expressions.rst:1410
msgid "division"
msgstr "divisão"

#: ../../reference/expressions.rst:1410
msgid "/ (slash)"
msgstr "/ (barra)"

#: ../../reference/expressions.rst:1410
msgid "//"
msgstr "//"

#: ../../reference/expressions.rst:1428
msgid "modulo"
msgstr "módulo"

#: ../../reference/expressions.rst:1428
msgid "% (percent)"
msgstr "% (percentagem)"

#: ../../reference/expressions.rst:1458
msgid "addition"
msgstr "adição"

#: ../../reference/expressions.rst:1458 ../../reference/expressions.rst:1475
msgid "binary operator"
msgstr "operador binário"

#: ../../reference/expressions.rst:1475
msgid "subtraction"
msgstr "subtração"

#: ../../reference/expressions.rst:1496
msgid "shifting"
msgstr "deslocamento"

#: ../../reference/expressions.rst:1496
msgid "<<"
msgstr "<<"

#: ../../reference/expressions.rst:1496
msgid ">>"
msgstr ">>"

#: ../../reference/expressions.rst:1514
msgid "ValueError"
msgstr "ValueError"

#: ../../reference/expressions.rst:1534 ../../reference/expressions.rst:1861
msgid "and"
msgstr "e"

#: ../../reference/expressions.rst:1534
msgid "& (ampersand)"
msgstr "& (e comercial)"

#: ../../reference/expressions.rst:1542
msgid "xor"
msgstr "XOR"

#: ../../reference/expressions.rst:1542
msgid "exclusive"
msgstr "exclusivo"

#: ../../reference/expressions.rst:1542 ../../reference/expressions.rst:1551
#: ../../reference/expressions.rst:1866
msgid "or"
msgstr "ou"

#: ../../reference/expressions.rst:1542
msgid "^ (caret)"
msgstr "^ (acento circunflexo)"

#: ../../reference/expressions.rst:1551
msgid "inclusive"
msgstr "inclusivo"

#: ../../reference/expressions.rst:1551
msgid "| (vertical bar)"
msgstr "| (barra vertical)"

#: ../../reference/expressions.rst:1566
msgid "comparison"
msgstr "comparação"

#: ../../reference/expressions.rst:1566
msgid "C"
msgstr "C"

#: ../../reference/expressions.rst:1566
msgid "language"
msgstr "linguagem"

#: ../../reference/expressions.rst:1566
msgid "< (less)"
msgstr "< (menor)"

#: ../../reference/expressions.rst:1566
msgid "> (greater)"
msgstr "> (maior)"

#: ../../reference/expressions.rst:1566
msgid "<="
msgstr "<="

#: ../../reference/expressions.rst:1566
msgid ">="
msgstr ">="

#: ../../reference/expressions.rst:1566
msgid "=="
msgstr "=="

#: ../../reference/expressions.rst:1566
msgid "!="
msgstr "!="

#: ../../reference/expressions.rst:1590
msgid "chaining"
msgstr "encadeamento"

#: ../../reference/expressions.rst:1590
msgid "comparisons"
msgstr "comparações"

#: ../../reference/expressions.rst:1805
msgid "in"
msgstr "em"

#: ../../reference/expressions.rst:1805
msgid "not in"
msgstr "não em"

#: ../../reference/expressions.rst:1805
msgid "membership"
msgstr "pertence"

#: ../../reference/expressions.rst:1805 ../../reference/expressions.rst:1814
msgid "test"
msgstr "teste"

#: ../../reference/expressions.rst:1814
msgid "is"
msgstr "é"

#: ../../reference/expressions.rst:1814
msgid "is not"
msgstr "não é"

#: ../../reference/expressions.rst:1814
msgid "identity"
msgstr "identidade"

#: ../../reference/expressions.rst:1840
msgid "Conditional"
msgstr "Condicional"

#: ../../reference/expressions.rst:1840
msgid "Boolean"
msgstr "Booleano"

#: ../../reference/expressions.rst:1856
msgid "not"
msgstr "não"

#: ../../reference/expressions.rst:1880
msgid ":= (colon equals)"
msgstr ":= (dois pontos igual)"

#: ../../reference/expressions.rst:1880
msgid "assignment expression"
msgstr "expressão de atribuição"

#: ../../reference/expressions.rst:1880
msgid "walrus operator"
msgstr "operador walrus"

#: ../../reference/expressions.rst:1880
msgid "named expression"
msgstr "expressão nomeada"

#: ../../reference/expressions.rst:1880
msgid "assignment"
msgstr "atribuição"

#: ../../reference/expressions.rst:1931
msgid "conditional"
msgstr "condicional"

#: ../../reference/expressions.rst:1931
msgid "ternary"
msgstr "ternário"

#: ../../reference/expressions.rst:1931
msgid "conditional expression"
msgstr "expressão condicional"

#: ../../reference/expressions.rst:1931
msgid "else"
msgstr "senão"

#: ../../reference/expressions.rst:1958
msgid "lambda"
msgstr "lambda"

#: ../../reference/expressions.rst:1958
msgid "form"
msgstr "forma"

#: ../../reference/expressions.rst:1958
msgid "anonymous"
msgstr "anónimo"

#: ../../reference/expressions.rst:1958
msgid "lambda expression"
msgstr "expressão lambda"

#: ../../reference/expressions.rst:2005
msgid "iterable"
msgstr "iterável"

#: ../../reference/expressions.rst:2005
msgid "in expression lists"
msgstr "em listas de expressões"

#: ../../reference/expressions.rst:2020
msgid "trailing"
msgstr "final"

#: ../../reference/expressions.rst:2035
msgid "evaluation"
msgstr "avaliação"

#: ../../reference/expressions.rst:2035
msgid "order"
msgstr "ordem"

#: ../../reference/expressions.rst:2056
msgid "precedence"
msgstr "precedência"
