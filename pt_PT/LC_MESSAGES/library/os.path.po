# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-17 15:05+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/os.path.rst:2
msgid ":mod:`!os.path` --- Common pathname manipulations"
msgstr ":mod:`!os.path` --- Manipulações comuns de caminhos"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/genericpath.py`, :source:`Lib/posixpath.py` "
"(for POSIX) and :source:`Lib/ntpath.py` (for Windows)."
msgstr ""
"**Código-fonte:** :source:`Lib/genericpath.py`, :source:`Lib/posixpath.py` "
"(para POSIX) e :source:`Lib/ntpath.py` (para Windows)."

#: ../../library/os.path.rst:14
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"Este módulo implementa algumas funções úteis para manipular caminhos. Para "
"ler ou escrever ficheiros, consulte :func:`open`, e para aceder ao sistema "
"de ficheiros, consulte o módulo :mod:`os`. Os parâmetros de caminho podem "
"ser passados como strings, bytes, ou qualquer objeto que implemente o "
"protocolo :class:`os.PathLike`."

#: ../../library/os.path.rst:19
msgid ""
"Unlike a Unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also "
"the :mod:`glob` module.)"
msgstr ""
"Ao contrário de uma *shell* Unix, o Python não faz expansões de caminho "
"*automáticas*. Funções como :func:`expanduser` e :func:`expandvars` podem "
"ser invocadas explicitamente quando uma aplicação necessita de expansão de "
"caminho semelhante à *shell*. (Consulte também o módulo :mod:`glob`.)"

#: ../../library/os.path.rst:26
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr "O módulo :mod:`pathlib` oferece objetos de caminho de alto nível."

#: ../../library/os.path.rst:31
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr ""
"Todas estas funções aceitam apenas objetos do tipo bytes ou strings como "
"parâmetros. O resultado é um objeto do mesmo tipo, se um caminho ou nome de "
"ficheiro for devolvido."

#: ../../library/os.path.rst:37
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The :mod:"
"`os.path` module is always the path module suitable for the operating system "
"Python is running on, and therefore usable for local paths.  However, you "
"can also import and use the individual modules if you want to manipulate a "
"path that is *always* in one of the different formats.  They all have the "
"same interface:"
msgstr ""
"Como diferentes sistemas operativos têm convenções diferentes para nomes de "
"caminhos, existem várias versões deste módulo na biblioteca padrão. O "
"módulo :mod:`os.path` é sempre o módulo de caminho adequado para o sistema "
"operativo onde o Python está a ser executado, sendo, portanto, utilizável "
"para caminhos locais. No entanto, também pode importar e usar os módulos "
"individuais se pretender manipular um caminho que esteja *sempre* num dos "
"diferentes formatos. Todos eles têm a mesma interface:"

#: ../../library/os.path.rst:45
msgid ":mod:`!posixpath` for UNIX-style paths"
msgstr ":mod:`!posixpath` para caminhos no estilo UNIX"

#: ../../library/os.path.rst:46
msgid ":mod:`!ntpath` for Windows paths"
msgstr ":mod:`!ntpath` para caminhos Windows"

#: ../../library/os.path.rst:51
msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink`, and :func:`ismount` now return ``False`` instead of raising an "
"exception for paths that contain characters or bytes unrepresentable at the "
"OS level."
msgstr ""
"As funções :func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :"
"func:`islink` e :func:`ismount` agora devolvem ``False`` em vez de lançar "
"uma exceção para caminhos que contenham caracteres ou bytes não "
"representáveis ao nível do sistema operativo."

#: ../../library/os.path.rst:59
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling ``normpath(join(os.getcwd(), "
"path))``."
msgstr ""

#: ../../library/os.path.rst:62
msgid ":func:`os.path.join` and :func:`os.path.normpath`."
msgstr ""

#: ../../library/os.path.rst:64 ../../library/os.path.rst:77
#: ../../library/os.path.rst:118 ../../library/os.path.rst:127
#: ../../library/os.path.rst:143 ../../library/os.path.rst:153
#: ../../library/os.path.rst:179 ../../library/os.path.rst:199
#: ../../library/os.path.rst:216 ../../library/os.path.rst:228
#: ../../library/os.path.rst:237 ../../library/os.path.rst:249
#: ../../library/os.path.rst:263 ../../library/os.path.rst:273
#: ../../library/os.path.rst:292 ../../library/os.path.rst:312
#: ../../library/os.path.rst:398 ../../library/os.path.rst:418
#: ../../library/os.path.rst:458 ../../library/os.path.rst:487
#: ../../library/os.path.rst:503 ../../library/os.path.rst:514
#: ../../library/os.path.rst:541 ../../library/os.path.rst:566
#: ../../library/os.path.rst:630
msgid "Accepts a :term:`path-like object`."
msgstr "Aceita um :term:`objeto semelhante a um caminho`."

#: ../../library/os.path.rst:70
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"Devolve o nome base do caminho *path*. Este é o segundo elemento do par "
"devolvido pela função :func:`split` quando *path* é passado. Note que o "
"resultado desta função é diferente do programa Unix :program:`basename`; "
"enquanto :program:`basename` para ``'/foo/bar/'`` devolve ``'bar'``, a "
"função :func:`basename` devolve uma string vazia (``''``)."

#: ../../library/os.path.rst:83
msgid ""
"Return the longest common sub-path of each pathname in the iterable "
"*paths*.  Raise :exc:`ValueError` if *paths* contain both absolute and "
"relative pathnames, if *paths* are on different drives, or if *paths* is "
"empty.  Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"Devolve o sub-caminho comum mais longo de cada caminho no iterável *paths*. "
"Lança :exc:`ValueError` se *paths* contiver caminhos absolutos e relativos, "
"se *paths* estiverem em unidades diferentes, ou se *paths* estiver vazio. Ao "
"contrário de :func:`commonprefix`, isto devolve um caminho válido."

#: ../../library/os.path.rst:91
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr ""
"Aceita uma sequência de :term:`objetos semelhantes a caminhos <path-like "
"object>`."

#: ../../library/os.path.rst:94
msgid "Any iterable can now be passed, rather than just sequences."
msgstr "Agora pode ser passado qualquer iterável, não apenas sequências."

#: ../../library/os.path.rst:100
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string "
"(``''``)."
msgstr ""
"Devolve o prefixo de caminho mais longo (caracter a caracter) que é um "
"prefixo de todos os caminhos em *list*. Se *list* estiver vazio, devolve uma "
"string vazia (``''``)."

#: ../../library/os.path.rst:106
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr ""
"Esta função pode devolver caminhos inválidos porque trabalha caracter a "
"caracter. Para obter um caminho válido, consulte :func:`commonpath`."

#: ../../library/os.path.rst:112
msgid ""
">>> os.path.commonprefix(['/usr/lib', '/usr/local/lib'])\n"
"'/usr/l'\n"
"\n"
">>> os.path.commonpath(['/usr/lib', '/usr/local/lib'])\n"
"'/usr'"
msgstr ""
">>> os.path.commonprefix(['/usr/lib', '/usr/local/lib'])\n"
"'/usr/l'\n"
"\n"
">>> os.path.commonpath(['/usr/lib', '/usr/local/lib'])\n"
"'/usr'"

#: ../../library/os.path.rst:124
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr ""
"Devolve o nome do diretório do caminho *path*. Este é o primeiro elemento do "
"par devolvido pela função :func:`split` quando *path* é passado."

#: ../../library/os.path.rst:133
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"Devolve ``True`` se *path* se referir a um caminho existente ou a um "
"descritor de ficheiro aberto. Devolve ``False`` para ligações simbólicas "
"partidas. Em algumas plataformas, esta função pode devolver ``False`` se não "
"for concedida permissão para executar :func:`os.stat` no ficheiro "
"solicitado, mesmo que o *path* exista fisicamente."

#: ../../library/os.path.rst:139
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr ""
"*path* agora pode ser um inteiro: ``True`` é devolvido se for um descritor "
"de ficheiro aberto, ``False`` caso contrário."

#: ../../library/os.path.rst:149
msgid ""
"Return ``True`` if *path* refers to an existing path, including broken "
"symbolic links.   Equivalent to :func:`exists` on platforms lacking :func:"
"`os.lstat`."
msgstr ""
"Devolve ``True`` se *path* se referir a um caminho existente, incluindo "
"ligações simbólicas partidas. Equivalente a :func:`exists` em plataformas "
"sem :func:`os.lstat`."

#: ../../library/os.path.rst:161
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr ""
"Em Unix e Windows, devolve o argumento com um componente inicial ``~`` ou "
"``~user`` substituído pelo diretório *home* desse *user*."

#: ../../library/os.path.rst:166
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable :envvar:"
"`HOME` if it is set; otherwise the current user's home directory is looked "
"up in the password directory through the built-in module :mod:`pwd`. An "
"initial ``~user`` is looked up directly in the password directory."
msgstr ""
"Em Unix, um ``~`` inicial é substituído pela variável de ambiente :envvar:"
"`HOME` se estiver definida; caso contrário, o diretório *home* do utilizador "
"atual é procurado no diretório de passwords através do módulo integrado :mod:"
"`pwd`. Um ``~user`` inicial é procurado diretamente no diretório de "
"passwords."

#: ../../library/os.path.rst:171
msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by checking that the last directory component "
"of the current user's home directory matches :envvar:`USERNAME`, and "
"replacing it if so."
msgstr ""
"No Windows, :envvar:`USERPROFILE` será usado se estiver definido; caso "
"contrário, será usada uma combinação de :envvar:`HOMEPATH` e :envvar:"
"`HOMEDRIVE`. Um ``~user`` inicial é tratado verificando se o último "
"componente do diretório *home* do utilizador atual corresponde a :envvar:"
"`USERNAME`, substituindo-o se for o caso."

#: ../../library/os.path.rst:176
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr ""
"Se a expansão falhar ou se o caminho não começar com um til, o caminho é "
"devolvido inalterado."

#: ../../library/os.path.rst:182
msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "Já não usa :envvar:`HOME` no Windows."

#: ../../library/os.path.rst:191
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"Devolve o argumento com as variáveis de ambiente expandidas. Substrings da "
"forma ``$name`` ou ``${name}`` são substituídas pelo valor da variável de "
"ambiente *name*. Nomes de variáveis malformados e referências a variáveis "
"inexistentes permanecem inalterados."

#: ../../library/os.path.rst:196
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and "
"``${name}``."
msgstr ""
"No Windows, as expansões ``%name%`` são suportadas além de ``$name`` e "
"``${name}``."

#: ../../library/os.path.rst:205
msgid ""
"Return the time of last access of *path*.  The return value is a floating-"
"point number giving the number of seconds since the epoch (see the  :mod:"
"`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"Devolve a hora do último acesso a *path*. O valor devolvido é um número de "
"ponto flutuante que indica o número de segundos desde a época (consulte o "
"módulo :mod:`time`). Lança :exc:`OSError` se o ficheiro não existir ou for "
"inacessível."

#: ../../library/os.path.rst:212
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating-point number giving the number of seconds since the epoch (see "
"the  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or "
"is inaccessible."
msgstr ""
"Devolve a hora da última modificação de *path*. O valor devolvido é um "
"número de ponto flutuante que indica o número de segundos desde a época "
"(consulte o módulo :mod:`time`). Lança :exc:`OSError` se o ficheiro não "
"existir ou for inacessível."

#: ../../library/os.path.rst:222
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"Devolve o *ctime* do sistema, que em alguns sistemas (como Unix) é a hora da "
"última alteração dos metadados, e noutros (como Windows) é a hora de criação "
"de *path*. O valor devolvido é um número que indica o número de segundos "
"desde a época (consulte o módulo :mod:`time`). Lança :exc:`OSError` se o "
"ficheiro não existir ou for inacessível."

#: ../../library/os.path.rst:234
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does "
"not exist or is inaccessible."
msgstr ""
"Devolve o tamanho, em bytes, de *path*. Lança :exc:`OSError` se o ficheiro "
"não existir ou for inacessível."

#: ../../library/os.path.rst:243
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with two (back)slashes, or a "
"drive letter, colon, and (back)slash together."
msgstr ""
"Devolve ``True`` se *path* for um caminho absoluto. Em Unix, isso significa "
"que começa com uma barra; no Windows, que começa com duas barras invertidas, "
"ou uma letra de unidade, dois pontos e uma barra invertida."

#: ../../library/os.path.rst:247
msgid ":func:`abspath`"
msgstr ""

#: ../../library/os.path.rst:252
msgid ""
"On Windows, returns ``False`` if the given path starts with exactly one "
"(back)slash."
msgstr ""
"No Windows, devolve ``False`` se o caminho dado começar com exatamente uma "
"barra invertida."

#: ../../library/os.path.rst:259
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This "
"follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"Devolve ``True`` se *path* for um ficheiro regular :func:`existente "
"<exists>`. Isto segue ligações simbólicas, por isso tanto :func:`islink` "
"como :func:`isfile` podem ser verdadeiros para o mesmo caminho."

#: ../../library/os.path.rst:269
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true "
"for the same path."
msgstr ""
"Devolve ``True`` se *path* for um diretório :func:`existente <exists>`. Isto "
"segue ligações simbólicas, por isso tanto :func:`islink` como :func:`isdir` "
"podem ser verdadeiros para o mesmo caminho."

#: ../../library/os.path.rst:279
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <lexists>` directory "
"entry that is a junction.  Always return ``False`` if junctions are not "
"supported on the current platform."
msgstr ""
"Devolve ``True`` se *path* se referir a uma entrada de diretório :func:"
"`existente <lexists>` que seja uma junção. Devolve sempre ``False`` se as "
"junções não forem suportadas na plataforma atual."

#: ../../library/os.path.rst:288
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"Devolve ``True`` se *path* se referir a uma entrada de diretório :func:"
"`existente <exists>` que seja uma ligação simbólica. Sempre ``False`` se "
"ligações simbólicas não forem suportadas pelo ambiente de execução do Python."

#: ../../library/os.path.rst:298
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem. On Linux systems, it will always return "
"``True`` for btrfs subvolumes, even if they aren't mount points. On Windows, "
"a drive letter root and a share UNC are always mount points, and for any "
"other path ``GetVolumePathName`` is called to see if it is different from "
"the input path."
msgstr ""
"Devolve ``True`` se o caminho *path* for um :dfn:`ponto de montagem`: um "
"ponto num sistema de ficheiros onde outro sistema de ficheiros foi montado. "
"No POSIX, a função verifica se o pai de *path*, :file:`{path}/..`, está num "
"dispositivo diferente de *path*, ou se :file:`{path}/..` e *path* apontam "
"para o mesmo i-nó no mesmo dispositivo — isto deve detetar pontos de "
"montagem para todas as variantes Unix e POSIX. Não é capaz de detetar "
"confiavelmente *bind mounts* no mesmo sistema de ficheiros. Em sistemas "
"Linux, devolverá sempre ``True`` para subvolumes btrfs, mesmo que não sejam "
"pontos de montagem. No Windows, uma raiz de letra de unidade e um UNC de "
"partilha são sempre pontos de montagem, e para qualquer outro caminho, "
"``GetVolumePathName`` é chamado para verificar se é diferente do caminho de "
"entrada."

#: ../../library/os.path.rst:309
msgid "Added support for detecting non-root mount points on Windows."
msgstr ""
"Adicionado suporte para detetar pontos de montagem não-raiz no Windows."

#: ../../library/os.path.rst:318
msgid ""
"Return ``True`` if pathname *path* is located on a Windows Dev Drive. A Dev "
"Drive is optimized for developer scenarios, and offers faster performance "
"for reading and writing files. It is recommended for use for source code, "
"temporary build directories, package caches, and other IO-intensive "
"operations."
msgstr ""
"Devolve ``True`` se o caminho *path* estiver localizado numa *Dev Drive* do "
"Windows. Uma *Dev Drive* é otimizada para cenários de desenvolvimento e "
"oferece melhor desempenho para leitura e escrita de ficheiros. É recomendada "
"para código-fonte, diretórios de construção temporários, caches de pacotes e "
"outras operações intensivas de E/S."

#: ../../library/os.path.rst:324
msgid ""
"May raise an error for an invalid path, for example, one without a "
"recognizable drive, but returns ``False`` on platforms that do not support "
"Dev Drives. See `the Windows documentation <https://learn.microsoft.com/"
"windows/dev-drive/>`_ for information on enabling and creating Dev Drives."
msgstr ""
"Pode lançar um erro para um caminho inválido, por exemplo, um sem uma "
"unidade reconhecível, mas devolve ``False`` em plataformas que não suportam "
"*Dev Drives*. Consulte a `documentação do Windows <https://learn.microsoft."
"com/windows/dev-drive/>`_ para obter informações sobre como ativar e criar "
"*Dev Drives*."

#: ../../library/os.path.rst:331
msgid ""
"The function is now available on all platforms, and will always return "
"``False`` on those that have no support for Dev Drives"
msgstr ""
"A função está agora disponível em todas as plataformas e devolverá sempre "
"``False`` naquelas que não suportam *Dev Drives*."

#: ../../library/os.path.rst:337
msgid "Return ``True`` if *path* is a reserved pathname on the current system."
msgstr "Devolve ``True`` se *path* for um caminho reservado no sistema atual."

#: ../../library/os.path.rst:339
msgid ""
"On Windows, reserved filenames include those that end with a space or dot; "
"those that contain colons (i.e. file streams such as \"name:stream\"), "
"wildcard characters (i.e. ``'*?\"<>'``), pipe, or ASCII control characters; "
"as well as DOS device names such as \"NUL\", \"CON\", \"CONIN$\", \"CONOUT$"
"\", \"AUX\", \"PRN\", \"COM1\", and \"LPT1\"."
msgstr ""
"No Windows, os nomes de ficheiros reservados incluem aqueles que terminam "
"com um espaço ou ponto; aqueles que contêm dois pontos (por exemplo, fluxos "
"de ficheiros como \"name:stream\"), caracteres curinga (por exemplo, ``'*?"
"\"<>'``), pipe, ou caracteres de controlo ASCII; bem como nomes de "
"dispositivos DOS como \"NUL\", \"CON\", \"CONIN$\", \"CONOUT$\", \"AUX\", "
"\"PRN\", \"COM1\" e \"LPT1\"."

#: ../../library/os.path.rst:347
msgid ""
"This function approximates rules for reserved paths on most Windows systems. "
"These rules change over time in various Windows releases. This function may "
"be updated in future Python releases as changes to the rules become broadly "
"available."
msgstr ""
"Esta função aproxima as regras para caminhos reservados na maioria dos "
"sistemas Windows. Estas regras mudam ao longo do tempo em várias versões do "
"Windows. Esta função pode ser atualizada em futuras versões do Python à "
"medida que as alterações às regras se tornem amplamente disponíveis."

#: ../../library/os.path.rst:352
msgid "Availability"
msgstr "Disponibilidade"

#: ../../library/os.path.rst:359
msgid ""
"Join one or more path segments intelligently.  The return value is the "
"concatenation of *path* and all members of *\\*paths*, with exactly one "
"directory separator following each non-empty part, except the last. That is, "
"the result will only end in a separator if the last part is either empty or "
"ends in a separator."
msgstr ""

#: ../../library/os.path.rst:365
msgid ""
"If a segment is an absolute path (which on Windows requires both a drive and "
"a root), then all previous segments are ignored and joining continues from "
"the absolute path segment. On Linux, for example::"
msgstr ""

#: ../../library/os.path.rst:369
msgid ""
">>> os.path.join('/home/foo', 'bar')\n"
"'/home/foo/bar'\n"
">>> os.path.join('/home/foo', '/home/bar')\n"
"'/home/bar'"
msgstr ""

#: ../../library/os.path.rst:374
msgid ""
"On Windows, the drive is not reset when a rooted path segment (e.g., "
"``r'\\foo'``) is encountered. If a segment is on a different drive or is an "
"absolute path, all previous segments are ignored and the drive is reset. For "
"example::"
msgstr ""

#: ../../library/os.path.rst:379
msgid ""
">>> os.path.join('c:\\\\', 'foo')\n"
"'c:\\\\foo'\n"
">>> os.path.join('c:\\\\foo', 'd:\\\\bar')\n"
"'d:\\\\bar'"
msgstr ""

#: ../../library/os.path.rst:384
msgid ""
"Note that since there is a current directory for each drive, ``os.path."
"join(\"c:\", \"foo\")`` represents a path relative to the current directory "
"on drive :file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""

#: ../../library/os.path.rst:388
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr ""
"Aceita um :term:`objeto semelhante a um caminho` para *path* e *paths*."

#: ../../library/os.path.rst:394
msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the "
"pathname to lowercase, and also convert forward slashes to backward slashes. "
"On other operating systems, return the path unchanged."
msgstr ""
"Normaliza a capitalização de um caminho. No Windows, converte todos os "
"caracteres do caminho para minúsculas e também converte barras para a frente "
"em barras invertidas. Noutros sistemas operativos, devolve o caminho "
"inalterado."

#: ../../library/os.path.rst:404
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"Normaliza um caminho, eliminando separadores redundantes e referências a "
"níveis superiores, de modo que ``A//B``, ``A/B/``, ``A/./B`` e ``A/foo/../"
"B`` se tornem ``A/B``. Esta manipulação de strings pode alterar o "
"significado de um caminho que contenha ligações simbólicas. No Windows, "
"converte barras para a frente em barras invertidas. Para normalizar a "
"capitalização, use :func:`normcase`."

#: ../../library/os.path.rst:411
msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, if a pathname begins with exactly two "
"slashes, the first component following the leading characters may be "
"interpreted in an implementation-defined manner, although more than two "
"leading characters shall be treated as a single character."
msgstr ""
"Nos sistemas POSIX, de acordo com `IEEE Std 1003.1 2013 Edition; 4.13 "
"Resolução de Caminhos <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, se um caminho começar com exatamente "
"duas barras, o primeiro componente a seguir aos caracteres iniciais pode ser "
"interpretado de uma forma definida pela implementação, embora mais de duas "
"barras iniciais devam ser tratadas como um único caracter."

#: ../../library/os.path.rst:424
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system). On Windows, this function will also resolve MS-DOS (also "
"called 8.3) style names such as ``C:\\\\PROGRA~1`` to ``C:\\\\Program "
"Files``."
msgstr ""
"Devolve o caminho canónico do nome de ficheiro especificado, eliminando "
"quaisquer ligações simbólicas encontradas no caminho (se forem suportadas "
"pelo sistema operativo). No Windows, esta função também resolve nomes no "
"estilo MS-DOS (também chamados 8.3) como ``C:\\\\PROGRA~1`` para ``C:\\"
"\\Program Files``."

#: ../../library/os.path.rst:429
msgid ""
"By default, the path is evaluated up to the first component that does not "
"exist, is a symlink loop, or whose evaluation raises :exc:`OSError`. All "
"such components are appended unchanged to the existing part of the path."
msgstr ""
"Por predefinição, o caminho é avaliado até ao primeiro componente que não "
"exista, seja um ciclo de ligação simbólica, ou cuja avaliação lance :exc:"
"`OSError`. Todos esses componentes são anexados inalterados à parte "
"existente do caminho."

#: ../../library/os.path.rst:433
msgid ""
"Some errors that are handled this way include \"access denied\", \"not a "
"directory\", or \"bad argument to internal function\". Thus, the resulting "
"path may be missing or inaccessible, may still contain links or loops, and "
"may traverse non-directories."
msgstr ""
"Alguns erros tratados desta forma incluem \"acesso negado\", \"não é um "
"diretório\" ou \"argumento inválido para função interna\". Assim, o caminho "
"resultante pode estar em falta ou ser inacessível, pode ainda conter "
"ligações ou ciclos e pode atravessar não-diretórios."

#: ../../library/os.path.rst:438
msgid "This behavior can be modified by keyword arguments:"
msgstr ""
"Este comportamento pode ser modificado por argumentos de palavra-chave:"

#: ../../library/os.path.rst:440
msgid ""
"If *strict* is ``True``, the first error encountered when evaluating the "
"path is re-raised. In particular, :exc:`FileNotFoundError` is raised if "
"*path* does not exist, or another :exc:`OSError` if it is otherwise "
"inaccessible."
msgstr ""
"Se *strict* for ``True``, o primeiro erro encontrado ao avaliar o caminho é "
"relançado. Em particular, :exc:`FileNotFoundError` é lançado se *path* não "
"existir, ou outro :exc:`OSError` se for de outra forma inacessível."

#: ../../library/os.path.rst:445
msgid ""
"If *strict* is :py:data:`os.path.ALLOW_MISSING`, errors other than :exc:"
"`FileNotFoundError` are re-raised (as with ``strict=True``). Thus, the "
"returned path will not contain any symbolic links, but the named file and "
"some of its parent directories may be missing."
msgstr ""
"Se *strict* for :py:data:`os.path.ALLOW_MISSING`, erros diferentes de :exc:"
"`FileNotFoundError` são relançados (como com ``strict=True``). Assim, o "
"caminho devolvido não conterá ligações simbólicas, mas o ficheiro nomeado e "
"alguns dos seus diretórios pai podem estar em falta."

#: ../../library/os.path.rst:451
msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr ""
"Esta função emula o procedimento do sistema operativo para tornar um caminho "
"canónico, que difere ligeiramente entre Windows e UNIX no que diz respeito a "
"como as ligações e os componentes subsequentes do caminho interagem."

#: ../../library/os.path.rst:455
msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr ""
"As APIs do sistema operativo tornam os caminhos canónicos conforme "
"necessário, por isso não é normalmente necessário chamar esta função."

#: ../../library/os.path.rst:461
msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "Ligações simbólicas e junções são agora resolvidas no Windows."

#: ../../library/os.path.rst:464
msgid "The *strict* parameter was added."
msgstr "O parâmetro *strict* foi adicionado."

#: ../../library/os.path.rst:467
msgid ""
"The :py:data:`~os.path.ALLOW_MISSING` value for the *strict* parameter was "
"added."
msgstr ""
"O valor :py:data:`~os.path.ALLOW_MISSING` para o parâmetro *strict* foi "
"adicionado."

#: ../../library/os.path.rst:473
msgid "Special value used for the *strict* argument in :func:`realpath`."
msgstr "Valor especial usado para o argumento *strict* em :func:`realpath`."

#: ../../library/os.path.rst:479
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"Devolve um caminho de ficheiro relativo para *path*, a partir do diretório "
"atual ou de um diretório *start* opcional. Isto é um cálculo de caminho: o "
"sistema de ficheiros não é acedido para confirmar a existência ou natureza "
"de *path* ou *start*. No Windows, :exc:`ValueError` é lançado quando *path* "
"e *start* estão em unidades diferentes."

#: ../../library/os.path.rst:485
msgid "*start* defaults to :data:`os.curdir`."
msgstr "*start* por predefinição é :data:`os.curdir`."

#: ../../library/os.path.rst:493
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"Devolve ``True`` se ambos os argumentos de caminho se referirem ao mesmo "
"ficheiro ou diretório. Isto é determinado pelo número do dispositivo e "
"número do i-nó, e lança uma exceção se uma chamada :func:`os.stat` em "
"qualquer um dos caminhos falhar."

#: ../../library/os.path.rst:497 ../../library/os.path.rst:511
#: ../../library/os.path.rst:525
msgid "Added Windows support."
msgstr "Adicionado suporte para Windows."

#: ../../library/os.path.rst:500
msgid "Windows now uses the same implementation as all other platforms."
msgstr ""
"O Windows agora usa a mesma implementação que todas as outras plataformas."

#: ../../library/os.path.rst:509
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr ""
"Devolve ``True`` se os descritores de ficheiro *fp1* e *fp2* se referirem ao "
"mesmo ficheiro."

#: ../../library/os.path.rst:520
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, :func:`os."
"lstat`, or :func:`os.stat`.  This function implements the underlying "
"comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"Devolve ``True`` se os tuplos *stat1* e *stat2* se referirem ao mesmo "
"ficheiro. Estas estruturas podem ter sido devolvidas por :func:`os.fstat`, :"
"func:`os.lstat` ou :func:`os.stat`. Esta função implementa a comparação "
"subjacente usada por :func:`samefile` e :func:`sameopenfile`."

#: ../../library/os.path.rst:531
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`join`, :"
"func:`dirname` and :func:`basename`."
msgstr ""

#: ../../library/os.path.rst:547
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive "
"specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"Divide o caminho *path* num par ``(drive, tail)``, onde *drive* é um ponto "
"de montagem ou uma string vazia. Em sistemas que não usam especificações de "
"unidade, *drive* será sempre uma string vazia. Em todos os casos, ``drive + "
"tail`` será o mesmo que *path*."

#: ../../library/os.path.rst:552
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr ""
"No Windows, divide um caminho em unidade/ponto de partilha UNC e caminho "
"relativo."

#: ../../library/os.path.rst:554
msgid ""
"If the path contains a drive letter, drive will contain everything up to and "
"including the colon::"
msgstr ""
"Se o caminho contiver uma letra de unidade, *drive* conterá tudo até e "
"incluindo os dois pontos::"

#: ../../library/os.path.rst:557
msgid ""
">>> splitdrive(\"c:/dir\")\n"
"(\"c:\", \"/dir\")"
msgstr ""
">>> splitdrive(\"c:/dir\")\n"
"(\"c:\", \"/dir\")"

#: ../../library/os.path.rst:560
msgid ""
"If the path contains a UNC path, drive will contain the host name and share::"
msgstr ""
"Se o caminho contiver um caminho UNC, *drive* conterá o nome do anfitrião e "
"a partilha::"

#: ../../library/os.path.rst:563
msgid ""
">>> splitdrive(\"//host/computer/dir\")\n"
"(\"//host/computer\", \"/dir\")"
msgstr ""
">>> splitdrive(\"//host/computer/dir\")\n"
"(\"//host/computer\", \"/dir\")"

#: ../../library/os.path.rst:572
msgid ""
"Split the pathname *path* into a 3-item tuple ``(drive, root, tail)`` where "
"*drive* is a device name or mount point, *root* is a string of separators "
"after the drive, and *tail* is everything after the root. Any of these items "
"may be the empty string. In all cases, ``drive + root + tail`` will be the "
"same as *path*."
msgstr ""
"Divide o caminho *path* num tuplo de 3 itens ``(drive, root, tail)``, onde "
"*drive* é um nome de dispositivo ou ponto de montagem, *root* é uma string "
"de separadores após a unidade, e *tail* é tudo após a raiz. Qualquer um "
"destes itens pode ser uma string vazia. Em todos os casos, ``drive + root + "
"tail`` será o mesmo que *path*."

#: ../../library/os.path.rst:578
msgid ""
"On POSIX systems, *drive* is always empty. The *root* may be empty (if "
"*path* is relative), a single forward slash (if *path* is absolute), or two "
"forward slashes (implementation-defined per `IEEE Std 1003.1-2017; 4.13 "
"Pathname Resolution <https://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_.) For example::"
msgstr ""
"Nos sistemas POSIX, *drive* está sempre vazio. A *root* pode estar vazia (se "
"*path* for relativo), ser uma barra para a frente única (se *path* for "
"absoluto), ou duas barras para a frente (definido pela implementação de "
"acordo com `IEEE Std 1003.1-2017; 4.13 Resolução de Caminhos <https://pubs."
"opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13>`_). "
"Por exemplo::"

#: ../../library/os.path.rst:584
msgid ""
">>> splitroot('/home/sam')\n"
"('', '/', 'home/sam')\n"
">>> splitroot('//home/sam')\n"
"('', '//', 'home/sam')\n"
">>> splitroot('///home/sam')\n"
"('', '/', '//home/sam')"
msgstr ""
">>> splitroot('/home/sam')\n"
"('', '/', 'home/sam')\n"
">>> splitroot('//home/sam')\n"
"('', '//', 'home/sam')\n"
">>> splitroot('///home/sam')\n"
"('', '/', '//home/sam')"

#: ../../library/os.path.rst:591
msgid ""
"On Windows, *drive* may be empty, a drive-letter name, a UNC share, or a "
"device name. The *root* may be empty, a forward slash, or a backward slash. "
"For example::"
msgstr ""
"No Windows, *drive* pode estar vazio, ser um nome de letra de unidade, uma "
"partilha UNC ou um nome de dispositivo. A *root* pode estar vazia, ser uma "
"barra para a frente ou uma barra invertida. Por exemplo::"

#: ../../library/os.path.rst:595
msgid ""
">>> splitroot('C:/Users/Sam')\n"
"('C:', '/', 'Users/Sam')\n"
">>> splitroot('//Server/Share/Users/Sam')\n"
"('//Server/Share', '/', 'Users/Sam')"
msgstr ""
">>> splitroot('C:/Users/Sam')\n"
"('C:', '/', 'Users/Sam')\n"
">>> splitroot('//Server/Share/Users/Sam')\n"
"('//Server/Share', '/', 'Users/Sam')"

#: ../../library/os.path.rst:605
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"Divide o caminho *path* num par ``(root, ext)``, de modo que ``root + ext == "
"path``, e a extensão, *ext*, está vazia ou começa com um ponto e contém no "
"máximo um ponto."

#: ../../library/os.path.rst:609
msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "Se o caminho não contiver extensão, *ext* será ``''``::"

#: ../../library/os.path.rst:611
msgid ""
">>> splitext('bar')\n"
"('bar', '')"
msgstr ""
">>> splitext('bar')\n"
"('bar', '')"

#: ../../library/os.path.rst:614
msgid ""
"If the path contains an extension, then *ext* will be set to this extension, "
"including the leading period. Note that previous periods will be ignored::"
msgstr ""
"Se o caminho contiver uma extensão, então *ext* será definido para essa "
"extensão, incluindo o ponto inicial. Note que os pontos anteriores serão "
"ignorados::"

#: ../../library/os.path.rst:617
msgid ""
">>> splitext('foo.bar.exe')\n"
"('foo.bar', '.exe')\n"
">>> splitext('/foo/bar.exe')\n"
"('/foo/bar', '.exe')"
msgstr ""
">>> splitext('foo.bar.exe')\n"
"('foo.bar', '.exe')\n"
">>> splitext('/foo/bar.exe')\n"
"('/foo/bar', '.exe')"

#: ../../library/os.path.rst:622
msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr ""
"Os pontos iniciais do último componente do caminho são considerados parte da "
"raiz::"

#: ../../library/os.path.rst:625
msgid ""
">>> splitext('.cshrc')\n"
"('.cshrc', '')\n"
">>> splitext('/foo/....jpg')\n"
"('/foo/....jpg', '')"
msgstr ""
">>> splitext('.cshrc')\n"
"('.cshrc', '')\n"
">>> splitext('/foo/....jpg')\n"
"('/foo/....jpg', '')"

#: ../../library/os.path.rst:636
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr ""
"``True`` se strings Unicode arbitrárias podem ser usadas como nomes de "
"ficheiros (dentro dos limites impostos pelo sistema de ficheiros)."

#: ../../library/os.path.rst:10
msgid "path"
msgstr "caminho"

#: ../../library/os.path.rst:10
msgid "operations"
msgstr "operações"

#: ../../library/os.path.rst:157
msgid "~ (tilde)"
msgstr "~ (til)"

#: ../../library/os.path.rst:157
msgid "home directory expansion"
msgstr "expansão do diretório *home*"

#: ../../library/os.path.rst:164
msgid "module"
msgstr "módulo"

#: ../../library/os.path.rst:164
msgid "pwd"
msgstr "pwd"

#: ../../library/os.path.rst:185
msgid "$ (dollar)"
msgstr "$ (dólar)"

#: ../../library/os.path.rst:185
msgid "environment variables expansion"
msgstr "expansão de variáveis de ambiente"

#: ../../library/os.path.rst:185
msgid "% (percent)"
msgstr "% (percentagem)"

#: ../../library/os.path.rst:185
msgid "environment variables expansion (Windows)"
msgstr "expansão de variáveis de ambiente (Windows)"
