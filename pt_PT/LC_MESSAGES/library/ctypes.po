# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-07 17:12+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ""

#: ../../library/ctypes.rst:9
msgid "**Source code:** :source:`Lib/ctypes`"
msgstr "**Código-fonte:** :source:`Lib/ctypes`"

#: ../../library/ctypes.rst:13
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` é uma biblioteca de funções externas para Python. Fornece "
"tipos de dados compatíveis com C e permite chamar funções em DLLs ou "
"bibliotecas partilhadas. Pode ser usada para encapsular estas bibliotecas em "
"Python puro."

#: ../../library/ctypes.rst:21
msgid "ctypes tutorial"
msgstr "tutorial de ctypes"

#: ../../library/ctypes.rst:23
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Nota: Os exemplos de código neste tutorial usam :mod:`doctest` para garantir "
"que funcionam. Como alguns exemplos de código se comportam de forma "
"diferente em Linux, Windows ou macOS, contêm diretivas de doctest nos "
"comentários."

#: ../../library/ctypes.rst:27
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Nota: Alguns exemplos de código referenciam o tipo :class:`c_int` de ctypes. "
"Em plataformas onde ``sizeof(long) == sizeof(int)``, é um alias para :class:"
"`c_long`. Portanto, não deve ficar confuso se :class:`c_long` for impresso "
"quando esperava :class:`c_int` — são, na verdade, o mesmo tipo."

#: ../../library/ctypes.rst:35
msgid "Loading dynamic link libraries"
msgstr "Carregar bibliotecas de ligação dinâmica"

#: ../../library/ctypes.rst:37
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` exporta os objetos *cdll* e, no Windows, *windll* e *oledll*, "
"para carregar bibliotecas de ligação dinâmica."

#: ../../library/ctypes.rst:40
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`HRESULT` error code. The "
"error code is used to automatically raise an :class:`OSError` exception when "
"the function call fails."
msgstr ""

#: ../../library/ctypes.rst:48
msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Os erros do Windows costumavam gerar :exc:`WindowsError`, que agora é um "
"alias de :exc:`OSError`."

#: ../../library/ctypes.rst:53
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""

#: ../../library/ctypes.rst:65
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr ""
"O Windows adiciona automaticamente o sufixo de ficheiro ``.dll`` habitual."

#: ../../library/ctypes.rst:68
msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Aceder à biblioteca C padrão através de ``cdll.msvcrt`` usará uma versão "
"desatualizada da biblioteca que pode ser incompatível com a usada pelo "
"Python. Sempre que possível, use a funcionalidade nativa do Python, ou então "
"importe e use o módulo ``msvcrt``."

#: ../../library/ctypes.rst:73
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""

#: ../../library/ctypes.rst:91
msgid "Accessing functions from loaded dlls"
msgstr "Aceder a funções de bibliotecas carregadas"

#: ../../library/ctypes.rst:93
msgid "Functions are accessed as attributes of dll objects::"
msgstr "As funções são acedidas como atributos de objetos dll:"

#: ../../library/ctypes.rst:107
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""

#: ../../library/ctypes.rst:120
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* não tenta selecionar uma delas por magia, deve aceder à versão que "
"precisa especificando explicitamente ``GetModuleHandleA`` ou "
"``GetModuleHandleW`` e depois chamá-la com objetos bytes ou string, "
"respetivamente."

#: ../../library/ctypes.rst:124
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"Às vezes, as dlls exportam funções com nomes que não são identificadores "
"Python válidos, como ``\"??2@YAPAXI@Z\"``. Neste caso, tem de usar :func:"
"`getattr` para recuperar a função:"

#: ../../library/ctypes.rst:132
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"No Windows, algumas dlls exportam funções não por nome, mas por ordinal. "
"Estas funções podem ser acedidas indexando o objeto dll com o número ordinal:"

#: ../../library/ctypes.rst:149
msgid "Calling functions"
msgstr "Chamar funções"

#: ../../library/ctypes.rst:151
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the "
"Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""

#: ../../library/ctypes.rst:156
msgid ""
"This example calls both functions with a ``NULL`` pointer (``None`` should "
"be used as the ``NULL`` pointer)::"
msgstr ""

#: ../../library/ctypes.rst:165
msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
":exc:`ValueError` é gerado quando chama uma função ``stdcall`` com a "
"convenção de chamada ``cdecl``, ou vice-versa:"

#: ../../library/ctypes.rst:180
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"Para descobrir a convenção de chamada correta, tem de consultar o ficheiro "
"de cabeçalho C ou a documentação da função que deseja chamar."

#: ../../library/ctypes.rst:183
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"No Windows, :mod:`ctypes` usa o tratamento de exceções estruturado win32 "
"para evitar falhas de proteção geral quando funções são chamadas com valores "
"de argumentos inválidos:"

#: ../../library/ctypes.rst:193
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"No entanto, existem formas suficientes de fazer o Python falhar com :mod:"
"`ctypes`, pelo que deve ter cuidado. O módulo :mod:`faulthandler` pode ser "
"útil na depuração de falhas (por exemplo, de falhas de segmentação "
"produzidas por chamadas erradas a bibliotecas C)."

#: ../../library/ctypes.rst:198
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platforms default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""

#: ../../library/ctypes.rst:205
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Antes de avançarmos para chamar funções com outros tipos de parâmetros, "
"temos de aprender mais sobre os tipos de dados :mod:`ctypes`."

#: ../../library/ctypes.rst:212 ../../library/ctypes.rst:2161
msgid "Fundamental data types"
msgstr "Tipos de dados fundamentais"

#: ../../library/ctypes.rst:214
msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ""
":mod:`ctypes` define vários tipos de dados primitivos compatíveis com C:"

#: ../../library/ctypes.rst:217
msgid "ctypes type"
msgstr "tipo ctypes"

#: ../../library/ctypes.rst:217
msgid "C type"
msgstr "tipo C"

#: ../../library/ctypes.rst:217
msgid "Python type"
msgstr "tipo Python"

#: ../../library/ctypes.rst:219
msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

#: ../../library/ctypes.rst:219
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: ../../library/ctypes.rst:219
msgid "bool (1)"
msgstr "bool (1)"

#: ../../library/ctypes.rst:221
msgid ":class:`c_char`"
msgstr ":class:`c_char`"

#: ../../library/ctypes.rst:221 ../../library/ctypes.rst:225
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../library/ctypes.rst:221
msgid "1-character bytes object"
msgstr "objeto bytes de 1 caráter"

#: ../../library/ctypes.rst:223
msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

#: ../../library/ctypes.rst:223
msgid ":c:type:`wchar_t`"
msgstr ":c:type:`wchar_t`"

#: ../../library/ctypes.rst:223
msgid "1-character string"
msgstr "string de 1 caráter"

#: ../../library/ctypes.rst:225
msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

#: ../../library/ctypes.rst:225 ../../library/ctypes.rst:227
#: ../../library/ctypes.rst:229 ../../library/ctypes.rst:231
#: ../../library/ctypes.rst:233 ../../library/ctypes.rst:235
#: ../../library/ctypes.rst:237 ../../library/ctypes.rst:239
#: ../../library/ctypes.rst:241 ../../library/ctypes.rst:243
#: ../../library/ctypes.rst:246 ../../library/ctypes.rst:248
msgid "int"
msgstr "int"

#: ../../library/ctypes.rst:227
msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

#: ../../library/ctypes.rst:227
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../library/ctypes.rst:229
msgid ":class:`c_short`"
msgstr ":class:`c_short`"

#: ../../library/ctypes.rst:229
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../library/ctypes.rst:231
msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

#: ../../library/ctypes.rst:231
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../library/ctypes.rst:233
msgid ":class:`c_int`"
msgstr ":class:`c_int`"

#: ../../library/ctypes.rst:233
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../library/ctypes.rst:235
msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

#: ../../library/ctypes.rst:235
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../library/ctypes.rst:237
msgid ":class:`c_long`"
msgstr ":class:`c_long`"

#: ../../library/ctypes.rst:237
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../library/ctypes.rst:239
msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

#: ../../library/ctypes.rst:239
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../library/ctypes.rst:241
msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

#: ../../library/ctypes.rst:241
msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ":c:expr:`__int64` ou :c:expr:`long long`"

#: ../../library/ctypes.rst:243
msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

#: ../../library/ctypes.rst:243
msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned __int64` ou :c:expr:`unsigned long long`"

#: ../../library/ctypes.rst:246
msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

#: ../../library/ctypes.rst:246
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: ../../library/ctypes.rst:248
msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

#: ../../library/ctypes.rst:248
msgid ":c:type:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ":c:type:`ssize_t` ou :c:expr:`Py_ssize_t`"

#: ../../library/ctypes.rst:251
msgid ":class:`c_float`"
msgstr ":class:`c_float`"

#: ../../library/ctypes.rst:251
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../library/ctypes.rst:251 ../../library/ctypes.rst:253
#: ../../library/ctypes.rst:255
msgid "float"
msgstr "float"

#: ../../library/ctypes.rst:253
msgid ":class:`c_double`"
msgstr ":class:`c_double`"

#: ../../library/ctypes.rst:253
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../library/ctypes.rst:255
msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

#: ../../library/ctypes.rst:255
msgid ":c:expr:`long double`"
msgstr ":c:expr:`long double`"

#: ../../library/ctypes.rst:257
msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

#: ../../library/ctypes.rst:257
msgid ":c:expr:`char *` (NUL terminated)"
msgstr ":c:expr:`char *` (terminado em NUL)"

#: ../../library/ctypes.rst:257
msgid "bytes object or ``None``"
msgstr "objeto bytes ou ``None``"

#: ../../library/ctypes.rst:259
msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

#: ../../library/ctypes.rst:259
msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ":c:expr:`wchar_t *` (terminado em NUL)"

#: ../../library/ctypes.rst:259
msgid "string or ``None``"
msgstr "string ou ``None``"

#: ../../library/ctypes.rst:261
msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

#: ../../library/ctypes.rst:261
msgid ":c:expr:`void *`"
msgstr ":c:expr:`void *`"

#: ../../library/ctypes.rst:261
msgid "int or ``None``"
msgstr "int ou ``None``"

#: ../../library/ctypes.rst:265
msgid "The constructor accepts any object with a truth value."
msgstr "O construtor aceita qualquer objeto com um valor de verdade."

#: ../../library/ctypes.rst:267
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Todos estes tipos podem ser criados chamando-os com um inicializador "
"opcional do tipo e valor corretos:"

#: ../../library/ctypes.rst:278
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""
"Como estes tipos são mutáveis, o seu valor também pode ser alterado "
"posteriormente:"

#: ../../library/ctypes.rst:290
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""

#: ../../library/ctypes.rst:310
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"Deve, no entanto, ter cuidado para não os passar para funções que esperam "
"ponteiros para memória mutável. Se precisar de blocos de memória mutáveis, o "
"ctypes tem uma função :func:`create_string_buffer` que os cria de várias "
"formas. O conteúdo atual do bloco de memória pode ser acedido (ou alterado) "
"com a propriedade ``raw``; se quiser aceder como uma string terminada em "
"NUL, use a propriedade ``value``:"

#: ../../library/ctypes.rst:334
msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:type:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""

#: ../../library/ctypes.rst:343
msgid "Calling functions, continued"
msgstr "Chamar funções (continuação)"

#: ../../library/ctypes.rst:345
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"Note que printf imprime para o canal de saída padrão real, *não* para :data:"
"`sys.stdout`, pelo que estes exemplos só funcionarão no prompt da consola, "
"não a partir do *IDLE* ou *PythonWin*:"

#: ../../library/ctypes.rst:365
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Como foi mencionado anteriormente, todos os tipos Python, exceto inteiros, "
"strings e objetos bytes, têm de ser encapsulados no seu tipo :mod:`ctypes` "
"correspondente, para que possam ser convertidos para o tipo de dados C "
"necessário:"

#: ../../library/ctypes.rst:377
msgid "Calling variadic functions"
msgstr "Chamar funções variádicas"

#: ../../library/ctypes.rst:379
msgid ""
"On a lot of platforms calling variadic functions through ctypes is exactly "
"the same as calling functions with a fixed number of parameters. On some "
"platforms, and in particular ARM64 for Apple Platforms, the calling "
"convention for variadic functions is different than that for regular "
"functions."
msgstr ""
"Em muitas plataformas, chamar funções variádicas através de ctypes é "
"exatamente igual a chamar funções com um número fixo de parâmetros. Em "
"algumas plataformas, e em particular ARM64 para plataformas Apple, a "
"convenção de chamada para funções variádicas é diferente da das funções "
"regulares."

#: ../../library/ctypes.rst:384
msgid ""
"On those platforms it is required to specify the *argtypes* attribute for "
"the regular, non-variadic, function arguments:"
msgstr ""

#: ../../library/ctypes.rst:391
msgid ""
"Because specifying the attribute does not inhibit portability it is advised "
"to always specify ``argtypes`` for all variadic functions."
msgstr ""

#: ../../library/ctypes.rst:398
msgid "Calling functions with your own custom data types"
msgstr "Chamar funções com os seus próprios tipos de dados personalizados"

#: ../../library/ctypes.rst:400
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments. :mod:`ctypes` looks for "
"an :attr:`!_as_parameter_` attribute and uses this as the function argument. "
"The attribute must be an integer, string, bytes, a :mod:`ctypes` instance, "
"or an object with an :attr:`!_as_parameter_` attribute::"
msgstr ""
"Também pode personalizar a conversão de argumentos :mod:`ctypes` para "
"permitir que instâncias das suas próprias classes sejam usadas como "
"argumentos de função. :mod:`ctypes` procura um atributo :attr:`!"
"_as_parameter_` e usa-o como argumento da função. O atributo deve ser um "
"inteiro, string, bytes, uma instância :mod:`ctypes` ou um objeto com um "
"atributo :attr:`!_as_parameter_`::"

#: ../../library/ctypes.rst:416
msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_` "
"instance variable, you could define a :class:`property` which makes the "
"attribute available on request."
msgstr ""

#: ../../library/ctypes.rst:424
msgid "Specifying the required argument types (function prototypes)"
msgstr "Especificar os tipos de argumentos necessários (protótipos de função)"

#: ../../library/ctypes.rst:426
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""

#: ../../library/ctypes.rst:429
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function "
"is probably not a good example here, because it takes a variable number and "
"different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""

#: ../../library/ctypes.rst:440
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"Especificar um formato protege contra tipos de argumentos incompatíveis (tal "
"como um protótipo para uma função C) e tenta converter os argumentos para "
"tipos válidos:"

#: ../../library/ctypes.rst:452
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, bytes, a :mod:`ctypes` instance, or "
"an object with an :attr:`_as_parameter_` attribute."
msgstr ""

#: ../../library/ctypes.rst:466
msgid "Return types"
msgstr "Tipos de retorno"

#: ../../library/ctypes.rst:468
msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""

#: ../../library/ctypes.rst:472
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""

#: ../../library/ctypes.rst:485
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the :attr:"
"`argtypes` attribute, and the second argument will be converted from a "
"single character Python bytes object into a C char::"
msgstr ""

#: ../../library/ctypes.rst:503
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""

#: ../../library/ctypes.rst:526
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` é uma função que chamará a API Windows ``FormatMessage()`` para "
"obter a representação em string de um código de erro e *devolve* uma "
"exceção. ``WinError`` aceita um parâmetro opcional de código de erro; se "
"nenhum for usado, chama :func:`GetLastError` para o obter."

#: ../../library/ctypes.rst:531
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for details."
msgstr ""

#: ../../library/ctypes.rst:538
msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Passar ponteiros (ou: passar parâmetros por referência)"

#: ../../library/ctypes.rst:540
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"Às vezes, uma função de API C espera um *ponteiro* para um tipo de dados "
"como parâmetro, provavelmente para escrever na localização correspondente, "
"ou se os dados forem demasiado grandes para serem passados por valor. Isto "
"também é conhecido como *passar parâmetros por referência*."

#: ../../library/ctypes.rst:544
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` exporta a função :func:`byref`, que é usada para passar "
"parâmetros por referência. O mesmo efeito pode ser alcançado com a função :"
"func:`pointer`, embora :func:`pointer` faça muito mais trabalho, uma vez que "
"constrói um objeto ponteiro real, pelo que é mais rápido usar :func:`byref` "
"se não precisar do objeto ponteiro em Python:"

#: ../../library/ctypes.rst:566
msgid "Structures and unions"
msgstr "Estruturas e uniões"

#: ../../library/ctypes.rst:568
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` must be "
"a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""

#: ../../library/ctypes.rst:573
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"O tipo de campo deve ser um tipo :mod:`ctypes`, como :class:`c_int`, ou "
"qualquer outro tipo derivado de :mod:`ctypes`: estrutura, união, array, "
"ponteiro."

#: ../../library/ctypes.rst:576
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Aqui está um exemplo simples de uma estrutura POINT, que contém dois "
"inteiros chamados *x* e *y*, e também mostra como inicializar uma estrutura "
"no construtor:"

#: ../../library/ctypes.rst:596
msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Pode, no entanto, construir estruturas muito mais complicadas. Uma estrutura "
"pode ela própria conter outras estruturas, usando uma estrutura como tipo de "
"campo."

#: ../../library/ctypes.rst:599
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Aqui está uma estrutura RECT que contém dois POINTs chamados *upperleft* e "
"*lowerright*:"

#: ../../library/ctypes.rst:613
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Estruturas aninhadas também podem ser inicializadas no construtor de várias "
"formas:"

#: ../../library/ctypes.rst:618
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""

#: ../../library/ctypes.rst:632
msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` não suporta passar uniões ou estruturas com campos de bits "
"para funções por valor. Embora isto possa funcionar em x86 de 32 bits, não é "
"garantido pela biblioteca que funcione no caso geral. Uniões e estruturas "
"com campos de bits devem sempre ser passadas para funções por ponteiro."

#: ../../library/ctypes.rst:638
msgid "Structure/union alignment and byte order"
msgstr ""

#: ../../library/ctypes.rst:640
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""

#: ../../library/ctypes.rst:646
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` usa a ordem de bytes nativa para Estruturas e Uniões. Para "
"construir estruturas com ordem de bytes não nativa, pode usar uma das "
"classes base :class:`BigEndianStructure`, :class:`LittleEndianStructure`, :"
"class:`BigEndianUnion` e :class:`LittleEndianUnion`. Estas classes não podem "
"conter campos de ponteiro."

#: ../../library/ctypes.rst:656
msgid "Bit fields in structures and unions"
msgstr "Campos de bits em estruturas e uniões"

#: ../../library/ctypes.rst:658
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""

#: ../../library/ctypes.rst:676
msgid "Arrays"
msgstr "Arrays"

#: ../../library/ctypes.rst:678
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Arrays são sequências que contêm um número fixo de instâncias do mesmo tipo."

#: ../../library/ctypes.rst:680
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"A forma recomendada de criar tipos de array é multiplicando um tipo de dados "
"por um inteiro positivo:"

#: ../../library/ctypes.rst:685
msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Aqui está um exemplo de um tipo de dados algo artificial, uma estrutura que "
"contém 4 POINTs entre outras coisas:"

#: ../../library/ctypes.rst:701
msgid "Instances are created in the usual way, by calling the class::"
msgstr "As instâncias são criadas da forma habitual, chamando a classe:"

#: ../../library/ctypes.rst:707
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"O código acima imprime uma série de linhas ``0 0``, porque o conteúdo do "
"array é inicializado com zeros."

#: ../../library/ctypes.rst:710
msgid "Initializers of the correct type can also be specified::"
msgstr "Inicializadores do tipo correto também podem ser especificados:"

#: ../../library/ctypes.rst:726
msgid "Pointers"
msgstr "Ponteiros"

#: ../../library/ctypes.rst:728
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"Instâncias de ponteiros são criadas chamando a função :func:`pointer` num "
"tipo :mod:`ctypes`:"

#: ../../library/ctypes.rst:736
msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Instâncias de ponteiros têm um atributo :attr:`~_Pointer.contents` que "
"devolve o objeto para o qual o ponteiro aponta, o objeto ``i`` acima:"

#: ../../library/ctypes.rst:743
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Note que :mod:`ctypes` não tem OOR (original object return); constrói um "
"novo objeto equivalente cada vez que recupera um atributo:"

#: ../../library/ctypes.rst:752
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Atribuir outra instância :class:`c_int` ao atributo contents do ponteiro "
"faria com que o ponteiro apontasse para a localização de memória onde esta "
"está armazenada:"

#: ../../library/ctypes.rst:764
msgid "Pointer instances can also be indexed with integers::"
msgstr "Instâncias de ponteiros também podem ser indexadas com inteiros:"

#: ../../library/ctypes.rst:770
msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Atribuir a um índice inteiro altera o valor apontado:"

#: ../../library/ctypes.rst:779
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"Também é possível usar índices diferentes de 0, mas deve saber o que está a "
"fazer, tal como em C: pode aceder ou alterar localizações de memória "
"arbitrárias. Geralmente, só usa esta funcionalidade se receber um ponteiro "
"de uma função C e *saber* que o ponteiro aponta na verdade para um array em "
"vez de um único item."

#: ../../library/ctypes.rst:785
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"Por trás dos panos, a função :func:`pointer` faz mais do que simplesmente "
"criar instâncias de ponteiro; primeiro, tem de criar *tipos* de ponteiro. "
"Isto é feito com a função :func:`POINTER`, que aceita qualquer tipo :mod:"
"`ctypes` e devolve um novo tipo:"

#: ../../library/ctypes.rst:801
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Chamar o tipo de ponteiro sem argumento cria um ponteiro ``NULL``. Ponteiros "
"``NULL`` têm um valor booleano ``False``:"

#: ../../library/ctypes.rst:809
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` verifica ``NULL`` ao desreferenciar ponteiros (mas "
"desreferenciar ponteiros inválidos não-``NULL`` faria o Python falhar):"

#: ../../library/ctypes.rst:828
msgid "Type conversions"
msgstr "Conversões de tipo"

#: ../../library/ctypes.rst:830
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type "
"of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""

#: ../../library/ctypes.rst:851
msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the "
"pointed type (``c_int`` in this case) can be passed to the function.  ctypes "
"will apply the required :func:`byref` conversion in this case automatically."
msgstr ""

#: ../../library/ctypes.rst:856
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"Para definir um campo do tipo POINTER para ``NULL``, pode atribuir ``None``:"

#: ../../library/ctypes.rst:863
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"Às vezes, tem instâncias de tipos incompatíveis. Em C, pode converter um "
"tipo noutro tipo. :mod:`ctypes` fornece uma função :func:`cast` que pode ser "
"usada da mesma forma. A estrutura ``Bar`` definida acima aceita ponteiros "
"``POINTER(c_int)`` ou arrays :class:`c_int` para o seu campo ``values``, mas "
"não instâncias de outros tipos:"

#: ../../library/ctypes.rst:875
msgid "For these cases, the :func:`cast` function is handy."
msgstr "Para estes casos, a função :func:`cast` é útil."

#: ../../library/ctypes.rst:877
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"A função :func:`cast` pode ser usada para converter uma instância ctypes num "
"ponteiro para um tipo de dados ctypes diferente. :func:`cast` recebe dois "
"parâmetros: um objeto ctypes que é ou pode ser convertido num ponteiro de "
"algum tipo, e um tipo de ponteiro ctypes. Devolve uma instância do segundo "
"argumento, que referencia o mesmo bloco de memória que o primeiro argumento:"

#: ../../library/ctypes.rst:888
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Assim, :func:`cast` pode ser usado para atribuir ao campo ``values`` da "
"estrutura ``Bar``:"

#: ../../library/ctypes.rst:901
msgid "Incomplete Types"
msgstr "Tipos Incompletos"

#: ../../library/ctypes.rst:903
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*Tipos Incompletos* são estruturas, uniões ou arrays cujos membros ainda não "
"estão especificados. Em C, são especificados por declarações antecipadas, "
"que são definidas mais tarde:"

#: ../../library/ctypes.rst:914
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr "A tradução direta para código ctypes seria esta, mas não funciona:"

#: ../../library/ctypes.rst:927
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`_fields_` attribute later, after the class statement::"
msgstr ""

#: ../../library/ctypes.rst:939
msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Vamos experimentar. Criamos duas instâncias de ``cell``, fazemos com que "
"apontem uma para a outra e, finalmente, seguimos a cadeia de ponteiros "
"algumas vezes:"

#: ../../library/ctypes.rst:960
msgid "Callback functions"
msgstr "Funções de retorno de chamada"

#: ../../library/ctypes.rst:962
msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` permite criar ponteiros de função chamáveis em C a partir de "
"objetos chamáveis em Python. Estas são por vezes chamadas *funções de "
"retorno de chamada*."

#: ../../library/ctypes.rst:965
msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"Primeiro, deve criar uma classe para a função de retorno de chamada. A "
"classe conhece a convenção de chamada, o tipo de retorno e o número e tipos "
"de argumentos que esta função receberá."

#: ../../library/ctypes.rst:969
msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"A função de fábrica :func:`CFUNCTYPE` cria tipos para funções de retorno de "
"chamada usando a convenção de chamada ``cdecl``. No Windows, a função de "
"fábrica :func:`WINFUNCTYPE` cria tipos para funções de retorno de chamada "
"usando a convenção de chamada ``stdcall``."

#: ../../library/ctypes.rst:974
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Ambas estas funções de fábrica são chamadas com o tipo de resultado como "
"primeiro argumento e os tipos de argumentos esperados pelas funções de "
"retorno de chamada como argumentos restantes."

#: ../../library/ctypes.rst:978
msgid ""
"I will present an example here which uses the standard C library's :c:func:"
"`qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`qsort` will be used to sort an array of integers::"
msgstr ""

#: ../../library/ctypes.rst:988
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""

#: ../../library/ctypes.rst:994
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Assim, a nossa função de retorno de chamada recebe ponteiros para inteiros e "
"deve devolver um inteiro. Primeiro, criamos o ``type`` para a função de "
"retorno de chamada:"

#: ../../library/ctypes.rst:1000
msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"Para começar, aqui está um retorno de chamada simples que mostra os valores "
"que recebe:"

#: ../../library/ctypes.rst:1010
msgid "The result::"
msgstr "O resultado:"

#: ../../library/ctypes.rst:1020
msgid "Now we can actually compare the two items and return a useful result::"
msgstr "Agora podemos comparar os dois itens e devolver um resultado útil:"

#: ../../library/ctypes.rst:1035
msgid "As we can easily check, our array is sorted now::"
msgstr "Como podemos verificar facilmente, o nosso array está agora ordenado:"

#: ../../library/ctypes.rst:1042
msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"As fábricas de funções podem ser usadas como fábricas de decoradores, pelo "
"que também podemos escrever:"

#: ../../library/ctypes.rst:1060
msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Certifique-se de que mantém referências a objetos :func:`CFUNCTYPE` enquanto "
"forem usados a partir de código C. :mod:`ctypes` não o faz, e se não o "
"fizer, podem ser recolhidos pelo garbage collector, fazendo com que o seu "
"programa falhe quando for feito um retorno de chamada."

#: ../../library/ctypes.rst:1064
msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Além disso, note que se a função de retorno de chamada for chamada numa "
"thread criada fora do controlo do Python (por exemplo, pelo código externo "
"que chama o retorno de chamada), o ctypes cria uma nova thread Python "
"fictícia em cada invocação. Este comportamento é correto para a maioria dos "
"fins, mas significa que os valores armazenados com :class:`threading.local` "
"*não* sobreviverão entre diferentes retornos de chamada, mesmo quando essas "
"chamadas são feitas a partir da mesma thread C."

#: ../../library/ctypes.rst:1074
msgid "Accessing values exported from dlls"
msgstr "Aceder a valores exportados de dlls"

#: ../../library/ctypes.rst:1076
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_OptimizeFlag`, an "
"integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` "
"flag given on startup."
msgstr ""

#: ../../library/ctypes.rst:1081
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""

#: ../../library/ctypes.rst:1090
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""

#: ../../library/ctypes.rst:1094
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Um exemplo estendido que também demonstra o uso de ponteiros acede ao "
"ponteiro :c:data:`PyImport_FrozenModules` exportado pelo Python."

#: ../../library/ctypes.rst:1097
msgid "Quoting the docs for that value:"
msgstr "Citando a documentação para esse valor:"

#: ../../library/ctypes.rst:1099
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Este ponteiro é inicializado para apontar para uma array de registos :c:"
"struct:`_frozen`, terminada por um cujos membros são todos ``NULL`` ou zero. "
"Quando um módulo congelado é importado, ele é procurado nesta tabela. Código "
"de terceiros poderia usar isso para fornecer uma coleção criada "
"dinamicamente de módulos congelados."

#: ../../library/ctypes.rst:1104
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Assim, manipular este ponteiro poderia até ser útil. Para restringir o "
"tamanho do exemplo, mostramos apenas como esta tabela pode ser lida com :mod:"
"`ctypes`:"

#: ../../library/ctypes.rst:1118
msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""
"Definimos o tipo de dados :c:struct:`_frozen`, pelo que podemos obter o "
"ponteiro para a tabela:"

#: ../../library/ctypes.rst:1125
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Como ``table`` é um ``pointer`` para o array de registos ``struct_frozen``, "
"podemos iterar sobre ele, mas temos de garantir que o nosso ciclo termina, "
"porque os ponteiros não têm tamanho. Mais cedo ou mais tarde, provavelmente "
"falharia com uma violação de acesso ou algo do género, pelo que é melhor "
"sair do ciclo quando encontrarmos a entrada ``NULL``:"

#: ../../library/ctypes.rst:1141
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"O facto de o Python padrão ter um módulo congelado e um pacote congelado "
"(indicado pelo membro ``size`` negativo) não é muito conhecido, sendo usado "
"apenas para testes. Experimente, por exemplo, com ``import __hello__``."

#: ../../library/ctypes.rst:1149
msgid "Surprises"
msgstr "Surpresas"

#: ../../library/ctypes.rst:1151
msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"Existem alguns aspetos em :mod:`ctypes` onde pode esperar algo diferente "
"daquilo que realmente acontece."

#: ../../library/ctypes.rst:1154
msgid "Consider the following example::"
msgstr "Considere o seguinte exemplo::"

#: ../../library/ctypes.rst:1174
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Hm. Certamente esperávamos que a última instrução imprimisse ``3 4 1 2``. O "
"que aconteceu? Aqui estão os passos da linha ``rc.a, rc.b = rc.b, rc.a`` "
"acima::"

#: ../../library/ctypes.rst:1182
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Note que ``temp0`` e ``temp1`` são objetos que ainda usam o buffer interno "
"do objeto ``rc`` acima. Assim, executar ``rc.a = temp0`` copia o conteúdo do "
"buffer de ``temp0`` para o buffer de ``rc``. Isto, por sua vez, altera o "
"conteúdo de ``temp1``. Portanto, a última atribuição ``rc.b = temp1`` não "
"tem o efeito esperado."

#: ../../library/ctypes.rst:1188
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Tenha em mente que recuperar sub-objetos de Structure, Unions e Arrays não "
"*copia* o sub-objeto, em vez disso, recupera um objeto wrapper que acede ao "
"buffer subjacente do objeto raiz."

#: ../../library/ctypes.rst:1192
msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr ""
"Outro exemplo que pode comportar-se de forma diferente do esperado é este::"

#: ../../library/ctypes.rst:1204
msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"Objetos instanciados a partir de :class:`c_char_p` só podem ter o seu valor "
"definido para bytes ou inteiros."

#: ../../library/ctypes.rst:1207
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"Porque imprime ``False``? As instâncias ctypes são objetos que contêm um "
"bloco de memória e alguns :term:`descritores` que acedem ao conteúdo da "
"memória. Armazenar um objeto Python no bloco de memória não armazena o "
"objeto em si, em vez disso, armazena-se o ``contents`` do objeto. Aceder "
"novamente ao conteúdo constrói um novo objeto Python cada vez!"

#: ../../library/ctypes.rst:1217
msgid "Variable-sized data types"
msgstr "Tipos de dados de tamanho variável"

#: ../../library/ctypes.rst:1219
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` fornece algum suporte para arrays e estruturas de tamanho "
"variável."

#: ../../library/ctypes.rst:1221
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"A função :func:`resize` pode ser usada para redimensionar o buffer de "
"memória de um objeto ctypes existente. A função recebe o objeto como "
"primeiro argumento e o tamanho solicitado em bytes como segundo argumento. O "
"bloco de memória não pode ser tornado mais pequeno do que o bloco de memória "
"natural especificado pelo tipo do objeto; é levantado um :exc:`ValueError` "
"se isto for tentado::"

#: ../../library/ctypes.rst:1241
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Isto é bom, mas como aceder aos elementos adicionais contidos neste array? "
"Como o tipo ainda só conhece 4 elementos, obtemos erros ao aceder a outros "
"elementos::"

#: ../../library/ctypes.rst:1253
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Outra forma de usar tipos de dados de tamanho variável com :mod:`ctypes` é "
"utilizar a natureza dinâmica do Python e (re)definir o tipo de dados depois "
"de o tamanho necessário ser conhecido, caso a caso."

#: ../../library/ctypes.rst:1261
msgid "ctypes reference"
msgstr "Referência de ctypes"

#: ../../library/ctypes.rst:1267
msgid "Finding shared libraries"
msgstr "A localizar bibliotecas partilhadas"

#: ../../library/ctypes.rst:1269
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"Ao programar numa linguagem compilada, as bibliotecas partilhadas são "
"acedidas durante a compilação/ligação de um programa e quando o programa é "
"executado."

#: ../../library/ctypes.rst:1272
msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a "
"way similar to what the compiler or runtime loader does (on platforms with "
"several versions of a shared library the most recent should be loaded), "
"while the ctypes library loaders act like when a program is run, and call "
"the runtime loader directly."
msgstr ""

#: ../../library/ctypes.rst:1278
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""

#: ../../library/ctypes.rst:1286
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Tenta encontrar uma biblioteca e devolve um caminho. *name* é o nome da "
"biblioteca sem qualquer prefixo como *lib*, sufixo como ``.so``, ``.dylib`` "
"ou número de versão (esta é a forma usada para a opção do linker posix :"
"option:`!-l`). Se nenhuma biblioteca for encontrada, devolve ``None``."

#: ../../library/ctypes.rst:1291 ../../library/ctypes.rst:1935
msgid "The exact functionality is system dependent."
msgstr "A funcionalidade exata depende do sistema."

#: ../../library/ctypes.rst:1293
msgid ""
"On Linux, :func:`find_library` tries to run external programs (``/sbin/"
"ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library file. It "
"returns the filename of the library file."
msgstr ""

#: ../../library/ctypes.rst:1297
msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"No Linux, o valor da variável de ambiente ``LD_LIBRARY_PATH`` é usado quando "
"se procura bibliotecas, se uma biblioteca não puder ser encontrada por "
"outros meios."

#: ../../library/ctypes.rst:1301
msgid "Here are some examples::"
msgstr "Aqui estão alguns exemplos::"

#: ../../library/ctypes.rst:1312
msgid ""
"On macOS, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""

#: ../../library/ctypes.rst:1326
msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""

#: ../../library/ctypes.rst:1330
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""

#: ../../library/ctypes.rst:1338
msgid "Loading shared libraries"
msgstr "A carregar bibliotecas partilhadas"

#: ../../library/ctypes.rst:1340
msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Existem várias formas de carregar bibliotecas partilhadas no processo "
"Python. Uma das formas é instanciar uma das seguintes classes:"

#: ../../library/ctypes.rst:1346
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""
"Instâncias desta classe representam bibliotecas partilhadas carregadas. As "
"funções nestas bibliotecas usam a convenção de chamada C padrão e assumem-se "
"que devolvem :c:expr:`int`."

#: ../../library/ctypes.rst:1350
msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"No Windows, a criação de uma instância :class:`CDLL` pode falhar mesmo que o "
"nome da DLL exista. Quando uma DLL dependente da DLL carregada não é "
"encontrada, é levantado um erro :exc:`OSError` com a mensagem *\"[WinError "
"126] The specified module could not be found\".* Esta mensagem de erro não "
"contém o nome da DLL em falta porque a API do Windows não devolve esta "
"informação, tornando este erro difícil de diagnosticar. Para resolver este "
"erro e determinar qual a DLL em falta, é necessário encontrar a lista de "
"DLLs dependentes e determinar qual não foi encontrada usando ferramentas de "
"depuração e rastreio do Windows."

#: ../../library/ctypes.rst:1362
msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"Ferramenta `Microsoft DUMPBIN <https://docs.microsoft.com/cpp/build/"
"reference/dependents>`_ — Uma ferramenta para encontrar dependências de DLL."

#: ../../library/ctypes.rst:1368
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`OSError` is automatically raised."
msgstr ""

#: ../../library/ctypes.rst:1375
msgid ""
":exc:`WindowsError` used to be raised, which is now an alias of :exc:"
"`OSError`."
msgstr ""
":exc:`WindowsError` costumava ser levantado, que agora é um alias de :exc:"
"`OSError`."

#: ../../library/ctypes.rst:1382
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :c:expr:`int` by default."
msgstr ""

#: ../../library/ctypes.rst:1386
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
"A :term:`trava global do intérprete` do Python é libertada antes de chamar "
"qualquer função exportada por estas bibliotecas e readquirida depois."

#: ../../library/ctypes.rst:1392
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Instâncias desta classe comportam-se como instâncias :class:`CDLL`, exceto "
"que a GIL do Python *não* é libertada durante a chamada da função e, após a "
"execução da função, a flag de erro do Python é verificada. Se a flag de erro "
"estiver definida, é levantada uma exceção Python."

#: ../../library/ctypes.rst:1397
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""
"Portanto, isto é útil apenas para chamar diretamente funções da API C do "
"Python."

#: ../../library/ctypes.rst:1399
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or "
"``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""

#: ../../library/ctypes.rst:1406
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"O parâmetro *mode* pode ser usado para especificar como a biblioteca é "
"carregada. Para mais detalhes, consulte a página de manual :manpage:"
"`dlopen(3)`. No Windows, *mode* é ignorado. Em sistemas POSIX, RTLD_NOW é "
"sempre adicionado e não é configurável."

#: ../../library/ctypes.rst:1411
msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""

#: ../../library/ctypes.rst:1418
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"A função :func:`ctypes.get_errno` devolve o valor da cópia privada do "
"ctypes, e a função :func:`ctypes.set_errno` altera a cópia privada do ctypes "
"para um novo valor e devolve o valor anterior."

#: ../../library/ctypes.rst:1422
msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""

#: ../../library/ctypes.rst:1428
msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load to avoiding issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""

#: ../../library/ctypes.rst:1435
msgid "Added *winmode* parameter."
msgstr "Adicionado o parâmetro *winmode*."

#: ../../library/ctypes.rst:1442
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Flag a usar como parâmetro *mode*. Em plataformas onde esta flag não está "
"disponível, é definida como o inteiro zero."

#: ../../library/ctypes.rst:1449
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Flag a usar como parâmetro *mode*. Em plataformas onde esta não está "
"disponível, é o mesmo que *RTLD_GLOBAL*."

#: ../../library/ctypes.rst:1456
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"O modo predefinido usado para carregar bibliotecas partilhadas. No OSX 10.3, "
"este é *RTLD_GLOBAL*, caso contrário é o mesmo que *RTLD_LOCAL*."

#: ../../library/ctypes.rst:1459
msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Instâncias destas classes não têm métodos públicos. As funções exportadas "
"pela biblioteca partilhada podem ser acedidas como atributos ou por índice. "
"Note que aceder à função através de um atributo guarda em cache o resultado "
"e, portanto, aceder repetidamente devolve o mesmo objeto cada vez. Por outro "
"lado, aceder através de um índice devolve um novo objeto cada vez::"

#: ../../library/ctypes.rst:1472
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Os seguintes atributos públicos estão disponíveis; os seus nomes começam com "
"um sublinhado para não conflituar com os nomes das funções exportadas:"

#: ../../library/ctypes.rst:1478
msgid "The system handle used to access the library."
msgstr "O identificador do sistema usado para aceder à biblioteca."

#: ../../library/ctypes.rst:1483
msgid "The name of the library passed in the constructor."
msgstr "O nome da biblioteca passado no construtor."

#: ../../library/ctypes.rst:1485
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""

#: ../../library/ctypes.rst:1493
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Classe que carrega bibliotecas partilhadas. *dlltype* deve ser um dos tipos :"
"class:`CDLL`, :class:`PyDLL`, :class:`WinDLL` ou :class:`OleDLL`."

#: ../../library/ctypes.rst:1496
msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared library "
"by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""

#: ../../library/ctypes.rst:1502
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Carrega uma biblioteca partilhada no processo e devolve-a. Este método "
"devolve sempre uma nova instância da biblioteca."

#: ../../library/ctypes.rst:1506
msgid "These prefabricated library loaders are available:"
msgstr ""
"Os seguintes carregadores de biblioteca pré-fabricados estão disponíveis:"

#: ../../library/ctypes.rst:1511
msgid "Creates :class:`CDLL` instances."
msgstr "Cria instâncias :class:`CDLL`."

#: ../../library/ctypes.rst:1517
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr ""

#: ../../library/ctypes.rst:1523
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr ""

#: ../../library/ctypes.rst:1529
msgid "Creates :class:`PyDLL` instances."
msgstr "Cria instâncias :class:`PyDLL`."

#: ../../library/ctypes.rst:1532
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"Para aceder diretamente à API C do Python, está disponível um objeto de "
"biblioteca partilhada Python pronto a usar:"

#: ../../library/ctypes.rst:1538
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`restype` attribute to use these functions."
msgstr ""

#: ../../library/ctypes.rst:1543
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlopen`` with argument "
"``name``."
msgstr ""

#: ../../library/ctypes.rst:1545
msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Carregar uma biblioteca através de qualquer um destes objetos levanta um "
"evento de auditoria :ref:`auditing <auditing>` ``ctypes.dlopen`` com o "
"argumento string ``name``, o nome usado para carregar a biblioteca."

#: ../../library/ctypes.rst:1549
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym`` with arguments "
"``library``, ``name``."
msgstr ""

#: ../../library/ctypes.rst:1551
msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Aceder a uma função numa biblioteca carregada levanta um evento de auditoria "
"``ctypes.dlsym`` com os argumentos ``library`` (o objeto biblioteca) e "
"``name`` (o nome do símbolo como string ou inteiro)."

#: ../../library/ctypes.rst:1555
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym/handle`` with "
"arguments ``handle``, ``name``."
msgstr ""

#: ../../library/ctypes.rst:1557
msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"Nos casos em que apenas o identificador da biblioteca está disponível em vez "
"do objeto, aceder a uma função levanta um evento de auditoria ``ctypes.dlsym/"
"handle`` com os argumentos ``handle`` (o identificador bruto da biblioteca) "
"e ``name``."

#: ../../library/ctypes.rst:1564
msgid "Foreign functions"
msgstr "Funções externas"

#: ../../library/ctypes.rst:1566
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""

#: ../../library/ctypes.rst:1575
msgid "Base class for C callable foreign functions."
msgstr "Classe base para funções externas chamáveis em C."

#: ../../library/ctypes.rst:1577
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Instâncias de funções externas também são tipos de dados compatíveis com C; "
"representam ponteiros de função C."

#: ../../library/ctypes.rst:1580
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Este comportamento pode ser personalizado atribuindo atributos especiais ao "
"objeto da função externa."

#: ../../library/ctypes.rst:1585
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""
"Atribua um tipo ctypes para especificar o tipo de resultado da função "
"externa. Use ``None`` para :c:expr:`void`, uma função que não devolve nada."

#: ../../library/ctypes.rst:1588
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""

#: ../../library/ctypes.rst:1597
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Atribua um tuplo de tipos ctypes para especificar os tipos de argumentos que "
"a função aceita. Funções que usam a convenção de chamada ``stdcall`` só "
"podem ser chamadas com o mesmo número de argumentos que o comprimento deste "
"tuplo; funções que usam a convenção de chamada C também aceitam argumentos "
"adicionais não especificados."

#: ../../library/ctypes.rst:1603
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""

#: ../../library/ctypes.rst:1610
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows defining "
"adapters that can adapt custom objects as function parameters."
msgstr ""

#: ../../library/ctypes.rst:1617
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Atribua uma função Python ou outro objeto chamável a este atributo. O objeto "
"chamável será chamado com três ou mais argumentos:"

#: ../../library/ctypes.rst:1624
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:"
"`restype` attribute."
msgstr ""

#: ../../library/ctypes.rst:1627
msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* é o próprio objeto da função externa; isto permite reutilizar o mesmo "
"objeto chamável para verificar ou pós-processar os resultados de várias "
"funções."

#: ../../library/ctypes.rst:1631
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*arguments* é um tuplo que contém os parâmetros originalmente passados para "
"a chamada da função; isto permite especializar o comportamento com base nos "
"argumentos usados."

#: ../../library/ctypes.rst:1635
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"O objeto que esta função devolve será devolvido pela chamada da função "
"externa, mas também pode verificar o valor do resultado e levantar uma "
"exceção se a chamada da função externa falhar."

#: ../../library/ctypes.rst:1642
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Esta exceção é levantada quando uma chamada de função externa não consegue "
"converter um dos argumentos passados."

#: ../../library/ctypes.rst:1646
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.seh_exception`` with "
"argument ``code``."
msgstr ""

#: ../../library/ctypes.rst:1648
msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"seh_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""

#: ../../library/ctypes.rst:1654
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.call_function`` with "
"arguments ``func_pointer``, ``arguments``."
msgstr ""

#: ../../library/ctypes.rst:1656
msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""

#: ../../library/ctypes.rst:1662
msgid "Function prototypes"
msgstr "Protótipos de função"

#: ../../library/ctypes.rst:1664
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Funções externas também podem ser criadas instanciando protótipos de função. "
"Os protótipos de função são semelhantes aos protótipos de função em C; "
"descrevem uma função (tipo de retorno, tipos de argumentos, convenção de "
"chamada) sem definir uma implementação. As funções de fábrica devem ser "
"chamadas com o tipo de resultado desejado e os tipos de argumentos da "
"função, e podem ser usadas como fábricas de decoradores, sendo aplicadas a "
"funções através da sintaxe ``@wrapper``. Veja :ref:`ctypes-callback-"
"functions` para exemplos."

#: ../../library/ctypes.rst:1675
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"O protótipo de função devolvido cria funções que usam a convenção de chamada "
"C padrão. A função libertará a GIL durante a chamada. Se *use_errno* estiver "
"definido como verdadeiro, a cópia privada do ctypes da variável do sistema :"
"data:`errno` é trocada com o valor real de :data:`errno` antes e depois da "
"chamada; *use_last_error* faz o mesmo para o código de erro do Windows."

#: ../../library/ctypes.rst:1685
msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention.  The function will release the GIL during "
"the call.  *use_errno* and *use_last_error* have the same meaning as above."
msgstr ""

#: ../../library/ctypes.rst:1693
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"O protótipo de função devolvido cria funções que usam a convenção de chamada "
"Python. A função *não* libertará a GIL durante a chamada."

#: ../../library/ctypes.rst:1696
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Os protótipos de função criados por estas funções de fábrica podem ser "
"instanciados de diferentes formas, dependendo do tipo e número de parâmetros "
"na chamada:"

#: ../../library/ctypes.rst:1703
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Devolve uma função externa no endereço especificado, que deve ser um inteiro."

#: ../../library/ctypes.rst:1710
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Cria uma função chamável em C (uma função de retorno) a partir de um objeto "
"*callable* Python."

#: ../../library/ctypes.rst:1717
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Devolve uma função externa exportada por uma biblioteca partilhada. "
"*func_spec* deve ser um tuplo de 2 elementos ``(name_or_ordinal, library)``. "
"O primeiro item é o nome da função exportada como string, ou o ordinal da "
"função exportada como inteiro pequeno. O segundo item é a instância da "
"biblioteca partilhada."

#: ../../library/ctypes.rst:1727
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Devolve uma função externa que chamará um método COM. *vtbl_index* é o "
"índice na tabela de funções virtuais, um inteiro não negativo pequeno. "
"*name* é o nome do método COM. *iid* é um ponteiro opcional para o "
"identificador da interface, que é usado em relatórios de erro estendidos."

#: ../../library/ctypes.rst:1732
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`!argtypes` tuple."
msgstr ""
"Os métodos COM usam uma convenção de chamada especial: exigem um ponteiro "
"para a interface COM como primeiro argumento, além dos parâmetros "
"especificados no tuplo :attr:`!argtypes`."

#: ../../library/ctypes.rst:1736
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"O parâmetro opcional *paramflags* cria wrappers de funções externas com "
"muito mais funcionalidade do que as características descritas acima."

#: ../../library/ctypes.rst:1739
msgid ""
"*paramflags* must be a tuple of the same length as :attr:`~_FuncPtr."
"argtypes`."
msgstr ""

#: ../../library/ctypes.rst:1741
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Cada item neste tuplo contém mais informações sobre um parâmetro; deve ser "
"um tuplo contendo um, dois ou três itens."

#: ../../library/ctypes.rst:1744
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"O primeiro item é um inteiro contendo uma combinação de flags de direção "
"para o parâmetro:"

#: ../../library/ctypes.rst:1748
msgid "1"
msgstr "1"

#: ../../library/ctypes.rst:1748
msgid "Specifies an input parameter to the function."
msgstr "Especifica um parâmetro de entrada para a função."

#: ../../library/ctypes.rst:1751
msgid "2"
msgstr "2"

#: ../../library/ctypes.rst:1751
msgid "Output parameter.  The foreign function fills in a value."
msgstr "Parâmetro de saída. A função externa preenche um valor."

#: ../../library/ctypes.rst:1754
msgid "4"
msgstr "4"

#: ../../library/ctypes.rst:1754
msgid "Input parameter which defaults to the integer zero."
msgstr "Parâmetro de entrada que, por defeito, é o inteiro zero."

#: ../../library/ctypes.rst:1756
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"O segundo item opcional é o nome do parâmetro como string. Se isto for "
"especificado, a função externa pode ser chamada com parâmetros nomeados."

#: ../../library/ctypes.rst:1759
msgid "The optional third item is the default value for this parameter."
msgstr "O terceiro item opcional é o valor predefinido para este parâmetro."

#: ../../library/ctypes.rst:1762
msgid ""
"The following example demonstrates how to wrap the Windows ``MessageBoxW`` "
"function so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"O exemplo seguinte demonstra como encapsular a função Windows "
"``MessageBoxW`` para que suporte parâmetros predefinidos e argumentos "
"nomeados. A declaração C do ficheiro de cabeçalho do Windows é esta::"

#: ../../library/ctypes.rst:1773 ../../library/ctypes.rst:1796
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "Aqui está o encapsulamento com :mod:`ctypes`::"

#: ../../library/ctypes.rst:1781
msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr ""
"A função externa ``MessageBox`` pode agora ser chamada das seguintes formas::"

#: ../../library/ctypes.rst:1787
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"Um segundo exemplo demonstra parâmetros de saída. A função win32 "
"``GetWindowRect`` obtém as dimensões de uma janela especificada, copiando-as "
"para uma estrutura ``RECT`` que o chamador tem de fornecer. Aqui está a "
"declaração C::"

#: ../../library/ctypes.rst:1805
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Funções com parâmetros de saída devolverão automaticamente o valor do "
"parâmetro de saída se houver apenas um, ou um tuplo contendo os valores dos "
"parâmetros de saída quando houver mais do que um; assim, a função "
"GetWindowRect agora devolve uma instância RECT quando chamada."

#: ../../library/ctypes.rst:1810
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""

#: ../../library/ctypes.rst:1823
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""

#: ../../library/ctypes.rst:1842
msgid "Utility functions"
msgstr "Funções utilitárias"

#: ../../library/ctypes.rst:1846
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"Devolve o endereço do buffer de memória como inteiro. *obj* deve ser uma "
"instância de um tipo ctypes."

#: ../../library/ctypes.rst:1849
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"addressof`` com o argumento ``obj``."

#: ../../library/ctypes.rst:1854
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"Devolve os requisitos de alinhamento de um tipo ctypes. *obj_or_type* deve "
"ser um tipo ou instância ctypes."

#: ../../library/ctypes.rst:1860
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"Devolve um ponteiro leve para *obj*, que deve ser uma instância de um tipo "
"ctypes. *offset* é zero por defeito e deve ser um inteiro que será "
"adicionado ao valor interno do ponteiro."

#: ../../library/ctypes.rst:1864
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` corresponde ao seguinte código C::"

#: ../../library/ctypes.rst:1868
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"O objeto devolvido só pode ser usado como parâmetro de chamada de função "
"externa. Comporta-se de forma semelhante a ``pointer(obj)``, mas a "
"construção é muito mais rápida."

#: ../../library/ctypes.rst:1874
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"Esta função é semelhante ao operador cast em C. Devolve uma nova instância "
"de *type* que aponta para o mesmo bloco de memória que *obj*. *type* deve "
"ser um tipo de ponteiro e *obj* deve ser um objeto que pode ser interpretado "
"como um ponteiro."

#: ../../library/ctypes.rst:1882
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"Esta função cria um buffer de caracteres mutável. O objeto devolvido é um "
"array ctypes de :class:`c_char`."

#: ../../library/ctypes.rst:1885
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""

#: ../../library/ctypes.rst:1888
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""

#: ../../library/ctypes.rst:1893
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"create_string_buffer`` com os argumentos ``init``, ``size``."

#: ../../library/ctypes.rst:1898
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"Esta função cria um buffer de caracteres Unicode mutável. O objeto devolvido "
"é um array ctypes de :class:`c_wchar`."

#: ../../library/ctypes.rst:1901
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""

#: ../../library/ctypes.rst:1904
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""

#: ../../library/ctypes.rst:1910
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"create_unicode_buffer`` com os argumentos ``init``, ``size``."

#: ../../library/ctypes.rst:1915
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""

#: ../../library/ctypes.rst:1922
msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""

#: ../../library/ctypes.rst:1930
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Tenta encontrar uma biblioteca e devolve um caminho. *name* é o nome da "
"biblioteca sem qualquer prefixo como ``lib``, sufixo como ``.so``, ``."
"dylib`` ou número de versão (esta é a forma usada para a opção do linker "
"posix :option:`!-l`). Se nenhuma biblioteca for encontrada, devolve ``None``."

#: ../../library/ctypes.rst:1941
msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""

#: ../../library/ctypes.rst:1945
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"Se precisar de libertar memória, por exemplo, alocada por um módulo de "
"extensão com uma chamada para ``free(void *)``, é importante que utilize a "
"função na mesma biblioteca que alocou a memória."

#: ../../library/ctypes.rst:1952
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""

#: ../../library/ctypes.rst:1959
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows ``GetLastError()`` function "
"directly, it does not return the ctypes-private copy of the error code."
msgstr ""

#: ../../library/ctypes.rst:1965
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"Devolve o valor atual da cópia privada do ctypes da variável do sistema :"
"data:`errno` na thread de chamada."

#: ../../library/ctypes.rst:1968
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"get_errno`` sem argumentos."

#: ../../library/ctypes.rst:1972
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr ""

#: ../../library/ctypes.rst:1975
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"get_last_error`` sem argumentos."

#: ../../library/ctypes.rst:1979
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"Igual à função de biblioteca C padrão memmove: copia *count* bytes de *src* "
"para *dst*. *dst* e *src* devem ser inteiros ou instâncias ctypes que possam "
"ser convertidos em ponteiros."

#: ../../library/ctypes.rst:1986
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"Igual à função de biblioteca C padrão memset: preenche o bloco de memória no "
"endereço *dst* com *count* bytes do valor *c*. *dst* deve ser um inteiro que "
"especifica um endereço ou uma instância ctypes."

#: ../../library/ctypes.rst:1993
msgid ""
"Create and return a new ctypes pointer type. Pointer types are cached and "
"reused internally, so calling this function repeatedly is cheap. *type* must "
"be a ctypes type."
msgstr ""

#: ../../library/ctypes.rst:2000
msgid ""
"Create a new pointer instance, pointing to *obj*. The returned object is of "
"the type ``POINTER(type(obj))``."
msgstr ""
"Cria uma nova instância de ponteiro, apontando para *obj*. O objeto "
"devolvido é do tipo ``POINTER(type(obj))``."

#: ../../library/ctypes.rst:2003
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"Nota: Se apenas pretender passar um ponteiro para um objeto a uma chamada de "
"função externa, deve usar ``byref(obj)``, que é muito mais rápido."

#: ../../library/ctypes.rst:2009
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"Esta função redimensiona o buffer de memória interno de *obj*, que deve ser "
"uma instância de um tipo ctypes. Não é possível tornar o buffer mais pequeno "
"do que o tamanho nativo do tipo do objeto, conforme dado por "
"``sizeof(type(obj))``, mas é possível aumentar o buffer."

#: ../../library/ctypes.rst:2017
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"Define o valor atual da cópia privada do ctypes da variável do sistema :data:"
"`errno` na thread de chamada para *value* e devolve o valor anterior."

#: ../../library/ctypes.rst:2020
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"set_errno`` com o argumento ``errno``."

#: ../../library/ctypes.rst:2025
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""

#: ../../library/ctypes.rst:2029
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes."
"set_last_error`` com o argumento ``error``."

#: ../../library/ctypes.rst:2034
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"Devolve o tamanho em bytes de um tipo ctypes ou buffer de memória de "
"instância. Faz o mesmo que o operador C ``sizeof``."

#: ../../library/ctypes.rst:2040
msgid ""
"This function returns the C string starting at memory address *address* as a "
"bytes object. If size is specified, it is used as size, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""

#: ../../library/ctypes.rst:2044
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``address``, ``size``."
msgstr ""

#: ../../library/ctypes.rst:2049
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of :exc:`OSError`.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""

#: ../../library/ctypes.rst:2055
msgid ""
"An instance of :exc:`WindowsError` used to be created, which is now an alias "
"of :exc:`OSError`."
msgstr ""
"Uma instância de :exc:`WindowsError` costumava ser criada, que agora é um "
"alias de :exc:`OSError`."

#: ../../library/ctypes.rst:2062
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""

#: ../../library/ctypes.rst:2067
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``address``, ``size``."
msgstr ""

#: ../../library/ctypes.rst:2073
msgid "Data types"
msgstr "Tipos de dados"

#: ../../library/ctypes.rst:2078
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"Esta classe não pública é a classe base comum de todos os tipos de dados "
"ctypes. Entre outras coisas, todas as instâncias de tipos ctypes contêm um "
"bloco de memória que mantém dados compatíveis com C; o endereço do bloco de "
"memória é devolvido pela função auxiliar :func:`addressof`. Outra variável "
"de instância é exposta como :attr:`_objects`; esta contém outros objetos "
"Python que precisam de ser mantidos vivos caso o bloco de memória contenha "
"ponteiros."

#: ../../library/ctypes.rst:2085
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"Métodos comuns dos tipos de dados ctypes, estes são todos métodos de classe "
"(para ser exato, são métodos da :term:`metaclasse`):"

#: ../../library/ctypes.rst:2090
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"Este método devolve uma instância ctypes que partilha o buffer do objeto "
"*source*. O objeto *source* deve suportar a interface de buffer gravável. O "
"parâmetro opcional *offset* especifica um deslocamento no buffer de origem "
"em bytes; o valor predefinido é zero. Se o buffer de origem não for grande o "
"suficiente, é levantado um :exc:`ValueError`."

#: ../../library/ctypes.rst:2096 ../../library/ctypes.rst:2106
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"Levanta um evento de auditoria :ref:`auditing <auditing>` ``ctypes.cdata/"
"buffer`` com os argumentos ``pointer``, ``size``, ``offset``."

#: ../../library/ctypes.rst:2100
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"Este método cria uma instância ctypes, copiando o buffer do buffer do objeto "
"*source*, que deve ser legível. O parâmetro opcional *offset* especifica um "
"deslocamento no buffer de origem em bytes; o valor predefinido é zero. Se o "
"buffer de origem não for grande o suficiente, é levantado um :exc:"
"`ValueError`."

#: ../../library/ctypes.rst:2110
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"Este método devolve uma instância de tipo ctypes usando a memória "
"especificada por *address*, que deve ser um inteiro."

#: ../../library/ctypes.rst:2113
msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata`` with argument "
"``address``."
msgstr ""

#: ../../library/ctypes.rst:2115
msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"Este método, e outros que chamam indiretamente este método, levanta um "
"evento de auditoria :ref:`auditing <auditing>` ``ctypes.cdata`` com o "
"argumento ``address``."

#: ../../library/ctypes.rst:2121
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can "
"be used as a function call parameter."
msgstr ""

#: ../../library/ctypes.rst:2126
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"Todos os tipos de dados ctypes têm uma implementação predefinida deste "
"método de classe que normalmente devolve *obj* se este for uma instância do "
"tipo. Alguns tipos aceitam outros objetos também."

#: ../../library/ctypes.rst:2132
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"Este método devolve uma instância de tipo ctypes exportada por uma "
"biblioteca partilhada. *name* é o nome do símbolo que exporta os dados, "
"*library* é a biblioteca partilhada carregada."

#: ../../library/ctypes.rst:2136
msgid "Common instance variables of ctypes data types:"
msgstr "Variáveis de instância comuns dos tipos de dados ctypes:"

#: ../../library/ctypes.rst:2140
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"Às vezes, as instâncias de dados ctypes não são proprietárias do bloco de "
"memória que contêm; em vez disso, partilham parte do bloco de memória de um "
"objeto base. O membro de apenas leitura :attr:`_b_base_` é o objeto ctypes "
"raiz que possui o bloco de memória."

#: ../../library/ctypes.rst:2147
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"Esta variável de apenas leitura é verdadeira quando a instância de dados "
"ctypes alocou ela própria o bloco de memória, falsa caso contrário."

#: ../../library/ctypes.rst:2152
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"Este membro é ``None`` ou um dicionário que contém objetos Python que "
"precisam de ser mantidos vivos para que o conteúdo do bloco de memória "
"permaneça válido. Este objeto é exposto apenas para depuração; nunca "
"modifique o conteúdo deste dicionário."

#: ../../library/ctypes.rst:2165
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"Esta classe não pública é a classe base de todos os tipos de dados "
"fundamentais ctypes. É mencionada aqui porque contém os atributos comuns dos "
"tipos de dados fundamentais ctypes. :class:`_SimpleCData` é uma subclasse "
"de :class:`_CData`, pelo que herda os seus métodos e atributos. Os tipos de "
"dados ctypes que não são e não contêm ponteiros agora podem ser serializados."

#: ../../library/ctypes.rst:2171
msgid "Instances have a single attribute:"
msgstr "As instâncias têm um único atributo:"

#: ../../library/ctypes.rst:2175
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"Este atributo contém o valor real da instância. Para tipos inteiros e "
"ponteiros, é um inteiro; para tipos de caracteres, é um objeto bytes de um "
"único carácter ou uma string; para tipos de ponteiros de caracteres, é um "
"objeto bytes ou uma string Python."

#: ../../library/ctypes.rst:2180
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"Quando o atributo ``value`` é recuperado de uma instância ctypes, "
"normalmente um novo objeto é devolvido cada vez. :mod:`ctypes` *não* "
"implementa o retorno do objeto original; um novo objeto é sempre construído. "
"O mesmo é verdadeiro para todas as outras instâncias de objetos ctypes."

#: ../../library/ctypes.rst:2186
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always "
"receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""

#: ../../library/ctypes.rst:2194
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""

#: ../../library/ctypes.rst:2199
msgid "These are the fundamental ctypes data types:"
msgstr "Estes são os tipos de dados fundamentais ctypes:"

#: ../../library/ctypes.rst:2203
msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`signed char` e interpreta o valor como "
"um inteiro pequeno. O construtor aceita um inicializador inteiro opcional; "
"não é feita verificação de overflow."

#: ../../library/ctypes.rst:2210
msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""
"Representa o tipo de dados C :c:expr:`char` e interpreta o valor como um "
"único carácter. O construtor aceita um inicializador de string opcional; o "
"comprimento da string deve ser exatamente um carácter."

#: ../../library/ctypes.rst:2217
msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""
"Representa o tipo de dados C :c:expr:`char *` quando aponta para uma string "
"terminada por zero. Para um ponteiro de carácter geral que também pode "
"apontar para dados binários, deve ser usado ``POINTER(c_char)``. O "
"construtor aceita um endereço inteiro ou um objeto bytes."

#: ../../library/ctypes.rst:2225
msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representa o tipo de dados C :c:expr:`double`. O construtor aceita um "
"inicializador float opcional."

#: ../../library/ctypes.rst:2231
msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""
"Representa o tipo de dados C :c:expr:`long double`. O construtor aceita um "
"inicializador float opcional. Em plataformas onde ``sizeof(long double) == "
"sizeof(double)``, é um alias para :class:`c_double`."

#: ../../library/ctypes.rst:2237
msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""
"Representa o tipo de dados C :c:expr:`float`. O construtor aceita um "
"inicializador float opcional."

#: ../../library/ctypes.rst:2243
msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""
"Representa o tipo de dados C :c:expr:`signed int`. O construtor aceita um "
"inicializador inteiro opcional; não é feita verificação de overflow. Em "
"plataformas onde ``sizeof(int) == sizeof(long)``, é um alias para :class:"
"`c_long`."

#: ../../library/ctypes.rst:2250
msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""

#: ../../library/ctypes.rst:2256
msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""
"Representa o tipo de dados C 16-bit :c:expr:`signed int`. Normalmente um "
"alias para :class:`c_short`."

#: ../../library/ctypes.rst:2262
msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""
"Representa o tipo de dados C 32-bit :c:expr:`signed int`. Normalmente um "
"alias para :class:`c_int`."

#: ../../library/ctypes.rst:2268
msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""
"Representa o tipo de dados C 64-bit :c:expr:`signed int`. Normalmente um "
"alias para :class:`c_longlong`."

#: ../../library/ctypes.rst:2274
msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`signed long`. O construtor aceita um "
"inicializador inteiro opcional; não é feita verificação de overflow."

#: ../../library/ctypes.rst:2280
msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`signed long long`. O construtor aceita "
"um inicializador inteiro opcional; não é feita verificação de overflow."

#: ../../library/ctypes.rst:2286
msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`signed short`. O construtor aceita um "
"inicializador inteiro opcional; não é feita verificação de overflow."

#: ../../library/ctypes.rst:2292
msgid "Represents the C :c:type:`size_t` datatype."
msgstr "Representa o tipo de dados C :c:type:`size_t`."

#: ../../library/ctypes.rst:2297
msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "Representa o tipo de dados C :c:type:`ssize_t`."

#: ../../library/ctypes.rst:2304
msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`unsigned char` e interpreta o valor "
"como um inteiro pequeno. O construtor aceita um inicializador inteiro "
"opcional; não é feita verificação de overflow."

#: ../../library/ctypes.rst:2311
msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""
"Representa o tipo de dados C :c:expr:`unsigned int`. O construtor aceita um "
"inicializador inteiro opcional; não é feita verificação de overflow. Em "
"plataformas onde ``sizeof(int) == sizeof(long)``, é um alias para :class:"
"`c_ulong`."

#: ../../library/ctypes.rst:2318
msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""

#: ../../library/ctypes.rst:2324
msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""
"Representa o tipo de dados C 16-bit :c:expr:`unsigned int`. Normalmente um "
"alias para :class:`c_ushort`."

#: ../../library/ctypes.rst:2330
msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""
"Representa o tipo de dados C 32-bit :c:expr:`unsigned int`. Normalmente um "
"alias para :class:`c_uint`."

#: ../../library/ctypes.rst:2336
msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""
"Representa o tipo de dados C 64-bit :c:expr:`unsigned int`. Normalmente um "
"alias para :class:`c_ulonglong`."

#: ../../library/ctypes.rst:2342
msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`unsigned long`. O construtor aceita um "
"inicializador inteiro opcional; não é feita verificação de overflow."

#: ../../library/ctypes.rst:2348
msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`unsigned long long`. O construtor "
"aceita um inicializador inteiro opcional; não é feita verificação de "
"overflow."

#: ../../library/ctypes.rst:2354
msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""
"Representa o tipo de dados C :c:expr:`unsigned short`. O construtor aceita "
"um inicializador inteiro opcional; não é feita verificação de overflow."

#: ../../library/ctypes.rst:2360
msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""
"Representa o tipo C :c:expr:`void *`. O valor é representado como um "
"inteiro. O construtor aceita um inicializador inteiro opcional."

#: ../../library/ctypes.rst:2366
msgid ""
"Represents the C :c:type:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""
"Representa o tipo de dados C :c:type:`wchar_t` e interpreta o valor como uma "
"string Unicode de um único carácter. O construtor aceita um inicializador de "
"string opcional; o comprimento da string deve ser exatamente um carácter."

#: ../../library/ctypes.rst:2373
msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""
"Representa o tipo de dados C :c:expr:`wchar_t *`, que deve ser um ponteiro "
"para uma string de caracteres largos terminada por zero. O construtor aceita "
"um endereço inteiro ou uma string."

#: ../../library/ctypes.rst:2380
msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""
"Representa o tipo de dados C :c:expr:`bool` (mais precisamente, :c:expr:"
"`_Bool` do C99). O seu valor pode ser ``True`` ou ``False``, e o construtor "
"aceita qualquer objeto que tenha um valor de verdade."

#: ../../library/ctypes.rst:2387
msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr ""

#: ../../library/ctypes.rst:2393
msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""
"Representa o tipo de dados C :c:expr:`PyObject *`. Chamar isto sem um "
"argumento cria um ponteiro ``NULL`` :c:expr:`PyObject *`."

#: ../../library/ctypes.rst:2396
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific "
"data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or :c:type:"
"`DWORD`.  Some useful structures like :c:type:`MSG` or :c:type:`RECT` are "
"also defined."
msgstr ""

#: ../../library/ctypes.rst:2404
msgid "Structured data types"
msgstr "Tipos de dados estruturados"

#: ../../library/ctypes.rst:2409
msgid "Abstract base class for unions in native byte order."
msgstr "Classe base abstrata para uniões em ordem de bytes nativa."

#: ../../library/ctypes.rst:2414
msgid "Abstract base class for unions in *big endian* byte order."
msgstr "Classe base abstrata para uniões em ordem de bytes *big endian*."

#: ../../library/ctypes.rst:2420
msgid "Abstract base class for unions in *little endian* byte order."
msgstr "Classe base abstrata para uniões em ordem de bytes *little endian*."

#: ../../library/ctypes.rst:2426
msgid "Abstract base class for structures in *big endian* byte order."
msgstr "Classe base abstrata para estruturas em ordem de bytes *big endian*."

#: ../../library/ctypes.rst:2431
msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""
"Classe base abstrata para estruturas em ordem de bytes *little endian*."

#: ../../library/ctypes.rst:2433
msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""
"Estruturas e uniões com ordem de bytes não nativa não podem conter campos de "
"tipo ponteiro ou quaisquer outros tipos de dados que contenham campos de "
"tipo ponteiro."

#: ../../library/ctypes.rst:2439
msgid "Abstract base class for structures in *native* byte order."
msgstr "Classe base abstrata para estruturas em ordem de bytes *nativa*."

#: ../../library/ctypes.rst:2441
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"Os tipos concretos de estruturas e uniões devem ser criados por subclasse de "
"um destes tipos e, pelo menos, definir uma variável de classe :attr:"
"`_fields_`. O :mod:`ctypes` criará :term:`descritores` que permitem ler e "
"escrever os campos através de acessos diretos aos atributos. Estes são os"

#: ../../library/ctypes.rst:2449
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"Uma sequência que define os campos da estrutura. Os itens devem ser 2-tuplos "
"ou 3-tuplos. O primeiro item é o nome do campo; o segundo item especifica o "
"tipo do campo, que pode ser qualquer tipo de dados ctypes."

#: ../../library/ctypes.rst:2453
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"Para campos de tipo inteiro como :class:`c_int`, pode ser fornecido um "
"terceiro item opcional. Deve ser um inteiro positivo pequeno que define a "
"largura em bits do campo."

#: ../../library/ctypes.rst:2457
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"Os nomes dos campos devem ser únicos dentro de uma estrutura ou união. Isto "
"não é verificado; apenas um campo pode ser acedido quando os nomes são "
"repetidos."

#: ../../library/ctypes.rst:2460
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"É possível definir a variável de classe :attr:`_fields_` *depois* da "
"instrução de classe que define a subclasse Structure, o que permite criar "
"tipos de dados que referenciam diretamente ou indiretamente a si mesmos::"

#: ../../library/ctypes.rst:2470
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""

#: ../../library/ctypes.rst:2475
msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""

#: ../../library/ctypes.rst:2482
msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect."
msgstr ""

#: ../../library/ctypes.rst:2489
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"Uma sequência opcional que lista os nomes dos campos sem nome (anónimos). :"
"attr:`_anonymous_` já deve estar definido quando :attr:`_fields_` é "
"atribuído, caso contrário não terá efeito."

#: ../../library/ctypes.rst:2493
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"Os campos listados nesta variável devem ser campos de tipo estrutura ou "
"união. :mod:`ctypes` criará descritores no tipo de estrutura que permitem "
"aceder aos campos aninhados diretamente, sem necessidade de criar o campo de "
"estrutura ou união."

#: ../../library/ctypes.rst:2498
msgid "Here is an example type (Windows)::"
msgstr "Aqui está um exemplo de tipo (Windows)::"

#: ../../library/ctypes.rst:2511
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"A estrutura ``TYPEDESC`` descreve um tipo de dados COM; o campo ``vt`` "
"especifica qual dos campos da união é válido. Como o campo ``u`` está "
"definido como campo anónimo, é agora possível aceder aos membros diretamente "
"a partir da instância TYPEDESC. ``td.lptdesc`` e ``td.u.lptdesc`` são "
"equivalentes, mas o primeiro é mais rápido, uma vez que não precisa de criar "
"uma instância temporária da união::"

#: ../../library/ctypes.rst:2523
msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"É possível definir sub-subclasses de estruturas; estas herdam os campos da "
"classe base. Se a definição da subclasse tiver uma variável :attr:`_fields_` "
"separada, os campos especificados nesta são adicionados aos campos da classe "
"base."

#: ../../library/ctypes.rst:2528
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"Os construtores de estruturas e uniões aceitam argumentos posicionais e de "
"palavra-chave. Os argumentos posicionais são usados para inicializar os "
"campos membros pela mesma ordem em que aparecem em :attr:`_fields_`. Os "
"argumentos de palavra-chave no construtor são interpretados como atribuições "
"de atributos, pelo que inicializarão :attr:`_fields_` com o mesmo nome ou "
"criarão novos atributos para nomes não presentes em :attr:`_fields_`."

#: ../../library/ctypes.rst:2539
msgid "Arrays and pointers"
msgstr "Arrays e ponteiros"

#: ../../library/ctypes.rst:2543
msgid "Abstract base class for arrays."
msgstr "Classe base abstrata para arrays."

#: ../../library/ctypes.rst:2545
msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"A forma recomendada de criar tipos de array concretos é multiplicando "
"qualquer tipo de dados :mod:`ctypes` por um inteiro não negativo. "
"Alternativamente, pode criar uma subclasse deste tipo e definir as variáveis "
"de classe :attr:`_length_` e :attr:`_type_`. Os elementos do array podem ser "
"lidos e escritos usando acessos de subscrito e fatia padrão; para leituras "
"de fatia, o objeto resultante *não* é ele próprio um :class:`Array`."

#: ../../library/ctypes.rst:2555
msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"Um inteiro positivo que especifica o número de elementos no array. "
"Subscritos fora do intervalo resultam num :exc:`IndexError`. Será devolvido "
"por :func:`len`."

#: ../../library/ctypes.rst:2562
msgid "Specifies the type of each element in the array."
msgstr "Especifica o tipo de cada elemento no array."

#: ../../library/ctypes.rst:2565
msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"Os construtores de subclasses de array aceitam argumentos posicionais, "
"usados para inicializar os elementos por ordem."

#: ../../library/ctypes.rst:2571
msgid "Private, abstract base class for pointers."
msgstr "Classe base abstrata privada para ponteiros."

#: ../../library/ctypes.rst:2573
msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"Os tipos de ponteiros concretos são criados chamando :func:`POINTER` com o "
"tipo que será apontado; isto é feito automaticamente por :func:`pointer`."

#: ../../library/ctypes.rst:2577
msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"Se um ponteiro apontar para um array, os seus elementos podem ser lidos e "
"escritos usando acessos de subscrito e fatia padrão. Os objetos ponteiro não "
"têm tamanho, pelo que :func:`len` levantará um :exc:`TypeError`. Subscritos "
"negativos lerão da memória *antes* do ponteiro (como em C), e subscritos "
"fora do intervalo provavelmente causarão uma violação de acesso (se tiver "
"sorte)."

#: ../../library/ctypes.rst:2587
msgid "Specifies the type pointed to."
msgstr "Especifica o tipo apontado."

#: ../../library/ctypes.rst:2591
msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"Devolve o objeto para o qual o ponteiro aponta. Atribuir a este atributo "
"altera o ponteiro para apontar para o objeto atribuído."
