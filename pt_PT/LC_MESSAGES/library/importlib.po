# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-23 14:20+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- A implementação de :keyword:`!import`"

#: ../../library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/__init__.py`"

#: ../../library/importlib.rst:18
msgid "Introduction"
msgstr "Introdução"

#: ../../library/importlib.rst:20
msgid "The purpose of the :mod:`importlib` package is three-fold."
msgstr "O propósito do pacote :mod:`importlib` é triplo."

#: ../../library/importlib.rst:22
msgid ""
"One is to provide the implementation of the :keyword:`import` statement (and "
"thus, by extension, the :func:`__import__` function) in Python source code. "
"This provides an implementation of :keyword:`!import` which is portable to "
"any Python interpreter. This also provides an implementation which is easier "
"to comprehend than one implemented in a programming language other than "
"Python."
msgstr ""
"Um é fornecer a implementação da instrução :keyword:`import` (e, por "
"extensão, da função :func:`__import__`) em código-fonte Python. Isto fornece "
"uma implementação de :keyword:`!import` que é portátil para qualquer "
"interpretador Python. Também fornece uma implementação que é mais fácil de "
"compreender do que uma implementada noutra linguagem de programação que não "
"Python."

#: ../../library/importlib.rst:29
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"Dois, os componentes para implementar :keyword:`import` estão expostos neste "
"pacote, facilitando aos utilizadores a criação dos seus próprios objetos "
"personalizados (conhecidos genericamente como :term:`importer`) para "
"participar no processo de importação."

#: ../../library/importlib.rst:33
msgid ""
"Three, the package contains modules exposing additional functionality for "
"managing aspects of Python packages:"
msgstr ""
"Três, o pacote contém módulos que expõem funcionalidades adicionais para "
"gerir aspetos dos pacotes Python:"

#: ../../library/importlib.rst:36
msgid ""
":mod:`importlib.metadata` presents access to metadata from third-party "
"distributions."
msgstr ""
":mod:`importlib.metadata` fornece acesso a metadados de distribuições de "
"terceiros."

#: ../../library/importlib.rst:38
msgid ""
":mod:`importlib.resources` provides routines for accessing non-code "
"\"resources\" from Python packages."
msgstr ""
":mod:`importlib.resources` fornece rotinas para aceder a \"recursos\" não-"
"código de pacotes Python."

#: ../../library/importlib.rst:43
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: ../../library/importlib.rst:44
msgid "The language reference for the :keyword:`import` statement."
msgstr "A referência da linguagem para a instrução :keyword:`import`."

#: ../../library/importlib.rst:46
msgid ""
"`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr ""
"`Especificação de pacotes <https://www.python.org/doc/essays/packages/>`__"

#: ../../library/importlib.rst:47
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""
"Especificação original de pacotes. Algumas semânticas foram alteradas desde "
"a escrita deste documento (por exemplo, redirecionamento baseado em ``None`` "
"em :data:`sys.modules`)."

#: ../../library/importlib.rst:51
msgid "The :func:`.__import__` function"
msgstr "A função :func:`.__import__`"

#: ../../library/importlib.rst:52
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr "A instrução :keyword:`import` é açúcar sintático para esta função."

#: ../../library/importlib.rst:54
msgid ":ref:`sys-path-init`"
msgstr ":ref:`sys-path-init`"

#: ../../library/importlib.rst:55
msgid "The initialization of :data:`sys.path`."
msgstr "A inicialização de :data:`sys.path`."

#: ../../library/importlib.rst:57
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: ../../library/importlib.rst:58
msgid "Import on Case-Insensitive Platforms"
msgstr "Importação em plataformas insensíveis a maiúsculas/minúsculas"

#: ../../library/importlib.rst:60
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: ../../library/importlib.rst:61
msgid "Defining Python Source Code Encodings"
msgstr "Definir codificações de código-fonte Python"

#: ../../library/importlib.rst:63
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../library/importlib.rst:64
msgid "New Import Hooks"
msgstr "Novos ganchos de importação"

#: ../../library/importlib.rst:66
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: ../../library/importlib.rst:67
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "Importações: Multi-linha e absolutas/relativas"

#: ../../library/importlib.rst:69
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: ../../library/importlib.rst:70
msgid "Main module explicit relative imports"
msgstr "Importações relativas explícitas no módulo principal"

#: ../../library/importlib.rst:72
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: ../../library/importlib.rst:73
msgid "Implicit namespace packages"
msgstr "Pacotes de namespace implícitos"

#: ../../library/importlib.rst:75
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: ../../library/importlib.rst:76
msgid "A ModuleSpec Type for the Import System"
msgstr "Um tipo ModuleSpec para o sistema de importação"

#: ../../library/importlib.rst:78
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: ../../library/importlib.rst:79
msgid "Elimination of PYO files"
msgstr "Eliminação de ficheiros PYO"

#: ../../library/importlib.rst:81
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: ../../library/importlib.rst:82
msgid "Multi-phase extension module initialization"
msgstr "Inicialização de módulos de extensão em várias fases"

#: ../../library/importlib.rst:84
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: ../../library/importlib.rst:85
msgid "Deterministic pycs"
msgstr "Ficheiros pyc determinísticos"

#: ../../library/importlib.rst:87
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: ../../library/importlib.rst:88
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "Utilizar UTF-8 como codificação de origem padrão"

#: ../../library/importlib.rst:90
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: ../../library/importlib.rst:91
msgid "PYC Repository Directories"
msgstr "Diretórios de repositório PYC"

#: ../../library/importlib.rst:95
msgid "Functions"
msgstr "Funções"

#: ../../library/importlib.rst:99
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "Uma implementação da função integrada :func:`__import__`."

#: ../../library/importlib.rst:102
msgid ""
"Programmatic importing of modules should use :func:`import_module` instead "
"of this function."
msgstr ""
"A importação programática de módulos deve usar :func:`import_module` em vez "
"desta função."

#: ../../library/importlib.rst:107
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""
"Importa um módulo. O argumento *name* especifica que módulo importar em "
"termos absolutos ou relativos (por exemplo, ``pkg.mod`` ou ``..mod``). Se o "
"nome for especificado em termos relativos, então o argumento *package* deve "
"ser definido para o nome do pacote que servirá como âncora para resolver o "
"nome do pacote (por exemplo, ``import_module('..mod', 'pkg.subpkg')`` "
"importará ``pkg.mod``)."

#: ../../library/importlib.rst:115
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`. The most important difference "
"between these two functions is that :func:`import_module` returns the "
"specified package or module (e.g. ``pkg.mod``), while :func:`__import__` "
"returns the top-level package or module (e.g. ``pkg``)."
msgstr ""
"A função :func:`import_module` atua como um invólucro simplificador em torno "
"de :func:`importlib.__import__`. Isto significa que todas as semânticas da "
"função são derivadas de :func:`importlib.__import__`. A diferença mais "
"importante entre estas duas funções é que :func:`import_module` devolve o "
"pacote ou módulo especificado (por exemplo, ``pkg.mod``), enquanto :func:"
"`__import__` devolve o pacote ou módulo de nível superior (por exemplo, "
"``pkg``)."

#: ../../library/importlib.rst:122
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may "
"need to call :func:`invalidate_caches` in order for the new module to be "
"noticed by the import system."
msgstr ""
"Se estiver a importar dinamicamente um módulo que foi criado desde que o "
"interpretador iniciou a execução (por exemplo, criou um ficheiro de código "
"Python), poderá ser necessário chamar :func:`invalidate_caches` para que o "
"novo módulo seja notado pelo sistema de importação."

#: ../../library/importlib.rst:127
msgid "Parent packages are automatically imported."
msgstr "Os pacotes pai são importados automaticamente."

#: ../../library/importlib.rst:132
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""
"Invalidar as caches internas dos *finders* armazenadas em :data:`sys."
"meta_path`. Se um *finder* implementar ``invalidate_caches()``, este será "
"chamado para realizar a invalidação. Esta função deve ser chamada se algum "
"módulo for criado/instalado enquanto o seu programa estiver a correr, para "
"garantir que todos os *finders* notam a existência do novo módulo."

#: ../../library/importlib.rst:140
msgid ""
"Namespace packages created/installed in a different :data:`sys.path` "
"location after the same namespace was already imported are noticed."
msgstr ""
"Pacotes de namespace criados/instalados numa localização diferente de :data:"
"`sys.path` após o mesmo namespace já ter sido importado são notados."

#: ../../library/importlib.rst:146
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (which can be different if re-importing "
"causes a different object to be placed in :data:`sys.modules`)."
msgstr ""
"Recarrega um *módulo* previamente importado. O argumento deve ser um objeto "
"módulo, pelo que deve ter sido importado com sucesso anteriormente. Isto é "
"útil se editou o ficheiro de origem do módulo usando um editor externo e "
"pretende experimentar a nova versão sem sair do interpretador Python. O "
"valor de retorno é o objeto módulo (que pode ser diferente se a reimportação "
"colocar um objeto diferente em :data:`sys.modules`)."

#: ../../library/importlib.rst:153
msgid "When :func:`reload` is executed:"
msgstr "Quando :func:`reload` é executado:"

#: ../../library/importlib.rst:155
msgid ""
"Python module's code is recompiled and the module-level code re-executed, "
"defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a second "
"time."
msgstr ""
"O código do módulo Python é recompilado e o código ao nível do módulo é "
"reexecutado, definindo um novo conjunto de objetos que são associados a "
"nomes no dicionário do módulo, reutilizando o :term:`loader` que "
"originalmente carregou o módulo. A função ``init`` de módulos de extensão "
"não é chamada uma segunda vez."

#: ../../library/importlib.rst:161
msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Como com todos os outros objetos em Python, os objetos antigos só são "
"recuperados após as suas contagens de referência chegarem a zero."

#: ../../library/importlib.rst:164
msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Os nomes no espaço de nomes do módulo são atualizados para apontar para "
"quaisquer novos objetos ou objetos alterados."

#: ../../library/importlib.rst:167
msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Outras referências aos objetos antigos (como nomes externos ao módulo) não "
"são reassociadas para referir os novos objetos e devem ser atualizadas em "
"cada espaço de nomes onde ocorrem, se assim for desejado."

#: ../../library/importlib.rst:171
msgid "There are a number of other caveats:"
msgstr "Existem várias outras advertências:"

#: ../../library/importlib.rst:173
msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Quando um módulo é recarregado, o seu dicionário (que contém as variáveis "
"globais do módulo) é retido. Redefinições de nomes substituirão as "
"definições antigas, pelo que isto geralmente não é um problema. Se a nova "
"versão de um módulo não definir um nome que foi definido pela versão antiga, "
"a definição antiga permanece. Esta funcionalidade pode ser usada em vantagem "
"do módulo se este mantiver uma tabela global ou cache de objetos — com uma "
"instrução :keyword:`try`, pode testar a presença da tabela e ignorar a sua "
"inicialização, se desejado::"

#: ../../library/importlib.rst:182
msgid ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"
msgstr ""
"try:\n"
"    cache\n"
"except NameError:\n"
"    cache = {}"

#: ../../library/importlib.rst:187
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and other "
"key modules is not recommended.  In many cases extension modules are not "
"designed to be initialized more than once, and may fail in arbitrary ways "
"when reloaded."
msgstr ""
"Geralmente, não é muito útil recarregar módulos integrados ou carregados "
"dinamicamente. Não é recomendado recarregar :mod:`sys`, :mod:`__main__`, :"
"mod:`builtins` e outros módulos-chave. Em muitos casos, os módulos de "
"extensão não são concebidos para serem inicializados mais do que uma vez e "
"podem falhar de formas arbitrárias quando recarregados."

#: ../../library/importlib.rst:193
msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module.name*) instead."
msgstr ""
"Se um módulo importa objetos de outro módulo usando :keyword:`from` ... :"
"keyword:`import` ..., chamar :func:`reload` para o outro módulo não redefine "
"os objetos importados dele — uma forma de contornar isto é reexecutar a "
"instrução :keyword:`!from`, outra é usar :keyword:`!import` e nomes "
"qualificados (*module.name*) em vez disso."

#: ../../library/importlib.rst:199
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Se um módulo instancia instâncias de uma classe, recarregar o módulo que "
"define a classe não afeta as definições de métodos das instâncias — estas "
"continuam a usar a definição antiga da classe. O mesmo é verdadeiro para "
"classes derivadas."

#: ../../library/importlib.rst:205
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks a :"
"class:`~importlib.machinery.ModuleSpec`."
msgstr ""
":exc:`ModuleNotFoundError` é levantado quando o módulo a ser recarregado não "
"tem um :class:`~importlib.machinery.ModuleSpec`."

#: ../../library/importlib.rst:210
msgid ""
"This function is not thread-safe. Calling it from multiple threads can "
"result in unexpected behavior. It's recommended to use the :class:`threading."
"Lock` or other synchronization primitives for thread-safe module reloading."
msgstr ""
"Esta função não é segura para threads. Chamá-la a partir de múltiplos "
"threads pode resultar em comportamento inesperado. É recomendado usar :class:"
"`threading.Lock` ou outras primitivas de sincronização para recarregar "
"módulos de forma segura para threads."

#: ../../library/importlib.rst:215
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ""
":mod:`importlib.abc` — Classes base abstratas relacionadas com importação"

#: ../../library/importlib.rst:220
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/abc.py`"

#: ../../library/importlib.rst:225
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""
"O módulo :mod:`importlib.abc` contém todas as classes base abstratas "
"principais usadas por :keyword:`import`. Algumas subclasses das classes base "
"abstratas principais também são fornecidas para ajudar na implementação das "
"ABCs principais."

#: ../../library/importlib.rst:229
msgid "ABC hierarchy::"
msgstr "Hierarquia de ABCs::"

#: ../../library/importlib.rst:231
msgid ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"
msgstr ""
"object\n"
" +-- MetaPathFinder\n"
" +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader"

#: ../../library/importlib.rst:244
msgid "An abstract base class representing a :term:`meta path finder`."
msgstr "Uma classe base abstrata que representa um :term:`meta path finder`."

#: ../../library/importlib.rst:248 ../../library/importlib.rst:284
msgid "No longer a subclass of :class:`!Finder`."
msgstr "Já não é uma subclasse de :class:`!Finder`."

#: ../../library/importlib.rst:253
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be ``None``.  "
"Otherwise, this is a search for a subpackage or module and *path* will be "
"the value of :attr:`~module.__path__` from the parent package. If a spec "
"cannot be found, ``None`` is returned. When passed in, ``target`` is a "
"module object that the finder may use to make a more educated guess about "
"what spec to return. :func:`importlib.util.spec_from_loader` may be useful "
"for implementing concrete ``MetaPathFinders``."
msgstr ""
"Um método abstrato para encontrar uma :term:`especificação <module spec>` "
"para o módulo especificado. Se esta for uma importação de nível superior, "
"*path* será ``None``. Caso contrário, esta é uma pesquisa por um subpacote "
"ou módulo e *path* será o valor de :attr:`~module.__path__` do pacote pai. "
"Se uma especificação não puder ser encontrada, ``None`` é retornado. Quando "
"passado, ``target`` é um objeto módulo que o *finder* pode usar para fazer "
"uma suposição mais informada sobre que especificação retornar. :func:"
"`importlib.util.spec_from_loader` pode ser útil para implementar "
"``MetaPathFinders`` concretos."

#: ../../library/importlib.rst:267
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"Um método opcional que, quando chamado, deve invalidar qualquer cache "
"interna usada pelo *finder*. Usado por :func:`importlib.invalidate_caches` "
"ao invalidar as caches de todos os *finders* em :data:`sys.meta_path`."

#: ../../library/importlib.rst:271
msgid "Returns ``None`` when called instead of :data:`NotImplemented`."
msgstr "Retorna ``None`` quando chamado em vez de :data:`NotImplemented`."

#: ../../library/importlib.rst:277
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`importlib.machinery.PathFinder`."
msgstr ""
"Uma classe base abstrata que representa um :term:`path entry finder`. Embora "
"tenha algumas semelhanças com :class:`MetaPathFinder`, ``PathEntryFinder`` é "
"destinado a ser usado apenas no subsistema de importação baseado em caminho "
"fornecido por :class:`importlib.machinery.PathFinder`."

#: ../../library/importlib.rst:289
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the :"
"term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that "
"the finder may use to make a more educated guess about what spec to return. :"
"func:`importlib.util.spec_from_loader` may be useful for implementing "
"concrete ``PathEntryFinders``."
msgstr ""
"Um método abstrato para encontrar uma :term:`especificação <module spec>` "
"para o módulo especificado. O *finder* pesquisará o módulo apenas dentro da :"
"term:`entrada de caminho` a que está atribuído. Se uma especificação não "
"puder ser encontrada, ``None`` é retornado. Quando passado, ``target`` é um "
"objeto módulo que o *finder* pode usar para fazer uma suposição mais "
"informada sobre que especificação retornar. :func:`importlib.util."
"spec_from_loader` pode ser útil para implementar ``PathEntryFinders`` "
"concretos."

#: ../../library/importlib.rst:301
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`importlib.machinery.PathFinder."
"invalidate_caches` when invalidating the caches of all cached finders."
msgstr ""
"Um método opcional que, quando chamado, deve invalidar qualquer cache "
"interna usada pelo *finder*. Usado por :meth:`importlib.machinery.PathFinder."
"invalidate_caches` ao invalidar as caches de todos os *finders* em cache."

#: ../../library/importlib.rst:309
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""
"Uma classe base abstrata para um :term:`loader`. Consulte :pep:`302` para a "
"definição exata de um *loader*."

#: ../../library/importlib.rst:312
msgid ""
"Loaders that wish to support resource reading should implement a :meth:"
"`get_resource_reader` method as specified by :class:`importlib.resources.abc."
"ResourceReader`."
msgstr ""
"Os *loaders* que pretendem suportar a leitura de recursos devem implementar "
"um método :meth:`get_resource_reader` conforme especificado por :class:"
"`importlib.resources.abc.ResourceReader`."

#: ../../library/importlib.rst:316
msgid "Introduced the optional :meth:`get_resource_reader` method."
msgstr "Introduziu o método opcional :meth:`get_resource_reader`."

#: ../../library/importlib.rst:321
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"Um método que retorna o objeto módulo a usar ao importar um módulo. Este "
"método pode retornar ``None``, indicando que as semânticas de criação de "
"módulo predefinidas devem ser aplicadas."

#: ../../library/importlib.rst:327
msgid "This method is no longer optional when :meth:`exec_module` is defined."
msgstr ""
"Este método já não é opcional quando :meth:`exec_module` está definido."

#: ../../library/importlib.rst:333
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized "
"when :meth:`exec_module` is called.  When this method exists, :meth:"
"`create_module` must be defined."
msgstr ""
"Um método abstrato que executa o módulo no seu próprio espaço de nomes "
"quando um módulo é importado ou recarregado. O módulo deve já estar "
"inicializado quando :meth:`exec_module` é chamado. Quando este método "
"existe, :meth:`create_module` deve ser definido."

#: ../../library/importlib.rst:340
msgid ":meth:`create_module` must also be defined."
msgstr ":meth:`create_module` também deve ser definido."

#: ../../library/importlib.rst:345
msgid ""
"A legacy method for loading a module.  If the module cannot be loaded, :exc:"
"`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"Um método legado para carregar um módulo. Se o módulo não puder ser "
"carregado, :exc:`ImportError` é levantado, caso contrário, o módulo "
"carregado é retornado."

#: ../../library/importlib.rst:349
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import.  If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone."
msgstr ""
"Se o módulo solicitado já existir em :data:`sys.modules`, esse módulo deve "
"ser usado e recarregado. Caso contrário, o *loader* deve criar um novo "
"módulo e inseri-lo em :data:`sys.modules` antes de qualquer carregamento "
"começar, para evitar recursão da importação. Se o *loader* inseriu um módulo "
"e o carregamento falhar, este deve ser removido pelo *loader* de :data:`sys."
"modules`; os módulos já em :data:`sys.modules` antes do início da execução "
"do *loader* devem ser deixados como estão."

#: ../../library/importlib.rst:358
msgid ""
"The loader should set several attributes on the module (note that some of "
"these attributes can change when a module is reloaded):"
msgstr ""
"O *loader* deve definir vários atributos no módulo (note que alguns destes "
"atributos podem mudar quando um módulo é recarregado):"

#: ../../library/importlib.rst:362
msgid ":attr:`module.__name__`"
msgstr ":attr:`module.__name__`"

#: ../../library/importlib.rst:363
msgid ":attr:`module.__file__`"
msgstr ":attr:`module.__file__`"

#: ../../library/importlib.rst:364
msgid ":attr:`module.__cached__` *(deprecated)*"
msgstr ":attr:`module.__cached__` *(obsoleto)*"

#: ../../library/importlib.rst:365
msgid ":attr:`module.__path__`"
msgstr ":attr:`module.__path__`"

#: ../../library/importlib.rst:366
msgid ":attr:`module.__package__` *(deprecated)*"
msgstr ":attr:`module.__package__` *(obsoleto)*"

#: ../../library/importlib.rst:367
msgid ":attr:`module.__loader__` *(deprecated)*"
msgstr ":attr:`module.__loader__` *(obsoleto)*"

#: ../../library/importlib.rst:369
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ""
"Quando :meth:`exec_module` está disponível, a funcionalidade retrocompatível "
"é fornecida."

#: ../../library/importlib.rst:372
msgid ""
"Raise :exc:`ImportError` when called instead of :exc:`NotImplementedError`.  "
"Functionality provided when :meth:`exec_module` is available."
msgstr ""
"Levanta :exc:`ImportError` quando chamado em vez de :exc:"
"`NotImplementedError`. Funcionalidade fornecida quando :meth:`exec_module` "
"está disponível."

#: ../../library/importlib.rst:377
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and :meth:"
"`create_module`).  Loaders should implement it instead of :meth:"
"`load_module`.  The import machinery takes care of all the other "
"responsibilities of :meth:`load_module` when :meth:`exec_module` is "
"implemented."
msgstr ""
"A API recomendada para carregar um módulo é :meth:`exec_module` (e :meth:"
"`create_module`). Os *loaders* devem implementá-la em vez de :meth:"
"`load_module`. A maquinaria de importação trata de todas as outras "
"responsabilidades de :meth:`load_module` quando :meth:`exec_module` é "
"implementado."

#: ../../library/importlib.rst:387
msgid "*Superseded by TraversableResources*"
msgstr "*Substituído por TraversableResources*"

#: ../../library/importlib.rst:389
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"Uma classe base abstrata para um :term:`loader` que implementa o protocolo "
"opcional :pep:`302` para carregar recursos arbitrários do backend de "
"armazenamento."

#: ../../library/importlib.rst:393
msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.resources.abc.TraversableResources`. This class exists for "
"backwards compatibility only with other ABCs in this module."
msgstr ""
"Esta ABC está obsoleta em favor do suporte ao carregamento de recursos "
"através de :class:`importlib.resources.abc.TraversableResources`. Esta "
"classe existe apenas para retrocompatibilidade com outras ABCs neste módulo."

#: ../../library/importlib.rst:402
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`~module."
"__file__` attribute or an item from a package's :attr:`~module.__path__`."
msgstr ""
"Um método abstrato para retornar os bytes dos dados localizados em *path*. "
"Os *loaders* que têm um backend de armazenamento tipo ficheiro que permite "
"armazenar dados arbitrários podem implementar este método abstrato para dar "
"acesso direto aos dados armazenados. :exc:`OSError` deve ser levantado se o "
"*path* não puder ser encontrado. Espera-se que o *path* seja construído "
"usando o atributo :attr:`~module.__file__` de um módulo ou um item de :attr:"
"`~module.__path__` de um pacote."

#: ../../library/importlib.rst:411
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Levanta :exc:`OSError` em vez de :exc:`NotImplementedError`."

#: ../../library/importlib.rst:417
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Uma classe base abstrata para um :term:`loader` que implementa o protocolo "
"opcional :pep:`302` para *loaders* que inspecionam módulos."

#: ../../library/importlib.rst:422
msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Retorna o objeto código para um módulo, ou ``None`` se o módulo não tiver um "
"objeto código (como seria o caso, por exemplo, de um módulo integrado). "
"Levanta um :exc:`ImportError` se o *loader* não conseguir encontrar o módulo "
"solicitado."

#: ../../library/importlib.rst:428
msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Embora o método tenha uma implementação predefinida, é sugerido que seja "
"substituído, se possível, por razões de desempenho."

#: ../../library/importlib.rst:434
msgid "No longer abstract and a concrete implementation is provided."
msgstr "Já não é abstrato e uma implementação concreta é fornecida."

#: ../../library/importlib.rst:440
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"Um método abstrato para retornar a origem de um módulo. É retornado como uma "
"string de texto usando :term:`universal newlines`, traduzindo todos os "
"separadores de linha reconhecidos em caracteres ``'\\n'``. Retorna ``None`` "
"se não houver origem disponível (por exemplo, um módulo integrado). Levanta :"
"exc:`ImportError` se o *loader* não conseguir encontrar o módulo "
"especificado."

#: ../../library/importlib.rst:446 ../../library/importlib.rst:455
#: ../../library/importlib.rst:506
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Levanta :exc:`ImportError` em vez de :exc:`NotImplementedError`."

#: ../../library/importlib.rst:451
msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"Um método opcional para retornar um valor verdadeiro se o módulo for um "
"pacote, um valor falso caso contrário. :exc:`ImportError` é levantado se o :"
"term:`loader` não conseguir encontrar o módulo."

#: ../../library/importlib.rst:460
msgid "Create a code object from Python source."
msgstr "Criar um objeto código a partir de código-fonte Python."

#: ../../library/importlib.rst:462
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"O argumento *data* pode ser qualquer coisa que a função :func:`compile` "
"suporta (ou seja, string ou bytes). O argumento *path* deve ser o "
"\"caminho\" de onde o código-fonte se originou, o que pode ser um conceito "
"abstrato (por exemplo, localização num ficheiro zip)."

#: ../../library/importlib.rst:467
msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"Com o objeto código subsequente, pode executá-lo num módulo executando "
"``exec(code, module.__dict__)``."

#: ../../library/importlib.rst:472
msgid "Made the method static."
msgstr "Tornou o método estático."

#: ../../library/importlib.rst:477
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Implementação de :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:483
msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Implementação de :meth:`Loader.load_module`."

#: ../../library/importlib.rst:485
msgid "use :meth:`exec_module` instead."
msgstr "use :meth:`exec_module` em vez disso."

#: ../../library/importlib.rst:491
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Uma classe base abstrata que herda de :class:`InspectLoader` que, quando "
"implementada, ajuda um módulo a ser executado como um script. A ABC "
"representa um protocolo opcional :pep:`302`."

#: ../../library/importlib.rst:498
msgid ""
"An abstract method that is to return the value of :attr:`~module.__file__` "
"for the specified module. If no path is available, :exc:`ImportError` is "
"raised."
msgstr ""
"Um método abstrato que deve retornar o valor de :attr:`~module.__file__` "
"para o módulo especificado. Se não houver caminho disponível, :exc:"
"`ImportError` é levantado."

#: ../../library/importlib.rst:502
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Se o código-fonte estiver disponível, então o método deve retornar o caminho "
"para o ficheiro de origem, independentemente de um bytecode ter sido usado "
"para carregar o módulo."

#: ../../library/importlib.rst:512
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Uma classe base abstrata que herda de :class:`ResourceLoader` e :class:"
"`ExecutionLoader`, fornecendo implementações concretas de :meth:"
"`ResourceLoader.get_data` e :meth:`ExecutionLoader.get_filename`."

#: ../../library/importlib.rst:516
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"O argumento *fullname* é um nome totalmente resolvido do módulo que o "
"*loader* deve tratar. O argumento *path* é o caminho para o ficheiro do "
"módulo."

#: ../../library/importlib.rst:523
msgid "The name of the module the loader can handle."
msgstr "O nome do módulo que o *loader* pode tratar."

#: ../../library/importlib.rst:527
msgid "Path to the file of the module."
msgstr "Caminho para o ficheiro do módulo."

#: ../../library/importlib.rst:531
msgid "Calls super's ``load_module()``."
msgstr "Chama ``load_module()`` da superclasse."

#: ../../library/importlib.rst:533
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Use :meth:`Loader.exec_module` em vez disso."

#: ../../library/importlib.rst:539 ../../library/importlib.rst:980
msgid "Returns :attr:`path`."
msgstr "Retorna :attr:`path`."

#: ../../library/importlib.rst:544
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Lê *path* como um ficheiro binário e retorna os bytes do mesmo."

#: ../../library/importlib.rst:549
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Uma classe base abstrata para implementar o carregamento de ficheiros de "
"origem (e opcionalmente bytecode). A classe herda de :class:`ResourceLoader` "
"e :class:`ExecutionLoader`, exigindo a implementação de:"

#: ../../library/importlib.rst:553
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: ../../library/importlib.rst:554
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: ../../library/importlib.rst:555
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Deve retornar apenas o caminho para o ficheiro de origem; o carregamento sem "
"origem não é suportado."

#: ../../library/importlib.rst:558
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Os métodos abstratos definidos por esta classe são para adicionar suporte "
"opcional a ficheiros de bytecode. Não implementar estes métodos opcionais "
"(ou fazê-los levantar :exc:`NotImplementedError`) faz com que o *loader* "
"funcione apenas com código-fonte. Implementar os métodos permite que o "
"*loader* trabalhe com ficheiros de origem *e* bytecode; não permite "
"carregamento *sem origem* onde apenas bytecode é fornecido. Os ficheiros de "
"bytecode são uma otimização para acelerar o carregamento, removendo a etapa "
"de análise do compilador do Python, e, portanto, nenhuma API específica de "
"bytecode é exposta."

#: ../../library/importlib.rst:569
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Método abstrato opcional que retorna um :class:`dict` contendo metadados "
"sobre o caminho especificado. As chaves suportadas no dicionário são:"

#: ../../library/importlib.rst:572
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (obrigatório): um número inteiro ou de ponto flutuante que "
"representa o tempo de modificação do código-fonte;"

#: ../../library/importlib.rst:574
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (opcional): o tamanho em bytes do código-fonte."

#: ../../library/importlib.rst:576
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Quaisquer outras chaves no dicionário são ignoradas, para permitir extensões "
"futuras. Se o caminho não puder ser tratado, :exc:`OSError` é levantado."

#: ../../library/importlib.rst:581 ../../library/importlib.rst:594
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Levanta :exc:`OSError` em vez de :exc:`NotImplementedError`."

#: ../../library/importlib.rst:586
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Método abstrato opcional que retorna o tempo de modificação para o caminho "
"especificado."

#: ../../library/importlib.rst:589
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Este método está obsoleto em favor de :meth:`path_stats`. Não precisa de o "
"implementar, mas ainda está disponível por razões de compatibilidade. "
"Levante :exc:`OSError` se o caminho não puder ser tratado."

#: ../../library/importlib.rst:599
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Método abstrato opcional que escreve os bytes especificados para um caminho "
"de ficheiro. Quaisquer diretórios intermédios que não existam devem ser "
"criados automaticamente."

#: ../../library/importlib.rst:603
msgid ""
"When writing to the path fails because the path is read-only (:const:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""
"Quando a escrita para o caminho falha porque o caminho é de apenas leitura (:"
"const:`errno.EACCES`/:exc:`PermissionError`), não propague a exceção."

#: ../../library/importlib.rst:607
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Já não levanta :exc:`NotImplementedError` quando chamado."

#: ../../library/importlib.rst:612
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Implementação concreta de :meth:`InspectLoader.get_code`."

#: ../../library/importlib.rst:616
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Implementação concreta de :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:622
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Implementação concreta de :meth:`Loader.load_module`."

#: ../../library/importlib.rst:624
msgid "Use :meth:`exec_module` instead."
msgstr "Use :meth:`exec_module` em vez disso."

#: ../../library/importlib.rst:629
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Implementação concreta de :meth:`InspectLoader.get_source`."

#: ../../library/importlib.rst:633
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Implementação concreta de :meth:`InspectLoader.is_package`. Um módulo é "
"determinado como sendo um pacote se o seu caminho de ficheiro (conforme "
"fornecido por :meth:`ExecutionLoader.get_filename`) for um ficheiro chamado "
"``__init__`` quando a extensão do ficheiro é removida **e** o nome do módulo "
"em si não terminar em ``__init__``."

#: ../../library/importlib.rst:641
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` — Importadores e ganchos de caminho"

#: ../../library/importlib.rst:646
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/machinery.py`"

#: ../../library/importlib.rst:650
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""
"Este módulo contém vários objetos que ajudam :keyword:`import` a encontrar e "
"carregar módulos."

#: ../../library/importlib.rst:655
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""
"Uma lista de strings que representam os sufixos de ficheiros reconhecidos "
"para módulos de origem."

#: ../../library/importlib.rst:662
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""
"Uma lista de strings que representam os sufixos de ficheiros para módulos de "
"bytecode não otimizados."

#: ../../library/importlib.rst:667 ../../library/importlib.rst:677
msgid "Use :const:`BYTECODE_SUFFIXES` instead."
msgstr "Use :const:`BYTECODE_SUFFIXES` em vez disso."

#: ../../library/importlib.rst:672
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""
"Uma lista de strings que representam os sufixos de ficheiros para módulos de "
"bytecode otimizados."

#: ../../library/importlib.rst:682
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr ""
"Uma lista de strings que representam os sufixos de ficheiros reconhecidos "
"para módulos de bytecode (incluindo o ponto inicial)."

#: ../../library/importlib.rst:687
msgid "The value is no longer dependent on ``__debug__``."
msgstr "O valor já não depende de ``__debug__``."

#: ../../library/importlib.rst:692
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""
"Uma lista de strings que representam os sufixos de ficheiros reconhecidos "
"para módulos de extensão."

#: ../../library/importlib.rst:699
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)."
msgstr ""
"Retorna uma lista combinada de strings que representam todos os sufixos de "
"ficheiros para módulos reconhecidos pela maquinaria de importação padrão. "
"Isto é um auxiliar para código que simplesmente precisa de saber se um "
"caminho no sistema de ficheiros refere-se potencialmente a um módulo sem "
"precisar de quaisquer detalhes sobre o tipo de módulo (por exemplo, :func:"
"`inspect.getmodulename`)."

#: ../../library/importlib.rst:710
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"Um :term:`importador` para módulos integrados. Todos os módulos integrados "
"conhecidos estão listados em :data:`sys.builtin_module_names`. Esta classe "
"implementa as ABCs :class:`importlib.abc.MetaPathFinder` e :class:`importlib."
"abc.InspectLoader`."

#: ../../library/importlib.rst:715 ../../library/importlib.rst:729
#: ../../library/importlib.rst:742 ../../library/importlib.rst:757
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""
"Apenas métodos de classe são definidos por esta classe para evitar a "
"necessidade de instanciar."

#: ../../library/importlib.rst:718
msgid ""
"As part of :pep:`489`, the builtin importer now implements :meth:`Loader."
"create_module` and :meth:`Loader.exec_module`"
msgstr ""
"Como parte da :pep:`489`, o importador integrado agora implementa :meth:"
"`Loader.create_module` e :meth:`Loader.exec_module`."

#: ../../library/importlib.rst:725
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"Um :term:`importador` para módulos congelados. Esta classe implementa as "
"ABCs :class:`importlib.abc.MetaPathFinder` e :class:`importlib.abc."
"InspectLoader`."

#: ../../library/importlib.rst:732
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` methods."
msgstr ""
"Obteve os métodos :meth:`~Loader.create_module` e :meth:`~Loader."
"exec_module`."

#: ../../library/importlib.rst:739
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  This "
"class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":term:`Finder <finder>` para módulos declarados no registo do Windows. Esta "
"classe implementa a ABC :class:`importlib.abc.MetaPathFinder`."

#: ../../library/importlib.rst:747
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr ""
"Use a configuração :mod:`site` em vez disso. Versões futuras do Python podem "
"não ativar este *finder* por predefinição."

#: ../../library/importlib.rst:754
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the :class:`importlib.abc.MetaPathFinder` "
"ABC."
msgstr ""
"Um :term:`Finder <finder>` para :data:`sys.path` e atributos ``__path__`` de "
"pacotes. Esta classe implementa a ABC :class:`importlib.abc.MetaPathFinder`."

#: ../../library/importlib.rst:762
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, :data:`sys."
"path_importer_cache` is checked. If a non-false object is found then it is "
"used as the :term:`path entry finder` to look for the module being searched "
"for. If no entry is found in :data:`sys.path_importer_cache`, then :data:"
"`sys.path_hooks` is searched for a finder for the path entry and, if found, "
"is stored in :data:`sys.path_importer_cache` along with being queried about "
"the module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
"Método de classe que tenta encontrar uma :term:`especificação <module spec>` "
"para o módulo especificado por *fullname* em :data:`sys.path` ou, se "
"definido, em *path*. Para cada entrada de caminho pesquisada, :data:`sys."
"path_importer_cache` é verificado. Se for encontrado um objeto não falso, "
"este é usado como :term:`path entry finder` para procurar o módulo em "
"questão. Se nenhuma entrada for encontrada em :data:`sys."
"path_importer_cache`, então :data:`sys.path_hooks` é pesquisado por um "
"*finder* para a entrada de caminho e, se encontrado, é armazenado em :data:"
"`sys.path_importer_cache` e consultado sobre o módulo. Se nenhum *finder* "
"for encontrado, ``None`` é armazenado na cache e retornado."

#: ../../library/importlib.rst:776
msgid ""
"If the current working directory -- represented by an empty string -- is no "
"longer valid then ``None`` is returned but no value is cached in :data:`sys."
"path_importer_cache`."
msgstr ""
"Se o diretório de trabalho atual — representado por uma string vazia — já "
"não for válido, então ``None`` é retornado, mas nenhum valor é armazenado em "
"cache em :data:`sys.path_importer_cache`."

#: ../../library/importlib.rst:783
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :data:`sys.path_importer_cache` that define the method. Otherwise "
"entries in :data:`sys.path_importer_cache` set to ``None`` are deleted."
msgstr ""
"Chama :meth:`importlib.abc.PathEntryFinder.invalidate_caches` em todos os "
"*finders* armazenados em :data:`sys.path_importer_cache` que definem o "
"método. Caso contrário, as entradas em :data:`sys.path_importer_cache` "
"definidas para ``None`` são eliminadas."

#: ../../library/importlib.rst:788
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ""
"As entradas de ``None`` em :data:`sys.path_importer_cache` são eliminadas."

#: ../../library/importlib.rst:791
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working directory "
"for ``''`` (i.e. the empty string)."
msgstr ""
"Chama objetos em :data:`sys.path_hooks` com o diretório de trabalho atual "
"para ``''`` (ou seja, a string vazia)."

#: ../../library/importlib.rst:798
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.PathEntryFinder` que "
"armazenar em cache os resultados do sistema de ficheiros."

#: ../../library/importlib.rst:801
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr ""
"O argumento *path* é o diretório pelo qual o *finder* é responsável por "
"pesquisar."

#: ../../library/importlib.rst:804
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""
"O argumento *loader_details* é um número variável de tuplos de 2 itens, cada "
"um contendo um *loader* e uma sequência de sufixos de ficheiros que o "
"*loader* reconhece. Espera-se que os *loaders* sejam chamáveis que aceitem "
"dois argumentos: o nome do módulo e o caminho para o ficheiro encontrado."

#: ../../library/importlib.rst:809
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""
"O *finder* armazenará em cache os conteúdos do diretório conforme "
"necessário, fazendo chamadas de estatísticas para cada pesquisa de módulo "
"para verificar se a cache não está desatualizada. Como a desatualização da "
"cache depende da granularidade das informações de estado do sistema "
"operativo sobre o sistema de ficheiros, existe uma potencial condição de "
"corrida ao pesquisar um módulo, criar um novo ficheiro e, em seguida, "
"pesquisar o módulo que o novo ficheiro representa. Se as operações "
"acontecerem rapidamente o suficiente para caber na granularidade das "
"chamadas de estatísticas, então a pesquisa do módulo falhará. Para evitar "
"que isto aconteça, ao criar um módulo dinamicamente, certifique-se de "
"chamar :func:`importlib.invalidate_caches`."

#: ../../library/importlib.rst:823
msgid "The path the finder will search in."
msgstr "O caminho que o *finder* pesquisará."

#: ../../library/importlib.rst:827
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ""
"Tenta encontrar a especificação para tratar *fullname* dentro de :attr:"
"`path`."

#: ../../library/importlib.rst:833
msgid "Clear out the internal cache."
msgstr "Limpa a cache interna."

#: ../../library/importlib.rst:837
msgid ""
"A class method which returns a closure for use on :data:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""
"Um método de classe que retorna uma closure para uso em :data:`sys."
"path_hooks`. Uma instância de :class:`FileFinder` é retornada pela closure "
"usando o argumento de caminho dado diretamente à closure e *loader_details* "
"indiretamente."

#: ../../library/importlib.rst:842
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""
"Se o argumento para a closure não for um diretório existente, :exc:"
"`ImportError` é levantado."

#: ../../library/importlib.rst:848
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.SourceLoader` através da "
"subclasse :class:`importlib.abc.FileLoader` e fornecendo algumas "
"implementações concretas de outros métodos."

#: ../../library/importlib.rst:856
msgid "The name of the module that this loader will handle."
msgstr "O nome do módulo que este *loader* tratará."

#: ../../library/importlib.rst:860
msgid "The path to the source file."
msgstr "O caminho para o ficheiro de origem."

#: ../../library/importlib.rst:864
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr "Retorna ``True`` se :attr:`path` parecer ser de um pacote."

#: ../../library/importlib.rst:868
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ""
"Implementação concreta de :meth:`importlib.abc.SourceLoader.path_stats`."

#: ../../library/importlib.rst:872
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr "Implementação concreta de :meth:`importlib.abc.SourceLoader.set_data`."

#: ../../library/importlib.rst:876 ../../library/importlib.rst:919
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where "
"specifying the name of the module to load is optional."
msgstr ""
"Implementação concreta de :meth:`importlib.abc.Loader.load_module` onde "
"especificar o nome do módulo a carregar é opcional."

#: ../../library/importlib.rst:881 ../../library/importlib.rst:924
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "Use :meth:`importlib.abc.Loader.exec_module` em vez disso."

#: ../../library/importlib.rst:886
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.FileLoader` que pode "
"importar ficheiros de bytecode (ou seja, não existem ficheiros de código-"
"fonte)."

#: ../../library/importlib.rst:889
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""
"Note que o uso direto de ficheiros de bytecode (e, portanto, não de "
"ficheiros de código-fonte) impede que os seus módulos sejam utilizáveis por "
"todas as implementações do Python ou por novas versões do Python que alteram "
"o formato do bytecode."

#: ../../library/importlib.rst:898
msgid "The name of the module the loader will handle."
msgstr "O nome do módulo que o *loader* tratará."

#: ../../library/importlib.rst:902
msgid "The path to the bytecode file."
msgstr "O caminho para o ficheiro de bytecode."

#: ../../library/importlib.rst:906
msgid "Determines if the module is a package based on :attr:`path`."
msgstr "Determina se o módulo é um pacote com base em :attr:`path`."

#: ../../library/importlib.rst:910
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ""
"Retorna o objeto código para :attr:`name` criado a partir de :attr:`path`."

#: ../../library/importlib.rst:914
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""
"Retorna ``None`` porque os ficheiros de bytecode não têm origem quando este "
"*loader* é usado."

#: ../../library/importlib.rst:929
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.ExecutionLoader` para "
"módulos de extensão."

#: ../../library/importlib.rst:932
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""
"O argumento *fullname* especifica o nome do módulo que o *loader* deve "
"suportar. O argumento *path* é o caminho para o ficheiro do módulo de "
"extensão."

#: ../../library/importlib.rst:935
msgid ""
"Note that, by default, importing an extension module will fail in "
"subinterpreters if it doesn't implement multi-phase init (see :pep:`489`), "
"even if it would otherwise import successfully."
msgstr ""
"Note que, por predefinição, a importação de um módulo de extensão falhará em "
"subinterpretadores se não implementar a inicialização em várias fases (ver :"
"pep:`489`), mesmo que, de outra forma, fosse importado com sucesso."

#: ../../library/importlib.rst:941
msgid "Multi-phase init is now required for use in subinterpreters."
msgstr ""
"A inicialização em várias fases é agora necessária para uso em "
"subinterpretadores."

#: ../../library/importlib.rst:946 ../../library/importlib.rst:1132
msgid "Name of the module the loader supports."
msgstr "Nome do módulo que o *loader* suporta."

#: ../../library/importlib.rst:950
msgid "Path to the extension module."
msgstr "Caminho para o módulo de extensão."

#: ../../library/importlib.rst:954
msgid ""
"Creates the module object from the given specification in accordance with :"
"pep:`489`."
msgstr ""
"Cria o objeto módulo a partir da especificação dada de acordo com :pep:`489`."

#: ../../library/importlib.rst:961
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr "Inicializa o objeto módulo dado de acordo com :pep:`489`."

#: ../../library/importlib.rst:967
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :const:`EXTENSION_SUFFIXES`."
msgstr ""
"Retorna ``True`` se o caminho do ficheiro apontar para um módulo "
"``__init__`` de um pacote com base em :const:`EXTENSION_SUFFIXES`."

#: ../../library/importlib.rst:972
msgid "Returns ``None`` as extension modules lack a code object."
msgstr ""
"Retorna ``None`` porque os módulos de extensão não têm um objeto código."

#: ../../library/importlib.rst:976
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "Retorna ``None`` porque os módulos de extensão não têm código-fonte."

#: ../../library/importlib.rst:987
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"namespace packages.  This is an alias for a private class and is only made "
"public for introspecting the ``__loader__`` attribute on namespace packages::"
msgstr ""
"Uma implementação concreta de :class:`importlib.abc.InspectLoader` para "
"pacotes de namespace. Isto é um alias para uma classe privada e é tornado "
"público apenas para introspeção do atributo ``__loader__`` em pacotes de "
"namespace::"

#: ../../library/importlib.rst:992
msgid ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"
msgstr ""
">>> from importlib.machinery import NamespaceLoader\n"
">>> import my_namespace\n"
">>> isinstance(my_namespace.__loader__, NamespaceLoader)\n"
"True\n"
">>> import importlib.abc\n"
">>> isinstance(my_namespace.__loader__, importlib.abc.Loader)\n"
"True"

#: ../../library/importlib.rst:1005
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's :attr:`~module.__spec__` attribute.  Many "
"of these attributes are also available directly on a module: for example, "
"``module.__spec__.origin == module.__file__``.  Note, however, that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  For example, it is possible to "
"update the module's :attr:`~module.__file__` at runtime and this will not be "
"automatically reflected in the module's :attr:`__spec__.origin <ModuleSpec."
"origin>`, and vice versa."
msgstr ""
"Uma especificação para o estado relacionado com o sistema de importação de "
"um módulo. Isto é tipicamente exposto como o atributo :attr:`~module."
"__spec__` do módulo. Muitos destes atributos também estão disponíveis "
"diretamente num módulo: por exemplo, ``module.__spec__.origin == module."
"__file__``. No entanto, note que, embora os *valores* sejam geralmente "
"equivalentes, podem diferir, uma vez que não há sincronização entre os dois "
"objetos. Por exemplo, é possível atualizar o :attr:`~module.__file__` do "
"módulo em tempo de execução e isto não será automaticamente refletido no :"
"attr:`__spec__.origin <ModuleSpec.origin>` do módulo, e vice-versa."

#: ../../library/importlib.rst:1019
msgid ""
"The module's fully qualified name (see :attr:`module.__name__`). The :term:"
"`finder` should always set this attribute to a non-empty string."
msgstr ""
"O nome totalmente qualificado do módulo (ver :attr:`module.__name__`). O :"
"term:`finder` deve sempre definir este atributo para uma string não vazia."

#: ../../library/importlib.rst:1024
msgid ""
"The :term:`loader` used to load the module (see :attr:`module.__loader__`). "
"The :term:`finder` should always set this attribute."
msgstr ""
"O :term:`loader` usado para carregar o módulo (ver :attr:`module."
"__loader__`). O :term:`finder` deve sempre definir este atributo."

#: ../../library/importlib.rst:1029
msgid ""
"The location the :term:`loader` should use to load the module (see :attr:"
"`module.__file__`). For example, for modules loaded from a ``.py`` file this "
"is the filename. The :term:`finder` should always set this attribute to a "
"meaningful value for the :term:`loader` to use.  In the uncommon case that "
"there is not one (like for namespace packages), it should be set to ``None``."
msgstr ""
"A localização que o :term:`loader` deve usar para carregar o módulo (ver :"
"attr:`module.__file__`). Por exemplo, para módulos carregados a partir de um "
"ficheiro ``.py``, este é o nome do ficheiro. O :term:`finder` deve sempre "
"definir este atributo para um valor significativo para o :term:`loader` "
"usar. No caso incomum de não haver um (como para pacotes de namespace), deve "
"ser definido como ``None``."

#: ../../library/importlib.rst:1038
msgid ""
"A (possibly empty) :term:`sequence` of strings enumerating the locations in "
"which a package's submodules will be found (see :attr:`module.__path__`). "
"Most of the time there will only be a single directory in this list."
msgstr ""
"Uma :term:`sequência` (possivelmente vazia) de strings que enumera as "
"localizações onde os submódulos de um pacote serão encontrados (ver :attr:"
"`module.__path__`). Na maioria das vezes, haverá apenas um diretório nesta "
"lista."

#: ../../library/importlib.rst:1043
msgid ""
"The :term:`finder` should set this attribute to a sequence, even an empty "
"one, to indicate to the import system that the module is a package.  It "
"should be set to ``None`` for non-package modules.  It is set automatically "
"later to a special object for namespace packages."
msgstr ""
"O :term:`finder` deve definir este atributo para uma sequência, mesmo que "
"vazia, para indicar ao sistema de importação que o módulo é um pacote. Deve "
"ser definido como ``None`` para módulos que não são pacotes. É definido "
"automaticamente mais tarde para um objeto especial para pacotes de namespace."

#: ../../library/importlib.rst:1051
msgid ""
"The :term:`finder` may set this attribute to an object containing "
"additional, module-specific data to use when loading the module.  Otherwise "
"it should be set to ``None``."
msgstr ""
"O :term:`finder` pode definir este atributo para um objeto contendo dados "
"adicionais específicos do módulo a usar ao carregar o módulo. Caso "
"contrário, deve ser definido como ``None``."

#: ../../library/importlib.rst:1057
msgid ""
"The filename of a compiled version of the module's code (see :attr:`module."
"__cached__`). The :term:`finder` should always set this attribute but it may "
"be ``None`` for modules that do not need compiled code stored."
msgstr ""
"O nome do ficheiro de uma versão compilada do código do módulo (ver :attr:"
"`module.__cached__`). O :term:`finder` deve sempre definir este atributo, "
"mas pode ser ``None`` para módulos que não precisam de código compilado "
"armazenado."

#: ../../library/importlib.rst:1064
msgid ""
"(Read-only) The fully qualified name of the package the module is in (or the "
"empty string for a top-level module). See :attr:`module.__package__`. If the "
"module is a package then this is the same as :attr:`name`."
msgstr ""
"(Apenas leitura) O nome totalmente qualificado do pacote em que o módulo "
"está (ou a string vazia para um módulo de nível superior). Ver :attr:`module."
"__package__`. Se o módulo for um pacote, então isto é o mesmo que :attr:"
"`name`."

#: ../../library/importlib.rst:1071
msgid ""
"``True`` if the spec's :attr:`origin` refers to a loadable location, "
"``False`` otherwise.  This value impacts how :attr:`!origin` is interpreted "
"and how the module's :attr:`~module.__file__` is populated."
msgstr ""
"``True`` se o :attr:`origin` da especificação se referir a uma localização "
"carregável, ``False`` caso contrário. Este valor afeta como :attr:`!origin` "
"é interpretado e como o :attr:`~module.__file__` do módulo é preenchido."

#: ../../library/importlib.rst:1078
msgid ""
"A specialization of :class:`importlib.machinery.ExtensionFileLoader` that is "
"able to load extension modules in Framework format."
msgstr ""
"Uma especialização de :class:`importlib.machinery.ExtensionFileLoader` que é "
"capaz de carregar módulos de extensão no formato Framework."

#: ../../library/importlib.rst:1081
msgid ""
"For compatibility with the iOS App Store, *all* binary modules in an iOS app "
"must be dynamic libraries, contained in a framework with appropriate "
"metadata, stored in the ``Frameworks`` folder of the packaged app. There can "
"be only a single binary per framework, and there can be no executable binary "
"material outside the Frameworks folder."
msgstr ""
"Para compatibilidade com a App Store do iOS, *todos* os módulos binários "
"numa aplicação iOS devem ser bibliotecas dinâmicas, contidas numa framework "
"com metadados apropriados, armazenadas na pasta ``Frameworks`` da aplicação "
"empacotada. Pode haver apenas um binário por framework, e não pode haver "
"material binário executável fora da pasta Frameworks."

#: ../../library/importlib.rst:1087
msgid ""
"To accommodate this requirement, when running on iOS, extension module "
"binaries are *not* packaged as ``.so`` files on ``sys.path``, but as "
"individual standalone frameworks. To discover those frameworks, this loader "
"is registered against the ``.fwork`` file extension, with a ``.fwork`` file "
"acting as a placeholder in the original location of the binary on ``sys."
"path``. The ``.fwork`` file contains the path of the actual binary in the "
"``Frameworks`` folder, relative to the app bundle. To allow for resolving a "
"framework-packaged binary back to the original location, the framework is "
"expected to contain a ``.origin`` file that contains the location of the ``."
"fwork`` file, relative to the app bundle."
msgstr ""
"Para acomodar este requisito, ao executar no iOS, os binários de módulos de "
"extensão *não* são empacotados como ficheiros ``.so`` em ``sys.path``, mas "
"como frameworks autónomos individuais. Para descobrir essas frameworks, este "
"*loader* é registrado contra a extensão de ficheiro ``.fwork``, com um "
"ficheiro ``.fwork`` a atuar como um espaço reservado na localização original "
"do binário em ``sys.path``. O ficheiro ``.fwork`` contém o caminho do "
"binário real na pasta ``Frameworks``, relativo ao pacote da aplicação. Para "
"permitir a resolução de um binário empacotado em framework de volta à "
"localização original, espera-se que a framework contenha um ficheiro ``."
"origin`` que contém a localização do ficheiro ``.fwork``, relativo ao pacote "
"da aplicação."

#: ../../library/importlib.rst:1098
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"Por exemplo, considere o caso de uma importação ``from foo.bar import "
"_whiz``, onde ``_whiz`` é implementado com o módulo binário ``sources/foo/"
"bar/_whiz.abi3.so``, com ``sources`` sendo a localização registada em ``sys."
"path``, relativa ao pacote da aplicação. Este módulo *deve* ser distribuído "
"como ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` (criando o nome da "
"framework a partir do caminho de importação completo do módulo), com um "
"ficheiro ``Info.plist`` no diretório ``.framework`` que identifica o binário "
"como uma framework. O módulo ``foo.bar._whiz`` seria representado na "
"localização original com um ficheiro marcador ``sources/foo/bar/_whiz.abi3."
"fwork``, contendo o caminho ``Frameworks/foo.bar._whiz/foo.bar._whiz``. A "
"framework também conteria ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz."
"origin``, contendo o caminho para o ficheiro ``.fwork``."

#: ../../library/importlib.rst:1112
msgid ""
"When a module is loaded with this loader, the ``__file__`` for the module "
"will report as the location of the ``.fwork`` file. This allows code to use "
"the ``__file__`` of a  module as an anchor for file system traversal. "
"However, the spec origin will reference the location of the *actual* binary "
"in the ``.framework`` folder."
msgstr ""
"Quando um módulo é carregado com este *loader*, o ``__file__`` do módulo "
"reportará a localização do ficheiro ``.fwork``. Isto permite que o código "
"use o ``__file__`` de um módulo como uma âncora para a travessia do sistema "
"de ficheiros. No entanto, a origem da especificação referenciará a "
"localização do binário *real* na pasta ``.framework``."

#: ../../library/importlib.rst:1118
msgid ""
"The Xcode project building the app is responsible for converting any ``.so`` "
"files from wherever they exist in the ``PYTHONPATH`` into frameworks in the "
"``Frameworks`` folder (including stripping extensions from the module file, "
"the addition of framework metadata, and signing the resulting framework), "
"and creating the ``.fwork`` and ``.origin`` files. This will usually be done "
"with a build step in the Xcode project; see the iOS documentation for "
"details on how to construct this build step."
msgstr ""
"O projeto Xcode que constrói a aplicação é responsável por converter "
"quaisquer ficheiros ``.so`` de onde quer que existam no ``PYTHONPATH`` em "
"frameworks na pasta ``Frameworks`` (incluindo a remoção de extensões do "
"ficheiro do módulo, a adição de metadados da framework e a assinatura da "
"framework resultante), e criar os ficheiros ``.fwork`` e ``.origin``. Isto "
"será normalmente feito com uma etapa de construção no projeto Xcode; "
"consulte a documentação do iOS para detalhes sobre como construir esta etapa "
"de construção."

#: ../../library/importlib.rst:1128
msgid "Availability"
msgstr "Disponibilidade"

#: ../../library/importlib.rst:1136
msgid "Path to the ``.fwork`` file for the extension module."
msgstr "Caminho para o ficheiro ``.fwork`` do módulo de extensão."

#: ../../library/importlib.rst:1140
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` — Código utilitário para importadores"

#: ../../library/importlib.rst:1146
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**Código-fonte:** :source:`Lib/importlib/util.py`"

#: ../../library/importlib.rst:1150
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""
"Este módulo contém vários objetos que ajudam na construção de um :term:"
"`importador`."

#: ../../library/importlib.rst:1155
msgid ""
"The bytes which represent the bytecode version number. If you need help with "
"loading/writing bytecode then consider :class:`importlib.abc.SourceLoader`."
msgstr ""
"Os bytes que representam o número de versão do bytecode. Se precisar de "
"ajuda com o carregamento/escrita de bytecode, considere :class:`importlib."
"abc.SourceLoader`."

#: ../../library/importlib.rst:1162
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file associated "
"with the source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the "
"return value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python "
"3.2. The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised)."
msgstr ""
"Retorna o caminho :pep:`3147`/:pep:`488` para o ficheiro compilado em "
"bytecode associado ao *path* de origem. Por exemplo, se *path* for ``/foo/"
"bar/baz.py``, o valor retornado seria ``/foo/bar/__pycache__/baz.cpython-32."
"pyc`` para Python 3.2. A string ``cpython-32`` vem da etiqueta mágica atual "
"(ver :func:`get_tag`; se :attr:`sys.implementation.cache_tag` não estiver "
"definido, então :exc:`NotImplementedError` será levantado)."

#: ../../library/importlib.rst:1169
msgid ""
"The *optimization* parameter is used to specify the optimization level of "
"the bytecode file. An empty string represents no optimization, so ``/foo/bar/"
"baz.py`` with an *optimization* of ``''`` will result in a bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` causes the "
"interpreter's optimization level to be used. Any other value's string "
"representation is used, so ``/foo/bar/baz.py`` with an *optimization* of "
"``2`` will lead to the bytecode path of ``/foo/bar/__pycache__/baz."
"cpython-32.opt-2.pyc``. The string representation of *optimization* can only "
"be alphanumeric, else :exc:`ValueError` is raised."
msgstr ""
"O parâmetro *optimization* é usado para especificar o nível de otimização do "
"ficheiro de bytecode. Uma string vazia representa nenhuma otimização, então "
"``/foo/bar/baz.py`` com uma *optimization* de ``''`` resultará num caminho "
"de bytecode de ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` faz com "
"que o nível de otimização do interpretador seja usado. A representação em "
"string de qualquer outro valor é usada, então ``/foo/bar/baz.py`` com uma "
"*optimization* de ``2`` levará ao caminho de bytecode de ``/foo/bar/"
"__pycache__/baz.cpython-32.opt-2.pyc``. A representação em string de "
"*optimization* só pode ser alfanumérica, caso contrário, :exc:`ValueError` é "
"levantado."

#: ../../library/importlib.rst:1179
msgid ""
"The *debug_override* parameter is deprecated and can be used to override the "
"system's value for ``__debug__``. A ``True`` value is the equivalent of "
"setting *optimization* to the empty string. A ``False`` value is the same as "
"setting *optimization* to ``1``. If both *debug_override* an *optimization* "
"are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"O parâmetro *debug_override* está obsoleto e pode ser usado para substituir "
"o valor do sistema para ``__debug__``. Um valor ``True`` é equivalente a "
"definir *optimization* para a string vazia. Um valor ``False`` é o mesmo que "
"definir *optimization* para ``1``. Se ambos *debug_override* e "
"*optimization* não forem ``None``, então :exc:`TypeError` é levantado."

#: ../../library/importlib.rst:1187
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter "
"was deprecated."
msgstr ""
"O parâmetro *optimization* foi adicionado e o parâmetro *debug_override* foi "
"tornado obsoleto."

#: ../../library/importlib.rst:1191 ../../library/importlib.rst:1207
#: ../../library/importlib.rst:1296
msgid "Accepts a :term:`path-like object`."
msgstr "Aceita um :term:`objeto semelhante a um caminho`."

#: ../../library/importlib.rst:1197
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` or :pep:`488` "
"format, a :exc:`ValueError` is raised. If :attr:`sys.implementation."
"cache_tag` is not defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Dado o *path* para um nome de ficheiro :pep:`3147`, retorna o caminho do "
"ficheiro de código-fonte associado. Por exemplo, se *path* for ``/foo/bar/"
"__pycache__/baz.cpython-32.pyc``, o caminho retornado seria ``/foo/bar/baz."
"py``. *path* não precisa de existir, no entanto, se não conformar com o "
"formato :pep:`3147` ou :pep:`488`, um :exc:`ValueError` é levantado. Se :"
"attr:`sys.implementation.cache_tag` não estiver definido, :exc:"
"`NotImplementedError` é levantado."

#: ../../library/importlib.rst:1212
msgid ""
"Decode the given bytes representing source code and return it as a string "
"with universal newlines (as required by :meth:`importlib.abc.InspectLoader."
"get_source`)."
msgstr ""
"Decodifica os bytes dados que representam código-fonte e retorna-os como uma "
"string com novas linhas universais (como exigido por :meth:`importlib.abc."
"InspectLoader.get_source`)."

#: ../../library/importlib.rst:1220
msgid "Resolve a relative module name to an absolute one."
msgstr "Resolve um nome de módulo relativo para um absoluto."

#: ../../library/importlib.rst:1222
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __spec__."
"parent)`` without doing a check to see if the **package** argument is needed."
msgstr ""
"Se **name** não tiver pontos iniciais, então **name** é simplesmente "
"retornado. Isto permite o uso como ``importlib.util.resolve_name('sys', "
"__spec__.parent)`` sem verificar se o argumento **package** é necessário."

#: ../../library/importlib.rst:1227
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). :exc:"
"`ImportError` is also raised if a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""
":exc:`ImportError` é levantado se **name** for um nome de módulo relativo, "
"mas **package** for um valor falso (por exemplo, ``None`` ou a string "
"vazia). :exc:`ImportError` também é levantado se um nome relativo escapar do "
"seu pacote contêiner (por exemplo, solicitar ``..bacon`` a partir do pacote "
"``spam``)."

#: ../../library/importlib.rst:1235
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""
"Para melhorar a consistência com as instruções de importação, levanta :exc:"
"`ImportError` em vez de :exc:`ValueError` para tentativas de importação "
"relativa inválidas."

#: ../../library/importlib.rst:1242
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to the "
"specified **package** name. If the module is in :data:`sys.modules`, then "
"``sys.modules[name].__spec__`` is returned (unless the spec would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :data:`sys.meta_path` is done. ``None`` is returned "
"if no spec is found."
msgstr ""
"Encontra a :term:`especificação <module spec>` para um módulo, opcionalmente "
"relativo ao nome do **package** especificado. Se o módulo estiver em :data:"
"`sys.modules`, então ``sys.modules[name].__spec__`` é retornado (a menos que "
"a especificação seja ``None`` ou não esteja definida, caso em que :exc:"
"`ValueError` é levantado). Caso contrário, é feita uma pesquisa usando :data:"
"`sys.meta_path`. ``None`` é retornado se nenhuma especificação for "
"encontrada."

#: ../../library/importlib.rst:1249
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr ""
"Se **name** for para um submódulo (contém um ponto), o módulo pai é "
"automaticamente importado."

#: ../../library/importlib.rst:1252
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr ""
"**name** e **package** funcionam da mesma forma que para :func:"
"`import_module`."

#: ../../library/importlib.rst:1256
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`~module.__path__` "
"attribute)."
msgstr ""
"Levanta :exc:`ModuleNotFoundError` em vez de :exc:`AttributeError` se "
"**package** não for de facto um pacote (ou seja, não tem um atributo :attr:"
"`~module.__path__`)."

#: ../../library/importlib.rst:1263
msgid ""
"Create a new module based on **spec** and :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."
msgstr ""
"Cria um novo módulo com base em **spec** e :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`."

#: ../../library/importlib.rst:1266
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
"Se :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>` "
"não retornar ``None``, então quaisquer atributos pré-existentes não serão "
"redefinidos. Além disso, nenhum :exc:`AttributeError` será levantado se "
"desencadeado ao aceder a **spec** ou ao definir um atributo no módulo."

#: ../../library/importlib.rst:1271
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create a "
"new module as **spec** is used to set as many import-controlled attributes "
"on the module as possible."
msgstr ""
"Esta função é preferível ao uso de :class:`types.ModuleType` para criar um "
"novo módulo, uma vez que **spec** é usado para definir o maior número "
"possível de atributos controlados por importação no módulo."

#: ../../library/importlib.rst:1279
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on a loader.  The parameters have the same meaning as they do "
"for ModuleSpec.  The function uses available :term:`loader` APIs, such as :"
"meth:`InspectLoader.is_package`, to fill in any missing information on the "
"spec."
msgstr ""
"Uma função de fábrica para criar uma instância de :class:`~importlib."
"machinery.ModuleSpec` com base num *loader*. Os parâmetros têm o mesmo "
"significado que para ModuleSpec. A função usa APIs disponíveis do :term:"
"`loader`, como :meth:`InspectLoader.is_package`, para preencher quaisquer "
"informações em falta na especificação."

#: ../../library/importlib.rst:1289
msgid ""
"A factory function for creating a :class:`~importlib.machinery.ModuleSpec` "
"instance based on the path to a file.  Missing information will be filled in "
"on the spec by making use of loader APIs and by the implication that the "
"module will be file-based."
msgstr ""
"Uma função de fábrica para criar uma instância de :class:`~importlib."
"machinery.ModuleSpec` com base no caminho para um ficheiro. As informações "
"em falta serão preenchidas na especificação através do uso de APIs do "
"*loader* e pela implicação de que o módulo será baseado em ficheiros."

#: ../../library/importlib.rst:1301
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's contents "
"in its header."
msgstr ""
"Retorna o hash de *source_bytes* como bytes. Um ficheiro ``.pyc`` baseado em "
"hash incorpora o :func:`source_hash` do conteúdo do ficheiro de origem "
"correspondente no seu cabeçalho."

#: ../../library/importlib.rst:1309
msgid ""
"A context manager that can temporarily skip the compatibility check for "
"extension modules.  By default the check is enabled and will fail when a "
"single-phase init module is imported in a subinterpreter. It will also fail "
"for a multi-phase init module that doesn't explicitly support a per-"
"interpreter GIL, when imported in an interpreter with its own GIL."
msgstr ""
"Um gestor de contexto que pode ignorar temporariamente a verificação de "
"compatibilidade para módulos de extensão. Por predefinição, a verificação "
"está ativada e falhará quando um módulo de inicialização de fase única for "
"importado num subinterpretador. Também falhará para um módulo de "
"inicialização em várias fases que não suporte explicitamente um GIL por "
"interpretador, quando importado num interpretador com o seu próprio GIL."

#: ../../library/importlib.rst:1316
msgid ""
"Note that this function is meant to accommodate an unusual case; one which "
"is likely to eventually go away.  There's is a pretty good chance this is "
"not what you were looking for."
msgstr ""
"Note que esta função destina-se a acomodar um caso invulgar; um que "
"provavelmente desaparecerá eventualmente. Há uma boa probabilidade de isto "
"não ser o que procurava."

#: ../../library/importlib.rst:1320
msgid ""
"You can get the same effect as this function by implementing the basic "
"interface of multi-phase init (:pep:`489`) and lying about support for "
"multiple interpreters (or per-interpreter GIL)."
msgstr ""
"Pode obter o mesmo efeito desta função implementando a interface básica de "
"inicialização em várias fases (:pep:`489`) e mentindo sobre o suporte para "
"múltiplos interpretadores (ou GIL por interpretador)."

#: ../../library/importlib.rst:1325
msgid ""
"Using this function to disable the check can lead to unexpected behavior and "
"even crashes.  It should only be used during extension module development."
msgstr ""
"Usar esta função para desativar a verificação pode levar a comportamentos "
"inesperados e até falhas. Deve ser usada apenas durante o desenvolvimento de "
"módulos de extensão."

#: ../../library/importlib.rst:1333
msgid ""
"A class which postpones the execution of the loader of a module until the "
"module has an attribute accessed."
msgstr ""
"Uma classe que adia a execução do *loader* de um módulo até que um atributo "
"do módulo seja acedido."

#: ../../library/importlib.rst:1336
msgid ""
"This class **only** works with loaders that define :meth:`~importlib.abc."
"Loader.exec_module` as control over what module type is used for the module "
"is required. For those same reasons, the loader's :meth:`~importlib.abc."
"Loader.create_module` method must return ``None`` or a type for which its "
"``__class__`` attribute can be mutated along with not using :term:`slots "
"<__slots__>`. Finally, modules which substitute the object placed into :data:"
"`sys.modules` will not work as there is no way to properly replace the "
"module references throughout the interpreter safely; :exc:`ValueError` is "
"raised if such a substitution is detected."
msgstr ""
"Esta classe **apenas** funciona com *loaders* que definem :meth:`~importlib."
"abc.Loader.exec_module`, uma vez que é necessário controlo sobre o tipo de "
"módulo usado para o módulo. Pelas mesmas razões, o método :meth:`~importlib."
"abc.Loader.create_module` do *loader* deve retornar ``None`` ou um tipo para "
"o qual o seu atributo ``__class__`` possa ser mutado, além de não usar :term:"
"`slots <__slots__>`. Finalmente, módulos que substituem o objeto colocado "
"em :data:`sys.modules` não funcionarão, uma vez que não há forma de "
"substituir corretamente as referências do módulo em todo o interpretador de "
"forma segura; :exc:`ValueError` é levantado se tal substituição for detetada."

#: ../../library/importlib.rst:1347
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. For "
"projects where startup time is not essential then use of this class is "
"**heavily** discouraged due to error messages created during loading being "
"postponed and thus occurring out of context."
msgstr ""
"Para projetos em que o tempo de arranque é crítico, esta classe permite "
"potencialmente minimizar o custo de carregar um módulo se este nunca for "
"usado. Para projetos em que o tempo de arranque não é essencial, o uso desta "
"classe é **fortemente** desencorajado, uma vez que as mensagens de erro "
"criadas durante o carregamento são adiadas e, portanto, ocorrem fora de "
"contexto."

#: ../../library/importlib.rst:1355
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` and :"
"class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
"Começou a chamar :meth:`~importlib.abc.Loader.create_module`, removendo o "
"aviso de compatibilidade para :class:`importlib.machinery.BuiltinImporter` "
"e :class:`importlib.machinery.ExtensionFileLoader`."

#: ../../library/importlib.rst:1362
msgid ""
"A class method which returns a callable that creates a lazy loader. This is "
"meant to be used in situations where the loader is passed by class instead "
"of by instance. ::"
msgstr ""
"Um método de classe que retorna um chamável que cria um *loader* preguiçoso. "
"Isto destina-se a ser usado em situações em que o *loader* é passado por "
"classe em vez de por instância. ::"

#: ../../library/importlib.rst:1367
msgid ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"
msgstr ""
"suffixes = importlib.machinery.SOURCE_SUFFIXES\n"
"loader = importlib.machinery.SourceFileLoader\n"
"lazy_loader = importlib.util.LazyLoader.factory(loader)\n"
"finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))"

#: ../../library/importlib.rst:1375
msgid "Examples"
msgstr "Exemplos"

#: ../../library/importlib.rst:1378
msgid "Importing programmatically"
msgstr "Importar programaticamente"

#: ../../library/importlib.rst:1380
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`. ::"
msgstr ""
"Para importar um módulo programaticamente, use :func:`importlib."
"import_module`. :"

#: ../../library/importlib.rst:1383
msgid ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"
msgstr ""
"import importlib\n"
"\n"
"itertools = importlib.import_module('itertools')"

#: ../../library/importlib.rst:1389
msgid "Checking if a module can be imported"
msgstr "Verificar se um módulo pode ser importado"

#: ../../library/importlib.rst:1391
msgid ""
"If you need to find out if a module can be imported without actually doing "
"the import, then you should use :func:`importlib.util.find_spec`."
msgstr ""
"Se precisar de saber se um módulo pode ser importado sem realmente fazer a "
"importação, deve usar :func:`importlib.util.find_spec`."

#: ../../library/importlib.rst:1394
msgid ""
"Note that if ``name`` is a submodule (contains a dot), :func:`importlib.util."
"find_spec` will import the parent module. ::"
msgstr ""
"Note que se ``name`` for um submódulo (contém um ponto), :func:`importlib."
"util.find_spec` importará o módulo pai. :"

#: ../../library/importlib.rst:1398
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"# For illustrative purposes.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} already in sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # If you chose to perform the actual import ...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} has been imported\")\n"
"else:\n"
"    print(f\"can't find the {name!r} module\")"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"# Apenas para fins ilustrativos.\n"
"name = 'itertools'\n"
"\n"
"if name in sys.modules:\n"
"    print(f\"{name!r} já está em sys.modules\")\n"
"elif (spec := importlib.util.find_spec(name)) is not None:\n"
"    # Se optar por realizar a importação real...\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[name] = module\n"
"    spec.loader.exec_module(module)\n"
"    print(f\"{name!r} foi importado\")\n"
"else:\n"
"    print(f\"não é possível encontrar o módulo {name!r}\")"

#: ../../library/importlib.rst:1417
msgid "Importing a source file directly"
msgstr "Importar um ficheiro de origem diretamente"

#: ../../library/importlib.rst:1419
msgid ""
"This recipe should be used with caution: it is an approximation of an import "
"statement where the file path is specified directly, rather than :data:`sys."
"path` being searched. Alternatives should first be considered first, such as "
"modifying :data:`sys.path` when a proper module is required, or using :func:"
"`runpy.run_path` when the global namespace resulting from running a Python "
"file is appropriate."
msgstr ""
"Esta receita deve ser usada com cautela: é uma aproximação de uma instrução "
"de importação em que o caminho do ficheiro é especificado diretamente, em "
"vez de :data:`sys.path` ser pesquisado. Alternativas devem ser consideradas "
"primeiro, como modificar :data:`sys.path` quando um módulo adequado é "
"necessário, ou usar :func:`runpy.run_path` quando o espaço de nomes global "
"resultante da execução de um ficheiro Python é apropriado."

#: ../../library/importlib.rst:1426
msgid ""
"To import a Python source file directly from a path, use the following "
"recipe::"
msgstr ""
"Para importar um ficheiro de origem Python diretamente a partir de um "
"caminho, use a seguinte receita::"

#: ../../library/importlib.rst:1428
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# For illustrative purposes only (use of `json` is arbitrary).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Similar outcome as `import json`.\n"
"json = import_from_path(module_name, file_path)"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"\n"
"def import_from_path(module_name, file_path):\n"
"    spec = importlib.util.spec_from_file_location(module_name, file_path)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[module_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    return module\n"
"\n"
"\n"
"# Apenas para fins ilustrativos (o uso de `json` é arbitrário).\n"
"import json\n"
"file_path = json.__file__\n"
"module_name = json.__name__\n"
"\n"
"# Resultado semelhante a `import json`.\n"
"json = import_from_path(module_name, file_path)"

#: ../../library/importlib.rst:1450
msgid "Implementing lazy imports"
msgstr "Implementar importações preguiçosas"

#: ../../library/importlib.rst:1452
msgid "The example below shows how to implement lazy imports::"
msgstr "O exemplo abaixo mostra como implementar importações preguiçosas::"

#: ../../library/importlib.rst:1454
msgid ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> #lazy_typing is a real module object,\n"
">>> #but it is not loaded in memory yet.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"
msgstr ""
">>> import importlib.util\n"
">>> import sys\n"
">>> def lazy_import(name):\n"
"...     spec = importlib.util.find_spec(name)\n"
"...     loader = importlib.util.LazyLoader(spec.loader)\n"
"...     spec.loader = loader\n"
"...     module = importlib.util.module_from_spec(spec)\n"
"...     sys.modules[name] = module\n"
"...     loader.exec_module(module)\n"
"...     return module\n"
"...\n"
">>> lazy_typing = lazy_import(\"typing\")\n"
">>> # lazy_typing é um objeto de módulo real,\n"
">>> # mas ainda não está carregado na memória.\n"
">>> lazy_typing.TYPE_CHECKING\n"
"False"

#: ../../library/importlib.rst:1473
msgid "Setting up an importer"
msgstr "Configurar um importador"

#: ../../library/importlib.rst:1475
msgid ""
"For deep customizations of import, you typically want to implement an :term:"
"`importer`. This means managing both the :term:`finder` and :term:`loader` "
"side of things. For finders there are two flavours to choose from depending "
"on your needs: a :term:`meta path finder` or a :term:`path entry finder`. "
"The former is what you would put on :data:`sys.meta_path` while the latter "
"is what you create using a :term:`path entry hook` on :data:`sys.path_hooks` "
"which works with :data:`sys.path` entries to potentially create a finder. "
"This example will show you how to register your own importers so that import "
"will use them (for creating an importer for yourself, read the documentation "
"for the appropriate classes defined within this package)::"
msgstr ""
"Para personalizações profundas da importação, geralmente deseja implementar "
"um :term:`importador`. Isto significa gerir tanto o lado :term:`finder` como "
"o lado :term:`loader`. Para *finders*, há dois tipos para escolher, "
"dependendo das suas necessidades: um :term:`meta path finder` ou um :term:"
"`path entry finder`. O primeiro é o que colocaria em :data:`sys.meta_path`, "
"enquanto o último é o que cria usando um :term:`path entry hook` em :data:"
"`sys.path_hooks`, que funciona com entradas de :data:`sys.path` para "
"potencialmente criar um *finder*. Este exemplo mostrará como registar os "
"seus próprios importadores para que a importação os utilize (para criar um "
"importador para si, leia a documentação das classes apropriadas definidas "
"dentro deste pacote)::"

#: ../../library/importlib.rst:1486
msgid ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# For illustrative purposes only.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Setting up a meta path finder.\n"
"# Make sure to put the finder in the proper location in the list in terms "
"of\n"
"# priority.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Setting up a path entry finder.\n"
"# Make sure to put the path hook in the proper location in the list in "
"terms\n"
"# of priority.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"
msgstr ""
"import importlib.machinery\n"
"import sys\n"
"\n"
"# Apenas para fins ilustrativos.\n"
"SpamMetaPathFinder = importlib.machinery.PathFinder\n"
"SpamPathEntryFinder = importlib.machinery.FileFinder\n"
"loader_details = (importlib.machinery.SourceFileLoader,\n"
"                  importlib.machinery.SOURCE_SUFFIXES)\n"
"\n"
"# Configurar um meta path finder.\n"
"# Certifique-se de colocar o finder na posição correta na lista em termos "
"de\n"
"# prioridade.\n"
"sys.meta_path.append(SpamMetaPathFinder)\n"
"\n"
"# Configurar um path entry finder.\n"
"# Certifique-se de colocar o path hook na posição correta na lista em "
"termos\n"
"# de prioridade.\n"
"sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))"

#: ../../library/importlib.rst:1507
msgid "Approximating :func:`importlib.import_module`"
msgstr "Aproximar :func:`importlib.import_module`"

#: ../../library/importlib.rst:1509
msgid ""
"Import itself is implemented in Python code, making it possible to expose "
"most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module`::"
msgstr ""
"A própria importação é implementada em código Python, o que torna possível "
"expor a maior parte da maquinaria de importação através do importlib. O "
"seguinte ajuda a ilustrar as várias APIs que o importlib expõe, fornecendo "
"uma implementação aproximada de :func:`importlib.import_module`::"

#: ../../library/importlib.rst:1515
msgid ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"An approximate implementation of import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"
msgstr ""
"import importlib.util\n"
"import sys\n"
"\n"
"def import_module(name, package=None):\n"
"    \"\"\"Uma implementação aproximada de import.\"\"\"\n"
"    absolute_name = importlib.util.resolve_name(name, package)\n"
"    try:\n"
"        return sys.modules[absolute_name]\n"
"    except KeyError:\n"
"        pass\n"
"\n"
"    path = None\n"
"    if '.' in absolute_name:\n"
"        parent_name, _, child_name = absolute_name.rpartition('.')\n"
"        parent_module = import_module(parent_name)\n"
"        path = parent_module.__spec__.submodule_search_locations\n"
"    for finder in sys.meta_path:\n"
"        spec = finder.find_spec(absolute_name, path)\n"
"        if spec is not None:\n"
"            break\n"
"    else:\n"
"        msg = f'No module named {absolute_name!r}'\n"
"        raise ModuleNotFoundError(msg, name=absolute_name)\n"
"    module = importlib.util.module_from_spec(spec)\n"
"    sys.modules[absolute_name] = module\n"
"    spec.loader.exec_module(module)\n"
"    if path is not None:\n"
"        setattr(parent_module, child_name, module)\n"
"    return module"

#: ../../library/importlib.rst:431
msgid "universal newlines"
msgstr "novas linhas universais"

#: ../../library/importlib.rst:431
msgid "importlib.abc.InspectLoader.get_source method"
msgstr "método importlib.abc.InspectLoader.get_source"
