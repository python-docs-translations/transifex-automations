# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-03 14:56+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/multiprocessing.rst:2
msgid ":mod:`!multiprocessing` --- Process-based parallelism"
msgstr ":mod:`!multiprocessing` --- Paralelismo baseado em processos"

#: ../../library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**Código fonte:** :source:`Lib/multiprocessing/`"

#: ../../includes/wasm-mobile-notavail.rst:3
msgid "Availability"
msgstr "Disponibilidade"

#: ../../includes/wasm-mobile-notavail.rst:5
msgid ""
"This module is not supported on :ref:`mobile platforms <mobile-"
"availability>` or :ref:`WebAssembly platforms <wasm-availability>`."
msgstr ""
"Este módulo não é suportado em :ref:`plataformas móveis <mobile-"
"availability>` ou :ref:`plataformas WebAssembly <wasm-availability>`."

#: ../../library/multiprocessing.rst:14
msgid "Introduction"
msgstr "Introdução"

#: ../../library/multiprocessing.rst:16
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock <global interpreter lock>` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing` "
"module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both POSIX and Windows."
msgstr ""
"O módulo :mod:`multiprocessing` é um pacote que suporta a criação de "
"processos usando uma API semelhante ao módulo :mod:`threading`. O pacote :"
"mod:`multiprocessing` oferece concorrência local e remota, contornando "
"efetivamente o :term:`Global Interpreter Lock <global interpreter lock>` ao "
"usar subprocessos em vez de threads. Por isso, o módulo :mod:"
"`multiprocessing` permite que o programador utilize plenamente vários "
"processadores numa determinada máquina. Funciona tanto em sistemas POSIX "
"como Windows."

#: ../../library/multiprocessing.rst:25
msgid ""
"The :mod:`multiprocessing` module also introduces the :class:"
"`~multiprocessing.pool.Pool` object which offers a convenient means of "
"parallelizing the execution of a function across multiple input values, "
"distributing the input data across processes (data parallelism).  The "
"following example demonstrates the common practice of defining such "
"functions in a module so that child processes can successfully import that "
"module.  This basic example of data parallelism using :class:"
"`~multiprocessing.pool.Pool`, ::"
msgstr ""

#: ../../library/multiprocessing.rst:33
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"
msgstr ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(5) as p:\n"
"        print(p.map(f, [1, 2, 3]))"

#: ../../library/multiprocessing.rst:42
msgid "will print to standard output ::"
msgstr "irá imprimir na saída padrão ::"

#: ../../library/multiprocessing.rst:44
msgid "[1, 4, 9]"
msgstr "[1, 4, 9]"

#: ../../library/multiprocessing.rst:46
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module, like the ability to :meth:`terminate "
"<Process.terminate>`, :meth:`interrupt <Process.interrupt>` or :meth:`kill "
"<Process.kill>` a running process."
msgstr ""

#: ../../library/multiprocessing.rst:53
msgid ""
":class:`concurrent.futures.ProcessPoolExecutor` offers a higher level "
"interface to push tasks to a background process without blocking execution "
"of the calling process. Compared to using the :class:`~multiprocessing.pool."
"Pool` interface directly, the :mod:`concurrent.futures` API more readily "
"allows the submission of work to the underlying process pool to be separated "
"from waiting for the results."
msgstr ""
":class:`concurrent.futures.ProcessPoolExecutor` oferece uma interface de "
"nível superior para enviar tarefas para um processo em segundo plano sem "
"bloquear a execução do processo chamador. Comparado com o uso direto da "
"interface :class:`~multiprocessing.pool.Pool`, a API :mod:`concurrent."
"futures` permite mais facilmente separar o envio de trabalho para o pool de "
"processos da espera pelos resultados."

#: ../../library/multiprocessing.rst:62
msgid "The :class:`Process` class"
msgstr "A classe :class:`Process`"

#: ../../library/multiprocessing.rst:64
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""
"No módulo :mod:`multiprocessing`, os processos são criados através da "
"instanciação de um objeto :class:`Process` e chamando o seu método :meth:"
"`~Process.start`. A classe :class:`Process` segue a API de :class:`threading."
"Thread`. Um exemplo trivial de um programa multiprocesso é ::"

#: ../../library/multiprocessing.rst:69
msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print('olá', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

#: ../../library/multiprocessing.rst:79
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""
"Para mostrar os IDs dos processos individuais envolvidos, aqui está um "
"exemplo expandido::"

#: ../../library/multiprocessing.rst:81
msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('module name:', __name__)\n"
"    print('parent process:', os.getppid())\n"
"    print('process id:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print('hello', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print(title)\n"
"    print('nome do módulo:', __name__)\n"
"    print('processo pai:', os.getppid())\n"
"    print('ID do processo:', os.getpid())\n"
"\n"
"def f(name):\n"
"    info('função f')\n"
"    print('olá', name)\n"
"\n"
"if __name__ == '__main__':\n"
"    info('linha principal')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"

#: ../../library/multiprocessing.rst:100
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"Para uma explicação de porque a parte ``if __name__ == '__main__'`` é "
"necessária, consulte :ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:103
msgid ""
"The arguments to :class:`Process` usually need to be unpickleable from "
"within the child process. If you tried typing the above example directly "
"into a REPL it could lead to an :exc:`AttributeError` in the child process "
"trying to locate the *f* function in the ``__main__`` module."
msgstr ""
"Os argumentos para :class:`Process` geralmente precisam de ser "
"desserializáveis a partir do processo filho. Se tentar escrever o exemplo "
"acima diretamente num REPL, pode levar a um :exc:`AttributeError` no "
"processo filho ao tentar localizar a função *f* no módulo ``__main__``."

#: ../../library/multiprocessing.rst:112
msgid "Contexts and start methods"
msgstr "Contexto e métodos de inicialização"

#: ../../library/multiprocessing.rst:114
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"Dependendo da plataforma, o módulo :mod:`multiprocessing` suporta três "
"formas de iniciar um processo. Estes *métodos de inicialização* são:"

#: ../../library/multiprocessing.rst:119
msgid "*spawn*"
msgstr "*spawn*"

#: ../../library/multiprocessing.rst:120
msgid ""
"The parent process starts a fresh Python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"object's :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using *fork* "
"or *forkserver*."
msgstr ""
"O processo pai inicia um novo processo do interpretador Python. O processo "
"filho apenas herdará os recursos necessários para executar o método :meth:"
"`~Process.run` do objeto do processo. Em particular, descritores de "
"ficheiros e identificadores desnecessários do processo pai não serão "
"herdados. Iniciar um processo usando este método é bastante lento comparado "
"com o uso de *fork* ou *forkserver*."

#: ../../library/multiprocessing.rst:127
msgid ""
"Available on POSIX and Windows platforms.  The default on Windows and macOS."
msgstr ""
"Disponível em plataformas POSIX e Windows. O método predefinido no Windows e "
"macOS."

#: ../../library/multiprocessing.rst:131
msgid "*fork*"
msgstr "*fork*"

#: ../../library/multiprocessing.rst:132
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  The "
"child process, when it begins, is effectively identical to the parent "
"process.  All resources of the parent are inherited by the child process.  "
"Note that safely forking a multithreaded process is problematic."
msgstr ""
"O processo pai usa :func:`os.fork` para bifurcar o interpretador Python. O "
"processo filho, quando inicia, é efetivamente idêntico ao processo pai. "
"Todos os recursos do pai são herdados pelo processo filho. Note que bifurcar "
"um processo multithread de forma segura é problemático."

#: ../../library/multiprocessing.rst:138
msgid ""
"Available on POSIX systems.  Currently the default on POSIX except macOS."
msgstr ""

#: ../../library/multiprocessing.rst:141
msgid ""
"The default start method will change away from *fork* in Python 3.14. Code "
"that requires *fork* should explicitly specify that via :func:`get_context` "
"or :func:`set_start_method`."
msgstr ""

#: ../../library/multiprocessing.rst:145
msgid ""
"If Python is able to detect that your process has multiple threads, the :"
"func:`os.fork` function that this start method calls internally will raise "
"a :exc:`DeprecationWarning`. Use a different start method. See the :func:`os."
"fork` documentation for further explanation."
msgstr ""
"Se o Python conseguir detetar que o seu processo tem múltiplas threads, a "
"função :func:`os.fork`, chamada internamente por este método de "
"inicialização, gerará um :exc:`DeprecationWarning`. Use um método de "
"inicialização diferente. Consulte a documentação de :func:`os.fork` para "
"mais informações."

#: ../../library/multiprocessing.rst:153
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../../library/multiprocessing.rst:154
msgid ""
"When the program starts and selects the *forkserver* start method, a server "
"process is spawned.  From then on, whenever a new process is needed, the "
"parent process connects to the server and requests that it fork a new "
"process.  The fork server process is single threaded unless system libraries "
"or preloaded imports spawn threads as a side-effect so it is generally safe "
"for it to use :func:`os.fork`. No unnecessary resources are inherited."
msgstr ""
"Quando o programa inicia e seleciona o método de inicialização *forkserver*, "
"é criado um processo servidor. A partir daí, sempre que um novo processo é "
"necessário, o processo pai liga-se ao servidor e solicita que este bifurque "
"um novo processo. O processo servidor de bifurcação é monothread, a menos "
"que bibliotecas do sistema ou importações pré-carregadas criem threads como "
"efeito secundário, pelo que é geralmente seguro usar :func:`os.fork`. Nenhum "
"recurso desnecessário é herdado."

#: ../../library/multiprocessing.rst:162
msgid ""
"Available on POSIX platforms which support passing file descriptors over "
"Unix pipes such as Linux."
msgstr ""

#: ../../library/multiprocessing.rst:166
msgid ""
"*spawn* added on all POSIX platforms, and *forkserver* added for some POSIX "
"platforms. Child processes no longer inherit all of the parents inheritable "
"handles on Windows."
msgstr ""
"*spawn* adicionado em todas as plataformas POSIX, e *forkserver* adicionado "
"para algumas plataformas POSIX. Os processos filhos já não herdam todos os "
"identificadores herdáveis do pai no Windows."

#: ../../library/multiprocessing.rst:174
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess as macOS system libraries may start threads. See :issue:`33725`."
msgstr ""
"No macOS, o método de inicialização *spawn* é agora o predefinido. O método "
"*fork* deve ser considerado inseguro, pois pode levar a falhas no "
"subprocesso, uma vez que as bibliotecas do sistema macOS podem iniciar "
"threads. Consulte :issue:`33725`."

#: ../../library/multiprocessing.rst:178
msgid ""
"On POSIX using the *spawn* or *forkserver* start methods will also start a "
"*resource tracker* process which tracks the unlinked named system resources "
"(such as named semaphores or :class:`~multiprocessing.shared_memory."
"SharedMemory` objects) created by processes of the program.  When all "
"processes have exited the resource tracker unlinks any remaining tracked "
"object. Usually there should be none, but if a process was killed by a "
"signal there may be some \"leaked\" resources.  (Neither leaked semaphores "
"nor shared memory segments will be automatically unlinked until the next "
"reboot. This is problematic for both objects because the system allows only "
"a limited number of named semaphores, and shared memory segments occupy some "
"space in the main memory.)"
msgstr ""
"Em POSIX, o uso dos métodos de inicialização *spawn* ou *forkserver* também "
"iniciará um processo *resource tracker* que rastreia os recursos do sistema "
"nomeados não vinculados (como semáforos nomeados ou objetos :class:"
"`~multiprocessing.shared_memory.SharedMemory`) criados pelos processos do "
"programa. Quando todos os processos terminam, o rastreador de recursos "
"desvincula quaisquer objetos rastreados restantes. Normalmente, não deveria "
"haver nenhum, mas se um processo for terminado por um sinal, pode haver "
"alguns recursos \"vazados\". (Nem semáforos vazados nem segmentos de memória "
"partilhada serão automaticamente desvinculados até à próxima "
"reinicialização. Isto é problemático para ambos os objetos, porque o sistema "
"permite apenas um número limitado de semáforos nomeados e os segmentos de "
"memória partilhada ocupam algum espaço na memória principal.)"

#: ../../library/multiprocessing.rst:191
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if "
"__name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"Para selecionar um método de inicialização, use :func:`set_start_method` na "
"cláusula ``if __name__ == '__main__'`` do módulo principal. Por exemplo::"

#: ../../library/multiprocessing.rst:195
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('olá')\n"
"\n"
"if __name__ == '__main__':\n"
"    mp.set_start_method('spawn')\n"
"    q = mp.Queue()\n"
"    p = mp.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

#: ../../library/multiprocessing.rst:208
msgid ""
":func:`set_start_method` should not be used more than once in the program."
msgstr ""
"A função :func:`set_start_method` não deve ser usada mais do que uma vez no "
"programa."

#: ../../library/multiprocessing.rst:211
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context object.  "
"Context objects have the same API as the multiprocessing module, and allow "
"one to use multiple start methods in the same program. ::"
msgstr ""
"Alternativamente, pode usar :func:`get_context` para obter um objeto de "
"contexto. Os objetos de contexto têm a mesma API que o módulo "
"multiprocessing e permitem usar vários métodos de inicialização no mesmo "
"programa. ::"

#: ../../library/multiprocessing.rst:216
msgid ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"
msgstr ""
"import multiprocessing as mp\n"
"\n"
"def foo(q):\n"
"    q.put('olá')\n"
"\n"
"if __name__ == '__main__':\n"
"    ctx = mp.get_context('spawn')\n"
"    q = ctx.Queue()\n"
"    p = ctx.Process(target=foo, args=(q,))\n"
"    p.start()\n"
"    print(q.get())\n"
"    p.join()"

#: ../../library/multiprocessing.rst:229
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using the "
"*fork* context cannot be passed to processes started using the *spawn* or "
"*forkserver* start methods."
msgstr ""
"Note que os objetos relacionados a um contexto podem não ser compatíveis com "
"processos de um contexto diferente. Em particular, bloqueios criados usando "
"o contexto *fork* não podem ser passados para processos iniciados usando os "
"métodos de inicialização *spawn* ou *forkserver*."

#: ../../library/multiprocessing.rst:234
msgid ""
"Libraries using :mod:`multiprocessing` or :class:`~concurrent.futures."
"ProcessPoolExecutor` should be designed to allow their users to provide "
"their own multiprocessing context.  Using a specific context of your own "
"within a library can lead to incompatibilities with the rest of the library "
"user's application.  Always document if your library requires a specific "
"start method."
msgstr ""
"Bibliotecas que usam :mod:`multiprocessing` ou :class:`~concurrent.futures."
"ProcessPoolExecutor` devem ser concebidas para permitir que os seus "
"utilizadores forneçam o seu próprio contexto de multiprocessamento. O uso de "
"um contexto específico dentro de uma biblioteca pode levar a "
"incompatibilidades com o resto da aplicação do utilizador da biblioteca. "
"Documente sempre se a sua biblioteca requer um método de inicialização "
"específico."

#: ../../library/multiprocessing.rst:243
msgid ""
"The ``'spawn'`` and ``'forkserver'`` start methods generally cannot be used "
"with \"frozen\" executables (i.e., binaries produced by packages like "
"**PyInstaller** and **cx_Freeze**) on POSIX systems. The ``'fork'`` start "
"method may work if code does not use threads."
msgstr ""
"Os métodos de inicialização ``'spawn'`` e ``'forkserver'`` geralmente não "
"podem ser usados com executáveis \"congelados\" (ou seja, binários "
"produzidos por pacotes como **PyInstaller** e **cx_Freeze**) em sistemas "
"POSIX. O método de inicialização ``'fork'`` pode funcionar se o código não "
"usar threads."

#: ../../library/multiprocessing.rst:250
msgid "Exchanging objects between processes"
msgstr "Troca de objetos entre processos"

#: ../../library/multiprocessing.rst:252
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""
"O módulo :mod:`multiprocessing` suporta dois tipos de canais de comunicação "
"entre processos:"

#: ../../library/multiprocessing.rst:255
msgid "**Queues**"
msgstr "**Filas**"

#: ../../library/multiprocessing.rst:257
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ""
"A classe :class:`Queue` é quase um clone de :class:`queue.Queue`. Por "
"exemplo::"

#: ../../library/multiprocessing.rst:260
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'olá'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print(q.get())    # imprime \"[42, None, 'olá']\"\n"
"    p.join()"

#: ../../library/multiprocessing.rst:272
msgid ""
"Queues are thread and process safe. Any object put into a :mod:"
"`~multiprocessing` queue will be serialized."
msgstr ""
"As filas são seguras para threads e processos. Qualquer objeto colocado numa "
"fila :mod:`~multiprocessing` será serializado."

#: ../../library/multiprocessing.rst:275
msgid "**Pipes**"
msgstr "**Pipes**"

#: ../../library/multiprocessing.rst:277
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""
"A função :func:`Pipe` devolve um par de objetos de ligação conectados por um "
"pipe que, por predefinição, é duplex (bidirecional). Por exemplo::"

#: ../../library/multiprocessing.rst:280
msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'olá'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print(parent_conn.recv())   # imprime \"[42, None, 'olá']\"\n"
"    p.join()"

#: ../../library/multiprocessing.rst:293
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""
"Os dois objetos de ligação devolvidos por :func:`Pipe` representam as duas "
"extremidades do pipe. Cada objeto de ligação tem os métodos :meth:"
"`~Connection.send` e :meth:`~Connection.recv` (entre outros). Note que os "
"dados num pipe podem ficar corrompidos se dois processos (ou threads) "
"tentarem ler ou escrever na *mesma* extremidade do pipe ao mesmo tempo. "
"Claro que não há risco de corrupção se os processos usarem extremidades "
"diferentes do pipe ao mesmo tempo."

#: ../../library/multiprocessing.rst:301
msgid ""
"The :meth:`~Connection.send` method serializes the object and :meth:"
"`~Connection.recv` re-creates the object."
msgstr ""
"O método :meth:`~Connection.send` serializa o objeto e o método :meth:"
"`~Connection.recv` recria o objeto."

#: ../../library/multiprocessing.rst:305
msgid "Synchronization between processes"
msgstr "Sincronização entre processos"

#: ../../library/multiprocessing.rst:307
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""
"O módulo :mod:`multiprocessing` contém equivalentes a todas as primitivas de "
"sincronização do módulo :mod:`threading`. Por exemplo, pode-se usar um "
"bloqueio para garantir que apenas um processo imprime na saída padrão de "
"cada vez::"

#: ../../library/multiprocessing.rst:311
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('hello world', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    try:\n"
"        print('olá mundo', i)\n"
"    finally:\n"
"        l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"

#: ../../library/multiprocessing.rst:326
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""
"Sem usar o bloqueio, a saída dos diferentes processos pode ficar toda "
"misturada."

#: ../../library/multiprocessing.rst:331
msgid "Sharing state between processes"
msgstr "Partilha de estado entre processos"

#: ../../library/multiprocessing.rst:333
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""
"Como mencionado acima, ao fazer programação concorrente, é geralmente melhor "
"evitar o uso de estado partilhado tanto quanto possível. Isto é "
"especialmente verdadeiro quando se usam vários processos."

#: ../../library/multiprocessing.rst:337
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""
"No entanto, se realmente precisar de usar alguns dados partilhados, o "
"módulo :mod:`multiprocessing` fornece algumas formas de o fazer."

#: ../../library/multiprocessing.rst:340
msgid "**Shared memory**"
msgstr "**Memória partilhada**"

#: ../../library/multiprocessing.rst:342
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""
"Os dados podem ser armazenados num mapa de memória partilhada usando :class:"
"`Value` ou :class:`Array`. Por exemplo, o seguinte código::"

#: ../../library/multiprocessing.rst:345
msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"
msgstr ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(num.value)\n"
"    print(arr[:])"

#: ../../library/multiprocessing.rst:363 ../../library/multiprocessing.rst:409
msgid "will print ::"
msgstr "irá imprimir ::"

#: ../../library/multiprocessing.rst:365
msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"

#: ../../library/multiprocessing.rst:368
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread-safe."
msgstr ""
"Os argumentos ``'d'`` e ``'i'`` usados ao criar ``num`` e ``arr`` são "
"códigos de tipo do tipo usado pelo módulo :mod:`array`: ``'d'`` indica um "
"float de precisão dupla e ``'i'`` indica um inteiro com sinal. Estes objetos "
"partilhados serão seguros para processos e threads."

#: ../../library/multiprocessing.rst:373
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""
"Para maior flexibilidade no uso de memória partilhada, pode-se usar o "
"módulo :mod:`multiprocessing.sharedctypes`, que suporta a criação de objetos "
"ctypes arbitrários alocados a partir de memória partilhada."

#: ../../library/multiprocessing.rst:377
msgid "**Server process**"
msgstr "**Processo servidor**"

#: ../../library/multiprocessing.rst:379
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""
"Um objeto gestor devolvido por :func:`Manager` controla um processo servidor "
"que contém objetos Python e permite que outros processos os manipulem usando "
"proxies."

#: ../../library/multiprocessing.rst:383
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, :"
"class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:"
"`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` and :class:"
"`Array`.  For example, ::"
msgstr ""

#: ../../library/multiprocessing.rst:389
msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"\n"
"if __name__ == '__main__':\n"
"    with Manager() as manager:\n"
"        d = manager.dict()\n"
"        l = manager.list(range(10))\n"
"\n"
"        p = Process(target=f, args=(d, l))\n"
"        p.start()\n"
"        p.join()\n"
"\n"
"        print(d)\n"
"        print(l)"
msgstr ""

#: ../../library/multiprocessing.rst:411
msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
msgstr ""

#: ../../library/multiprocessing.rst:414
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""
"Os gestores de processos servidor são mais flexíveis do que o uso de objetos "
"de memória partilhada, pois podem ser configurados para suportar tipos de "
"objetos arbitrários. Além disso, um único gestor pode ser partilhado por "
"processos em computadores diferentes através de uma rede. No entanto, são "
"mais lentos do que o uso de memória partilhada."

#: ../../library/multiprocessing.rst:421
msgid "Using a pool of workers"
msgstr "Usar um conjunto de trabalhadores"

#: ../../library/multiprocessing.rst:423
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""
"A classe :class:`~multiprocessing.pool.Pool` representa um conjunto de "
"processos trabalhadores. Tem métodos que permitem que tarefas sejam "
"descarregadas para os processos trabalhadores de várias formas."

#: ../../library/multiprocessing.rst:427
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/multiprocessing.rst:429
msgid ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # start 4 worker processes\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # print \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # print same numbers in arbitrary order\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # evaluate \"f(20)\" asynchronously\n"
"        res = pool.apply_async(f, (20,))      # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints \"400\"\n"
"\n"
"        # evaluate \"os.getpid()\" asynchronously\n"
"        res = pool.apply_async(os.getpid, ()) # runs in *only* one process\n"
"        print(res.get(timeout=1))             # prints the PID of that "
"process\n"
"\n"
"        # launching multiple evaluations asynchronously *may* use more "
"processes\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # make a single worker sleep for 10 seconds\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"We lacked patience and got a multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"For the moment, the pool remains available for more work\")\n"
"\n"
"    # exiting the 'with'-block has stopped the pool\n"
"    print(\"Now the pool is closed and no longer available\")"
msgstr ""
"from multiprocessing import Pool, TimeoutError\n"
"import time\n"
"import os\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    # iniciar 4 processos trabalhadores\n"
"    with Pool(processes=4) as pool:\n"
"\n"
"        # imprime \"[0, 1, 4,..., 81]\"\n"
"        print(pool.map(f, range(10)))\n"
"\n"
"        # imprime os mesmos números por ordem arbitrária\n"
"        for i in pool.imap_unordered(f, range(10)):\n"
"            print(i)\n"
"\n"
"        # avalia \"f(20)\" de forma assíncrona\n"
"        res = pool.apply_async(f, (20,))      # executa em *apenas* um "
"processo\n"
"        print(res.get(timeout=1))             # imprime \"400\"\n"
"\n"
"        # avalia \"os.getpid()\" de forma assíncrona\n"
"        res = pool.apply_async(os.getpid, ()) # executa em *apenas* um "
"processo\n"
"        print(res.get(timeout=1))             # imprime o PID desse "
"processo\n"
"\n"
"        # lançar múltiplas avaliações de forma assíncrona *pode* usar mais "
"processos\n"
"        multiple_results = [pool.apply_async(os.getpid, ()) for i in "
"range(4)]\n"
"        print([res.get(timeout=1) for res in multiple_results])\n"
"\n"
"        # faz um trabalhador dormir por 10 segundos\n"
"        res = pool.apply_async(time.sleep, (10,))\n"
"        try:\n"
"            print(res.get(timeout=1))\n"
"        except TimeoutError:\n"
"            print(\"Faltou-nos a paciência e obtivemos um multiprocessing."
"TimeoutError\")\n"
"\n"
"        print(\"Por agora, o conjunto de trabalhadores continua disponível "
"para mais trabalho\")\n"
"\n"
"    # sair do bloco 'with' parou o conjunto de trabalhadores\n"
"    print(\"Agora o conjunto de trabalhadores está fechado e já não está "
"disponível\")"

#: ../../library/multiprocessing.rst:471
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr ""
"Note que os métodos de um conjunto de trabalhadores só devem ser usados pelo "
"processo que o criou."

#: ../../library/multiprocessing.rst:476
msgid ""
"Functionality within this package requires that the ``__main__`` module be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will not "
"work in the interactive interpreter. For example::"
msgstr ""
"A funcionalidade dentro deste pacote requer que o módulo ``__main__`` possa "
"ser importado pelos processos filhos. Isto é abordado em :ref:"
"`multiprocessing-programming`, mas vale a pena salientar aqui. Isto "
"significa que alguns exemplos, como os exemplos de :class:`multiprocessing."
"pool.Pool`, não funcionarão no interpretador interativo. Por exemplo::"

#: ../../library/multiprocessing.rst:482
msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>"
msgstr ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> with p:\n"
"...     p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>\n"
"AttributeError: Can't get attribute 'f' on <module '__main__' (<class "
"'_frozen_importlib.BuiltinImporter'>)>"

#: ../../library/multiprocessing.rst:499
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the parent process "
"somehow.)"
msgstr ""
"(Se tentar isto, irá produzir três tracebacks completos entrelaçados de "
"forma semi-aleatória, e depois pode ter de parar o processo pai de alguma "
"forma.)"

#: ../../library/multiprocessing.rst:505
msgid "Reference"
msgstr "Referência"

#: ../../library/multiprocessing.rst:507
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""
"O pacote :mod:`multiprocessing` replica maioritariamente a API do módulo :"
"mod:`threading`."

#: ../../library/multiprocessing.rst:513
msgid "Global start method"
msgstr ""

#: ../../library/multiprocessing.rst:515
msgid ""
"Python supports several ways to create and initialize a process. The global "
"start method sets the default mechanism for creating a process."
msgstr ""

#: ../../library/multiprocessing.rst:518
msgid ""
"Several multiprocessing functions and methods that may also instantiate "
"certain objects will implicitly set the global start method to the system's "
"default, if it hasn’t been set already. The global start method can only be "
"set once. If you need to change the start method from the system default, "
"you must proactively set the global start method before calling functions or "
"methods, or creating these objects."
msgstr ""

#: ../../library/multiprocessing.rst:527
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process` e exceções"

#: ../../library/multiprocessing.rst:532
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""
"Os objetos Process representam atividade que é executada num processo "
"separado. A classe :class:`Process` tem equivalentes a todos os métodos de :"
"class:`threading.Thread`."

#: ../../library/multiprocessing.rst:536
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name (see :attr:`name` for more details). *args* is "
"the argument tuple for the target invocation.  *kwargs* is a dictionary of "
"keyword arguments for the target invocation.  If provided, the keyword-only "
"*daemon* argument sets the process :attr:`daemon` flag to ``True`` or "
"``False``.  If ``None`` (the default), this flag will be inherited from the "
"creating process."
msgstr ""
"O construtor deve ser sempre chamado com argumentos nomeados. *group* deve "
"ser sempre ``None``; existe apenas para compatibilidade com :class:"
"`threading.Thread`. *target* é o objeto invocável a ser chamado pelo método :"
"meth:`run`. Por predefinição é ``None``, o que significa que nada é chamado. "
"*name* é o nome do processo (consulte :attr:`name` para mais detalhes). "
"*args* é a tupla de argumentos para a invocação do alvo. *kwargs* é um "
"dicionário de argumentos nomeados para a invocação do alvo. Se fornecido, o "
"argumento *daemon* (apenas por palavra-chave) define a flag :attr:`daemon` "
"do processo para ``True`` ou ``False``. Se for ``None`` (predefinição), esta "
"flag será herdada do processo que o criou."

#: ../../library/multiprocessing.rst:547
msgid ""
"By default, no arguments are passed to *target*. The *args* argument, which "
"defaults to ``()``, can be used to specify a list or tuple of the arguments "
"to pass to *target*."
msgstr ""
"Por predefinição, não são passados argumentos para *target*. O argumento "
"*args*, que por predefinição é ``()``, pode ser usado para especificar uma "
"lista ou tupla de argumentos a passar para *target*."

#: ../../library/multiprocessing.rst:551
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (``super().__init__()``) before doing anything else "
"to the process."
msgstr ""
"Se uma subclasse substituir o construtor, deve garantir que invoca o "
"construtor da classe base (``super().__init__()``) antes de fazer qualquer "
"outra coisa com o processo."

#: ../../library/multiprocessing.rst:557
msgid ""
"In general, all arguments to :class:`Process` must be picklable.  This is "
"frequently observed when trying to create a :class:`Process` or use a :class:"
"`concurrent.futures.ProcessPoolExecutor` from a REPL with a locally defined "
"*target* function."
msgstr ""
"Em geral, todos os argumentos para :class:`Process` devem ser serializáveis. "
"Isto é frequentemente observado ao tentar criar um :class:`Process` ou usar "
"um :class:`concurrent.futures.ProcessPoolExecutor` a partir de um REPL com "
"uma função *target* definida localmente."

#: ../../library/multiprocessing.rst:562
msgid ""
"Passing a callable object defined in the current REPL session causes the "
"child process to die via an uncaught :exc:`AttributeError` exception when "
"starting as *target* must have been defined within an importable module in "
"order to be loaded during unpickling."
msgstr ""
"Passar um objeto invocável definido na sessão atual do REPL faz com que o "
"processo filho termine com uma exceção :exc:`AttributeError` não capturada "
"ao iniciar, uma vez que *target* deve ter sido definido dentro de um módulo "
"importável para ser carregado durante a desserialização."

#: ../../library/multiprocessing.rst:567
msgid "Example of this uncatchable error from the child::"
msgstr "Exemplo deste erro não capturável do processo filho::"

#: ../../library/multiprocessing.rst:569
msgid ""
">>> import multiprocessing as mp\n"
">>> def knigit():\n"
"...     print(\"Ni!\")\n"
"...\n"
">>> process = mp.Process(target=knigit)\n"
">>> process.start()\n"
">>> Traceback (most recent call last):\n"
"  File \".../multiprocessing/spawn.py\", line ..., in spawn_main\n"
"  File \".../multiprocessing/spawn.py\", line ..., in _main\n"
"AttributeError: module '__main__' has no attribute 'knigit'\n"
">>> process\n"
"<SpawnProcess name='SpawnProcess-1' pid=379473 parent=378707 stopped "
"exitcode=1>"
msgstr ""
">>> import multiprocessing as mp\n"
">>> def knigit():\n"
"...     print(\"Ni!\")\n"
"...\n"
">>> process = mp.Process(target=knigit)\n"
">>> process.start()\n"
">>> Traceback (most recent call last):\n"
"  File \".../multiprocessing/spawn.py\", line ..., in spawn_main\n"
"  File \".../multiprocessing/spawn.py\", line ..., in _main\n"
"AttributeError: module '__main__' has no attribute 'knigit'\n"
">>> process\n"
"<SpawnProcess name='SpawnProcess-1' pid=379473 parent=378707 stopped "
"exitcode=1>"

#: ../../library/multiprocessing.rst:582
msgid ""
"See :ref:`multiprocessing-programming-spawn`.  While this restriction is not "
"true if using the ``\"fork\"`` start method, as of Python ``3.14`` that is "
"no longer the default on any platform.  See :ref:`multiprocessing-start-"
"methods`. See also :gh:`132898`."
msgstr ""
"Consulte :ref:`multiprocessing-programming-spawn`. Embora esta restrição não "
"seja verdadeira se usar o método de inicialização ``\"fork\"``, a partir do "
"Python ``3.14`` este já não é o predefinido em nenhuma plataforma. Consulte :"
"ref:`multiprocessing-start-methods`. Veja também :gh:`132898`."

#: ../../library/multiprocessing.rst:588
msgid "Added the *daemon* parameter."
msgstr "Adicionado o parâmetro *daemon*."

#: ../../library/multiprocessing.rst:593
msgid "Method representing the process's activity."
msgstr "Método que representa a atividade do processo."

#: ../../library/multiprocessing.rst:595
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""
"Pode substituir este método numa subclasse. O método :meth:`run` padrão "
"invoca o objeto invocável passado ao construtor do objeto como argumento "
"*target*, se houver, com argumentos sequenciais e nomeados retirados dos "
"argumentos *args* e *kwargs*, respetivamente."

#: ../../library/multiprocessing.rst:600
msgid ""
"Using a list or tuple as the *args* argument passed to :class:`Process` "
"achieves the same effect."
msgstr ""
"Usar uma lista ou tuplo como argumento *args* passado para :class:`Process` "
"alcança o mesmo efeito."

#: ../../library/multiprocessing.rst:603
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/multiprocessing.rst:605
msgid ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"
msgstr ""
">>> from multiprocessing import Process\n"
">>> p = Process(target=print, args=[1])\n"
">>> p.run()\n"
"1\n"
">>> p = Process(target=print, args=(1,))\n"
">>> p.run()\n"
"1"

#: ../../library/multiprocessing.rst:615
msgid "Start the process's activity."
msgstr "Iniciar a atividade do processo."

#: ../../library/multiprocessing.rst:617
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"Isto deve ser chamado no máximo uma vez por objeto de processo. Organiza "
"para que o método :meth:`run` do objeto seja invocado num processo separado."

#: ../../library/multiprocessing.rst:622
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. If "
"*timeout* is a positive number, it blocks at most *timeout* seconds. Note "
"that the method returns ``None`` if its process terminates or if the method "
"times out.  Check the process's :attr:`exitcode` to determine if it "
"terminated."
msgstr ""
"Se o argumento opcional *timeout* for ``None`` (predefinição), o método "
"bloqueia até que o processo cujo método :meth:`join` é chamado termine. Se "
"*timeout* for um número positivo, bloqueia no máximo *timeout* segundos. "
"Note que o método devolve ``None`` se o processo terminar ou se o método "
"atingir o tempo limite. Verifique o :attr:`exitcode` do processo para "
"determinar se este terminou."

#: ../../library/multiprocessing.rst:629
msgid "A process can be joined many times."
msgstr "Um processo pode ser aguardado várias vezes."

#: ../../library/multiprocessing.rst:631
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""
"Um processo não pode aguardar por si próprio, pois isso causaria um impasse. "
"É um erro tentar aguardar por um processo antes de este ter sido iniciado."

#: ../../library/multiprocessing.rst:636
msgid ""
"The process's name.  The name is a string used for identification purposes "
"only.  It has no semantics.  Multiple processes may be given the same name."
msgstr ""
"O nome do processo. O nome é uma string usada apenas para fins de "
"identificação. Não tem semântica. Vários processos podem ter o mesmo nome."

#: ../../library/multiprocessing.rst:640
msgid ""
"The initial name is set by the constructor.  If no explicit name is provided "
"to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\ :sub:"
"`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is the N-th "
"child of its parent."
msgstr ""
"O nome inicial é definido pelo construtor. Se nenhum nome explícito for "
"fornecido ao construtor, é construído um nome da forma 'Process-N\\ :sub:`1`:"
"N\\ :sub:`2`:...:N\\ :sub:`k`', onde cada N\\ :sub:`k` é o N-ésimo filho do "
"seu pai."

#: ../../library/multiprocessing.rst:647
msgid "Return whether the process is alive."
msgstr "Devolve se o processo está ativo."

#: ../../library/multiprocessing.rst:649
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""
"Grosseiramente, um objeto de processo está ativo desde o momento em que o "
"método :meth:`start` retorna até que o processo filho termine."

#: ../../library/multiprocessing.rst:654
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""
"A flag de daemon do processo, um valor booleano. Isto deve ser definido "
"antes de :meth:`start` ser chamado."

#: ../../library/multiprocessing.rst:657
msgid "The initial value is inherited from the creating process."
msgstr "O valor inicial é herdado do processo que o criou."

#: ../../library/multiprocessing.rst:659
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""
"Quando um processo termina, tenta terminar todos os seus processos filhos "
"daemónicos."

#: ../../library/multiprocessing.rst:662
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-daemonic processes have exited."
msgstr ""
"Note que um processo daemónico não pode criar processos filhos. Caso "
"contrário, um processo daemónico deixaria os seus filhos órfãos se fosse "
"terminado quando o seu processo pai terminasse. Além disso, estes **não** "
"são daemons Unix ou serviços, são processos normais que serão terminados (e "
"não aguardados) se os processos não daemónicos tiverem terminado."

#: ../../library/multiprocessing.rst:668
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""
"Além da API :class:`threading.Thread`, os objetos :class:`Process` também "
"suportam os seguintes atributos e métodos:"

#: ../../library/multiprocessing.rst:673
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""
"Devolve o ID do processo. Antes do processo ser criado, isto será ``None``."

#: ../../library/multiprocessing.rst:678
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated."
msgstr ""
"O código de saída do processo filho. Isto será ``None`` se o processo ainda "
"não terminou."

#: ../../library/multiprocessing.rst:681
msgid ""
"If the child's :meth:`run` method returned normally, the exit code will be "
"0.  If it terminated via :func:`sys.exit` with an integer argument *N*, the "
"exit code will be *N*."
msgstr ""
"Se o método :meth:`run` do processo filho retornar normalmente, o código de "
"saída será 0. Se terminar através de :func:`sys.exit` com um argumento "
"inteiro *N*, o código de saída será *N*."

#: ../../library/multiprocessing.rst:685
msgid ""
"If the child terminated due to an exception not caught within :meth:`run`, "
"the exit code will be 1.  If it was terminated by signal *N*, the exit code "
"will be the negative value *-N*."
msgstr ""
"Se o processo filho terminar devido a uma exceção não capturada dentro de :"
"meth:`run`, o código de saída será 1. Se for terminado por um sinal *N*, o "
"código de saída será o valor negativo *-N*."

#: ../../library/multiprocessing.rst:691
msgid "The process's authentication key (a byte string)."
msgstr "A chave de autenticação do processo (uma string de bytes)."

#: ../../library/multiprocessing.rst:693
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.urandom`."
msgstr ""
"Quando :mod:`multiprocessing` é inicializado, é atribuída uma string "
"aleatória ao processo principal usando :func:`os.urandom`."

#: ../../library/multiprocessing.rst:696
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""
"Quando um objeto :class:`Process` é criado, herdará a chave de autenticação "
"do seu processo pai, embora isto possa ser alterado definindo :attr:"
"`authkey` para outra string de bytes."

#: ../../library/multiprocessing.rst:700
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr "Consulte :ref:`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:704
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr ""
"Um identificador numérico de um objeto do sistema que ficará \"pronto\" "
"quando o processo terminar."

#: ../../library/multiprocessing.rst:707
msgid ""
"You can use this value if you want to wait on several events at once using :"
"func:`multiprocessing.connection.wait`.  Otherwise calling :meth:`join` is "
"simpler."
msgstr ""
"Pode usar este valor se quiser aguardar vários eventos de uma vez usando :"
"func:`multiprocessing.connection.wait`. Caso contrário, chamar :meth:`join` "
"é mais simples."

#: ../../library/multiprocessing.rst:711
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` and "
"``WaitForMultipleObjects`` family of API calls.  On POSIX, this is a file "
"descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"No Windows, este é um identificador do sistema utilizável com as chamadas de "
"API da família ``WaitForSingleObject`` e ``WaitForMultipleObjects``. Em "
"POSIX, este é um descritor de ficheiro utilizável com primitivas do módulo :"
"mod:`select`."

#: ../../library/multiprocessing.rst:719
msgid ""
"Terminate the process.  On POSIX this is done using the :py:const:`~signal."
"SIGTERM` signal; on Windows :c:func:`!TerminateProcess` is used.  Note that "
"exit handlers and finally clauses, etc., will not be executed."
msgstr ""
"Termina o processo. Em POSIX, isto é feito usando o sinal :py:const:`~signal."
"SIGTERM`; no Windows, é usada a função :c:func:`!TerminateProcess`. Note que "
"os manipuladores de saída e cláusulas finally, etc., não serão executados."

#: ../../library/multiprocessing.rst:723
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""
"Note que os processos descendentes do processo **não** serão terminados -- "
"eles simplesmente ficarão órfãos."

#: ../../library/multiprocessing.rst:728
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""
"Se este método for usado enquanto o processo associado estiver a usar um "
"pipe ou uma fila, o pipe ou a fila podem ficar corrompidos e tornar-se "
"inutilizáveis por outros processos. Da mesma forma, se o processo tiver "
"adquirido um bloqueio ou semáforo, etc., terminá-lo pode causar impasse "
"noutros processos."

#: ../../library/multiprocessing.rst:736
msgid "Same as :meth:`terminate` but using the ``SIGKILL`` signal on POSIX."
msgstr "Igual a :meth:`terminate`, mas usando o sinal ``SIGKILL`` em POSIX."

#: ../../library/multiprocessing.rst:742
msgid ""
"Close the :class:`Process` object, releasing all resources associated with "
"it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and "
"attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
"Fecha o objeto :class:`Process`, libertando todos os recursos associados a "
"ele. É gerada uma exceção :exc:`ValueError` se o processo subjacente ainda "
"estiver em execução. Após o :meth:`close` retornar com sucesso, a maioria "
"dos outros métodos e atributos do objeto :class:`Process` gerará :exc:"
"`ValueError`."

#: ../../library/multiprocessing.rst:750
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` and :attr:`exitcode` methods should only be called by the "
"process that created the process object."
msgstr ""
"Note que os métodos :meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:"
"`terminate` e o atributo :attr:`exitcode` só devem ser chamados pelo "
"processo que criou o objeto do processo."

#: ../../library/multiprocessing.rst:754
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr "Exemplo de utilização de alguns dos métodos de :class:`Process`:"

#: ../../library/multiprocessing.rst:756
msgid ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""
">>> import multiprocessing, time, signal\n"
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> p = mp_context.Process(target=time.sleep, args=(1000,))\n"
">>> print(p, p.is_alive())\n"
"<...Process ... initial> False\n"
">>> p.start()\n"
">>> print(p, p.is_alive())\n"
"<...Process ... started> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print(p, p.is_alive())\n"
"<...Process ... stopped exitcode=-SIGTERM> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"

#: ../../library/multiprocessing.rst:775
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "A classe base de todas as exceções de :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:779
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into` when the supplied "
"buffer object is too small for the message read."
msgstr ""
"Exceção gerada por :meth:`Connection.recv_bytes_into` quando o objeto buffer "
"fornecido é demasiado pequeno para a mensagem lida."

#: ../../library/multiprocessing.rst:782
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"Se ``e`` for uma instância de :exc:`BufferTooShort`, então ``e.args[0]`` "
"devolverá a mensagem como uma string de bytes."

#: ../../library/multiprocessing.rst:787
msgid "Raised when there is an authentication error."
msgstr "Gerada quando ocorre um erro de autenticação."

#: ../../library/multiprocessing.rst:791
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "Gerada por métodos com timeout quando o timeout expira."

#: ../../library/multiprocessing.rst:794
msgid "Pipes and Queues"
msgstr "Pipes e Filas"

#: ../../library/multiprocessing.rst:796
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""
"Ao usar vários processos, geralmente usa-se a passagem de mensagens para "
"comunicação entre processos e evita-se o uso de primitivas de sincronização, "
"como bloqueios."

#: ../../library/multiprocessing.rst:800
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""
"Para passar mensagens, pode-se usar :func:`Pipe` (para uma ligação entre "
"dois processos) ou uma fila (que permite vários produtores e consumidores)."

#: ../../library/multiprocessing.rst:803
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types "
"are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` queues "
"modelled on the :class:`queue.Queue` class in the standard library.  They "
"differ in that :class:`Queue` lacks the :meth:`~queue.Queue.task_done` and :"
"meth:`~queue.Queue.join` methods introduced into Python 2.5's :class:`queue."
"Queue` class."
msgstr ""
"Os tipos :class:`Queue`, :class:`SimpleQueue` e :class:`JoinableQueue` são "
"filas :abbr:`FIFO (first-in, first-out)` multi-produtor, multi-consumidor, "
"modeladas na classe :class:`queue.Queue` da biblioteca padrão. Diferem no "
"facto de :class:`Queue` não ter os métodos :meth:`~queue.Queue.task_done` e :"
"meth:`~queue.Queue.join`, introduzidos na classe :class:`queue.Queue` do "
"Python 2.5."

#: ../../library/multiprocessing.rst:810
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow, raising an exception."
msgstr ""
"Se usar :class:`JoinableQueue`, **deve** chamar :meth:`JoinableQueue."
"task_done` para cada tarefa removida da fila, caso contrário o semáforo "
"usado para contar o número de tarefas não concluídas pode eventualmente "
"transbordar, gerando uma exceção."

#: ../../library/multiprocessing.rst:815
msgid ""
"One difference from other Python queue implementations, is that :mod:"
"`multiprocessing` queues serializes all objects that are put into them "
"using :mod:`pickle`. The object return by the get method is a re-created "
"object that does not share memory with the original object."
msgstr ""
"Uma diferença em relação a outras implementações de filas em Python é que as "
"filas de :mod:`multiprocessing` serializam todos os objetos que são "
"colocados nelas usando :mod:`pickle`. O objeto devolvido pelo método get é "
"um objeto recriado que não partilha memória com o objeto original."

#: ../../library/multiprocessing.rst:820
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""
"Note que também é possível criar uma fila partilhada usando um objeto gestor "
"-- consulte :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:825
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and :exc:`queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`queue`."
msgstr ""
"O módulo :mod:`multiprocessing` usa as exceções habituais :exc:`queue.Empty` "
"e :exc:`queue.Full` para sinalizar um timeout. Elas não estão disponíveis no "
"espaço de nomes :mod:`multiprocessing`, pelo que é necessário importá-las "
"de :mod:`queue`."

#: ../../library/multiprocessing.rst:832
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has some "
"consequences which are a little surprising, but should not cause any "
"practical difficulties -- if they really bother you then you can instead use "
"a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"Quando um objeto é colocado numa fila, o objeto é serializado e uma thread "
"em segundo plano escreve os dados serializados num pipe subjacente. Isto tem "
"algumas consequências um pouco surpreendentes, mas não deve causar "
"dificuldades práticas -- se isto o incomodar, pode em vez disso usar uma "
"fila criada com um :ref:`gestor <multiprocessing-managers>`."

#: ../../library/multiprocessing.rst:839
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns :const:`False` "
"and :meth:`~Queue.get_nowait` can return without raising :exc:`queue.Empty`."
msgstr ""
"Após colocar um objeto numa fila vazia, pode haver um atraso infinitesimal "
"antes do método :meth:`~Queue.empty` da fila devolver :const:`False` e o :"
"meth:`~Queue.get_nowait` poder devolver sem gerar :exc:`queue.Empty`."

#: ../../library/multiprocessing.rst:844
msgid ""
"If multiple processes are enqueuing objects, it is possible for the objects "
"to be received at the other end out-of-order. However, objects enqueued by "
"the same process will always be in the expected order with respect to each "
"other."
msgstr ""
"Se vários processos estiverem a enfileirar objetos, é possível que os "
"objetos sejam recebidos na outra extremidade fora de ordem. No entanto, os "
"objetos enfileirados pelo mesmo processo estarão sempre na ordem esperada em "
"relação uns aos outros."

#: ../../library/multiprocessing.rst:851
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other process to get an "
"exception when it tries to use the queue later on."
msgstr ""
"Se um processo for terminado usando :meth:`Process.terminate` ou :func:`os."
"kill` enquanto estiver a tentar usar uma :class:`Queue`, os dados na fila "
"podem ficar corrompidos. Isto pode fazer com que qualquer outro processo "
"obtenha uma exceção quando tentar usar a fila mais tarde."

#: ../../library/multiprocessing.rst:858
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread <multiprocessing.Queue."
"cancel_join_thread>`), then that process will not terminate until all "
"buffered items have been flushed to the pipe."
msgstr ""
"Como mencionado acima, se um processo filho tiver colocado itens numa fila "
"(e não tiver usado :meth:`JoinableQueue.cancel_join_thread <multiprocessing."
"Queue.cancel_join_thread>`), então esse processo não terminará até que todos "
"os itens em buffer tenham sido escritos no pipe."

#: ../../library/multiprocessing.rst:863
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""
"Isto significa que, se tentar aguardar pela conclusão desse processo, pode "
"obter um impasse, a menos que tenha a certeza de que todos os itens "
"colocados na fila foram consumidos. Da mesma forma, se o processo filho não "
"for daemónico, o processo pai pode ficar bloqueado na saída quando tentar "
"aguardar por todos os seus processos filhos não daemónicos."

#: ../../library/multiprocessing.rst:868
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""
"Note que uma fila criada usando um gestor não tem este problema. Consulte :"
"ref:`multiprocessing-programming`."

#: ../../library/multiprocessing.rst:871
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""
"Para um exemplo de utilização de filas para comunicação entre processos, "
"consulte :ref:`multiprocessing-examples`."

#: ../../library/multiprocessing.rst:877
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`~multiprocessing.connection."
"Connection` objects representing the ends of a pipe."
msgstr ""
"Devolve um par ``(conn1, conn2)`` de objetos :class:`~multiprocessing."
"connection.Connection` que representam as extremidades de um pipe."

#: ../../library/multiprocessing.rst:881
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""
"Se *duplex* for ``True`` (predefinição), então o pipe é bidirecional. Se "
"*duplex* for ``False``, então o pipe é unidirecional: ``conn1`` só pode ser "
"usado para receber mensagens e ``conn2`` só pode ser usado para enviar "
"mensagens."

#: ../../library/multiprocessing.rst:886
msgid ""
"The :meth:`~multiprocessing.Connection.send` method serializes the object "
"using :mod:`pickle` and the :meth:`~multiprocessing.Connection.recv` re-"
"creates the object."
msgstr ""
"O método :meth:`~multiprocessing.Connection.send` serializa o objeto usando :"
"mod:`pickle` e o método :meth:`~multiprocessing.Connection.recv` recria o "
"objeto."

#: ../../library/multiprocessing.rst:891
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""
"Devolve uma fila partilhada entre processos implementada usando um pipe e "
"alguns bloqueios/semáforos. Quando um processo coloca um item na fila pela "
"primeira vez, é iniciada uma thread de alimentação que transfere objetos de "
"um buffer para o pipe."

#: ../../library/multiprocessing.rst:895 ../../library/multiprocessing.rst:1013
#: ../../library/multiprocessing.rst:1046
#: ../../library/multiprocessing.rst:1402
#: ../../library/multiprocessing.rst:1412
#: ../../library/multiprocessing.rst:1429
#: ../../library/multiprocessing.rst:1439
#: ../../library/multiprocessing.rst:1456
#: ../../library/multiprocessing.rst:1509
#: ../../library/multiprocessing.rst:1564
msgid ""
"Instantiating this class may set the global start method. See :ref:`global-"
"start-method` for more details."
msgstr ""

#: ../../library/multiprocessing.rst:898
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"As exceções habituais :exc:`queue.Empty` e :exc:`queue.Full` do módulo :mod:"
"`queue` da biblioteca padrão são geradas para sinalizar timeouts."

#: ../../library/multiprocessing.rst:901
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` implementa todos os métodos de :class:`queue.Queue`, exceto :"
"meth:`~queue.Queue.task_done` e :meth:`~queue.Queue.join`."

#: ../../library/multiprocessing.rst:906
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""
"Devolve o tamanho aproximado da fila. Devido à semântica de multithreading/"
"multiprocessing, este número não é fiável."

#: ../../library/multiprocessing.rst:909
msgid ""
"Note that this may raise :exc:`NotImplementedError` on platforms like macOS "
"where ``sem_getvalue()`` is not implemented."
msgstr ""
"Note que isto pode gerar :exc:`NotImplementedError` em plataformas como "
"macOS, onde ``sem_getvalue()`` não está implementado."

#: ../../library/multiprocessing.rst:914
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Devolve ``True`` se a fila estiver vazia, ``False`` caso contrário. Devido à "
"semântica de multithreading/multiprocessing, isto não é fiável."

#: ../../library/multiprocessing.rst:917
msgid "May raise an :exc:`OSError` on closed queues. (not guaranteed)"
msgstr ""
"Pode gerar uma exceção :exc:`OSError` em filas fechadas. (não garantido)"

#: ../../library/multiprocessing.rst:921
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"Devolve ``True`` se a fila estiver cheia, ``False`` caso contrário. Devido à "
"semântica de multithreading/multiprocessing, isto não é fiável."

#: ../../library/multiprocessing.rst:926
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""
"Coloca *obj* na fila. Se o argumento opcional *block* for ``True`` "
"(predefinição) e *timeout* for ``None`` (predefinição), bloqueia se "
"necessário até que um espaço livre esteja disponível. Se *timeout* for um "
"número positivo, bloqueia no máximo *timeout* segundos e gera a exceção :exc:"
"`queue.Full` se nenhum espaço livre estiver disponível dentro desse tempo. "
"Caso contrário (*block* é ``False``), coloca um item na fila se um espaço "
"livre estiver imediatamente disponível, caso contrário gera a exceção :exc:"
"`queue.Full` (*timeout* é ignorado nesse caso)."

#: ../../library/multiprocessing.rst:935
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Se a fila estiver fechada, é gerada :exc:`ValueError` em vez de :exc:"
"`AssertionError`."

#: ../../library/multiprocessing.rst:941
msgid "Equivalent to ``put(obj, False)``."
msgstr "Equivalente a ``put(obj, False)``."

#: ../../library/multiprocessing.rst:945
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"Remove e devolve um item da fila. Se o argumento opcional *block* for "
"``True`` (predefinição) e *timeout* for ``None`` (predefinição), bloqueia se "
"necessário até que um item esteja disponível. Se *timeout* for um número "
"positivo, bloqueia no máximo *timeout* segundos e gera a exceção :exc:`queue."
"Empty` se nenhum item estiver disponível dentro desse tempo. Caso contrário "
"(*block* é ``False``), devolve um item se um estiver imediatamente "
"disponível, caso contrário gera a exceção :exc:`queue.Empty` (*timeout* é "
"ignorado nesse caso)."

#: ../../library/multiprocessing.rst:953
msgid ""
"If the queue is closed, :exc:`ValueError` is raised instead of :exc:"
"`OSError`."
msgstr ""
"Se a fila estiver fechada, é gerada :exc:`ValueError` em vez de :exc:"
"`OSError`."

#: ../../library/multiprocessing.rst:959
msgid "Equivalent to ``get(False)``."
msgstr "Equivalente a ``get(False)``."

#: ../../library/multiprocessing.rst:961
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""
":class:`multiprocessing.Queue` tem alguns métodos adicionais não encontrados "
"em :class:`queue.Queue`. Estes métodos são geralmente desnecessários para a "
"maioria do código:"

#: ../../library/multiprocessing.rst:967 ../../library/multiprocessing.rst:1018
msgid "Close the queue: release internal resources."
msgstr "Fecha a fila: libera recursos internos."

#: ../../library/multiprocessing.rst:969
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`~Queue.get`, :meth:`~Queue.put` and :meth:`~Queue.empty` methods must no "
"longer be called."
msgstr ""
"Uma fila não deve ser usada após ser fechada. Por exemplo, os métodos :meth:"
"`~Queue.get`, :meth:`~Queue.put` e :meth:`~Queue.empty` não devem mais ser "
"chamados."

#: ../../library/multiprocessing.rst:973
msgid ""
"The background thread will quit once it has flushed all buffered data to the "
"pipe.  This is called automatically when the queue is garbage collected."
msgstr ""
"A thread em segundo plano sairá assim que tiver escrito todos os dados em "
"buffer no pipe. Isto é chamado automaticamente quando a fila é recolhida "
"pelo garbage collector."

#: ../../library/multiprocessing.rst:979
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""
"Aguarda pela thread em segundo plano. Isto só pode ser usado após :meth:"
"`close` ter sido chamado. Bloqueia até que a thread em segundo plano "
"termine, garantindo que todos os dados no buffer tenham sido escritos no "
"pipe."

#: ../../library/multiprocessing.rst:983
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"Por predefinição, se um processo não for o criador da fila, ao terminar "
"tentará aguardar pela thread em segundo plano da fila. O processo pode "
"chamar :meth:`cancel_join_thread` para fazer com que :meth:`join_thread` não "
"faça nada."

#: ../../library/multiprocessing.rst:989
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""
"Impede que :meth:`join_thread` bloqueie. Em particular, isto impede que a "
"thread em segundo plano seja aguardada automaticamente quando o processo "
"termina -- consulte :meth:`join_thread`."

#: ../../library/multiprocessing.rst:993
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  It "
"is likely to cause enqueued data to be lost, and you almost certainly will "
"not need to use it. It is really only there if you need the current process "
"to exit immediately without waiting to flush enqueued data to the underlying "
"pipe, and you don't care about lost data."
msgstr ""
"Um nome melhor para este método poderia ser ``allow_exit_without_flush()``. "
"É provável que cause a perda de dados enfileirados, e quase certamente não "
"precisará de o usar. Está realmente apenas disponível se precisar que o "
"processo atual termine imediatamente sem esperar para escrever os dados "
"enfileirados no pipe subjacente, e não se importar com a perda de dados."

#: ../../library/multiprocessing.rst:1002
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the functionality "
"in this class will be disabled, and attempts to instantiate a :class:`Queue` "
"will result in an :exc:`ImportError`. See :issue:`3770` for additional "
"information.  The same holds true for any of the specialized queue types "
"listed below."
msgstr ""
"A funcionalidade desta classe requer uma implementação funcional de "
"semáforos partilhados no sistema operativo anfitrião. Sem ela, a "
"funcionalidade desta classe será desativada, e tentativas de instanciar uma :"
"class:`Queue` resultarão num :exc:`ImportError`. Consulte :issue:`3770` para "
"informações adicionais. O mesmo aplica-se a qualquer um dos tipos de fila "
"especializados listados abaixo."

#: ../../library/multiprocessing.rst:1011
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked :class:`Pipe`."
msgstr ""
"É um tipo de :class:`Queue` simplificado, muito próximo de um :class:`Pipe` "
"bloqueado."

#: ../../library/multiprocessing.rst:1020
msgid ""
"A queue must not be used anymore after it is closed. For example, :meth:"
"`get`, :meth:`put` and :meth:`empty` methods must no longer be called."
msgstr ""
"Uma fila não deve ser usada após ser fechada. Por exemplo, os métodos :meth:"
"`get`, :meth:`put` e :meth:`empty` não devem mais ser chamados."

#: ../../library/multiprocessing.rst:1028
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "Devolve ``True`` se a fila estiver vazia, ``False`` caso contrário."

#: ../../library/multiprocessing.rst:1030
msgid "Always raises an :exc:`OSError` if the SimpleQueue is closed."
msgstr ""
"Sempre gera uma exceção :exc:`OSError` se a SimpleQueue estiver fechada."

#: ../../library/multiprocessing.rst:1034
msgid "Remove and return an item from the queue."
msgstr "Remove e devolve um item da fila."

#: ../../library/multiprocessing.rst:1038
msgid "Put *item* into the queue."
msgstr "Coloca *item* na fila."

#: ../../library/multiprocessing.rst:1043
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`JoinableQueue`, uma subclasse de :class:`Queue`, é uma fila que tem "
"adicionalmente os métodos :meth:`task_done` e :meth:`join`."

#: ../../library/multiprocessing.rst:1051
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""
"Indica que uma tarefa anteriormente enfileirada está completa. Usado pelos "
"consumidores da fila. Para cada :meth:`~Queue.get` usado para buscar uma "
"tarefa, uma chamada subsequente a :meth:`task_done` informa a fila de que o "
"processamento da tarefa está completo."

#: ../../library/multiprocessing.rst:1056
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when "
"all items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""
"Se um :meth:`~queue.Queue.join` estiver atualmente bloqueado, retomará "
"quando todos os itens tiverem sido processados (significando que uma "
"chamada :meth:`task_done` foi recebida para cada item que foi :meth:`~Queue."
"put` na fila)."

#: ../../library/multiprocessing.rst:1060
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""
"Gera uma exceção :exc:`ValueError` se for chamado mais vezes do que o número "
"de itens colocados na fila."

#: ../../library/multiprocessing.rst:1066
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""
"Bloqueia até que todos os itens na fila tenham sido obtidos e processados."

#: ../../library/multiprocessing.rst:1068
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` to "
"indicate that the item was retrieved and all work on it is complete.  When "
"the count of unfinished tasks drops to zero, :meth:`~queue.Queue.join` "
"unblocks."
msgstr ""
"A contagem de tarefas não concluídas aumenta sempre que um item é adicionado "
"à fila. A contagem diminui sempre que um consumidor chama :meth:`task_done` "
"para indicar que o item foi recuperado e todo o trabalho nele está completo. "
"Quando a contagem de tarefas não concluídas chega a zero, :meth:`~queue."
"Queue.join` desbloqueia."

#: ../../library/multiprocessing.rst:1076
msgid "Miscellaneous"
msgstr "Diversos"

#: ../../library/multiprocessing.rst:1080
msgid "Return list of all live children of the current process."
msgstr ""
"Devolve uma lista de todos os processos filhos ativos do processo atual."

#: ../../library/multiprocessing.rst:1082
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr ""
"Chamar isto tem o efeito secundário de \"aguardar\" por quaisquer processos "
"que já tenham terminado."

#: ../../library/multiprocessing.rst:1087
msgid "Return the number of CPUs in the system."
msgstr "Devolve o número de CPUs no sistema."

#: ../../library/multiprocessing.rst:1089
msgid ""
"This number is not equivalent to the number of CPUs the current process can "
"use.  The number of usable CPUs can be obtained with :func:`os."
"process_cpu_count` (or ``len(os.sched_getaffinity(0))``)."
msgstr ""
"Este número não é equivalente ao número de CPUs que o processo atual pode "
"usar. O número de CPUs utilizáveis pode ser obtido com :func:`os."
"process_cpu_count` (ou ``len(os.sched_getaffinity(0))``)."

#: ../../library/multiprocessing.rst:1093
msgid ""
"When the number of CPUs cannot be determined a :exc:`NotImplementedError` is "
"raised."
msgstr ""
"Quando o número de CPUs não pode ser determinado, é gerada uma exceção :exc:"
"`NotImplementedError`."

#: ../../library/multiprocessing.rst:1097
msgid ":func:`os.cpu_count` :func:`os.process_cpu_count`"
msgstr ":func:`os.cpu_count` :func:`os.process_cpu_count`"

#: ../../library/multiprocessing.rst:1102
msgid ""
"The return value can also be overridden using the :option:`-X cpu_count <-"
"X>` flag or :envvar:`PYTHON_CPU_COUNT` as this is merely a wrapper around "
"the :mod:`os` cpu count APIs."
msgstr ""
"O valor de retorno também pode ser substituído usando a flag :option:`-X "
"cpu_count <-X>` ou a variável de ambiente :envvar:`PYTHON_CPU_COUNT`, uma "
"vez que isto é apenas um wrapper em torno das APIs de contagem de CPUs do "
"módulo :mod:`os`."

#: ../../library/multiprocessing.rst:1108
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr "Devolve o objeto :class:`Process` correspondente ao processo atual."

#: ../../library/multiprocessing.rst:1110
msgid "An analogue of :func:`threading.current_thread`."
msgstr "Um análogo de :func:`threading.current_thread`."

#: ../../library/multiprocessing.rst:1114
msgid ""
"Return the :class:`Process` object corresponding to the parent process of "
"the :func:`current_process`. For the main process, ``parent_process`` will "
"be ``None``."
msgstr ""
"Devolve o objeto :class:`Process` correspondente ao processo pai de :func:"
"`current_process`. Para o processo principal, ``parent_process`` será "
"``None``."

#: ../../library/multiprocessing.rst:1122
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce an executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""
"Adiciona suporte para quando um programa que usa :mod:`multiprocessing` foi "
"congelado para produzir um executável. (Foi testado com **py2exe**, "
"**PyInstaller** e **cx_Freeze**.)"

#: ../../library/multiprocessing.rst:1126
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""
"É necessário chamar esta função logo após a linha ``if __name__ == "
"'__main__'`` do módulo principal. Por exemplo::"

#: ../../library/multiprocessing.rst:1129
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('hello world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print('olá mundo!')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"

#: ../../library/multiprocessing.rst:1138
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""
"Se a linha ``freeze_support()`` for omitida, tentar executar o executável "
"congelado gerará uma exceção :exc:`RuntimeError`."

#: ../../library/multiprocessing.rst:1141
msgid ""
"Calling ``freeze_support()`` has no effect when the start method is not "
"*spawn*. In addition, if the module is being run normally by the Python "
"interpreter (the program has not been frozen), then ``freeze_support()`` has "
"no effect."
msgstr ""
"Chamar ``freeze_support()`` não tem efeito quando o método de inicialização "
"não é *spawn*. Além disso, se o módulo estiver a ser executado normalmente "
"pelo interpretador Python (o programa não foi congelado), então "
"``freeze_support()`` não tem efeito."

#: ../../library/multiprocessing.rst:1148
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  Not all platforms support all methods.  See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Devolve uma lista dos métodos de inicialização suportados, sendo o primeiro "
"o predefinido. Os métodos de inicialização possíveis são ``'fork'``, "
"``'spawn'`` e ``'forkserver'``. Nem todas as plataformas suportam todos os "
"métodos. Consulte :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1157
msgid ""
"Return a context object which has the same attributes as the :mod:"
"`multiprocessing` module."
msgstr ""
"Devolve um objeto de contexto que tem os mesmos atributos que o módulo :mod:"
"`multiprocessing`."

#: ../../library/multiprocessing.rst:1160
msgid ""
"If *method* is ``None`` then the default context is returned. Note that if "
"the global start method has not been set, this will set it to the system "
"default See :ref:`global-start-method` for more details. Otherwise *method* "
"should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  :exc:`ValueError` is "
"raised if the specified start method is not available.  See :ref:"
"`multiprocessing-start-methods`."
msgstr ""

#: ../../library/multiprocessing.rst:1171
msgid "Return the name of start method used for starting processes."
msgstr ""
"Devolve o nome do método de inicialização usado para iniciar processos."

#: ../../library/multiprocessing.rst:1173
msgid ""
"If the global start method is not set and *allow_none* is ``False``, the "
"global start method is set to the default, and its name is returned. See :"
"ref:`global-start-method` for more details."
msgstr ""

#: ../../library/multiprocessing.rst:1177
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  See :ref:`multiprocessing-start-methods`."
msgstr ""
"O valor de retorno pode ser ``'fork'``, ``'spawn'``, ``'forkserver'`` ou "
"``None``. Consulte :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1184
msgid ""
"On macOS, the *spawn* start method is now the default.  The *fork* start "
"method should be considered unsafe as it can lead to crashes of the "
"subprocess. See :issue:`33725`."
msgstr ""
"No macOS, o método de inicialização *spawn* é agora o predefinido. O método "
"de inicialização *fork* deve ser considerado inseguro, pois pode levar a "
"falhas no subprocesso. Consulte :issue:`33725`."

#: ../../library/multiprocessing.rst:1190
msgid ""
"Set the path of the Python interpreter to use when starting a child process. "
"(By default :data:`sys.executable` is used).  Embedders will probably need "
"to do some thing like ::"
msgstr ""
"Define o caminho do interpretador Python a usar ao iniciar um processo "
"filho. (Por predefinição, é usado :data:`sys.executable`). Os incorporadores "
"provavelmente precisarão de fazer algo como::"

#: ../../library/multiprocessing.rst:1194
msgid "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr "set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"

#: ../../library/multiprocessing.rst:1196
msgid "before they can create child processes."
msgstr "antes de poderem criar processos filhos."

#: ../../library/multiprocessing.rst:1198
msgid "Now supported on POSIX when the ``'spawn'`` start method is used."
msgstr ""
"Agora suportado em POSIX quando o método de inicialização ``'spawn'`` é "
"usado."

#: ../../library/multiprocessing.rst:1201
msgid "Accepts a :term:`path-like object`."
msgstr "Aceita um :term:`objeto semelhante a um caminho`."

#: ../../library/multiprocessing.rst:1206
msgid ""
"Set a list of module names for the forkserver main process to attempt to "
"import so that their already imported state is inherited by forked "
"processes. Any :exc:`ImportError` when doing so is silently ignored. This "
"can be used as a performance enhancement to avoid repeated work in every "
"process."
msgstr ""
"Define uma lista de nomes de módulos para que o processo principal do "
"forkserver tente importar, de modo que o seu estado já importado seja "
"herdado pelos processos bifurcados. Qualquer :exc:`ImportError` ao fazê-lo é "
"ignorado silenciosamente. Isto pode ser usado como uma melhoria de "
"desempenho para evitar trabalho repetido em cada processo."

#: ../../library/multiprocessing.rst:1212
msgid ""
"For this to work, it must be called before the forkserver process has been "
"launched (before creating a :class:`Pool` or starting a :class:`Process`)."
msgstr ""
"Para que isto funcione, deve ser chamado antes de o processo forkserver ter "
"sido iniciado (antes de criar um :class:`Pool` ou iniciar um :class:"
"`Process`)."

#: ../../library/multiprocessing.rst:1215
msgid ""
"Only meaningful when using the ``'forkserver'`` start method. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Apenas relevante quando se usa o método de inicialização ``'forkserver'``. "
"Consulte :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1222
msgid ""
"Set the method which should be used to start child processes. The *method* "
"argument can be ``'fork'``, ``'spawn'`` or ``'forkserver'``. Raises :exc:"
"`RuntimeError` if the start method has already been set and *force* is not "
"``True``.  If *method* is ``None`` and *force* is ``True`` then the start "
"method is set to ``None``.  If *method* is ``None`` and *force* is ``False`` "
"then the context is set to the default context."
msgstr ""
"Define o método que deve ser usado para iniciar processos filhos. O "
"argumento *method* pode ser ``'fork'``, ``'spawn'`` ou ``'forkserver'``. "
"Gera uma exceção :exc:`RuntimeError` se o método de inicialização já tiver "
"sido definido e *force* não for ``True``. Se *method* for ``None`` e *force* "
"for ``True``, então o método de inicialização é definido para ``None``. Se "
"*method* for ``None`` e *force* for ``False``, então o contexto é definido "
"para o contexto predefinido."

#: ../../library/multiprocessing.rst:1229
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"Note que isto deve ser chamado no máximo uma vez e deve ser protegido dentro "
"da cláusula ``if __name__ == '__main__'`` do módulo principal."

#: ../../library/multiprocessing.rst:1233
msgid "See :ref:`multiprocessing-start-methods`."
msgstr "Consulte :ref:`multiprocessing-start-methods`."

#: ../../library/multiprocessing.rst:1239
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""
"O módulo :mod:`multiprocessing` não contém análogos de :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer` ou :class:`threading."
"local`."

#: ../../library/multiprocessing.rst:1246
msgid "Connection Objects"
msgstr "Objetos de Ligação"

#: ../../library/multiprocessing.rst:1250
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""
"Os objetos de ligação permitem o envio e receção de objetos serializáveis ou "
"strings. Podem ser pensados como sockets conectados orientados a mensagens."

#: ../../library/multiprocessing.rst:1253
msgid ""
"Connection objects are usually created using :func:`Pipe <multiprocessing."
"Pipe>` -- see also :ref:`multiprocessing-listeners-clients`."
msgstr ""
"Os objetos de ligação são geralmente criados usando :func:`Pipe "
"<multiprocessing.Pipe>` -- consulte também :ref:`multiprocessing-listeners-"
"clients`."

#: ../../library/multiprocessing.rst:1261
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""
"Envie um objeto para a outra extremidade da ligação, que deve ser lido "
"usando :meth:`recv`."

#: ../../library/multiprocessing.rst:1264
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+, "
"though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"O objeto deve ser serializável. Objetos serializados muito grandes "
"(aproximadamente 32 MiB+, embora dependa do sistema operativo) podem gerar "
"uma exceção :exc:`ValueError`."

#: ../../library/multiprocessing.rst:1269
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Blocks until there is something to receive.  Raises :exc:`EOFError` "
"if there is nothing left to receive and the other end was closed."
msgstr ""
"Devolve um objeto enviado da outra extremidade da ligação usando :meth:"
"`send`. Bloqueia até que haja algo para receber. Gera :exc:`EOFError` se não "
"houver nada para receber e a outra extremidade tiver sido fechada."

#: ../../library/multiprocessing.rst:1276
msgid "Return the file descriptor or handle used by the connection."
msgstr "Devolve o descritor de ficheiro ou identificador usado pela ligação."

#: ../../library/multiprocessing.rst:1280
msgid "Close the connection."
msgstr "Fecha a ligação."

#: ../../library/multiprocessing.rst:1282
msgid "This is called automatically when the connection is garbage collected."
msgstr ""
"Isto é chamado automaticamente quando a ligação é recolhida pelo garbage "
"collector."

#: ../../library/multiprocessing.rst:1286
msgid "Return whether there is any data available to be read."
msgstr "Devolve se há dados disponíveis para leitura."

#: ../../library/multiprocessing.rst:1288
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"Se *timeout* não for especificado, retornará imediatamente. Se *timeout* for "
"um número, isto especifica o tempo máximo em segundos para bloquear. Se "
"*timeout* for ``None``, é usado um timeout infinito."

#: ../../library/multiprocessing.rst:1292
msgid ""
"Note that multiple connection objects may be polled at once by using :func:"
"`multiprocessing.connection.wait`."
msgstr ""
"Note que vários objetos de ligação podem ser sondados de uma vez usando :"
"func:`multiprocessing.connection.wait`."

#: ../../library/multiprocessing.rst:1297
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ""
"Envie dados de bytes de um :term:`objeto semelhante a bytes` como uma "
"mensagem completa."

#: ../../library/multiprocessing.rst:1299
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer.  Very large "
"buffers (approximately 32 MiB+, though it depends on the OS) may raise a :"
"exc:`ValueError` exception"
msgstr ""
"Se *offset* for fornecido, os dados são lidos a partir dessa posição em "
"*buffer*. Se *size* for fornecido, esse número de bytes será lido do buffer. "
"Buffers muito grandes (aproximadamente 32 MiB+, embora dependa do sistema "
"operativo) podem gerar uma exceção :exc:`ValueError`."

#: ../../library/multiprocessing.rst:1306
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end has "
"closed."
msgstr ""
"Devolve uma mensagem completa de dados de bytes enviada da outra extremidade "
"da ligação como uma string. Bloqueia até que haja algo para receber. Gera :"
"exc:`EOFError` se não houver nada para receber e a outra extremidade tiver "
"sido fechada."

#: ../../library/multiprocessing.rst:1311
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`OSError` is raised and the connection will no longer be readable."
msgstr ""
"Se *maxlength* for especificado e a mensagem for mais longa do que "
"*maxlength*, é gerada uma exceção :exc:`OSError` e a ligação já não será "
"legível."

#: ../../library/multiprocessing.rst:1315
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of :exc:"
"`OSError`."
msgstr ""
"Esta função costumava gerar :exc:`IOError`, que agora é um alias de :exc:"
"`OSError`."

#: ../../library/multiprocessing.rst:1322
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Blocks "
"until there is something to receive.  Raises :exc:`EOFError` if there is "
"nothing left to receive and the other end was closed."
msgstr ""
"Lê para *buffer* uma mensagem completa de dados de bytes enviada da outra "
"extremidade da ligação e devolve o número de bytes na mensagem. Bloqueia até "
"que haja algo para receber. Gera :exc:`EOFError` se não houver nada para "
"receber e a outra extremidade tiver sido fechada."

#: ../../library/multiprocessing.rst:1328
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is given "
"then the message will be written into the buffer from that position.  Offset "
"must be a non-negative integer less than the length of *buffer* (in bytes)."
msgstr ""
"*buffer* deve ser um :term:`objeto semelhante a bytes` gravável. Se *offset* "
"for fornecido, a mensagem será escrita no buffer a partir dessa posição. O "
"offset deve ser um inteiro não negativo menor que o comprimento de *buffer* "
"(em bytes)."

#: ../../library/multiprocessing.rst:1333
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""
"Se o buffer for demasiado pequeno, é gerada uma exceção :exc:"
"`BufferTooShort` e a mensagem completa está disponível como ``e.args[0]``, "
"onde ``e`` é a instância da exceção."

#: ../../library/multiprocessing.rst:1337
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"Os próprios objetos de ligação agora podem ser transferidos entre processos "
"usando :meth:`Connection.send` e :meth:`Connection.recv`."

#: ../../library/multiprocessing.rst:1341
msgid ""
"Connection objects also now support the context management protocol -- see :"
"ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"connection object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Os objetos de ligação agora também suportam o protocolo de gestão de "
"contexto -- consulte :ref:`typecontextmanager`. :meth:`~contextmanager."
"__enter__` devolve o objeto de ligação, e :meth:`~contextmanager.__exit__` "
"chama :meth:`close`."

#: ../../library/multiprocessing.rst:1345
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/multiprocessing.rst:1347
msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes(b'thank you')\n"
">>> a.recv_bytes()\n"
"b'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'olá', None])\n"
">>> b.recv()\n"
"[1, 'olá', None]\n"
">>> b.send_bytes(b'obrigado')\n"
">>> a.recv_bytes()\n"
"b'obrigado'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"

#: ../../library/multiprocessing.rst:1370
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
"O método :meth:`Connection.recv` desserializa automaticamente os dados que "
"recebe, o que pode ser um risco de segurança, a menos que confie no processo "
"que enviou a mensagem."

#: ../../library/multiprocessing.rst:1374
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Portanto, a menos que o objeto de ligação tenha sido produzido usando :func:"
"`Pipe`, só deve usar os métodos :meth:`~Connection.recv` e :meth:"
"`~Connection.send` após realizar algum tipo de autenticação. Consulte :ref:"
"`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:1381
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""
"Se um processo for terminado enquanto estiver a tentar ler ou escrever num "
"pipe, os dados no pipe podem ficar corrompidos, porque pode tornar-se "
"impossível saber onde estão os limites das mensagens."

#: ../../library/multiprocessing.rst:1387
msgid "Synchronization primitives"
msgstr "Primitivas de Sincronização"

#: ../../library/multiprocessing.rst:1391
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""
"Geralmente, as primitivas de sincronização não são tão necessárias num "
"programa multiprocesso como num programa multithread. Consulte a "
"documentação do módulo :mod:`threading`."

#: ../../library/multiprocessing.rst:1395
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""
"Note que também é possível criar primitivas de sincronização usando um "
"objeto gestor -- consulte :ref:`multiprocessing-managers`."

#: ../../library/multiprocessing.rst:1400
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "Um objeto barreira: um clone de :class:`threading.Barrier`."

#: ../../library/multiprocessing.rst:1409
msgid ""
"A bounded semaphore object: a close analog of :class:`threading."
"BoundedSemaphore`."
msgstr ""
"Um objeto semáforo limitado: um análogo próximo de :class:`threading."
"BoundedSemaphore`."

#: ../../library/multiprocessing.rst:1415
#: ../../library/multiprocessing.rst:1567
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` method's "
"first argument is named *block*, as is consistent with :meth:`Lock.acquire`."
msgstr ""
"Uma única diferença em relação ao seu análogo próximo existe: o primeiro "
"argumento do seu método ``acquire`` chama-se *block*, o que é consistente "
"com :meth:`Lock.acquire`."

#: ../../library/multiprocessing.rst:1419
msgid ""
"On macOS, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"No macOS, isto é indistinguível de :class:`Semaphore` porque "
"``sem_getvalue()`` não está implementado nessa plataforma."

#: ../../library/multiprocessing.rst:1424
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "Uma variável de condição: um alias para :class:`threading.Condition`."

#: ../../library/multiprocessing.rst:1426
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""
"Se *lock* for especificado, deve ser um objeto :class:`Lock` ou :class:"
"`RLock` de :mod:`multiprocessing`."

#: ../../library/multiprocessing.rst:1432
#: ../../library/multiprocessing.rst:1997
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr "O método :meth:`~threading.Condition.wait_for` foi adicionado."

#: ../../library/multiprocessing.rst:1437
msgid "A clone of :class:`threading.Event`."
msgstr "Um clone de :class:`threading.Event`."

#: ../../library/multiprocessing.rst:1444
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. Once "
"a process or thread has acquired a lock, subsequent attempts to acquire it "
"from any process or thread will block until it is released; any process or "
"thread may release it.  The concepts and behaviors of :class:`threading."
"Lock` as it applies to threads are replicated here in :class:"
"`multiprocessing.Lock` as it applies to either processes or threads, except "
"as noted."
msgstr ""
"Um objeto de bloqueio não recursivo: um análogo próximo de :class:`threading."
"Lock`. Uma vez que um processo ou thread tenha adquirido um bloqueio, "
"tentativas subsequentes de adquiri-lo a partir de qualquer processo ou "
"thread serão bloqueadas até que seja libertado; qualquer processo ou thread "
"pode libertá-lo. Os conceitos e comportamentos de :class:`threading.Lock`, "
"tal como se aplica a threads, são replicados aqui em :class:`multiprocessing."
"Lock`, tal como se aplica a processos ou threads, exceto onde indicado."

#: ../../library/multiprocessing.rst:1452
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a default "
"context."
msgstr ""
"Note que :class:`Lock` é na verdade uma função fábrica que devolve uma "
"instância de ``multiprocessing.synchronize.Lock`` inicializada com um "
"contexto predefinido."

#: ../../library/multiprocessing.rst:1459
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`Lock` suporta o protocolo :term:`gestor de contexto` e, portanto, "
"pode ser usado em instruções :keyword:`with`."

#: ../../library/multiprocessing.rst:1464
#: ../../library/multiprocessing.rst:1518
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Adquire um bloqueio, bloqueante ou não bloqueante."

#: ../../library/multiprocessing.rst:1466
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked and "
"return ``True``.  Note that the name of this first argument differs from "
"that in :meth:`threading.Lock.acquire`."
msgstr ""
"Com o argumento *block* definido como ``True`` (predefinição), a chamada do "
"método bloqueará até que o bloqueio esteja num estado desbloqueado, depois "
"definirá-o como bloqueado e devolverá ``True``. Note que o nome deste "
"primeiro argumento difere do de :meth:`threading.Lock.acquire`."

#: ../../library/multiprocessing.rst:1471
msgid ""
"With the *block* argument set to ``False``, the method call does not block.  "
"If the lock is currently in a locked state, return ``False``; otherwise set "
"the lock to a locked state and return ``True``."
msgstr ""
"Com o argumento *block* definido como ``False``, a chamada do método não "
"bloqueia. Se o bloqueio estiver atualmente num estado bloqueado, devolve "
"``False``; caso contrário, define o bloqueio para um estado bloqueado e "
"devolve ``True``."

#: ../../library/multiprocessing.rst:1475
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block for "
"at most the number of seconds specified by *timeout* as long as the lock can "
"not be acquired.  Invocations with a negative value for *timeout* are "
"equivalent to a *timeout* of zero.  Invocations with a *timeout* value of "
"``None`` (the default) set the timeout period to infinite.  Note that the "
"treatment of negative or ``None`` values for *timeout* differs from the "
"implemented behavior in :meth:`threading.Lock.acquire`.  The *timeout* "
"argument has no practical implications if the *block* argument is set to "
"``False`` and is thus ignored.  Returns ``True`` if the lock has been "
"acquired or ``False`` if the timeout period has elapsed."
msgstr ""
"Quando invocado com um valor positivo de ponto flutuante para *timeout*, "
"bloqueia durante, no máximo, o número de segundos especificado por "
"*timeout*, enquanto o bloqueio não puder ser adquirido. Invocações com um "
"valor negativo para *timeout* são equivalentes a um *timeout* de zero. "
"Invocações com um valor *timeout* de ``None`` (predefinição) definem o "
"período de timeout como infinito. Note que o tratamento de valores negativos "
"ou ``None`` para *timeout* difere do comportamento implementado em :meth:"
"`threading.Lock.acquire`. O argumento *timeout* não tem implicações práticas "
"se o argumento *block* estiver definido como ``False`` e, portanto, é "
"ignorado. Devolve ``True`` se o bloqueio tiver sido adquirido ou ``False`` "
"se o período de timeout tiver expirado."

#: ../../library/multiprocessing.rst:1490
msgid ""
"Release a lock.  This can be called from any process or thread, not only the "
"process or thread which originally acquired the lock."
msgstr ""
"Liberta um bloqueio. Isto pode ser chamado a partir de qualquer processo ou "
"thread, não apenas do processo ou thread que adquiriu originalmente o "
"bloqueio."

#: ../../library/multiprocessing.rst:1493
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that when "
"invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"O comportamento é o mesmo que em :meth:`threading.Lock.release`, exceto que, "
"quando invocado num bloqueio desbloqueado, é gerada uma exceção :exc:"
"`ValueError`."

#: ../../library/multiprocessing.rst:1499
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired it. "
"Once a process or thread has acquired a recursive lock, the same process or "
"thread may acquire it again without blocking; that process or thread must "
"release it once for each time it has been acquired."
msgstr ""
"Um objeto de bloqueio recursivo: um análogo próximo de :class:`threading."
"RLock`. Um bloqueio recursivo deve ser libertado pelo processo ou thread que "
"o adquiriu. Uma vez que um processo ou thread tenha adquirido um bloqueio "
"recursivo, o mesmo processo ou thread pode adquiri-lo novamente sem "
"bloquear; esse processo ou thread deve libertá-lo uma vez para cada vez que "
"foi adquirido."

#: ../../library/multiprocessing.rst:1505
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a default "
"context."
msgstr ""
"Note que :class:`RLock` é na verdade uma função fábrica que devolve uma "
"instância de ``multiprocessing.synchronize.RLock`` inicializada com um "
"contexto predefinido."

#: ../../library/multiprocessing.rst:1512
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may be "
"used in :keyword:`with` statements."
msgstr ""
":class:`RLock` suporta o protocolo :term:`gestor de contexto` e, portanto, "
"pode ser usado em instruções :keyword:`with`."

#: ../../library/multiprocessing.rst:1520
msgid ""
"When invoked with the *block* argument set to ``True``, block until the lock "
"is in an unlocked state (not owned by any process or thread) unless the lock "
"is already owned by the current process or thread.  The current process or "
"thread then takes ownership of the lock (if it does not already have "
"ownership) and the recursion level inside the lock increments by one, "
"resulting in a return value of ``True``.  Note that there are several "
"differences in this first argument's behavior compared to the implementation "
"of :meth:`threading.RLock.acquire`, starting with the name of the argument "
"itself."
msgstr ""
"Quando invocado com o argumento *block* definido como ``True``, bloqueia até "
"que o bloqueio esteja num estado desbloqueado (não possuído por nenhum "
"processo ou thread), a menos que o bloqueio já seja possuído pelo processo "
"ou thread atual. O processo ou thread atual assume então a posse do bloqueio "
"(se ainda não a tiver) e o nível de recursão dentro do bloqueio incrementa "
"em um, resultando num valor de retorno de ``True``. Note que existem várias "
"diferenças no comportamento deste primeiro argumento em comparação com a "
"implementação de :meth:`threading.RLock.acquire`, começando pelo nome do "
"próprio argumento."

#: ../../library/multiprocessing.rst:1530
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If "
"the lock has already been acquired (and thus is owned) by another process or "
"thread, the current process or thread does not take ownership and the "
"recursion level within the lock is not changed, resulting in a return value "
"of ``False``.  If the lock is in an unlocked state, the current process or "
"thread takes ownership and the recursion level is incremented, resulting in "
"a return value of ``True``."
msgstr ""
"Quando invocado com o argumento *block* definido como ``False``, não "
"bloqueia. Se o bloqueio já tiver sido adquirido (e, portanto, é possuído) "
"por outro processo ou thread, o processo ou thread atual não assume a posse "
"e o nível de recursão dentro do bloqueio não é alterado, resultando num "
"valor de retorno de ``False``. Se o bloqueio estiver num estado "
"desbloqueado, o processo ou thread atual assume a posse e o nível de "
"recursão é incrementado, resultando num valor de retorno de ``True``."

#: ../../library/multiprocessing.rst:1538
msgid ""
"Use and behaviors of the *timeout* argument are the same as in :meth:`Lock."
"acquire`.  Note that some of these behaviors of *timeout* differ from the "
"implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"O uso e comportamentos do argumento *timeout* são os mesmos que em :meth:"
"`Lock.acquire`. Note que alguns destes comportamentos de *timeout* diferem "
"dos comportamentos implementados em :meth:`threading.RLock.acquire`."

#: ../../library/multiprocessing.rst:1545
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement "
"the recursion level is zero, reset the lock to unlocked (not owned by any "
"process or thread) and if any other processes or threads are blocked waiting "
"for the lock to become unlocked, allow exactly one of them to proceed.  If "
"after the decrement the recursion level is still nonzero, the lock remains "
"locked and owned by the calling process or thread."
msgstr ""
"Liberta um bloqueio, decrementando o nível de recursão. Se, após o "
"decremento, o nível de recursão for zero, redefine o bloqueio para "
"desbloqueado (não possuído por nenhum processo ou thread) e, se outros "
"processos ou threads estiverem bloqueados à espera que o bloqueio seja "
"desbloqueado, permite que exatamente um deles prossiga. Se, após o "
"decremento, o nível de recursão ainda for diferente de zero, o bloqueio "
"permanece bloqueado e possuído pelo processo ou thread chamador."

#: ../../library/multiprocessing.rst:1553
msgid ""
"Only call this method when the calling process or thread owns the lock. An :"
"exc:`AssertionError` is raised if this method is called by a process or "
"thread other than the owner or if the lock is in an unlocked (unowned) "
"state.  Note that the type of exception raised in this situation differs "
"from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"Chame este método apenas quando o processo ou thread chamador possuir o "
"bloqueio. Uma exceção :exc:`AssertionError` é gerada se este método for "
"chamado por um processo ou thread diferente do proprietário ou se o bloqueio "
"estiver num estado desbloqueado (não possuído). Note que o tipo de exceção "
"gerada nesta situação difere do comportamento implementado em :meth:"
"`threading.RLock.release`."

#: ../../library/multiprocessing.rst:1562
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr ""
"Um objeto semáforo: um análogo próximo de :class:`threading.Semaphore`."

#: ../../library/multiprocessing.rst:1572
msgid ""
"On macOS, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with a "
"timeout will emulate that function's behavior using a sleeping loop."
msgstr ""
"No macOS, ``sem_timedwait`` não é suportado, por isso chamar ``acquire()`` "
"com um timeout emulará o comportamento dessa função usando um ciclo de "
"espera."

#: ../../library/multiprocessing.rst:1577
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"Algumas funcionalidades deste pacote requerem uma implementação funcional de "
"semáforos partilhados no sistema operativo anfitrião. Sem ela, o módulo :mod:"
"`multiprocessing.synchronize` será desativado, e tentativas de importá-lo "
"resultarão numa exceção :exc:`ImportError`. Consulte :issue:`3770` para "
"informações adicionais."

#: ../../library/multiprocessing.rst:1585
msgid "Shared :mod:`ctypes` Objects"
msgstr "Objetos :mod:`ctypes` Partilhados"

#: ../../library/multiprocessing.rst:1587
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""
"É possível criar objetos partilhados usando memória partilhada que pode ser "
"herdada por processos filhos."

#: ../../library/multiprocessing.rst:1592
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object.  The object "
"itself can be accessed via the *value* attribute of a :class:`Value`."
msgstr ""
"Devolve um objeto :mod:`ctypes` alocado a partir de memória partilhada. Por "
"predefinição, o valor devolvido é, na verdade, um wrapper sincronizado para "
"o objeto. O próprio objeto pode ser acedido através do atributo *value* de "
"um :class:`Value`."

#: ../../library/multiprocessing.rst:1596
#: ../../library/multiprocessing.rst:1686
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""
"*typecode_or_type* determina o tipo do objeto devolvido: pode ser um tipo "
"ctypes ou um código de tipo de um carácter do tipo usado pelo módulo :mod:"
"`array`. *\\*args* é passado para o construtor do tipo."

#: ../../library/multiprocessing.rst:1600
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock` "
"or :class:`RLock` object then that will be used to synchronize access to the "
"value.  If *lock* is ``False`` then access to the returned object will not "
"be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"Se *lock* for ``True`` (predefinição), é criado um novo objeto de bloqueio "
"recursivo para sincronizar o acesso ao valor. Se *lock* for um objeto :class:"
"`Lock` ou :class:`RLock`, esse será usado para sincronizar o acesso ao "
"valor. Se *lock* for ``False``, o acesso ao objeto devolvido não será "
"automaticamente protegido por um bloqueio, pelo que não será necessariamente "
"\"seguro para processos\"."

#: ../../library/multiprocessing.rst:1607
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So "
"if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"Operações como ``+=``, que envolvem uma leitura e uma escrita, não são "
"atómicas. Portanto, se, por exemplo, pretender incrementar atomicamente um "
"valor partilhado, não é suficiente fazer apenas::"

#: ../../library/multiprocessing.rst:1611
msgid "counter.value += 1"
msgstr "counter.value += 1"

#: ../../library/multiprocessing.rst:1613
msgid ""
"Assuming the associated lock is recursive (which it is by default) you can "
"instead do ::"
msgstr ""
"Assumindo que o bloqueio associado é recursivo (o que é por predefinição), "
"pode em vez disso fazer::"

#: ../../library/multiprocessing.rst:1616
msgid ""
"with counter.get_lock():\n"
"    counter.value += 1"
msgstr ""
"with counter.get_lock():\n"
"    counter.value += 1"

#: ../../library/multiprocessing.rst:1619
msgid "Note that *lock* is a keyword-only argument."
msgstr "Note que *lock* é um argumento apenas por palavra-chave."

#: ../../library/multiprocessing.rst:1623
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""
"Devolve um array ctypes alocado a partir de memória partilhada. Por "
"predefinição, o valor devolvido é, na verdade, um wrapper sincronizado para "
"o array."

#: ../../library/multiprocessing.rst:1626
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a :ref:`ctypes type <ctypes-fundamental-data-types>` or "
"a one character typecode of the kind used by the :mod:`array` module with "
"the exception of ``'w'``, which is not supported.  In addition, the ``'c'`` "
"typecode is an alias for :class:`ctypes.c_char`.  If *size_or_initializer* "
"is an integer, then it determines the length of the array, and the array "
"will be initially zeroed. Otherwise, *size_or_initializer* is a sequence "
"which is used to initialize the array and whose length determines the length "
"of the array."
msgstr ""

#: ../../library/multiprocessing.rst:1636
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""
"Se *lock* for ``True`` (predefinição), é criado um novo objeto de bloqueio "
"para sincronizar o acesso ao valor. Se *lock* for um objeto :class:`Lock` "
"ou :class:`RLock`, esse será usado para sincronizar o acesso ao valor. Se "
"*lock* for ``False``, o acesso ao objeto devolvido não será automaticamente "
"protegido por um bloqueio, pelo que não será necessariamente \"seguro para "
"processos\"."

#: ../../library/multiprocessing.rst:1643
msgid "Note that *lock* is a keyword only argument."
msgstr "Note que *lock* é um argumento apenas por palavra-chave."

#: ../../library/multiprocessing.rst:1645
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""
"Note que um array de :data:`ctypes.c_char` tem atributos *value* e *raw* que "
"permitem usá-lo para armazenar e recuperar strings."

#: ../../library/multiprocessing.rst:1650
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr "O módulo :mod:`multiprocessing.sharedctypes`"

#: ../../library/multiprocessing.rst:1655
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""
"O módulo :mod:`multiprocessing.sharedctypes` fornece funções para alocar "
"objetos :mod:`ctypes` a partir de memória partilhada que podem ser herdados "
"por processos filhos."

#: ../../library/multiprocessing.rst:1661
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""
"Embora seja possível armazenar um ponteiro em memória partilhada, lembre-se "
"de que este se referirá a um local no espaço de endereçamento de um processo "
"específico. No entanto, é muito provável que o ponteiro seja inválido no "
"contexto de um segundo processo, e tentar desreferenciá-lo a partir do "
"segundo processo pode causar uma falha."

#: ../../library/multiprocessing.rst:1669
msgid "Return a ctypes array allocated from shared memory."
msgstr "Devolve um array ctypes alocado a partir de memória partilhada."

#: ../../library/multiprocessing.rst:1671
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""
"*typecode_or_type* determina o tipo dos elementos do array devolvido: pode "
"ser um tipo ctypes ou um código de tipo de um carácter do tipo usado pelo "
"módulo :mod:`array`. Se *size_or_initializer* for um inteiro, então "
"determina o comprimento do array, e o array será inicialmente preenchido com "
"zeros. Caso contrário, *size_or_initializer* é uma sequência que é usada "
"para inicializar o array e cujo comprimento determina o comprimento do array."

#: ../../library/multiprocessing.rst:1678
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Note que definir e obter um elemento pode não ser atómico -- use :func:"
"`Array` em vez disso para garantir que o acesso seja automaticamente "
"sincronizado usando um bloqueio."

#: ../../library/multiprocessing.rst:1684
msgid "Return a ctypes object allocated from shared memory."
msgstr "Devolve um objeto ctypes alocado a partir de memória partilhada."

#: ../../library/multiprocessing.rst:1690
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""
"Note que definir e obter o valor pode não ser atómico -- use :func:`Value` "
"em vez disso para garantir que o acesso seja automaticamente sincronizado "
"usando um bloqueio."

#: ../../library/multiprocessing.rst:1694
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""
"Note que um array de :data:`ctypes.c_char` tem atributos ``value`` e ``raw`` "
"que permitem usá-lo para armazenar e recuperar strings -- consulte a "
"documentação para :mod:`ctypes`."

#: ../../library/multiprocessing.rst:1700
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""
"O mesmo que :func:`RawArray`, exceto que, dependendo do valor de *lock*, "
"pode ser devolvido um wrapper de sincronização seguro para processos em vez "
"de um array ctypes bruto."

#: ../../library/multiprocessing.rst:1704
#: ../../library/multiprocessing.rst:1724
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`~multiprocessing."
"Lock` or :class:`~multiprocessing.RLock` object then that will be used to "
"synchronize access to the value.  If *lock* is ``False`` then access to the "
"returned object will not be automatically protected by a lock, so it will "
"not necessarily be \"process-safe\"."
msgstr ""
"Se *lock* for ``True`` (predefinição), é criado um novo objeto de bloqueio "
"para sincronizar o acesso ao valor. Se *lock* for um objeto :class:"
"`~multiprocessing.Lock` ou :class:`~multiprocessing.RLock`, esse será usado "
"para sincronizar o acesso ao valor. Se *lock* for ``False``, o acesso ao "
"objeto devolvido não será automaticamente protegido por um bloqueio, pelo "
"que não será necessariamente \"seguro para processos\"."

#: ../../library/multiprocessing.rst:1712
#: ../../library/multiprocessing.rst:1731
#: ../../library/multiprocessing.rst:1748
#: ../../library/multiprocessing.rst:1869
msgid ""
"*ctx* is a context object, or ``None`` (use the current context). If "
"``None``, calling this may set the global start method. See :ref:`global-"
"start-method` for more details."
msgstr ""

#: ../../library/multiprocessing.rst:1716
#: ../../library/multiprocessing.rst:1735
msgid "Note that *lock* and *ctx* are keyword-only parameters."
msgstr ""

#: ../../library/multiprocessing.rst:1720
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""
"O mesmo que :func:`RawValue`, exceto que, dependendo do valor de *lock*, "
"pode ser devolvido um wrapper de sincronização seguro para processos em vez "
"de um objeto ctypes bruto."

#: ../../library/multiprocessing.rst:1739
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""
"Devolve um objeto ctypes alocado a partir de memória partilhada que é uma "
"cópia do objeto ctypes *obj*."

#: ../../library/multiprocessing.rst:1744
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""
"Devolve um objeto wrapper seguro para processos para um objeto ctypes que "
"usa *lock* para sincronizar o acesso. Se *lock* for ``None`` (predefinição), "
"então um objeto :class:`multiprocessing.RLock` é criado automaticamente."

#: ../../library/multiprocessing.rst:1752
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""
"Um wrapper sincronizado terá dois métodos além daqueles do objeto que "
"envolve: :meth:`get_obj` devolve o objeto envolvido e :meth:`get_lock` "
"devolve o objeto de bloqueio usado para sincronização."

#: ../../library/multiprocessing.rst:1756
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""
"Note que aceder ao objeto ctypes através do wrapper pode ser muito mais "
"lento do que aceder diretamente ao objeto ctypes bruto."

#: ../../library/multiprocessing.rst:1759
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "Objetos sincronizados suportam o protocolo :term:`gestor de contexto`."

#: ../../library/multiprocessing.rst:1763
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"A tabela abaixo compara a sintaxe para criar objetos ctypes partilhados a "
"partir de memória partilhada com a sintaxe normal de ctypes. (Na tabela, "
"``MyStruct`` é alguma subclasse de :class:`ctypes.Structure`.)"

#: ../../library/multiprocessing.rst:1768
msgid "ctypes"
msgstr "ctypes"

#: ../../library/multiprocessing.rst:1768
msgid "sharedctypes using type"
msgstr "sharedctypes usando tipo"

#: ../../library/multiprocessing.rst:1768
msgid "sharedctypes using typecode"
msgstr "sharedctypes usando código de tipo"

#: ../../library/multiprocessing.rst:1770
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../../library/multiprocessing.rst:1770
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../../library/multiprocessing.rst:1770
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../../library/multiprocessing.rst:1771
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../../library/multiprocessing.rst:1771
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../../library/multiprocessing.rst:1772
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../../library/multiprocessing.rst:1772
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../../library/multiprocessing.rst:1772
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../../library/multiprocessing.rst:1773
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../../library/multiprocessing.rst:1773
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../../library/multiprocessing.rst:1773
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../../library/multiprocessing.rst:1777
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""
"Em baixo está um exemplo onde vários objetos ctypes são modificados por um "
"processo filho::"

#: ../../library/multiprocessing.rst:1780
msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"
msgstr ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', b'olá mundo', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print(n.value)\n"
"    print(x.value)\n"
"    print(s.value)\n"
"    print([(a.x, a.y) for a in A])"

#: ../../library/multiprocessing.rst:1815
msgid "The results printed are ::"
msgstr "Os resultados impressos são::"

#: ../../library/multiprocessing.rst:1817
msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""
"49\n"
"0.1111111111111111\n"
"OLÁ MUNDO\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"

#: ../../library/multiprocessing.rst:1828
msgid "Managers"
msgstr "Gestores"

#: ../../library/multiprocessing.rst:1830
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes, including sharing over a network between processes running on "
"different machines. A manager object controls a server process which manages "
"*shared objects*.  Other processes can access the shared objects by using "
"proxies."
msgstr ""
"Os gestores fornecem uma forma de criar dados que podem ser partilhados "
"entre diferentes processos, incluindo a partilha através de uma rede entre "
"processos a correr em máquinas diferentes. Um objeto gestor controla um "
"processo servidor que gere *objetos partilhados*. Outros processos podem "
"aceder aos objetos partilhados usando proxies."

#: ../../library/multiprocessing.rst:1839
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""
"Devolve um objeto :class:`~multiprocessing.managers.SyncManager` iniciado "
"que pode ser usado para partilhar objetos entre processos. O objeto gestor "
"devolvido corresponde a um processo filho criado e tem métodos que criarão "
"objetos partilhados e devolverão proxies correspondentes."

#: ../../library/multiprocessing.rst:1847
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""
"Os processos gestores serão encerrados assim que forem recolhidos pelo "
"garbage collector ou quando o seu processo pai terminar. As classes de "
"gestores estão definidas no módulo :mod:`multiprocessing.managers`:"

#: ../../library/multiprocessing.rst:1853
msgid "Create a BaseManager object."
msgstr "Cria um objeto BaseManager."

#: ../../library/multiprocessing.rst:1855
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""
"Uma vez criado, deve chamar :meth:`start` ou ``get_server()."
"serve_forever()`` para garantir que o objeto gestor se refere a um processo "
"gestor iniciado."

#: ../../library/multiprocessing.rst:1858
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* é o endereço no qual o processo gestor escuta por novas ligações. "
"Se *address* for ``None``, então um endereço arbitrário é escolhido."

#: ../../library/multiprocessing.rst:1861
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey`` is used. Otherwise *authkey* is used and "
"it must be a byte string."
msgstr ""
"*authkey* é a chave de autenticação que será usada para verificar a validade "
"de ligações recebidas no processo servidor. Se *authkey* for ``None``, então "
"``current_process().authkey`` é usado. Caso contrário, *authkey* é usado e "
"deve ser uma string de bytes."

#: ../../library/multiprocessing.rst:1866
msgid ""
"*serializer* must be ``'pickle'`` (use :mod:`pickle` serialization) or "
"``'xmlrpclib'`` (use :mod:`xmlrpc.client` serialization)."
msgstr ""
"*serializer* deve ser ``'pickle'`` (usar serialização :mod:`pickle`) ou "
"``'xmlrpclib'`` (usar serialização :mod:`xmlrpc.client`)."

#: ../../library/multiprocessing.rst:1873
msgid ""
"*shutdown_timeout* is a timeout in seconds used to wait until the process "
"used by the manager completes in the :meth:`shutdown` method. If the "
"shutdown times out, the process is terminated. If terminating the process "
"also times out, the process is killed."
msgstr ""
"*shutdown_timeout* é um timeout em segundos usado para aguardar até que o "
"processo usado pelo gestor complete o método :meth:`shutdown`. Se o "
"encerramento exceder o tempo limite, o processo é terminado. Se a terminação "
"do processo também exceder o tempo limite, o processo é eliminado."

#: ../../library/multiprocessing.rst:1878
msgid "Added the *shutdown_timeout* parameter."
msgstr "Adicionado o parâmetro *shutdown_timeout*."

#: ../../library/multiprocessing.rst:1883
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not ``None`` "
"then the subprocess will call ``initializer(*initargs)`` when it starts."
msgstr ""
"Inicia um subprocesso para iniciar o gestor. Se *initializer* não for "
"``None``, então o subprocesso chamará ``initializer(*initargs)`` quando "
"iniciar."

#: ../../library/multiprocessing.rst:1888
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""
"Devolve um objeto :class:`Server` que representa o servidor real sob o "
"controlo do Gestor. O objeto :class:`Server` suporta o método :meth:"
"`serve_forever`::"

#: ../../library/multiprocessing.rst:1892
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey=b'abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"

#: ../../library/multiprocessing.rst:1897
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ""
"A classe :class:`Server` tem adicionalmente um atributo :attr:`address`."

#: ../../library/multiprocessing.rst:1901
msgid "Connect a local manager object to a remote manager process::"
msgstr "Liga um objeto gestor local a um processo gestor remoto::"

#: ../../library/multiprocessing.rst:1903
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')\n"
">>> m.connect()"

#: ../../library/multiprocessing.rst:1909
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""
"Para o processo usado pelo gestor. Isto só está disponível se :meth:`start` "
"tiver sido usado para iniciar o processo servidor."

#: ../../library/multiprocessing.rst:1912
msgid "This can be called multiple times."
msgstr "Isto pode ser chamado várias vezes."

#: ../../library/multiprocessing.rst:1916
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""
"Um método de classe que pode ser usado para registar um tipo ou objeto "
"invocável com a classe gestora."

#: ../../library/multiprocessing.rst:1919
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""
"*typeid* é um \"identificador de tipo\" que é usado para identificar um tipo "
"específico de objeto partilhado. Isto deve ser uma string."

#: ../../library/multiprocessing.rst:1922
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""
"*callable* é um objeto invocável usado para criar objetos para este "
"identificador de tipo. Se uma instância do gestor for ligada ao servidor "
"usando o método :meth:`connect`, ou se o argumento *create_method* for "
"``False``, então isto pode ser deixado como ``None``."

#: ../../library/multiprocessing.rst:1928
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* é uma subclasse de :class:`BaseProxy` que é usada para criar "
"proxies para objetos partilhados com este *typeid*. Se for ``None``, então "
"uma classe proxy é criada automaticamente."

#: ../../library/multiprocessing.rst:1932
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callmethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`~object.__call__` "
"method and whose name does not begin with ``'_'``.)"
msgstr ""
"*exposed* é usado para especificar uma sequência de nomes de métodos que os "
"proxies para este typeid devem ser permitidos aceder usando :meth:`BaseProxy."
"_callmethod`. (Se *exposed* for ``None``, então :attr:`proxytype._exposed_` "
"é usado em vez disso, se existir.) No caso em que nenhuma lista exposta é "
"especificada, todos os \"métodos públicos\" do objeto partilhado serão "
"acessíveis. (Aqui, um \"método público\" significa qualquer atributo que "
"tenha um método :meth:`~object.__call__` e cujo nome não comece com ``'_'``.)"

#: ../../library/multiprocessing.rst:1941
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* é um mapeamento usado para especificar o tipo de retorno "
"daqueles métodos expostos que devem devolver um proxy. Mapeia nomes de "
"métodos para strings de typeid. (Se *method_to_typeid* for ``None``, então :"
"attr:`proxytype._method_to_typeid_` é usado em vez disso, se existir.) Se o "
"nome de um método não for uma chave deste mapeamento ou se o mapeamento for "
"``None``, então o objeto devolvido pelo método será copiado por valor."

#: ../../library/multiprocessing.rst:1948
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* determina se um método deve ser criado com o nome *typeid* "
"que pode ser usado para instruir o processo servidor a criar um novo objeto "
"partilhado e devolver um proxy para ele. Por predefinição, é ``True``."

#: ../../library/multiprocessing.rst:1952
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""
"As instâncias de :class:`BaseManager` também têm uma propriedade apenas de "
"leitura:"

#: ../../library/multiprocessing.rst:1956
msgid "The address used by the manager."
msgstr "O endereço usado pelo gestor."

#: ../../library/multiprocessing.rst:1958
msgid ""
"Manager objects support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the server "
"process (if it has not already started) and then returns the manager "
"object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"Os objetos gestores suportam o protocolo de gestão de contexto -- consulte :"
"ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` inicia o "
"processo servidor (se ainda não tiver sido iniciado) e depois devolve o "
"objeto gestor. :meth:`~contextmanager.__exit__` chama :meth:`shutdown`."

#: ../../library/multiprocessing.rst:1964
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"Em versões anteriores, :meth:`~contextmanager.__enter__` não iniciava o "
"processo servidor do gestor se este ainda não tivesse sido iniciado."

#: ../../library/multiprocessing.rst:1969
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""
"Uma subclasse de :class:`BaseManager` que pode ser usada para a "
"sincronização de processos. Objetos deste tipo são devolvidos por :func:"
"`multiprocessing.Manager`."

#: ../../library/multiprocessing.rst:1973
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. This "
"notably includes shared lists and dictionaries."
msgstr ""
"Os seus métodos criam e devolvem :ref:`multiprocessing-proxy_objects` para "
"vários tipos de dados comumente usados para serem sincronizados entre "
"processos. Isto inclui notavelmente listas e dicionários partilhados."

#: ../../library/multiprocessing.rst:1979
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for it."
msgstr ""
"Cria um objeto :class:`threading.Barrier` partilhado e devolve um proxy para "
"ele."

#: ../../library/multiprocessing.rst:1986
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""
"Cria um objeto :class:`threading.BoundedSemaphore` partilhado e devolve um "
"proxy para ele."

#: ../../library/multiprocessing.rst:1991
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""
"Cria um objeto :class:`threading.Condition` partilhado e devolve um proxy "
"para ele."

#: ../../library/multiprocessing.rst:1994
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""
"Se *lock* for fornecido, então deve ser um proxy para um objeto :class:"
"`threading.Lock` ou :class:`threading.RLock`."

#: ../../library/multiprocessing.rst:2002
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""
"Cria um objeto :class:`threading.Event` partilhado e devolve um proxy para "
"ele."

#: ../../library/multiprocessing.rst:2006
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""
"Cria um objeto :class:`threading.Lock` partilhado e devolve um proxy para "
"ele."

#: ../../library/multiprocessing.rst:2010
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""
"Cria um objeto :class:`Namespace` partilhado e devolve um proxy para ele."

#: ../../library/multiprocessing.rst:2014
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr ""
"Cria um objeto :class:`queue.Queue` partilhado e devolve um proxy para ele."

#: ../../library/multiprocessing.rst:2018
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""
"Cria um objeto :class:`threading.RLock` partilhado e devolve um proxy para "
"ele."

#: ../../library/multiprocessing.rst:2022
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""
"Cria um objeto :class:`threading.Semaphore` partilhado e devolve um proxy "
"para ele."

#: ../../library/multiprocessing.rst:2027
msgid "Create an array and return a proxy for it."
msgstr "Cria um array e devolve um proxy para ele."

#: ../../library/multiprocessing.rst:2031
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""
"Cria um objeto com um atributo ``value`` gravável e devolve um proxy para "
"ele."

#: ../../library/multiprocessing.rst:2038
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "Cria um objeto :class:`dict` partilhado e devolve um proxy para ele."

#: ../../library/multiprocessing.rst:2043
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "Cria um objeto :class:`list` partilhado e devolve um proxy para ele."

#: ../../library/multiprocessing.rst:2045
msgid ""
"Shared objects are capable of being nested.  For example, a shared container "
"object such as a shared list can contain other shared objects which will all "
"be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"Os objetos partilhados podem ser aninhados. Por exemplo, um objeto contêiner "
"partilhado, como uma lista partilhada, pode conter outros objetos "
"partilhados que serão todos geridos e sincronizados pelo :class:"
"`SyncManager`."

#: ../../library/multiprocessing.rst:2052
msgid "A type that can register with :class:`SyncManager`."
msgstr "Um tipo que pode ser registado com :class:`SyncManager`."

#: ../../library/multiprocessing.rst:2054
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""
"Um objeto namespace não tem métodos públicos, mas tem atributos graváveis. A "
"sua representação mostra os valores dos seus atributos."

#: ../../library/multiprocessing.rst:2057
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""
"No entanto, ao usar um proxy para um objeto namespace, um atributo que "
"comece com ``'_'`` será um atributo do proxy e não um atributo do referente:"

#: ../../library/multiprocessing.rst:2061
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='hello')"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'olá'\n"
">>> Global._z = 12.3    # este é um atributo do proxy\n"
">>> print(Global)\n"
"Namespace(x=10, y='olá')"

#: ../../library/multiprocessing.rst:2074
msgid "Customized managers"
msgstr "Gestores Personalizados"

#: ../../library/multiprocessing.rst:2076
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and uses the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""
"Para criar o seu próprio gestor, cria-se uma subclasse de :class:"
"`BaseManager` e usa-se o método de classe :meth:`~BaseManager.register` para "
"registar novos tipos ou objetos invocáveis com a classe gestora. Por "
"exemplo::"

#: ../../library/multiprocessing.rst:2080
msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # prints 7\n"
"        print(maths.mul(7, 8))         # prints 56"
msgstr ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass:\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    with MyManager() as manager:\n"
"        maths = manager.Maths()\n"
"        print(maths.add(4, 3))         # imprime 7\n"
"        print(maths.mul(7, 8))         # imprime 56"

#: ../../library/multiprocessing.rst:2101
msgid "Using a remote manager"
msgstr "Usar um gestor remoto"

#: ../../library/multiprocessing.rst:2103
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""
"É possível executar um servidor gestor numa máquina e ter clientes a usá-lo "
"a partir de outras máquinas (assumindo que as firewalls envolvidas o "
"permitam)."

#: ../../library/multiprocessing.rst:2106
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""
"Executar os seguintes comandos cria um servidor para uma fila partilhada "
"única que clientes remotos podem aceder::"

#: ../../library/multiprocessing.rst:2109
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> from queue import Queue\n"
">>> queue = Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"

#: ../../library/multiprocessing.rst:2118
msgid "One client can access the server as follows::"
msgstr "Um cliente pode aceder ao servidor da seguinte forma::"

#: ../../library/multiprocessing.rst:2120
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('olá')"

#: ../../library/multiprocessing.rst:2128
msgid "Another client can also use it::"
msgstr "Outro cliente também pode usá-lo::"

#: ../../library/multiprocessing.rst:2130
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), "
"authkey=b'abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'olá'"

#: ../../library/multiprocessing.rst:2139
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""
"Processos locais também podem aceder a essa fila, usando o código acima no "
"cliente para aceder remotamente::"

#: ../../library/multiprocessing.rst:2142
msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super().__init__()\n"
"...     def run(self):\n"
"...         self.q.put('olá local')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"

#: ../../library/multiprocessing.rst:2164
msgid "Proxy Objects"
msgstr "Objetos Proxy"

#: ../../library/multiprocessing.rst:2166
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""
"Um proxy é um objeto que *refere* um objeto partilhado que existe "
"(presumivelmente) num processo diferente. O objeto partilhado é dito ser o "
"*referente* do proxy. Vários objetos proxy podem ter o mesmo referente."

#: ../../library/multiprocessing.rst:2170
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like "
"its referent can:"
msgstr ""
"Um objeto proxy tem métodos que invocam métodos correspondentes do seu "
"referente (embora nem todos os métodos do referente estejam necessariamente "
"disponíveis através do proxy). Desta forma, um proxy pode ser usado da mesma "
"forma que o seu referente:"

#: ../../library/multiprocessing.rst:2174
msgid ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""
">>> mp_context = multiprocessing.get_context('spawn')\n"
">>> manager = mp_context.Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print(l)\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print(repr(l))\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"

#: ../../library/multiprocessing.rst:2188
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""
"Note que aplicar :func:`str` a um proxy devolverá a representação do "
"referente, enquanto que aplicar :func:`repr` devolverá a representação do "
"proxy."

#: ../../library/multiprocessing.rst:2192
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  As such, a referent can contain :ref:"
"`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"Uma característica importante dos objetos proxy é que são serializáveis, "
"pelo que podem ser passados entre processos. Como tal, um referente pode "
"conter :ref:`multiprocessing-proxy_objects`. Isto permite o aninhamento "
"destas listas geridas, dicionários e outros :ref:`multiprocessing-"
"proxy_objects`:"

#: ../../library/multiprocessing.rst:2197
msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('hello')\n"
">>> print(a[0], b)\n"
"['hello'] ['hello']"
msgstr ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referente de a agora contém referente de b\n"
">>> print(a, b)\n"
"[<ListProxy object, typeid 'list' at ...>] []\n"
">>> b.append('olá')\n"
">>> print(a[0], b)\n"
"['olá'] ['olá']"

#: ../../library/multiprocessing.rst:2208
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr ""
"Da mesma forma, proxies de dicionários e listas podem ser aninhados uns "
"dentro dos outros::"

#: ../../library/multiprocessing.rst:2210
msgid ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"
msgstr ""
">>> l_outer = manager.list([ manager.dict() for i in range(2) ])\n"
">>> d_first_inner = l_outer[0]\n"
">>> d_first_inner['a'] = 1\n"
">>> d_first_inner['b'] = 2\n"
">>> l_outer[1]['c'] = 3\n"
">>> l_outer[1]['z'] = 26\n"
">>> print(l_outer[0])\n"
"{'a': 1, 'b': 2}\n"
">>> print(l_outer[1])\n"
"{'c': 3, 'z': 26}"

#: ../../library/multiprocessing.rst:2221
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are contained "
"in a referent, modifications to those mutable values will not be propagated "
"through the manager because the proxy has no way of knowing when the values "
"contained within are modified.  However, storing a value in a container "
"proxy (which triggers a ``__setitem__`` on the proxy object) does propagate "
"through the manager and so to effectively modify such an item, one could re-"
"assign the modified value to the container proxy::"
msgstr ""
"Se objetos :class:`list` ou :class:`dict` padrão (não proxy) estiverem "
"contidos num referente, as modificações nesses valores mutáveis não serão "
"propagadas através do gestor, porque o proxy não tem forma de saber quando "
"os valores contidos são modificados. No entanto, armazenar um valor num "
"proxy de contêiner (o que desencadeia um ``__setitem__`` no objeto proxy) "
"propaga através do gestor e, portanto, para modificar efetivamente tal item, "
"pode-se reatribuir o valor modificado ao proxy do contêiner::"

#: ../../library/multiprocessing.rst:2229
msgid ""
"# create a list proxy and append a mutable object (a dictionary)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# now mutate the dictionary\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# at this point, the changes to d are not yet synced, but by\n"
"# updating the dictionary, the proxy is notified of the change\n"
"lproxy[0] = d"
msgstr ""
"# cria um proxy de lista e anexa um objeto mutável (um dicionário)\n"
"lproxy = manager.list()\n"
"lproxy.append({})\n"
"# agora modifica o dicionário\n"
"d = lproxy[0]\n"
"d['a'] = 1\n"
"d['b'] = 2\n"
"# neste ponto, as alterações a d ainda não estão sincronizadas, mas ao\n"
"# atualizar o dicionário, o proxy é notificado da alteração\n"
"lproxy[0] = d"

#: ../../library/multiprocessing.rst:2240
msgid ""
"This approach is perhaps less convenient than employing nested :ref:"
"`multiprocessing-proxy_objects` for most use cases but also demonstrates a "
"level of control over the synchronization."
msgstr ""
"Esta abordagem pode ser menos conveniente do que usar :ref:`multiprocessing-"
"proxy_objects` aninhados para a maioria dos casos de uso, mas também "
"demonstra um nível de controlo sobre a sincronização."

#: ../../library/multiprocessing.rst:2246
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""
"Os tipos de proxy em :mod:`multiprocessing` não fazem nada para suportar "
"comparações por valor. Por exemplo, temos:"

#: ../../library/multiprocessing.rst:2249
msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"

#: ../../library/multiprocessing.rst:2254
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""
"Deve-se usar simplesmente uma cópia do referente em vez disso ao fazer "
"comparações."

#: ../../library/multiprocessing.rst:2258
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "Objetos proxy são instâncias de subclasses de :class:`BaseProxy`."

#: ../../library/multiprocessing.rst:2262
msgid "Call and return the result of a method of the proxy's referent."
msgstr "Chama e devolve o resultado de um método do referente do proxy."

#: ../../library/multiprocessing.rst:2264
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr ""
"Se ``proxy`` for um proxy cujo referente é ``obj``, então a expressão::"

#: ../../library/multiprocessing.rst:2266
msgid "proxy._callmethod(methodname, args, kwds)"
msgstr "proxy._callmethod(methodname, args, kwds)"

#: ../../library/multiprocessing.rst:2268
msgid "will evaluate the expression ::"
msgstr "avaliará a expressão::"

#: ../../library/multiprocessing.rst:2270
msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr "getattr(obj, methodname)(*args, **kwds)"

#: ../../library/multiprocessing.rst:2272
msgid "in the manager's process."
msgstr "no processo do gestor."

#: ../../library/multiprocessing.rst:2274
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""

#: ../../library/multiprocessing.rst:2278
msgid ""
"If an exception is raised by the call, then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""
"Se uma exceção for gerada pela chamada, então é regerada por :meth:"
"`_callmethod`. Se outra exceção for gerada no processo do gestor, esta é "
"convertida numa exceção :exc:`RemoteError` e é gerada por :meth:"
"`_callmethod`."

#: ../../library/multiprocessing.rst:2283
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*."
msgstr ""
"Note, em particular, que uma exceção será gerada se *methodname* não tiver "
"sido *exposto*."

#: ../../library/multiprocessing.rst:2286
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr "Um exemplo de utilização de :meth:`_callmethod`:"

#: ../../library/multiprocessing.rst:2288
msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalente a l[2:7]\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))          # equivalente a l[20]\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: índice de lista fora do intervalo"

#: ../../library/multiprocessing.rst:2302
msgid "Return a copy of the referent."
msgstr "Devolve uma cópia do referente."

#: ../../library/multiprocessing.rst:2304
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "Se o referente não for serializável, isto gerará uma exceção."

#: ../../library/multiprocessing.rst:2308
msgid "Return a representation of the proxy object."
msgstr "Devolve uma representação do objeto proxy."

#: ../../library/multiprocessing.rst:2312
msgid "Return the representation of the referent."
msgstr "Devolve a representação do referente."

#: ../../library/multiprocessing.rst:2316
msgid "Cleanup"
msgstr "Limpeza"

#: ../../library/multiprocessing.rst:2318
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""
"Um objeto proxy usa uma callback de weakref para que, quando for recolhido "
"pelo garbage collector, se desregiste do gestor que possui o seu referente."

#: ../../library/multiprocessing.rst:2321
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""
"Um objeto partilhado é eliminado do processo do gestor quando não houver "
"mais proxies a referenciá-lo."

#: ../../library/multiprocessing.rst:2326
msgid "Process Pools"
msgstr "Conjuntos de Processos"

#: ../../library/multiprocessing.rst:2331
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""
"Pode-se criar um conjunto de processos que executará tarefas submetidas a "
"ele com a classe :class:`Pool`."

#: ../../library/multiprocessing.rst:2336
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""
"Um objeto de conjunto de processos que controla um conjunto de processos "
"trabalhadores aos quais podem ser submetidas tarefas. Suporta resultados "
"assíncronos com timeouts e callbacks e tem uma implementação de mapeamento "
"paralelo."

#: ../../library/multiprocessing.rst:2340
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* é o número de processos trabalhadores a usar. Se *processes* for "
"``None``, então o número devolvido por :func:`os.process_cpu_count` é usado."

#: ../../library/multiprocessing.rst:2343
#: ../../library/multiprocessing.rst:2909
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"Se *initializer* não for ``None``, então cada processo trabalhador chamará "
"``initializer(*initargs)`` quando iniciar."

#: ../../library/multiprocessing.rst:2346
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to enable "
"unused resources to be freed. The default *maxtasksperchild* is ``None``, "
"which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* é o número de tarefas que um processo trabalhador pode "
"completar antes de terminar e ser substituído por um novo processo "
"trabalhador, para permitir que recursos não utilizados sejam libertados. O "
"valor predefinido de *maxtasksperchild* é ``None``, o que significa que os "
"processos trabalhadores viverão tanto tempo quanto o conjunto."

#: ../../library/multiprocessing.rst:2351
msgid ""
"*context* can be used to specify the context used for starting the worker "
"processes.  Usually a pool is created using the function :func:"
"`multiprocessing.Pool` or the :meth:`Pool` method of a context object.  In "
"both cases *context* is set appropriately. If ``None``, calling this "
"function will have the side effect of setting the current global start "
"method if it has not been set already. See the :func:`get_context` function."
msgstr ""

#: ../../library/multiprocessing.rst:2359
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr ""
"Note que os métodos do objeto de conjunto só devem ser chamados pelo "
"processo que criou o conjunto."

#: ../../library/multiprocessing.rst:2363
msgid ""
":class:`multiprocessing.pool` objects have internal resources that need to "
"be properly managed (like any other resource) by using the pool as a context "
"manager or by calling :meth:`close` and :meth:`terminate` manually. Failure "
"to do this can lead to the process hanging on finalization."
msgstr ""
"Os objetos :class:`multiprocessing.pool` têm recursos internos que precisam "
"de ser geridos adequadamente (como qualquer outro recurso), usando o "
"conjunto como um gestor de contexto ou chamando :meth:`close` e :meth:"
"`terminate` manualmente. A falha em fazê-lo pode levar a que o processo "
"fique bloqueado na finalização."

#: ../../library/multiprocessing.rst:2368
msgid ""
"Note that it is **not correct** to rely on the garbage collector to destroy "
"the pool as CPython does not assure that the finalizer of the pool will be "
"called (see :meth:`object.__del__` for more information)."
msgstr ""
"Note que **não é correto** confiar no garbage collector para destruir o "
"conjunto, pois o CPython não garante que o finalizador do conjunto será "
"chamado (consulte :meth:`object.__del__` para mais informações)."

#: ../../library/multiprocessing.rst:2372
msgid "Added the *maxtasksperchild* parameter."
msgstr "Adicionado o parâmetro *maxtasksperchild*."

#: ../../library/multiprocessing.rst:2375
msgid "Added the *context* parameter."
msgstr "Adicionado o parâmetro *context*."

#: ../../library/multiprocessing.rst:2378
msgid ""
"*processes* uses :func:`os.process_cpu_count` by default, instead of :func:"
"`os.cpu_count`."
msgstr ""
"*processes* usa :func:`os.process_cpu_count` por predefinição, em vez de :"
"func:`os.cpu_count`."

#: ../../library/multiprocessing.rst:2384
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other systems "
"(such as Apache, mod_wsgi, etc) to free resources held by workers is to "
"allow a worker within a pool to complete only a set amount of work before "
"being exiting, being cleaned up and a new process spawned to replace the old "
"one. The *maxtasksperchild* argument to the :class:`Pool` exposes this "
"ability to the end user."
msgstr ""
"Os processos trabalhadores dentro de um :class:`Pool` geralmente vivem "
"durante toda a duração da fila de trabalho do Pool. Um padrão frequente "
"encontrado em outros sistemas (como Apache, mod_wsgi, etc.) para libertar "
"recursos mantidos pelos trabalhadores é permitir que um trabalhador dentro "
"de um conjunto complete apenas uma quantidade definida de trabalho antes de "
"terminar, ser limpo e um novo processo ser criado para substituir o antigo. "
"O argumento *maxtasksperchild* para :class:`Pool` expõe esta capacidade ao "
"utilizador final."

#: ../../library/multiprocessing.rst:2394
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It blocks "
"until the result is ready. Given this blocks, :meth:`apply_async` is better "
"suited for performing work in parallel. Additionally, *func* is only "
"executed in one of the workers of the pool."
msgstr ""
"Chama *func* com argumentos *args* e argumentos nomeados *kwds*. Bloqueia "
"até que o resultado esteja pronto. Dado que isto bloqueia, :meth:"
"`apply_async` é mais adequado para realizar trabalho em paralelo. Além "
"disso, *func* é executado apenas em um dos trabalhadores do conjunto."

#: ../../library/multiprocessing.rst:2401
msgid ""
"A variant of the :meth:`apply` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Uma variante do método :meth:`apply` que devolve um objeto :class:"
"`~multiprocessing.pool.AsyncResult`."

#: ../../library/multiprocessing.rst:2404
#: ../../library/multiprocessing.rst:2435
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it, "
"that is unless the call failed, in which case the *error_callback* is "
"applied instead."
msgstr ""
"Se *callback* for especificado, então deve ser um objeto invocável que "
"aceite um único argumento. Quando o resultado estiver pronto, *callback* é "
"aplicado a ele, a menos que a chamada tenha falhado, caso em que "
"*error_callback* é aplicado em vez disso."

#: ../../library/multiprocessing.rst:2409
#: ../../library/multiprocessing.rst:2440
msgid ""
"If *error_callback* is specified then it should be a callable which accepts "
"a single argument.  If the target function fails, then the *error_callback* "
"is called with the exception instance."
msgstr ""
"Se *error_callback* for especificado, então deve ser um objeto invocável que "
"aceite um único argumento. Se a função alvo falhar, então *error_callback* é "
"chamado com a instância da exceção."

#: ../../library/multiprocessing.rst:2413
#: ../../library/multiprocessing.rst:2444
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr ""
"Os callbacks devem ser concluídos imediatamente, caso contrário a thread que "
"trata dos resultados ficará bloqueada."

#: ../../library/multiprocessing.rst:2418
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though, for multiple iterables see :meth:`starmap`). "
"It blocks until the result is ready."
msgstr ""
"Um equivalente paralelo da função integrada :func:`map` (suporta apenas um "
"argumento *iterable*, para vários iteráveis, consulte :meth:`starmap`). "
"Bloqueia até que o resultado esteja pronto."

#: ../../library/multiprocessing.rst:2422
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""
"Este método divide o iterável em vários blocos que submete ao conjunto de "
"processos como tarefas separadas. O tamanho (aproximado) destes blocos pode "
"ser especificado definindo *chunksize* para um inteiro positivo."

#: ../../library/multiprocessing.rst:2426
msgid ""
"Note that it may cause high memory usage for very long iterables. Consider "
"using :meth:`imap` or :meth:`imap_unordered` with explicit *chunksize* "
"option for better efficiency."
msgstr ""
"Note que isto pode causar um uso elevado de memória para iteráveis muito "
"longos. Considere usar :meth:`imap` ou :meth:`imap_unordered` com a opção "
"*chunksize* explícita para uma melhor eficiência."

#: ../../library/multiprocessing.rst:2432
msgid ""
"A variant of the :meth:`.map` method which returns a :class:"
"`~multiprocessing.pool.AsyncResult` object."
msgstr ""
"Uma variante do método :meth:`.map` que devolve um objeto :class:"
"`~multiprocessing.pool.AsyncResult`."

#: ../../library/multiprocessing.rst:2449
msgid "A lazier version of :meth:`.map`."
msgstr "Uma versão mais preguiçosa de :meth:`.map`."

#: ../../library/multiprocessing.rst:2451
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of ``1``."
msgstr ""
"O argumento *chunksize* é o mesmo que o usado pelo método :meth:`.map`. Para "
"iteráveis muito longos, usar um valor grande para *chunksize* pode fazer com "
"que a tarefa seja concluída **muito** mais rapidamente do que usar o valor "
"predefinido de ``1``."

#: ../../library/multiprocessing.rst:2456
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""
"Além disso, se *chunksize* for ``1``, então o método :meth:`!next` do "
"iterador devolvido pelo método :meth:`imap` tem um parâmetro opcional "
"*timeout*: ``next(timeout)`` gerará :exc:`multiprocessing.TimeoutError` se o "
"resultado não puder ser devolvido dentro de *timeout* segundos."

#: ../../library/multiprocessing.rst:2463
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
"O mesmo que :meth:`imap`, exceto que a ordenação dos resultados do iterador "
"devolvido deve ser considerada arbitrária. (Apenas quando há apenas um "
"processo trabalhador é que a ordem é garantidamente \"correta\".)"

#: ../../library/multiprocessing.rst:2469
msgid ""
"Like :meth:`~multiprocessing.pool.Pool.map` except that the elements of the "
"*iterable* are expected to be iterables that are unpacked as arguments."
msgstr ""
"Semelhante a :meth:`~multiprocessing.pool.Pool.map`, exceto que os elementos "
"do *iterable* são esperados ser iteráveis que são desempacotados como "
"argumentos."

#: ../../library/multiprocessing.rst:2473
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"Portanto, um *iterable* de ``[(1,2), (3, 4)]`` resulta em ``[func(1,2), "
"func(3,4)]``."

#: ../../library/multiprocessing.rst:2480
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over "
"*iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
"Uma combinação de :meth:`starmap` e :meth:`map_async` que itera sobre "
"*iterable* de iteráveis e chama *func* com os iteráveis desempacotados. "
"Devolve um objeto de resultado."

#: ../../library/multiprocessing.rst:2488
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""
"Impede que mais tarefas sejam submetidas ao conjunto. Assim que todas as "
"tarefas tiverem sido concluídas, os processos trabalhadores terminarão."

#: ../../library/multiprocessing.rst:2493
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""
"Para os processos trabalhadores imediatamente sem concluir o trabalho "
"pendente. Quando o objeto do conjunto for recolhido pelo garbage collector, :"
"meth:`terminate` será chamado imediatamente."

#: ../../library/multiprocessing.rst:2499
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""
"Aguarda que os processos trabalhadores terminem. Deve chamar :meth:`close` "
"ou :meth:`terminate` antes de usar :meth:`join`."

#: ../../library/multiprocessing.rst:2502
msgid ""
"Pool objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the pool "
"object, and :meth:`~contextmanager.__exit__` calls :meth:`terminate`."
msgstr ""
"Os objetos Pool agora suportam o protocolo de gestão de contexto -- "
"consulte :ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` "
"devolve o objeto pool, e :meth:`~contextmanager.__exit__` chama :meth:"
"`terminate`."

#: ../../library/multiprocessing.rst:2510
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""
"A classe do resultado devolvido por :meth:`Pool.apply_async` e :meth:`Pool."
"map_async`."

#: ../../library/multiprocessing.rst:2515
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""
"Devolve o resultado quando este chegar. Se *timeout* não for ``None`` e o "
"resultado não chegar dentro de *timeout* segundos, então :exc:"
"`multiprocessing.TimeoutError` é gerado. Se a chamada remota gerar uma "
"exceção, então essa exceção será regerada por :meth:`get`."

#: ../../library/multiprocessing.rst:2522
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""
"Aguarda até que o resultado esteja disponível ou até que passem *timeout* "
"segundos."

#: ../../library/multiprocessing.rst:2526
msgid "Return whether the call has completed."
msgstr "Devolve se a chamada foi concluída."

#: ../../library/multiprocessing.rst:2530
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`ValueError` if the result is not ready."
msgstr ""
"Devolve se a chamada foi concluída sem gerar uma exceção. Gerará :exc:"
"`ValueError` se o resultado não estiver pronto."

#: ../../library/multiprocessing.rst:2533
msgid ""
"If the result is not ready, :exc:`ValueError` is raised instead of :exc:"
"`AssertionError`."
msgstr ""
"Se o resultado não estiver pronto, :exc:`ValueError` é gerado em vez de :exc:"
"`AssertionError`."

#: ../../library/multiprocessing.rst:2537
msgid "The following example demonstrates the use of a pool::"
msgstr "O seguinte exemplo demonstra a utilização de um conjunto::"

#: ../../library/multiprocessing.rst:2539
msgid ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # start 4 worker processes\n"
"        result = pool.apply_async(f, (10,)) # evaluate \"f(10)\" "
"asynchronously in a single process\n"
"        print(result.get(timeout=1))        # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"        print(pool.map(f, range(10)))       # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # prints \"0\"\n"
"        print(next(it))                     # prints \"1\"\n"
"        print(it.next(timeout=1))           # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # raises multiprocessing."
"TimeoutError"
msgstr ""
"from multiprocessing import Pool\n"
"import time\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    with Pool(processes=4) as pool:         # inicia 4 processos "
"trabalhadores\n"
"        result = pool.apply_async(f, (10,)) # avalia \"f(10)\" de forma "
"assíncrona num único processo\n"
"        print(result.get(timeout=1))        # imprime \"100\" a menos que o "
"seu computador seja *muito* lento\n"
"\n"
"        print(pool.map(f, range(10)))       # imprime \"[0, 1, 4,..., 81]\"\n"
"\n"
"        it = pool.imap(f, range(10))\n"
"        print(next(it))                     # imprime \"0\"\n"
"        print(next(it))                     # imprime \"1\"\n"
"        print(it.__next__(timeout=1))           # imprime \"4\" a menos que "
"o seu computador seja *muito* lento\n"
"\n"
"        result = pool.apply_async(time.sleep, (10,))\n"
"        print(result.get(timeout=1))        # gera multiprocessing."
"TimeoutError"

#: ../../library/multiprocessing.rst:2564
msgid "Listeners and Clients"
msgstr "Ouvintes e Clientes"

#: ../../library/multiprocessing.rst:2569
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`~Connection` objects returned by :func:`~multiprocessing.Pipe`."
msgstr ""
"Normalmente, a passagem de mensagens entre processos é feita usando filas ou "
"usando objetos :class:`~Connection` devolvidos por :func:`~multiprocessing."
"Pipe`."

#: ../../library/multiprocessing.rst:2573
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"No entanto, o módulo :mod:`multiprocessing.connection` permite alguma "
"flexibilidade extra. Basicamente, fornece uma API orientada a mensagens de "
"alto nível para lidar com sockets ou pipes nomeados do Windows. Também tem "
"suporte para *autenticação por digest* usando o módulo :mod:`hmac` e para "
"sondar várias ligações ao mesmo tempo."

#: ../../library/multiprocessing.rst:2582
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""
"Envie uma mensagem gerada aleatoriamente para a outra extremidade da ligação "
"e aguarde por uma resposta."

#: ../../library/multiprocessing.rst:2585
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Se a resposta corresponder ao digest da mensagem usando *authkey* como "
"chave, então uma mensagem de boas-vindas é enviada para a outra extremidade "
"da ligação. Caso contrário, :exc:`~multiprocessing.AuthenticationError` é "
"gerado."

#: ../../library/multiprocessing.rst:2591
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""
"Recebe uma mensagem, calcula o digest da mensagem usando *authkey* como "
"chave, e depois envia o digest de volta."

#: ../../library/multiprocessing.rst:2594
msgid ""
"If a welcome message is not received, then :exc:`~multiprocessing."
"AuthenticationError` is raised."
msgstr ""
"Se uma mensagem de boas-vindas não for recebida, então :exc:"
"`~multiprocessing.AuthenticationError` é gerado."

#: ../../library/multiprocessing.rst:2599
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"Tenta estabelecer uma ligação ao ouvinte que está a usar o endereço "
"*address*, devolvendo um :class:`~Connection`."

#: ../../library/multiprocessing.rst:2602
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"O tipo de ligação é determinado pelo argumento *family*, mas este pode "
"geralmente ser omitido, uma vez que pode ser inferido a partir do formato de "
"*address*. (Consulte :ref:`multiprocessing-address-formats`)"

#: ../../library/multiprocessing.rst:2606
#: ../../library/multiprocessing.rst:2641
msgid ""
"If *authkey* is given and not ``None``, it should be a byte string and will "
"be used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is ``None``. :exc:`~multiprocessing."
"AuthenticationError` is raised if authentication fails. See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""
"Se *authkey* for fornecido e não for ``None``, deve ser uma string de bytes "
"e será usado como a chave secreta para um desafio de autenticação baseado em "
"HMAC. Não é feita autenticação se *authkey* for ``None``. :exc:"
"`~multiprocessing.AuthenticationError` é gerado se a autenticação falhar. "
"Consulte :ref:`multiprocessing-auth-keys`."

#: ../../library/multiprocessing.rst:2614
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""
"Um wrapper para um socket ligado ou um pipe nomeado do Windows que está 'à "
"escuta' de ligações."

#: ../../library/multiprocessing.rst:2617
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""
"*address* é o endereço a ser usado pelo socket ligado ou pipe nomeado do "
"objeto ouvinte."

#: ../../library/multiprocessing.rst:2622
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""
"Se um endereço de '0.0.0.0' for usado, o endereço não será um ponto final "
"conectável no Windows. Se precisar de um ponto final conectável, deve usar "
"'127.0.0.1'."

#: ../../library/multiprocessing.rst:2626
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""
"*family* é o tipo de socket (ou pipe nomeado) a usar. Pode ser uma das "
"strings ``'AF_INET'`` (para um socket TCP), ``'AF_UNIX'`` (para um socket de "
"domínio Unix) ou ``'AF_PIPE'`` (para um pipe nomeado do Windows). Destes, "
"apenas o primeiro está garantidamente disponível. Se *family* for ``None``, "
"então a família é inferida a partir do formato de *address*. Se *address* "
"também for ``None``, então é escolhido um valor predefinido. Este valor "
"predefinido é a família que se assume ser a mais rápida disponível. "
"Consulte :ref:`multiprocessing-address-formats`. Note que, se *family* for "
"``'AF_UNIX'`` e *address* for ``None``, então o socket será criado num "
"diretório temporário privado criado usando :func:`tempfile.mkstemp`."

#: ../../library/multiprocessing.rst:2637
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`~socket.socket.listen` method of the socket once it has been "
"bound."
msgstr ""
"Se o objeto ouvinte usar um socket, então *backlog* (1 por predefinição) é "
"passado para o método :meth:`~socket.socket.listen` do socket assim que este "
"for ligado."

#: ../../library/multiprocessing.rst:2649
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`~Connection` object. If authentication is attempted and "
"fails, then :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"Aceita uma ligação no socket ligado ou pipe nomeado do objeto ouvinte e "
"devolve um objeto :class:`~Connection`. Se a autenticação for tentada e "
"falhar, então :exc:`~multiprocessing.AuthenticationError` é gerado."

#: ../../library/multiprocessing.rst:2656
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""
"Fecha o socket ligado ou pipe nomeado do objeto ouvinte. Isto é chamado "
"automaticamente quando o ouvinte é recolhido pelo garbage collector. No "
"entanto, é aconselhável chamá-lo explicitamente."

#: ../../library/multiprocessing.rst:2660
msgid "Listener objects have the following read-only properties:"
msgstr "Os objetos ouvintes têm as seguintes propriedades apenas de leitura:"

#: ../../library/multiprocessing.rst:2664
msgid "The address which is being used by the Listener object."
msgstr "O endereço que está a ser usado pelo objeto Listener."

#: ../../library/multiprocessing.rst:2668
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""
"O endereço de onde veio a última ligação aceite. Se isto não estiver "
"disponível, então é ``None``."

#: ../../library/multiprocessing.rst:2671
msgid ""
"Listener objects now support the context management protocol -- see :ref:"
"`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the "
"listener object, and :meth:`~contextmanager.__exit__` calls :meth:`close`."
msgstr ""
"Os objetos ouvintes agora suportam o protocolo de gestão de contexto -- "
"consulte :ref:`typecontextmanager`. :meth:`~contextmanager.__enter__` "
"devolve o objeto ouvinte, e :meth:`~contextmanager.__exit__` chama :meth:"
"`close`."

#: ../../library/multiprocessing.rst:2678
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those "
"objects in *object_list* which are ready.  If *timeout* is a float then the "
"call blocks for at most that many seconds.  If *timeout* is ``None`` then it "
"will block for an unlimited period. A negative timeout is equivalent to a "
"zero timeout."
msgstr ""
"Aguarda até que um objeto em *object_list* esteja pronto. Devolve a lista "
"daqueles objetos em *object_list* que estão prontos. Se *timeout* for um "
"float, então a chamada bloqueia durante, no máximo, esse número de segundos. "
"Se *timeout* for ``None``, então bloqueará por um período ilimitado. Um "
"timeout negativo é equivalente a um timeout zero."

#: ../../library/multiprocessing.rst:2684
msgid ""
"For both POSIX and Windows, an object can appear in *object_list* if it is"
msgstr ""
"Tanto para POSIX como para Windows, um objeto pode aparecer em *object_list* "
"se for"

#: ../../library/multiprocessing.rst:2687
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "um objeto :class:`~multiprocessing.connection.Connection` legível;"

#: ../../library/multiprocessing.rst:2688
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "um objeto :class:`socket.socket` conectado e legível; ou"

#: ../../library/multiprocessing.rst:2689
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a :class:"
"`~multiprocessing.Process` object."
msgstr ""
"o atributo :attr:`~multiprocessing.Process.sentinel` de um objeto :class:"
"`~multiprocessing.Process`."

#: ../../library/multiprocessing.rst:2692
msgid ""
"A connection or socket object is ready when there is data available to be "
"read from it, or the other end has been closed."
msgstr ""
"Um objeto de ligação ou socket está pronto quando há dados disponíveis para "
"serem lidos a partir dele, ou a outra extremidade foi fechada."

#: ../../library/multiprocessing.rst:2695
msgid ""
"**POSIX**: ``wait(object_list, timeout)`` almost equivalent ``select."
"select(object_list, [], [], timeout)``.  The difference is that, if :func:"
"`select.select` is interrupted by a signal, it can raise :exc:`OSError` with "
"an error number of ``EINTR``, whereas :func:`wait` will not."
msgstr ""
"**POSIX**: ``wait(object_list, timeout)`` é quase equivalente a ``select."
"select(object_list, [], [], timeout)``. A diferença é que, se :func:`select."
"select` for interrompido por um sinal, pode gerar :exc:`OSError` com um "
"número de erro de ``EINTR``, enquanto :func:`wait` não o fará."

#: ../../library/multiprocessing.rst:2701
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle which "
"is waitable (according to the definition used by the documentation of the "
"Win32 function ``WaitForMultipleObjects()``) or it can be an object with a :"
"meth:`~io.IOBase.fileno` method which returns a socket handle or pipe "
"handle.  (Note that pipe handles and socket handles are **not** waitable "
"handles.)"
msgstr ""
"**Windows**: Um item em *object_list* deve ser um identificador inteiro que "
"seja aguardável (de acordo com a definição usada pela documentação da função "
"Win32 ``WaitForMultipleObjects()``) ou pode ser um objeto com um método :"
"meth:`~io.IOBase.fileno` que devolve um identificador de socket ou de pipe. "
"(Note que os identificadores de pipe e de socket **não** são identificadores "
"aguardáveis.)"

#: ../../library/multiprocessing.rst:2711
msgid "**Examples**"
msgstr "**Exemplos**"

#: ../../library/multiprocessing.rst:2713
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""
"O seguinte código de servidor cria um ouvinte que usa ``'secret password'`` "
"como uma chave de autenticação. Em seguida, aguarda por uma ligação e envia "
"alguns dados para o cliente::"

#: ../../library/multiprocessing.rst:2717
msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'secret password') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('connection accepted from', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'junk', float])\n"
"\n"
"        conn.send_bytes(b'hello')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"
msgstr ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # a família é deduzida como 'AF_INET'\n"
"\n"
"with Listener(address, authkey=b'senha secreta') as listener:\n"
"    with listener.accept() as conn:\n"
"        print('ligação aceite de', listener.last_accepted)\n"
"\n"
"        conn.send([2.25, None, 'lixo', float])\n"
"\n"
"        conn.send_bytes(b'olá')\n"
"\n"
"        conn.send_bytes(array('i', [42, 1729]))"

#: ../../library/multiprocessing.rst:2732
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""
"O seguinte código liga-se ao servidor e recebe alguns dados do servidor::"

#: ../../library/multiprocessing.rst:2735
msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'secret password') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'junk', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'hello'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"
msgstr ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"\n"
"with Client(address, authkey=b'senha secreta') as conn:\n"
"    print(conn.recv())                  # => [2.25, None, 'lixo', float]\n"
"\n"
"    print(conn.recv_bytes())            # => 'olá'\n"
"\n"
"    arr = array('i', [0, 0, 0, 0, 0])\n"
"    print(conn.recv_bytes_into(arr))    # => 8\n"
"    print(arr)                          # => array('i', [42, 1729, 0, 0, 0])"

#: ../../library/multiprocessing.rst:2749
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait for "
"messages from multiple processes at once::"
msgstr ""
"O seguinte código usa :func:`~multiprocessing.connection.wait` para aguardar "
"mensagens de vários processos de uma vez::"

#: ../../library/multiprocessing.rst:2752
msgid ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # We close the writable end of the pipe now to be sure that\n"
"        # p is the only process which owns a handle for it.  This\n"
"        # ensures that when p closes its handle for the writable end,\n"
"        # wait() will promptly report the readable end as being ready.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"
msgstr ""
"from multiprocessing import Process, Pipe, current_process\n"
"from multiprocessing.connection import wait\n"
"\n"
"def foo(w):\n"
"    for i in range(10):\n"
"        w.send((i, current_process().name))\n"
"    w.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    readers = []\n"
"\n"
"    for i in range(4):\n"
"        r, w = Pipe(duplex=False)\n"
"        readers.append(r)\n"
"        p = Process(target=foo, args=(w,))\n"
"        p.start()\n"
"        # Fechamos agora a extremidade gravável do pipe para garantir que\n"
"        # p é o único processo que possui um identificador para ela. Isto\n"
"        # garante que, quando p fecha o seu identificador para a extremidade "
"gravável,\n"
"        # wait() reportará prontamente a extremidade legível como estando "
"pronta.\n"
"        w.close()\n"
"\n"
"    while readers:\n"
"        for r in wait(readers):\n"
"            try:\n"
"                msg = r.recv()\n"
"            except EOFError:\n"
"                readers.remove(r)\n"
"            else:\n"
"                print(msg)"

#: ../../library/multiprocessing.rst:2787
msgid "Address Formats"
msgstr "Formatos de Endereço"

#: ../../library/multiprocessing.rst:2789
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""
"Um endereço ``'AF_INET'`` é um tuplo da forma ``(hostname, port)``, onde "
"*nome_do_anfitrião* é uma string e *porta* é um inteiro."

#: ../../library/multiprocessing.rst:2792
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""
"Um endereço ``'AF_UNIX'`` é uma string que representa um nome de ficheiro no "
"sistema de ficheiros."

#: ../../library/multiprocessing.rst:2795
msgid ""
"An ``'AF_PIPE'`` address is a string of the form :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`.  To use :func:`Client` to connect to a named "
"pipe on a remote computer called *ServerName* one should use an address of "
"the form :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"instead."
msgstr ""
"Um endereço ``'AF_PIPE'`` é uma string da forma :samp:`r'\\\\\\\\\\\\.\\"
"\\pipe\\\\\\\\{PipeName}'`. Para usar :func:`Client` para ligar a um pipe "
"nomeado num computador remoto chamado *ServerName*, deve-se usar um endereço "
"da forma :samp:`r'\\\\\\\\\\\\\\\\{ServerName}\\\\pipe\\\\\\\\{PipeName}'` "
"em vez disso."

#: ../../library/multiprocessing.rst:2800
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"Note que qualquer string que comece com duas barras invertidas é assumida, "
"por predefinição, como sendo um endereço ``'AF_PIPE'`` em vez de um endereço "
"``'AF_UNIX'``."

#: ../../library/multiprocessing.rst:2807
msgid "Authentication keys"
msgstr "Chaves de Autenticação"

#: ../../library/multiprocessing.rst:2809
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data received "
"is automatically unpickled. Unfortunately unpickling data from an untrusted "
"source is a security risk. Therefore :class:`Listener` and :func:`Client` "
"use the :mod:`hmac` module to provide digest authentication."
msgstr ""
"Quando se usa :meth:`Connection.recv <Connection.recv>`, os dados recebidos "
"são automaticamente desserializados. Infelizmente, desserializar dados de "
"uma fonte não confiável é um risco de segurança. Portanto, :class:`Listener` "
"e :func:`Client` usam o módulo :mod:`hmac` para fornecer autenticação por "
"digest."

#: ../../library/multiprocessing.rst:2815
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof that "
"the other knows the authentication key.  (Demonstrating that both ends are "
"using the same key does **not** involve sending the key over the connection.)"
msgstr ""
"Uma chave de autenticação é uma string de bytes que pode ser pensada como "
"uma senha: uma vez estabelecida uma ligação, ambas as extremidades exigirão "
"prova de que a outra conhece a chave de autenticação. (Demonstrar que ambas "
"as extremidades estão a usar a mesma chave **não** envolve enviar a chave "
"através da ligação.)"

#: ../../library/multiprocessing.rst:2821
msgid ""
"If authentication is requested but no authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will be automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""
"Se a autenticação for solicitada, mas nenhuma chave de autenticação for "
"especificada, então o valor devolvido por ``current_process().authkey`` é "
"usado (consulte :class:`~multiprocessing.Process`). Este valor será "
"automaticamente herdado por qualquer objeto :class:`~multiprocessing."
"Process` que o processo atual crie. Isto significa que (por predefinição) "
"todos os processos de um programa multiprocessos partilharão uma única chave "
"de autenticação que pode ser usada ao estabelecer ligações entre si."

#: ../../library/multiprocessing.rst:2829
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""
"Chaves de autenticação adequadas também podem ser geradas usando :func:`os."
"urandom`."

#: ../../library/multiprocessing.rst:2833
msgid "Logging"
msgstr "A criar registo"

#: ../../library/multiprocessing.rst:2835
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""
"Existe algum suporte para registo. No entanto, note que o pacote :mod:"
"`logging` não usa bloqueios partilhados entre processos, pelo que é possível "
"(dependendo do tipo de manipulador) que mensagens de diferentes processos se "
"misturem."

#: ../../library/multiprocessing.rst:2842
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""
"Devolve o registador usado por :mod:`multiprocessing`. Se necessário, um "
"novo será criado."

#: ../../library/multiprocessing.rst:2845
msgid ""
"When first created the logger has level :const:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""
"Quando criado pela primeira vez, o registador tem o nível :const:`logging."
"NOTSET` e nenhum manipulador predefinido. As mensagens enviadas para este "
"registador não se propagarão, por predefinição, para o registador raiz."

#: ../../library/multiprocessing.rst:2849
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""
"Note que, no Windows, os processos filhos herdarão apenas o nível do "
"registador do processo pai -- qualquer outra personalização do registador "
"não será herdada."

#: ../../library/multiprocessing.rst:2856
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``. You can modify ``levelname`` of the logger by passing a "
"``level`` argument."
msgstr ""
"Esta função realiza uma chamada a :func:`get_logger`, mas, além de devolver "
"o registador criado por get_logger, adiciona um manipulador que envia a "
"saída para :data:`sys.stderr` usando o formato ``'[%(levelname)s/"
"%(processName)s] %(message)s'``. Pode modificar o ``levelname`` do "
"registador passando um argumento ``level``."

#: ../../library/multiprocessing.rst:2862
msgid "Below is an example session with logging turned on::"
msgstr "Em baixo está uma sessão de exemplo com o registo ativado::"

#: ../../library/multiprocessing.rst:2864
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[AVISO/ProcessoPrincipal] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/GestorSincronizado-...] processo filho a chamar self.run()\n"
"[INFO/GestorSincronizado-...] criado diretório temporário /.../pymp-...\n"
"[INFO/GestorSincronizado-...] gestor a servir em '/.../listener-...'\n"
">>> del m\n"
"[INFO/ProcessoPrincipal] a enviar mensagem de encerramento para o gestor\n"
"[INFO/GestorSincronizado-...] gestor a sair com código de saída 0"

#: ../../library/multiprocessing.rst:2877
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""
"Para uma tabela completa dos níveis de registo, consulte o módulo :mod:"
"`logging`."

#: ../../library/multiprocessing.rst:2881
msgid "The :mod:`multiprocessing.dummy` module"
msgstr "O módulo :mod:`multiprocessing.dummy`"

#: ../../library/multiprocessing.rst:2886
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` replica a API de :mod:`multiprocessing`, mas "
"não é mais do que um invólucro em torno do módulo :mod:`threading`."

#: ../../library/multiprocessing.rst:2891
msgid ""
"In particular, the ``Pool`` function provided by :mod:`multiprocessing."
"dummy` returns an instance of :class:`ThreadPool`, which is a subclass of :"
"class:`Pool` that supports all the same method calls but uses a pool of "
"worker threads rather than worker processes."
msgstr ""
"Em particular, a função ``Pool`` fornecida por :mod:`multiprocessing.dummy` "
"retorna uma instância de :class:`ThreadPool`, que é uma subclasse de :class:"
"`Pool` que suporta todas as mesmas chamadas de método, mas usa um conjunto "
"de *threads* de trabalho em vez de processos de trabalho."

#: ../../library/multiprocessing.rst:2899
msgid ""
"A thread pool object which controls a pool of worker threads to which jobs "
"can be submitted.  :class:`ThreadPool` instances are fully interface "
"compatible with :class:`Pool` instances, and their resources must also be "
"properly managed, either by using the pool as a context manager or by "
"calling :meth:`~multiprocessing.pool.Pool.close` and :meth:`~multiprocessing."
"pool.Pool.terminate` manually."
msgstr ""
"Um objeto de conjunto de *threads* que controla um conjunto de *threads* de "
"trabalho às quais podem ser submetidos trabalhos. As instâncias de :class:"
"`ThreadPool` são totalmente compatíveis com as instâncias de :class:`Pool`, "
"e os seus recursos também devem ser geridos corretamente, quer usando o "
"conjunto como um gestor de contexto, quer chamando :meth:`~multiprocessing."
"pool.Pool.close` e :meth:`~multiprocessing.pool.Pool.terminate` manualmente."

#: ../../library/multiprocessing.rst:2906
msgid ""
"*processes* is the number of worker threads to use.  If *processes* is "
"``None`` then the number returned by :func:`os.process_cpu_count` is used."
msgstr ""
"*processes* é o número de *threads* de trabalho a usar. Se *processes* for "
"``None``, é usado o número retornado por :func:`os.process_cpu_count`."

#: ../../library/multiprocessing.rst:2912
msgid ""
"Unlike :class:`Pool`, *maxtasksperchild* and *context* cannot be provided."
msgstr ""
"Ao contrário de :class:`Pool`, *maxtasksperchild* e *context* não podem ser "
"fornecidos."

#: ../../library/multiprocessing.rst:2916
msgid ""
"A :class:`ThreadPool` shares the same interface as :class:`Pool`, which is "
"designed around a pool of processes and predates the introduction of the :"
"class:`concurrent.futures` module.  As such, it inherits some operations "
"that don't make sense for a pool backed by threads, and it has its own type "
"for representing the status of asynchronous jobs, :class:`AsyncResult`, that "
"is not understood by any other libraries."
msgstr ""
"Um :class:`ThreadPool` partilha a mesma interface que :class:`Pool`, que foi "
"concebida em torno de um conjunto de processos e precede a introdução do "
"módulo :class:`concurrent.futures`. Como tal, herda algumas operações que "
"não fazem sentido para um conjunto suportado por *threads*, e tem o seu "
"próprio tipo para representar o estado de trabalhos assíncronos, :class:"
"`AsyncResult`, que não é compreendido por outras bibliotecas."

#: ../../library/multiprocessing.rst:2923
msgid ""
"Users should generally prefer to use :class:`concurrent.futures."
"ThreadPoolExecutor`, which has a simpler interface that was designed around "
"threads from the start, and which returns :class:`concurrent.futures.Future` "
"instances that are compatible with many other libraries, including :mod:"
"`asyncio`."
msgstr ""
"Os utilizadores devem, em geral, preferir usar :class:`concurrent.futures."
"ThreadPoolExecutor`, que tem uma interface mais simples concebida em torno "
"de *threads* desde o início, e que retorna instâncias de :class:`concurrent."
"futures.Future` que são compatíveis com muitas outras bibliotecas, "
"incluindo :mod:`asyncio`."

#: ../../library/multiprocessing.rst:2933
msgid "Programming guidelines"
msgstr "Diretrizes de programação"

#: ../../library/multiprocessing.rst:2935
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""
"Existem certas diretrizes e idiomas que devem ser seguidos ao usar :mod:"
"`multiprocessing`."

#: ../../library/multiprocessing.rst:2940
msgid "All start methods"
msgstr "Todos os métodos de início"

#: ../../library/multiprocessing.rst:2942
msgid "The following applies to all start methods."
msgstr "O seguinte aplica-se a todos os métodos de início."

#: ../../library/multiprocessing.rst:2944
msgid "Avoid shared state"
msgstr "Evitar estado partilhado"

#: ../../library/multiprocessing.rst:2946
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""
"Sempre que possível, deve-se evitar transferir grandes quantidades de dados "
"entre processos."

#: ../../library/multiprocessing.rst:2949
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr ""
"Provavelmente, é melhor usar filas ou tubos para comunicação entre "
"processos, em vez de usar primitivas de sincronização de nível inferior."

#: ../../library/multiprocessing.rst:2953
msgid "Picklability"
msgstr "Capacidade de serialização"

#: ../../library/multiprocessing.rst:2955
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr ""
"Certifique-se de que os argumentos dos métodos dos *proxies* são "
"serializáveis."

#: ../../library/multiprocessing.rst:2957
msgid "Thread safety of proxies"
msgstr "Segurança de *threads* de *proxies*"

#: ../../library/multiprocessing.rst:2959
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""
"Não utilize um objeto *proxy* a partir de mais do que uma *thread*, a menos "
"que o proteja com um bloqueio."

#: ../../library/multiprocessing.rst:2962
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""
"(Não há nunca um problema com diferentes processos a usar o *mesmo* proxy.)"

#: ../../library/multiprocessing.rst:2964
msgid "Joining zombie processes"
msgstr "Juntar processos zumbi"

#: ../../library/multiprocessing.rst:2966
msgid ""
"On POSIX when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all completed "
"processes which have not yet been joined will be joined.  Also calling a "
"finished process's :meth:`Process.is_alive <multiprocessing.Process."
"is_alive>` will join the process.  Even so it is probably good practice to "
"explicitly join all the processes that you start."
msgstr ""
"Em sistemas POSIX, quando um processo termina mas não foi juntado, torna-se "
"um zumbi. Não deve haver muitos, porque sempre que um novo processo é "
"iniciado (ou :func:`~multiprocessing.active_children` é chamado), todos os "
"processos concluídos que ainda não foram juntados serão juntados. Também "
"chamar :meth:`Process.is_alive <multiprocessing.Process.is_alive>` de um "
"processo terminado juntará o processo. Ainda assim, é provavelmente uma boa "
"prática juntar explicitamente todos os processos que iniciar."

#: ../../library/multiprocessing.rst:2974
msgid "Better to inherit than pickle/unpickle"
msgstr "Melhor herdar do que serializar/desserializar"

#: ../../library/multiprocessing.rst:2976
msgid ""
"When using the *spawn* or *forkserver* start methods many types from :mod:"
"`multiprocessing` need to be picklable so that child processes can use "
"them.  However, one should generally avoid sending shared objects to other "
"processes using pipes or queues. Instead you should arrange the program so "
"that a process which needs access to a shared resource created elsewhere can "
"inherit it from an ancestor process."
msgstr ""
"Ao usar os métodos de início *spawn* ou *forkserver*, muitos tipos de :mod:"
"`multiprocessing` precisam de ser serializáveis para que os processos filhos "
"possam usá-los. No entanto, deve-se evitar geralmente enviar objetos "
"partilhados para outros processos usando tubos ou filas. Em vez disso, deve "
"organizar o programa de forma a que um processo que necessite de aceder a um "
"recurso partilhado criado noutro local possa herdá-lo de um processo "
"ancestral."

#: ../../library/multiprocessing.rst:2984
msgid "Avoid terminating processes"
msgstr "Evitar terminar processos"

#: ../../library/multiprocessing.rst:2986
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as "
"locks, semaphores, pipes and queues) currently being used by the process to "
"become broken or unavailable to other processes."
msgstr ""
"Usar o método :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"para parar um processo pode causar que quaisquer recursos partilhados (como "
"bloqueios, semáforos, tubos e filas) atualmente usados pelo processo se "
"tornem danificados ou indisponíveis para outros processos."

#: ../../library/multiprocessing.rst:2992
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate <multiprocessing.Process.terminate>` on processes which never use "
"any shared resources."
msgstr ""
"Portanto, é provavelmente melhor considerar o uso de :meth:`Process."
"terminate <multiprocessing.Process.terminate>` apenas em processos que nunca "
"usam quaisquer recursos partilhados."

#: ../../library/multiprocessing.rst:2996
msgid "Joining processes that use queues"
msgstr "Juntar processos que usam filas"

#: ../../library/multiprocessing.rst:2998
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` method of the "
"queue to avoid this behaviour.)"
msgstr ""
"Tenha em mente que um processo que colocou itens numa fila aguardará antes "
"de terminar até que todos os itens em buffer sejam alimentados pela *thread* "
"\"feeder\" para o tubo subjacente. (O processo filho pode chamar o método :"
"meth:`Queue.cancel_join_thread <multiprocessing.Queue.cancel_join_thread>` "
"da fila para evitar este comportamento.)"

#: ../../library/multiprocessing.rst:3004
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be joined automatically."
msgstr ""
"Isto significa que sempre que usar uma fila, deve garantir que todos os "
"itens que foram colocados na fila serão eventualmente removidos antes de o "
"processo ser juntado. Caso contrário, não pode ter a certeza de que os "
"processos que colocaram itens na fila irão terminar. Lembre-se também de que "
"os processos não-daemónicos serão juntados automaticamente."

#: ../../library/multiprocessing.rst:3010
msgid "An example which will deadlock is the following::"
msgstr "Um exemplo que causará impasse é o seguinte::"

#: ../../library/multiprocessing.rst:3012
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""

#: ../../library/multiprocessing.rst:3024
msgid ""
"A fix here would be to swap the last two lines (or simply remove the ``p."
"join()`` line)."
msgstr ""
"Uma correção aqui seria trocar as duas últimas linhas (ou simplesmente "
"remover a linha ``p.join()``)."

#: ../../library/multiprocessing.rst:3027
msgid "Explicitly pass resources to child processes"
msgstr "Passar recursos explicitamente para processos filhos"

#: ../../library/multiprocessing.rst:3029
msgid ""
"On POSIX using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the constructor "
"for the child process."
msgstr ""
"Em sistemas POSIX, usando o método de início *fork*, um processo filho pode "
"usar um recurso partilhado criado num processo pai usando um recurso global. "
"No entanto, é melhor passar o objeto como argumento ao construtor do "
"processo filho."

#: ../../library/multiprocessing.rst:3034
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process is "
"still alive the object will not be garbage collected in the parent process.  "
"This might be important if some resource is freed when the object is garbage "
"collected in the parent process."
msgstr ""
"Além de tornar o código (potencialmente) compatível com Windows e outros "
"métodos de início, isto também garante que, enquanto o processo filho "
"estiver ativo, o objeto não será recolhido pelo *garbage collector* no "
"processo pai. Isto pode ser importante se algum recurso for libertado quando "
"o objeto for recolhido pelo *garbage collector* no processo pai."

#: ../../library/multiprocessing.rst:3041
msgid "So for instance ::"
msgstr "Por exemplo ::"

#: ../../library/multiprocessing.rst:3043
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""

#: ../../library/multiprocessing.rst:3053
msgid "should be rewritten as ::"
msgstr ""

#: ../../library/multiprocessing.rst:3055
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"    for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""

#: ../../library/multiprocessing.rst:3065
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ""
"Cuidado ao substituir :data:`sys.stdin` por um objeto \"tipo ficheiro\""

#: ../../library/multiprocessing.rst:3067
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ""

#: ../../library/multiprocessing.rst:3069
msgid "os.close(sys.stdin.fileno())"
msgstr ""

#: ../../library/multiprocessing.rst:3071
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""

#: ../../library/multiprocessing.rst:3074
msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.open(os.devnull, os.O_RDONLY), closefd=False)"
msgstr ""

#: ../../library/multiprocessing.rst:3077
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :meth:"
"`~io.IOBase.close` on this file-like object, it could result in the same "
"data being flushed to the object multiple times, resulting in corruption."
msgstr ""

#: ../../library/multiprocessing.rst:3084
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""

#: ../../library/multiprocessing.rst:3088
msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""

#: ../../library/multiprocessing.rst:3096
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""

#: ../../library/multiprocessing.rst:3102
msgid "The *spawn* and *forkserver* start methods"
msgstr "Os métodos de início *spawn* e *forkserver*"

#: ../../library/multiprocessing.rst:3104
msgid ""
"There are a few extra restrictions which don't apply to the *fork* start "
"method."
msgstr ""
"Existem algumas restrições adicionais que não se aplicam ao método de início "
"*fork*."

#: ../../library/multiprocessing.rst:3107
msgid "More picklability"
msgstr "Mais capacidade de serialização"

#: ../../library/multiprocessing.rst:3109
msgid ""
"Ensure that all arguments to :class:`~multiprocessing.Process` are "
"picklable.  Also, if you subclass ``Process.__init__``, you must make sure "
"that instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
"Certifique-se de que todos os argumentos para :class:`~multiprocessing."
"Process` são serializáveis. Também, se criar uma subclasse de ``Process."
"__init__``, deve garantir que as instâncias serão serializáveis quando o "
"método :meth:`Process.start <multiprocessing.Process.start>` for chamado."

#: ../../library/multiprocessing.rst:3114
msgid "Global variables"
msgstr "Variáveis globais"

#: ../../library/multiprocessing.rst:3116
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start <multiprocessing."
"Process.start>` was called."
msgstr ""
"Tenha em mente que, se o código executado num processo filho tentar aceder a "
"uma variável global, o valor que vê (se existir) pode não ser o mesmo que o "
"valor no processo pai no momento em que :meth:`Process.start "
"<multiprocessing.Process.start>` foi chamado."

#: ../../library/multiprocessing.rst:3121
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""
"No entanto, variáveis globais que são apenas constantes a nível de módulo "
"não causam problemas."

#: ../../library/multiprocessing.rst:3126
msgid "Safe importing of main module"
msgstr "Importação segura do módulo principal"

#: ../../library/multiprocessing.rst:3128
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such as starting a new "
"process)."
msgstr ""
"Certifique-se de que o módulo principal pode ser importado com segurança por "
"um novo interpretador Python sem causar efeitos secundários indesejados "
"(como iniciar um novo processo)."

#: ../../library/multiprocessing.rst:3132
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"Por exemplo, usando o método de início *spawn* ou *forkserver*, executar o "
"seguinte módulo falharia com um :exc:`RuntimeError`::"

#: ../../library/multiprocessing.rst:3136
msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""

#: ../../library/multiprocessing.rst:3144
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""
"Em vez disso, deve proteger o \"ponto de entrada\" do programa usando ``if "
"__name__ == '__main__':`` da seguinte forma::"

#: ../../library/multiprocessing.rst:3147
msgid ""
"from multiprocessing import Process, freeze_support, set_start_method\n"
"\n"
"def foo():\n"
"    print('hello')\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    set_start_method('spawn')\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""

#: ../../library/multiprocessing.rst:3158
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""
"(A linha ``freeze_support()`` pode ser omitida se o programa for executado "
"normalmente em vez de congelado.)"

#: ../../library/multiprocessing.rst:3161
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""
"Isto permite que o novo interpretador Python criado importe o módulo com "
"segurança e depois execute a função ``foo()`` do módulo."

#: ../../library/multiprocessing.rst:3164
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""
"Restrições semelhantes aplicam-se se um conjunto ou gestor for criado no "
"módulo principal."

#: ../../library/multiprocessing.rst:3171
msgid "Examples"
msgstr "Exemplos"

#: ../../library/multiprocessing.rst:3173
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr "Demonstração de como criar e usar gestores e *proxies* personalizados:"

#: ../../library/multiprocessing.rst:3175
msgid ""
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo:\n"
"    def f(self):\n"
"        print('you called Foo.f()')\n"
"    def g(self):\n"
"        print('you called Foo.g()')\n"
"    def _h(self):\n"
"        print('you called Foo._h()')\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in range(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ['__next__']\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print('<%d>' % i, end=' ')\n"
"    print()\n"
"\n"
"    print('-' * 20)\n"
"\n"
"    op = manager.operator()\n"
"    print('op.add(23, 45) =', op.add(23, 45))\n"
"    print('op.pow(2, 94) =', op.pow(2, 94))\n"
"    print('op._exposed_ =', op._exposed_)\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../library/multiprocessing.rst:3179
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr "A usar :class:`~multiprocessing.pool.Pool`:"

#: ../../library/multiprocessing.rst:3181
msgid ""
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5 * random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x - 5.0)\n"
"\n"
"def pow3(x):\n"
"    return x ** 3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    PROCESSES = 4\n"
"    print('Creating pool with %d processes\\n' % PROCESSES)\n"
"\n"
"    with multiprocessing.Pool(PROCESSES) as pool:\n"
"        #\n"
"        # Tests\n"
"        #\n"
"\n"
"        TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"                [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"        results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"        imap_it = pool.imap(calculatestar, TASKS)\n"
"        imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"        print('Ordered results using pool.apply_async():')\n"
"        for r in results:\n"
"            print('\\t', r.get())\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.imap():')\n"
"        for x in imap_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Unordered results using pool.imap_unordered():')\n"
"        for x in imap_unordered_it:\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        print('Ordered results using pool.map() --- will block till "
"complete:')\n"
"        for x in pool.map(calculatestar, TASKS):\n"
"            print('\\t', x)\n"
"        print()\n"
"\n"
"        #\n"
"        # Test error handling\n"
"        #\n"
"\n"
"        print('Testing error handling:')\n"
"\n"
"        try:\n"
"            print(pool.apply(f, (5,)))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.apply()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(pool.map(f, list(range(10))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from pool.map()')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        try:\n"
"            print(list(pool.imap(f, list(range(10)))))\n"
"        except ZeroDivisionError:\n"
"            print('\\tGot ZeroDivisionError as expected from list(pool."
"imap())')\n"
"        else:\n"
"            raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        it = pool.imap(f, list(range(10)))\n"
"        for i in range(10):\n"
"            try:\n"
"                x = next(it)\n"
"            except ZeroDivisionError:\n"
"                if i == 5:\n"
"                    pass\n"
"            except StopIteration:\n"
"                break\n"
"            else:\n"
"                if i == 5:\n"
"                    raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"        assert i == 9\n"
"        print('\\tGot ZeroDivisionError as expected from IMapIterator."
"next()')\n"
"        print()\n"
"\n"
"        #\n"
"        # Testing timeouts\n"
"        #\n"
"\n"
"        print('Testing ApplyResult.get() with timeout:', end=' ')\n"
"        res = pool.apply_async(calculate, TASKS[0])\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"        print('Testing IMapIterator.next() with timeout:', end=' ')\n"
"        it = pool.imap(calculatestar, TASKS)\n"
"        while 1:\n"
"            sys.stdout.flush()\n"
"            try:\n"
"                sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"            except StopIteration:\n"
"                break\n"
"            except multiprocessing.TimeoutError:\n"
"                sys.stdout.write('.')\n"
"        print()\n"
"        print()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../library/multiprocessing.rst:3185
msgid ""
"An example showing how to use queues to feed tasks to a collection of worker "
"processes and collect the results:"
msgstr ""
"Um exemplo que mostra como usar filas para alimentar tarefas a um conjunto "
"de processos de trabalho e recolher os resultados:"

#: ../../library/multiprocessing.rst:3188
msgid ""
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print('Unordered results:')\n"
"    for i in range(len(TASKS1)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print('\\t', done_queue.get())\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""
