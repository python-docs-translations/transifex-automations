# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-01 15:56+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-eventloop.rst:8
msgid "Event Loop"
msgstr "Ciclo de Eventos"

#: ../../library/asyncio-eventloop.rst:10
msgid ""
"**Source code:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"
msgstr ""
"**Código-fonte:** :source:`Lib/asyncio/events.py`, :source:`Lib/asyncio/"
"base_events.py`"

#: ../../library/asyncio-eventloop.rst:16
msgid "Preface"
msgstr "Prefácio"

#: ../../library/asyncio-eventloop.rst:17
msgid ""
"The event loop is the core of every asyncio application. Event loops run "
"asynchronous tasks and callbacks, perform network IO operations, and run "
"subprocesses."
msgstr ""
"O ciclo de eventos é o núcleo de todas as aplicações asyncio. Os ciclos de "
"eventos executam tarefas e chamadas de retorno assíncronas, realizam "
"operações de E/S de rede e executam subprocessos."

#: ../../library/asyncio-eventloop.rst:21
msgid ""
"Application developers should typically use the high-level asyncio "
"functions, such as :func:`asyncio.run`, and should rarely need to reference "
"the loop object or call its methods.  This section is intended mostly for "
"authors of lower-level code, libraries, and frameworks, who need finer "
"control over the event loop behavior."
msgstr ""
"Os programadores de aplicações devem normalmente utilizar as funções de alto "
"nível do asyncio, como :func:`asyncio.run`, e raramente precisam de "
"referenciar o objeto do ciclo ou chamar os seus métodos. Esta secção destina-"
"se principalmente a autores de código de baixo nível, bibliotecas e "
"frameworks, que necessitam de um controlo mais fino sobre o comportamento do "
"ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:28
msgid "Obtaining the Event Loop"
msgstr "Obter o ciclo de eventos"

#: ../../library/asyncio-eventloop.rst:29
msgid ""
"The following low-level functions can be used to get, set, or create an "
"event loop:"
msgstr ""
"As seguintes funções de baixo nível podem ser utilizadas para obter, definir "
"ou criar um ciclo de eventos:"

#: ../../library/asyncio-eventloop.rst:34
msgid "Return the running event loop in the current OS thread."
msgstr ""
"Devolve o ciclo de eventos em execução na thread atual do sistema operativo."

#: ../../library/asyncio-eventloop.rst:36
msgid "Raise a :exc:`RuntimeError` if there is no running event loop."
msgstr ""
"Levanta um :exc:`RuntimeError` se não existir nenhum ciclo de eventos em "
"execução."

#: ../../library/asyncio-eventloop.rst:38
msgid "This function can only be called from a coroutine or a callback."
msgstr ""
"Esta função só pode ser chamada a partir de uma corrotina ou de uma chamada "
"de retorno."

#: ../../library/asyncio-eventloop.rst:44
msgid "Get the current event loop."
msgstr "Obtém o ciclo de eventos atual."

#: ../../library/asyncio-eventloop.rst:46
msgid ""
"When called from a coroutine or a callback (e.g. scheduled with call_soon or "
"similar API), this function will always return the running event loop."
msgstr ""
"Quando chamada a partir de uma corrotina ou de uma chamada de retorno (por "
"exemplo, agendada com call_soon ou API semelhante), esta função irá sempre "
"devolver o ciclo de eventos em execução."

#: ../../library/asyncio-eventloop.rst:50
msgid ""
"If there is no running event loop set, the function will return the result "
"of the ``get_event_loop_policy().get_event_loop()`` call."
msgstr ""
"Se não existir nenhum ciclo de eventos em execução definido, a função irá "
"devolver o resultado da chamada ``get_event_loop_policy().get_event_loop()``."

#: ../../library/asyncio-eventloop.rst:53
msgid ""
"Because this function has rather complex behavior (especially when custom "
"event loop policies are in use), using the :func:`get_running_loop` function "
"is preferred to :func:`get_event_loop` in coroutines and callbacks."
msgstr ""
"Como esta função tem um comportamento bastante complexo (especialmente "
"quando são utilizadas políticas personalizadas de ciclo de eventos), é "
"preferível utilizar a função :func:`get_running_loop` em vez de :func:"
"`get_event_loop` em corrotinas e chamadas de retorno."

#: ../../library/asyncio-eventloop.rst:58
msgid ""
"As noted above, consider using the higher-level :func:`asyncio.run` "
"function, instead of using these lower level functions to manually create "
"and close an event loop."
msgstr ""
"Como mencionado acima, considere utilizar a função de alto nível :func:"
"`asyncio.run`, em vez de utilizar estas funções de baixo nível para criar e "
"fechar manualmente um ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:62
msgid ""
"Deprecation warning is emitted if there is no current event loop. In some "
"future Python release this will become an error."
msgstr ""

#: ../../library/asyncio-eventloop.rst:68
msgid "Set *loop* as the current event loop for the current OS thread."
msgstr ""
"Define *loop* como o ciclo de eventos atual para a thread atual do sistema "
"operativo."

#: ../../library/asyncio-eventloop.rst:72
msgid "Create and return a new event loop object."
msgstr "Cria e devolve um novo objeto de ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:74
msgid ""
"Note that the behaviour of :func:`get_event_loop`, :func:`set_event_loop`, "
"and :func:`new_event_loop` functions can be altered by :ref:`setting a "
"custom event loop policy <asyncio-policies>`."
msgstr ""
"Note que o comportamento das funções :func:`get_event_loop`, :func:"
"`set_event_loop` e :func:`new_event_loop` pode ser alterado através da :ref:"
"`definição de uma política personalizada de ciclo de eventos <asyncio-"
"policies>`."

#: ../../library/asyncio-eventloop.rst:80
msgid "Contents"
msgstr "Conteúdos"

#: ../../library/asyncio-eventloop.rst:81
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentação contém as seguintes secções:"

#: ../../library/asyncio-eventloop.rst:83
msgid ""
"The `Event Loop Methods`_ section is the reference documentation of the "
"event loop APIs;"
msgstr ""
"A secção `Métodos do Ciclo de Eventos`_ é a documentação de referência das "
"APIs do ciclo de eventos;"

#: ../../library/asyncio-eventloop.rst:86
msgid ""
"The `Callback Handles`_ section documents the :class:`Handle` and :class:"
"`TimerHandle` instances which are returned from scheduling methods such as :"
"meth:`loop.call_soon` and :meth:`loop.call_later`;"
msgstr ""
"A secção `Manipuladores de Chamadas de Retorno`_ documenta as instâncias :"
"class:`Handle` e :class:`TimerHandle` que são devolvidas pelos métodos de "
"agendamento, como :meth:`loop.call_soon` e :meth:`loop.call_later`;"

#: ../../library/asyncio-eventloop.rst:90
msgid ""
"The `Server Objects`_ section documents types returned from event loop "
"methods like :meth:`loop.create_server`;"
msgstr ""
"A secção `Objetos de Servidor`_ documenta os tipos devolvidos pelos métodos "
"do ciclo de eventos, como :meth:`loop.create_server`;"

#: ../../library/asyncio-eventloop.rst:93
msgid ""
"The `Event Loop Implementations`_ section documents the :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop` classes;"
msgstr ""
"A secção `Implementações do Ciclo de Eventos`_ documenta as classes :class:"
"`SelectorEventLoop` e :class:`ProactorEventLoop`;"

#: ../../library/asyncio-eventloop.rst:96
msgid ""
"The `Examples`_ section showcases how to work with some event loop APIs."
msgstr ""
"A secção `Examples`_ mostra como trabalhar com algumas APIs do ciclo de "
"eventos."

#: ../../library/asyncio-eventloop.rst:103
msgid "Event Loop Methods"
msgstr "Métodos do ciclo de eventos"

#: ../../library/asyncio-eventloop.rst:105
msgid "Event loops have **low-level** APIs for the following:"
msgstr ""
"Os ciclos de eventos têm APIs de **baixo nível** para as seguintes operações:"

#: ../../library/asyncio-eventloop.rst:113
msgid "Running and stopping the loop"
msgstr "Execução e paragem do ciclo"

#: ../../library/asyncio-eventloop.rst:117
msgid "Run until the *future* (an instance of :class:`Future`) has completed."
msgstr ""
"Executa até que o *future* (uma instância de :class:`Future`) esteja "
"concluído."

#: ../../library/asyncio-eventloop.rst:120
msgid ""
"If the argument is a :ref:`coroutine object <coroutine>` it is implicitly "
"scheduled to run as a :class:`asyncio.Task`."
msgstr ""
"Se o argumento for um :ref:`objeto corrotina <coroutine>`, é implicitamente "
"agendado para ser executado como uma :class:`asyncio.Task`."

#: ../../library/asyncio-eventloop.rst:123
msgid "Return the Future's result or raise its exception."
msgstr "Devolve o resultado do Future ou levanta a sua exceção."

#: ../../library/asyncio-eventloop.rst:127
msgid "Run the event loop until :meth:`stop` is called."
msgstr "Executa o ciclo de eventos até que :meth:`stop` seja chamado."

#: ../../library/asyncio-eventloop.rst:129
msgid ""
"If :meth:`stop` is called before :meth:`run_forever` is called, the loop "
"will poll the I/O selector once with a timeout of zero, run all callbacks "
"scheduled in response to I/O events (and those that were already scheduled), "
"and then exit."
msgstr ""
"Se :meth:`stop` for chamado antes de :meth:`run_forever`, o ciclo irá "
"consultar o seletor de E/S uma vez com um timeout de zero, executar todas as "
"chamadas de retorno agendadas em resposta a eventos de E/S (e aquelas que já "
"estavam agendadas), e depois sair."

#: ../../library/asyncio-eventloop.rst:134
msgid ""
"If :meth:`stop` is called while :meth:`run_forever` is running, the loop "
"will run the current batch of callbacks and then exit. Note that new "
"callbacks scheduled by callbacks will not run in this case; instead, they "
"will run the next time :meth:`run_forever` or :meth:`run_until_complete` is "
"called."
msgstr ""
"Se :meth:`stop` for chamado enquanto :meth:`run_forever` estiver a ser "
"executado, o ciclo irá executar o lote atual de chamadas de retorno e depois "
"sair. Note que novas chamadas de retorno agendadas por chamadas de retorno "
"não serão executadas neste caso; em vez disso, serão executadas na próxima "
"vez que :meth:`run_forever` ou :meth:`run_until_complete` for chamado."

#: ../../library/asyncio-eventloop.rst:142
msgid "Stop the event loop."
msgstr "Para o ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:146
msgid "Return ``True`` if the event loop is currently running."
msgstr "Devolve ``True`` se o ciclo de eventos estiver atualmente em execução."

#: ../../library/asyncio-eventloop.rst:150
msgid "Return ``True`` if the event loop was closed."
msgstr "Devolve ``True`` se o ciclo de eventos tiver sido fechado."

#: ../../library/asyncio-eventloop.rst:154
msgid "Close the event loop."
msgstr "Fecha o ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:156
msgid ""
"The loop must not be running when this function is called. Any pending "
"callbacks will be discarded."
msgstr ""
"O ciclo não deve estar em execução quando esta função é chamada. Quaisquer "
"chamadas de retorno pendentes serão descartadas."

#: ../../library/asyncio-eventloop.rst:159
msgid ""
"This method clears all queues and shuts down the executor, but does not wait "
"for the executor to finish."
msgstr ""
"Este método limpa todas as filas e desliga o executor, mas não aguarda que o "
"executor termine."

#: ../../library/asyncio-eventloop.rst:162
msgid ""
"This method is idempotent and irreversible.  No other methods should be "
"called after the event loop is closed."
msgstr ""
"Este método é idempotente e irreversível. Nenhum outro método deve ser "
"chamado após o ciclo de eventos ser fechado."

#: ../../library/asyncio-eventloop.rst:168
msgid ""
"Schedule all currently open :term:`asynchronous generator` objects to close "
"with an :meth:`~agen.aclose` call.  After calling this method, the event "
"loop will issue a warning if a new asynchronous generator is iterated. This "
"should be used to reliably finalize all scheduled asynchronous generators."
msgstr ""
"Agenda todos os objetos :term:`gerador assíncrono` atualmente abertos para "
"fechar com uma chamada :meth:`~agen.aclose`. Após chamar este método, o "
"ciclo de eventos emitirá um aviso se um novo gerador assíncrono for iterado. "
"Isto deve ser utilizado para finalizar de forma fiável todos os geradores "
"assíncronos agendados."

#: ../../library/asyncio-eventloop.rst:174
msgid ""
"Note that there is no need to call this function when :func:`asyncio.run` is "
"used."
msgstr ""
"Note que não é necessário chamar esta função quando :func:`asyncio.run` é "
"utilizado."

#: ../../library/asyncio-eventloop.rst:177
#: ../../library/asyncio-eventloop.rst:1285
#: ../../library/asyncio-eventloop.rst:1707
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/asyncio-eventloop.rst:179
msgid ""
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"
msgstr ""
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.run_until_complete(loop.shutdown_asyncgens())\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:190
msgid ""
"Schedule the closure of the default executor and wait for it to join all of "
"the threads in the :class:`~concurrent.futures.ThreadPoolExecutor`. Once "
"this method has been called, using the default executor with :meth:`loop."
"run_in_executor` will raise a :exc:`RuntimeError`."
msgstr ""
"Agenda o encerramento do executor padrão e aguarda que este se junte a todas "
"as threads no :class:`~concurrent.futures.ThreadPoolExecutor`. Depois de "
"este método ser chamado, a utilização do executor padrão com :meth:`loop."
"run_in_executor` levantará um :exc:`RuntimeError`."

#: ../../library/asyncio-eventloop.rst:196
msgid ""
"The *timeout* parameter specifies the amount of time (in :class:`float` "
"seconds) the executor will be given to finish joining. With the default, "
"``None``, the executor is allowed an unlimited amount of time."
msgstr ""
"O parâmetro *timeout* especifica a quantidade de tempo (em segundos :class:"
"`float`) que o executor terá para terminar a junção. Com o valor "
"predefinido, ``None``, é permitido ao executor um tempo ilimitado."

#: ../../library/asyncio-eventloop.rst:201
msgid ""
"If the *timeout* is reached, a :exc:`RuntimeWarning` is emitted and the "
"default executor is terminated without waiting for its threads to finish "
"joining."
msgstr ""
"Se o *timeout* for atingido, é emitido um :exc:`RuntimeWarning` e o executor "
"padrão é terminado sem aguardar que as suas threads terminem a junção."

#: ../../library/asyncio-eventloop.rst:207
msgid ""
"Do not call this method when using :func:`asyncio.run`, as the latter "
"handles default executor shutdown automatically."
msgstr ""
"Não chame este método ao utilizar :func:`asyncio.run`, uma vez que este "
"último trata automaticamente do encerramento do executor padrão."

#: ../../library/asyncio-eventloop.rst:212
msgid "Added the *timeout* parameter."
msgstr "Adicionado o parâmetro *timeout*."

#: ../../library/asyncio-eventloop.rst:216
msgid "Scheduling callbacks"
msgstr "Agendamento de chamadas de retorno"

#: ../../library/asyncio-eventloop.rst:220
msgid ""
"Schedule the *callback* :term:`callback` to be called with *args* arguments "
"at the next iteration of the event loop."
msgstr ""
"Agenda a :term:`chamada de retorno` *callback* para ser chamada com os "
"argumentos *args* na próxima iteração do ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:223
msgid ""
"Return an instance of :class:`asyncio.Handle`, which can be used later to "
"cancel the callback."
msgstr ""
"Devolve uma instância de :class:`asyncio.Handle`, que pode ser utilizada "
"mais tarde para cancelar a chamada de retorno."

#: ../../library/asyncio-eventloop.rst:226
msgid ""
"Callbacks are called in the order in which they are registered. Each "
"callback will be called exactly once."
msgstr ""
"As chamadas de retorno são chamadas pela ordem em que são registadas. Cada "
"chamada de retorno será chamada exatamente uma vez."

#: ../../library/asyncio-eventloop.rst:229
msgid ""
"The optional keyword-only *context* argument specifies a custom :class:"
"`contextvars.Context` for the *callback* to run in. Callbacks use the "
"current context when no *context* is provided."
msgstr ""
"O argumento opcional apenas por palavra-chave *context* especifica um :class:"
"`contextvars.Context` personalizado para a *callback* ser executada. As "
"chamadas de retorno utilizam o contexto atual quando nenhum *context* é "
"fornecido."

#: ../../library/asyncio-eventloop.rst:233
msgid "Unlike :meth:`call_soon_threadsafe`, this method is not thread-safe."
msgstr ""
"Ao contrário de :meth:`call_soon_threadsafe`, este método não é seguro para "
"threads."

#: ../../library/asyncio-eventloop.rst:237
msgid ""
"A thread-safe variant of :meth:`call_soon`. When scheduling callbacks from "
"another thread, this function *must* be used, since :meth:`call_soon` is not "
"thread-safe."
msgstr ""
"Uma variante segura para threads de :meth:`call_soon`. Ao agendar chamadas "
"de retorno a partir de outra thread, esta função *deve* ser utilizada, uma "
"vez que :meth:`call_soon` não é seguro para threads."

#: ../../library/asyncio-eventloop.rst:241
msgid ""
"This function is safe to be called from a reentrant context or signal "
"handler, however, it is not safe or fruitful to use the returned handle in "
"such contexts."
msgstr ""
"Esta função é segura para ser chamada a partir de um contexto reentrante ou "
"de um manipulador de sinais, no entanto, não é seguro nem produtivo utilizar "
"o manipulador devolvido nestes contextos."

#: ../../library/asyncio-eventloop.rst:244
msgid ""
"Raises :exc:`RuntimeError` if called on a loop that's been closed. This can "
"happen on a secondary thread when the main application is shutting down."
msgstr ""
"Levanta :exc:`RuntimeError` se chamado num ciclo que foi fechado. Isto pode "
"acontecer numa thread secundária quando a aplicação principal está a "
"encerrar."

#: ../../library/asyncio-eventloop.rst:248
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Consulte a secção :ref:`concorrência e multithreading <asyncio-"
"multithreading>` da documentação."

#: ../../library/asyncio-eventloop.rst:251
#: ../../library/asyncio-eventloop.rst:301
#: ../../library/asyncio-eventloop.rst:321
msgid ""
"The *context* keyword-only parameter was added. See :pep:`567` for more "
"details."
msgstr ""
"O parâmetro apenas por palavra-chave *context* foi adicionado. Consulte :pep:"
"`567` para mais detalhes."

#: ../../library/asyncio-eventloop.rst:259
msgid ""
"Most :mod:`asyncio` scheduling functions don't allow passing keyword "
"arguments.  To do that, use :func:`functools.partial`::"
msgstr ""
"A maioria das funções de agendamento :mod:`asyncio` não permite passar "
"argumentos de palavra-chave. Para o fazer, utilize :func:`functools."
"partial`::"

#: ../../library/asyncio-eventloop.rst:262
msgid ""
"# will schedule \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"
msgstr ""
"# irá agendar \"print(\"Hello\", flush=True)\"\n"
"loop.call_soon(\n"
"    functools.partial(print, \"Hello\", flush=True))"

#: ../../library/asyncio-eventloop.rst:266
msgid ""
"Using partial objects is usually more convenient than using lambdas, as "
"asyncio can render partial objects better in debug and error messages."
msgstr ""
"A utilização de objetos parciais é geralmente mais conveniente do que a "
"utilização de lambdas, uma vez que o asyncio pode apresentar melhor os "
"objetos parciais em mensagens de depuração e de erro."

#: ../../library/asyncio-eventloop.rst:274
msgid "Scheduling delayed callbacks"
msgstr "Agendamento de chamadas de retorno adiado"

#: ../../library/asyncio-eventloop.rst:276
msgid ""
"Event loop provides mechanisms to schedule callback functions to be called "
"at some point in the future.  Event loop uses monotonic clocks to track time."
msgstr ""
"O ciclo de eventos fornece mecanismos para agendar funções de chamada de "
"retorno para serem chamadas em algum momento no futuro. O ciclo de eventos "
"utiliza relógios monótonos para acompanhar o tempo."

#: ../../library/asyncio-eventloop.rst:283
msgid ""
"Schedule *callback* to be called after the given *delay* number of seconds "
"(can be either an int or a float)."
msgstr ""
"Agenda *callback* para ser chamada após o número de segundos especificado em "
"*delay* (pode ser um int ou um float)."

#: ../../library/asyncio-eventloop.rst:286
#: ../../library/asyncio-eventloop.rst:318
msgid ""
"An instance of :class:`asyncio.TimerHandle` is returned which can be used to "
"cancel the callback."
msgstr ""
"É devolvida uma instância de :class:`asyncio.TimerHandle`, que pode ser "
"utilizada para cancelar a chamada de retorno."

#: ../../library/asyncio-eventloop.rst:289
msgid ""
"*callback* will be called exactly once.  If two callbacks are scheduled for "
"exactly the same time, the order in which they are called is undefined."
msgstr ""
"*callback* será chamada exatamente uma vez. Se duas chamadas de retorno "
"forem agendadas para exatamente o mesmo momento, a ordem pela qual são "
"chamadas é indefinida."

#: ../../library/asyncio-eventloop.rst:293
msgid ""
"The optional positional *args* will be passed to the callback when it is "
"called. If you want the callback to be called with keyword arguments use :"
"func:`functools.partial`."
msgstr ""
"Os argumentos posicionais opcionais *args* serão passados para a chamada de "
"retorno quando esta for chamada. Se pretender que a chamada de retorno seja "
"chamada com argumentos de palavra-chave, utilize :func:`functools.partial`."

#: ../../library/asyncio-eventloop.rst:297
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *callback* to run in. The current "
"context is used when no *context* is provided."
msgstr ""
"Um argumento opcional apenas por palavra-chave *context* permite especificar "
"um :class:`contextvars.Context` personalizado para a *callback* ser "
"executada. O contexto atual é utilizado quando nenhum *context* é fornecido."

#: ../../library/asyncio-eventloop.rst:305
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"*delay* could not exceed one day. This has been fixed in Python 3.8."
msgstr ""
"Nas versões do Python 3.7 e anteriores, com a implementação padrão do ciclo "
"de eventos, o *delay* não podia exceder um dia. Isto foi corrigido no Python "
"3.8."

#: ../../library/asyncio-eventloop.rst:312
msgid ""
"Schedule *callback* to be called at the given absolute timestamp *when* (an "
"int or a float), using the same time reference as :meth:`loop.time`."
msgstr ""
"Agenda *callback* para ser chamada no carimbo de tempo absoluto *when* (um "
"int ou um float), utilizando a mesma referência de tempo que :meth:`loop."
"time`."

#: ../../library/asyncio-eventloop.rst:316
msgid "This method's behavior is the same as :meth:`call_later`."
msgstr "O comportamento deste método é o mesmo que :meth:`call_later`."

#: ../../library/asyncio-eventloop.rst:325
msgid ""
"In Python 3.7 and earlier with the default event loop implementation, the "
"difference between *when* and the current time could not exceed one day.  "
"This has been fixed in Python 3.8."
msgstr ""
"Nas versões do Python 3.7 e anteriores, com a implementação padrão do ciclo "
"de eventos, a diferença entre *when* e a hora atual não podia exceder um "
"dia. Isto foi corrigido no Python 3.8."

#: ../../library/asyncio-eventloop.rst:332
msgid ""
"Return the current time, as a :class:`float` value, according to the event "
"loop's internal monotonic clock."
msgstr ""
"Devolve a hora atual, como um valor :class:`float`, de acordo com o relógio "
"monótono interno do ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:336
msgid ""
"In Python 3.7 and earlier timeouts (relative *delay* or absolute *when*) "
"should not exceed one day.  This has been fixed in Python 3.8."
msgstr ""
"Nas versões do Python 3.7 e anteriores, os timeouts (atraso relativo *delay* "
"ou absoluto *when*) não deviam exceder um dia. Isto foi corrigido no Python "
"3.8."

#: ../../library/asyncio-eventloop.rst:342
msgid "The :func:`asyncio.sleep` function."
msgstr "A função :func:`asyncio.sleep`."

#: ../../library/asyncio-eventloop.rst:346
msgid "Creating Futures and Tasks"
msgstr "Criação de Futures e Tarefas"

#: ../../library/asyncio-eventloop.rst:350
msgid "Create an :class:`asyncio.Future` object attached to the event loop."
msgstr "Cria um objeto :class:`asyncio.Future` associado ao ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:352
msgid ""
"This is the preferred way to create Futures in asyncio. This lets third-"
"party event loops provide alternative implementations of the Future object "
"(with better performance or instrumentation)."
msgstr ""
"Esta é a forma preferida de criar Futures no asyncio. Isto permite que "
"ciclos de eventos de terceiros forneçam implementações alternativas do "
"objeto Future (com melhor desempenho ou instrumentação)."

#: ../../library/asyncio-eventloop.rst:360
msgid ""
"Schedule the execution of :ref:`coroutine <coroutine>` *coro*. Return a :"
"class:`Task` object."
msgstr ""
"Agenda a execução da :ref:`corrotina <coroutine>` *coro*. Devolve um objeto :"
"class:`Task`."

#: ../../library/asyncio-eventloop.rst:363
msgid ""
"Third-party event loops can use their own subclass of :class:`Task` for "
"interoperability. In this case, the result type is a subclass of :class:"
"`Task`."
msgstr ""
"Ciclos de eventos de terceiros podem utilizar a sua própria subclasse de :"
"class:`Task` para interoperabilidade. Neste caso, o tipo de resultado é uma "
"subclasse de :class:`Task`."

#: ../../library/asyncio-eventloop.rst:367
msgid ""
"If the *name* argument is provided and not ``None``, it is set as the name "
"of the task using :meth:`Task.set_name`."
msgstr ""
"Se o argumento *name* for fornecido e não for ``None``, é definido como o "
"nome da tarefa utilizando :meth:`Task.set_name`."

#: ../../library/asyncio-eventloop.rst:370
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Um argumento opcional apenas por palavra-chave *context* permite especificar "
"um :class:`contextvars.Context` personalizado para a *coro* ser executada. "
"Uma cópia do contexto atual é criada quando nenhum *context* é fornecido."

#: ../../library/asyncio-eventloop.rst:374
msgid "Added the *name* parameter."
msgstr "Adicionado o parâmetro *name*."

#: ../../library/asyncio-eventloop.rst:377
msgid "Added the *context* parameter."
msgstr "Adicionado o parâmetro *context*."

#: ../../library/asyncio-eventloop.rst:382
msgid "Set a task factory that will be used by :meth:`loop.create_task`."
msgstr ""
"Define uma fábrica de tarefas que será utilizada por :meth:`loop."
"create_task`."

#: ../../library/asyncio-eventloop.rst:385
msgid ""
"If *factory* is ``None`` the default task factory will be set. Otherwise, "
"*factory* must be a *callable* with the signature matching ``(loop, coro, "
"context=None)``, where *loop* is a reference to the active event loop, and "
"*coro* is a coroutine object.  The callable must return a :class:`asyncio."
"Future`-compatible object."
msgstr ""

#: ../../library/asyncio-eventloop.rst:393
msgid "Return a task factory or ``None`` if the default one is in use."
msgstr ""
"Devolve uma fábrica de tarefas ou ``None`` se a predefinida estiver em uso."

#: ../../library/asyncio-eventloop.rst:397
msgid "Opening network connections"
msgstr "Abertura de ligações de rede"

#: ../../library/asyncio-eventloop.rst:409
msgid ""
"Open a streaming transport connection to a given address specified by *host* "
"and *port*."
msgstr ""
"Abre uma ligação de transporte de fluxo para um endereço especificado por "
"*host* e *port*."

#: ../../library/asyncio-eventloop.rst:412
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET` or :py:const:"
"`~socket.AF_INET6` depending on *host* (or the *family* argument, if "
"provided)."
msgstr ""
"A família de sockets pode ser :py:const:`~socket.AF_INET` ou :py:const:"
"`~socket.AF_INET6`, dependendo de *host* (ou do argumento *family*, se "
"fornecido)."

#: ../../library/asyncio-eventloop.rst:416
msgid "The socket type will be :py:const:`~socket.SOCK_STREAM`."
msgstr "O tipo de socket será :py:const:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:418
#: ../../library/asyncio-eventloop.rst:1195
#: ../../library/asyncio-eventloop.rst:1212
msgid ""
"*protocol_factory* must be a callable returning an :ref:`asyncio protocol "
"<asyncio-protocol>` implementation."
msgstr ""
"*protocol_factory* deve ser um callable que devolva uma implementação de :"
"ref:`protocolo asyncio <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:421
msgid ""
"This method will try to establish the connection in the background. When "
"successful, it returns a ``(transport, protocol)`` pair."
msgstr ""
"Este método tentará estabelecer a ligação em segundo plano. Quando bem-"
"sucedido, devolve um par ``(transport, protocol)``."

#: ../../library/asyncio-eventloop.rst:424
msgid "The chronological synopsis of the underlying operation is as follows:"
msgstr "O resumo cronológico da operação subjacente é o seguinte:"

#: ../../library/asyncio-eventloop.rst:426
msgid ""
"The connection is established and a :ref:`transport <asyncio-transport>` is "
"created for it."
msgstr ""
"A ligação é estabelecida e um :ref:`transporte <asyncio-transport>` é criado "
"para a mesma."

#: ../../library/asyncio-eventloop.rst:429
msgid ""
"*protocol_factory* is called without arguments and is expected to return a :"
"ref:`protocol <asyncio-protocol>` instance."
msgstr ""
"*protocol_factory* é chamado sem argumentos e espera-se que devolva uma "
"instância de :ref:`protocolo <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:432
msgid ""
"The protocol instance is coupled with the transport by calling its :meth:"
"`~BaseProtocol.connection_made` method."
msgstr ""
"A instância do protocolo é acoplada ao transporte chamando o seu método :"
"meth:`~BaseProtocol.connection_made`."

#: ../../library/asyncio-eventloop.rst:435
msgid "A ``(transport, protocol)`` tuple is returned on success."
msgstr "Um tuplo ``(transport, protocol)`` é devolvido em caso de sucesso."

#: ../../library/asyncio-eventloop.rst:437
msgid ""
"The created transport is an implementation-dependent bidirectional stream."
msgstr ""
"O transporte criado é um fluxo bidirecional dependente da implementação."

#: ../../library/asyncio-eventloop.rst:440
#: ../../library/asyncio-eventloop.rst:573
msgid "Other arguments:"
msgstr "Outros argumentos:"

#: ../../library/asyncio-eventloop.rst:442
msgid ""
"*ssl*: if given and not false, a SSL/TLS transport is created (by default a "
"plain TCP transport is created).  If *ssl* is a :class:`ssl.SSLContext` "
"object, this context is used to create the transport; if *ssl* is :const:"
"`True`, a default context returned from :func:`ssl.create_default_context` "
"is used."
msgstr ""
"*ssl*: se fornecido e não falso, é criado um transporte SSL/TLS (por "
"predefinição, é criado um transporte TCP simples). Se *ssl* for um objeto :"
"class:`ssl.SSLContext`, este contexto é utilizado para criar o transporte; "
"se *ssl* for :const:`True`, é utilizado um contexto predefinido devolvido "
"por :func:`ssl.create_default_context`."

#: ../../library/asyncio-eventloop.rst:448
msgid ":ref:`SSL/TLS security considerations <ssl-security>`"
msgstr ":ref:`Considerações de segurança SSL/TLS <ssl-security>`"

#: ../../library/asyncio-eventloop.rst:450
msgid ""
"*server_hostname* sets or overrides the hostname that the target server's "
"certificate will be matched against.  Should only be passed if *ssl* is not "
"``None``.  By default the value of the *host* argument is used.  If *host* "
"is empty, there is no default and you must pass a value for "
"*server_hostname*.  If *server_hostname* is an empty string, hostname "
"matching is disabled (which is a serious security risk, allowing for "
"potential man-in-the-middle attacks)."
msgstr ""
"*server_hostname* define ou substitui o nome do host contra o qual o "
"certificado do servidor de destino será comparado. Deve ser passado apenas "
"se *ssl* não for ``None``. Por predefinição, é utilizado o valor do "
"argumento *host*. Se *host* estiver vazio, não existe um valor predefinido e "
"deve passar um valor para *server_hostname*. Se *server_hostname* for uma "
"string vazia, a correspondência do nome do host é desativada (o que "
"representa um sério risco de segurança, permitindo potenciais ataques man-in-"
"the-middle)."

#: ../../library/asyncio-eventloop.rst:458
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to getaddrinfo() for *host* resolution. If given, "
"these should all be integers from the corresponding :mod:`socket` module "
"constants."
msgstr ""
"*family*, *proto*, *flags* são a família de endereços, protocolo e flags "
"opcionais a serem passados para getaddrinfo() para resolução de *host*. Se "
"fornecidos, estes devem ser todos inteiros das constantes do módulo :mod:"
"`socket` correspondentes."

#: ../../library/asyncio-eventloop.rst:463
msgid ""
"*happy_eyeballs_delay*, if given, enables Happy Eyeballs for this "
"connection. It should be a floating-point number representing the amount of "
"time in seconds to wait for a connection attempt to complete, before "
"starting the next attempt in parallel. This is the \"Connection Attempt "
"Delay\" as defined in :rfc:`8305`. A sensible default value recommended by "
"the RFC is ``0.25`` (250 milliseconds)."
msgstr ""
"*happy_eyeballs_delay*, se fornecido, ativa o Happy Eyeballs para esta "
"ligação. Deve ser um número de vírgula flutuante que representa a quantidade "
"de tempo em segundos para aguardar que uma tentativa de ligação seja "
"concluída, antes de iniciar a próxima tentativa em paralelo. Este é o "
"\"Atraso de Tentativa de Ligação\" conforme definido na :rfc:`8305`. Um "
"valor predefinido recomendado pela RFC é ``0.25`` (250 milissegundos)."

#: ../../library/asyncio-eventloop.rst:471
msgid ""
"*interleave* controls address reordering when a host name resolves to "
"multiple IP addresses. If ``0`` or unspecified, no reordering is done, and "
"addresses are tried in the order returned by :meth:`getaddrinfo`. If a "
"positive integer is specified, the addresses are interleaved by address "
"family, and the given integer is interpreted as \"First Address Family "
"Count\" as defined in :rfc:`8305`. The default is ``0`` if "
"*happy_eyeballs_delay* is not specified, and ``1`` if it is."
msgstr ""
"*interleave* controla a reordenação de endereços quando um nome de host "
"resolve para vários endereços IP. Se for ``0`` ou não especificado, não é "
"feita nenhuma reordenação e os endereços são tentados pela ordem devolvida "
"por :meth:`getaddrinfo`. Se for especificado um inteiro positivo, os "
"endereços são intercalados por família de endereços, e o inteiro fornecido é "
"interpretado como \"Contagem da Primeira Família de Endereços\" conforme "
"definido na :rfc:`8305`. O valor predefinido é ``0`` se "
"*happy_eyeballs_delay* não for especificado, e ``1`` se for."

#: ../../library/asyncio-eventloop.rst:480
msgid ""
"*sock*, if given, should be an existing, already connected :class:`socket."
"socket` object to be used by the transport. If *sock* is given, none of "
"*host*, *port*, *family*, *proto*, *flags*, *happy_eyeballs_delay*, "
"*interleave* and *local_addr* should be specified."
msgstr ""
"*sock*, se fornecido, deve ser um objeto :class:`socket.socket` existente e "
"já ligado a ser utilizado pelo transporte. Se *sock* for fornecido, nenhum "
"dos seguintes deve ser especificado: *host*, *port*, *family*, *proto*, "
"*flags*, *happy_eyeballs_delay*, *interleave* e *local_addr*."

#: ../../library/asyncio-eventloop.rst:488
#: ../../library/asyncio-eventloop.rst:604
#: ../../library/asyncio-eventloop.rst:836
msgid ""
"The *sock* argument transfers ownership of the socket to the transport "
"created. To close the socket, call the transport's :meth:`~asyncio."
"BaseTransport.close` method."
msgstr ""
"O argumento *sock* transfere a propriedade do socket para o transporte "
"criado. Para fechar o socket, chame o método :meth:`~asyncio.BaseTransport."
"close` do transporte."

#: ../../library/asyncio-eventloop.rst:492
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using "
"``getaddrinfo()``, similarly to *host* and *port*."
msgstr ""
"*local_addr*, se fornecido, é um tuplo ``(local_host, local_port)`` "
"utilizado para ligar o socket localmente. *local_host* e *local_port* são "
"pesquisados utilizando ``getaddrinfo()``, de forma semelhante a *host* e "
"*port*."

#: ../../library/asyncio-eventloop.rst:496
#: ../../library/asyncio-eventloop.rst:932
msgid ""
"*ssl_handshake_timeout* is (for a TLS connection) the time in seconds to "
"wait for the TLS handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* é (para uma ligação TLS) o tempo em segundos para "
"aguardar que o TLS handshake seja concluído antes de abortar a ligação. "
"``60.0`` segundos se for ``None`` (predefinição)."

#: ../../library/asyncio-eventloop.rst:500
#: ../../library/asyncio-eventloop.rst:751
#: ../../library/asyncio-eventloop.rst:847
#: ../../library/asyncio-eventloop.rst:936
msgid ""
"*ssl_shutdown_timeout* is the time in seconds to wait for the SSL shutdown "
"to complete before aborting the connection. ``30.0`` seconds if ``None`` "
"(default)."
msgstr ""
"*ssl_shutdown_timeout* é o tempo em segundos para aguardar que o "
"encerramento SSL seja concluído antes de abortar a ligação. ``30.0`` "
"segundos se for ``None`` (predefinição)."

#: ../../library/asyncio-eventloop.rst:504
msgid ""
"*all_errors* determines what exceptions are raised when a connection cannot "
"be created. By default, only a single ``Exception`` is raised: the first "
"exception if there is only one or all errors have same message, or a single "
"``OSError`` with the error messages combined. When ``all_errors`` is "
"``True``, an ``ExceptionGroup`` will be raised containing all exceptions "
"(even if there is only one)."
msgstr ""
"*all_errors* determina quais exceções são levantadas quando uma ligação não "
"pode ser criada. Por predefinição, apenas uma única ``Exception`` é "
"levantada: a primeira exceção se houver apenas uma ou se todas as mensagens "
"de erro forem iguais, ou um único ``OSError`` com as mensagens de erro "
"combinadas. Quando ``all_errors`` for ``True``, um ``ExceptionGroup`` será "
"levantado contendo todas as exceções (mesmo que haja apenas uma)."

#: ../../library/asyncio-eventloop.rst:514
#: ../../library/asyncio-eventloop.rst:763
msgid "Added support for SSL/TLS in :class:`ProactorEventLoop`."
msgstr "Adicionado suporte para SSL/TLS em :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:518
msgid ""
"The socket option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set "
"by default for all TCP connections."
msgstr ""
"A opção de socket :ref:`socket.TCP_NODELAY <socket-unix-constants>` é "
"definida por predefinição para todas as ligações TCP."

#: ../../library/asyncio-eventloop.rst:523
#: ../../library/asyncio-eventloop.rst:857
msgid "Added the *ssl_handshake_timeout* parameter."
msgstr "Adicionado o parâmetro *ssl_handshake_timeout*."

#: ../../library/asyncio-eventloop.rst:527
msgid "Added the *happy_eyeballs_delay* and *interleave* parameters."
msgstr "Adicionados os parâmetros *happy_eyeballs_delay* e *interleave*."

#: ../../library/asyncio-eventloop.rst:529
msgid ""
"Happy Eyeballs Algorithm: Success with Dual-Stack Hosts. When a server's "
"IPv4 path and protocol are working, but the server's IPv6 path and protocol "
"are not working, a dual-stack client application experiences significant "
"connection delay compared to an IPv4-only client.  This is undesirable "
"because it causes the dual-stack client to have a worse user experience.  "
"This document specifies requirements for algorithms that reduce this user-"
"visible delay and provides an algorithm."
msgstr ""
"Algoritmo Happy Eyeballs: Sucesso com Hosts Dual-Stack. Quando o caminho e "
"protocolo IPv4 de um servidor estão a funcionar, mas o caminho e protocolo "
"IPv6 do servidor não estão a funcionar, uma aplicação cliente dual-stack "
"experimenta um atraso significativo na ligação em comparação com um cliente "
"apenas IPv4. Isto é indesejável porque faz com que o cliente dual-stack "
"tenha uma pior experiência de utilizador. Este documento especifica os "
"requisitos para algoritmos que reduzem este atraso visível pelo utilizador e "
"fornece um algoritmo."

#: ../../library/asyncio-eventloop.rst:538
msgid "For more information: https://datatracker.ietf.org/doc/html/rfc6555"
msgstr "Para mais informações: https://datatracker.ietf.org/doc/html/rfc6555"

#: ../../library/asyncio-eventloop.rst:542
#: ../../library/asyncio-eventloop.rst:668
#: ../../library/asyncio-eventloop.rst:777
#: ../../library/asyncio-eventloop.rst:813
#: ../../library/asyncio-eventloop.rst:861
#: ../../library/asyncio-eventloop.rst:944
msgid "Added the *ssl_shutdown_timeout* parameter."
msgstr "Adicionado o parâmetro *ssl_shutdown_timeout*."

#: ../../library/asyncio-eventloop.rst:544
msgid "*all_errors* was added."
msgstr "Foi adicionado *all_errors*."

#: ../../library/asyncio-eventloop.rst:549
msgid ""
"The :func:`open_connection` function is a high-level alternative API.  It "
"returns a pair of (:class:`StreamReader`, :class:`StreamWriter`) that can be "
"used directly in async/await code."
msgstr ""
"A função :func:`open_connection` é uma API alternativa de alto nível. "
"Devolve um par (:class:`StreamReader`, :class:`StreamWriter`) que pode ser "
"utilizado diretamente em código async/await."

#: ../../library/asyncio-eventloop.rst:560
msgid "Create a datagram connection."
msgstr "Cria uma ligação de datagrama."

#: ../../library/asyncio-eventloop.rst:562
msgid ""
"The socket family can be either :py:const:`~socket.AF_INET`, :py:const:"
"`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`, depending on *host* (or "
"the *family* argument, if provided)."
msgstr ""
"A família de sockets pode ser :py:const:`~socket.AF_INET`, :py:const:"
"`~socket.AF_INET6`, ou :py:const:`~socket.AF_UNIX`, dependendo de *host* (ou "
"do argumento *family*, se fornecido)."

#: ../../library/asyncio-eventloop.rst:566
msgid "The socket type will be :py:const:`~socket.SOCK_DGRAM`."
msgstr "O tipo de socket será :py:const:`~socket.SOCK_DGRAM`."

#: ../../library/asyncio-eventloop.rst:568
#: ../../library/asyncio-eventloop.rst:694
#: ../../library/asyncio-eventloop.rst:828
msgid ""
"*protocol_factory* must be a callable returning a :ref:`protocol <asyncio-"
"protocol>` implementation."
msgstr ""
"*protocol_factory* deve ser um callable que devolva uma implementação de :"
"ref:`protocolo <asyncio-protocol>`."

#: ../../library/asyncio-eventloop.rst:571
#: ../../library/asyncio-eventloop.rst:650
msgid "A tuple of ``(transport, protocol)`` is returned on success."
msgstr "Um tuplo ``(transport, protocol)`` é devolvido em caso de sucesso."

#: ../../library/asyncio-eventloop.rst:575
msgid ""
"*local_addr*, if given, is a ``(local_host, local_port)`` tuple used to bind "
"the socket locally.  The *local_host* and *local_port* are looked up using :"
"meth:`getaddrinfo`."
msgstr ""
"*local_addr*, se fornecido, é um tuplo ``(local_host, local_port)`` "
"utilizado para ligar o socket localmente. *local_host* e *local_port* são "
"pesquisados utilizando :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:579
msgid ""
"*remote_addr*, if given, is a ``(remote_host, remote_port)`` tuple used to "
"connect the socket to a remote address.  The *remote_host* and *remote_port* "
"are looked up using :meth:`getaddrinfo`."
msgstr ""
"*remote_addr*, se fornecido, é um tuplo ``(remote_host, remote_port)`` "
"utilizado para ligar o socket a um endereço remoto. *remote_host* e "
"*remote_port* são pesquisados utilizando :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:583
msgid ""
"*family*, *proto*, *flags* are the optional address family, protocol and "
"flags to be passed through to :meth:`getaddrinfo` for *host* resolution. If "
"given, these should all be integers from the corresponding :mod:`socket` "
"module constants."
msgstr ""
"*family*, *proto*, *flags* são a família de endereços, protocolo e flags "
"opcionais a serem passados para :meth:`getaddrinfo` para resolução de "
"*host*. Se fornecidos, estes devem ser todos inteiros das constantes do "
"módulo :mod:`socket` correspondentes."

#: ../../library/asyncio-eventloop.rst:588
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows and some "
"Unixes. If the :ref:`socket.SO_REUSEPORT <socket-unix-constants>` constant "
"is not defined then this capability is unsupported."
msgstr ""
"*reuse_port* indica ao kernel para permitir que este endpoint seja ligado à "
"mesma porta que outros endpoints existentes, desde que todos definam esta "
"flag ao serem criados. Esta opção não é suportada no Windows e em alguns "
"Unix. Se a constante :ref:`socket.SO_REUSEPORT <socket-unix-constants>` não "
"estiver definida, esta capacidade não é suportada."

#: ../../library/asyncio-eventloop.rst:594
msgid ""
"*allow_broadcast* tells the kernel to allow this endpoint to send messages "
"to the broadcast address."
msgstr ""
"*allow_broadcast* indica ao kernel para permitir que este endpoint envie "
"mensagens para o endereço de broadcast."

#: ../../library/asyncio-eventloop.rst:597
msgid ""
"*sock* can optionally be specified in order to use a preexisting, already "
"connected, :class:`socket.socket` object to be used by the transport. If "
"specified, *local_addr* and *remote_addr* should be omitted (must be :const:"
"`None`)."
msgstr ""
"*sock* pode ser opcionalmente especificado para utilizar um objeto :class:"
"`socket.socket` pré-existente e já ligado a ser utilizado pelo transporte. "
"Se especificado, *local_addr* e *remote_addr* devem ser omitidos (devem ser :"
"const:`None`)."

#: ../../library/asyncio-eventloop.rst:608
msgid ""
"See :ref:`UDP echo client protocol <asyncio-udp-echo-client-protocol>` and :"
"ref:`UDP echo server protocol <asyncio-udp-echo-server-protocol>` examples."
msgstr ""
"Consulte os exemplos :ref:`protocolo de cliente eco UDP <asyncio-udp-echo-"
"client-protocol>` e :ref:`protocolo de servidor eco UDP <asyncio-udp-echo-"
"server-protocol>`."

#: ../../library/asyncio-eventloop.rst:611
msgid ""
"The *family*, *proto*, *flags*, *reuse_address*, *reuse_port*, "
"*allow_broadcast*, and *sock* parameters were added."
msgstr ""
"Foram adicionados os parâmetros *family*, *proto*, *flags*, *reuse_address*, "
"*reuse_port*, *allow_broadcast* e *sock*."

#: ../../library/asyncio-eventloop.rst:615
msgid "Added support for Windows."
msgstr "Adicionado suporte para Windows."

#: ../../library/asyncio-eventloop.rst:618
msgid ""
"The *reuse_address* parameter is no longer supported, as using :ref:`socket."
"SO_REUSEADDR <socket-unix-constants>` poses a significant security concern "
"for UDP. Explicitly passing ``reuse_address=True`` will raise an exception."
msgstr ""
"O parâmetro *reuse_address* já não é suportado, uma vez que a utilização de :"
"ref:`socket.SO_REUSEADDR <socket-unix-constants>` representa uma preocupação "
"significativa de segurança para UDP. Passar explicitamente "
"``reuse_address=True`` levantará uma exceção."

#: ../../library/asyncio-eventloop.rst:624
msgid ""
"When multiple processes with differing UIDs assign sockets to an identical "
"UDP socket address with ``SO_REUSEADDR``, incoming packets can become "
"randomly distributed among the sockets."
msgstr ""
"Quando vários processos com UIDs diferentes atribuem sockets ao mesmo "
"endereço de socket UDP com ``SO_REUSEADDR``, os pacotes recebidos podem ser "
"distribuídos aleatoriamente entre os sockets."

#: ../../library/asyncio-eventloop.rst:628
msgid ""
"For supported platforms, *reuse_port* can be used as a replacement for "
"similar functionality. With *reuse_port*, :ref:`socket.SO_REUSEPORT <socket-"
"unix-constants>` is used instead, which specifically prevents processes with "
"differing UIDs from assigning sockets to the same socket address."
msgstr ""
"Para plataformas suportadas, *reuse_port* pode ser utilizado como substituto "
"para funcionalidade semelhante. Com *reuse_port*, é utilizado :ref:`socket."
"SO_REUSEPORT <socket-unix-constants>`, que impede especificamente que "
"processos com UIDs diferentes atribuam sockets ao mesmo endereço de socket."

#: ../../library/asyncio-eventloop.rst:635
msgid ""
"The *reuse_address* parameter, disabled since Python 3.8.1, 3.7.6 and "
"3.6.10, has been entirely removed."
msgstr ""
"O parâmetro *reuse_address*, desativado desde o Python 3.8.1, 3.7.6 e "
"3.6.10, foi completamente removido."

#: ../../library/asyncio-eventloop.rst:645
msgid "Create a Unix connection."
msgstr "Cria uma ligação Unix."

#: ../../library/asyncio-eventloop.rst:647
msgid ""
"The socket family will be :py:const:`~socket.AF_UNIX`; socket type will be :"
"py:const:`~socket.SOCK_STREAM`."
msgstr ""
"A família de sockets será :py:const:`~socket.AF_UNIX`; o tipo de socket "
"será :py:const:`~socket.SOCK_STREAM`."

#: ../../library/asyncio-eventloop.rst:652
msgid ""
"*path* is the name of a Unix domain socket and is required, unless a *sock* "
"parameter is specified.  Abstract Unix sockets, :class:`str`, :class:"
"`bytes`, and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* é o nome de um socket de domínio Unix e é obrigatório, a menos que "
"seja especificado um parâmetro *sock*. São suportados sockets Unix "
"abstratos, :class:`str`, :class:`bytes` e caminhos :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:657
msgid ""
"See the documentation of the :meth:`loop.create_connection` method for "
"information about arguments to this method."
msgstr ""
"Consulte a documentação do método :meth:`loop.create_connection` para obter "
"informações sobre os argumentos deste método."

#: ../../library/asyncio-eventloop.rst:660
#: ../../library/asyncio-eventloop.rst:804
#: ../../library/asyncio-eventloop.rst:1265
#: ../../library/asyncio-eventloop.rst:1778
#: ../../library/asyncio-eventloop.rst:1785
msgid "Availability"
msgstr "Disponibilidade"

#: ../../library/asyncio-eventloop.rst:662
msgid ""
"Added the *ssl_handshake_timeout* parameter. The *path* parameter can now be "
"a :term:`path-like object`."
msgstr ""
"Adicionado o parâmetro *ssl_handshake_timeout*. O parâmetro *path* agora "
"pode ser um :term:`objeto tipo caminho`."

#: ../../library/asyncio-eventloop.rst:672
msgid "Creating network servers"
msgstr "Criação de servidores de rede"

#: ../../library/asyncio-eventloop.rst:687
msgid ""
"Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening on "
"*port* of the *host* address."
msgstr ""
"Cria um servidor TCP (tipo de socket :const:`~socket.SOCK_STREAM`) à escuta "
"na *porta* do endereço *host*."

#: ../../library/asyncio-eventloop.rst:690
msgid "Returns a :class:`Server` object."
msgstr "Devolve um objeto :class:`Server`."

#: ../../library/asyncio-eventloop.rst:692
msgid "Arguments:"
msgstr "Argumentos:"

#: ../../library/asyncio-eventloop.rst:697
msgid ""
"The *host* parameter can be set to several types which determine where the "
"server would be listening:"
msgstr ""
"O parâmetro *host* pode ser definido para vários tipos que determinam onde o "
"servidor estará à escuta:"

#: ../../library/asyncio-eventloop.rst:700
msgid ""
"If *host* is a string, the TCP server is bound to a single network interface "
"specified by *host*."
msgstr ""
"Se *host* for uma string, o servidor TCP é ligado a uma única interface de "
"rede especificada por *host*."

#: ../../library/asyncio-eventloop.rst:703
msgid ""
"If *host* is a sequence of strings, the TCP server is bound to all network "
"interfaces specified by the sequence."
msgstr ""
"Se *host* for uma sequência de strings, o servidor TCP é ligado a todas as "
"interfaces de rede especificadas pela sequência."

#: ../../library/asyncio-eventloop.rst:706
msgid ""
"If *host* is an empty string or ``None``, all interfaces are assumed and a "
"list of multiple sockets will be returned (most likely one for IPv4 and "
"another one for IPv6)."
msgstr ""
"Se *host* for uma string vazia ou ``None``, todas as interfaces são "
"assumidas e será devolvida uma lista de vários sockets (provavelmente um "
"para IPv4 e outro para IPv6)."

#: ../../library/asyncio-eventloop.rst:710
msgid ""
"The *port* parameter can be set to specify which port the server should "
"listen on. If ``0`` or ``None`` (the default), a random unused port will be "
"selected (note that if *host* resolves to multiple network interfaces, a "
"different random port will be selected for each interface)."
msgstr ""
"O parâmetro *port* pode ser definido para especificar em que porta o "
"servidor deve escutar. Se for ``0`` ou ``None`` (predefinição), será "
"selecionada uma porta aleatória não utilizada (note que se *host* resolver "
"para várias interfaces de rede, uma porta aleatória diferente será "
"selecionada para cada interface)."

#: ../../library/asyncio-eventloop.rst:715
msgid ""
"*family* can be set to either :const:`socket.AF_INET` or :const:`~socket."
"AF_INET6` to force the socket to use IPv4 or IPv6. If not set, the *family* "
"will be determined from host name (defaults to :const:`~socket.AF_UNSPEC`)."
msgstr ""
"*family* pode ser definido como :const:`socket.AF_INET` ou :const:`~socket."
"AF_INET6` para forçar o socket a usar IPv4 ou IPv6. Se não for definido, "
"*family* será determinado a partir do nome do host (predefinição para :const:"
"`~socket.AF_UNSPEC`)."

#: ../../library/asyncio-eventloop.rst:720
msgid "*flags* is a bitmask for :meth:`getaddrinfo`."
msgstr "*flags* é uma máscara de bits para :meth:`getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:722
msgid ""
"*sock* can optionally be specified in order to use a preexisting socket "
"object. If specified, *host* and *port* must not be specified."
msgstr ""
"*sock* pode ser opcionalmente especificado para utilizar um objeto socket "
"pré-existente. Se especificado, *host* e *port* não devem ser especificados."

#: ../../library/asyncio-eventloop.rst:727
msgid ""
"The *sock* argument transfers ownership of the socket to the server created. "
"To close the socket, call the server's :meth:`~asyncio.Server.close` method."
msgstr ""
"O argumento *sock* transfere a propriedade do socket para o servidor criado. "
"Para fechar o socket, chame o método :meth:`~asyncio.Server.close` do "
"servidor."

#: ../../library/asyncio-eventloop.rst:731
msgid ""
"*backlog* is the maximum number of queued connections passed to :meth:"
"`~socket.socket.listen` (defaults to 100)."
msgstr ""
"*backlog* é o número máximo de ligações em fila passadas para :meth:`~socket."
"socket.listen` (predefinição é 100)."

#: ../../library/asyncio-eventloop.rst:734
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` instance to enable TLS over "
"the accepted connections."
msgstr ""
"*ssl* pode ser definido como uma instância :class:`~ssl.SSLContext` para "
"ativar TLS nas ligações aceites."

#: ../../library/asyncio-eventloop.rst:737
msgid ""
"*reuse_address* tells the kernel to reuse a local socket in ``TIME_WAIT`` "
"state, without waiting for its natural timeout to expire. If not specified "
"will automatically be set to ``True`` on Unix."
msgstr ""
"*reuse_address* indica ao kernel para reutilizar um socket local no estado "
"``TIME_WAIT``, sem aguardar que o seu timeout natural expire. Se não for "
"especificado, será automaticamente definido como ``True`` em Unix."

#: ../../library/asyncio-eventloop.rst:742
msgid ""
"*reuse_port* tells the kernel to allow this endpoint to be bound to the same "
"port as other existing endpoints are bound to, so long as they all set this "
"flag when being created. This option is not supported on Windows."
msgstr ""
"*reuse_port* indica ao kernel para permitir que este endpoint seja ligado à "
"mesma porta que outros endpoints existentes, desde que todos definam esta "
"flag ao serem criados. Esta opção não é suportada no Windows."

#: ../../library/asyncio-eventloop.rst:747
msgid ""
"*ssl_handshake_timeout* is (for a TLS server) the time in seconds to wait "
"for the TLS handshake to complete before aborting the connection. ``60.0`` "
"seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* é (para um servidor TLS) o tempo em segundos para "
"aguardar que o TLS handshake seja concluído antes de abortar a ligação. "
"``60.0`` segundos se for ``None`` (predefinição)."

#: ../../library/asyncio-eventloop.rst:755
msgid ""
"*start_serving* set to ``True`` (the default) causes the created server to "
"start accepting connections immediately.  When set to ``False``, the user "
"should await on :meth:`Server.start_serving` or :meth:`Server.serve_forever` "
"to make the server to start accepting connections."
msgstr ""
"*start_serving* definido como ``True`` (predefinição) faz com que o servidor "
"criado comece a aceitar ligações imediatamente. Quando definido como "
"``False``, o utilizador deve aguardar por :meth:`Server.start_serving` ou :"
"meth:`Server.serve_forever` para que o servidor comece a aceitar ligações."

#: ../../library/asyncio-eventloop.rst:767
msgid "The *host* parameter can be a sequence of strings."
msgstr "O parâmetro *host* pode ser uma sequência de strings."

#: ../../library/asyncio-eventloop.rst:771
msgid ""
"Added *ssl_handshake_timeout* and *start_serving* parameters. The socket "
"option :ref:`socket.TCP_NODELAY <socket-unix-constants>` is set by default "
"for all TCP connections."
msgstr ""
"Adicionados os parâmetros *ssl_handshake_timeout* e *start_serving*. A opção "
"de socket :ref:`socket.TCP_NODELAY <socket-unix-constants>` é definida por "
"predefinição para todas as ligações TCP."

#: ../../library/asyncio-eventloop.rst:781
msgid ""
"The :func:`start_server` function is a higher-level alternative API that "
"returns a pair of :class:`StreamReader` and :class:`StreamWriter` that can "
"be used in an async/await code."
msgstr ""
"A função :func:`start_server` é uma API alternativa de alto nível que "
"devolve um par de :class:`StreamReader` e :class:`StreamWriter` que pode ser "
"utilizado em código async/await."

#: ../../library/asyncio-eventloop.rst:793
msgid ""
"Similar to :meth:`loop.create_server` but works with the :py:const:`~socket."
"AF_UNIX` socket family."
msgstr ""
"Semelhante a :meth:`loop.create_server`, mas funciona com a família de "
"sockets :py:const:`~socket.AF_UNIX`."

#: ../../library/asyncio-eventloop.rst:796
msgid ""
"*path* is the name of a Unix domain socket, and is required, unless a *sock* "
"argument is provided.  Abstract Unix sockets, :class:`str`, :class:`bytes`, "
"and :class:`~pathlib.Path` paths are supported."
msgstr ""
"*path* é o nome de um socket de domínio Unix e é obrigatório, a menos que "
"seja fornecido um argumento *sock*. São suportados sockets Unix abstratos, :"
"class:`str`, :class:`bytes` e caminhos :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:801
msgid ""
"See the documentation of the :meth:`loop.create_server` method for "
"information about arguments to this method."
msgstr ""
"Consulte a documentação do método :meth:`loop.create_server` para obter "
"informações sobre os argumentos deste método."

#: ../../library/asyncio-eventloop.rst:808
msgid ""
"Added the *ssl_handshake_timeout* and *start_serving* parameters. The *path* "
"parameter can now be a :class:`~pathlib.Path` object."
msgstr ""
"Adicionados os parâmetros *ssl_handshake_timeout* e *start_serving*. O "
"parâmetro *path* agora pode ser um objeto :class:`~pathlib.Path`."

#: ../../library/asyncio-eventloop.rst:821
msgid "Wrap an already accepted connection into a transport/protocol pair."
msgstr "Encapsula uma ligação já aceite num par transporte/protocolo."

#: ../../library/asyncio-eventloop.rst:823
msgid ""
"This method can be used by servers that accept connections outside of "
"asyncio but that use asyncio to handle them."
msgstr ""
"Este método pode ser utilizado por servidores que aceitam ligações fora do "
"asyncio, mas que utilizam o asyncio para as tratar."

#: ../../library/asyncio-eventloop.rst:826
#: ../../library/asyncio-eventloop.rst:918
msgid "Parameters:"
msgstr "Parâmetros:"

#: ../../library/asyncio-eventloop.rst:831
msgid ""
"*sock* is a preexisting socket object returned from :meth:`socket.accept "
"<socket.socket.accept>`."
msgstr ""
"*sock* é um objeto socket pré-existente devolvido por :meth:`socket.accept "
"<socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:840
msgid ""
"*ssl* can be set to an :class:`~ssl.SSLContext` to enable SSL over the "
"accepted connections."
msgstr ""
"*ssl* pode ser definido como um :class:`~ssl.SSLContext` para ativar SSL nas "
"ligações aceites."

#: ../../library/asyncio-eventloop.rst:843
msgid ""
"*ssl_handshake_timeout* is (for an SSL connection) the time in seconds to "
"wait for the SSL handshake to complete before aborting the connection. "
"``60.0`` seconds if ``None`` (default)."
msgstr ""
"*ssl_handshake_timeout* é (para uma ligação SSL) o tempo em segundos para "
"aguardar que o SSL handshake seja concluído antes de abortar a ligação. "
"``60.0`` segundos se for ``None`` (predefinição)."

#: ../../library/asyncio-eventloop.rst:851
msgid "Returns a ``(transport, protocol)`` pair."
msgstr "Devolve um par ``(transport, protocol)``."

#: ../../library/asyncio-eventloop.rst:865
msgid "Transferring files"
msgstr "Transferência de ficheiros"

#: ../../library/asyncio-eventloop.rst:871
msgid ""
"Send a *file* over a *transport*.  Return the total number of bytes sent."
msgstr ""
"Envie um *ficheiro* através de um *transporte*. Devolve o número total de "
"bytes enviados."

#: ../../library/asyncio-eventloop.rst:874
msgid "The method uses high-performance :meth:`os.sendfile` if available."
msgstr ""
"O método utiliza :meth:`os.sendfile` de alto desempenho, se disponível."

#: ../../library/asyncio-eventloop.rst:876
msgid "*file* must be a regular file object opened in binary mode."
msgstr "*file* deve ser um objeto de ficheiro regular aberto em modo binário."

#: ../../library/asyncio-eventloop.rst:878
#: ../../library/asyncio-eventloop.rst:1139
msgid ""
"*offset* tells from where to start reading the file. If specified, *count* "
"is the total number of bytes to transmit as opposed to sending the file "
"until EOF is reached. File position is always updated, even when this method "
"raises an error, and :meth:`file.tell() <io.IOBase.tell>` can be used to "
"obtain the actual number of bytes sent."
msgstr ""
"*offset* indica de onde começar a ler o ficheiro. Se especificado, *count* é "
"o número total de bytes a transmitir, em vez de enviar o ficheiro até "
"atingir o EOF. A posição do ficheiro é sempre atualizada, mesmo quando este "
"método levanta um erro, e :meth:`file.tell() <io.IOBase.tell>` pode ser "
"utilizado para obter o número real de bytes enviados."

#: ../../library/asyncio-eventloop.rst:885
msgid ""
"*fallback* set to ``True`` makes asyncio to manually read and send the file "
"when the platform does not support the sendfile system call (e.g. Windows or "
"SSL socket on Unix)."
msgstr ""
"*fallback* definido como ``True`` faz com que o asyncio leia e envie "
"manualmente o ficheiro quando a plataforma não suporta a chamada de sistema "
"sendfile (por exemplo, Windows ou socket SSL em Unix)."

#: ../../library/asyncio-eventloop.rst:889
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support the "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Levanta :exc:`SendfileNotAvailableError` se o sistema não suportar a chamada "
"de sistema *sendfile* e *fallback* for ``False``."

#: ../../library/asyncio-eventloop.rst:896
msgid "TLS Upgrade"
msgstr "Atualização TLS"

#: ../../library/asyncio-eventloop.rst:904
msgid "Upgrade an existing transport-based connection to TLS."
msgstr "Atualiza uma ligação baseada em transporte existente para TLS."

#: ../../library/asyncio-eventloop.rst:906
msgid ""
"Create a TLS coder/decoder instance and insert it between the *transport* "
"and the *protocol*. The coder/decoder implements both *transport*-facing "
"protocol and *protocol*-facing transport."
msgstr ""
"Cria uma instância de codificador/descodificador TLS e insere-a entre o "
"*transporte* e o *protocolo*. O codificador/descodificador implementa tanto "
"o protocolo voltado para o *transporte* como o transporte voltado para o "
"*protocolo*."

#: ../../library/asyncio-eventloop.rst:910
msgid ""
"Return the created two-interface instance. After *await*, the *protocol* "
"must stop using the original *transport* and communicate with the returned "
"object only because the coder caches *protocol*-side data and sporadically "
"exchanges extra TLS session packets with *transport*."
msgstr ""
"Devolve a instância de duas interfaces criada. Após *await*, o *protocolo* "
"deve parar de utilizar o *transporte* original e comunicar apenas com o "
"objeto devolvido, porque o codificador guarda em cache dados do lado do "
"*protocolo* e troca esporadicamente pacotes adicionais da sessão TLS com o "
"*transporte*."

#: ../../library/asyncio-eventloop.rst:915
msgid ""
"In some situations (e.g. when the passed transport is already closing) this "
"may return ``None``."
msgstr ""
"Em algumas situações (por exemplo, quando o transporte passado já está a "
"fechar), isto pode devolver ``None``."

#: ../../library/asyncio-eventloop.rst:920
msgid ""
"*transport* and *protocol* instances that methods like :meth:`~loop."
"create_server` and :meth:`~loop.create_connection` return."
msgstr ""
"Instâncias de *transporte* e *protocolo* que métodos como :meth:`~loop."
"create_server` e :meth:`~loop.create_connection` devolvem."

#: ../../library/asyncio-eventloop.rst:924
msgid "*sslcontext*: a configured instance of :class:`~ssl.SSLContext`."
msgstr "*sslcontext*: uma instância configurada de :class:`~ssl.SSLContext`."

#: ../../library/asyncio-eventloop.rst:926
msgid ""
"*server_side* pass ``True`` when a server-side connection is being upgraded "
"(like the one created by :meth:`~loop.create_server`)."
msgstr ""
"*server_side* passe ``True`` quando uma ligação do lado do servidor está a "
"ser atualizada (como a criada por :meth:`~loop.create_server`)."

#: ../../library/asyncio-eventloop.rst:929
msgid ""
"*server_hostname*: sets or overrides the host name that the target server's "
"certificate will be matched against."
msgstr ""
"*server_hostname*: define ou substitui o nome do host contra o qual o "
"certificado do servidor de destino será comparado."

#: ../../library/asyncio-eventloop.rst:949
msgid "Watching file descriptors"
msgstr "Observação de descritores de ficheiros"

#: ../../library/asyncio-eventloop.rst:953
msgid ""
"Start monitoring the *fd* file descriptor for read availability and invoke "
"*callback* with the specified arguments once *fd* is available for reading."
msgstr ""
"Inicia a monitorização do descritor de ficheiro *fd* para disponibilidade de "
"leitura e invoca *callback* com os argumentos especificados assim que *fd* "
"estiver disponível para leitura."

#: ../../library/asyncio-eventloop.rst:957
#: ../../library/asyncio-eventloop.rst:971
msgid ""
"Any preexisting callback registered for *fd* is cancelled and replaced by "
"*callback*."
msgstr ""
"Qualquer chamada de retorno pré-existente registada para *fd* é cancelada e "
"substituída por *callback*."

#: ../../library/asyncio-eventloop.rst:962
msgid ""
"Stop monitoring the *fd* file descriptor for read availability. Returns "
"``True`` if *fd* was previously being monitored for reads."
msgstr ""
"Para de monitorizar o descritor de ficheiro *fd* para disponibilidade de "
"leitura. Devolve ``True`` se *fd* estava a ser monitorizado para leituras."

#: ../../library/asyncio-eventloop.rst:967
msgid ""
"Start monitoring the *fd* file descriptor for write availability and invoke "
"*callback* with the specified arguments once *fd* is available for writing."
msgstr ""
"Inicia a monitorização do descritor de ficheiro *fd* para disponibilidade de "
"escrita e invoca *callback* com os argumentos especificados assim que *fd* "
"estiver disponível para escrita."

#: ../../library/asyncio-eventloop.rst:974
#: ../../library/asyncio-eventloop.rst:1252
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *callback*."
msgstr ""
"Utilize :func:`functools.partial` :ref:`para passar argumentos de palavra-"
"chave <asyncio-pass-keywords>` para *callback*."

#: ../../library/asyncio-eventloop.rst:979
msgid ""
"Stop monitoring the *fd* file descriptor for write availability. Returns "
"``True`` if *fd* was previously being monitored for writes."
msgstr ""
"Para de monitorizar o descritor de ficheiro *fd* para disponibilidade de "
"escrita. Devolve ``True`` se *fd* estava a ser monitorizado para escritas."

#: ../../library/asyncio-eventloop.rst:982
msgid ""
"See also :ref:`Platform Support <asyncio-platform-support>` section for some "
"limitations of these methods."
msgstr ""
"Consulte também a secção :ref:`Suporte de Plataforma <asyncio-platform-"
"support>` para algumas limitações destes métodos."

#: ../../library/asyncio-eventloop.rst:987
msgid "Working with socket objects directly"
msgstr "Trabalhar diretamente com objetos socket"

#: ../../library/asyncio-eventloop.rst:989
msgid ""
"In general, protocol implementations that use transport-based APIs such as :"
"meth:`loop.create_connection` and :meth:`loop.create_server` are faster than "
"implementations that work with sockets directly. However, there are some use "
"cases when performance is not critical, and working with :class:`~socket."
"socket` objects directly is more convenient."
msgstr ""
"Em geral, as implementações de protocolos que utilizam APIs baseadas em "
"transporte, como :meth:`loop.create_connection` e :meth:`loop."
"create_server`, são mais rápidas do que as implementações que trabalham "
"diretamente com sockets. No entanto, existem alguns casos de uso em que o "
"desempenho não é crítico e trabalhar diretamente com objetos :class:`~socket."
"socket` é mais conveniente."

#: ../../library/asyncio-eventloop.rst:999
msgid ""
"Receive up to *nbytes* from *sock*.  Asynchronous version of :meth:`socket."
"recv() <socket.socket.recv>`."
msgstr ""
"Recebe até *nbytes* de *sock*. Versão assíncrona de :meth:`socket.recv() "
"<socket.socket.recv>`."

#: ../../library/asyncio-eventloop.rst:1002
msgid "Return the received data as a bytes object."
msgstr "Devolve os dados recebidos como um objeto bytes."

#: ../../library/asyncio-eventloop.rst:1004
#: ../../library/asyncio-eventloop.rst:1019
#: ../../library/asyncio-eventloop.rst:1031
#: ../../library/asyncio-eventloop.rst:1044
#: ../../library/asyncio-eventloop.rst:1060
#: ../../library/asyncio-eventloop.rst:1076
#: ../../library/asyncio-eventloop.rst:1087
#: ../../library/asyncio-eventloop.rst:1114
#: ../../library/asyncio-eventloop.rst:1153
msgid "*sock* must be a non-blocking socket."
msgstr "*sock* deve ser um socket não bloqueante."

#: ../../library/asyncio-eventloop.rst:1006
msgid ""
"Even though this method was always documented as a coroutine method, "
"releases before Python 3.7 returned a :class:`Future`. Since Python 3.7 this "
"is an ``async def`` method."
msgstr ""
"Embora este método tenha sido sempre documentado como um método de "
"corrotina, as versões anteriores ao Python 3.7 devolviam um :class:`Future`. "
"Desde o Python 3.7, este é um método ``async def``."

#: ../../library/asyncio-eventloop.rst:1014
msgid ""
"Receive data from *sock* into the *buf* buffer.  Modeled after the blocking :"
"meth:`socket.recv_into() <socket.socket.recv_into>` method."
msgstr ""
"Recebe dados de *sock* para o buffer *buf*. Modelado após o método "
"bloqueante :meth:`socket.recv_into() <socket.socket.recv_into>`."

#: ../../library/asyncio-eventloop.rst:1017
msgid "Return the number of bytes written to the buffer."
msgstr "Devolve o número de bytes escritos no buffer."

#: ../../library/asyncio-eventloop.rst:1026
msgid ""
"Receive a datagram of up to *bufsize* from *sock*.  Asynchronous version of :"
"meth:`socket.recvfrom() <socket.socket.recvfrom>`."
msgstr ""
"Recebe um datagrama de até *bufsize* de *sock*. Versão assíncrona de :meth:"
"`socket.recvfrom() <socket.socket.recvfrom>`."

#: ../../library/asyncio-eventloop.rst:1029
msgid "Return a tuple of (received data, remote address)."
msgstr "Devolve um tuplo de (dados recebidos, endereço remoto)."

#: ../../library/asyncio-eventloop.rst:1038
msgid ""
"Receive a datagram of up to *nbytes* from *sock* into *buf*. Asynchronous "
"version of :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."
msgstr ""
"Recebe um datagrama de até *nbytes* de *sock* para *buf*. Versão assíncrona "
"de :meth:`socket.recvfrom_into() <socket.socket.recvfrom_into>`."

#: ../../library/asyncio-eventloop.rst:1042
msgid "Return a tuple of (number of bytes received, remote address)."
msgstr "Devolve um tuplo de (número de bytes recebidos, endereço remoto)."

#: ../../library/asyncio-eventloop.rst:1051
msgid ""
"Send *data* to the *sock* socket. Asynchronous version of :meth:`socket."
"sendall() <socket.socket.sendall>`."
msgstr ""
"Envie *data* para o socket *sock*. Versão assíncrona de :meth:`socket."
"sendall() <socket.socket.sendall>`."

#: ../../library/asyncio-eventloop.rst:1054
msgid ""
"This method continues to send to the socket until either all data in *data* "
"has been sent or an error occurs.  ``None`` is returned on success.  On "
"error, an exception is raised. Additionally, there is no way to determine "
"how much data, if any, was successfully processed by the receiving end of "
"the connection."
msgstr ""
"Este método continua a enviar para o socket até que todos os dados em *data* "
"tenham sido enviados ou ocorra um erro. ``None`` é devolvido em caso de "
"sucesso. Em caso de erro, é levantada uma exceção. Além disso, não há forma "
"de determinar quantos dados, se houver, foram processados com sucesso pelo "
"lado recetor da ligação."

#: ../../library/asyncio-eventloop.rst:1062
#: ../../library/asyncio-eventloop.rst:1116
msgid ""
"Even though the method was always documented as a coroutine method, before "
"Python 3.7 it returned a :class:`Future`. Since Python 3.7, this is an "
"``async def`` method."
msgstr ""
"Embora este método tenha sido sempre documentado como um método de "
"corrotina, antes do Python 3.7 devolvia um :class:`Future`. Desde o Python "
"3.7, este é um método ``async def``."

#: ../../library/asyncio-eventloop.rst:1070
msgid ""
"Send a datagram from *sock* to *address*. Asynchronous version of :meth:"
"`socket.sendto() <socket.socket.sendto>`."
msgstr ""
"Envie um datagrama de *sock* para *address*. Versão assíncrona de :meth:"
"`socket.sendto() <socket.socket.sendto>`."

#: ../../library/asyncio-eventloop.rst:1074
msgid "Return the number of bytes sent."
msgstr "Devolve o número de bytes enviados."

#: ../../library/asyncio-eventloop.rst:1083
msgid "Connect *sock* to a remote socket at *address*."
msgstr "Liga *sock* a um socket remoto em *address*."

#: ../../library/asyncio-eventloop.rst:1085
msgid ""
"Asynchronous version of :meth:`socket.connect() <socket.socket.connect>`."
msgstr "Versão assíncrona de :meth:`socket.connect() <socket.socket.connect>`."

#: ../../library/asyncio-eventloop.rst:1089
msgid ""
"``address`` no longer needs to be resolved.  ``sock_connect`` will try to "
"check if the *address* is already resolved by calling :func:`socket."
"inet_pton`.  If not, :meth:`loop.getaddrinfo` will be used to resolve the "
"*address*."
msgstr ""
"``address`` já não precisa de ser resolvido. ``sock_connect`` tentará "
"verificar se *address* já está resolvido chamando :func:`socket.inet_pton`. "
"Caso contrário, :meth:`loop.getaddrinfo` será utilizado para resolver "
"*address*."

#: ../../library/asyncio-eventloop.rst:1098
msgid ""
":meth:`loop.create_connection` and  :func:`asyncio.open_connection() "
"<open_connection>`."
msgstr ""
":meth:`loop.create_connection` e :func:`asyncio.open_connection() "
"<open_connection>`."

#: ../../library/asyncio-eventloop.rst:1105
msgid ""
"Accept a connection.  Modeled after the blocking :meth:`socket.accept() "
"<socket.socket.accept>` method."
msgstr ""
"Aceita uma ligação. Modelado após o método bloqueante :meth:`socket.accept() "
"<socket.socket.accept>`."

#: ../../library/asyncio-eventloop.rst:1108
msgid ""
"The socket must be bound to an address and listening for connections. The "
"return value is a pair ``(conn, address)`` where *conn* is a *new* socket "
"object usable to send and receive data on the connection, and *address* is "
"the address bound to the socket on the other end of the connection."
msgstr ""
"O socket deve estar ligado a um endereço e à escuta de ligações. O valor "
"devolvido é um par ``(conn, address)``, onde *conn* é um *novo* objeto "
"socket utilizável para enviar e receber dados na ligação, e *address* é o "
"endereço ligado ao socket na outra extremidade da ligação."

#: ../../library/asyncio-eventloop.rst:1123
msgid ":meth:`loop.create_server` and :func:`start_server`."
msgstr ":meth:`loop.create_server` e :func:`start_server`."

#: ../../library/asyncio-eventloop.rst:1129
msgid ""
"Send a file using high-performance :mod:`os.sendfile` if possible. Return "
"the total number of bytes sent."
msgstr ""
"Envie um ficheiro utilizando :mod:`os.sendfile` de alto desempenho, se "
"possível. Devolve o número total de bytes enviados."

#: ../../library/asyncio-eventloop.rst:1132
msgid ""
"Asynchronous version of :meth:`socket.sendfile() <socket.socket.sendfile>`."
msgstr ""
"Versão assíncrona de :meth:`socket.sendfile() <socket.socket.sendfile>`."

#: ../../library/asyncio-eventloop.rst:1134
msgid ""
"*sock* must be a non-blocking :const:`socket.SOCK_STREAM` :class:`~socket."
"socket`."
msgstr ""
"*sock* deve ser um :const:`socket.SOCK_STREAM` não bloqueante :class:"
"`~socket.socket`."

#: ../../library/asyncio-eventloop.rst:1137
msgid "*file* must be a regular file object open in binary mode."
msgstr "*file* deve ser um objeto de ficheiro regular aberto em modo binário."

#: ../../library/asyncio-eventloop.rst:1146
msgid ""
"*fallback*, when set to ``True``, makes asyncio manually read and send the "
"file when the platform does not support the sendfile syscall (e.g. Windows "
"or SSL socket on Unix)."
msgstr ""
"*fallback*, quando definido como ``True``, faz com que o asyncio leia e "
"envie manualmente o ficheiro quando a plataforma não suporta a chamada de "
"sistema sendfile (por exemplo, Windows ou socket SSL em Unix)."

#: ../../library/asyncio-eventloop.rst:1150
msgid ""
"Raise :exc:`SendfileNotAvailableError` if the system does not support "
"*sendfile* syscall and *fallback* is ``False``."
msgstr ""
"Levanta :exc:`SendfileNotAvailableError` se o sistema não suportar a chamada "
"de sistema *sendfile* e *fallback* for ``False``."

#: ../../library/asyncio-eventloop.rst:1159
msgid "DNS"
msgstr "DNS"

#: ../../library/asyncio-eventloop.rst:1165
msgid "Asynchronous version of :meth:`socket.getaddrinfo`."
msgstr "Versão assíncrona de :meth:`socket.getaddrinfo`."

#: ../../library/asyncio-eventloop.rst:1170
msgid "Asynchronous version of :meth:`socket.getnameinfo`."
msgstr "Versão assíncrona de :meth:`socket.getnameinfo`."

#: ../../library/asyncio-eventloop.rst:1173
msgid ""
"Both *getaddrinfo* and *getnameinfo* internally utilize their synchronous "
"versions through the loop's default thread pool executor. When this executor "
"is saturated, these methods may experience delays, which higher-level "
"networking libraries may report as increased timeouts. To mitigate this, "
"consider using a custom executor for other user tasks, or setting a default "
"executor with a larger number of workers."
msgstr ""
"Tanto *getaddrinfo* como *getnameinfo* utilizam internamente as suas versões "
"síncronas através do executor de pool de threads predefinido do ciclo. "
"Quando este executor está saturado, estes métodos podem sofrer atrasos, que "
"bibliotecas de rede de nível superior podem reportar como timeouts "
"aumentados. Para mitigar isto, considere utilizar um executor personalizado "
"para outras tarefas do utilizador, ou definir um executor predefinido com um "
"maior número de trabalhadores."

#: ../../library/asyncio-eventloop.rst:1180
msgid ""
"Both *getaddrinfo* and *getnameinfo* methods were always documented to "
"return a coroutine, but prior to Python 3.7 they were, in fact, returning :"
"class:`asyncio.Future` objects.  Starting with Python 3.7 both methods are "
"coroutines."
msgstr ""
"Ambos os métodos *getaddrinfo* e *getnameinfo* foram sempre documentados "
"para devolver uma corrotina, mas antes do Python 3.7 devolviam, de facto, "
"objetos :class:`asyncio.Future`. A partir do Python 3.7, ambos os métodos "
"são corrotinas."

#: ../../library/asyncio-eventloop.rst:1188
msgid "Working with pipes"
msgstr "Trabalhar com pipes"

#: ../../library/asyncio-eventloop.rst:1193
msgid "Register the read end of *pipe* in the event loop."
msgstr "Regista a extremidade de leitura de *pipe* no ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1198
msgid "*pipe* is a :term:`file-like object <file object>`."
msgstr "*pipe* é um :term:`objeto tipo ficheiro <file object>`."

#: ../../library/asyncio-eventloop.rst:1200
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports the :class:"
"`ReadTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Devolve um par ``(transport, protocol)``, onde *transporte* suporta a "
"interface :class:`ReadTransport` e *protocolo* é um objeto instanciado por "
"*protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1204
#: ../../library/asyncio-eventloop.rst:1221
msgid ""
"With :class:`SelectorEventLoop` event loop, the *pipe* is set to non-"
"blocking mode."
msgstr ""
"Com o ciclo de eventos :class:`SelectorEventLoop`, o *pipe* é definido para "
"modo não bloqueante."

#: ../../library/asyncio-eventloop.rst:1210
msgid "Register the write end of *pipe* in the event loop."
msgstr "Regista a extremidade de escrita de *pipe* no ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1215
msgid "*pipe* is :term:`file-like object <file object>`."
msgstr "*pipe* é um :term:`objeto tipo ficheiro <file object>`."

#: ../../library/asyncio-eventloop.rst:1217
msgid ""
"Return pair ``(transport, protocol)``, where *transport* supports :class:"
"`WriteTransport` interface and *protocol* is an object instantiated by the "
"*protocol_factory*."
msgstr ""
"Devolve um par ``(transport, protocol)``, onde *transporte* suporta a "
"interface :class:`WriteTransport` e *protocolo* é um objeto instanciado por "
"*protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1226
msgid ""
":class:`SelectorEventLoop` does not support the above methods on Windows.  "
"Use :class:`ProactorEventLoop` instead for Windows."
msgstr ""
":class:`SelectorEventLoop` não suporta os métodos acima no Windows. Utilize :"
"class:`ProactorEventLoop` em vez disso para Windows."

#: ../../library/asyncio-eventloop.rst:1231
msgid ""
"The :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` methods."
msgstr ""
"Os métodos :meth:`loop.subprocess_exec` e :meth:`loop.subprocess_shell`."

#: ../../library/asyncio-eventloop.rst:1236
msgid "Unix signals"
msgstr "Sinais Unix"

#: ../../library/asyncio-eventloop.rst:1242
msgid "Set *callback* as the handler for the *signum* signal."
msgstr "Define *callback* como o manipulador para o sinal *signum*."

#: ../../library/asyncio-eventloop.rst:1244
msgid ""
"The callback will be invoked by *loop*, along with other queued callbacks "
"and runnable coroutines of that event loop. Unlike signal handlers "
"registered using :func:`signal.signal`, a callback registered with this "
"function is allowed to interact with the event loop."
msgstr ""
"A chamada de retorno será invocada por *loop*, juntamente com outras "
"chamadas de retorno em fila e corrotinas executáveis desse ciclo de eventos. "
"Ao contrário dos manipuladores de sinais registados utilizando :func:`signal."
"signal`, uma chamada de retorno registada com esta função pode interagir com "
"o ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1249
msgid ""
"Raise :exc:`ValueError` if the signal number is invalid or uncatchable. "
"Raise :exc:`RuntimeError` if there is a problem setting up the handler."
msgstr ""
"Levanta :exc:`ValueError` se o número do sinal for inválido ou não puder ser "
"capturado. Levanta :exc:`RuntimeError` se houver um problema ao configurar o "
"manipulador."

#: ../../library/asyncio-eventloop.rst:1255
msgid ""
"Like :func:`signal.signal`, this function must be invoked in the main thread."
msgstr ""
"Tal como :func:`signal.signal`, esta função deve ser invocada na thread "
"principal."

#: ../../library/asyncio-eventloop.rst:1260
msgid "Remove the handler for the *sig* signal."
msgstr "Remove o manipulador para o sinal *sig*."

#: ../../library/asyncio-eventloop.rst:1262
msgid ""
"Return ``True`` if the signal handler was removed, or ``False`` if no "
"handler was set for the given signal."
msgstr ""
"Devolve ``True`` se o manipulador de sinal foi removido, ou ``False`` se "
"nenhum manipulador estava definido para o sinal dado."

#: ../../library/asyncio-eventloop.rst:1269
msgid "The :mod:`signal` module."
msgstr "O módulo :mod:`signal`."

#: ../../library/asyncio-eventloop.rst:1273
msgid "Executing code in thread or process pools"
msgstr "Execução de código em pools de threads ou processos"

#: ../../library/asyncio-eventloop.rst:1277
msgid "Arrange for *func* to be called in the specified executor."
msgstr "Organiza para que *func* seja chamada no executor especificado."

#: ../../library/asyncio-eventloop.rst:1279
msgid ""
"The *executor* argument should be an :class:`concurrent.futures.Executor` "
"instance. The default executor is used if *executor* is ``None``. The "
"default executor can be set by :meth:`loop.set_default_executor`, otherwise, "
"a :class:`concurrent.futures.ThreadPoolExecutor` will be lazy-initialized "
"and used by :func:`run_in_executor` if needed."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1287
msgid ""
"import asyncio\n"
"import concurrent.futures\n"
"\n"
"def blocking_io():\n"
"    # File operations (such as logging) can block the\n"
"    # event loop: run them in a thread pool.\n"
"    with open('/dev/urandom', 'rb') as f:\n"
"        return f.read(100)\n"
"\n"
"def cpu_bound():\n"
"    # CPU-bound operations will block the event loop:\n"
"    # in general it is preferable to run them in a\n"
"    # process pool.\n"
"    return sum(i * i for i in range(10 ** 7))\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    ## Options:\n"
"\n"
"    # 1. Run in the default loop's executor:\n"
"    result = await loop.run_in_executor(\n"
"        None, blocking_io)\n"
"    print('default thread pool', result)\n"
"\n"
"    # 2. Run in a custom thread pool:\n"
"    with concurrent.futures.ThreadPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, blocking_io)\n"
"        print('custom thread pool', result)\n"
"\n"
"    # 3. Run in a custom process pool:\n"
"    with concurrent.futures.ProcessPoolExecutor() as pool:\n"
"        result = await loop.run_in_executor(\n"
"            pool, cpu_bound)\n"
"        print('custom process pool', result)\n"
"\n"
"if __name__ == '__main__':\n"
"    asyncio.run(main())"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1327
msgid ""
"Note that the entry point guard (``if __name__ == '__main__'``) is required "
"for option 3 due to the peculiarities of :mod:`multiprocessing`, which is "
"used by :class:`~concurrent.futures.ProcessPoolExecutor`. See :ref:`Safe "
"importing of main module <multiprocessing-safe-main-import>`."
msgstr ""
"Note que a guarda do ponto de entrada (``if __name__ == '__main__'``) é "
"necessária para a opção 3 devido às particularidades do :mod:"
"`multiprocessing`, que é utilizado por :class:`~concurrent.futures."
"ProcessPoolExecutor`. Consulte :ref:`Importação segura do módulo principal "
"<multiprocessing-safe-main-import>`."

#: ../../library/asyncio-eventloop.rst:1332
msgid "This method returns a :class:`asyncio.Future` object."
msgstr "Este método devolve um objeto :class:`asyncio.Future`."

#: ../../library/asyncio-eventloop.rst:1334
msgid ""
"Use :func:`functools.partial` :ref:`to pass keyword arguments <asyncio-pass-"
"keywords>` to *func*."
msgstr ""
"Utilize :func:`functools.partial` :ref:`para passar argumentos de palavra-"
"chave <asyncio-pass-keywords>` para *func*."

#: ../../library/asyncio-eventloop.rst:1337
msgid ""
":meth:`loop.run_in_executor` no longer configures the ``max_workers`` of the "
"thread pool executor it creates, instead leaving it up to the thread pool "
"executor (:class:`~concurrent.futures.ThreadPoolExecutor`) to set the "
"default."
msgstr ""
":meth:`loop.run_in_executor` já não configura o ``max_workers`` do executor "
"de pool de threads que cria, deixando em vez disso que o executor de pool de "
"threads (:class:`~concurrent.futures.ThreadPoolExecutor`) defina o valor "
"predefinido."

#: ../../library/asyncio-eventloop.rst:1346
msgid ""
"Set *executor* as the default executor used by :meth:`run_in_executor`. "
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1350
msgid ""
"*executor* must be an instance of :class:`~concurrent.futures."
"ThreadPoolExecutor`."
msgstr ""
"*executor* deve ser uma instância de :class:`~concurrent.futures."
"ThreadPoolExecutor`."

#: ../../library/asyncio-eventloop.rst:1356
msgid "Error Handling API"
msgstr "API de Tratamento de Erros"

#: ../../library/asyncio-eventloop.rst:1358
msgid "Allows customizing how exceptions are handled in the event loop."
msgstr ""
"Permite personalizar a forma como as exceções são tratadas no ciclo de "
"eventos."

#: ../../library/asyncio-eventloop.rst:1362
msgid "Set *handler* as the new event loop exception handler."
msgstr ""
"Define *handler* como o novo manipulador de exceções do ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1364
msgid ""
"If *handler* is ``None``, the default exception handler will be set.  "
"Otherwise, *handler* must be a callable with the signature matching ``(loop, "
"context)``, where ``loop`` is a reference to the active event loop, and "
"``context`` is a ``dict`` object containing the details of the exception "
"(see :meth:`call_exception_handler` documentation for details about context)."
msgstr ""
"Se *handler* for ``None``, o manipulador de exceções predefinido será "
"definido. Caso contrário, *handler* deve ser um callable com a assinatura "
"correspondente a ``(loop, context)``, onde ``loop`` é uma referência ao "
"ciclo de eventos ativo e ``context`` é um objeto ``dict`` contendo os "
"detalhes da exceção (consulte a documentação de :meth:"
"`call_exception_handler` para detalhes sobre o contexto)."

#: ../../library/asyncio-eventloop.rst:1372
msgid ""
"If the handler is called on behalf of a :class:`~asyncio.Task` or :class:"
"`~asyncio.Handle`, it is run in the :class:`contextvars.Context` of that "
"task or callback handle."
msgstr ""
"Se o manipulador for chamado em nome de uma :class:`~asyncio.Task` ou :class:"
"`~asyncio.Handle`, é executado no :class:`contextvars.Context` dessa tarefa "
"ou manipulador de chamada de retorno."

#: ../../library/asyncio-eventloop.rst:1378
msgid ""
"The handler may be called in the :class:`~contextvars.Context` of the task "
"or handle where the exception originated."
msgstr ""
"O manipulador pode ser chamado no :class:`~contextvars.Context` da tarefa ou "
"manipulador onde a exceção se originou."

#: ../../library/asyncio-eventloop.rst:1383
msgid ""
"Return the current exception handler, or ``None`` if no custom exception "
"handler was set."
msgstr ""
"Devolve o manipulador de exceções atual, ou ``None`` se nenhum manipulador "
"de exceções personalizado foi definido."

#: ../../library/asyncio-eventloop.rst:1390
msgid "Default exception handler."
msgstr "Manipulador de exceções predefinido."

#: ../../library/asyncio-eventloop.rst:1392
msgid ""
"This is called when an exception occurs and no exception handler is set. "
"This can be called by a custom exception handler that wants to defer to the "
"default handler behavior."
msgstr ""
"Isto é chamado quando ocorre uma exceção e nenhum manipulador de exceções "
"está definido. Isto pode ser chamado por um manipulador de exceções "
"personalizado que pretenda recorrer ao comportamento do manipulador "
"predefinido."

#: ../../library/asyncio-eventloop.rst:1396
msgid ""
"*context* parameter has the same meaning as in :meth:"
"`call_exception_handler`."
msgstr ""
"O parâmetro *context* tem o mesmo significado que em :meth:"
"`call_exception_handler`."

#: ../../library/asyncio-eventloop.rst:1401
msgid "Call the current event loop exception handler."
msgstr "Chama o manipulador de exceções atual do ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1403
msgid ""
"*context* is a ``dict`` object containing the following keys (new keys may "
"be introduced in future Python versions):"
msgstr ""
"*context* é um objeto ``dict`` contendo as seguintes chaves (podem ser "
"introduzidas novas chaves em versões futuras do Python):"

#: ../../library/asyncio-eventloop.rst:1406
msgid "'message': Error message;"
msgstr "'message': Mensagem de erro;"

#: ../../library/asyncio-eventloop.rst:1407
msgid "'exception' (optional): Exception object;"
msgstr "'exception' (opcional): Objeto de exceção;"

#: ../../library/asyncio-eventloop.rst:1408
msgid "'future' (optional): :class:`asyncio.Future` instance;"
msgstr "'future' (opcional): Instância de :class:`asyncio.Future`;"

#: ../../library/asyncio-eventloop.rst:1409
msgid "'task' (optional): :class:`asyncio.Task` instance;"
msgstr "'task' (opcional): Instância de :class:`asyncio.Task`;"

#: ../../library/asyncio-eventloop.rst:1410
msgid "'handle' (optional): :class:`asyncio.Handle` instance;"
msgstr "'handle' (opcional): Instância de :class:`asyncio.Handle`;"

#: ../../library/asyncio-eventloop.rst:1411
msgid "'protocol' (optional): :ref:`Protocol <asyncio-protocol>` instance;"
msgstr ""
"'protocol' (opcional): Instância de :ref:`Protocolo <asyncio-protocol>`;"

#: ../../library/asyncio-eventloop.rst:1412
msgid "'transport' (optional): :ref:`Transport <asyncio-transport>` instance;"
msgstr ""
"'transport' (opcional): Instância de :ref:`Transporte <asyncio-transport>`;"

#: ../../library/asyncio-eventloop.rst:1413
msgid "'socket' (optional): :class:`socket.socket` instance;"
msgstr "'socket' (opcional): Instância de :class:`socket.socket`;"

#: ../../library/asyncio-eventloop.rst:1414
msgid "'asyncgen' (optional): Asynchronous generator that caused"
msgstr "'asyncgen' (opcional): Gerador assíncrono que causou"

#: ../../library/asyncio-eventloop.rst:1415
msgid "the exception."
msgstr "a exceção."

#: ../../library/asyncio-eventloop.rst:1419
msgid ""
"This method should not be overloaded in subclassed event loops.  For custom "
"exception handling, use the :meth:`set_exception_handler` method."
msgstr ""
"Este método não deve ser sobrecarregado em ciclos de eventos "
"subclassificados. Para tratamento de exceções personalizado, utilize o "
"método :meth:`set_exception_handler`."

#: ../../library/asyncio-eventloop.rst:1424
msgid "Enabling debug mode"
msgstr "Ativação do modo de depuração"

#: ../../library/asyncio-eventloop.rst:1428
msgid "Get the debug mode (:class:`bool`) of the event loop."
msgstr "Obtém o modo de depuração (:class:`bool`) do ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1430
msgid ""
"The default value is ``True`` if the environment variable :envvar:"
"`PYTHONASYNCIODEBUG` is set to a non-empty string, ``False`` otherwise."
msgstr ""
"O valor predefinido é ``True`` se a variável de ambiente :envvar:"
"`PYTHONASYNCIODEBUG` estiver definida para uma string não vazia, ``False`` "
"caso contrário."

#: ../../library/asyncio-eventloop.rst:1436
msgid "Set the debug mode of the event loop."
msgstr "Define o modo de depuração do ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1440
msgid ""
"The new :ref:`Python Development Mode <devmode>` can now also be used to "
"enable the debug mode."
msgstr ""
"O novo :ref:`Modo de Desenvolvimento do Python <devmode>` também pode ser "
"utilizado para ativar o modo de depuração."

#: ../../library/asyncio-eventloop.rst:1445
msgid ""
"This attribute can be used to set the minimum execution duration in seconds "
"that is considered \"slow\". When debug mode is enabled, \"slow\" callbacks "
"are logged."
msgstr ""
"Este atributo pode ser utilizado para definir a duração mínima de execução "
"em segundos que é considerada \"lenta\". Quando o modo de depuração está "
"ativado, as chamadas de retorno \"lentas\" são registadas."

#: ../../library/asyncio-eventloop.rst:1449
msgid "Default value is 100 milliseconds."
msgstr "O valor predefinido é 100 milissegundos."

#: ../../library/asyncio-eventloop.rst:1453
msgid "The :ref:`debug mode of asyncio <asyncio-debug-mode>`."
msgstr "O :ref:`modo de depuração do asyncio <asyncio-debug-mode>`."

#: ../../library/asyncio-eventloop.rst:1457
msgid "Running Subprocesses"
msgstr "Execução de Subprocessos"

#: ../../library/asyncio-eventloop.rst:1459
msgid ""
"Methods described in this subsections are low-level.  In regular async/await "
"code consider using the high-level :func:`asyncio.create_subprocess_shell` "
"and :func:`asyncio.create_subprocess_exec` convenience functions instead."
msgstr ""
"Os métodos descritos nestas subsecções são de baixo nível. Em código async/"
"await regular, considere utilizar as funções de conveniência de alto nível :"
"func:`asyncio.create_subprocess_shell` e :func:`asyncio."
"create_subprocess_exec` em vez disso."

#: ../../library/asyncio-eventloop.rst:1466
msgid ""
"On Windows, the default event loop :class:`ProactorEventLoop` supports "
"subprocesses, whereas :class:`SelectorEventLoop` does not. See :ref:"
"`Subprocess Support on Windows <asyncio-windows-subprocess>` for details."
msgstr ""
"No Windows, o ciclo de eventos predefinido :class:`ProactorEventLoop` "
"suporta subprocessos, enquanto :class:`SelectorEventLoop` não suporta. "
"Consulte :ref:`Suporte a Subprocessos no Windows <asyncio-windows-"
"subprocess>` para mais detalhes."

#: ../../library/asyncio-eventloop.rst:1478
msgid ""
"Create a subprocess from one or more string arguments specified by *args*."
msgstr ""
"Cria um subprocesso a partir de um ou mais argumentos de string "
"especificados por *args*."

#: ../../library/asyncio-eventloop.rst:1481
msgid "*args* must be a list of strings represented by:"
msgstr "*args* deve ser uma lista de strings representada por:"

#: ../../library/asyncio-eventloop.rst:1483
msgid ":class:`str`;"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1484
msgid ""
"or :class:`bytes`, encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`."
msgstr ""
"ou :class:`bytes`, codificado para a :ref:`codificação do sistema de "
"ficheiros <filesystem-encoding>`."

#: ../../library/asyncio-eventloop.rst:1487
msgid ""
"The first string specifies the program executable, and the remaining strings "
"specify the arguments.  Together, string arguments form the ``argv`` of the "
"program."
msgstr ""
"A primeira string especifica o executável do programa, e as strings "
"restantes especificam os argumentos. Em conjunto, os argumentos de string "
"formam o ``argv`` do programa."

#: ../../library/asyncio-eventloop.rst:1491
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=False`` and the list of strings passed as the first "
"argument; however, where :class:`~subprocess.Popen` takes a single argument "
"which is list of strings, *subprocess_exec* takes multiple string arguments."
msgstr ""
"Isto é semelhante à classe :class:`subprocess.Popen` da biblioteca padrão "
"chamada com ``shell=False`` e a lista de strings passada como primeiro "
"argumento; no entanto, enquanto :class:`~subprocess.Popen` recebe um único "
"argumento que é uma lista de strings, *subprocess_exec* recebe vários "
"argumentos de string."

#: ../../library/asyncio-eventloop.rst:1497
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`asyncio.SubprocessProtocol` class."
msgstr ""
"*protocol_factory* deve ser um objeto invocável que devolva uma subclasse da "
"classe :class:`asyncio.SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1500
msgid "Other parameters:"
msgstr "Outros parâmetros:"

#: ../../library/asyncio-eventloop.rst:1502
msgid "*stdin* can be any of these:"
msgstr "*stdin* pode ser qualquer um dos seguintes:"

#: ../../library/asyncio-eventloop.rst:1504
#: ../../library/asyncio-eventloop.rst:1515
#: ../../library/asyncio-eventloop.rst:1525
msgid "a file-like object"
msgstr "um objeto tipo ficheiro"

#: ../../library/asyncio-eventloop.rst:1505
msgid ""
"an existing file descriptor (a positive integer), for example those created "
"with :meth:`os.pipe`"
msgstr ""
"um descritor de ficheiro existente (um inteiro positivo), por exemplo, "
"aqueles criados com :meth:`os.pipe`"

#: ../../library/asyncio-eventloop.rst:1506
#: ../../library/asyncio-eventloop.rst:1516
#: ../../library/asyncio-eventloop.rst:1526
msgid ""
"the :const:`subprocess.PIPE` constant (default) which will create a new pipe "
"and connect it,"
msgstr ""
"a constante :const:`subprocess.PIPE` (predefinição), que criará uma nova "
"pipe e ligá-la-á,"

#: ../../library/asyncio-eventloop.rst:1508
#: ../../library/asyncio-eventloop.rst:1518
#: ../../library/asyncio-eventloop.rst:1528
msgid ""
"the value ``None`` which will make the subprocess inherit the file "
"descriptor from this process"
msgstr ""
"o valor ``None``, que fará com que o subprocesso herde o descritor de "
"ficheiro deste processo"

#: ../../library/asyncio-eventloop.rst:1510
#: ../../library/asyncio-eventloop.rst:1520
#: ../../library/asyncio-eventloop.rst:1530
msgid ""
"the :const:`subprocess.DEVNULL` constant which indicates that the special :"
"data:`os.devnull` file will be used"
msgstr ""
"a constante :const:`subprocess.DEVNULL`, que indica que o ficheiro especial :"
"data:`os.devnull` será utilizado"

#: ../../library/asyncio-eventloop.rst:1513
msgid "*stdout* can be any of these:"
msgstr "*stdout* pode ser qualquer um dos seguintes:"

#: ../../library/asyncio-eventloop.rst:1523
msgid "*stderr* can be any of these:"
msgstr "*stderr* pode ser qualquer um dos seguintes:"

#: ../../library/asyncio-eventloop.rst:1532
msgid ""
"the :const:`subprocess.STDOUT` constant which will connect the standard "
"error stream to the process' standard output stream"
msgstr ""
"a constante :const:`subprocess.STDOUT`, que ligará o fluxo de erro padrão ao "
"fluxo de saída padrão do processo"

#: ../../library/asyncio-eventloop.rst:1535
msgid ""
"All other keyword arguments are passed to :class:`subprocess.Popen` without "
"interpretation, except for *bufsize*, *universal_newlines*, *shell*, *text*, "
"*encoding* and *errors*, which should not be specified at all."
msgstr ""
"Todos os outros argumentos de palavra-chave são passados para :class:"
"`subprocess.Popen` sem interpretação, exceto *bufsize*, "
"*universal_newlines*, *shell*, *text*, *encoding* e *errors*, que não devem "
"ser especificados."

#: ../../library/asyncio-eventloop.rst:1540
msgid ""
"The ``asyncio`` subprocess API does not support decoding the streams as "
"text. :func:`bytes.decode` can be used to convert the bytes returned from "
"the stream to text."
msgstr ""
"A API de subprocessos ``asyncio`` não suporta a descodificação dos fluxos "
"como texto. :func:`bytes.decode` pode ser utilizado para converter os bytes "
"devolvidos pelo fluxo em texto."

#: ../../library/asyncio-eventloop.rst:1544
msgid ""
"If a file-like object passed as *stdin*, *stdout* or *stderr* represents a "
"pipe, then the other side of this pipe should be registered with :meth:"
"`~loop.connect_write_pipe` or :meth:`~loop.connect_read_pipe` for use with "
"the event loop."
msgstr ""
"Se um objeto tipo ficheiro passado como *stdin*, *stdout* ou *stderr* "
"representar uma pipe, então a outra extremidade desta pipe deve ser "
"registada com :meth:`~loop.connect_write_pipe` ou :meth:`~loop."
"connect_read_pipe` para uso com o ciclo de eventos."

#: ../../library/asyncio-eventloop.rst:1549
msgid ""
"See the constructor of the :class:`subprocess.Popen` class for documentation "
"on other arguments."
msgstr ""
"Consulte o construtor da classe :class:`subprocess.Popen` para documentação "
"sobre outros argumentos."

#: ../../library/asyncio-eventloop.rst:1552
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`asyncio.SubprocessTransport` base class and *protocol* is an "
"object instantiated by the *protocol_factory*."
msgstr ""
"Devolve um par ``(transport, protocol)``, onde *transporte* está em "
"conformidade com a classe base :class:`asyncio.SubprocessTransport` e "
"*protocolo* é um objeto instanciado por *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1561
msgid ""
"Create a subprocess from *cmd*, which can be a :class:`str` or a :class:"
"`bytes` string encoded to the :ref:`filesystem encoding <filesystem-"
"encoding>`, using the platform's \"shell\" syntax."
msgstr ""
"Cria um subprocesso a partir de *cmd*, que pode ser uma :class:`str` ou uma "
"string :class:`bytes` codificada para a :ref:`codificação do sistema de "
"ficheiros <filesystem-encoding>`, utilizando a sintaxe \"shell\" da "
"plataforma."

#: ../../library/asyncio-eventloop.rst:1566
msgid ""
"This is similar to the standard library :class:`subprocess.Popen` class "
"called with ``shell=True``."
msgstr ""
"Isto é semelhante à classe :class:`subprocess.Popen` da biblioteca padrão "
"chamada com ``shell=True``."

#: ../../library/asyncio-eventloop.rst:1569
msgid ""
"The *protocol_factory* must be a callable returning a subclass of the :class:"
"`SubprocessProtocol` class."
msgstr ""
"*protocol_factory* deve ser um objeto invocável que devolva uma subclasse da "
"classe :class:`SubprocessProtocol`."

#: ../../library/asyncio-eventloop.rst:1572
msgid ""
"See :meth:`~loop.subprocess_exec` for more details about the remaining "
"arguments."
msgstr ""
"Consulte :meth:`~loop.subprocess_exec` para mais detalhes sobre os "
"argumentos restantes."

#: ../../library/asyncio-eventloop.rst:1575
msgid ""
"Returns a pair of ``(transport, protocol)``, where *transport* conforms to "
"the :class:`SubprocessTransport` base class and *protocol* is an object "
"instantiated by the *protocol_factory*."
msgstr ""
"Devolve um par ``(transport, protocol)``, onde *transporte* está em "
"conformidade com a classe base :class:`SubprocessTransport` e *protocolo* é "
"um objeto instanciado por *protocol_factory*."

#: ../../library/asyncio-eventloop.rst:1580
msgid ""
"It is the application's responsibility to ensure that all whitespace and "
"special characters are quoted appropriately to avoid `shell injection "
"<https://en.wikipedia.org/wiki/Shell_injection#Shell_injection>`_ "
"vulnerabilities. The :func:`shlex.quote` function can be used to properly "
"escape whitespace and special characters in strings that are going to be "
"used to construct shell commands."
msgstr ""
"É responsabilidade da aplicação garantir que todos os espaços em branco e "
"caracteres especiais sejam devidamente protegidos para evitar "
"vulnerabilidades de `injeção de shell <https://en.wikipedia.org/wiki/"
"Shell_injection#Shell_injection>`_. A função :func:`shlex.quote` pode ser "
"utilizada para escapar corretamente espaços em branco e caracteres especiais "
"em strings que serão utilizadas para construir comandos shell."

#: ../../library/asyncio-eventloop.rst:1589
msgid "Callback Handles"
msgstr "Manipuladores de Chamadas de Retorno"

#: ../../library/asyncio-eventloop.rst:1593
msgid ""
"A callback wrapper object returned by :meth:`loop.call_soon`, :meth:`loop."
"call_soon_threadsafe`."
msgstr ""
"Um objeto encapsulador de chamada de retorno devolvido por :meth:`loop."
"call_soon`, :meth:`loop.call_soon_threadsafe`."

#: ../../library/asyncio-eventloop.rst:1598
msgid ""
"Return the :class:`contextvars.Context` object associated with the handle."
msgstr ""
"Devolve o objeto :class:`contextvars.Context` associado ao manipulador."

#: ../../library/asyncio-eventloop.rst:1605
msgid ""
"Cancel the callback.  If the callback has already been canceled or executed, "
"this method has no effect."
msgstr ""
"Cancela a chamada de retorno. Se a chamada de retorno já tiver sido "
"cancelada ou executada, este método não tem efeito."

#: ../../library/asyncio-eventloop.rst:1610
msgid "Return ``True`` if the callback was cancelled."
msgstr "Devolve ``True`` se a chamada de retorno foi cancelada."

#: ../../library/asyncio-eventloop.rst:1616
msgid ""
"A callback wrapper object returned by :meth:`loop.call_later`, and :meth:"
"`loop.call_at`."
msgstr ""
"Um objeto encapsulador de chamada de retorno devolvido por :meth:`loop."
"call_later` e :meth:`loop.call_at`."

#: ../../library/asyncio-eventloop.rst:1619
msgid "This class is a subclass of :class:`Handle`."
msgstr "Esta classe é uma subclasse de :class:`Handle`."

#: ../../library/asyncio-eventloop.rst:1623
msgid "Return a scheduled callback time as :class:`float` seconds."
msgstr ""
"Devolve o tempo agendado da chamada de retorno em segundos :class:`float`."

#: ../../library/asyncio-eventloop.rst:1625
msgid ""
"The time is an absolute timestamp, using the same time reference as :meth:"
"`loop.time`."
msgstr ""
"O tempo é um carimbo de tempo absoluto, utilizando a mesma referência "
"temporal que :meth:`loop.time`."

#: ../../library/asyncio-eventloop.rst:1632
msgid "Server Objects"
msgstr "Objetos de Servidor"

#: ../../library/asyncio-eventloop.rst:1634
msgid ""
"Server objects are created by :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :func:`start_server`, and :func:`start_unix_server` "
"functions."
msgstr ""
"Os objetos de servidor são criados pelas funções :meth:`loop."
"create_server`, :meth:`loop.create_unix_server`, :func:`start_server` e :"
"func:`start_unix_server`."

#: ../../library/asyncio-eventloop.rst:1638
msgid "Do not instantiate the :class:`Server` class directly."
msgstr "Não instancie diretamente a classe :class:`Server`."

#: ../../library/asyncio-eventloop.rst:1642
msgid ""
"*Server* objects are asynchronous context managers.  When used in an ``async "
"with`` statement, it's guaranteed that the Server object is closed and not "
"accepting new connections when the ``async with`` statement is completed::"
msgstr ""
"Os objetos *Server* são gestores de contexto assíncronos. Quando utilizados "
"numa instrução ``async with``, é garantido que o objeto Server está fechado "
"e não aceita novas ligações quando a instrução ``async with`` é concluída::"

#: ../../library/asyncio-eventloop.rst:1647
msgid ""
"srv = await loop.create_server(...)\n"
"\n"
"async with srv:\n"
"    # some code\n"
"\n"
"# At this point, srv is closed and no longer accepts new connections."
msgstr ""
"srv = await loop.create_server(...)\n"
"\n"
"async with srv:\n"
"    # algum código\n"
"\n"
"# Neste ponto, srv está fechado e já não aceita novas ligações."

#: ../../library/asyncio-eventloop.rst:1655
msgid "Server object is an asynchronous context manager since Python 3.7."
msgstr "O objeto Server é um gestor de contexto assíncrono desde o Python 3.7."

#: ../../library/asyncio-eventloop.rst:1658
msgid ""
"This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, "
"3.10.3 and 3.11."
msgstr ""
"Esta classe foi exposta publicamente como ``asyncio.Server`` no Python "
"3.9.11, 3.10.3 e 3.11."

#: ../../library/asyncio-eventloop.rst:1663
msgid ""
"Stop serving: close listening sockets and set the :attr:`sockets` attribute "
"to ``None``."
msgstr ""
"Para de servir: fecha os sockets à escuta e define o atributo :attr:"
"`sockets` para ``None``."

#: ../../library/asyncio-eventloop.rst:1666
msgid ""
"The sockets that represent existing incoming client connections are left "
"open."
msgstr ""
"Os sockets que representam ligações de clientes existentes permanecem "
"abertos."

#: ../../library/asyncio-eventloop.rst:1669
msgid ""
"The server is closed asynchronously; use the :meth:`wait_closed` coroutine "
"to wait until the server is closed (and no more connections are active)."
msgstr ""
"O servidor é fechado de forma assíncrona; utilize a corrotina :meth:"
"`wait_closed` para aguardar até que o servidor esteja fechado (e não haja "
"mais ligações ativas)."

#: ../../library/asyncio-eventloop.rst:1675
msgid "Return the event loop associated with the server object."
msgstr "Devolve o ciclo de eventos associado ao objeto servidor."

#: ../../library/asyncio-eventloop.rst:1682
msgid "Start accepting connections."
msgstr "Começa a aceitar ligações."

#: ../../library/asyncio-eventloop.rst:1684
msgid ""
"This method is idempotent, so it can be called when the server is already "
"serving."
msgstr ""
"Este método é idempotente, pelo que pode ser chamado quando o servidor já "
"está a servir."

#: ../../library/asyncio-eventloop.rst:1687
msgid ""
"The *start_serving* keyword-only parameter to :meth:`loop.create_server` "
"and :meth:`asyncio.start_server` allows creating a Server object that is not "
"accepting connections initially.  In this case ``Server.start_serving()``, "
"or :meth:`Server.serve_forever` can be used to make the Server start "
"accepting connections."
msgstr ""
"O parâmetro apenas por palavra-chave *start_serving* para :meth:`loop."
"create_server` e :meth:`asyncio.start_server` permite criar um objeto Server "
"que não aceita ligações inicialmente. Neste caso, ``Server.start_serving()`` "
"ou :meth:`Server.serve_forever` podem ser utilizados para fazer com que o "
"servidor comece a aceitar ligações."

#: ../../library/asyncio-eventloop.rst:1699
msgid ""
"Start accepting connections until the coroutine is cancelled. Cancellation "
"of ``serve_forever`` task causes the server to be closed."
msgstr ""
"Começa a aceitar ligações até que a corrotina seja cancelada. O cancelamento "
"da tarefa ``serve_forever`` faz com que o servidor seja fechado."

#: ../../library/asyncio-eventloop.rst:1703
msgid ""
"This method can be called if the server is already accepting connections.  "
"Only one ``serve_forever`` task can exist per one *Server* object."
msgstr ""
"Este método pode ser chamado se o servidor já estiver a aceitar ligações. Só "
"pode existir uma tarefa ``serve_forever`` por objeto *Server*."

#: ../../library/asyncio-eventloop.rst:1709
msgid ""
"async def client_connected(reader, writer):\n"
"    # Communicate with the client with\n"
"    # reader/writer streams.  For example:\n"
"    await reader.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"
msgstr ""
"async def client_connected(reader, writer):\n"
"    # Comunicar com o cliente usando\n"
"    # fluxos reader/writer. Por exemplo:\n"
"    await reader.readline()\n"
"\n"
"async def main(host, port):\n"
"    srv = await asyncio.start_server(\n"
"        client_connected, host, port)\n"
"    await srv.serve_forever()\n"
"\n"
"asyncio.run(main('127.0.0.1', 0))"

#: ../../library/asyncio-eventloop.rst:1725
msgid "Return ``True`` if the server is accepting new connections."
msgstr "Devolve ``True`` se o servidor estiver a aceitar novas ligações."

#: ../../library/asyncio-eventloop.rst:1732
msgid ""
"Wait until the :meth:`close` method completes and all active connections "
"have finished."
msgstr ""
"Aguarda até que o método :meth:`close` seja concluído e todas as ligações "
"ativas tenham terminado."

#: ../../library/asyncio-eventloop.rst:1737
msgid ""
"List of socket-like objects, ``asyncio.trsock.TransportSocket``, which the "
"server is listening on."
msgstr ""
"Lista de objetos tipo socket, ``asyncio.trsock.TransportSocket``, nos quais "
"o servidor está à escuta."

#: ../../library/asyncio-eventloop.rst:1740
msgid ""
"Prior to Python 3.7 ``Server.sockets`` used to return an internal list of "
"server sockets directly.  In 3.7 a copy of that list is returned."
msgstr ""
"Antes do Python 3.7, ``Server.sockets`` devolvia diretamente uma lista "
"interna de sockets do servidor. A partir do 3.7, é devolvida uma cópia dessa "
"lista."

#: ../../library/asyncio-eventloop.rst:1750
msgid "Event Loop Implementations"
msgstr "Implementações do Ciclo de Eventos"

#: ../../library/asyncio-eventloop.rst:1752
msgid ""
"asyncio ships with two different event loop implementations: :class:"
"`SelectorEventLoop` and :class:`ProactorEventLoop`."
msgstr ""
"O asyncio inclui duas implementações diferentes de ciclo de eventos: :class:"
"`SelectorEventLoop` e :class:`ProactorEventLoop`."

#: ../../library/asyncio-eventloop.rst:1755
msgid ""
"By default asyncio is configured to use :class:`SelectorEventLoop` on Unix "
"and :class:`ProactorEventLoop` on Windows."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1761
msgid "An event loop based on the :mod:`selectors` module."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1763
msgid ""
"Uses the most efficient *selector* available for the given platform.  It is "
"also possible to manually configure the exact selector implementation to be "
"used::"
msgstr ""
"Utiliza o *selector* mais eficiente disponível para a plataforma dada. "
"Também é possível configurar manualmente a implementação exata do selector a "
"ser utilizada::"

#: ../../library/asyncio-eventloop.rst:1767
msgid ""
"import asyncio\n"
"import selectors\n"
"\n"
"class MyPolicy(asyncio.DefaultEventLoopPolicy):\n"
"   def new_event_loop(self):\n"
"      selector = selectors.SelectSelector()\n"
"      return asyncio.SelectorEventLoop(selector)\n"
"\n"
"asyncio.set_event_loop_policy(MyPolicy())"
msgstr ""

#: ../../library/asyncio-eventloop.rst:1783
msgid "An event loop for Windows that uses \"I/O Completion Ports\" (IOCP)."
msgstr ""

#: ../../library/asyncio-eventloop.rst:1789
msgid ""
"`MSDN documentation on I/O Completion Ports <https://learn.microsoft.com/"
"windows/win32/fileio/i-o-completion-ports>`_."
msgstr ""
"`Documentação MSDN sobre Portas de Conclusão de E/S <https://learn.microsoft."
"com/windows/win32/fileio/i-o-completion-ports>`_._"

#: ../../library/asyncio-eventloop.rst:1795
msgid "Abstract base class for asyncio-compliant event loops."
msgstr "Classe base abstrata para ciclos de eventos compatíveis com asyncio."

#: ../../library/asyncio-eventloop.rst:1797
msgid ""
"The :ref:`asyncio-event-loop-methods` section lists all methods that an "
"alternative implementation of ``AbstractEventLoop`` should have defined."
msgstr ""
"A secção :ref:`asyncio-event-loop-methods` lista todos os métodos que uma "
"implementação alternativa de ``AbstractEventLoop`` deve ter definido."

#: ../../library/asyncio-eventloop.rst:1803
msgid "Examples"
msgstr "Exemplos"

#: ../../library/asyncio-eventloop.rst:1805
msgid ""
"Note that all examples in this section **purposefully** show how to use the "
"low-level event loop APIs, such as :meth:`loop.run_forever` and :meth:`loop."
"call_soon`.  Modern asyncio applications rarely need to be written this way; "
"consider using the high-level functions like :func:`asyncio.run`."
msgstr ""
"Note que todos os exemplos nesta secção mostram **intencionalmente** como "
"utilizar as APIs de baixo nível do ciclo de eventos, como :meth:`loop."
"run_forever` e :meth:`loop.call_soon`. As aplicações modernas asyncio "
"raramente precisam de ser escritas desta forma; considere utilizar funções "
"de alto nível como :func:`asyncio.run`."

#: ../../library/asyncio-eventloop.rst:1815
msgid "Hello World with call_soon()"
msgstr "Olá Mundo com call_soon()"

#: ../../library/asyncio-eventloop.rst:1817
msgid ""
"An example using the :meth:`loop.call_soon` method to schedule a callback. "
"The callback displays ``\"Hello World\"`` and then stops the event loop::"
msgstr ""
"Um exemplo que utiliza o método :meth:`loop.call_soon` para agendar uma "
"chamada de retorno. A chamada de retorno mostra ``\"Hello World\"`` e depois "
"para o ciclo de eventos::"

#: ../../library/asyncio-eventloop.rst:1821
msgid ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\"\n"
"    print('Hello World')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule a call to hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"\n"
"def hello_world(loop):\n"
"    \"\"\"Uma chamada de retorno para imprimir 'Olá Mundo' e parar o ciclo "
"de eventos\"\"\"\n"
"    print('Olá Mundo')\n"
"    loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Agendar uma chamada para hello_world()\n"
"loop.call_soon(hello_world, loop)\n"
"\n"
"# Chamada bloqueante interrompida por loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:1841
msgid ""
"A similar :ref:`Hello World <coroutine>` example created with a coroutine "
"and the :func:`run` function."
msgstr ""
"Um exemplo semelhante de :ref:`Olá Mundo <coroutine>` criado com uma "
"corrotina e a função :func:`run`."

#: ../../library/asyncio-eventloop.rst:1848
msgid "Display the current date with call_later()"
msgstr "Mostrar a data atual com call_later()"

#: ../../library/asyncio-eventloop.rst:1850
msgid ""
"An example of a callback displaying the current date every second. The "
"callback uses the :meth:`loop.call_later` method to reschedule itself after "
"5 seconds, and then stops the event loop::"
msgstr ""
"Um exemplo de uma chamada de retorno que mostra a data atual a cada segundo. "
"A chamada de retorno utiliza o método :meth:`loop.call_later` para se "
"reagendar após 5 segundos e depois para o ciclo de eventos::"

#: ../../library/asyncio-eventloop.rst:1854
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(end_time, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    else:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Schedule the first call to display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Blocking call interrupted by loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"def display_date(end_time, loop):\n"
"    print(datetime.datetime.now())\n"
"    if (loop.time() + 1.0) < end_time:\n"
"        loop.call_later(1, display_date, end_time, loop)\n"
"    else:\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"# Agendar a primeira chamada para display_date()\n"
"end_time = loop.time() + 5.0\n"
"loop.call_soon(display_date, end_time, loop)\n"
"\n"
"# Chamada bloqueante interrompida por loop.stop()\n"
"try:\n"
"    loop.run_forever()\n"
"finally:\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:1878
msgid ""
"A similar :ref:`current date <asyncio_example_sleep>` example created with a "
"coroutine and the :func:`run` function."
msgstr ""
"Um exemplo semelhante de :ref:`data atual <asyncio_example_sleep>` criado "
"com uma corrotina e a função :func:`run`."

#: ../../library/asyncio-eventloop.rst:1885
msgid "Watch a file descriptor for read events"
msgstr "Observar um descritor de ficheiro para eventos de leitura"

#: ../../library/asyncio-eventloop.rst:1887
msgid ""
"Wait until a file descriptor received some data using the :meth:`loop."
"add_reader` method and then close the event loop::"
msgstr ""
"Aguarda até que um descritor de ficheiro receba alguns dados utilizando o "
"método :meth:`loop.add_reader` e depois fecha o ciclo de eventos::"

#: ../../library/asyncio-eventloop.rst:1890
msgid ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Create a pair of connected file descriptors\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Received:\", data.decode())\n"
"\n"
"    # We are done: unregister the file descriptor\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Stop the event loop\n"
"    loop.stop()\n"
"\n"
"# Register the file descriptor for read event\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Run the event loop\n"
"    loop.run_forever()\n"
"finally:\n"
"    # We are done. Close sockets and the event loop.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"
msgstr ""
"import asyncio\n"
"from socket import socketpair\n"
"\n"
"# Criar um par de descritores de ficheiro ligados\n"
"rsock, wsock = socketpair()\n"
"\n"
"loop = asyncio.new_event_loop()\n"
"\n"
"def reader():\n"
"    data = rsock.recv(100)\n"
"    print(\"Recebido:\", data.decode())\n"
"\n"
"    # Terminámos: remover o registo do descritor de ficheiro\n"
"    loop.remove_reader(rsock)\n"
"\n"
"    # Parar o ciclo de eventos\n"
"    loop.stop()\n"
"\n"
"# Registar o descritor de ficheiro para evento de leitura\n"
"loop.add_reader(rsock, reader)\n"
"\n"
"# Simular a receção de dados da rede\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"try:\n"
"    # Executar o ciclo de eventos\n"
"    loop.run_forever()\n"
"finally:\n"
"    # Terminámos. Fechar sockets e o ciclo de eventos.\n"
"    rsock.close()\n"
"    wsock.close()\n"
"    loop.close()"

#: ../../library/asyncio-eventloop.rst:1925
msgid ""
"A similar :ref:`example <asyncio_example_create_connection>` using "
"transports, protocols, and the :meth:`loop.create_connection` method."
msgstr ""
"Um :ref:`example <asyncio_example_create_connection>` semelhante que utiliza "
"transportes, protocolos e o método :meth:`loop.create_connection`."

#: ../../library/asyncio-eventloop.rst:1929
msgid ""
"Another similar :ref:`example <asyncio_example_create_connection-streams>` "
"using the high-level :func:`asyncio.open_connection` function and streams."
msgstr ""
"Outro :ref:`example <asyncio_example_create_connection-streams>` semelhante "
"que utiliza a função de alto nível :func:`asyncio.open_connection` e fluxos."

#: ../../library/asyncio-eventloop.rst:1937
msgid "Set signal handlers for SIGINT and SIGTERM"
msgstr "Definir manipuladores de sinais para SIGINT e SIGTERM"

#: ../../library/asyncio-eventloop.rst:1939
msgid "(This ``signals`` example only works on Unix.)"
msgstr "(Este exemplo de ``signals`` só funciona em Unix.)"

#: ../../library/asyncio-eventloop.rst:1941
msgid ""
"Register handlers for signals :const:`~signal.SIGINT` and :const:`~signal."
"SIGTERM` using the :meth:`loop.add_signal_handler` method::"
msgstr ""
"Registar manipuladores para os sinais :const:`~signal.SIGINT` e :const:"
"`~signal.SIGTERM` utilizando o método :meth:`loop.add_signal_handler`::"

#: ../../library/asyncio-eventloop.rst:1944
msgid ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"got signal %s: exit\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Event loop running for 1 hour, press Ctrl+C to interrupt.\")\n"
"print(f\"pid {os.getpid()}: send SIGINT or SIGTERM to exit.\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import functools\n"
"import os\n"
"import signal\n"
"\n"
"def ask_exit(signame, loop):\n"
"    print(\"recebeu sinal %s: sair\" % signame)\n"
"    loop.stop()\n"
"\n"
"async def main():\n"
"    loop = asyncio.get_running_loop()\n"
"\n"
"    for signame in {'SIGINT', 'SIGTERM'}:\n"
"        loop.add_signal_handler(\n"
"            getattr(signal, signame),\n"
"            functools.partial(ask_exit, signame, loop))\n"
"\n"
"    await asyncio.sleep(3600)\n"
"\n"
"print(\"Ciclo de eventos a executar durante 1 hora, prima Ctrl+C para "
"interromper.\")\n"
"print(f\"pid {os.getpid()}: envie SIGINT ou SIGTERM para sair.\")\n"
"\n"
"asyncio.run(main())"
