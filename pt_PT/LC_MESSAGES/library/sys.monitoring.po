# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-03 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/sys.monitoring.rst:2
msgid ":mod:`!sys.monitoring` --- Execution event monitoring"
msgstr ":mod:`!sys.monitoring` --- Monitorização de eventos de execução"

#: ../../library/sys.monitoring.rst:13
msgid ""
":mod:`sys.monitoring` is a namespace within the :mod:`sys` module, not an "
"independent module, so there is no need to ``import sys.monitoring``, simply "
"``import sys`` and then use ``sys.monitoring``."
msgstr ""
":mod:`sys.monitoring` é um *namespace* dentro do módulo :mod:`sys`, não um "
"módulo independente, pelo que não é necessário fazer ``import sys."
"monitoring``; basta fazer ``import sys`` e depois usar ``sys.monitoring``."

#: ../../library/sys.monitoring.rst:19
msgid ""
"This namespace provides access to the functions and constants necessary to "
"activate and control event monitoring."
msgstr ""
"Este *namespace* fornece acesso às funções e constantes necessárias para "
"ativar e controlar a monitorização de eventos."

#: ../../library/sys.monitoring.rst:22
msgid ""
"As programs execute, events occur that might be of interest to tools that "
"monitor execution. The :mod:`sys.monitoring` namespace provides means to "
"receive callbacks when events of interest occur."
msgstr ""
"À medida que os programas são executados, ocorrem eventos que podem ser de "
"interesse para ferramentas que monitorizam a execução. O *namespace* :mod:"
"`sys.monitoring` fornece meios para receber *callbacks* quando ocorrem "
"eventos de interesse."

#: ../../library/sys.monitoring.rst:26
msgid "The monitoring API consists of three components:"
msgstr "A API de monitorização consiste em três componentes:"

#: ../../library/sys.monitoring.rst:28
msgid "`Tool identifiers`_"
msgstr "`Identificadores de ferramentas`_"

#: ../../library/sys.monitoring.rst:29
msgid "`Events`_"
msgstr "`Events`_"

#: ../../library/sys.monitoring.rst:30
msgid ":ref:`Callbacks <callbacks>`"
msgstr ":ref:`*Callbacks* <callbacks>`"

#: ../../library/sys.monitoring.rst:33
msgid "Tool identifiers"
msgstr "Identificadores de ferramentas"

#: ../../library/sys.monitoring.rst:35
msgid ""
"A tool identifier is an integer and the associated name. Tool identifiers "
"are used to discourage tools from interfering with each other and to allow "
"multiple tools to operate at the same time. Currently tools are completely "
"independent and cannot be used to monitor each other. This restriction may "
"be lifted in the future."
msgstr ""
"Um identificador de ferramenta é um inteiro e o nome associado. Os "
"identificadores de ferramentas são usados para evitar que as ferramentas "
"interfiram umas com as outras e para permitir que várias ferramentas operem "
"ao mesmo tempo. Atualmente, as ferramentas são completamente independentes e "
"não podem ser usadas para monitorizar umas às outras. Esta restrição pode "
"ser removida no futuro."

#: ../../library/sys.monitoring.rst:41
msgid ""
"Before registering or activating events, a tool should choose an identifier. "
"Identifiers are integers in the range 0 to 5 inclusive."
msgstr ""
"Antes de registar ou ativar eventos, uma ferramenta deve escolher um "
"identificador. Os identificadores são inteiros no intervalo de 0 a 5, "
"inclusive."

#: ../../library/sys.monitoring.rst:45
msgid "Registering and using tools"
msgstr "Registo e utilização de ferramentas"

#: ../../library/sys.monitoring.rst:49
msgid ""
"Must be called before *tool_id* can be used. *tool_id* must be in the range "
"0 to 5 inclusive. Raises a :exc:`ValueError` if *tool_id* is in use."
msgstr ""
"Deve ser chamada antes de *tool_id* poder ser usado. *tool_id* deve estar no "
"intervalo de 0 a 5, inclusive. Gera um :exc:`ValueError` se *tool_id* já "
"estiver em uso."

#: ../../library/sys.monitoring.rst:55
msgid "Unregister all events and callback functions associated with *tool_id*."
msgstr ""
"Remove o registo de todos os eventos e funções de *callback* associados a "
"*tool_id*."

#: ../../library/sys.monitoring.rst:59
msgid ""
"Should be called once a tool no longer requires *tool_id*. Will call :func:"
"`clear_tool_id` before releasing *tool_id*."
msgstr ""
"Deve ser chamada quando uma ferramenta já não necessitar de *tool_id*. "
"Chama :func:`clear_tool_id` antes de libertar *tool_id*."

#: ../../library/sys.monitoring.rst:64
msgid ""
"Returns the name of the tool if *tool_id* is in use, otherwise it returns "
"``None``. *tool_id* must be in the range 0 to 5 inclusive."
msgstr ""
"Devolve o nome da ferramenta se *tool_id* estiver em uso; caso contrário, "
"devolve ``None``. *tool_id* deve estar no intervalo de 0 a 5, inclusive."

#: ../../library/sys.monitoring.rst:68
msgid ""
"All IDs are treated the same by the VM with regard to events, but the "
"following IDs are pre-defined to make co-operation of tools easier::"
msgstr ""
"Todos os IDs são tratados da mesma forma pela VM em relação a eventos, mas "
"os seguintes IDs estão pré-definidos para facilitar a cooperação entre "
"ferramentas::"

#: ../../library/sys.monitoring.rst:71
msgid ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.monitoring.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"
msgstr ""
"sys.monitoring.DEBUGGER_ID = 0\n"
"sys.monitoring.COVERAGE_ID = 1\n"
"sys.monitoring.PROFILER_ID = 2\n"
"sys.monitoring.OPTIMIZER_ID = 5"

#: ../../library/sys.monitoring.rst:78
msgid "Events"
msgstr "Eventos"

#: ../../library/sys.monitoring.rst:80
msgid "The following events are supported:"
msgstr "Os seguintes eventos são suportados:"

#: ../../library/sys.monitoring.rst:84
msgid "A conditional branch goes left."
msgstr "Um ramo condicional segue para a esquerda."

#: ../../library/sys.monitoring.rst:86
msgid ""
"It is up to the tool to determine how to present \"left\" and \"right\" "
"branches. There is no guarantee which branch is \"left\" and which is "
"\"right\", except that it will be consistent for the duration of the program."
msgstr ""
"Cabe à ferramenta determinar como apresentar os ramos \"esquerda\" e "
"\"direita\". Não há garantia de qual ramo é \"esquerda\" e qual é "
"\"direita\", exceto que será consistente durante a execução do programa."

#: ../../library/sys.monitoring.rst:92
msgid "A conditional branch goes right."
msgstr "Um ramo condicional segue para a direita."

#: ../../library/sys.monitoring.rst:96
msgid "A call in Python code (event occurs before the call)."
msgstr "Uma chamada em código Python (o evento ocorre antes da chamada)."

#: ../../library/sys.monitoring.rst:100
msgid ""
"An exception raised from any callable, except for Python functions (event "
"occurs after the exit)."
msgstr ""
"Uma exceção gerada a partir de qualquer objeto chamável, exceto funções "
"Python (o evento ocorre após a saída)."

#: ../../library/sys.monitoring.rst:104
msgid ""
"Return from any callable, except for Python functions (event occurs after "
"the return)."
msgstr ""
"Retorno de qualquer objeto chamável, exceto funções Python (o evento ocorre "
"após o retorno)."

#: ../../library/sys.monitoring.rst:108
msgid "An exception is handled."
msgstr "Uma exceção é tratada."

#: ../../library/sys.monitoring.rst:112
msgid "A VM instruction is about to be executed."
msgstr "Uma instrução da VM está prestes a ser executada."

#: ../../library/sys.monitoring.rst:116
msgid "An unconditional jump in the control flow graph is made."
msgstr "É feito um salto incondicional no grafo de fluxo de controlo."

#: ../../library/sys.monitoring.rst:120
msgid ""
"An instruction is about to be executed that has a different line number from "
"the preceding instruction."
msgstr ""
"Uma instrução está prestes a ser executada que tem um número de linha "
"diferente da instrução anterior."

#: ../../library/sys.monitoring.rst:124
msgid ""
"Resumption of a Python function (for generator and coroutine functions), "
"except for ``throw()`` calls."
msgstr ""
"Retoma de uma função Python (para funções geradoras e *coroutines*), exceto "
"para chamadas ``throw()``."

#: ../../library/sys.monitoring.rst:128
msgid ""
"Return from a Python function (occurs immediately before the return, the "
"callee's frame will be on the stack)."
msgstr ""
"Retorno de uma função Python (ocorre imediatamente antes do retorno, o "
"*frame* da função chamada estará na pilha)."

#: ../../library/sys.monitoring.rst:132
msgid ""
"Start of a Python function (occurs immediately after the call, the callee's "
"frame will be on the stack)"
msgstr ""
"Início de uma função Python (ocorre imediatamente após a chamada, o *frame* "
"da função chamada estará na pilha)."

#: ../../library/sys.monitoring.rst:136
msgid "A Python function is resumed by a ``throw()`` call."
msgstr "Uma função Python é retomada por uma chamada ``throw()``."

#: ../../library/sys.monitoring.rst:140
msgid ""
"Exit from a Python function during exception unwinding. This includes "
"exceptions raised directly within the function and that are allowed to "
"continue to propagate."
msgstr ""
"Saída de uma função Python durante o desenrolar de exceções. Isto inclui "
"exceções geradas diretamente dentro da função e que são permitidas continuar "
"a propagar-se."

#: ../../library/sys.monitoring.rst:145
msgid ""
"Yield from a Python function (occurs immediately before the yield, the "
"callee's frame will be on the stack)."
msgstr ""
"*Yield* de uma função Python (ocorre imediatamente antes do *yield*, o "
"*frame* da função chamada estará na pilha)."

#: ../../library/sys.monitoring.rst:149
msgid ""
"An exception is raised, except those that cause a :monitoring-event:"
"`STOP_ITERATION` event."
msgstr ""
"Uma exceção é gerada, exceto aquelas que causam um evento :monitoring-event:"
"`STOP_ITERATION`."

#: ../../library/sys.monitoring.rst:153
msgid ""
"An exception is re-raised, for example at the end of a :keyword:`finally` "
"block."
msgstr ""
"Uma exceção é regerada, por exemplo, no final de um bloco :keyword:`finally`."

#: ../../library/sys.monitoring.rst:157
msgid ""
"An artificial :exc:`StopIteration` is raised; see `the STOP_ITERATION "
"event`_."
msgstr ""
"Uma :exc:`StopIteration` artificial é gerada; consulte `o evento "
"STOP_ITERATION`_."

#: ../../library/sys.monitoring.rst:160
msgid "More events may be added in the future."
msgstr "Mais eventos podem ser adicionados no futuro."

#: ../../library/sys.monitoring.rst:162
msgid ""
"These events are attributes of the :mod:`!sys.monitoring.events` namespace. "
"Each event is represented as a power-of-2 integer constant. To define a set "
"of events, simply bitwise OR the individual events together. For example, to "
"specify both :monitoring-event:`PY_RETURN` and :monitoring-event:`PY_START` "
"events, use the expression ``PY_RETURN | PY_START``."
msgstr ""
"Estes eventos são atributos do *namespace* :mod:`!sys.monitoring.events`. "
"Cada evento é representado como uma constante inteira potência de 2. Para "
"definir um conjunto de eventos, basta fazer um OR bit a bit dos eventos "
"individuais. Por exemplo, para especificar os eventos :monitoring-event:"
"`PY_RETURN` e :monitoring-event:`PY_START`, use a expressão ``PY_RETURN | "
"PY_START``."

#: ../../library/sys.monitoring.rst:170
msgid "An alias for ``0`` so users can do explicit comparisons like::"
msgstr ""
"Um alias para ``0`` para que os utilizadores possam fazer comparações "
"explícitas como::"

#: ../../library/sys.monitoring.rst:172
msgid ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."
msgstr ""
"if get_events(DEBUGGER_ID) == NO_EVENTS:\n"
"    ..."

#: ../../library/sys.monitoring.rst:175
msgid "Setting this event deactivates all events."
msgstr "Definir este evento desativa todos os eventos."

#: ../../library/sys.monitoring.rst:180
msgid "Local events"
msgstr "Eventos locais"

#: ../../library/sys.monitoring.rst:182
msgid ""
"Local events are associated with normal execution of the program and happen "
"at clearly defined locations. All local events can be disabled. The local "
"events are:"
msgstr ""
"Os eventos locais estão associados à execução normal do programa e ocorrem "
"em locais claramente definidos. Todos os eventos locais podem ser "
"desativados. Os eventos locais são:"

#: ../../library/sys.monitoring.rst:186
msgid ":monitoring-event:`PY_START`"
msgstr ":monitoring-event:`PY_START`"

#: ../../library/sys.monitoring.rst:187
msgid ":monitoring-event:`PY_RESUME`"
msgstr ":monitoring-event:`PY_RESUME`"

#: ../../library/sys.monitoring.rst:188
msgid ":monitoring-event:`PY_RETURN`"
msgstr ":monitoring-event:`PY_RETURN`"

#: ../../library/sys.monitoring.rst:189
msgid ":monitoring-event:`PY_YIELD`"
msgstr ":monitoring-event:`PY_YIELD`"

#: ../../library/sys.monitoring.rst:190
msgid ":monitoring-event:`CALL`"
msgstr ":monitoring-event:`CALL`"

#: ../../library/sys.monitoring.rst:191
msgid ":monitoring-event:`LINE`"
msgstr ":monitoring-event:`LINE`"

#: ../../library/sys.monitoring.rst:192
msgid ":monitoring-event:`INSTRUCTION`"
msgstr ":monitoring-event:`INSTRUCTION`"

#: ../../library/sys.monitoring.rst:193
msgid ":monitoring-event:`JUMP`"
msgstr ":monitoring-event:`JUMP`"

#: ../../library/sys.monitoring.rst:194
msgid ":monitoring-event:`BRANCH_LEFT`"
msgstr ":monitoring-event:`BRANCH_LEFT`"

#: ../../library/sys.monitoring.rst:195
msgid ":monitoring-event:`BRANCH_RIGHT`"
msgstr ":monitoring-event:`BRANCH_RIGHT`"

#: ../../library/sys.monitoring.rst:196
msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ":monitoring-event:`STOP_ITERATION`"

#: ../../library/sys.monitoring.rst:199
msgid "Deprecated event"
msgstr "Evento obsoleto"

#: ../../library/sys.monitoring.rst:201
msgid "``BRANCH``"
msgstr "``BRANCH``"

#: ../../library/sys.monitoring.rst:203
msgid ""
"The ``BRANCH`` event is deprecated in 3.14. Using :monitoring-event:"
"`BRANCH_LEFT` and :monitoring-event:`BRANCH_RIGHT` events will give much "
"better performance as they can be disabled independently."
msgstr ""
"O evento ``BRANCH`` está obsoleto na versão 3.14. Usar os eventos :"
"monitoring-event:`BRANCH_LEFT` e :monitoring-event:`BRANCH_RIGHT` "
"proporciona um desempenho muito melhor, uma vez que podem ser desativados "
"independentemente."

#: ../../library/sys.monitoring.rst:209
msgid "Ancillary events"
msgstr "Eventos ancilares"

#: ../../library/sys.monitoring.rst:211
msgid ""
"Ancillary events can be monitored like other events, but are controlled by "
"another event:"
msgstr ""
"Os eventos ancilares podem ser monitorizados como outros eventos, mas são "
"controlados por outro evento:"

#: ../../library/sys.monitoring.rst:214
msgid ":monitoring-event:`C_RAISE`"
msgstr ":monitoring-event:`C_RAISE`"

#: ../../library/sys.monitoring.rst:215
msgid ":monitoring-event:`C_RETURN`"
msgstr ":monitoring-event:`C_RETURN`"

#: ../../library/sys.monitoring.rst:217
msgid ""
"The :monitoring-event:`C_RETURN` and :monitoring-event:`C_RAISE` events are "
"controlled by the :monitoring-event:`CALL` event. :monitoring-event:"
"`C_RETURN` and :monitoring-event:`C_RAISE` events will only be seen if the "
"corresponding :monitoring-event:`CALL` event is being monitored."
msgstr ""
"Os eventos :monitoring-event:`C_RETURN` e :monitoring-event:`C_RAISE` são "
"controlados pelo evento :monitoring-event:`CALL`. Os eventos :monitoring-"
"event:`C_RETURN` e :monitoring-event:`C_RAISE` só serão vistos se o evento :"
"monitoring-event:`CALL` correspondente estiver a ser monitorizado."

#: ../../library/sys.monitoring.rst:226
msgid "Other events"
msgstr "Outros eventos"

#: ../../library/sys.monitoring.rst:228
msgid ""
"Other events are not necessarily tied to a specific location in the program "
"and cannot be individually disabled via :data:`DISABLE`."
msgstr ""
"Outros eventos não estão necessariamente associados a um local específico no "
"programa e não podem ser desativados individualmente através de :data:"
"`DISABLE`."

#: ../../library/sys.monitoring.rst:231
msgid "The other events that can be monitored are:"
msgstr "Os outros eventos que podem ser monitorizados são:"

#: ../../library/sys.monitoring.rst:233
msgid ":monitoring-event:`PY_THROW`"
msgstr ":monitoring-event:`PY_THROW`"

#: ../../library/sys.monitoring.rst:234
msgid ":monitoring-event:`PY_UNWIND`"
msgstr ":monitoring-event:`PY_UNWIND`"

#: ../../library/sys.monitoring.rst:235
msgid ":monitoring-event:`RAISE`"
msgstr ":monitoring-event:`RAISE`"

#: ../../library/sys.monitoring.rst:236
msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ":monitoring-event:`EXCEPTION_HANDLED`"

#: ../../library/sys.monitoring.rst:240
msgid "The STOP_ITERATION event"
msgstr "O evento STOP_ITERATION"

#: ../../library/sys.monitoring.rst:242
msgid ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` specifies that a :"
"exc:`StopIteration` exception is raised when returning a value from a "
"generator or coroutine. However, this is a very inefficient way to return a "
"value, so some Python implementations, notably CPython 3.12+, do not raise "
"an exception unless it would be visible to other code."
msgstr ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` especifica que "
"uma exceção :exc:`StopIteration` é gerada ao devolver um valor de um gerador "
"ou *coroutine*. No entanto, esta é uma forma muito ineficiente de devolver "
"um valor, pelo que algumas implementações de Python, nomeadamente CPython "
"3.12+, não geram uma exceção a menos que esta seja visível para outro código."

#: ../../library/sys.monitoring.rst:248
msgid ""
"To allow tools to monitor for real exceptions without slowing down "
"generators and coroutines, the :monitoring-event:`STOP_ITERATION` event is "
"provided. :monitoring-event:`STOP_ITERATION` can be locally disabled, "
"unlike :monitoring-event:`RAISE`."
msgstr ""
"Para permitir que as ferramentas monitorizem exceções reais sem abrandar "
"geradores e *coroutines*, é fornecido o evento :monitoring-event:"
"`STOP_ITERATION`. Ao contrário de :monitoring-event:`RAISE`, o evento :"
"monitoring-event:`STOP_ITERATION` pode ser desativado localmente."

#: ../../library/sys.monitoring.rst:253
msgid ""
"Note that the :monitoring-event:`STOP_ITERATION` event and the :monitoring-"
"event:`RAISE` event for a :exc:`StopIteration` exception are equivalent, and "
"are treated as interchangeable when generating events. Implementations will "
"favor :monitoring-event:`STOP_ITERATION` for performance reasons, but may "
"generate a :monitoring-event:`RAISE` event with a :exc:`StopIteration`."
msgstr ""
"Note que o evento :monitoring-event:`STOP_ITERATION` e o evento :monitoring-"
"event:`RAISE` para uma exceção :exc:`StopIteration` são equivalentes e são "
"tratados como intercambiáveis ao gerar eventos. As implementações "
"privilegiarão :monitoring-event:`STOP_ITERATION` por razões de desempenho, "
"mas podem gerar um evento :monitoring-event:`RAISE` com uma :exc:"
"`StopIteration`."

#: ../../library/sys.monitoring.rst:261
msgid "Turning events on and off"
msgstr "Ativar e desativar eventos"

#: ../../library/sys.monitoring.rst:263
msgid ""
"In order to monitor an event, it must be turned on and a corresponding "
"callback must be registered. Events can be turned on or off by setting the "
"events either globally and/or for a particular code object. An event will "
"trigger only once, even if it is turned on both globally and locally."
msgstr ""
"Para monitorizar um evento, este deve ser ativado e deve ser registado um "
"*callback* correspondente. Os eventos podem ser ativados ou desativados "
"definindo-os globalmente e/ou para um objeto de código específico. Um evento "
"será acionado apenas uma vez, mesmo que esteja ativado globalmente e "
"localmente."

#: ../../library/sys.monitoring.rst:270
msgid "Setting events globally"
msgstr "Definir eventos globalmente"

#: ../../library/sys.monitoring.rst:272
msgid ""
"Events can be controlled globally by modifying the set of events being "
"monitored."
msgstr ""
"Os eventos podem ser controlados globalmente modificando o conjunto de "
"eventos a ser monitorizado."

#: ../../library/sys.monitoring.rst:276
msgid "Returns the ``int`` representing all the active events."
msgstr "Devolve o ``int`` que representa todos os eventos ativos."

#: ../../library/sys.monitoring.rst:280
msgid ""
"Activates all events which are set in *event_set*. Raises a :exc:"
"`ValueError` if *tool_id* is not in use."
msgstr ""
"Ativa todos os eventos definidos em *event_set*. Gera um :exc:`ValueError` "
"se *tool_id* não estiver em uso."

#: ../../library/sys.monitoring.rst:283
msgid "No events are active by default."
msgstr "Por defeito, nenhum evento está ativo."

#: ../../library/sys.monitoring.rst:286
msgid "Per code object events"
msgstr "Eventos por objeto de código"

#: ../../library/sys.monitoring.rst:288
msgid ""
"Events can also be controlled on a per code object basis. The functions "
"defined below which accept a :class:`types.CodeType` should be prepared to "
"accept a look-alike object from functions which are not defined in Python "
"(see :ref:`c-api-monitoring`)."
msgstr ""
"Os eventos também podem ser controlados por objeto de código. As funções "
"definidas abaixo que aceitam um :class:`types.CodeType` devem estar "
"preparadas para aceitar um objeto semelhante de funções que não estão "
"definidas em Python (consulte :ref:`c-api-monitoring`)."

#: ../../library/sys.monitoring.rst:295
msgid "Returns all the :ref:`local events <monitoring-event-local>` for *code*"
msgstr ""
"Devolve todos os :ref:`eventos locais <monitoring-event-local>` para *code*"

#: ../../library/sys.monitoring.rst:299
msgid ""
"Activates all the :ref:`local events <monitoring-event-local>` for *code* "
"which are set in *event_set*. Raises a :exc:`ValueError` if *tool_id* is not "
"in use."
msgstr ""
"Ativa todos os :ref:`eventos locais <monitoring-event-local>` para *code* "
"que estejam definidos em *event_set*. Gera um :exc:`ValueError` se *tool_id* "
"não estiver em uso."

#: ../../library/sys.monitoring.rst:305
msgid "Disabling events"
msgstr "Desativar eventos"

#: ../../library/sys.monitoring.rst:309
msgid ""
"A special value that can be returned from a callback function to disable "
"events for the current code location."
msgstr ""
"Um valor especial que pode ser devolvido por uma função de *callback* para "
"desativar eventos para a localização atual do código."

#: ../../library/sys.monitoring.rst:312
msgid ""
":ref:`Local events <monitoring-event-local>` can be disabled for a specific "
"code location by returning :data:`sys.monitoring.DISABLE` from a callback "
"function. This does not change which events are set, or any other code "
"locations for the same event."
msgstr ""
"Os :ref:`eventos locais <monitoring-event-local>` podem ser desativados para "
"uma localização específica de código devolvendo :data:`sys.monitoring."
"DISABLE` a partir de uma função de *callback*. Isto não altera quais eventos "
"estão definidos, nem outras localizações de código para o mesmo evento."

#: ../../library/sys.monitoring.rst:317
msgid ""
"Disabling events for specific locations is very important for high "
"performance monitoring. For example, a program can be run under a debugger "
"with no overhead if the debugger disables all monitoring except for a few "
"breakpoints."
msgstr ""
"Desativar eventos para localizações específicas é muito importante para "
"monitorização de alto desempenho. Por exemplo, um programa pode ser "
"executado num depurador sem sobrecarga se o depurador desativar toda a "
"monitorização, exceto para alguns pontos de interrupção."

#: ../../library/sys.monitoring.rst:322
msgid ""
"If :data:`DISABLE` is returned by a callback for a :ref:`global event "
"<monitoring-event-global>`, :exc:`ValueError` will be raised by the "
"interpreter in a non-specific location (that is, no traceback will be "
"provided)."
msgstr ""
"Se :data:`DISABLE` for devolvido por um *callback* para um :ref:`evento "
"global <monitoring-event-global>`, será gerado um :exc:`ValueError` pelo "
"interpretador numa localização não específica (ou seja, não será fornecido "
"um *traceback*)."

#: ../../library/sys.monitoring.rst:329
msgid ""
"Enable all the events that were disabled by :data:`sys.monitoring.DISABLE` "
"for all tools."
msgstr ""
"Ativa todos os eventos que foram desativados por :data:`sys.monitoring."
"DISABLE` para todas as ferramentas."

#: ../../library/sys.monitoring.rst:336
msgid "Registering callback functions"
msgstr "Registo de funções de *callback*"

#: ../../library/sys.monitoring.rst:340
msgid "Registers the callable *func* for the *event* with the given *tool_id*"
msgstr "Regista a função chamável *func* para o *event* com o *tool_id* dado"

#: ../../library/sys.monitoring.rst:342
msgid ""
"If another callback was registered for the given *tool_id* and *event*, it "
"is unregistered and returned. Otherwise :func:`register_callback` returns "
"``None``."
msgstr ""
"Se outro *callback* estiver registado para o *tool_id* e *event* dados, este "
"é removido do registo e devolvido. Caso contrário, :func:`register_callback` "
"devolve ``None``."

#: ../../library/sys.monitoring.rst:346
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sys.monitoring."
"register_callback`` with argument ``func``."
msgstr ""
"Gera um :ref:`evento de auditoria <auditing>` ``sys.monitoring."
"register_callback`` com o argumento ``func``."

#: ../../library/sys.monitoring.rst:348
msgid ""
"Functions can be unregistered by calling ``sys.monitoring."
"register_callback(tool_id, event, None)``."
msgstr ""
"As funções podem ser removidas do registo chamando ``sys.monitoring."
"register_callback(tool_id, event, None)``."

#: ../../library/sys.monitoring.rst:351
msgid "Callback functions can be registered and unregistered at any time."
msgstr ""
"As funções de *callback* podem ser registadas e removidas do registo a "
"qualquer momento."

#: ../../library/sys.monitoring.rst:353
msgid ""
"Callbacks are called only once regardless if the event is turned on both "
"globally and locally. As such, if an event could be turned on for both "
"global and local events by your code then the callback needs to be written "
"to handle either trigger."
msgstr ""
"Os *callbacks* são chamados apenas uma vez, independentemente de o evento "
"estar ativado globalmente e localmente. Como tal, se um evento puder ser "
"ativado tanto globalmente como localmente pelo seu código, o *callback* deve "
"ser escrito para lidar com qualquer um dos disparos."

#: ../../library/sys.monitoring.rst:360
msgid "Callback function arguments"
msgstr "Argumentos das funções de *callback*"

#: ../../library/sys.monitoring.rst:364
msgid ""
"A special value that is passed to a callback function to indicate that there "
"are no arguments to the call."
msgstr ""
"Um valor especial que é passado a uma função de *callback* para indicar que "
"não há argumentos para a chamada."

#: ../../library/sys.monitoring.rst:367
msgid ""
"When an active event occurs, the registered callback function is called. "
"Callback functions returning an object other than :data:`DISABLE` will have "
"no effect. Different events will provide the callback function with "
"different arguments, as follows:"
msgstr ""
"Quando um evento ativo ocorre, a função de *callback* registada é chamada. "
"Funções de *callback* que devolvem um objeto diferente de :data:`DISABLE` "
"não terão qualquer efeito. Diferentes eventos fornecerão à função de "
"*callback* argumentos diferentes, como se segue:"

#: ../../library/sys.monitoring.rst:371
msgid ":monitoring-event:`PY_START` and :monitoring-event:`PY_RESUME`::"
msgstr ":monitoring-event:`PY_START` e :monitoring-event:`PY_RESUME`::"

#: ../../library/sys.monitoring.rst:373 ../../library/sys.monitoring.rst:410
msgid "func(code: CodeType, instruction_offset: int) -> object"
msgstr "func(code: CodeType, instruction_offset: int) -> object"

#: ../../library/sys.monitoring.rst:375
msgid ":monitoring-event:`PY_RETURN` and :monitoring-event:`PY_YIELD`::"
msgstr ":monitoring-event:`PY_RETURN` e :monitoring-event:`PY_YIELD`::"

#: ../../library/sys.monitoring.rst:377
msgid "func(code: CodeType, instruction_offset: int, retval: object) -> object"
msgstr ""
"func(code: CodeType, instruction_offset: int, retval: object) -> object"

#: ../../library/sys.monitoring.rst:379
msgid ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` and :monitoring-event:"
"`C_RETURN` (*arg0* can be :data:`MISSING` specifically)::"
msgstr ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` e :monitoring-event:"
"`C_RETURN` (*arg0* pode ser especificamente :data:`MISSING`)::"

#: ../../library/sys.monitoring.rst:382
msgid ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"
msgstr ""
"func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object) -> object"

#: ../../library/sys.monitoring.rst:384
msgid ""
"*code* represents the code object where the call is being made, while "
"*callable* is the object that is about to be called (and thus triggered the "
"event). If there are no arguments, *arg0* is set to :data:`sys.monitoring."
"MISSING`."
msgstr ""
"*code* representa o objeto de código onde a chamada está a ser feita, "
"enquanto *callable* é o objeto que está prestes a ser chamado (e assim "
"disparou o evento). Se não houver argumentos, *arg0* é definido para :data:"
"`sys.monitoring.MISSING`."

#: ../../library/sys.monitoring.rst:389
msgid ""
"For instance methods, *callable* will be the function object as found on the "
"class with *arg0* set to the instance (i.e. the ``self`` argument to the "
"method)."
msgstr ""
"Para métodos de instância, *callable* será o objeto função encontrado na "
"classe, com *arg0* definido para a instância (ou seja, o argumento ``self`` "
"do método)."

#: ../../library/sys.monitoring.rst:393
msgid ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-event:"
"`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-event:"
"`PY_THROW` and :monitoring-event:`STOP_ITERATION`::"
msgstr ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-event:"
"`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-event:"
"`PY_THROW` e :monitoring-event:`STOP_ITERATION`::"

#: ../../library/sys.monitoring.rst:396
msgid ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"object"
msgstr ""
"func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"object"

#: ../../library/sys.monitoring.rst:398
msgid ":monitoring-event:`LINE`::"
msgstr ":monitoring-event:`LINE`::"

#: ../../library/sys.monitoring.rst:400
msgid "func(code: CodeType, line_number: int) -> object"
msgstr "func(code: CodeType, line_number: int) -> object"

#: ../../library/sys.monitoring.rst:402
msgid ""
":monitoring-event:`BRANCH_LEFT`, :monitoring-event:`BRANCH_RIGHT` and :"
"monitoring-event:`JUMP`::"
msgstr ""
":monitoring-event:`BRANCH_LEFT`, :monitoring-event:`BRANCH_RIGHT` e :"
"monitoring-event:`JUMP`::"

#: ../../library/sys.monitoring.rst:404
msgid ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"object"
msgstr ""
"func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"object"

#: ../../library/sys.monitoring.rst:406
msgid "Note that the *destination_offset* is where the code will next execute."
msgstr "Note que *destination_offset* é onde o código será executado a seguir."

#: ../../library/sys.monitoring.rst:408
msgid ":monitoring-event:`INSTRUCTION`::"
msgstr ":monitoring-event:`INSTRUCTION`::"
