# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-11 15:06+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/ssl.rst:2
msgid ":mod:`!ssl` --- TLS/SSL wrapper for socket objects"
msgstr ":mod:`!ssl` --- Envoltório TLS/SSL para objetos socket"

#: ../../library/ssl.rst:10
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr "**Código fonte:** :source:`Lib/ssl.py`"

#: ../../library/ssl.rst:18
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, macOS, "
"and probably additional platforms, as long as OpenSSL is installed on that "
"platform."
msgstr ""
"Este módulo fornece acesso à encriptação Transport Layer Security (muitas "
"vezes conhecida como \"Secure Sockets Layer\") e às facilidades de "
"autenticação de pares para sockets de rede, tanto do lado do cliente como do "
"lado do servidor. Este módulo usa a biblioteca OpenSSL. Está disponível em "
"todos os sistemas Unix modernos, Windows, macOS, e provavelmente em "
"plataformas adicionais, desde que o OpenSSL esteja instalado nessa "
"plataforma."

#: ../../library/ssl.rst:26
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior. For example, TLSv1.3 comes with OpenSSL "
"version 1.1.1."
msgstr ""
"Alguns comportamentos podem ser dependentes da plataforma, uma vez que são "
"feitas chamadas às APIs de socket do sistema operativo. A versão instalada "
"do OpenSSL também pode causar variações no comportamento. Por exemplo, o "
"TLSv1.3 está disponível com a versão 1.1.1 do OpenSSL."

#: ../../library/ssl.rst:32
msgid ""
"Don't use this module without reading the :ref:`ssl-security`.  Doing so may "
"lead to a false sense of security, as the default settings of the ssl module "
"are not necessarily appropriate for your application."
msgstr ""
"Não utilize este módulo sem ler :ref:`ssl-security`. Fazê-lo pode levar a "
"uma falsa sensação de segurança, uma vez que as configurações predefinidas "
"do módulo ssl podem não ser apropriadas para a sua aplicação."

#: ../../library/ssl.rst:455 ../../library/ssl.rst:470
#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Disponibilidade"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Este módulo não funciona ou não está disponível em WebAssembly. Consulte :"
"ref:`wasm-availability` para mais informações."

#: ../../library/ssl.rst:38
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""
"Esta secção documenta os objetos e funções no módulo ``ssl``; para "
"informações mais gerais sobre TLS, SSL e certificados, o leitor é remetido "
"para os documentos na secção \"Veja Também\" no final."

#: ../../library/ssl.rst:42
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, :meth:`cipher`, which "
"retrieves the cipher being used for the secure connection or :meth:"
"`get_verified_chain`, :meth:`get_unverified_chain` which retrieves "
"certificate chain."
msgstr ""
"Este módulo fornece uma classe, :class:`ssl.SSLSocket`, que é derivada do "
"tipo :class:`socket.socket`, e fornece um envoltório semelhante a um socket "
"que também encripta e desencripta os dados que passam pelo socket com SSL. "
"Suporta métodos adicionais como :meth:`getpeercert`, que recupera o "
"certificado do outro lado da ligação, :meth:`cipher`, que recupera a cifra "
"usada para a ligação segura, ou :meth:`get_verified_chain`, :meth:"
"`get_unverified_chain` que recupera a cadeia de certificados."

#: ../../library/ssl.rst:51
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""
"Para aplicações mais sofisticadas, a classe :class:`ssl.SSLContext` ajuda a "
"gerir configurações e certificados, que podem então ser herdados por sockets "
"SSL criados através do método :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:55
msgid "Updated to support linking with OpenSSL 1.1.0"
msgstr "Atualizado para suportar ligação com OpenSSL 1.1.0"

#: ../../library/ssl.rst:60
msgid ""
"OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported. In "
"the future the ssl module will require at least OpenSSL 1.0.2 or 1.1.0."
msgstr ""
"OpenSSL 0.9.8, 1.0.0 e 1.0.1 estão obsoleto e já não são suportados. No "
"futuro, o módulo ssl irá requerer pelo menos OpenSSL 1.0.2 ou 1.1.0."

#: ../../library/ssl.rst:66
msgid ""
":pep:`644` has been implemented. The ssl module requires OpenSSL 1.1.1 or "
"newer."
msgstr ""
":pep:`644` foi implementado. O módulo ssl requer OpenSSL 1.1.1 ou mais "
"recente."

#: ../../library/ssl.rst:69
msgid ""
"Use of deprecated constants and functions result in deprecation warnings."
msgstr ""
"O uso de constantes e funções obsoletas resulta em avisos de obsolescência."

#: ../../library/ssl.rst:73
msgid "Functions, Constants, and Exceptions"
msgstr "Funções, constantes e exceções"

#: ../../library/ssl.rst:77
msgid "Socket creation"
msgstr "Criação de socket"

#: ../../library/ssl.rst:79
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method. The helper function :func:`create_default_context` "
"returns a new context with secure default settings."
msgstr ""
"Instâncias de :class:`SSLSocket` devem ser criadas usando o método :meth:"
"`SSLContext.wrap_socket`. A função auxiliar :func:`create_default_context` "
"retorna um novo contexto com configurações seguras predefinidas."

#: ../../library/ssl.rst:84
msgid "Client socket example with default context and IPv4/IPv6 dual stack::"
msgstr ""
"Exemplo de socket cliente com contexto predefinido e pilha dupla IPv4/IPv6::"

#: ../../library/ssl.rst:86
msgid ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""
"import socket\n"
"import ssl\n"
"\n"
"hostname = 'www.python.org'\n"
"context = ssl.create_default_context()\n"
"\n"
"with socket.create_connection((hostname, 443)) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"

#: ../../library/ssl.rst:97
msgid "Client socket example with custom context and IPv4::"
msgstr "Exemplo de socket cliente com contexto personalizado e IPv4::"

#: ../../library/ssl.rst:99
msgid ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"
msgstr ""
"hostname = 'www.python.org'\n"
"# PROTOCOL_TLS_CLIENT requer cadeia de certificados válida e nome de host\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.load_verify_locations('path/to/cabundle.pem')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n"
"        print(ssock.version())"

#: ../../library/ssl.rst:109
msgid "Server socket example listening on localhost IPv4::"
msgstr "Exemplo de socket servidor à escuta em localhost IPv4::"

#: ../../library/ssl.rst:111
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')\n"
"\n"
"with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:\n"
"    sock.bind(('127.0.0.1', 8443))\n"
"    sock.listen(5)\n"
"    with context.wrap_socket(sock, server_side=True) as ssock:\n"
"        conn, addr = ssock.accept()\n"
"        ..."

#: ../../library/ssl.rst:123
msgid "Context creation"
msgstr "Criação de contexto"

#: ../../library/ssl.rst:125
msgid ""
"A convenience function helps create :class:`SSLContext` objects for common "
"purposes."
msgstr ""
"Uma função de conveniência ajuda a criar objetos :class:`SSLContext` para "
"fins comuns."

#: ../../library/ssl.rst:131
msgid ""
"Return a new :class:`SSLContext` object with default settings for the given "
"*purpose*.  The settings are chosen by the :mod:`ssl` module, and usually "
"represent a higher security level than when calling the :class:`SSLContext` "
"constructor directly."
msgstr ""
"Retorna um novo objeto :class:`SSLContext` com configurações predefinidas "
"para o *purpose* dado. As configurações são escolhidas pelo módulo :mod:"
"`ssl`, e geralmente representam um nível de segurança mais elevado do que ao "
"chamar diretamente o construtor :class:`SSLContext`."

#: ../../library/ssl.rst:136
msgid ""
"*cafile*, *capath*, *cadata* represent optional CA certificates to trust for "
"certificate verification, as in :meth:`SSLContext.load_verify_locations`.  "
"If all three are :const:`None`, this function can choose to trust the "
"system's default CA certificates instead."
msgstr ""
"*cafile*, *capath*, *cadata* representam certificados CA opcionais para "
"confiar na verificação de certificados, como em :meth:`SSLContext."
"load_verify_locations`. Se todos os três forem :const:`None`, esta função "
"pode escolher confiar nos certificados CA predefinidos do sistema."

#: ../../library/ssl.rst:142
msgid ""
"The settings are: :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3` with "
"high encryption cipher suites without RC4 and without unauthenticated cipher "
"suites. Passing :const:`~Purpose.SERVER_AUTH` as *purpose* sets :data:"
"`~SSLContext.verify_mode` to :data:`CERT_REQUIRED` and either loads CA "
"certificates (when at least one of *cafile*, *capath* or *cadata* is given) "
"or uses :meth:`SSLContext.load_default_certs` to load default CA "
"certificates."
msgstr ""
"As configurações são: :data:`PROTOCOL_TLS_CLIENT` ou :data:"
"`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, e :data:`OP_NO_SSLv3` com suites "
"de cifras de encriptação forte sem RC4 e sem suites de cifras não "
"autenticadas. Passar :const:`~Purpose.SERVER_AUTH` como *purpose* define :"
"data:`~SSLContext.verify_mode` para :data:`CERT_REQUIRED` e carrega "
"certificados CA (quando pelo menos um de *cafile*, *capath* ou *cadata* é "
"fornecido) ou usa :meth:`SSLContext.load_default_certs` para carregar "
"certificados CA predefinidos."

#: ../../library/ssl.rst:151
msgid ""
"When :attr:`~SSLContext.keylog_filename` is supported and the environment "
"variable :envvar:`SSLKEYLOGFILE` is set, :func:`create_default_context` "
"enables key logging."
msgstr ""
"Quando :attr:`~SSLContext.keylog_filename` é suportado e a variável de "
"ambiente :envvar:`SSLKEYLOGFILE` está definida, :func:"
"`create_default_context` ativa o registo de chaves."

#: ../../library/ssl.rst:155
msgid ""
"The default settings for this context include :data:"
"`VERIFY_X509_PARTIAL_CHAIN` and :data:`VERIFY_X509_STRICT`. These make the "
"underlying OpenSSL implementation behave more like a conforming "
"implementation of :rfc:`5280`, in exchange for a small amount of "
"incompatibility with older X.509 certificates."
msgstr ""
"As configurações predefinidas para este contexto incluem :data:"
"`VERIFY_X509_PARTIAL_CHAIN` e :data:`VERIFY_X509_STRICT`. Estas fazem com "
"que a implementação subjacente do OpenSSL se comporte mais como uma "
"implementação conforme de :rfc:`5280`, em troca de uma pequena quantidade de "
"incompatibilidade com certificados X.509 mais antigos."

#: ../../library/ssl.rst:162
msgid ""
"The protocol, options, cipher and other settings may change to more "
"restrictive values anytime without prior deprecation.  The values represent "
"a fair balance between compatibility and security."
msgstr ""
"O protocolo, opções, cifras e outras configurações podem mudar para valores "
"mais restritivos a qualquer momento sem aviso prévio de obsolescência. Os "
"valores representam um equilíbrio justo entre compatibilidade e segurança."

#: ../../library/ssl.rst:166
msgid ""
"If your application needs specific settings, you should create a :class:"
"`SSLContext` and apply the settings yourself."
msgstr ""
"Se a sua aplicação necessitar de configurações específicas, deve criar um :"
"class:`SSLContext` e aplicar as configurações você mesmo."

#: ../../library/ssl.rst:170
msgid ""
"If you find that when certain older clients or servers attempt to connect "
"with a :class:`SSLContext` created by this function that they get an error "
"stating \"Protocol or cipher suite mismatch\", it may be that they only "
"support SSL3.0 which this function excludes using the :data:`OP_NO_SSLv3`. "
"SSL3.0 is widely considered to be `completely broken <https://en.wikipedia."
"org/wiki/POODLE>`_. If you still wish to continue to use this function but "
"still allow SSL 3.0 connections you can re-enable them using::"
msgstr ""
"Se descobrir que quando certos clientes ou servidores mais antigos tentam "
"ligar-se com um :class:`SSLContext` criado por esta função obtêm um erro "
"indicando \"Protocol or cipher suite mismatch\", pode ser que eles só "
"suportem SSL3.0, que esta função exclui usando :data:`OP_NO_SSLv3`. O SSL3.0 "
"é amplamente considerado `completamente quebrado <https://en.wikipedia.org/"
"wiki/POODLE>`_. Se ainda assim desejar continuar a usar esta função, mas "
"ainda permitir ligações SSL 3.0, pode reativá-las usando::"

#: ../../library/ssl.rst:179
msgid ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"
msgstr ""
"ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)\n"
"ctx.options &= ~ssl.OP_NO_SSLv3"

#: ../../library/ssl.rst:183
msgid ""
"This context enables :data:`VERIFY_X509_STRICT` by default, which may reject "
"pre-:rfc:`5280` or malformed certificates that the underlying OpenSSL "
"implementation otherwise would accept. While disabling this is not "
"recommended, you can do so using::"
msgstr ""
"Este contexto ativa :data:`VERIFY_X509_STRICT` por predefinição, o que pode "
"rejeitar certificados pré-:rfc:`5280` ou malformados que a implementação "
"subjacente do OpenSSL aceitaria de outra forma. Embora desativar isto não "
"seja recomendado, pode fazê-lo usando::"

#: ../../library/ssl.rst:188
msgid ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"
msgstr ""
"ctx = ssl.create_default_context()\n"
"ctx.verify_flags &= ~ssl.VERIFY_X509_STRICT"

#: ../../library/ssl.rst:195
msgid "RC4 was dropped from the default cipher string."
msgstr "RC4 foi removido da string de cifras predefinida."

#: ../../library/ssl.rst:199
msgid "ChaCha20/Poly1305 was added to the default cipher string."
msgstr "ChaCha20/Poly1305 foi adicionado à string de cifras predefinida."

#: ../../library/ssl.rst:201
msgid "3DES was dropped from the default cipher string."
msgstr "3DES foi removido da string de cifras predefinida."

#: ../../library/ssl.rst:205
msgid "Support for key logging to :envvar:`SSLKEYLOGFILE` was added."
msgstr ""
"Suporte para registo de chaves em :envvar:`SSLKEYLOGFILE` foi adicionado."

#: ../../library/ssl.rst:209
msgid ""
"The context now uses :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol instead of generic :data:`PROTOCOL_TLS`."
msgstr ""
"O contexto agora usa o protocolo :data:`PROTOCOL_TLS_CLIENT` ou :data:"
"`PROTOCOL_TLS_SERVER` em vez do protocolo genérico :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:215
msgid ""
"The context now uses :data:`VERIFY_X509_PARTIAL_CHAIN` and :data:"
"`VERIFY_X509_STRICT` in its default verify flags."
msgstr ""
"O contexto agora usa :data:`VERIFY_X509_PARTIAL_CHAIN` e :data:"
"`VERIFY_X509_STRICT` nas suas flags de verificação predefinidas."

#: ../../library/ssl.rst:220
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/ssl.rst:224
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`OSError`.  "
"The error code and message of :exc:`SSLError` instances are provided by the "
"OpenSSL library."
msgstr ""
"Levantada para sinalizar um erro da implementação SSL subjacente (atualmente "
"fornecida pela biblioteca OpenSSL). Isto significa algum problema na camada "
"de encriptação e autenticação de nível superior que é sobreposta à ligação "
"de rede subjacente. Este erro é um subtipo de :exc:`OSError`. O código de "
"erro e mensagem das instâncias :exc:`SSLError` são fornecidos pela "
"biblioteca OpenSSL."

#: ../../library/ssl.rst:231
msgid ":exc:`SSLError` used to be a subtype of :exc:`socket.error`."
msgstr ":exc:`SSLError` costumava ser um subtipo de :exc:`socket.error`."

#: ../../library/ssl.rst:236
msgid ""
"A string mnemonic designating the OpenSSL submodule in which the error "
"occurred, such as ``SSL``, ``PEM`` or ``X509``.  The range of possible "
"values depends on the OpenSSL version."
msgstr ""
"Uma string mnemónica que designa o submódulo OpenSSL no qual o erro ocorreu, "
"como ``SSL``, ``PEM`` ou ``X509``. A gama de valores possíveis depende da "
"versão do OpenSSL."

#: ../../library/ssl.rst:244
msgid ""
"A string mnemonic designating the reason this error occurred, for example "
"``CERTIFICATE_VERIFY_FAILED``.  The range of possible values depends on the "
"OpenSSL version."
msgstr ""
"Uma string mnemónica que designa a razão pela qual este erro ocorreu, por "
"exemplo, ``CERTIFICATE_VERIFY_FAILED``. A gama de valores possíveis depende "
"da versão do OpenSSL."

#: ../../library/ssl.rst:252
msgid ""
"A subclass of :exc:`SSLError` raised when trying to read or write and the "
"SSL connection has been closed cleanly.  Note that this doesn't mean that "
"the underlying transport (read TCP) has been closed."
msgstr ""
"Uma subclasse de :exc:`SSLError` levantada ao tentar ler ou escrever e a "
"ligação SSL ter sido fechada de forma limpa. Note que isto não significa que "
"o transporte subjacente (leia-se TCP) tenha sido fechado."

#: ../../library/ssl.rst:260
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"received on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Uma subclasse de :exc:`SSLError` levantada por um :ref:`socket SSL não "
"bloqueante <ssl-nonblocking>` ao tentar ler ou escrever dados, mas mais "
"dados precisam de ser recebidos no transporte TCP subjacente antes que o "
"pedido possa ser cumprido."

#: ../../library/ssl.rst:269
msgid ""
"A subclass of :exc:`SSLError` raised by a :ref:`non-blocking SSL socket <ssl-"
"nonblocking>` when trying to read or write data, but more data needs to be "
"sent on the underlying TCP transport before the request can be fulfilled."
msgstr ""
"Uma subclasse de :exc:`SSLError` levantada por um :ref:`socket SSL não "
"bloqueante <ssl-nonblocking>` ao tentar ler ou escrever dados, mas mais "
"dados precisam de ser enviados no transporte TCP subjacente antes que o "
"pedido possa ser cumprido."

#: ../../library/ssl.rst:278
msgid ""
"A subclass of :exc:`SSLError` raised when a system error was encountered "
"while trying to fulfill an operation on a SSL socket.  Unfortunately, there "
"is no easy way to inspect the original errno number."
msgstr ""
"Uma subclasse de :exc:`SSLError` levantada quando um erro de sistema foi "
"encontrado ao tentar cumprir uma operação num socket SSL. Infelizmente, não "
"há uma forma fácil de inspecionar o número errno original."

#: ../../library/ssl.rst:286
msgid ""
"A subclass of :exc:`SSLError` raised when the SSL connection has been "
"terminated abruptly.  Generally, you shouldn't try to reuse the underlying "
"transport when this error is encountered."
msgstr ""
"Uma subclasse de :exc:`SSLError` levantada quando a ligação SSL foi "
"terminada abruptamente. Geralmente, não deve tentar reutilizar o transporte "
"subjacente quando este erro é encontrado."

#: ../../library/ssl.rst:294
msgid ""
"A subclass of :exc:`SSLError` raised when certificate validation has failed."
msgstr ""
"Uma subclasse de :exc:`SSLError` levantada quando a validação de certificado "
"falhou."

#: ../../library/ssl.rst:301
msgid "A numeric error number that denotes the verification error."
msgstr "Um número de erro numérico que denota o erro de verificação."

#: ../../library/ssl.rst:305
msgid "A human readable string of the verification error."
msgstr "Uma string legível do erro de verificação."

#: ../../library/ssl.rst:309
msgid "An alias for :exc:`SSLCertVerificationError`."
msgstr "Um alias para :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:311
msgid "The exception is now an alias for :exc:`SSLCertVerificationError`."
msgstr "A exceção é agora um alias para :exc:`SSLCertVerificationError`."

#: ../../library/ssl.rst:316
msgid "Random generation"
msgstr "Geração aleatória"

#: ../../library/ssl.rst:320
msgid ""
"Return *num* cryptographically strong pseudo-random bytes. Raises an :class:"
"`SSLError` if the PRNG has not been seeded with enough data or if the "
"operation is not supported by the current RAND method. :func:`RAND_status` "
"can be used to check the status of the PRNG and :func:`RAND_add` can be used "
"to seed the PRNG."
msgstr ""
"Retorna *num* bytes pseudo-aleatórios criptograficamente fortes. Levanta um :"
"class:`SSLError` se o PRNG não tiver sido inicializado com dados suficientes "
"ou se a operação não for suportada pelo método RAND atual. :func:"
"`RAND_status` pode ser usado para verificar o estado do PRNG e :func:"
"`RAND_add` pode ser usado para inicializar o PRNG."

#: ../../library/ssl.rst:326
msgid "For almost all applications :func:`os.urandom` is preferable."
msgstr "Para quase todas as aplicações, :func:`os.urandom` é preferível."

#: ../../library/ssl.rst:328
msgid ""
"Read the Wikipedia article, `Cryptographically secure pseudorandom number "
"generator (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, to get the "
"requirements of a cryptographically strong generator."
msgstr ""
"Leia o artigo da Wikipedia, `Gerador de números pseudo-aleatórios "
"criptograficamente seguro (CSPRNG) <https://en.wikipedia.org/wiki/"
"Cryptographically_secure_pseudorandom_number_generator>`_, para obter os "
"requisitos de um gerador criptograficamente forte."

#: ../../library/ssl.rst:337
msgid ""
"Return ``True`` if the SSL pseudo-random number generator has been seeded "
"with 'enough' randomness, and ``False`` otherwise.  You can use :func:`ssl."
"RAND_egd` and :func:`ssl.RAND_add` to increase the randomness of the pseudo-"
"random number generator."
msgstr ""
"Retorna ``True`` se o gerador de números pseudo-aleatórios SSL tiver sido "
"inicializado com 'suficiente' aleatoriedade, e ``False`` caso contrário. "
"Pode usar :func:`ssl.RAND_egd` e :func:`ssl.RAND_add` para aumentar a "
"aleatoriedade do gerador de números pseudo-aleatórios."

#: ../../library/ssl.rst:344
msgid ""
"Mix the given *bytes* into the SSL pseudo-random number generator.  The "
"parameter *entropy* (a float) is a lower bound on the entropy contained in "
"string (so you can always use ``0.0``).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""
"Mistura os *bytes* dados no gerador de números pseudo-aleatórios SSL. O "
"parâmetro *entropy* (um float) é um limite inferior da entropia contida na "
"string (portanto, pode sempre usar ``0.0``). Consulte :rfc:`1750` para mais "
"informações sobre fontes de entropia."

#: ../../library/ssl.rst:349
msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Objeto :term:`bytes-like` gravável é agora aceite."

#: ../../library/ssl.rst:353
msgid "Certificate handling"
msgstr "Manipulação de certificados"

#: ../../library/ssl.rst:361
msgid ""
"Return the time in seconds since the Epoch, given the ``cert_time`` string "
"representing the \"notBefore\" or \"notAfter\" date from a certificate in "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale)."
msgstr ""
"Retorna o tempo em segundos desde a Época, dada a string ``cert_time`` que "
"representa a data \"notBefore\" ou \"notAfter\" de um certificado no formato "
"``\"%b %d %H:%M:%S %Y %Z\"`` strptime (localidade C)."

#: ../../library/ssl.rst:366
msgid "Here's an example:"
msgstr "Aqui está um exemplo:"

#: ../../library/ssl.rst:368
msgid ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"
msgstr ""
">>> import ssl\n"
">>> timestamp = ssl.cert_time_to_seconds(\"Jan  5 09:34:43 2018 GMT\")\n"
">>> timestamp\n"
"1515144883\n"
">>> from datetime import datetime\n"
">>> print(datetime.utcfromtimestamp(timestamp))\n"
"2018-01-05 09:34:43"

#: ../../library/ssl.rst:378
msgid "\"notBefore\" or \"notAfter\" dates must use GMT (:rfc:`5280`)."
msgstr "As datas \"notBefore\" ou \"notAfter\" devem usar GMT (:rfc:`5280`)."

#: ../../library/ssl.rst:380
msgid ""
"Interpret the input time as a time in UTC as specified by 'GMT' timezone in "
"the input string. Local timezone was used previously. Return an integer (no "
"fractions of a second in the input format)"
msgstr ""
"Interpreta o tempo de entrada como um tempo em UTC conforme especificado "
"pela zona horária 'GMT' na string de entrada. A zona horária local era usada "
"anteriormente. Retorna um inteiro (sem frações de segundo no formato de "
"entrada)."

#: ../../library/ssl.rst:389
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If *ca_certs* is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the *cafile* parameter in :meth:`SSLContext."
"load_verify_locations`.  The call will attempt to validate the server "
"certificate against that set of root certificates, and will fail if the "
"validation attempt fails.  A timeout can be specified with the ``timeout`` "
"parameter."
msgstr ""
"Dado o endereço ``addr`` de um servidor protegido por SSL, como um par "
"(*hostname*, *port-number*), obtém o certificado do servidor e retorna-o "
"como uma string codificada em PEM. Se ``ssl_version`` for especificado, usa "
"essa versão do protocolo SSL para tentar ligar-se ao servidor. Se *ca_certs* "
"for especificado, deve ser um ficheiro contendo uma lista de certificados "
"raiz, no mesmo formato usado para o parâmetro *cafile* em :meth:`SSLContext."
"load_verify_locations`. A chamada tentará validar o certificado do servidor "
"contra esse conjunto de certificados raiz e falhará se a tentativa de "
"validação falhar. Um tempo limite pode ser especificado com o parâmetro "
"``timeout``."

#: ../../library/ssl.rst:400
msgid "This function is now IPv6-compatible."
msgstr "Esta função é agora compatível com IPv6."

#: ../../library/ssl.rst:403
msgid ""
"The default *ssl_version* is changed from :data:`PROTOCOL_SSLv3` to :data:"
"`PROTOCOL_TLS` for maximum compatibility with modern servers."
msgstr ""
"A versão predefinida *ssl_version* foi alterada de :data:`PROTOCOL_SSLv3` "
"para :data:`PROTOCOL_TLS` para máxima compatibilidade com servidores "
"modernos."

#: ../../library/ssl.rst:407
msgid "The *timeout* parameter was added."
msgstr "O parâmetro *timeout* foi adicionado."

#: ../../library/ssl.rst:412
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""
"Dado um certificado como um blob de bytes codificado em DER, retorna uma "
"versão em string codificada em PEM do mesmo certificado."

#: ../../library/ssl.rst:417
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""
"Dado um certificado como uma string ASCII PEM, retorna uma sequência de "
"bytes codificada em DER para esse mesmo certificado."

#: ../../library/ssl.rst:422
msgid ""
"Returns a named tuple with paths to OpenSSL's default cafile and capath. The "
"paths are the same as used by :meth:`SSLContext.set_default_verify_paths`. "
"The return value is a :term:`named tuple` ``DefaultVerifyPaths``:"
msgstr ""
"Retorna um tuplo nomeado com caminhos para o cafile e capath predefinidos do "
"OpenSSL. Os caminhos são os mesmos usados por :meth:`SSLContext."
"set_default_verify_paths`. O valor de retorno é um :term:`named tuple` "
"``DefaultVerifyPaths``:"

#: ../../library/ssl.rst:427
msgid ""
":attr:`cafile` - resolved path to cafile or ``None`` if the file doesn't "
"exist,"
msgstr ""
":attr:`cafile` - caminho resolvido para cafile ou ``None`` se o ficheiro não "
"existir,"

#: ../../library/ssl.rst:428
msgid ""
":attr:`capath` - resolved path to capath or ``None`` if the directory "
"doesn't exist,"
msgstr ""
":attr:`capath` - caminho resolvido para capath ou ``None`` se o diretório "
"não existir,"

#: ../../library/ssl.rst:429
msgid ""
":attr:`openssl_cafile_env` - OpenSSL's environment key that points to a "
"cafile,"
msgstr ""
":attr:`openssl_cafile_env` - chave de ambiente do OpenSSL que aponta para um "
"cafile,"

#: ../../library/ssl.rst:430
msgid ":attr:`openssl_cafile` - hard coded path to a cafile,"
msgstr ":attr:`openssl_cafile` - caminho codificado para um cafile,"

#: ../../library/ssl.rst:431
msgid ""
":attr:`openssl_capath_env` - OpenSSL's environment key that points to a "
"capath,"
msgstr ""
":attr:`openssl_capath_env` - chave de ambiente do OpenSSL que aponta para um "
"capath,"

#: ../../library/ssl.rst:432
msgid ":attr:`openssl_capath` - hard coded path to a capath directory"
msgstr ":attr:`openssl_capath` - caminho codificado para um diretório capath"

#: ../../library/ssl.rst:438
msgid ""
"Retrieve certificates from Windows' system cert store. *store_name* may be "
"one of ``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert "
"stores, too."
msgstr ""
"Recupera certificados da loja de certificados do sistema Windows. "
"*store_name* pode ser um de ``CA``, ``ROOT`` ou ``MY``. O Windows pode "
"fornecer lojas de certificados adicionais também."

#: ../../library/ssl.rst:442
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 "
"data. Trust specifies the purpose of the certificate as a set of OIDS or "
"exactly ``True`` if the certificate is trustworthy for all purposes."
msgstr ""
"A função retorna uma lista de tuplos (cert_bytes, encoding_type, trust). O "
"encoding_type especifica a codificação de cert_bytes. É :const:`x509_asn` "
"para dados X.509 ASN.1 ou :const:`pkcs_7_asn` para dados PKCS#7 ASN.1. Trust "
"especifica o propósito do certificado como um conjunto de OIDs ou exatamente "
"``True`` se o certificado for confiável para todos os propósitos."

#: ../../library/ssl.rst:449 ../../library/ssl.rst:1603
#: ../../library/ssl.rst:1903
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/ssl.rst:451
msgid ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'data...', 'x509_asn', True)]"
msgstr ""
">>> ssl.enum_certificates(\"CA\")\n"
"[(b'dados...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),\n"
" (b'dados...', 'x509_asn', True)]"

#: ../../library/ssl.rst:461
msgid ""
"Retrieve CRLs from Windows' system cert store. *store_name* may be one of "
"``CA``, ``ROOT`` or ``MY``. Windows may provide additional cert stores, too."
msgstr ""
"Recupera CRLs da loja de certificados do sistema Windows. *store_name* pode "
"ser um de ``CA``, ``ROOT`` ou ``MY``. O Windows pode fornecer lojas de "
"certificados adicionais também."

#: ../../library/ssl.rst:465
msgid ""
"The function returns a list of (cert_bytes, encoding_type, trust) tuples. "
"The encoding_type specifies the encoding of cert_bytes. It is either :const:"
"`x509_asn` for X.509 ASN.1 data or :const:`pkcs_7_asn` for PKCS#7 ASN.1 data."
msgstr ""
"A função retorna uma lista de tuplos (cert_bytes, encoding_type, trust). O "
"encoding_type especifica a codificação de cert_bytes. É :const:`x509_asn` "
"para dados X.509 ASN.1 ou :const:`pkcs_7_asn` para dados PKCS#7 ASN.1."

#: ../../library/ssl.rst:476
msgid "Constants"
msgstr "Constantes"

#: ../../library/ssl.rst:478
msgid ""
"All constants are now :class:`enum.IntEnum` or :class:`enum.IntFlag` "
"collections."
msgstr ""
"Todas as constantes são agora coleções :class:`enum.IntEnum` ou :class:`enum."
"IntFlag`."

#: ../../library/ssl.rst:484
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. Except for :const:"
"`PROTOCOL_TLS_CLIENT`, it is the default mode.  With client-side sockets, "
"just about any cert is accepted.  Validation errors, such as untrusted or "
"expired cert, are ignored and do not abort the TLS/SSL handshake."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_mode`. Exceto para :const:"
"`PROTOCOL_TLS_CLIENT`, é o modo predefinido. Com sockets do lado do cliente, "
"quase qualquer certificado é aceite. Erros de validação, como certificados "
"não confiáveis ou expirados, são ignorados e não abortam o handshake TLS/SSL."

#: ../../library/ssl.rst:490
msgid ""
"In server mode, no certificate is requested from the client, so the client "
"does not send any for client cert authentication."
msgstr ""
"Em modo servidor, nenhum certificado é solicitado ao cliente, pelo que o "
"cliente não envia nenhum para autenticação de certificado de cliente."

#: ../../library/ssl.rst:493 ../../library/ssl.rst:2405
msgid "See the discussion of :ref:`ssl-security` below."
msgstr "Consulte a discussão de :ref:`ssl-security` abaixo."

#: ../../library/ssl.rst:497
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In client mode, :const:"
"`CERT_OPTIONAL` has the same meaning as :const:`CERT_REQUIRED`. It is "
"recommended to use :const:`CERT_REQUIRED` for client-side sockets instead."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_mode`. Em modo cliente, :const:"
"`CERT_OPTIONAL` tem o mesmo significado que :const:`CERT_REQUIRED`. É "
"recomendado usar :const:`CERT_REQUIRED` para sockets do lado do cliente."

#: ../../library/ssl.rst:502
msgid ""
"In server mode, a client certificate request is sent to the client.  The "
"client may either ignore the request or send a certificate in order perform "
"TLS client cert authentication.  If the client chooses to send a "
"certificate, it is verified.  Any verification error immediately aborts the "
"TLS handshake."
msgstr ""
"Em modo servidor, um pedido de certificado de cliente é enviado ao cliente. "
"O cliente pode ignorar o pedido ou enviar um certificado para realizar a "
"autenticação de certificado de cliente TLS. Se o cliente escolher enviar um "
"certificado, ele é verificado. Qualquer erro de verificação aborta "
"imediatamente o handshake TLS."

#: ../../library/ssl.rst:508 ../../library/ssl.rst:527
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed to :"
"meth:`SSLContext.load_verify_locations`."
msgstr ""
"O uso desta configuração requer que um conjunto válido de certificados CA "
"seja passado para :meth:`SSLContext.load_verify_locations`."

#: ../../library/ssl.rst:513
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`. In this mode, "
"certificates are required from the other side of the socket connection; an :"
"class:`SSLError` will be raised if no certificate is provided, or if its "
"validation fails. This mode is **not** sufficient to verify a certificate in "
"client mode as it does not match hostnames.  :attr:`~SSLContext."
"check_hostname` must be enabled as well to verify the authenticity of a "
"cert. :const:`PROTOCOL_TLS_CLIENT` uses :const:`CERT_REQUIRED` and enables :"
"attr:`~SSLContext.check_hostname` by default."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_mode`. Neste modo, são "
"necessários certificados do outro lado da ligação do socket; um :class:"
"`SSLError` será levantado se nenhum certificado for fornecido, ou se a sua "
"validação falhar. Este modo **não** é suficiente para verificar um "
"certificado em modo cliente, uma vez que não verifica os nomes de host. :"
"attr:`~SSLContext.check_hostname` também deve ser ativado para verificar a "
"autenticidade de um certificado. :const:`PROTOCOL_TLS_CLIENT` usa :const:"
"`CERT_REQUIRED` e ativa :attr:`~SSLContext.check_hostname` por predefinição."

#: ../../library/ssl.rst:523
msgid ""
"With server socket, this mode provides mandatory TLS client cert "
"authentication.  A client certificate request is sent to the client and the "
"client must provide a valid and trusted certificate."
msgstr ""
"Com socket de servidor, este modo fornece autenticação obrigatória de "
"certificado de cliente TLS. Um pedido de certificado de cliente é enviado ao "
"cliente e o cliente deve fornecer um certificado válido e confiável."

#: ../../library/ssl.rst:532
msgid ":class:`enum.IntEnum` collection of CERT_* constants."
msgstr ":class:`enum.IntEnum` coleção de constantes CERT_*."

#: ../../library/ssl.rst:538
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, "
"certificate revocation lists (CRLs) are not checked. By default OpenSSL does "
"neither require nor verify CRLs."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags`. Neste modo, as listas "
"de revogação de certificados (CRLs) não são verificadas. Por predefinição, o "
"OpenSSL não exige nem verifica CRLs."

#: ../../library/ssl.rst:546
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, only the "
"peer cert is checked but none of the intermediate CA certificates. The mode "
"requires a valid CRL that is signed by the peer cert's issuer (its direct "
"ancestor CA). If no proper CRL has been loaded with :attr:`SSLContext."
"load_verify_locations`, validation will fail."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags`. Neste modo, apenas o "
"certificado do par é verificado, mas nenhum dos certificados CA intermédios. "
"O modo requer uma CRL válida que seja assinada pelo emissor do certificado "
"do par (a sua CA ancestral direta). Se nenhuma CRL adequada tiver sido "
"carregada com :attr:`SSLContext.load_verify_locations`, a validação falhará."

#: ../../library/ssl.rst:556
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. In this mode, CRLs of "
"all certificates in the peer cert chain are checked."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags`. Neste modo, as CRLs de "
"todos os certificados na cadeia de certificados do par são verificadas."

#: ../../library/ssl.rst:563
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to disable workarounds "
"for broken X.509 certificates."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags` para desativar soluções "
"alternativas para certificados X.509 quebrados."

#: ../../library/ssl.rst:570
msgid ""
"Possible value for :attr:`SSLContext.verify_flags` to enables proxy "
"certificate verification."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags` para ativar a "
"verificação de certificados proxy."

#: ../../library/ssl.rst:577
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"prefer trusted certificates when building the trust chain to validate a "
"certificate. This flag is enabled by default."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags`. Instrui o OpenSSL a "
"preferir certificados confiáveis ao construir a cadeia de confiança para "
"validar um certificado. Esta flag está ativada por predefinição."

#: ../../library/ssl.rst:585
msgid ""
"Possible value for :attr:`SSLContext.verify_flags`. It instructs OpenSSL to "
"accept intermediate CAs in the trust store to be treated as trust-anchors, "
"in the same way as the self-signed root CA certificates. This makes it "
"possible to trust certificates issued by an intermediate CA without having "
"to trust its ancestor root CA."
msgstr ""
"Valor possível para :attr:`SSLContext.verify_flags`. Instrui o OpenSSL a "
"aceitar CAs intermédias na loja de confiança para serem tratadas como "
"âncoras de confiança, da mesma forma que os certificados CA raiz "
"autoassinados. Isto torna possível confiar em certificados emitidos por uma "
"CA intermédia sem ter de confiar na sua CA raiz ancestral."

#: ../../library/ssl.rst:596
msgid ":class:`enum.IntFlag` collection of VERIFY_* constants."
msgstr ":class:`enum.IntFlag` coleção de constantes VERIFY_*."

#: ../../library/ssl.rst:602
msgid ""
"Selects the highest protocol version that both the client and server "
"support. Despite the name, this option can select both \"SSL\" and \"TLS\" "
"protocols."
msgstr ""
"Selecciona a versão de protocolo mais alta suportada tanto pelo cliente como "
"pelo servidor. Apesar do nome, esta opção pode selecionar tanto protocolos "
"\"SSL\" como \"TLS\"."

#: ../../library/ssl.rst:609
msgid ""
"TLS clients and servers require different default settings for secure "
"communication. The generic TLS protocol constant is deprecated in favor of :"
"data:`PROTOCOL_TLS_CLIENT` and :data:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Clientes e servidores TLS requerem configurações predefinidas diferentes "
"para comunicação segura. A constante de protocolo TLS genérica está obsoleta "
"em favor de :data:`PROTOCOL_TLS_CLIENT` e :data:`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:615
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context client-side connections. The protocol "
"enables :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` by "
"default."
msgstr ""
"Negocia automaticamente a versão de protocolo mais alta suportada tanto pelo "
"cliente como pelo servidor, e configura as ligações do lado do cliente do "
"contexto. O protocolo ativa :data:`CERT_REQUIRED` e :attr:`~SSLContext."
"check_hostname` por predefinição."

#: ../../library/ssl.rst:624
msgid ""
"Auto-negotiate the highest protocol version that both the client and server "
"support, and configure the context server-side connections."
msgstr ""
"Negocia automaticamente a versão de protocolo mais alta suportada tanto pelo "
"cliente como pelo servidor, e configura as ligações do lado do servidor do "
"contexto."

#: ../../library/ssl.rst:631
msgid "Alias for :data:`PROTOCOL_TLS`."
msgstr "Alias para :data:`PROTOCOL_TLS`."

#: ../../library/ssl.rst:635
msgid "Use :data:`PROTOCOL_TLS` instead."
msgstr "Use :data:`PROTOCOL_TLS` em vez disso."

#: ../../library/ssl.rst:639
msgid "Selects SSL version 3 as the channel encryption protocol."
msgstr "Selecciona a versão SSL 3 como protocolo de encriptação do canal."

#: ../../library/ssl.rst:641
msgid ""
"This protocol is not available if OpenSSL is compiled with the ``no-ssl3`` "
"option."
msgstr ""
"Este protocolo não está disponível se o OpenSSL for compilado com a opção "
"``no-ssl3``."

#: ../../library/ssl.rst:646
msgid "SSL version 3 is insecure.  Its use is highly discouraged."
msgstr "A versão SSL 3 é insegura. O seu uso é altamente desencorajado."

#: ../../library/ssl.rst:650
msgid ""
"OpenSSL has deprecated all version specific protocols. Use the default "
"protocol :data:`PROTOCOL_TLS_SERVER` or :data:`PROTOCOL_TLS_CLIENT` with :"
"attr:`SSLContext.minimum_version` and :attr:`SSLContext.maximum_version` "
"instead."
msgstr ""
"O OpenSSL descontinuou todos os protocolos específicos de versão. Use o "
"protocolo predefinido :data:`PROTOCOL_TLS_SERVER` ou :data:"
"`PROTOCOL_TLS_CLIENT` com :attr:`SSLContext.minimum_version` e :attr:"
"`SSLContext.maximum_version` em vez disso."

#: ../../library/ssl.rst:658
msgid "Selects TLS version 1.0 as the channel encryption protocol."
msgstr "Selecciona a versão TLS 1.0 como protocolo de encriptação do canal."

#: ../../library/ssl.rst:662 ../../library/ssl.rst:673
#: ../../library/ssl.rst:684
msgid "OpenSSL has deprecated all version specific protocols."
msgstr "O OpenSSL descontinuou todos os protocolos específicos de versão."

#: ../../library/ssl.rst:666
msgid ""
"Selects TLS version 1.1 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Selecciona a versão TLS 1.1 como protocolo de encriptação do canal. "
"Disponível apenas com a versão openssl 1.0.1+."

#: ../../library/ssl.rst:677
msgid ""
"Selects TLS version 1.2 as the channel encryption protocol. Available only "
"with openssl version 1.0.1+."
msgstr ""
"Selecciona a versão TLS 1.2 como protocolo de encriptação do canal. "
"Disponível apenas com a versão openssl 1.0.1+."

#: ../../library/ssl.rst:688
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""
"Ativa soluções alternativas para vários bugs presentes em outras "
"implementações SSL. Esta opção está definida por predefinição. Não define "
"necessariamente as mesmas flags que a constante ``SSL_OP_ALL`` do OpenSSL."

#: ../../library/ssl.rst:696
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""
"Impede uma ligação SSLv2. Esta opção é apenas aplicável em conjunto com :"
"const:`PROTOCOL_TLS`. Impede que os pares escolham SSLv2 como a versão do "
"protocolo."

#: ../../library/ssl.rst:704
msgid "SSLv2 is deprecated"
msgstr "SSLv2 está obsoleto"

#: ../../library/ssl.rst:708
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""
"Impede uma ligação SSLv3. Esta opção é apenas aplicável em conjunto com :"
"const:`PROTOCOL_TLS`. Impede que os pares escolham SSLv3 como a versão do "
"protocolo."

#: ../../library/ssl.rst:716
msgid "SSLv3 is deprecated"
msgstr "SSLv3 está obsoleto"

#: ../../library/ssl.rst:720
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""
"Impede uma ligação TLSv1. Esta opção é apenas aplicável em conjunto com :"
"const:`PROTOCOL_TLS`. Impede que os pares escolham TLSv1 como a versão do "
"protocolo."

#: ../../library/ssl.rst:726
msgid ""
"The option is deprecated since OpenSSL 1.1.0, use the new :attr:`SSLContext."
"minimum_version` and :attr:`SSLContext.maximum_version` instead."
msgstr ""
"A opção está obsoleta desde o OpenSSL 1.1.0, use os novos :attr:`SSLContext."
"minimum_version` e :attr:`SSLContext.maximum_version` em vez disso."

#: ../../library/ssl.rst:733
msgid ""
"Prevents a TLSv1.1 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Impede uma ligação TLSv1.1. Esta opção é apenas aplicável em conjunto com :"
"const:`PROTOCOL_TLS`. Impede que os pares escolham TLSv1.1 como a versão do "
"protocolo. Disponível apenas com a versão openssl 1.0.1+."

#: ../../library/ssl.rst:739 ../../library/ssl.rst:750
msgid "The option is deprecated since OpenSSL 1.1.0."
msgstr "A opção está obsoleta desde o OpenSSL 1.1.0."

#: ../../library/ssl.rst:744
msgid ""
"Prevents a TLSv1.2 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as "
"the protocol version. Available only with openssl version 1.0.1+."
msgstr ""
"Impede uma ligação TLSv1.2. Esta opção é apenas aplicável em conjunto com :"
"const:`PROTOCOL_TLS`. Impede que os pares escolham TLSv1.2 como a versão do "
"protocolo. Disponível apenas com a versão openssl 1.0.1+."

#: ../../library/ssl.rst:755
msgid ""
"Prevents a TLSv1.3 connection. This option is only applicable in conjunction "
"with :const:`PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as "
"the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When "
"Python has been compiled against an older version of OpenSSL, the flag "
"defaults to *0*."
msgstr ""
"Impede uma ligação TLSv1.3. Esta opção é apenas aplicável em conjunto com :"
"const:`PROTOCOL_TLS`. Impede que os pares escolham TLSv1.3 como a versão do "
"protocolo. TLS 1.3 está disponível com OpenSSL 1.1.1 ou posterior. Quando o "
"Python é compilado contra uma versão mais antiga do OpenSSL, a flag é "
"predefinida para *0*."

#: ../../library/ssl.rst:763
msgid ""
"The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15 and "
"3.6.3 for backwards compatibility with OpenSSL 1.0.2."
msgstr ""
"A opção está obsoleta desde o OpenSSL 1.1.0. Foi adicionada às versões "
"2.7.15 e 3.6.3 para compatibilidade com versões anteriores do OpenSSL 1.0.2."

#: ../../library/ssl.rst:769
msgid ""
"Disable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest "
"messages, and ignore renegotiation requests via ClientHello."
msgstr ""
"Desativa toda a renegociação em TLSv1.2 e anteriores. Não envia mensagens "
"HelloRequest e ignora pedidos de renegociação via ClientHello."

#: ../../library/ssl.rst:772
msgid "This option is only available with OpenSSL 1.1.0h and later."
msgstr "Esta opção está disponível apenas com OpenSSL 1.1.0h e posterior."

#: ../../library/ssl.rst:778
msgid ""
"Use the server's cipher ordering preference, rather than the client's. This "
"option has no effect on client sockets and SSLv2 server sockets."
msgstr ""
"Usa a preferência de ordenação de cifras do servidor, em vez da do cliente. "
"Esta opção não tem efeito em sockets de cliente e sockets de servidor SSLv2."

#: ../../library/ssl.rst:785
msgid ""
"Prevents reuse of the same DH key for distinct SSL sessions.  This improves "
"forward secrecy but requires more computational resources. This option only "
"applies to server sockets."
msgstr ""
"Impede a reutilização da mesma chave DH para sessões SSL distintas. Isto "
"melhora a confidencialidade futura, mas requer mais recursos computacionais. "
"Esta opção aplica-se apenas a sockets de servidor."

#: ../../library/ssl.rst:793
msgid ""
"Prevents reuse of the same ECDH key for distinct SSL sessions.  This "
"improves forward secrecy but requires more computational resources. This "
"option only applies to server sockets."
msgstr ""
"Impede a reutilização da mesma chave ECDH para sessões SSL distintas. Isto "
"melhora a confidencialidade futura, mas requer mais recursos computacionais. "
"Esta opção aplica-se apenas a sockets de servidor."

#: ../../library/ssl.rst:801
msgid ""
"Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a "
"TLS 1.3 connection look more like a TLS 1.2 connection."
msgstr ""
"Envie mensagens Change Cipher Spec (CCS) fictícias no handshake TLS 1.3 para "
"fazer com que uma ligação TLS 1.3 pareça mais uma ligação TLS 1.2."

#: ../../library/ssl.rst:804
msgid "This option is only available with OpenSSL 1.1.1 and later."
msgstr "Esta opção está disponível apenas com OpenSSL 1.1.1 e posterior."

#: ../../library/ssl.rst:810
msgid ""
"Disable compression on the SSL channel.  This is useful if the application "
"protocol supports its own compression scheme."
msgstr ""
"Desativa a compressão no canal SSL. Isto é útil se o protocolo da aplicação "
"suportar o seu próprio esquema de compressão."

#: ../../library/ssl.rst:817
msgid ":class:`enum.IntFlag` collection of OP_* constants."
msgstr ":class:`enum.IntFlag` coleção de constantes OP_*."

#: ../../library/ssl.rst:821
msgid "Prevent client side from requesting a session ticket."
msgstr "Impede que o lado do cliente solicite um bilhete de sessão."

#: ../../library/ssl.rst:827
msgid "Ignore unexpected shutdown of TLS connections."
msgstr "Ignorar o encerramento inesperado de ligações TLS."

#: ../../library/ssl.rst:829 ../../library/ssl.rst:845
msgid "This option is only available with OpenSSL 3.0.0 and later."
msgstr "Esta opção está disponível apenas com OpenSSL 3.0.0 e posterior."

#: ../../library/ssl.rst:835
msgid ""
"Enable the use of the kernel TLS. To benefit from the feature, OpenSSL must "
"have been compiled with support for it, and the negotiated cipher suites and "
"extensions must be supported by it (a list of supported ones may vary by "
"platform and kernel version)."
msgstr ""
"Ativa o uso do TLS do kernel. Para beneficiar desta funcionalidade, o "
"OpenSSL deve ter sido compilado com suporte para ela, e as suites de cifras "
"e extensões negociadas devem ser suportadas por ela (uma lista das "
"suportadas pode variar por plataforma e versão do kernel)."

#: ../../library/ssl.rst:840
msgid ""
"Note that with enabled kernel TLS some cryptographic operations are "
"performed by the kernel directly and not via any available OpenSSL "
"Providers. This might be undesirable if, for example, the application "
"requires all cryptographic operations to be performed by the FIPS provider."
msgstr ""
"Note que com o TLS do kernel ativado, algumas operações criptográficas são "
"realizadas diretamente pelo kernel e não através de quaisquer Provedores "
"OpenSSL disponíveis. Isto pode ser indesejável se, por exemplo, a aplicação "
"exigir que todas as operações criptográficas sejam realizadas pelo provedor "
"FIPS."

#: ../../library/ssl.rst:851
msgid ""
"Allow legacy insecure renegotiation between OpenSSL and unpatched servers "
"only."
msgstr ""
"Permitir renegociação insegura legada apenas entre OpenSSL e servidores não "
"corrigidos."

#: ../../library/ssl.rst:858
msgid ""
"Whether the OpenSSL library has built-in support for the *Application-Layer "
"Protocol Negotiation* TLS extension as described in :rfc:`7301`."
msgstr ""

#: ../../library/ssl.rst:865
msgid ""
"Whether the OpenSSL library has built-in support not checking subject common "
"name and :attr:`SSLContext.hostname_checks_common_name` is writeable."
msgstr ""

#: ../../library/ssl.rst:873
msgid ""
"Whether the OpenSSL library has built-in support for the Elliptic Curve-"
"based Diffie-Hellman key exchange.  This should be true unless the feature "
"was explicitly disabled by the distributor."
msgstr ""

#: ../../library/ssl.rst:881
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension (as defined in :rfc:`6066`)."
msgstr ""

#: ../../library/ssl.rst:888
msgid ""
"Whether the OpenSSL library has built-in support for the *Next Protocol "
"Negotiation* as described in the `Application Layer Protocol Negotiation "
"<https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_. "
"When true, you can use the :meth:`SSLContext.set_npn_protocols` method to "
"advertise which protocols you want to support."
msgstr ""

#: ../../library/ssl.rst:898
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 2.0 protocol."
msgstr ""
"Indica se a biblioteca OpenSSL tem suporte integrado para o protocolo SSL "
"2.0."

#: ../../library/ssl.rst:904
msgid ""
"Whether the OpenSSL library has built-in support for the SSL 3.0 protocol."
msgstr ""
"Indica se a biblioteca OpenSSL tem suporte integrado para o protocolo SSL "
"3.0."

#: ../../library/ssl.rst:910
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.0 protocol."
msgstr ""
"Indica se a biblioteca OpenSSL tem suporte integrado para o protocolo TLS "
"1.0."

#: ../../library/ssl.rst:916
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.1 protocol."
msgstr ""
"Indica se a biblioteca OpenSSL tem suporte integrado para o protocolo TLS "
"1.1."

#: ../../library/ssl.rst:922
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.2 protocol."
msgstr ""
"Indica se a biblioteca OpenSSL tem suporte integrado para o protocolo TLS "
"1.2."

#: ../../library/ssl.rst:928
msgid ""
"Whether the OpenSSL library has built-in support for the TLS 1.3 protocol."
msgstr ""
"Indica se a biblioteca OpenSSL tem suporte integrado para o protocolo TLS "
"1.3."

#: ../../library/ssl.rst:934
msgid "Whether the OpenSSL library has built-in support for TLS-PSK."
msgstr "Indica se a biblioteca OpenSSL tem suporte integrado para TLS-PSK."

#: ../../library/ssl.rst:940
msgid ""
"List of supported TLS channel binding types.  Strings in this list can be "
"used as arguments to :meth:`SSLSocket.get_channel_binding`."
msgstr ""
"Lista de tipos de ligação de canal TLS suportados. As strings nesta lista "
"podem ser usadas como argumentos para :meth:`SSLSocket.get_channel_binding`."

#: ../../library/ssl.rst:947
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr ""
"A string de versão da biblioteca OpenSSL carregada pelo interpretador::"

#: ../../library/ssl.rst:949
msgid ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"
msgstr ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 1.0.2k  26 Jan 2017'"

#: ../../library/ssl.rst:956
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""
"Um tuplo de cinco inteiros representando informações de versão sobre a "
"biblioteca OpenSSL::"

#: ../../library/ssl.rst:959
msgid ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"
msgstr ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(1, 0, 2, 11, 15)"

#: ../../library/ssl.rst:966
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""
"O número de versão bruto da biblioteca OpenSSL, como um único inteiro::"

#: ../../library/ssl.rst:968
msgid ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"
msgstr ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"268443839\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x100020bf'"

#: ../../library/ssl.rst:979
msgid ""
"Alert Descriptions from :rfc:`5246` and others. The `IANA TLS Alert Registry "
"<https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contains this list and references to the RFCs where their "
"meaning is defined."
msgstr ""
"Descrições de alerta de :rfc:`5246` e outros. O `Registo de Alertas TLS da "
"IANA <https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-"
"parameters-6>`_ contém esta lista e referências aos RFCs onde o seu "
"significado é definido."

#: ../../library/ssl.rst:983
msgid ""
"Used as the return value of the callback function in :meth:`SSLContext."
"set_servername_callback`."
msgstr ""
"Usado como o valor de retorno da função de retorno de chamada em :meth:"
"`SSLContext.set_servername_callback`."

#: ../../library/ssl.rst:990
msgid ":class:`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants."
msgstr ":class:`enum.IntEnum` coleção de constantes ALERT_DESCRIPTION_*."

#: ../../library/ssl.rst:996
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web servers (therefore, it will be used to create client-side "
"sockets)."
msgstr ""
"Opção para :func:`create_default_context` e :meth:`SSLContext."
"load_default_certs`. Este valor indica que o contexto pode ser usado para "
"autenticar servidores web (portanto, será usado para criar sockets do lado "
"do cliente)."

#: ../../library/ssl.rst:1005
msgid ""
"Option for :func:`create_default_context` and :meth:`SSLContext."
"load_default_certs`.  This value indicates that the context may be used to "
"authenticate web clients (therefore, it will be used to create server-side "
"sockets)."
msgstr ""
"Opção para :func:`create_default_context` e :meth:`SSLContext."
"load_default_certs`. Este valor indica que o contexto pode ser usado para "
"autenticar clientes web (portanto, será usado para criar sockets do lado do "
"servidor)."

#: ../../library/ssl.rst:1014
msgid ":class:`enum.IntEnum` collection of SSL_ERROR_* constants."
msgstr ":class:`enum.IntEnum` coleção de constantes SSL_ERROR_*."

#: ../../library/ssl.rst:1020
msgid ""
":class:`enum.IntEnum` collection of SSL and TLS versions for :attr:"
"`SSLContext.maximum_version` and :attr:`SSLContext.minimum_version`."
msgstr ""
":class:`enum.IntEnum` coleção de versões SSL e TLS para :attr:`SSLContext."
"maximum_version` e :attr:`SSLContext.minimum_version`."

#: ../../library/ssl.rst:1028
msgid ""
"The minimum or maximum supported SSL or TLS version. These are magic "
"constants. Their values don't reflect the lowest and highest available TLS/"
"SSL versions."
msgstr ""
"A versão mínima ou máxima suportada de SSL ou TLS. Estas são constantes "
"mágicas. Os seus valores não refletem as versões mais baixas e mais altas "
"disponíveis de TLS/SSL."

#: ../../library/ssl.rst:1038
msgid "SSL 3.0 to TLS 1.3."
msgstr "SSL 3.0 a TLS 1.3."

#: ../../library/ssl.rst:1042
msgid ""
"All :class:`TLSVersion` members except :attr:`TLSVersion.TLSv1_2` and :attr:"
"`TLSVersion.TLSv1_3` are deprecated."
msgstr ""
"Todos os membros de :class:`TLSVersion`, exceto :attr:`TLSVersion.TLSv1_2` "
"e :attr:`TLSVersion.TLSv1_3`, estão obsoletos."

#: ../../library/ssl.rst:1047
msgid "SSL Sockets"
msgstr "Sockets SSL"

#: ../../library/ssl.rst:1051
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr "Os sockets SSL fornecem os seguintes métodos de :ref:`socket-objects`:"

#: ../../library/ssl.rst:1053
msgid ":meth:`~socket.socket.accept`"
msgstr ":meth:`~socket.socket.accept`"

#: ../../library/ssl.rst:1054
msgid ":meth:`~socket.socket.bind`"
msgstr ":meth:`~socket.socket.bind`"

#: ../../library/ssl.rst:1055
msgid ":meth:`~socket.socket.close`"
msgstr ":meth:`~socket.socket.close`"

#: ../../library/ssl.rst:1056
msgid ":meth:`~socket.socket.connect`"
msgstr ":meth:`~socket.socket.connect`"

#: ../../library/ssl.rst:1057
msgid ":meth:`~socket.socket.detach`"
msgstr ":meth:`~socket.socket.detach`"

#: ../../library/ssl.rst:1058
msgid ":meth:`~socket.socket.fileno`"
msgstr ":meth:`~socket.socket.fileno`"

#: ../../library/ssl.rst:1059
msgid ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"
msgstr ":meth:`~socket.socket.getpeername`, :meth:`~socket.socket.getsockname`"

#: ../../library/ssl.rst:1060
msgid ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"
msgstr ":meth:`~socket.socket.getsockopt`, :meth:`~socket.socket.setsockopt`"

#: ../../library/ssl.rst:1061
msgid ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, :meth:"
"`~socket.socket.setblocking`"
msgstr ""
":meth:`~socket.socket.gettimeout`, :meth:`~socket.socket.settimeout`, :meth:"
"`~socket.socket.setblocking`"

#: ../../library/ssl.rst:1063
msgid ":meth:`~socket.socket.listen`"
msgstr ":meth:`~socket.socket.listen`"

#: ../../library/ssl.rst:1064
msgid ":meth:`~socket.socket.makefile`"
msgstr ":meth:`~socket.socket.makefile`"

#: ../../library/ssl.rst:1065
msgid ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (but passing a "
"non-zero ``flags`` argument is not allowed)"
msgstr ""
":meth:`~socket.socket.recv`, :meth:`~socket.socket.recv_into` (mas passar um "
"argumento ``flags`` não nulo não é permitido)"

#: ../../library/ssl.rst:1067
msgid ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (with the same "
"limitation)"
msgstr ""
":meth:`~socket.socket.send`, :meth:`~socket.socket.sendall` (com a mesma "
"limitação)"

#: ../../library/ssl.rst:1069
msgid ""
":meth:`~socket.socket.sendfile` (but :mod:`os.sendfile` will be used for "
"plain-text sockets only, else :meth:`~socket.socket.send` will be used)"
msgstr ""
":meth:`~socket.socket.sendfile` (mas :mod:`os.sendfile` será usado apenas "
"para sockets de texto simples, caso contrário :meth:`~socket.socket.send` "
"será usado)"

#: ../../library/ssl.rst:1071
msgid ":meth:`~socket.socket.shutdown`"
msgstr ":meth:`~socket.socket.shutdown`"

#: ../../library/ssl.rst:1073
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""
"No entanto, uma vez que o protocolo SSL (e TLS) tem a sua própria "
"estruturação sobre TCP, a abstração de sockets SSL pode, em certos aspetos, "
"divergir da especificação de sockets normais, a nível do sistema operativo. "
"Consulte especialmente as :ref:`notas sobre sockets não bloqueantes <ssl-"
"nonblocking>`."

#: ../../library/ssl.rst:1078
msgid ""
"Instances of :class:`SSLSocket` must be created using the :meth:`SSLContext."
"wrap_socket` method."
msgstr ""
"Instâncias de :class:`SSLSocket` devem ser criadas usando o método :meth:"
"`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:1081
msgid "The :meth:`sendfile` method was added."
msgstr "O método :meth:`sendfile` foi adicionado."

#: ../../library/ssl.rst:1084
msgid ""
"The :meth:`shutdown` does not reset the socket timeout each time bytes are "
"received or sent. The socket timeout is now the maximum total duration of "
"the shutdown."
msgstr ""
"O :meth:`shutdown` não redefine o tempo limite do socket cada vez que bytes "
"são recebidos ou enviados. O tempo limite do socket é agora a duração total "
"máxima do encerramento."

#: ../../library/ssl.rst:1089
msgid ""
"It is deprecated to create a :class:`SSLSocket` instance directly, use :meth:"
"`SSLContext.wrap_socket` to wrap a socket."
msgstr ""
"Está obsoleto criar uma instância de :class:`SSLSocket` diretamente; use :"
"meth:`SSLContext.wrap_socket` para envolver um socket."

#: ../../library/ssl.rst:1093
msgid ""
":class:`SSLSocket` instances must to created with :meth:`~SSLContext."
"wrap_socket`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"As instâncias de :class:`SSLSocket` devem ser criadas com :meth:`~SSLContext."
"wrap_socket`. Em versões anteriores, era possível criar instâncias "
"diretamente. Isto nunca foi documentado nem oficialmente suportado."

#: ../../library/ssl.rst:1099
msgid ""
"Python now uses ``SSL_read_ex`` and ``SSL_write_ex`` internally. The "
"functions support reading and writing of data larger than 2 GB. Writing zero-"
"length data no longer fails with a protocol violation error."
msgstr ""
"O Python agora usa internamente ``SSL_read_ex`` e ``SSL_write_ex``. As "
"funções suportam a leitura e escrita de dados maiores que 2 GB. A escrita de "
"dados de comprimento zero já não falha com um erro de violação de protocolo."

#: ../../library/ssl.rst:1104
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr "Os sockets SSL também têm os seguintes métodos e atributos adicionais:"

#: ../../library/ssl.rst:1108
msgid ""
"Read up to *len* bytes of data from the SSL socket and return the result as "
"a ``bytes`` instance. If *buffer* is specified, then read into the buffer "
"instead, and return the number of bytes read."
msgstr ""
"Lê até *len* bytes de dados do socket SSL e retorna o resultado como uma "
"instância ``bytes``. Se *buffer* for especificado, então lê para o buffer, e "
"retorna o número de bytes lidos."

#: ../../library/ssl.rst:1112
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the read would block."
msgstr ""
"Levanta :exc:`SSLWantReadError` ou :exc:`SSLWantWriteError` se o socket for :"
"ref:`não bloqueante <ssl-nonblocking>` e a leitura bloqueasse."

#: ../../library/ssl.rst:1115
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`read` can also "
"cause write operations."
msgstr ""
"Como a qualquer momento uma renegociação é possível, uma chamada a :meth:"
"`read` também pode causar operações de escrita."

#: ../../library/ssl.rst:1118
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to read up to *len* "
"bytes."
msgstr ""
"O tempo limite do socket já não é redefinido cada vez que bytes são "
"recebidos ou enviados. O tempo limite do socket é agora a duração total "
"máxima para ler até *len* bytes."

#: ../../library/ssl.rst:1123
msgid "Use :meth:`~SSLSocket.recv` instead of :meth:`~SSLSocket.read`."
msgstr "Use :meth:`~SSLSocket.recv` em vez de :meth:`~SSLSocket.read`."

#: ../../library/ssl.rst:1128
msgid ""
"Write *data* to the SSL socket and return the number of bytes written. The "
"*data* argument must be an object supporting the buffer interface."
msgstr ""
"Escreve *data* no socket SSL e retorna o número de bytes escritos. O "
"argumento *data* deve ser um objeto que suporte a interface de buffer."

#: ../../library/ssl.rst:1131
msgid ""
"Raise :exc:`SSLWantReadError` or :exc:`SSLWantWriteError` if the socket is :"
"ref:`non-blocking <ssl-nonblocking>` and the write would block."
msgstr ""
"Levanta :exc:`SSLWantReadError` ou :exc:`SSLWantWriteError` se o socket for :"
"ref:`não bloqueante <ssl-nonblocking>` e a escrita bloqueasse."

#: ../../library/ssl.rst:1134
msgid ""
"As at any time a re-negotiation is possible, a call to :meth:`write` can "
"also cause read operations."
msgstr ""
"Como a qualquer momento uma renegociação é possível, uma chamada a :meth:"
"`write` também pode causar operações de leitura."

#: ../../library/ssl.rst:1137
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration to write *data*."
msgstr ""
"O tempo limite do socket já não é redefinido cada vez que bytes são "
"recebidos ou enviados. O tempo limite do socket é agora a duração total "
"máxima para escrever *data*."

#: ../../library/ssl.rst:1141
msgid "Use :meth:`~SSLSocket.send` instead of :meth:`~SSLSocket.write`."
msgstr "Use :meth:`~SSLSocket.send` em vez de :meth:`~SSLSocket.write`."

#: ../../library/ssl.rst:1146
msgid ""
"The :meth:`~SSLSocket.read` and :meth:`~SSLSocket.write` methods are the low-"
"level methods that read and write unencrypted, application-level data and "
"decrypt/encrypt it to encrypted, wire-level data. These methods require an "
"active SSL connection, i.e. the handshake was completed and :meth:`SSLSocket."
"unwrap` was not called."
msgstr ""
"Os métodos :meth:`~SSLSocket.read` e :meth:`~SSLSocket.write` são os métodos "
"de baixo nível que leem e escrevem dados não encriptados, a nível de "
"aplicação, e os desencriptam/encriptam para dados encriptados, a nível de "
"linha. Estes métodos requerem uma ligação SSL ativa, ou seja, o handshake "
"foi concluído e :meth:`SSLSocket.unwrap` não foi chamado."

#: ../../library/ssl.rst:1152
msgid ""
"Normally you should use the socket API methods like :meth:`~socket.socket."
"recv` and :meth:`~socket.socket.send` instead of these methods."
msgstr ""
"Normalmente, deve usar os métodos da API de socket como :meth:`~socket."
"socket.recv` e :meth:`~socket.socket.send` em vez destes métodos."

#: ../../library/ssl.rst:1158
msgid "Perform the SSL setup handshake."
msgstr "Executa o handshake de configuração SSL."

#: ../../library/ssl.rst:1160
msgid ""
"If *block* is true and the timeout obtained by :meth:`~socket.socket."
"gettimeout` is zero, the socket is set in blocking mode until the handshake "
"is performed."
msgstr ""
"Se *block* for verdadeiro e o tempo limite obtido por :meth:`~socket.socket."
"gettimeout` for zero, o socket é definido em modo bloqueante até que o "
"handshake seja executado."

#: ../../library/ssl.rst:1163
msgid ""
"The handshake method also performs :func:`!match_hostname` when the :attr:"
"`~SSLContext.check_hostname` attribute of the socket's :attr:`~SSLSocket."
"context` is true."
msgstr ""
"O método handshake também executa :func:`!match_hostname` quando o atributo :"
"attr:`~SSLContext.check_hostname` do contexto do socket :attr:`~SSLSocket."
"context` for verdadeiro."

#: ../../library/ssl.rst:1168
msgid ""
"The socket timeout is no longer reset each time bytes are received or sent. "
"The socket timeout is now the maximum total duration of the handshake."
msgstr ""
"O tempo limite do socket já não é redefinido cada vez que bytes são "
"recebidos ou enviados. O tempo limite do socket é agora a duração total "
"máxima do handshake."

#: ../../library/ssl.rst:1172
msgid ""
"Hostname or IP address is matched by OpenSSL during handshake. The function :"
"func:`!match_hostname` is no longer used. In case OpenSSL refuses a hostname "
"or IP address, the handshake is aborted early and a TLS alert message is "
"sent to the peer."
msgstr ""
"O nome de host ou endereço IP é verificado pelo OpenSSL durante o handshake. "
"A função :func:`!match_hostname` já não é usada. Caso o OpenSSL recuse um "
"nome de host ou endereço IP, o handshake é abortado precocemente e uma "
"mensagem de alerta TLS é enviada para o par."

#: ../../library/ssl.rst:1180
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"return ``None``.  If the SSL handshake hasn't been done yet, raise :exc:"
"`ValueError`."
msgstr ""
"Se não houver certificado para o par na outra extremidade da ligação, "
"retorna ``None``. Se o handshake SSL ainda não tiver sido feito, levanta :"
"exc:`ValueError`."

#: ../../library/ssl.rst:1184
msgid ""
"If the ``binary_form`` parameter is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""
"Se o parâmetro ``binary_form`` for :const:`False` e um certificado tiver "
"sido recebido do par, este método retorna uma instância :class:`dict`. Se o "
"certificado não tiver sido validado, o dicionário está vazio. Se o "
"certificado tiver sido validado, retorna um dicionário com várias chaves, "
"entre elas ``subject`` (o principal para o qual o certificado foi emitido) e "
"``issuer`` (o principal que emite o certificado). Se um certificado contiver "
"uma instância da extensão *Subject Alternative Name* (consulte :rfc:`3280`), "
"também haverá uma chave ``subjectAltName`` no dicionário."

#: ../../library/ssl.rst:1193
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""
"Os campos ``subject`` e ``issuer`` são tuplos contendo a sequência de nomes "
"distintos relativos (RDNs) dados na estrutura de dados do certificado para "
"os respetivos campos, e cada RDN é uma sequência de pares nome-valor. Aqui "
"está um exemplo real::"

#: ../../library/ssl.rst:1198
msgid ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"
msgstr ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Assinatura Digital Segura'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"

#: ../../library/ssl.rst:1217
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  Whether the peer provides a certificate depends on the SSL "
"socket's role:"
msgstr ""
"Se o parâmetro ``binary_form`` for :const:`True` e um certificado tiver sido "
"fornecido, este método retorna a forma codificada em DER de todo o "
"certificado como uma sequência de bytes, ou :const:`None` se o par não "
"forneceu um certificado. Se o par fornece um certificado depende do papel do "
"socket SSL:"

#: ../../library/ssl.rst:1223
msgid ""
"for a client SSL socket, the server will always provide a certificate, "
"regardless of whether validation was required;"
msgstr ""
"para um socket SSL do cliente, o servidor fornecerá sempre um certificado, "
"independentemente de a validação ser necessária;"

#: ../../library/ssl.rst:1226
msgid ""
"for a server SSL socket, the client will only provide a certificate when "
"requested by the server; therefore :meth:`getpeercert` will return :const:"
"`None` if you used :const:`CERT_NONE` (rather than :const:`CERT_OPTIONAL` "
"or :const:`CERT_REQUIRED`)."
msgstr ""
"para um socket SSL do servidor, o cliente fornecerá um certificado apenas "
"quando solicitado pelo servidor; portanto, :meth:`getpeercert` retornará :"
"const:`None` se tiver usado :const:`CERT_NONE` (em vez de :const:"
"`CERT_OPTIONAL` ou :const:`CERT_REQUIRED`)."

#: ../../library/ssl.rst:1231
msgid "See also :attr:`SSLContext.check_hostname`."
msgstr "Veja também :attr:`SSLContext.check_hostname`."

#: ../../library/ssl.rst:1233
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""
"O dicionário retornado inclui itens adicionais como ``issuer`` e "
"``notBefore``."

#: ../../library/ssl.rst:1237
msgid ""
":exc:`ValueError` is raised when the handshake isn't done. The returned "
"dictionary includes additional X509v3 extension items   such as "
"``crlDistributionPoints``, ``caIssuers`` and ``OCSP`` URIs."
msgstr ""
":exc:`ValueError` é levantado quando o handshake não está feito. O "
"dicionário retornado inclui itens adicionais de extensão X509v3, como "
"``crlDistributionPoints``, ``caIssuers`` e URIs ``OCSP``."

#: ../../library/ssl.rst:1242
msgid "IPv6 address strings no longer have a trailing new line."
msgstr "As strings de endereço IPv6 já não têm uma nova linha no final."

#: ../../library/ssl.rst:1247
msgid ""
"Returns verified certificate chain provided by the other end of the SSL "
"channel as a list of DER-encoded bytes. If certificate verification was "
"disabled method acts the same as :meth:`~SSLSocket.get_unverified_chain`."
msgstr ""
"Retorna a cadeia de certificados verificada fornecida pela outra extremidade "
"do canal SSL como uma lista de bytes codificados em DER. Se a verificação de "
"certificados estiver desativada, o método atua da mesma forma que :meth:"
"`~SSLSocket.get_unverified_chain`."

#: ../../library/ssl.rst:1256
msgid ""
"Returns raw certificate chain provided by the other end of the SSL channel "
"as a list of DER-encoded bytes."
msgstr ""
"Retorna a cadeia de certificados bruta fornecida pela outra extremidade do "
"canal SSL como uma lista de bytes codificados em DER."

#: ../../library/ssl.rst:1263
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""
"Retorna um tuplo de três valores contendo o nome da cifra em uso, a versão "
"do protocolo SSL que define o seu uso e o número de bits secretos em uso. Se "
"nenhuma ligação tiver sido estabelecida, retorna ``None``."

#: ../../library/ssl.rst:1269
msgid ""
"Return the list of ciphers available in both the client and server.  Each "
"entry of the returned list is a three-value tuple containing the name of the "
"cipher, the version of the SSL protocol that defines its use, and the number "
"of secret bits the cipher uses.  :meth:`~SSLSocket.shared_ciphers` returns "
"``None`` if no connection has been established or the socket is a client "
"socket."
msgstr ""
"Retorna a lista de cifras disponíveis tanto no cliente como no servidor. "
"Cada entrada da lista retornada é um tuplo de três valores contendo o nome "
"da cifra, a versão do protocolo SSL que define o seu uso e o número de bits "
"secretos que a cifra usa. :meth:`~SSLSocket.shared_ciphers` retorna ``None`` "
"se nenhuma ligação tiver sido estabelecida ou se o socket for um socket do "
"cliente."

#: ../../library/ssl.rst:1280
msgid ""
"Return the compression algorithm being used as a string, or ``None`` if the "
"connection isn't compressed."
msgstr ""
"Retorna o algoritmo de compressão em uso como uma string, ou ``None`` se a "
"ligação não estiver comprimida."

#: ../../library/ssl.rst:1283
msgid ""
"If the higher-level protocol supports its own compression mechanism, you can "
"use :data:`OP_NO_COMPRESSION` to disable SSL-level compression."
msgstr ""
"Se o protocolo de nível superior suportar o seu próprio mecanismo de "
"compressão, pode usar :data:`OP_NO_COMPRESSION` para desativar a compressão "
"a nível SSL."

#: ../../library/ssl.rst:1290
msgid ""
"Get channel binding data for current connection, as a bytes object.  Returns "
"``None`` if not connected or the handshake has not been completed."
msgstr ""
"Obtém dados de ligação de canal para a ligação atual, como um objeto bytes. "
"Retorna ``None`` se não estiver ligado ou se o handshake não tiver sido "
"concluído."

#: ../../library/ssl.rst:1293
msgid ""
"The *cb_type* parameter allow selection of the desired channel binding type. "
"Valid channel binding types are listed in the :data:`CHANNEL_BINDING_TYPES` "
"list.  Currently only the 'tls-unique' channel binding, defined by :rfc:"
"`5929`, is supported.  :exc:`ValueError` will be raised if an unsupported "
"channel binding type is requested."
msgstr ""
"O parâmetro *cb_type* permite a seleção do tipo de ligação de canal "
"desejado. Os tipos de ligação de canal válidos estão listados na lista :data:"
"`CHANNEL_BINDING_TYPES`. Atualmente, apenas a ligação de canal 'tls-unique', "
"definida por :rfc:`5929`, é suportada. :exc:`ValueError` será levantado se "
"for solicitado um tipo de ligação de canal não suportado."

#: ../../library/ssl.rst:1303
msgid ""
"Return the protocol that was selected during the TLS handshake.  If :meth:"
"`SSLContext.set_alpn_protocols` was not called, if the other party does not "
"support ALPN, if this socket does not support any of the client's proposed "
"protocols, or if the handshake has not happened yet, ``None`` is returned."
msgstr ""
"Retorna o protocolo que foi selecionado durante o handshake TLS. Se :meth:"
"`SSLContext.set_alpn_protocols` não tiver sido chamado, se a outra parte não "
"suportar ALPN, se este socket não suportar nenhum dos protocolos propostos "
"pelo cliente, ou se o handshake ainda não tiver ocorrido, ``None`` é "
"retornado."

#: ../../library/ssl.rst:1313
msgid ""
"Return the higher-level protocol that was selected during the TLS/SSL "
"handshake. If :meth:`SSLContext.set_npn_protocols` was not called, or if the "
"other party does not support NPN, or if the handshake has not yet happened, "
"this will return ``None``."
msgstr ""
"Retorna o protocolo de nível superior que foi selecionado durante o "
"handshake TLS/SSL. Se :meth:`SSLContext.set_npn_protocols` não tiver sido "
"chamado, ou se a outra parte não suportar NPN, ou se o handshake ainda não "
"tiver ocorrido, isto retornará ``None``."

#: ../../library/ssl.rst:1322 ../../library/ssl.rst:1691
msgid "NPN has been superseded by ALPN"
msgstr "NPN foi substituído por ALPN"

#: ../../library/ssl.rst:1326
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""
"Executa o handshake de encerramento SSL, que remove a camada TLS do socket "
"subjacente e retorna o objeto socket subjacente. Isto pode ser usado para "
"passar de uma operação encriptada numa ligação para não encriptada. O socket "
"retornado deve ser sempre usado para comunicação adicional com o outro lado "
"da ligação, em vez do socket original."

#: ../../library/ssl.rst:1334
msgid ""
"Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can "
"only be initiated for a TLS 1.3 connection from a server-side socket, after "
"the initial TLS handshake and with PHA enabled on both sides, see :attr:"
"`SSLContext.post_handshake_auth`."
msgstr ""
"Solicita autenticação pós-handshake (PHA) de um cliente TLS 1.3. A PHA só "
"pode ser iniciada para uma ligação TLS 1.3 a partir de um socket do lado do "
"servidor, após o handshake TLS inicial e com PHA ativada em ambos os lados; "
"consulte :attr:`SSLContext.post_handshake_auth`."

#: ../../library/ssl.rst:1339
msgid ""
"The method does not perform a cert exchange immediately. The server-side "
"sends a CertificateRequest during the next write event and expects the "
"client to respond with a certificate on the next read event."
msgstr ""
"O método não executa uma troca de certificados imediatamente. O lado do "
"servidor envia um CertificateRequest durante o próximo evento de escrita e "
"espera que o cliente responda com um certificado no próximo evento de "
"leitura."

#: ../../library/ssl.rst:1343
msgid ""
"If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an :exc:"
"`SSLError` is raised."
msgstr ""
"Se qualquer pré-condição não for cumprida (por exemplo, não é TLS 1.3, PHA "
"não ativada), é levantado um :exc:`SSLError`."

#: ../../library/ssl.rst:1347
msgid ""
"Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 "
"support, the method raises :exc:`NotImplementedError`."
msgstr ""
"Disponível apenas com OpenSSL 1.1.1 e TLS 1.3 ativado. Sem suporte para TLS "
"1.3, o método levanta :exc:`NotImplementedError`."

#: ../../library/ssl.rst:1354
msgid ""
"Return the actual SSL protocol version negotiated by the connection as a "
"string, or ``None`` if no secure connection is established. As of this "
"writing, possible return values include ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` and ``\"TLSv1.2\"``. Recent OpenSSL versions "
"may define more return values."
msgstr ""
"Retorna a versão do protocolo SSL negociada pela ligação como uma string, ou "
"``None`` se nenhuma ligação segura estiver estabelecida. Atualmente, os "
"valores de retorno possíveis incluem ``\"SSLv2\"``, ``\"SSLv3\"``, "
"``\"TLSv1\"``, ``\"TLSv1.1\"`` e ``\"TLSv1.2\"``. Versões recentes do "
"OpenSSL podem definir mais valores de retorno."

#: ../../library/ssl.rst:1364
msgid ""
"Returns the number of already decrypted bytes available for read, pending on "
"the connection."
msgstr ""
"Retorna o número de bytes já desencriptados disponíveis para leitura, "
"pendentes na ligação."

#: ../../library/ssl.rst:1369
msgid "The :class:`SSLContext` object this SSL socket is tied to."
msgstr "O objeto :class:`SSLContext` ao qual este socket SSL está associado."

#: ../../library/ssl.rst:1375
msgid ""
"A boolean which is ``True`` for server-side sockets and ``False`` for client-"
"side sockets."
msgstr ""
"Um booleano que é ``True`` para sockets do lado do servidor e ``False`` para "
"sockets do lado do cliente."

#: ../../library/ssl.rst:1382
msgid ""
"Hostname of the server: :class:`str` type, or ``None`` for server-side "
"socket or if the hostname was not specified in the constructor."
msgstr ""
"Nome de host do servidor: tipo :class:`str`, ou ``None`` para socket do lado "
"do servidor ou se o nome de host não tiver sido especificado no construtor."

#: ../../library/ssl.rst:1387
msgid ""
"The attribute is now always ASCII text. When ``server_hostname`` is an "
"internationalized domain name (IDN), this attribute now stores the A-label "
"form (``\"xn--pythn-mua.org\"``), rather than the U-label form (``\"pythön."
"org\"``)."
msgstr ""
"O atributo é agora sempre texto ASCII. Quando ``server_hostname`` é um nome "
"de domínio internacionalizado (IDN), este atributo armazena agora a forma A-"
"label (``\"xn--pythn-mua.org\"``), em vez da forma U-label (``\"pythön."
"org\"``)."

#: ../../library/ssl.rst:1395
msgid ""
"The :class:`SSLSession` for this SSL connection. The session is available "
"for client and server side sockets after the TLS handshake has been "
"performed. For client sockets the session can be set before :meth:"
"`~SSLSocket.do_handshake` has been called to reuse a session."
msgstr ""
"A :class:`SSLSession` para esta ligação SSL. A sessão está disponível para "
"sockets do lado do cliente e do servidor após o handshake TLS ter sido "
"executado. Para sockets do cliente, a sessão pode ser definida antes de :"
"meth:`~SSLSocket.do_handshake` ser chamada para reutilizar uma sessão."

#: ../../library/ssl.rst:1408
msgid "SSL Contexts"
msgstr "Contexto SSL"

#: ../../library/ssl.rst:1412
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""
"Um contexto SSL contém vários dados com uma vida útil maior do que ligações "
"SSL individuais, como opções de configuração SSL, certificado(s) e chave(s) "
"privada(s). Também gere uma cache de sessões SSL para sockets do lado do "
"servidor, a fim de acelerar ligações repetidas dos mesmos clientes."

#: ../../library/ssl.rst:1419
msgid ""
"Create a new SSL context.  You may pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module.  The parameter specifies "
"which version of the SSL protocol to use.  Typically, the server chooses a "
"particular protocol version, and the client must adapt to the server's "
"choice.  Most of the versions are not interoperable with the other "
"versions.  If not specified, the default is :data:`PROTOCOL_TLS`; it "
"provides the most compatibility with other versions."
msgstr ""
"Cria um novo contexto SSL. Pode passar *protocol*, que deve ser uma das "
"constantes ``PROTOCOL_*`` definidas neste módulo. O parâmetro especifica "
"qual a versão do protocolo SSL a usar. Normalmente, o servidor escolhe uma "
"versão específica do protocolo, e o cliente deve adaptar-se à escolha do "
"servidor. A maioria das versões não é interoperável com as outras versões. "
"Se não for especificado, o predefinido é :data:`PROTOCOL_TLS`; fornece a "
"maior compatibilidade com outras versões."

#: ../../library/ssl.rst:1428
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""
"Aqui está uma tabela mostrando quais versões num cliente (no lado) podem "
"ligar-se a quais versões num servidor (no topo):"

#: ../../library/ssl.rst:1434
msgid "*client* / **server**"
msgstr "*cliente* / **servidor**"

#: ../../library/ssl.rst:1434
msgid "**SSLv2**"
msgstr "**SSLv2**"

#: ../../library/ssl.rst:1434
msgid "**SSLv3**"
msgstr "**SSLv3**"

#: ../../library/ssl.rst:1434
msgid "**TLS** [3]_"
msgstr "**TLS** [3]_"

#: ../../library/ssl.rst:1434
msgid "**TLSv1**"
msgstr "**TLSv1**"

#: ../../library/ssl.rst:1434
msgid "**TLSv1.1**"
msgstr "**TLSv1.1**"

#: ../../library/ssl.rst:1434
msgid "**TLSv1.2**"
msgstr "**TLSv1.2**"

#: ../../library/ssl.rst:1436
msgid "*SSLv2*"
msgstr "*SSLv2*"

#: ../../library/ssl.rst:1436 ../../library/ssl.rst:1437
#: ../../library/ssl.rst:1438 ../../library/ssl.rst:1439
#: ../../library/ssl.rst:1440 ../../library/ssl.rst:1441
msgid "yes"
msgstr "sim"

#: ../../library/ssl.rst:1436 ../../library/ssl.rst:1437
#: ../../library/ssl.rst:1439 ../../library/ssl.rst:1440
#: ../../library/ssl.rst:1441
msgid "no"
msgstr "não"

#: ../../library/ssl.rst:1436 ../../library/ssl.rst:1438
msgid "no [1]_"
msgstr "não [1]_"

#: ../../library/ssl.rst:1437
msgid "*SSLv3*"
msgstr "*SSLv3*"

#: ../../library/ssl.rst:1437 ../../library/ssl.rst:1438
msgid "no [2]_"
msgstr "não [2]_"

#: ../../library/ssl.rst:1438
msgid "*TLS* (*SSLv23*) [3]_"
msgstr "*TLS* (*SSLv23*) [3]_"

#: ../../library/ssl.rst:1439
msgid "*TLSv1*"
msgstr "*TLSv1*"

#: ../../library/ssl.rst:1440
msgid "*TLSv1.1*"
msgstr "*TLSv1.1*"

#: ../../library/ssl.rst:1441
msgid "*TLSv1.2*"
msgstr "*TLSv1.2*"

#: ../../library/ssl.rst:1444
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/ssl.rst:1445
msgid ":class:`SSLContext` disables SSLv2 with :data:`OP_NO_SSLv2` by default."
msgstr ""
":class:`SSLContext` desativa SSLv2 com :data:`OP_NO_SSLv2` por predefinição."

#: ../../library/ssl.rst:1446
msgid ":class:`SSLContext` disables SSLv3 with :data:`OP_NO_SSLv3` by default."
msgstr ""
":class:`SSLContext` desativa SSLv3 com :data:`OP_NO_SSLv3` por predefinição."

#: ../../library/ssl.rst:1447
msgid ""
"TLS 1.3 protocol will be available with :data:`PROTOCOL_TLS` in OpenSSL >= "
"1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3."
msgstr ""
"O protocolo TLS 1.3 estará disponível com :data:`PROTOCOL_TLS` em OpenSSL >= "
"1.1.1. Não existe uma constante PROTOCOL dedicada apenas para TLS 1.3."

#: ../../library/ssl.rst:1452
msgid ""
":func:`create_default_context` lets the :mod:`ssl` module choose security "
"settings for a given purpose."
msgstr ""
":func:`create_default_context` permite que o módulo :mod:`ssl` escolha as "
"configurações de segurança para um determinado propósito."

#: ../../library/ssl.rst:1457
msgid ""
"The context is created with secure default values. The options :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2`, and :"
"data:`OP_NO_SSLv3` (except for :data:`PROTOCOL_SSLv3`) are set by default. "
"The initial cipher suite list contains only ``HIGH`` ciphers, no ``NULL`` "
"ciphers and no ``MD5`` ciphers."
msgstr ""
"O contexto é criado com valores predefinidos seguros. As opções :data:"
"`OP_NO_COMPRESSION`, :data:`OP_CIPHER_SERVER_PREFERENCE`, :data:"
"`OP_SINGLE_DH_USE`, :data:`OP_SINGLE_ECDH_USE`, :data:`OP_NO_SSLv2` e :data:"
"`OP_NO_SSLv3` (exceto para :data:`PROTOCOL_SSLv3`) são definidas por "
"predefinição. A lista inicial de suites de cifras contém apenas cifras "
"``HIGH``, sem cifras ``NULL`` e sem cifras ``MD5``."

#: ../../library/ssl.rst:1467
msgid ""
":class:`SSLContext` without protocol argument is deprecated. The context "
"class will either require :data:`PROTOCOL_TLS_CLIENT` or :data:"
"`PROTOCOL_TLS_SERVER` protocol in the future."
msgstr ""
":class:`SSLContext` sem argumento de protocolo está obsoleto. A classe de "
"contexto irá requerer o protocolo :data:`PROTOCOL_TLS_CLIENT` ou :data:"
"`PROTOCOL_TLS_SERVER` no futuro."

#: ../../library/ssl.rst:1473
msgid ""
"The default cipher suites now include only secure AES and ChaCha20 ciphers "
"with forward secrecy and security level 2. RSA and DH keys with less than "
"2048 bits and ECC keys with less than 224 bits are prohibited. :data:"
"`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT`, and :data:`PROTOCOL_TLS_SERVER` "
"use TLS 1.2 as minimum TLS version."
msgstr ""
"As suites de cifras predefinidas incluem agora apenas cifras AES e ChaCha20 "
"seguras com confidencialidade futura e nível de segurança 2. Chaves RSA e DH "
"com menos de 2048 bits e chaves ECC com menos de 224 bits são proibidas. :"
"data:`PROTOCOL_TLS`, :data:`PROTOCOL_TLS_CLIENT` e :data:"
"`PROTOCOL_TLS_SERVER` usam TLS 1.2 como versão mínima do TLS."

#: ../../library/ssl.rst:1481
msgid ""
":class:`SSLContext` only supports limited mutation once it has been used by "
"a connection. Adding new certificates to the internal trust store is "
"allowed, but changing ciphers, verification settings, or mTLS certificates "
"may result in surprising behavior."
msgstr ""
":class:`SSLContext` suporta apenas mutação limitada depois de ter sido usado "
"por uma ligação. Adicionar novos certificados à loja de confiança interna é "
"permitido, mas alterar cifras, configurações de verificação ou certificados "
"mTLS pode resultar em comportamento surpreendente."

#: ../../library/ssl.rst:1488
msgid ""
":class:`SSLContext` is designed to be shared and used by multiple "
"connections. Thus, it is thread-safe as long as it is not reconfigured after "
"being used by a connection."
msgstr ""
":class:`SSLContext` é concebido para ser partilhado e usado por várias "
"ligações. Assim, é seguro para threads desde que não seja reconfigurado após "
"ser usado por uma ligação."

#: ../../library/ssl.rst:1493
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr "Os objetos :class:`SSLContext` têm os seguintes métodos e atributos:"

#: ../../library/ssl.rst:1497
msgid ""
"Get statistics about quantities of loaded X.509 certificates, count of X.509 "
"certificates flagged as CA certificates and certificate revocation lists as "
"dictionary."
msgstr ""
"Obtém estatísticas sobre quantidades de certificados X.509 carregados, "
"contagem de certificados X.509 marcados como certificados CA e listas de "
"revogação de certificados como dicionário."

#: ../../library/ssl.rst:1501
msgid "Example for a context with one CA cert and one other cert::"
msgstr "Exemplo para um contexto com um certificado CA e outro certificado::"

#: ../../library/ssl.rst:1503
msgid ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"
msgstr ""
">>> context.cert_store_stats()\n"
"{'crl': 0, 'x509_ca': 1, 'x509': 2}"

#: ../../library/ssl.rst:1511
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key.  Otherwise the private key will be taken "
"from *certfile* as well.  See the discussion of :ref:`ssl-certificates` for "
"more information on how the certificate is stored in the *certfile*."
msgstr ""
"Carrega uma chave privada e o certificado correspondente. A string "
"*certfile* deve ser o caminho para um único ficheiro em formato PEM contendo "
"o certificado, bem como qualquer número de certificados CA necessários para "
"estabelecer a autenticidade do certificado. A string *keyfile*, se presente, "
"deve apontar para um ficheiro contendo a chave privada. Caso contrário, a "
"chave privada será obtida de *certfile*. Consulte a discussão de :ref:`ssl-"
"certificates` para mais informações sobre como o certificado é armazenado no "
"*certfile*."

#: ../../library/ssl.rst:1520
msgid ""
"The *password* argument may be a function to call to get the password for "
"decrypting the private key.  It will only be called if the private key is "
"encrypted and a password is necessary.  It will be called with no arguments, "
"and it should return a string, bytes, or bytearray.  If the return value is "
"a string it will be encoded as UTF-8 before using it to decrypt the key. "
"Alternatively a string, bytes, or bytearray value may be supplied directly "
"as the *password* argument.  It will be ignored if the private key is not "
"encrypted and no password is needed."
msgstr ""
"O argumento *password* pode ser uma função a chamar para obter a palavra-"
"passe para desencriptar a chave privada. Só será chamada se a chave privada "
"estiver encriptada e uma palavra-passe for necessária. Será chamada sem "
"argumentos e deve retornar uma string, bytes ou bytearray. Se o valor de "
"retorno for uma string, será codificado como UTF-8 antes de ser usado para "
"desencriptar a chave. Alternativamente, um valor de string, bytes ou "
"bytearray pode ser fornecido diretamente como argumento *password*. Será "
"ignorado se a chave privada não estiver encriptada e nenhuma palavra-passe "
"for necessária."

#: ../../library/ssl.rst:1529
msgid ""
"If the *password* argument is not specified and a password is required, "
"OpenSSL's built-in password prompting mechanism will be used to "
"interactively prompt the user for a password."
msgstr ""
"Se o argumento *password* não for especificado e uma palavra-passe for "
"necessária, o mecanismo integrado de solicitação de palavra-passe do OpenSSL "
"será usado para solicitar interativamente a palavra-passe ao utilizador."

#: ../../library/ssl.rst:1533
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""
"É levantado um :class:`SSLError` se a chave privada não corresponder ao "
"certificado."

#: ../../library/ssl.rst:1536
msgid "New optional argument *password*."
msgstr "Novo argumento opcional *password*."

#: ../../library/ssl.rst:1541
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from "
"default locations. On Windows it loads CA certs from the ``CA`` and ``ROOT`` "
"system stores. On all systems it calls :meth:`SSLContext."
"set_default_verify_paths`. In the future the method may load CA certificates "
"from other locations, too."
msgstr ""
"Carrega um conjunto de certificados de \"autoridade de certificação\" (CA) "
"predefinidos a partir de locais predefinidos. No Windows, carrega "
"certificados CA das lojas de sistema ``CA`` e ``ROOT``. Em todos os "
"sistemas, chama :meth:`SSLContext.set_default_verify_paths`. No futuro, o "
"método pode carregar certificados CA de outros locais também."

#: ../../library/ssl.rst:1547
msgid ""
"The *purpose* flag specifies what kind of CA certificates are loaded. The "
"default settings :const:`Purpose.SERVER_AUTH` loads certificates, that are "
"flagged and trusted for TLS web server authentication (client side "
"sockets). :const:`Purpose.CLIENT_AUTH` loads CA certificates for client "
"certificate verification on the server side."
msgstr ""
"A flag *purpose* especifica que tipo de certificados CA são carregados. As "
"configurações predefinidas :const:`Purpose.SERVER_AUTH` carregam "
"certificados que estão marcados e são confiáveis para autenticação de "
"servidores web TLS (sockets do lado do cliente). :const:`Purpose."
"CLIENT_AUTH` carrega certificados CA para verificação de certificados de "
"cliente no lado do servidor."

#: ../../library/ssl.rst:1557
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""
"Carrega um conjunto de certificados de \"autoridade de certificação\" (CA) "
"usados para validar certificados de outros pares quando :data:`verify_mode` "
"é diferente de :data:`CERT_NONE`. Pelo menos um de *cafile* ou *capath* deve "
"ser especificado."

#: ../../library/ssl.rst:1561
msgid ""
"This method can also load certification revocation lists (CRLs) in PEM or "
"DER format. In order to make use of CRLs, :attr:`SSLContext.verify_flags` "
"must be configured properly."
msgstr ""
"Este método também pode carregar listas de revogação de certificados (CRLs) "
"em formato PEM ou DER. Para utilizar CRLs, :attr:`SSLContext.verify_flags` "
"deve ser configurado corretamente."

#: ../../library/ssl.rst:1565
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""
"A string *cafile*, se presente, é o caminho para um ficheiro de certificados "
"CA concatenados em formato PEM. Consulte a discussão de :ref:`ssl-"
"certificates` para mais informações sobre como organizar os certificados "
"neste ficheiro."

#: ../../library/ssl.rst:1570
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/>`_."
msgstr ""
"A string *capath*, se presente, é o caminho para um diretório contendo "
"vários certificados CA em formato PEM, seguindo um `layout específico do "
"OpenSSL <https://docs.openssl.org/master/man3/SSL_CTX_load_verify_locations/"
">`_."

#: ../../library/ssl.rst:1575
msgid ""
"The *cadata* object, if present, is either an ASCII string of one or more "
"PEM-encoded certificates or a :term:`bytes-like object` of DER-encoded "
"certificates. Like with *capath* extra lines around PEM-encoded certificates "
"are ignored but at least one certificate must be present."
msgstr ""
"O objeto *cadata*, se presente, é uma string ASCII de um ou mais "
"certificados codificados em PEM ou um objeto :term:`bytes-like` de "
"certificados codificados em DER. Tal como com *capath*, linhas extra em "
"torno de certificados codificados em PEM são ignoradas, mas pelo menos um "
"certificado deve estar presente."

#: ../../library/ssl.rst:1580
msgid "New optional argument *cadata*"
msgstr "Novo argumento opcional *cadata*"

#: ../../library/ssl.rst:1585
msgid ""
"Get a list of loaded \"certification authority\" (CA) certificates. If the "
"``binary_form`` parameter is :const:`False` each list entry is a dict like "
"the output of :meth:`SSLSocket.getpeercert`. Otherwise the method returns a "
"list of DER-encoded certificates. The returned list does not contain "
"certificates from *capath* unless a certificate was requested and loaded by "
"a SSL connection."
msgstr ""
"Obtém uma lista de certificados de \"autoridade de certificação\" (CA) "
"carregados. Se o parâmetro ``binary_form`` for :const:`False`, cada entrada "
"da lista é um dicionário como a saída de :meth:`SSLSocket.getpeercert`. Caso "
"contrário, o método retorna uma lista de certificados codificados em DER. A "
"lista retornada não contém certificados de *capath* a menos que um "
"certificado tenha sido solicitado e carregado por uma ligação SSL."

#: ../../library/ssl.rst:1593
msgid ""
"Certificates in a capath directory aren't loaded unless they have been used "
"at least once."
msgstr ""
"Os certificados num diretório capath não são carregados a menos que tenham "
"sido usados pelo menos uma vez."

#: ../../library/ssl.rst:1600
msgid ""
"Get a list of enabled ciphers. The list is in order of cipher priority. See :"
"meth:`SSLContext.set_ciphers`."
msgstr ""
"Obtém uma lista de cifras ativadas. A lista está por ordem de prioridade de "
"cifras. Consulte :meth:`SSLContext.set_ciphers`."

#: ../../library/ssl.rst:1605
msgid ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"
msgstr ""
">>> ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> ctx.set_ciphers('ECDHE+AESGCM:!ECDSA')\n"
">>> ctx.get_ciphers()\n"
"[{'aead': True,\n"
"  'alg_bits': 256,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(256) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380848,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES256-GCM-SHA384',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 256,\n"
"  'symmetric': 'aes-256-gcm'},\n"
" {'aead': True,\n"
"  'alg_bits': 128,\n"
"  'auth': 'auth-rsa',\n"
"  'description': 'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '\n"
"                 'Enc=AESGCM(128) Mac=AEAD',\n"
"  'digest': None,\n"
"  'id': 50380847,\n"
"  'kea': 'kx-ecdhe',\n"
"  'name': 'ECDHE-RSA-AES128-GCM-SHA256',\n"
"  'protocol': 'TLSv1.2',\n"
"  'strength_bits': 128,\n"
"  'symmetric': 'aes-128-gcm'}]"

#: ../../library/ssl.rst:1637
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""
"Carrega um conjunto de certificados de \"autoridade de certificação\" (CA) "
"predefinidos a partir de um caminho do sistema de ficheiros definido ao "
"construir a biblioteca OpenSSL. Infelizmente, não há uma forma fácil de "
"saber se este método tem sucesso: nenhum erro é retornado se não forem "
"encontrados certificados. Quando a biblioteca OpenSSL é fornecida como parte "
"do sistema operativo, é provável que esteja configurada corretamente."

#: ../../library/ssl.rst:1646
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <https://docs.openssl.org/"
"master/man1/ciphers/>`_. If no cipher can be selected (because compile-time "
"options or other configuration forbids use of all the specified ciphers), "
"an :class:`SSLError` will be raised."
msgstr ""
"Define as cifras disponíveis para sockets criados com este contexto. Deve "
"ser uma string no `formato da lista de cifras do OpenSSL <https://docs."
"openssl.org/master/man1/ciphers/>`_. Se nenhuma cifra puder ser selecionada "
"(porque opções de tempo de compilação ou outra configuração proibem o uso de "
"todas as cifras especificadas), será levantado um :class:`SSLError`."

#: ../../library/ssl.rst:1654
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""
"quando ligado, o método :meth:`SSLSocket.cipher` dos sockets SSL dará a "
"cifra atualmente selecionada."

#: ../../library/ssl.rst:1657
msgid ""
"TLS 1.3 cipher suites cannot be disabled with :meth:`~SSLContext."
"set_ciphers`."
msgstr ""
"As suites de cifras TLS 1.3 não podem ser desativadas com :meth:`~SSLContext."
"set_ciphers`."

#: ../../library/ssl.rst:1662
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of ASCII strings, like ``['http/1.1', "
"'spdy/2']``, ordered by preference. The selection of a protocol will happen "
"during the handshake, and will play out according to :rfc:`7301`. After a "
"successful handshake, the :meth:`SSLSocket.selected_alpn_protocol` method "
"will return the agreed-upon protocol."
msgstr ""
"Especifica quais protocolos o socket deve anunciar durante o handshake SSL/"
"TLS. Deve ser uma lista de strings ASCII, como ``['http/1.1', 'spdy/2']``, "
"ordenada por preferência. A seleção de um protocolo acontecerá durante o "
"handshake e será executada de acordo com :rfc:`7301`. Após um handshake bem-"
"sucedido, o método :meth:`SSLSocket.selected_alpn_protocol` retornará o "
"protocolo acordado."

#: ../../library/ssl.rst:1669
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_ALPN` is "
"``False``."
msgstr ""
"Este método levantará :exc:`NotImplementedError` se :data:`HAS_ALPN` for "
"``False``."

#: ../../library/ssl.rst:1676
msgid ""
"Specify which protocols the socket should advertise during the SSL/TLS "
"handshake. It should be a list of strings, like ``['http/1.1', 'spdy/2']``, "
"ordered by preference. The selection of a protocol will happen during the "
"handshake, and will play out according to the `Application Layer Protocol "
"Negotiation <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. After a successful handshake, the :meth:"
"`SSLSocket.selected_npn_protocol` method will return the agreed-upon "
"protocol."
msgstr ""
"Especifica quais protocolos o socket deve anunciar durante o handshake SSL/"
"TLS. Deve ser uma lista de strings, como ``['http/1.1', 'spdy/2']``, "
"ordenada por preferência. A seleção de um protocolo acontecerá durante o "
"handshake e será executada de acordo com a `Negociação de Protocolo de "
"Camada de Aplicação <https://en.wikipedia.org/wiki/Application-"
"Layer_Protocol_Negotiation>`_. Após um handshake bem-sucedido, o método :"
"meth:`SSLSocket.selected_npn_protocol` retornará o protocolo acordado."

#: ../../library/ssl.rst:1684
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_NPN` is "
"``False``."
msgstr ""
"Este método levantará :exc:`NotImplementedError` se :data:`HAS_NPN` for "
"``False``."

#: ../../library/ssl.rst:1695
msgid ""
"Register a callback function that will be called after the TLS Client Hello "
"handshake message has been received by the SSL/TLS server when the TLS "
"client specifies a server name indication. The server name indication "
"mechanism is specified in :rfc:`6066` section 3 - Server Name Indication."
msgstr ""
"Regista uma função de retorno de chamada que será chamada após a mensagem de "
"handshake TLS Client Hello ter sido recebida pelo servidor SSL/TLS quando o "
"cliente TLS especifica uma indicação de nome de servidor. O mecanismo de "
"indicação de nome de servidor está especificado na secção 3 - Indicação de "
"Nome de Servidor do :rfc:`6066`."

#: ../../library/ssl.rst:1700
msgid ""
"Only one callback can be set per ``SSLContext``.  If *sni_callback* is set "
"to ``None`` then the callback is disabled. Calling this function a "
"subsequent time will disable the previously registered callback."
msgstr ""
"Apenas uma função de retorno de chamada pode ser definida por "
"``SSLContext``. Se *sni_callback* for definido como ``None``, a função de "
"retorno de chamada é desativada. Chamar esta função posteriormente "
"desativará a função de retorno de chamada previamente registada."

#: ../../library/ssl.rst:1704
msgid ""
"The callback function will be called with three arguments; the first being "
"the :class:`ssl.SSLSocket`, the second is a string that represents the "
"server name that the client is intending to communicate (or :const:`None` if "
"the TLS Client Hello does not contain a server name) and the third argument "
"is the original :class:`SSLContext`. The server name argument is text. For "
"internationalized domain name, the server name is an IDN A-label (``\"xn--"
"pythn-mua.org\"``)."
msgstr ""
"A função de retorno de chamada será chamada com três argumentos; o primeiro "
"é o :class:`ssl.SSLSocket`, o segundo é uma string que representa o nome do "
"servidor com o qual o cliente pretende comunicar (ou :const:`None` se o TLS "
"Client Hello não contiver um nome de servidor) e o terceiro argumento é o :"
"class:`SSLContext` original. O argumento do nome do servidor é texto. Para "
"nomes de domínio internacionalizados, o nome do servidor é um IDN A-label "
"(``\"xn--pythn-mua.org\"``)."

#: ../../library/ssl.rst:1712
msgid ""
"A typical use of this callback is to change the :class:`ssl.SSLSocket`'s :"
"attr:`SSLSocket.context` attribute to a new object of type :class:"
"`SSLContext` representing a certificate chain that matches the server name."
msgstr ""
"Uma utilização típica desta função de retorno de chamada é alterar o "
"atributo :attr:`SSLSocket.context` do :class:`ssl.SSLSocket` para um novo "
"objeto do tipo :class:`SSLContext` que representa uma cadeia de certificados "
"que corresponde ao nome do servidor."

#: ../../library/ssl.rst:1717
msgid ""
"Due to the early negotiation phase of the TLS connection, only limited "
"methods and attributes are usable like :meth:`SSLSocket."
"selected_alpn_protocol` and :attr:`SSLSocket.context`. The :meth:`SSLSocket."
"getpeercert`, :meth:`SSLSocket.get_verified_chain`, :meth:`SSLSocket."
"get_unverified_chain` :meth:`SSLSocket.cipher` and :meth:`SSLSocket."
"compression` methods require that the TLS connection has progressed beyond "
"the TLS Client Hello and therefore will not return meaningful values nor can "
"they be called safely."
msgstr ""
"Devido à fase inicial de negociação da ligação TLS, apenas métodos e "
"atributos limitados são utilizáveis, como :meth:`SSLSocket."
"selected_alpn_protocol` e :attr:`SSLSocket.context`. Os métodos :meth:"
"`SSLSocket.getpeercert`, :meth:`SSLSocket.get_verified_chain`, :meth:"
"`SSLSocket.get_unverified_chain`, :meth:`SSLSocket.cipher` e :meth:"
"`SSLSocket.compression` requerem que a ligação TLS tenha progredido além do "
"TLS Client Hello e, portanto, não retornarão valores significativos nem "
"podem ser chamados com segurança."

#: ../../library/ssl.rst:1726
msgid ""
"The *sni_callback* function must return ``None`` to allow the TLS "
"negotiation to continue.  If a TLS failure is required, a constant :const:"
"`ALERT_DESCRIPTION_* <ALERT_DESCRIPTION_INTERNAL_ERROR>` can be returned.  "
"Other return values will result in a TLS fatal error with :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR`."
msgstr ""
"A função *sni_callback* deve retornar ``None`` para permitir que a "
"negociação TLS continue. Se for necessário um falha TLS, pode ser retornada "
"uma constante :const:`ALERT_DESCRIPTION_* "
"<ALERT_DESCRIPTION_INTERNAL_ERROR>`. Outros valores de retorno resultarão "
"num erro fatal TLS com :const:`ALERT_DESCRIPTION_INTERNAL_ERROR`."

#: ../../library/ssl.rst:1732
msgid ""
"If an exception is raised from the *sni_callback* function the TLS "
"connection will terminate with a fatal TLS alert message :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."
msgstr ""
"Se uma exceção for levantada a partir da função *sni_callback*, a ligação "
"TLS terminará com uma mensagem de alerta fatal TLS :const:"
"`ALERT_DESCRIPTION_HANDSHAKE_FAILURE`."

#: ../../library/ssl.rst:1736
msgid ""
"This method will raise :exc:`NotImplementedError` if the OpenSSL library had "
"OPENSSL_NO_TLSEXT defined when it was built."
msgstr ""
"Este método levantará :exc:`NotImplementedError` se a biblioteca OpenSSL "
"tiver sido construída com OPENSSL_NO_TLSEXT definido."

#: ../../library/ssl.rst:1743
msgid ""
"This is a legacy API retained for backwards compatibility. When possible, "
"you should use :attr:`sni_callback` instead. The given "
"*server_name_callback* is similar to *sni_callback*, except that when the "
"server hostname is an IDN-encoded internationalized domain name, the "
"*server_name_callback* receives a decoded U-label (``\"pythön.org\"``)."
msgstr ""
"Esta é uma API legada mantida para compatibilidade retroativa. Sempre que "
"possível, deve usar :attr:`sni_callback` em vez disso. A função "
"*server_name_callback* dada é semelhante a *sni_callback*, exceto que, "
"quando o nome do servidor é um nome de domínio internacionalizado codificado "
"em IDN, o *server_name_callback* recebe um U-label descodificado (``\"pythön."
"org\"``)."

#: ../../library/ssl.rst:1749
msgid ""
"If there is a decoding error on the server name, the TLS connection will "
"terminate with an :const:`ALERT_DESCRIPTION_INTERNAL_ERROR` fatal TLS alert "
"message to the client."
msgstr ""
"Se houver um erro de descodificação no nome do servidor, a ligação TLS "
"terminará com uma mensagem de alerta fatal TLS :const:"
"`ALERT_DESCRIPTION_INTERNAL_ERROR` para o cliente."

#: ../../library/ssl.rst:1757
msgid ""
"Load the key generation parameters for Diffie-Hellman (DH) key exchange. "
"Using DH key exchange improves forward secrecy at the expense of "
"computational resources (both on the server and on the client). The *dhfile* "
"parameter should be the path to a file containing DH parameters in PEM "
"format."
msgstr ""
"Carrega os parâmetros de geração de chaves para a troca de chaves Diffie-"
"Hellman (DH). O uso da troca de chaves DH melhora a confidencialidade futura "
"à custa de recursos computacionais (tanto no servidor como no cliente). O "
"parâmetro *dhfile* deve ser o caminho para um ficheiro contendo parâmetros "
"DH em formato PEM."

#: ../../library/ssl.rst:1763
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_DH_USE` option to further improve security."
msgstr ""
"Esta configuração não se aplica a sockets de cliente. Também pode usar a "
"opção :data:`OP_SINGLE_DH_USE` para melhorar ainda mais a segurança."

#: ../../library/ssl.rst:1770
msgid ""
"Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key "
"exchange.  ECDH is significantly faster than regular DH while arguably as "
"secure.  The *curve_name* parameter should be a string describing a well-"
"known elliptic curve, for example ``prime256v1`` for a widely supported "
"curve."
msgstr ""
"Define o nome da curva para a troca de chaves Diffie-Hellman baseada em "
"Curvas Elípticas (ECDH). O ECDH é significativamente mais rápido do que o DH "
"regular, sendo igualmente seguro. O parâmetro *curve_name* deve ser uma "
"string que descreve uma curva elíptica bem conhecida, por exemplo, "
"``prime256v1`` para uma curva amplamente suportada."

#: ../../library/ssl.rst:1776
msgid ""
"This setting doesn't apply to client sockets.  You can also use the :data:"
"`OP_SINGLE_ECDH_USE` option to further improve security."
msgstr ""
"Esta configuração não se aplica a sockets de cliente. Também pode usar a "
"opção :data:`OP_SINGLE_ECDH_USE` para melhorar ainda mais a segurança."

#: ../../library/ssl.rst:1779
msgid "This method is not available if :data:`HAS_ECDH` is ``False``."
msgstr "Este método não está disponível se :data:`HAS_ECDH` for ``False``."

#: ../../library/ssl.rst:1784
msgid ""
"`SSL/TLS & Perfect Forward Secrecy <https://vincent.bernat.ch/en/blog/2011-"
"ssl-perfect-forward-secrecy>`_"
msgstr ""
"`SSL/TLS & Confidencialidade Perfeita Futura <https://vincent.bernat.ch/en/"
"blog/2011-ssl-perfect-forward-secrecy>`_"

#: ../../library/ssl.rst:1785
msgid "Vincent Bernat."
msgstr "Vincent Bernat."

#: ../../library/ssl.rst:1791
msgid ""
"Wrap an existing Python socket *sock* and return an instance of :attr:"
"`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The returned SSL "
"socket is tied to the context, its settings and certificates. *sock* must be "
"a :const:`~socket.SOCK_STREAM` socket; other socket types are unsupported."
msgstr ""
"Envolve um socket Python existente *sock* e retorna uma instância de :attr:"
"`SSLContext.sslsocket_class` (predefinido :class:`SSLSocket`). O socket SSL "
"retornado está associado ao contexto, às suas configurações e certificados. "
"*sock* deve ser um socket :const:`~socket.SOCK_STREAM`; outros tipos de "
"socket não são suportados."

#: ../../library/ssl.rst:1797
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""
"O parâmetro ``server_side`` é um booleano que identifica se o comportamento "
"desejado para este socket é do lado do servidor ou do lado do cliente."

#: ../../library/ssl.rst:1800
msgid ""
"For client-side sockets, the context construction is lazy; if the underlying "
"socket isn't connected yet, the context construction will be performed "
"after :meth:`connect` is called on the socket.  For server-side sockets, if "
"the socket has no remote peer, it is assumed to be a listening socket, and "
"the server-side SSL wrapping is automatically performed on client "
"connections accepted via the :meth:`accept` method. The method may raise :"
"exc:`SSLError`."
msgstr ""
"Para sockets do lado do cliente, a construção do contexto é preguiçosa; se o "
"socket subjacente ainda não estiver ligado, a construção do contexto será "
"realizada após :meth:`connect` ser chamado no socket. Para sockets do lado "
"do servidor, se o socket não tiver um par remoto, assume-se que é um socket "
"de escuta, e o envolvimento SSL do lado do servidor é realizado "
"automaticamente em ligações de clientes aceites através do método :meth:"
"`accept`. O método pode levantar :exc:`SSLError`."

#: ../../library/ssl.rst:1808
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts. Specifying "
"*server_hostname* will raise a :exc:`ValueError` if *server_side* is true."
msgstr ""
"Nas ligações do cliente, o parâmetro opcional *server_hostname* especifica o "
"nome do host do serviço ao qual nos estamos a ligar. Isto permite que um "
"único servidor aloje vários serviços baseados em SSL com certificados "
"distintos, de forma bastante semelhante aos hosts virtuais HTTP. Especificar "
"*server_hostname* levantará um :exc:`ValueError` se *server_side* for "
"verdadeiro."

#: ../../library/ssl.rst:1814
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""
"O parâmetro ``do_handshake_on_connect`` especifica se deve ser feito o "
"handshake SSL automaticamente após um :meth:`socket.connect`, ou se o "
"programa de aplicação o chamará explicitamente, invocando o método :meth:"
"`SSLSocket.do_handshake`. Chamar :meth:`SSLSocket.do_handshake` "
"explicitamente dá ao programa controlo sobre o comportamento de bloqueio do "
"I/O do socket envolvido no handshake."

#: ../../library/ssl.rst:1821
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""
"O parâmetro ``suppress_ragged_eofs`` especifica como o método :meth:"
"`SSLSocket.recv` deve sinalizar um EOF inesperado da outra extremidade da "
"ligação. Se especificado como :const:`True` (predefinição), retorna um EOF "
"normal (um objeto bytes vazio) em resposta a erros de EOF inesperados "
"levantados a partir do socket subjacente; se :const:`False`, levantará as "
"exceções de volta para o chamador."

#: ../../library/ssl.rst:1828
msgid "*session*, see :attr:`~SSLSocket.session`."
msgstr "*session*, consulte :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:1830
msgid ""
"To wrap an :class:`SSLSocket` in another :class:`SSLSocket`, use :meth:"
"`SSLContext.wrap_bio`."
msgstr ""
"Para envolver um :class:`SSLSocket` noutro :class:`SSLSocket`, use :meth:"
"`SSLContext.wrap_bio`."

#: ../../library/ssl.rst:1833
msgid ""
"Always allow a server_hostname to be passed, even if OpenSSL does not have "
"SNI."
msgstr ""
"Permitir sempre que um server_hostname seja passado, mesmo que o OpenSSL não "
"tenha SNI."

#: ../../library/ssl.rst:1837 ../../library/ssl.rst:1864
msgid "*session* argument was added."
msgstr "O argumento *session* foi adicionado."

#: ../../library/ssl.rst:1840
msgid ""
"The method returns an instance of :attr:`SSLContext.sslsocket_class` instead "
"of hard-coded :class:`SSLSocket`."
msgstr ""
"O método retorna uma instância de :attr:`SSLContext.sslsocket_class` em vez "
"de :class:`SSLSocket` codificado."

#: ../../library/ssl.rst:1846
msgid ""
"The return type of :meth:`SSLContext.wrap_socket`, defaults to :class:"
"`SSLSocket`. The attribute can be assigned to on instances of :class:"
"`SSLContext` in order to return a custom subclass of :class:`SSLSocket`."
msgstr ""
"O tipo de retorno de :meth:`SSLContext.wrap_socket`, predefinido para :class:"
"`SSLSocket`. O atributo pode ser atribuído a instâncias de :class:"
"`SSLContext` para retornar uma subclasse personalizada de :class:`SSLSocket`."

#: ../../library/ssl.rst:1856
msgid ""
"Wrap the BIO objects *incoming* and *outgoing* and return an instance of :"
"attr:`SSLContext.sslobject_class` (default :class:`SSLObject`). The SSL "
"routines will read input data from the incoming BIO and write data to the "
"outgoing BIO."
msgstr ""
"Envolve os objetos BIO *incoming* e *outgoing* e retorna uma instância de :"
"attr:`SSLContext.sslobject_class` (predefinido :class:`SSLObject`). As "
"rotinas SSL lerão dados de entrada do BIO de entrada e escreverão dados no "
"BIO de saída."

#: ../../library/ssl.rst:1861
msgid ""
"The *server_side*, *server_hostname* and *session* parameters have the same "
"meaning as in :meth:`SSLContext.wrap_socket`."
msgstr ""
"Os parâmetros *server_side*, *server_hostname* e *session* têm o mesmo "
"significado que em :meth:`SSLContext.wrap_socket`."

#: ../../library/ssl.rst:1867
msgid ""
"The method returns an instance of :attr:`SSLContext.sslobject_class` instead "
"of hard-coded :class:`SSLObject`."
msgstr ""
"O método retorna uma instância de :attr:`SSLContext.sslobject_class` em vez "
"de :class:`SSLObject` codificado."

#: ../../library/ssl.rst:1873
msgid ""
"The return type of :meth:`SSLContext.wrap_bio`, defaults to :class:"
"`SSLObject`. The attribute can be overridden on instance of class in order "
"to return a custom subclass of :class:`SSLObject`."
msgstr ""
"O tipo de retorno de :meth:`SSLContext.wrap_bio`, predefinido para :class:"
"`SSLObject`. O atributo pode ser substituído na instância da classe para "
"retornar uma subclasse personalizada de :class:`SSLObject`."

#: ../../library/ssl.rst:1881
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ to their "
"numeric values.  For example, here is the total number of hits and misses in "
"the session cache since the context was created::"
msgstr ""
"Obtém estatísticas sobre as sessões SSL criadas ou geridas por este "
"contexto. É retornado um dicionário que mapeia os nomes de cada `peça de "
"informação <https://docs.openssl.org/1.1.1/man3/SSL_CTX_sess_number/>`_ para "
"os seus valores numéricos. Por exemplo, aqui está o número total de acertos "
"e falhas na cache de sessão desde que o contexto foi criado::"

#: ../../library/ssl.rst:1886
msgid ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"
msgstr ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"

#: ../../library/ssl.rst:1892
msgid ""
"Whether to match the peer cert's hostname in :meth:`SSLSocket.do_handshake`. "
"The context's :attr:`~SSLContext.verify_mode` must be set to :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, and you must pass "
"*server_hostname* to :meth:`~SSLContext.wrap_socket` in order to match the "
"hostname.  Enabling hostname checking automatically sets :attr:`~SSLContext."
"verify_mode` from :data:`CERT_NONE` to :data:`CERT_REQUIRED`.  It cannot be "
"set back to :data:`CERT_NONE` as long as hostname checking is enabled. The :"
"data:`PROTOCOL_TLS_CLIENT` protocol enables hostname checking by default. "
"With other protocols, hostname checking must be enabled explicitly."
msgstr ""
"Se deve corresponder ao nome de host do certificado do par em :meth:"
"`SSLSocket.do_handshake`. O :attr:`~SSLContext.verify_mode` do contexto deve "
"ser definido para :data:`CERT_OPTIONAL` ou :data:`CERT_REQUIRED`, e deve "
"passar *server_hostname* para :meth:`~SSLContext.wrap_socket` para "
"corresponder ao nome de host. Ativar a verificação de nome de host define "
"automaticamente :attr:`~SSLContext.verify_mode` de :data:`CERT_NONE` para :"
"data:`CERT_REQUIRED`. Não pode ser redefinido para :data:`CERT_NONE` "
"enquanto a verificação de nome de host estiver ativada. O protocolo :data:"
"`PROTOCOL_TLS_CLIENT` ativa a verificação de nome de host por predefinição. "
"Com outros protocolos, a verificação de nome de host deve ser ativada "
"explicitamente."

#: ../../library/ssl.rst:1905
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"
msgstr ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n"
"context.verify_mode = ssl.CERT_REQUIRED\n"
"context.check_hostname = True\n"
"context.load_default_certs()\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')\n"
"ssl_sock.connect(('www.verisign.com', 443))"

#: ../../library/ssl.rst:1920
msgid ""
":attr:`~SSLContext.verify_mode` is now automatically changed to :data:"
"`CERT_REQUIRED`  when hostname checking is enabled and :attr:`~SSLContext."
"verify_mode` is :data:`CERT_NONE`. Previously the same operation would have "
"failed with a :exc:`ValueError`."
msgstr ""
":attr:`~SSLContext.verify_mode` é agora automaticamente alterado para :data:"
"`CERT_REQUIRED` quando a verificação de nome de host está ativada e :attr:"
"`~SSLContext.verify_mode` é :data:`CERT_NONE`. Anteriormente, a mesma "
"operação teria falhado com um :exc:`ValueError`."

#: ../../library/ssl.rst:1927
msgid ""
"Write TLS keys to a keylog file, whenever key material is generated or "
"received. The keylog file is designed for debugging purposes only. The file "
"format is specified by NSS and used by many traffic analyzers such as "
"Wireshark. The log file is opened in append-only mode. Writes are "
"synchronized between threads, but not between processes."
msgstr ""
"Escreve chaves TLS num ficheiro de registo de chaves, sempre que material de "
"chave é gerado ou recebido. O ficheiro de registo de chaves é concebido "
"apenas para fins de depuração. O formato do ficheiro é especificado pelo NSS "
"e é usado por muitos analisadores de tráfego, como o Wireshark. O ficheiro "
"de registo é aberto em modo de anexação. As escritas são sincronizadas entre "
"threads, mas não entre processos."

#: ../../library/ssl.rst:1937
msgid ""
"A :class:`TLSVersion` enum member representing the highest supported TLS "
"version. The value defaults to :attr:`TLSVersion.MAXIMUM_SUPPORTED`. The "
"attribute is read-only for protocols other than :const:`PROTOCOL_TLS`, :"
"const:`PROTOCOL_TLS_CLIENT`, and :const:`PROTOCOL_TLS_SERVER`."
msgstr ""
"Um membro :class:`TLSVersion` enum que representa a versão TLS mais alta "
"suportada. O valor predefinido é :attr:`TLSVersion.MAXIMUM_SUPPORTED`. O "
"atributo é de apenas leitura para protocolos diferentes de :const:"
"`PROTOCOL_TLS`, :const:`PROTOCOL_TLS_CLIENT` e :const:`PROTOCOL_TLS_SERVER`."

#: ../../library/ssl.rst:1942
msgid ""
"The attributes :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` and :attr:`SSLContext.options` all affect the supported SSL "
"and TLS versions of the context. The implementation does not prevent invalid "
"combination. For example a context with :attr:`OP_NO_TLSv1_2` in :attr:"
"`~SSLContext.options` and :attr:`~SSLContext.maximum_version` set to :attr:"
"`TLSVersion.TLSv1_2` will not be able to establish a TLS 1.2 connection."
msgstr ""
"Os atributos :attr:`~SSLContext.maximum_version`, :attr:`~SSLContext."
"minimum_version` e :attr:`SSLContext.options` afetam todas as versões SSL e "
"TLS suportadas pelo contexto. A implementação não impede combinações "
"inválidas. Por exemplo, um contexto com :attr:`OP_NO_TLSv1_2` em :attr:"
"`~SSLContext.options` e :attr:`~SSLContext.maximum_version` definido para :"
"attr:`TLSVersion.TLSv1_2` não será capaz de estabelecer uma ligação TLS 1.2."

#: ../../library/ssl.rst:1955
msgid ""
"Like :attr:`SSLContext.maximum_version` except it is the lowest supported "
"version or :attr:`TLSVersion.MINIMUM_SUPPORTED`."
msgstr ""
"Semelhante a :attr:`SSLContext.maximum_version`, exceto que é a versão "
"mínima suportada ou :attr:`TLSVersion.MINIMUM_SUPPORTED`."

#: ../../library/ssl.rst:1962
msgid ""
"Control the number of TLS 1.3 session tickets of a :const:"
"`PROTOCOL_TLS_SERVER` context. The setting has no impact on TLS 1.0 to 1.2 "
"connections."
msgstr ""
"Controla o número de bilhetes de sessão TLS 1.3 de um contexto :const:"
"`PROTOCOL_TLS_SERVER`. A configuração não tem impacto nas ligações TLS 1.0 a "
"1.2."

#: ../../library/ssl.rst:1970
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""
"Um inteiro que representa o conjunto de opções SSL ativadas neste contexto. "
"O valor predefinido é :data:`OP_ALL`, mas pode especificar outras opções, "
"como :data:`OP_NO_SSLv2`, combinando-as com OR."

#: ../../library/ssl.rst:1974
msgid ":attr:`SSLContext.options` returns :class:`Options` flags:"
msgstr ":attr:`SSLContext.options` retorna flags :class:`Options`:"

#: ../../library/ssl.rst:1982
msgid ""
"All ``OP_NO_SSL*`` and ``OP_NO_TLS*`` options have been deprecated since "
"Python 3.7. Use :attr:`SSLContext.minimum_version` and :attr:`SSLContext."
"maximum_version` instead."
msgstr ""
"Todas as opções ``OP_NO_SSL*`` e ``OP_NO_TLS*`` estão obsoletas desde o "
"Python 3.7. Use :attr:`SSLContext.minimum_version` e :attr:`SSLContext."
"maximum_version` em vez disso."

#: ../../library/ssl.rst:1988
msgid ""
"Enable TLS 1.3 post-handshake client authentication. Post-handshake auth is "
"disabled by default and a server can only request a TLS client certificate "
"during the initial handshake. When enabled, a server may request a TLS "
"client certificate at any time after the handshake."
msgstr ""
"Ativa a autenticação de cliente pós-handshake TLS 1.3. A autenticação pós-"
"handshake está desativada por predefinição e um servidor só pode solicitar "
"um certificado de cliente TLS durante o handshake inicial. Quando ativada, "
"um servidor pode solicitar um certificado de cliente TLS a qualquer momento "
"após o handshake."

#: ../../library/ssl.rst:1993
msgid ""
"When enabled on client-side sockets, the client signals the server that it "
"supports post-handshake authentication."
msgstr ""
"Quando ativado em sockets do lado do cliente, o cliente sinaliza ao servidor "
"que suporta autenticação pós-handshake."

#: ../../library/ssl.rst:1996
msgid ""
"When enabled on server-side sockets, :attr:`SSLContext.verify_mode` must be "
"set to :data:`CERT_OPTIONAL` or :data:`CERT_REQUIRED`, too. The actual "
"client cert exchange is delayed until :meth:`SSLSocket."
"verify_client_post_handshake` is called and some I/O is performed."
msgstr ""
"Quando ativado em sockets do lado do servidor, :attr:`SSLContext."
"verify_mode` também deve ser definido para :data:`CERT_OPTIONAL` ou :data:"
"`CERT_REQUIRED`. A troca real de certificados de cliente é adiada até que :"
"meth:`SSLSocket.verify_client_post_handshake` seja chamado e algum I/O seja "
"realizado."

#: ../../library/ssl.rst:2006
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""
"A versão do protocolo escolhida ao construir o contexto. Este atributo é de "
"apenas leitura."

#: ../../library/ssl.rst:2011
msgid ""
"Whether :attr:`~SSLContext.check_hostname` falls back to verify the cert's "
"subject common name in the absence of a subject alternative name extension "
"(default: true)."
msgstr ""
"Se :attr:`~SSLContext.check_hostname` recorre à verificação do nome comum do "
"assunto do certificado na ausência de uma extensão de nome alternativo do "
"assunto (predefinição: verdadeiro)."

#: ../../library/ssl.rst:2019
msgid ""
"The flag had no effect with OpenSSL before version 1.1.1l. Python 3.8.9, "
"3.9.3, and 3.10 include workarounds for previous versions."
msgstr ""
"A flag não teve efeito com o OpenSSL antes da versão 1.1.1l. O Python 3.8.9, "
"3.9.3 e 3.10 incluem soluções alternativas para versões anteriores."

#: ../../library/ssl.rst:2024
msgid ""
"An integer representing the `security level <https://docs.openssl.org/master/"
"man3/SSL_CTX_get_security_level/>`_ for the context. This attribute is read-"
"only."
msgstr ""
"Um inteiro que representa o `nível de segurança <https://docs.openssl.org/"
"master/man3/SSL_CTX_get_security_level/>`_ para o contexto. Este atributo é "
"de apenas leitura."

#: ../../library/ssl.rst:2032
msgid ""
"The flags for certificate verification operations. You can set flags like :"
"data:`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does "
"neither require nor verify certificate revocation lists (CRLs)."
msgstr ""
"As flags para operações de verificação de certificados. Pode definir flags "
"como :data:`VERIFY_CRL_CHECK_LEAF` combinando-as com OR. Por predefinição, o "
"OpenSSL não exige nem verifica listas de revogação de certificados (CRLs)."

#: ../../library/ssl.rst:2038
msgid ":attr:`SSLContext.verify_flags` returns :class:`VerifyFlags` flags:"
msgstr ":attr:`SSLContext.verify_flags` retorna flags :class:`VerifyFlags`:"

#: ../../library/ssl.rst:2046
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""
"Se deve tentar verificar os certificados de outros pares e como se comportar "
"se a verificação falhar. Este atributo deve ser um de :data:`CERT_NONE`, :"
"data:`CERT_OPTIONAL` ou :data:`CERT_REQUIRED`."

#: ../../library/ssl.rst:2050
msgid ":attr:`SSLContext.verify_mode` returns :class:`VerifyMode` enum:"
msgstr ":attr:`SSLContext.verify_mode` retorna enum :class:`VerifyMode`:"

#: ../../library/ssl.rst:2058
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a client-side connection."
msgstr ""
"Ativa a autenticação TLS-PSK (chave pré-compartilhada) numa ligação do lado "
"do cliente."

#: ../../library/ssl.rst:2060 ../../library/ssl.rst:2109
msgid ""
"In general, certificate based authentication should be preferred over this "
"method."
msgstr ""
"Em geral, a autenticação baseada em certificados deve ser preferida em "
"relação a este método."

#: ../../library/ssl.rst:2062
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(hint: str | None) -> tuple[str | None, bytes]``. The ``hint`` "
"parameter is an optional identity hint sent by the server. The return value "
"is a tuple in the form (client-identity, psk). Client-identity is an "
"optional string which may be used by the server to select a corresponding "
"PSK for the client. The string must be less than or equal to ``256`` octets "
"when UTF-8 encoded. PSK is a :term:`bytes-like object` representing the pre-"
"shared key. Return a zero length PSK to reject the connection."
msgstr ""
"O parâmetro ``callback`` é um objeto chamável com a assinatura: ``def "
"callback(hint: str | None) -> tuple[str | None, bytes]``. O parâmetro "
"``hint`` é uma sugestão de identidade opcional enviada pelo servidor. O "
"valor de retorno é um tuplo na forma (client-identity, psk). Client-identity "
"é uma string opcional que pode ser usada pelo servidor para selecionar uma "
"PSK correspondente para o cliente. A string deve ter menos ou igual a "
"``256`` octetos quando codificada em UTF-8. PSK é um objeto :term:`bytes-"
"like` que representa a chave pré-compartilhada. Retorne uma PSK de "
"comprimento zero para rejeitar a ligação."

#: ../../library/ssl.rst:2072 ../../library/ssl.rst:2118
msgid "Setting ``callback`` to :const:`None` removes any existing callback."
msgstr ""
"Definir ``callback`` para :const:`None` remove qualquer função de retorno de "
"chamada existente."

#: ../../library/ssl.rst:2075
msgid "When using TLS 1.3:"
msgstr "Ao usar TLS 1.3:"

#: ../../library/ssl.rst:2077
msgid "the ``hint`` parameter is always :const:`None`."
msgstr "o parâmetro ``hint`` é sempre :const:`None`."

#: ../../library/ssl.rst:2078
msgid "client-identity must be a non-empty string."
msgstr "client-identity deve ser uma string não vazia."

#: ../../library/ssl.rst:2080 ../../library/ssl.rst:2127
msgid "Example usage::"
msgstr "Exemplo de utilização::"

#: ../../library/ssl.rst:2082
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# A table using the hint from the server:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
"context.check_hostname = False\n"
"context.verify_mode = ssl.CERT_NONE\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# Uma lambda simples:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_client_callback(lambda hint: (None, psk))\n"
"\n"
"# Uma tabela usando a sugestão do servidor:\n"
"psk_table = { 'ServerId_1': bytes.fromhex('c0ffee'),\n"
"              'ServerId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(hint):\n"
"    return 'ClientId_1', psk_table.get(hint, b'')\n"
"context.set_psk_client_callback(callback)"

#: ../../library/ssl.rst:2100 ../../library/ssl.rst:2145
msgid ""
"This method will raise :exc:`NotImplementedError` if :data:`HAS_PSK` is "
"``False``."
msgstr ""
"Este método levantará :exc:`NotImplementedError` se :data:`HAS_PSK` for "
"``False``."

#: ../../library/ssl.rst:2107
msgid ""
"Enables TLS-PSK (pre-shared key) authentication on a server-side connection."
msgstr ""
"Ativa a autenticação TLS-PSK (chave pré-compartilhada) numa ligação do lado "
"do servidor."

#: ../../library/ssl.rst:2111
msgid ""
"The parameter ``callback`` is a callable object with the signature: ``def "
"callback(identity: str | None) -> bytes``. The ``identity`` parameter is an "
"optional identity sent by the client which can be used to select a "
"corresponding PSK. The return value is a :term:`bytes-like object` "
"representing the pre-shared key. Return a zero length PSK to reject the "
"connection."
msgstr ""
"O parâmetro ``callback`` é um objeto chamável com a assinatura: ``def "
"callback(identity: str | None) -> bytes``. O parâmetro ``identity`` é uma "
"identidade opcional enviada pelo cliente que pode ser usada para selecionar "
"uma PSK correspondente. O valor de retorno é um objeto :term:`bytes-like` "
"que representa a chave pré-compartilhada. Retorne uma PSK de comprimento "
"zero para rejeitar a ligação."

#: ../../library/ssl.rst:2120
msgid ""
"The parameter ``identity_hint`` is an optional identity hint string sent to "
"the client. The string must be less than or equal to ``256`` octets when "
"UTF-8 encoded."
msgstr ""
"O parâmetro ``identity_hint`` é uma string de sugestão de identidade "
"opcional enviada ao cliente. A string deve ter menos ou igual a ``256`` "
"octetos quando codificada em UTF-8."

#: ../../library/ssl.rst:2125
msgid ""
"When using TLS 1.3 the ``identity_hint`` parameter is not sent to the client."
msgstr ""
"Ao usar TLS 1.3, o parâmetro ``identity_hint`` não é enviado ao cliente."

#: ../../library/ssl.rst:2129
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# A simple lambda:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# A table using the identity of the client:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"
msgstr ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n"
"context.maximum_version = ssl.TLSVersion.TLSv1_2\n"
"context.set_ciphers('PSK')\n"
"\n"
"# Uma lambda simples:\n"
"psk = bytes.fromhex('c0ffee')\n"
"context.set_psk_server_callback(lambda identity: psk)\n"
"\n"
"# Uma tabela usando a identidade do cliente:\n"
"psk_table = { 'ClientId_1': bytes.fromhex('c0ffee'),\n"
"              'ClientId_2': bytes.fromhex('facade')\n"
"}\n"
"def callback(identity):\n"
"    return psk_table.get(identity, b'')\n"
"context.set_psk_server_callback(callback, 'ServerId_1')"

#: ../../library/ssl.rst:2157
msgid "Certificates"
msgstr "Certificados"

#: ../../library/ssl.rst:2159
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""
"Os certificados, em geral, fazem parte de um sistema de chave pública/chave "
"privada. Neste sistema, cada *entidade* (que pode ser uma máquina, uma "
"pessoa ou uma organização) é atribuída uma chave de encriptação única de "
"duas partes. Uma parte da chave é pública e é chamada de *chave pública*; a "
"outra parte é mantida secreta e é chamada de *chave privada*. As duas partes "
"estão relacionadas, no sentido de que, se encriptar uma mensagem com uma das "
"partes, pode desencriptá-la com a outra parte, e **apenas** com a outra "
"parte."

#: ../../library/ssl.rst:2167
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who they "
"claim to be, and that this is indeed the subject's public key.  The issuer's "
"statement is signed with the issuer's private key, which only the issuer "
"knows.  However, anyone can verify the issuer's statement by finding the "
"issuer's public key, decrypting the statement with it, and comparing it to "
"the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""
"Um certificado contém informações sobre duas entidades. Contém o nome de um "
"*assunto* e a chave pública do assunto. Também contém uma declaração de uma "
"segunda entidade, o *emissor*, de que o assunto é quem afirma ser, e de que "
"esta é, de facto, a chave pública do assunto. A declaração do emissor é "
"assinada com a chave privada do emissor, que apenas o emissor conhece. No "
"entanto, qualquer pessoa pode verificar a declaração do emissor encontrando "
"a chave pública do emissor, desencriptando a declaração com ela e comparando-"
"a com as outras informações no certificado. O certificado também contém "
"informações sobre o período de tempo durante o qual é válido. Isto é "
"expresso como dois campos, chamados \"notBefore\" e \"notAfter\"."

#: ../../library/ssl.rst:2177
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""
"Na utilização de certificados em Python, um cliente ou servidor pode usar um "
"certificado para provar quem são. O outro lado de uma ligação de rede também "
"pode ser obrigado a apresentar um certificado, e esse certificado pode ser "
"validado para satisfação do cliente ou servidor que exige tal validação. A "
"tentativa de ligação pode ser configurada para levantar uma exceção se a "
"validação falhar. A validação é feita automaticamente pela estrutura "
"subjacente OpenSSL; a aplicação não precisa preocupar-se com os seus "
"mecanismos. No entanto, a aplicação geralmente precisa fornecer conjuntos de "
"certificados para permitir que este processo ocorra."

#: ../../library/ssl.rst:2187
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""
"O Python usa ficheiros para conter certificados. Devem estar formatados como "
"\"PEM\" (consulte :rfc:`1422`), que é uma forma codificada em base-64 "
"envolvida por uma linha de cabeçalho e uma linha de rodapé::"

#: ../../library/ssl.rst:2191
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificado em codificação base64 PEM) ...\n"
"-----END CERTIFICATE-----"

#: ../../library/ssl.rst:2196
msgid "Certificate chains"
msgstr "Cadeias de certificados"

#: ../../library/ssl.rst:2198
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""
"Os ficheiros Python que contêm certificados podem conter uma sequência de "
"certificados, por vezes chamada de *cadeia de certificados*. Esta cadeia "
"deve começar com o certificado específico para a entidade que \"é\" o "
"cliente ou servidor, seguido do certificado para o emissor desse "
"certificado, e depois o certificado para o emissor desse certificado, e "
"assim por diante até chegar a um certificado que é *autoassinado*, ou seja, "
"um certificado que tem o mesmo assunto e emissor, por vezes chamado de "
"*certificado raiz*. Os certificados devem ser simplesmente concatenados no "
"ficheiro de certificados. Por exemplo, suponha que temos uma cadeia de três "
"certificados, do nosso certificado de servidor para o certificado da "
"autoridade de certificação que assinou o nosso certificado de servidor, até "
"ao certificado raiz da agência que emitiu o certificado da autoridade de "
"certificação::"

#: ../../library/ssl.rst:2211
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificado para o seu servidor)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (o certificado para a CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (o certificado raiz para o emissor da CA)...\n"
"-----END CERTIFICATE-----"

#: ../../library/ssl.rst:2222
msgid "CA certificates"
msgstr "Certificados CA"

#: ../../library/ssl.rst:2224
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  The "
"platform's certificates file can be used by calling :meth:`SSLContext."
"load_default_certs`, this is done automatically with :func:`."
"create_default_context`."
msgstr ""
"Se pretender exigir a validação do certificado do outro lado da ligação, "
"precisa de fornecer um ficheiro de \"certificados CA\", preenchido com as "
"cadeias de certificados para cada emissor em que está disposto a confiar. "
"Mais uma vez, este ficheiro contém apenas estas cadeias concatenadas. Para "
"validação, o Python usará a primeira cadeia que encontrar no ficheiro que "
"corresponda. O ficheiro de certificados da plataforma pode ser usado "
"chamando :meth:`SSLContext.load_default_certs`; isto é feito automaticamente "
"com :func:`.create_default_context`."

#: ../../library/ssl.rst:2233
msgid "Combined key and certificate"
msgstr "Chave e certificado combinados"

#: ../../library/ssl.rst:2235
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"needs to be passed.  If the private key is stored with the certificate, it "
"should come before the first certificate in the certificate chain::"
msgstr ""
"Muitas vezes, a chave privada é armazenada no mesmo ficheiro que o "
"certificado; neste caso, apenas o parâmetro ``certfile`` para :meth:"
"`SSLContext.load_cert_chain` precisa de ser passado. Se a chave privada for "
"armazenada com o certificado, deve vir antes do primeiro certificado na "
"cadeia de certificados::"

#: ../../library/ssl.rst:2241
msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (chave privada em codificação base64) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificado em codificação base64 PEM) ...\n"
"-----END CERTIFICATE-----"

#: ../../library/ssl.rst:2249
msgid "Self-signed certificates"
msgstr "Certificados autoassinados"

#: ../../library/ssl.rst:2251
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""
"Se pretender criar um servidor que forneça serviços de ligação encriptados "
"com SSL, precisará de adquirir um certificado para esse serviço. Existem "
"muitas formas de adquirir certificados apropriados, como comprar um de uma "
"autoridade de certificação. Outra prática comum é gerar um certificado "
"autoassinado. A forma mais simples de fazer isto é com o pacote OpenSSL, "
"usando algo como o seguinte::"

#: ../../library/ssl.rst:2258
msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, "
"Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"A gerar uma chave privada RSA de 1024 bits\n"
".......++++++\n"
".............................++++++\n"
"A escrever nova chave privada em 'cert.pem'\n"
"-----\n"
"Ser-lhe-á pedido que introduza informações que serão incorporadas\n"
"no seu pedido de certificado.\n"
"Aquilo que vai introduzir é chamado de Nome Distinto ou DN.\n"
"Existem vários campos, mas pode deixar alguns em branco\n"
"Para alguns campos haverá um valor predefinido,\n"
"Se introduzir '.', o campo será deixado em branco.\n"
"-----\n"
"Nome do País (código de 2 letras) [AU]:PT\n"
"Nome do Estado ou Província (nome completo) [Some-State]:MeuEstado\n"
"Nome da Localidade (ex., cidade) []:Minha Cidade\n"
"Nome da Organização (ex., empresa) [Internet Widgits Pty Ltd]:Minha "
"Organização, Lda.\n"
"Nome da Unidade Organizacional (ex., secção) []:Meu Grupo\n"
"Nome Comum (ex., o seu nome) []:meuservidor.meugrupo.minhaorganização.pt\n"
"Endereço de Email []:ops@meuservidor.meugrupo.minhaorganização.pt\n"
"%"

#: ../../library/ssl.rst:2280
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""
"A desvantagem de um certificado autoassinado é que ele é o seu próprio "
"certificado raiz, e mais ninguém o terá na sua cache de certificados raiz "
"conhecidos (e confiáveis)."

#: ../../library/ssl.rst:2286
msgid "Examples"
msgstr "Exemplos"

#: ../../library/ssl.rst:2289
msgid "Testing for SSL support"
msgstr "Testar suporte SSL"

#: ../../library/ssl.rst:2291
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""
"Para testar a presença de suporte SSL numa instalação Python, o código do "
"utilizador deve usar o seguinte idioma::"

#: ../../library/ssl.rst:2294
msgid ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # do something that requires SSL support"
msgstr ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ...  # fazer algo que requer suporte SSL"

#: ../../library/ssl.rst:2302
msgid "Client-side operation"
msgstr "Operação do lado do cliente"

#: ../../library/ssl.rst:2304
msgid ""
"This example creates a SSL context with the recommended security settings "
"for client sockets, including automatic certificate verification::"
msgstr ""
"Este exemplo cria um contexto SSL com as configurações de segurança "
"recomendadas para sockets de cliente, incluindo verificação automática de "
"certificados::"

#: ../../library/ssl.rst:2307
msgid ">>> context = ssl.create_default_context()"
msgstr ">>> context = ssl.create_default_context()"

#: ../../library/ssl.rst:2309
msgid ""
"If you prefer to tune security settings yourself, you might create a context "
"from scratch (but beware that you might not get the settings right)::"
msgstr ""
"Se preferir ajustar as configurações de segurança você mesmo, pode criar um "
"contexto do zero (mas tenha cuidado para não errar nas configurações)::"

#: ../../library/ssl.rst:2313
msgid ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"
msgstr ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"

#: ../../library/ssl.rst:2316
msgid ""
"(this snippet assumes your operating system places a bundle of all CA "
"certificates in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an "
"error and have to adjust the location)"
msgstr ""
"(este excerto assume que o seu sistema operativo coloca um pacote de todos "
"os certificados CA em ``/etc/ssl/certs/ca-bundle.crt``; se não, obterá um "
"erro e terá de ajustar a localização)"

#: ../../library/ssl.rst:2320
msgid ""
"The :data:`PROTOCOL_TLS_CLIENT` protocol configures the context for cert "
"validation and hostname verification. :attr:`~SSLContext.verify_mode` is set "
"to :data:`CERT_REQUIRED` and :attr:`~SSLContext.check_hostname` is set to "
"``True``. All other protocols create SSL contexts with insecure defaults."
msgstr ""
"O protocolo :data:`PROTOCOL_TLS_CLIENT` configura o contexto para validação "
"de certificados e verificação de nome de host. :attr:`~SSLContext."
"verify_mode` é definido para :data:`CERT_REQUIRED` e :attr:`~SSLContext."
"check_hostname` é definido para ``True``. Todos os outros protocolos criam "
"contextos SSL com predefinições inseguras."

#: ../../library/ssl.rst:2325
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` and :"
"attr:`~SSLContext.check_hostname` validate the server certificate: it "
"ensures that the server certificate was signed with one of the CA "
"certificates, checks the signature for correctness, and verifies other "
"properties like validity and identity of the hostname::"
msgstr ""
"Quando usa o contexto para se ligar a um servidor, :const:`CERT_REQUIRED` e :"
"attr:`~SSLContext.check_hostname` validam o certificado do servidor: "
"garantem que o certificado do servidor foi assinado com um dos certificados "
"CA, verificam a assinatura quanto à correção e verificam outras "
"propriedades, como validade e identidade do nome de host::"

#: ../../library/ssl.rst:2331
msgid ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"
msgstr ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET),\n"
"...                            server_hostname=\"www.python.org\")\n"
">>> conn.connect((\"www.python.org\", 443))"

#: ../../library/ssl.rst:2335
msgid "You may then fetch the certificate::"
msgstr "Pode então obter o certificado::"

#: ../../library/ssl.rst:2337
msgid ">>> cert = conn.getpeercert()"
msgstr ">>> cert = conn.getpeercert()"

#: ../../library/ssl.rst:2339
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``www.python.org``)::"
msgstr ""
"Uma inspeção visual mostra que o certificado identifica o serviço desejado "
"(ou seja, o host HTTPS ``www.python.org``)::"

#: ../../library/ssl.rst:2342
msgid ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/"
"DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1."
"crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1."
"crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server "
"CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"
msgstr ""
">>> pprint.pprint(cert)\n"
"{'OCSP': ('http://ocsp.digicert.com',),\n"
" 'caIssuers': ('http://cacerts.digicert.com/"
"DigiCertSHA2ExtendedValidationServerCA.crt',),\n"
" 'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1."
"crl',\n"
"                           'http://crl4.digicert.com/sha2-ev-server-g1."
"crl'),\n"
" 'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'DigiCert Inc'),),\n"
"            (('organizationalUnitName', 'www.digicert.com'),),\n"
"            (('commonName', 'DigiCert SHA2 Extended Validation Server "
"CA'),)),\n"
" 'notAfter': 'Sep  9 12:00:00 2016 GMT',\n"
" 'notBefore': 'Sep  5 00:00:00 2014 GMT',\n"
" 'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',\n"
" 'subject': ((('businessCategory', 'Private Organization'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('serialNumber', '3359300'),),\n"
"             (('streetAddress', '16 Allen Rd'),),\n"
"             (('postalCode', '03894-4801'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'NH'),),\n"
"             (('localityName', 'Wolfeboro'),),\n"
"             (('organizationName', 'Python Software Foundation'),),\n"
"             (('commonName', 'www.python.org'),)),\n"
" 'subjectAltName': (('DNS', 'www.python.org'),\n"
"                    ('DNS', 'python.org'),\n"
"                    ('DNS', 'pypi.org'),\n"
"                    ('DNS', 'docs.python.org'),\n"
"                    ('DNS', 'testpypi.org'),\n"
"                    ('DNS', 'bugs.python.org'),\n"
"                    ('DNS', 'wiki.python.org'),\n"
"                    ('DNS', 'hg.python.org'),\n"
"                    ('DNS', 'mail.python.org'),\n"
"                    ('DNS', 'packaging.python.org'),\n"
"                    ('DNS', 'pythonhosted.org'),\n"
"                    ('DNS', 'www.pythonhosted.org'),\n"
"                    ('DNS', 'test.pythonhosted.org'),\n"
"                    ('DNS', 'us.pycon.org'),\n"
"                    ('DNS', 'id.python.org')),\n"
" 'version': 3}"

#: ../../library/ssl.rst:2382
msgid ""
"Now the SSL channel is established and the certificate verified, you can "
"proceed to talk with the server::"
msgstr ""
"Agora que o canal SSL está estabelecido e o certificado verificado, pode "
"prosseguir para comunicar com o servidor::"

#: ../../library/ssl.rst:2385
msgid ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"
msgstr ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 200 OK',\n"
" b'Date: Sat, 18 Oct 2014 18:27:20 GMT',\n"
" b'Server: nginx',\n"
" b'Content-Type: text/html; charset=utf-8',\n"
" b'X-Frame-Options: SAMEORIGIN',\n"
" b'Content-Length: 45679',\n"
" b'Accept-Ranges: bytes',\n"
" b'Via: 1.1 varnish',\n"
" b'Age: 2188',\n"
" b'X-Served-By: cache-lcy1134-LCY',\n"
" b'X-Cache: HIT',\n"
" b'X-Cache-Hits: 11',\n"
" b'Vary: Cookie',\n"
" b'Strict-Transport-Security: max-age=63072000; includeSubDomains',\n"
" b'Connection: close',\n"
" b'',\n"
" b'']"

#: ../../library/ssl.rst:2409
msgid "Server-side operation"
msgstr "Operação do lado do servidor"

#: ../../library/ssl.rst:2411
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""
"Para a operação do lado do servidor, normalmente precisará de ter um "
"certificado de servidor e uma chave privada, cada um num ficheiro. Primeiro, "
"criará um contexto que contém a chave e o certificado, para que os clientes "
"possam verificar a sua autenticidade. Depois, abrirá um socket, associá-lo-á "
"a uma porta, chamará :meth:`listen` nele e começará a esperar que os "
"clientes se liguem::"

#: ../../library/ssl.rst:2417
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.example.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""
"import socket, ssl\n"
"\n"
"context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n"
"context.load_cert_chain(certfile=\"meucertificado\", "
"keyfile=\"minhachave\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('meuendereco.exemplo.com', 10023))\n"
"bindsocket.listen(5)"

#: ../../library/ssl.rst:2426
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""
"Quando um cliente se liga, chamará :meth:`accept` no socket para obter o "
"novo socket da outra extremidade e usará o método :meth:`SSLContext."
"wrap_socket` do contexto para criar um socket SSL do lado do servidor para a "
"ligação::"

#: ../../library/ssl.rst:2430
msgid ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"
msgstr ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"

#: ../../library/ssl.rst:2439
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""
"Depois, lerá dados de ``connstream`` e fará algo com eles até terminar com o "
"cliente (ou o cliente terminar consigo)::"

#: ../../library/ssl.rst:2442
msgid ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # empty data means the client is finished with us\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # we'll assume do_something returns False\n"
"            # when we're finished with client\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # finished with client"
msgstr ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # dados vazios significam que o cliente terminou connosco\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # assumiremos que do_something retorna False\n"
"            # quando terminarmos com o cliente\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # terminado com o cliente"

#: ../../library/ssl.rst:2453
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in :ref:`non-blocking mode <ssl-nonblocking>` and use an "
"event loop)."
msgstr ""
"E volte a escutar por novas ligações de clientes (claro que um servidor real "
"provavelmente trataria cada ligação de cliente numa thread separada, ou "
"colocaria os sockets em :ref:`modo não bloqueante <ssl-nonblocking>` e "
"usaria um ciclo de eventos)."

#: ../../library/ssl.rst:2461
msgid "Notes on non-blocking sockets"
msgstr "Notas sobre sockets não bloqueantes"

#: ../../library/ssl.rst:2463
msgid ""
"SSL sockets behave slightly different than regular sockets in non-blocking "
"mode. When working with non-blocking sockets, there are thus several things "
"you need to be aware of:"
msgstr ""
"Os sockets SSL comportam-se ligeiramente de forma diferente dos sockets "
"normais em modo não bloqueante. Ao trabalhar com sockets não bloqueantes, há "
"várias coisas que precisa de ter em conta:"

#: ../../library/ssl.rst:2467
msgid ""
"Most :class:`SSLSocket` methods will raise either :exc:`SSLWantWriteError` "
"or :exc:`SSLWantReadError` instead of :exc:`BlockingIOError` if an I/O "
"operation would block. :exc:`SSLWantReadError` will be raised if a read "
"operation on the underlying socket is necessary, and :exc:"
"`SSLWantWriteError` for a write operation on the underlying socket. Note "
"that attempts to *write* to an SSL socket may require *reading* from the "
"underlying socket first, and attempts to *read* from the SSL socket may "
"require a prior *write* to the underlying socket."
msgstr ""
"A maioria dos métodos :class:`SSLSocket` levantará :exc:`SSLWantWriteError` "
"ou :exc:`SSLWantReadError` em vez de :exc:`BlockingIOError` se uma operação "
"de I/O bloquear. :exc:`SSLWantReadError` será levantado se uma operação de "
"leitura no socket subjacente for necessária, e :exc:`SSLWantWriteError` para "
"uma operação de escrita no socket subjacente. Note que as tentativas de "
"*escrever* num socket SSL podem exigir *ler* primeiro do socket subjacente, "
"e as tentativas de *ler* de um socket SSL podem exigir uma *escrita* prévia "
"no socket subjacente."

#: ../../library/ssl.rst:2479
msgid ""
"In earlier Python versions, the :meth:`!SSLSocket.send` method returned zero "
"instead of raising :exc:`SSLWantWriteError` or :exc:`SSLWantReadError`."
msgstr ""
"Em versões anteriores do Python, o método :meth:`!SSLSocket.send` retornava "
"zero em vez de levantar :exc:`SSLWantWriteError` ou :exc:`SSLWantReadError`."

#: ../../library/ssl.rst:2483
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""
"Chamar :func:`~select.select` indica que o socket a nível do sistema "
"operativo pode ser lido (ou escrito), mas não implica que haja dados "
"suficientes na camada SSL superior. Por exemplo, apenas parte de um quadro "
"SSL pode ter chegado. Portanto, deve estar preparado para lidar com falhas "
"em :meth:`SSLSocket.recv` e :meth:`SSLSocket.send`, e tentar novamente após "
"outra chamada a :func:`~select.select`."

#: ../../library/ssl.rst:2490
msgid ""
"Conversely, since the SSL layer has its own framing, a SSL socket may still "
"have data available for reading without :func:`~select.select` being aware "
"of it.  Therefore, you should first call :meth:`SSLSocket.recv` to drain any "
"potentially available data, and then only block on a :func:`~select.select` "
"call if still necessary."
msgstr ""
"Por outro lado, uma vez que a camada SSL tem a sua própria estruturação, um "
"socket SSL pode ainda ter dados disponíveis para leitura sem que :func:"
"`~select.select` esteja ciente disso. Portanto, deve primeiro chamar :meth:"
"`SSLSocket.recv` para esgotar quaisquer dados potencialmente disponíveis e "
"só depois bloquear numa chamada :func:`~select.select`, se ainda for "
"necessário."

#: ../../library/ssl.rst:2496
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`, or those in the :mod:`selectors` module)"
msgstr ""
"(claro, disposições semelhantes aplicam-se ao usar outras primitivas como :"
"func:`~select.poll`, ou aquelas no módulo :mod:`selectors`)"

#: ../../library/ssl.rst:2499
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""
"O próprio handshake SSL será não bloqueante: o método :meth:`SSLSocket."
"do_handshake` tem de ser repetido até que retorne com sucesso. Aqui está um "
"resumo usando :func:`~select.select` para esperar pela prontidão do socket::"

#: ../../library/ssl.rst:2504
msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"
msgstr ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLWantReadError:\n"
"        select.select([sock], [], [])\n"
"    except ssl.SSLWantWriteError:\n"
"        select.select([], [sock], [])"

#: ../../library/ssl.rst:2515
msgid ""
"The :mod:`asyncio` module supports :ref:`non-blocking SSL sockets <ssl-"
"nonblocking>` and provides a higher level :ref:`Streams API <asyncio-"
"streams>`. It polls for events using the :mod:`selectors` module and "
"handles :exc:`SSLWantWriteError`, :exc:`SSLWantReadError` and :exc:"
"`BlockingIOError` exceptions. It runs the SSL handshake asynchronously as "
"well."
msgstr ""
"O módulo :mod:`asyncio` suporta :ref:`sockets SSL não bloqueantes <ssl-"
"nonblocking>` e fornece uma API de nível superior :ref:`Streams <asyncio-"
"streams>`. Faz polling de eventos usando o módulo :mod:`selectors` e lida "
"com as exceções :exc:`SSLWantWriteError`, :exc:`SSLWantReadError` e :exc:"
"`BlockingIOError`. Também executa o handshake SSL de forma assíncrona."

#: ../../library/ssl.rst:2524
msgid "Memory BIO Support"
msgstr "Suporte para Memory BIO"

#: ../../library/ssl.rst:2528
msgid ""
"Ever since the SSL module was introduced in Python 2.6, the :class:"
"`SSLSocket` class has provided two related but distinct areas of "
"functionality:"
msgstr ""
"Desde que o módulo SSL foi introduzido no Python 2.6, a classe :class:"
"`SSLSocket` tem fornecido duas áreas de funcionalidade relacionadas, mas "
"distintas:"

#: ../../library/ssl.rst:2531
msgid "SSL protocol handling"
msgstr "Manipulação do protocolo SSL"

#: ../../library/ssl.rst:2532
msgid "Network IO"
msgstr "I/O de rede"

#: ../../library/ssl.rst:2534
msgid ""
"The network IO API is identical to that provided by :class:`socket.socket`, "
"from which :class:`SSLSocket` also inherits. This allows an SSL socket to be "
"used as a drop-in replacement for a regular socket, making it very easy to "
"add SSL support to an existing application."
msgstr ""
"A API de I/O de rede é idêntica à fornecida por :class:`socket.socket`, da "
"qual :class:`SSLSocket` também herda. Isto permite que um socket SSL seja "
"usado como um substituto direto para um socket normal, tornando muito fácil "
"adicionar suporte SSL a uma aplicação existente."

#: ../../library/ssl.rst:2539
msgid ""
"Combining SSL protocol handling and network IO usually works well, but there "
"are some cases where it doesn't. An example is async IO frameworks that want "
"to use a different IO multiplexing model than the \"select/poll on a file "
"descriptor\" (readiness based) model that is assumed by :class:`socket."
"socket` and by the internal OpenSSL socket IO routines. This is mostly "
"relevant for platforms like Windows where this model is not efficient. For "
"this purpose, a reduced scope variant of :class:`SSLSocket` called :class:"
"`SSLObject` is provided."
msgstr ""
"Combinar a manipulação do protocolo SSL e I/O de rede geralmente funciona "
"bem, mas há alguns casos em que não funciona. Um exemplo são os frameworks "
"de I/O assíncrona que querem usar um modelo de multiplexação de I/O "
"diferente do modelo \"select/poll num descritor de ficheiro\" (baseado em "
"prontidão) que é assumido por :class:`socket.socket` e pelas rotinas "
"internas de I/O de socket do OpenSSL. Isto é principalmente relevante para "
"plataformas como o Windows, onde este modelo não é eficiente. Para este "
"propósito, é fornecida uma variante de âmbito reduzido de :class:`SSLSocket` "
"chamada :class:`SSLObject`."

#: ../../library/ssl.rst:2550
msgid ""
"A reduced-scope variant of :class:`SSLSocket` representing an SSL protocol "
"instance that does not contain any network IO methods. This class is "
"typically used by framework authors that want to implement asynchronous IO "
"for SSL through memory buffers."
msgstr ""
"Uma variante de âmbito reduzido de :class:`SSLSocket` que representa uma "
"instância de protocolo SSL que não contém quaisquer métodos de I/O de rede. "
"Esta classe é tipicamente usada por autores de frameworks que desejam "
"implementar I/O assíncrona para SSL através de buffers de memória."

#: ../../library/ssl.rst:2555
msgid ""
"This class implements an interface on top of a low-level SSL object as "
"implemented by OpenSSL. This object captures the state of an SSL connection "
"but does not provide any network IO itself. IO needs to be performed through "
"separate \"BIO\" objects which are OpenSSL's IO abstraction layer."
msgstr ""
"Esta classe implementa uma interface sobre um objeto SSL de baixo nível, "
"conforme implementado pelo OpenSSL. Este objeto captura o estado de uma "
"ligação SSL, mas não fornece qualquer I/O de rede por si só. A I/O precisa "
"de ser realizada através de objetos \"BIO\" separados, que são a camada de "
"abstração de I/O do OpenSSL."

#: ../../library/ssl.rst:2560
msgid ""
"This class has no public constructor.  An :class:`SSLObject` instance must "
"be created using the :meth:`~SSLContext.wrap_bio` method. This method will "
"create the :class:`SSLObject` instance and bind it to a pair of BIOs. The "
"*incoming* BIO is used to pass data from Python to the SSL protocol "
"instance, while the *outgoing* BIO is used to pass data the other way around."
msgstr ""
"Esta classe não tem um construtor público. Uma instância de :class:"
"`SSLObject` deve ser criada usando o método :meth:`~SSLContext.wrap_bio`. "
"Este método criará a instância :class:`SSLObject` e associá-la-á a um par de "
"BIOs. O BIO *incoming* é usado para passar dados de Python para a instância "
"do protocolo SSL, enquanto o BIO *outgoing* é usado para passar dados na "
"outra direção."

#: ../../library/ssl.rst:2567
msgid "The following methods are available:"
msgstr "Os seguintes métodos estão disponíveis:"

#: ../../library/ssl.rst:2569
msgid ":attr:`~SSLSocket.context`"
msgstr ":attr:`~SSLSocket.context`"

#: ../../library/ssl.rst:2570
msgid ":attr:`~SSLSocket.server_side`"
msgstr ":attr:`~SSLSocket.server_side`"

#: ../../library/ssl.rst:2571
msgid ":attr:`~SSLSocket.server_hostname`"
msgstr ":attr:`~SSLSocket.server_hostname`"

#: ../../library/ssl.rst:2572
msgid ":attr:`~SSLSocket.session`"
msgstr ":attr:`~SSLSocket.session`"

#: ../../library/ssl.rst:2573
msgid ":attr:`~SSLSocket.session_reused`"
msgstr ":attr:`~SSLSocket.session_reused`"

#: ../../library/ssl.rst:2574
msgid ":meth:`~SSLSocket.read`"
msgstr ":meth:`~SSLSocket.read`"

#: ../../library/ssl.rst:2575
msgid ":meth:`~SSLSocket.write`"
msgstr ":meth:`~SSLSocket.write`"

#: ../../library/ssl.rst:2576
msgid ":meth:`~SSLSocket.getpeercert`"
msgstr ":meth:`~SSLSocket.getpeercert`"

#: ../../library/ssl.rst:2577
msgid ":meth:`~SSLSocket.get_verified_chain`"
msgstr ":meth:`~SSLSocket.get_verified_chain`"

#: ../../library/ssl.rst:2578
msgid ":meth:`~SSLSocket.get_unverified_chain`"
msgstr ":meth:`~SSLSocket.get_unverified_chain`"

#: ../../library/ssl.rst:2579
msgid ":meth:`~SSLSocket.selected_alpn_protocol`"
msgstr ":meth:`~SSLSocket.selected_alpn_protocol`"

#: ../../library/ssl.rst:2580
msgid ":meth:`~SSLSocket.selected_npn_protocol`"
msgstr ":meth:`~SSLSocket.selected_npn_protocol`"

#: ../../library/ssl.rst:2581
msgid ":meth:`~SSLSocket.cipher`"
msgstr ":meth:`~SSLSocket.cipher`"

#: ../../library/ssl.rst:2582
msgid ":meth:`~SSLSocket.shared_ciphers`"
msgstr ":meth:`~SSLSocket.shared_ciphers`"

#: ../../library/ssl.rst:2583
msgid ":meth:`~SSLSocket.compression`"
msgstr ":meth:`~SSLSocket.compression`"

#: ../../library/ssl.rst:2584
msgid ":meth:`~SSLSocket.pending`"
msgstr ":meth:`~SSLSocket.pending`"

#: ../../library/ssl.rst:2585
msgid ":meth:`~SSLSocket.do_handshake`"
msgstr ":meth:`~SSLSocket.do_handshake`"

#: ../../library/ssl.rst:2586
msgid ":meth:`~SSLSocket.verify_client_post_handshake`"
msgstr ":meth:`~SSLSocket.verify_client_post_handshake`"

#: ../../library/ssl.rst:2587
msgid ":meth:`~SSLSocket.unwrap`"
msgstr ":meth:`~SSLSocket.unwrap`"

#: ../../library/ssl.rst:2588
msgid ":meth:`~SSLSocket.get_channel_binding`"
msgstr ":meth:`~SSLSocket.get_channel_binding`"

#: ../../library/ssl.rst:2589
msgid ":meth:`~SSLSocket.version`"
msgstr ":meth:`~SSLSocket.version`"

#: ../../library/ssl.rst:2591
msgid ""
"When compared to :class:`SSLSocket`, this object lacks the following "
"features:"
msgstr ""
"Em comparação com :class:`SSLSocket`, este objeto não possui as seguintes "
"funcionalidades:"

#: ../../library/ssl.rst:2594
msgid ""
"Any form of network IO; ``recv()`` and ``send()`` read and write only to the "
"underlying :class:`MemoryBIO` buffers."
msgstr ""
"Qualquer forma de I/O de rede; ``recv()`` e ``send()`` leem e escrevem "
"apenas para os buffers :class:`MemoryBIO` subjacentes."

#: ../../library/ssl.rst:2597
msgid ""
"There is no *do_handshake_on_connect* machinery. You must always manually "
"call :meth:`~SSLSocket.do_handshake` to start the handshake."
msgstr ""
"Não existe maquinaria *do_handshake_on_connect*. Deve sempre chamar "
"manualmente :meth:`~SSLSocket.do_handshake` para iniciar o handshake."

#: ../../library/ssl.rst:2600
msgid ""
"There is no handling of *suppress_ragged_eofs*. All end-of-file conditions "
"that are in violation of the protocol are reported via the :exc:"
"`SSLEOFError` exception."
msgstr ""
"Não existe tratamento de *suppress_ragged_eofs*. Todas as condições de fim-"
"de-ficheiro que violam o protocolo são reportadas através da exceção :exc:"
"`SSLEOFError`."

#: ../../library/ssl.rst:2604
msgid ""
"The method :meth:`~SSLSocket.unwrap` call does not return anything, unlike "
"for an SSL socket where it returns the underlying socket."
msgstr ""
"A chamada ao método :meth:`~SSLSocket.unwrap` não retorna nada, ao contrário "
"de um socket SSL, onde retorna o socket subjacente."

#: ../../library/ssl.rst:2607
msgid ""
"The *server_name_callback* callback passed to :meth:`SSLContext."
"set_servername_callback` will get an :class:`SSLObject` instance instead of "
"a :class:`SSLSocket` instance as its first parameter."
msgstr ""
"A função de retorno de chamada *server_name_callback* passada para :meth:"
"`SSLContext.set_servername_callback` receberá uma instância de :class:"
"`SSLObject` em vez de uma instância de :class:`SSLSocket` como seu primeiro "
"parâmetro."

#: ../../library/ssl.rst:2611
msgid "Some notes related to the use of :class:`SSLObject`:"
msgstr "Algumas notas relacionadas com o uso de :class:`SSLObject`:"

#: ../../library/ssl.rst:2613
msgid ""
"All IO on an :class:`SSLObject` is :ref:`non-blocking <ssl-nonblocking>`. "
"This means that for example :meth:`~SSLSocket.read` will raise an :exc:"
"`SSLWantReadError` if it needs more data than the incoming BIO has available."
msgstr ""
"Todo o I/O num :class:`SSLObject` é :ref:`não bloqueante <ssl-nonblocking>`. "
"Isto significa que, por exemplo, :meth:`~SSLSocket.read` levantará um :exc:"
"`SSLWantReadError` se precisar de mais dados do que os disponíveis no BIO de "
"entrada."

#: ../../library/ssl.rst:2618
msgid ""
":class:`SSLObject` instances must be created with :meth:`~SSLContext."
"wrap_bio`. In earlier versions, it was possible to create instances "
"directly. This was never documented or officially supported."
msgstr ""
"As instâncias de :class:`SSLObject` devem ser criadas com :meth:`~SSLContext."
"wrap_bio`. Em versões anteriores, era possível criar instâncias diretamente. "
"Isto nunca foi documentado nem oficialmente suportado."

#: ../../library/ssl.rst:2624
msgid ""
"An SSLObject communicates with the outside world using memory buffers. The "
"class :class:`MemoryBIO` provides a memory buffer that can be used for this "
"purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:"
msgstr ""
"Um SSLObject comunica com o mundo exterior usando buffers de memória. A "
"classe :class:`MemoryBIO` fornece um buffer de memória que pode ser usado "
"para este propósito. Envolve um objeto OpenSSL memory BIO (Basic IO):"

#: ../../library/ssl.rst:2630
msgid ""
"A memory buffer that can be used to pass data between Python and an SSL "
"protocol instance."
msgstr ""
"Um buffer de memória que pode ser usado para passar dados entre Python e uma "
"instância de protocolo SSL."

#: ../../library/ssl.rst:2635
msgid "Return the number of bytes currently in the memory buffer."
msgstr "Retorna o número de bytes atualmente no buffer de memória."

#: ../../library/ssl.rst:2639
msgid ""
"A boolean indicating whether the memory BIO is current at the end-of-file "
"position."
msgstr ""
"Um booleano que indica se o BIO de memória está atualmente na posição de fim-"
"de-ficheiro."

#: ../../library/ssl.rst:2644
msgid ""
"Read up to *n* bytes from the memory buffer. If *n* is not specified or "
"negative, all bytes are returned."
msgstr ""
"Lê até *n* bytes do buffer de memória. Se *n* não for especificado ou for "
"negativo, todos os bytes são retornados."

#: ../../library/ssl.rst:2649
msgid ""
"Write the bytes from *buf* to the memory BIO. The *buf* argument must be an "
"object supporting the buffer protocol."
msgstr ""
"Escreve os bytes de *buf* para o BIO de memória. O argumento *buf* deve ser "
"um objeto que suporte o protocolo de buffer."

#: ../../library/ssl.rst:2652
msgid ""
"The return value is the number of bytes written, which is always equal to "
"the length of *buf*."
msgstr ""
"O valor de retorno é o número de bytes escritos, que é sempre igual ao "
"comprimento de *buf*."

#: ../../library/ssl.rst:2657
msgid ""
"Write an EOF marker to the memory BIO. After this method has been called, it "
"is illegal to call :meth:`~MemoryBIO.write`. The attribute :attr:`eof` will "
"become true after all data currently in the buffer has been read."
msgstr ""
"Escreve um marcador de EOF no BIO de memória. Depois de este método ter sido "
"chamado, é ilegal chamar :meth:`~MemoryBIO.write`. O atributo :attr:`eof` "
"tornar-se-á verdadeiro depois de todos os dados atualmente no buffer terem "
"sido lidos."

#: ../../library/ssl.rst:2663
msgid "SSL session"
msgstr "Sessão SSL"

#: ../../library/ssl.rst:2669
msgid "Session object used by :attr:`~SSLSocket.session`."
msgstr "Objeto de sessão usado por :attr:`~SSLSocket.session`."

#: ../../library/ssl.rst:2681
msgid "Security considerations"
msgstr "Considerações de segurança"

#: ../../library/ssl.rst:2684
msgid "Best defaults"
msgstr "Melhores predefinições"

#: ../../library/ssl.rst:2686
msgid ""
"For **client use**, if you don't have any special requirements for your "
"security policy, it is highly recommended that you use the :func:"
"`create_default_context` function to create your SSL context. It will load "
"the system's trusted CA certificates, enable certificate validation and "
"hostname checking, and try to choose reasonably secure protocol and cipher "
"settings."
msgstr ""
"Para **uso do cliente**, se não tiver requisitos especiais para a sua "
"política de segurança, é altamente recomendado que utilize a função :func:"
"`create_default_context` para criar o seu contexto SSL. Esta carregará os "
"certificados CA confiáveis do sistema, ativará a validação de certificados e "
"a verificação de nomes de host, e tentará escolher configurações de "
"protocolo e cifras razoavelmente seguras."

#: ../../library/ssl.rst:2693
msgid ""
"For example, here is how you would use the :class:`smtplib.SMTP` class to "
"create a trusted, secure connection to a SMTP server::"
msgstr ""
"Por exemplo, aqui está como usaria a classe :class:`smtplib.SMTP` para criar "
"uma ligação segura e confiável a um servidor SMTP::"

#: ../../library/ssl.rst:2696
msgid ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"
msgstr ""
">>> import ssl, smtplib\n"
">>> smtp = smtplib.SMTP(\"mail.python.org\", port=587)\n"
">>> context = ssl.create_default_context()\n"
">>> smtp.starttls(context=context)\n"
"(220, b'2.0.0 Ready to start TLS')"

#: ../../library/ssl.rst:2702
msgid ""
"If a client certificate is needed for the connection, it can be added with :"
"meth:`SSLContext.load_cert_chain`."
msgstr ""
"Se um certificado de cliente for necessário para a ligação, pode ser "
"adicionado com :meth:`SSLContext.load_cert_chain`."

#: ../../library/ssl.rst:2705
msgid ""
"By contrast, if you create the SSL context by calling the :class:"
"`SSLContext` constructor yourself, it will not have certificate validation "
"nor hostname checking enabled by default.  If you do so, please read the "
"paragraphs below to achieve a good security level."
msgstr ""
"Por outro lado, se criar o contexto SSL chamando o construtor :class:"
"`SSLContext` você mesmo, não terá validação de certificados nem verificação "
"de nomes de host ativadas por predefinição. Se o fizer, leia os parágrafos "
"abaixo para alcançar um bom nível de segurança."

#: ../../library/ssl.rst:2711
msgid "Manual settings"
msgstr "Configurações manuais"

#: ../../library/ssl.rst:2714
msgid "Verifying certificates"
msgstr "Verificação de certificados"

#: ../../library/ssl.rst:2716
msgid ""
"When calling the :class:`SSLContext` constructor directly, :const:"
"`CERT_NONE` is the default.  Since it does not authenticate the other peer, "
"it can be insecure, especially in client mode where most of the time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname. This common "
"check is automatically performed when :attr:`SSLContext.check_hostname` is "
"enabled."
msgstr ""
"Ao chamar diretamente o construtor :class:`SSLContext`, :const:`CERT_NONE` é "
"o predefinido. Uma vez que não autentica o outro par, pode ser inseguro, "
"especialmente no modo cliente, onde a maior parte do tempo gostaria de "
"garantir a autenticidade do servidor com o qual está a comunicar. Portanto, "
"quando no modo cliente, é altamente recomendado usar :const:`CERT_REQUIRED`. "
"No entanto, por si só não é suficiente; também tem de verificar se o "
"certificado do servidor, que pode ser obtido chamando :meth:`SSLSocket."
"getpeercert`, corresponde ao serviço desejado. Para muitos protocolos e "
"aplicações, o serviço pode ser identificado pelo nome de host. Esta "
"verificação comum é realizada automaticamente quando :attr:`SSLContext."
"check_hostname` está ativado."

#: ../../library/ssl.rst:2728
msgid ""
"Hostname matchings is now performed by OpenSSL. Python no longer uses :func:"
"`!match_hostname`."
msgstr ""
"A correspondência de nomes de host é agora realizada pelo OpenSSL. O Python "
"já não usa :func:`!match_hostname`."

#: ../../library/ssl.rst:2732
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""
"Em modo servidor, se quiser autenticar os seus clientes usando a camada SSL "
"(em vez de usar um mecanismo de autenticação de nível superior), também terá "
"de especificar :const:`CERT_REQUIRED` e verificar de forma semelhante o "
"certificado do cliente."

#: ../../library/ssl.rst:2738
msgid "Protocol versions"
msgstr "Versões de protocolo"

#: ../../library/ssl.rst:2740
msgid ""
"SSL versions 2 and 3 are considered insecure and are therefore dangerous to "
"use.  If you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_TLS_CLIENT` or :const:"
"`PROTOCOL_TLS_SERVER` as the protocol version. SSLv2 and SSLv3 are disabled "
"by default."
msgstr ""
"As versões SSL 2 e 3 são consideradas inseguras e, portanto, perigosas de "
"usar. Se pretender a máxima compatibilidade entre clientes e servidores, é "
"recomendado usar :const:`PROTOCOL_TLS_CLIENT` ou :const:"
"`PROTOCOL_TLS_SERVER` como a versão do protocolo. SSLv2 e SSLv3 estão "
"desativados por predefinição."

#: ../../library/ssl.rst:2748
msgid ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"
msgstr ""
">>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n"
">>> client_context.minimum_version = ssl.TLSVersion.TLSv1_3\n"
">>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3"

#: ../../library/ssl.rst:2753
msgid ""
"The SSL context created above will only allow TLSv1.3 and later (if "
"supported by your system) connections to a server. :const:"
"`PROTOCOL_TLS_CLIENT` implies certificate validation and hostname checks by "
"default. You have to load certificates into the context."
msgstr ""
"O contexto SSL criado acima permitirá apenas ligações TLSv1.3 e posteriores "
"(se suportado pelo seu sistema) a um servidor. :const:`PROTOCOL_TLS_CLIENT` "
"implica validação de certificados e verificações de nome de host por "
"predefinição. Tem de carregar certificados no contexto."

#: ../../library/ssl.rst:2760
msgid "Cipher selection"
msgstr "Seleção de cifras"

#: ../../library/ssl.rst:2762
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice. Be sure to read OpenSSL's documentation about "
"the `cipher list format <https://docs.openssl.org/1.1.1/man1/ciphers/#cipher-"
"list-format>`_. If you want to check which ciphers are enabled by a given "
"cipher list, use :meth:`SSLContext.get_ciphers` or the ``openssl ciphers`` "
"command on your system."
msgstr ""
"Se tiver requisitos avançados de segurança, o ajuste fino das cifras "
"ativadas ao negociar uma sessão SSL é possível através do método :meth:"
"`SSLContext.set_ciphers`. A partir do Python 3.2.3, o módulo ssl desativa "
"certas cifras fracas por predefinição, mas pode querer restringir ainda mais "
"a escolha de cifras. Certifique-se de ler a documentação do OpenSSL sobre o "
"`formato da lista de cifras <https://docs.openssl.org/1.1.1/man1/ciphers/"
"#cipher-list-format>`_. Se quiser verificar quais cifras estão ativadas por "
"uma determinada lista de cifras, use :meth:`SSLContext.get_ciphers` ou o "
"comando ``openssl ciphers`` no seu sistema."

#: ../../library/ssl.rst:2773
msgid "Multi-processing"
msgstr "Multiprocessamento"

#: ../../library/ssl.rst:2775
msgid ""
"If using this module as part of a multi-processed application (using, for "
"example the :mod:`multiprocessing` or :mod:`concurrent.futures` modules), be "
"aware that OpenSSL's internal random number generator does not properly "
"handle forked processes.  Applications must change the PRNG state of the "
"parent process if they use any SSL feature with :func:`os.fork`.  Any "
"successful call of :func:`~ssl.RAND_add` or :func:`~ssl.RAND_bytes` is "
"sufficient."
msgstr ""
"Se estiver a usar este módulo como parte de uma aplicação multiprocessada "
"(usando, por exemplo, os módulos :mod:`multiprocessing` ou :mod:`concurrent."
"futures`), tenha em conta que o gerador interno de números aleatórios do "
"OpenSSL não lida corretamente com processos bifurcados. As aplicações devem "
"alterar o estado do PRNG do processo pai se usarem qualquer funcionalidade "
"SSL com :func:`os.fork`. Qualquer chamada bem-sucedida de :func:`~ssl."
"RAND_add` ou :func:`~ssl.RAND_bytes` é suficiente."

#: ../../library/ssl.rst:2787
msgid "TLS 1.3"
msgstr "TLS 1.3"

#: ../../library/ssl.rst:2791
msgid ""
"The TLS 1.3 protocol behaves slightly differently than previous version of "
"TLS/SSL. Some new TLS 1.3 features are not yet available."
msgstr ""
"O protocolo TLS 1.3 comporta-se ligeiramente de forma diferente das versões "
"anteriores de TLS/SSL. Algumas novas funcionalidades do TLS 1.3 ainda não "
"estão disponíveis."

#: ../../library/ssl.rst:2794
msgid ""
"TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 "
"cipher suites are enabled by default.  The method :meth:`SSLContext."
"set_ciphers` cannot enable or disable any TLS 1.3 ciphers yet, but :meth:"
"`SSLContext.get_ciphers` returns them."
msgstr ""
"O TLS 1.3 usa um conjunto disjunto de suites de cifras. Todas as suites de "
"cifras AES-GCM e ChaCha20 estão ativadas por predefinição. O método :meth:"
"`SSLContext.set_ciphers` ainda não pode ativar ou desativar quaisquer cifras "
"TLS 1.3, mas :meth:`SSLContext.get_ciphers` retorna-as."

#: ../../library/ssl.rst:2798
msgid ""
"Session tickets are no longer sent as part of the initial handshake and are "
"handled differently.  :attr:`SSLSocket.session` and :class:`SSLSession` are "
"not compatible with TLS 1.3."
msgstr ""
"Os bilhetes de sessão já não são enviados como parte do handshake inicial e "
"são tratados de forma diferente. :attr:`SSLSocket.session` e :class:"
"`SSLSession` não são compatíveis com TLS 1.3."

#: ../../library/ssl.rst:2801
msgid ""
"Client-side certificates are also no longer verified during the initial "
"handshake.  A server can request a certificate at any time.  Clients process "
"certificate requests while they send or receive application data from the "
"server."
msgstr ""
"Os certificados do lado do cliente também já não são verificados durante o "
"handshake inicial. Um servidor pode solicitar um certificado a qualquer "
"momento. Os clientes processam pedidos de certificados enquanto enviam ou "
"recebem dados de aplicação do servidor."

#: ../../library/ssl.rst:2805
msgid ""
"TLS 1.3 features like early data, deferred TLS client cert request, "
"signature algorithm configuration, and rekeying are not supported yet."
msgstr ""
"Funcionalidades do TLS 1.3 como dados iniciais, pedido diferido de "
"certificado de cliente TLS, configuração de algoritmo de assinatura e re-"
"chaveamento ainda não são suportadas."

#: ../../library/ssl.rst:2811
msgid "Class :class:`socket.socket`"
msgstr "Classe :class:`socket.socket`"

#: ../../library/ssl.rst:2812
msgid "Documentation of underlying :mod:`socket` class"
msgstr "Documentação da classe subjacente :mod:`socket`"

#: ../../library/ssl.rst:2814
msgid ""
"`SSL/TLS Strong Encryption: An Introduction <https://httpd.apache.org/docs/"
"trunk/en/ssl/ssl_intro.html>`_"
msgstr ""
"`Introdução à Encriptação Forte SSL/TLS <https://httpd.apache.org/docs/trunk/"
"en/ssl/ssl_intro.html>`_"

#: ../../library/ssl.rst:2815
msgid "Intro from the Apache HTTP Server documentation"
msgstr "Introdução da documentação do servidor HTTP Apache"

#: ../../library/ssl.rst:2817
msgid ""
":rfc:`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <1422>`"
msgstr ""
":rfc:`RFC 1422: Melhoria de Privacidade para Correio Eletrónico na Internet: "
"Parte II: Gestão de Chaves Baseada em Certificados <1422>`"

#: ../../library/ssl.rst:2818
msgid "Steve Kent"
msgstr "Steve Kent"

#: ../../library/ssl.rst:2820
msgid ":rfc:`RFC 4086: Randomness Requirements for Security <4086>`"
msgstr ":rfc:`RFC 4086: Requisitos de Aleatoriedade para Segurança <4086>`"

#: ../../library/ssl.rst:2821
msgid "Donald E., Jeffrey I. Schiller"
msgstr "Donald E., Jeffrey I. Schiller"

#: ../../library/ssl.rst:2823
msgid ""
":rfc:`RFC 5280: Internet X.509 Public Key Infrastructure Certificate and "
"Certificate Revocation List (CRL) Profile <5280>`"
msgstr ""
":rfc:`RFC 5280: Perfil de Infraestrutura de Chave Pública X.509 da Internet "
"e Lista de Revogação de Certificados (CRL) <5280>`"

#: ../../library/ssl.rst:2824
msgid "D. Cooper"
msgstr "D. Cooper"

#: ../../library/ssl.rst:2826
msgid ""
":rfc:`RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 "
"<5246>`"
msgstr ""
":rfc:`RFC 5246: O Protocolo de Segurança da Camada de Transporte (TLS) "
"Versão 1.2 <5246>`"

#: ../../library/ssl.rst:2827
msgid "T. Dierks et. al."
msgstr "T. Dierks et. al."

#: ../../library/ssl.rst:2829
msgid ":rfc:`RFC 6066: Transport Layer Security (TLS) Extensions <6066>`"
msgstr ""
":rfc:`RFC 6066: Extensões de Segurança da Camada de Transporte (TLS) <6066>`"

#: ../../library/ssl.rst:2830
msgid "D. Eastlake"
msgstr "D. Eastlake"

#: ../../library/ssl.rst:2832
msgid ""
"`IANA TLS: Transport Layer Security (TLS) Parameters <https://www.iana.org/"
"assignments/tls-parameters/tls-parameters.xml>`_"
msgstr ""
"`IANA TLS: Parâmetros de Segurança da Camada de Transporte (TLS) <https://"
"www.iana.org/assignments/tls-parameters/tls-parameters.xml>`_"

#: ../../library/ssl.rst:2833
msgid "IANA"
msgstr "IANA"

#: ../../library/ssl.rst:2835
msgid ""
":rfc:`RFC 7525: Recommendations for Secure Use of Transport Layer Security "
"(TLS) and Datagram Transport Layer Security (DTLS) <7525>`"
msgstr ""
":rfc:`RFC 7525: Recomendações para Uso Seguro de Segurança da Camada de "
"Transporte (TLS) e Segurança da Camada de Transporte de Datagramas (DTLS) "
"<7525>`"

#: ../../library/ssl.rst:2836
msgid "IETF"
msgstr "IETF"

#: ../../library/ssl.rst:2838
msgid ""
"`Mozilla's Server Side TLS recommendations <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"
msgstr ""
"`Recomendações do lado do servidor TLS da Mozilla <https://wiki.mozilla.org/"
"Security/Server_Side_TLS>`_"

#: ../../library/ssl.rst:2839
msgid "Mozilla"
msgstr "Mozilla"

#: ../../library/ssl.rst:12
msgid "OpenSSL"
msgstr "OpenSSL"

#: ../../library/ssl.rst:12
msgid "(use in module ssl)"
msgstr "(usado no módulo ssl)"

#: ../../library/ssl.rst:14
msgid "TLS"
msgstr "TLS"

#: ../../library/ssl.rst:14
msgid "SSL"
msgstr "SSL"

#: ../../library/ssl.rst:14
msgid "Transport Layer Security"
msgstr "Segurança da Camada de Transporte"

#: ../../library/ssl.rst:14
msgid "Secure Sockets Layer"
msgstr "Camada de Sockets Segura"

#: ../../library/ssl.rst:2150
msgid "certificates"
msgstr "certificados"

#: ../../library/ssl.rst:2152
msgid "X509 certificate"
msgstr "certificado X509"
