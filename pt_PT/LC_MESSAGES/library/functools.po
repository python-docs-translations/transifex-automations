# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-27 16:22+0000\n"
"PO-Revision-Date: 2025-09-22 16:50+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/functools.rst:2
msgid ""
":mod:`functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ""

#: ../../library/functools.rst:14
msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**Código-fonte:** :source:`Lib/functools.py`"

#: ../../library/functools.rst:23
msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ""
"O módulo :mod:`functools` é para funções de ordem superior: funções que "
"atuam ou retornam outras funções. Em geral, qualquer objeto chamável pode "
"ser tratado como uma função para os propósitos deste módulo."

#: ../../library/functools.rst:27
msgid "The :mod:`functools` module defines the following functions:"
msgstr "O módulo :mod:`functools` define as seguintes funções:"

#: ../../library/functools.rst:31
msgid ""
"Simple lightweight unbounded function cache.  Sometimes called `\"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_."
msgstr ""
"Cache de função simples e leve sem limites. Às vezes chamado de \"memoize\" "
"<https://en.wikipedia.org/wiki/Memoization>`_. "

#: ../../library/functools.rst:34
msgid ""
"Returns the same as ``lru_cache(maxsize=None)``, creating a thin wrapper "
"around a dictionary lookup for the function arguments.  Because it never "
"needs to evict old values, this is smaller and faster than :func:"
"`lru_cache()` with a size limit."
msgstr ""

#: ../../library/functools.rst:39 ../../library/functools.rst:276
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/functools.rst:52 ../../library/functools.rst:143
msgid ""
"The cache is threadsafe so that the wrapped function can be used in multiple "
"threads.  This means that the underlying data structure will remain coherent "
"during concurrent updates."
msgstr ""
"A cache é segura para threads, de modo que a função encapsulada pode ser "
"usada em múltiplas threads. Isto significa que a estrutura de dados "
"subjacente permanecerá coerente durante atualizações concorrentes."

#: ../../library/functools.rst:56 ../../library/functools.rst:147
msgid ""
"It is possible for the wrapped function to be called more than once if "
"another thread makes an additional call before the initial call has been "
"completed and cached."
msgstr ""
"É possível que a função encapsulada seja chamada mais de uma vez se outra "
"thread fizer uma chamada adicional antes da chamada inicial ter sido "
"concluída e colocada em cache."

#: ../../library/functools.rst:65
msgid ""
"Transform a method of a class into a property whose value is computed once "
"and then cached as a normal attribute for the life of the instance. Similar "
"to :func:`property`, with the addition of caching. Useful for expensive "
"computed properties of instances that are otherwise effectively immutable."
msgstr ""
"Transforma um método de uma classe numa propriedade cujo valor é calculado "
"uma vez e depois armazenado em cache como um atributo normal para a vida da "
"instância. Semelhante a :func:`property`, com a adição de cache. Útil para "
"propriedades calculadas dispendiosas de instâncias que são, de outra forma, "
"efetivamente imutáveis."

#: ../../library/functools.rst:70 ../../library/functools.rst:127
#: ../../library/functools.rst:368
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/functools.rst:81
msgid ""
"The mechanics of :func:`cached_property` are somewhat different from :func:"
"`property`.  A regular property blocks attribute writes unless a setter is "
"defined. In contrast, a *cached_property* allows writes."
msgstr ""
"A mecânica de :func:`cached_property` é um pouco diferente de :func:"
"`property`. Uma propriedade regular bloqueia escritas de atributos a menos "
"que um setter seja definido. Em contraste, uma *cached_property* permite "
"escritas."

#: ../../library/functools.rst:85
msgid ""
"The *cached_property* decorator only runs on lookups and only when an "
"attribute of the same name doesn't exist.  When it does run, the "
"*cached_property* writes to the attribute with the same name. Subsequent "
"attribute reads and writes take precedence over the *cached_property* method "
"and it works like a normal attribute."
msgstr ""
"O decorador *cached_property* só é executado em pesquisas e apenas quando um "
"atributo com o mesmo nome não existe. Quando é executado, a "
"*cached_property* escreve no atributo com o mesmo nome. Leitura e escrita "
"subsequentes do atributo têm precedência sobre o método *cached_property* e "
"funciona como um atributo normal."

#: ../../library/functools.rst:91
msgid ""
"The cached value can be cleared by deleting the attribute.  This allows the "
"*cached_property* method to run again."
msgstr ""
"O valor em cache pode ser limpo apagando o atributo. Isto permite que o "
"método *cached_property* seja executado novamente."

#: ../../library/functools.rst:94
msgid ""
"Note, this decorator interferes with the operation of :pep:`412` key-sharing "
"dictionaries.  This means that instance dictionaries can take more space "
"than usual."
msgstr ""
"Nota: este decorador interfere com a operação de dicionários de partilha de "
"chaves :pep:`412`. Isto significa que os dicionários de instância podem "
"ocupar mais espaço do que o habitual."

#: ../../library/functools.rst:98
msgid ""
"Also, this decorator requires that the ``__dict__`` attribute on each "
"instance be a mutable mapping. This means it will not work with some types, "
"such as metaclasses (since the ``__dict__`` attributes on type instances are "
"read-only proxies for the class namespace), and those that specify "
"``__slots__`` without including ``__dict__`` as one of the defined slots (as "
"such classes don't provide a ``__dict__`` attribute at all)."
msgstr ""
"Além disso, este decorador requer que o atributo ``__dict__`` em cada "
"instância seja um mapeamento mutável. Isto significa que não funcionará com "
"alguns tipos, como metaclasses (uma vez que os atributos ``__dict__`` em "
"instâncias de tipo são proxies de apenas leitura para o espaço de nomes da "
"classe), e aqueles que especificam ``__slots__`` sem incluir ``__dict__`` "
"como um dos slots definidos (uma vez que tais classes não fornecem um "
"atributo ``__dict__``)."

#: ../../library/functools.rst:105
msgid ""
"If a mutable mapping is not available or if space-efficient key sharing is "
"desired, an effect similar to :func:`cached_property` can also be achieved "
"by stacking :func:`property` on top of :func:`lru_cache`. See :ref:`faq-"
"cache-method-calls` for more details on how this differs from :func:"
"`cached_property`."
msgstr ""
"Se um mapeamento mutável não estiver disponível ou se for desejada uma "
"partilha de chaves eficiente em termos de espaço, um efeito semelhante a :"
"func:`cached_property` também pode ser alcançado empilhando :func:`property` "
"sobre :func:`lru_cache`. Consulte :ref:`faq-cache-method-calls` para mais "
"detalhes sobre como isto difere de :func:`cached_property`."

#: ../../library/functools.rst:115
msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`).  This function is primarily used as a transition tool "
"for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"Transforma uma função de comparação antiga em uma :term:`função chave`. "
"Usada com ferramentas que aceitam funções chave (como :func:`sorted`, :func:"
"`min`, :func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`). Esta função é usada principalmente como uma ferramenta "
"de transição para programas que estão a ser convertidos do Python 2, que "
"suportava o uso de funções de comparação."

#: ../../library/functools.rst:122
msgid ""
"A comparison function is any callable that accepts two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts "
"one argument and returns another value to be used as the sort key."
msgstr ""
"Uma função de comparação é qualquer objeto chamável que aceita dois "
"argumentos, compara-os e retorna um número negativo para menor-que, zero "
"para igualdade, ou um número positivo para maior-que. Uma função chave é um "
"objeto chamável que aceita um argumento e retorna outro valor para ser usado "
"como a chave de ordenação."

#: ../../library/functools.rst:131
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Para exemplos de ordenação e um breve tutorial sobre ordenação, consulte :"
"ref:`sortinghowto`."

#: ../../library/functools.rst:139
msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr ""
"Decorador para encapsular uma função com um objeto chamável de memoização "
"que guarda até *maxsize* chamadas mais recentes. Pode poupar tempo quando "
"uma função dispendiosa ou limitada por I/O é chamada periodicamente com os "
"mesmos argumentos."

#: ../../library/functools.rst:151
msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be :term:`hashable`."
msgstr ""
"Como um dicionário é usado para armazenar em cache os resultados, os "
"argumentos posicionais e de palavra-chave para a função devem ser :term:"
"`hashable`."

#: ../../library/functools.rst:154
msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, ``f(a=1, b=2)`` and ``f(b=2, a=1)`` "
"differ in their keyword argument order and may have two separate cache "
"entries."
msgstr ""
"Padrões de argumentos distintos podem ser considerados chamadas distintas "
"com entradas de cache separadas. Por exemplo, ``f(a=1, b=2)`` e ``f(b=2, "
"a=1)`` diferem na ordem dos seus argumentos de palavra-chave e podem ter "
"duas entradas de cache separadas."

#: ../../library/functools.rst:159
msgid ""
"If *user_function* is specified, it must be a callable. This allows the "
"*lru_cache* decorator to be applied directly to a user function, leaving the "
"*maxsize* at its default value of 128::"
msgstr ""
"Se *user_function* for especificada, deve ser um objeto chamável. Isto "
"permite que o decorador *lru_cache* seja aplicado diretamente a uma função "
"do utilizador, deixando o *maxsize* no seu valor padrão de 128::"

#: ../../library/functools.rst:167
msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound."
msgstr ""
"Se *maxsize* for definido como ``None``, a funcionalidade LRU é desativada e "
"a cache pode crescer sem limites."

#: ../../library/functools.rst:170
msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  If *typed* is false, the implementation will usually "
"regard them as equivalent calls and only cache a single result. (Some types "
"such as *str* and *int* may be cached separately even when *typed* is false.)"
msgstr ""
"Se *typed* for definido como verdadeiro, os argumentos da função de tipos "
"diferentes serão armazenados em cache separadamente. Se *typed* for falso, a "
"implementação geralmente os considerará chamadas equivalentes e armazenará "
"em cache apenas um único resultado. (Alguns tipos como *str* e *int* podem "
"ser armazenados em cache separadamente mesmo quando *typed* é falso.)"

#: ../../library/functools.rst:176
msgid ""
"Note, type specificity applies only to the function's immediate arguments "
"rather than their contents.  The scalar arguments, ``Decimal(42)`` and "
"``Fraction(42)`` are be treated as distinct calls with distinct results. In "
"contrast, the tuple arguments ``('answer', Decimal(42))`` and ``('answer', "
"Fraction(42))`` are treated as equivalent."
msgstr ""
"Nota: a especificidade de tipo aplica-se apenas aos argumentos imediatos da "
"função e não ao seu conteúdo. Os argumentos escalares, ``Decimal(42)`` e "
"``Fraction(42)`` são tratados como chamadas distintas com resultados "
"distintos. Em contraste, os argumentos de tuplo ``('answer', Decimal(42))`` "
"e ``('answer', Fraction(42))`` são tratados como equivalentes."

#: ../../library/functools.rst:182
msgid ""
"The wrapped function is instrumented with a :func:`!cache_parameters` "
"function that returns a new :class:`dict` showing the values for *maxsize* "
"and *typed*.  This is for information purposes only.  Mutating the values "
"has no effect."
msgstr ""
"A função encapsulada é instrumentada com uma função :func:`!"
"cache_parameters` que retorna um novo :class:`dict` mostrando os valores "
"para *maxsize* e *typed*. Isto é apenas para fins informativos. Mutar os "
"valores não tem efeito."

#: ../../library/functools.rst:187
msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*."
msgstr ""

#: ../../library/functools.rst:192
msgid ""
"The decorator also provides a :func:`cache_clear` function for clearing or "
"invalidating the cache."
msgstr ""

#: ../../library/functools.rst:195
msgid ""
"The original underlying function is accessible through the :attr:"
"`__wrapped__` attribute.  This is useful for introspection, for bypassing "
"the cache, or for rewrapping the function with a different cache."
msgstr ""
"A função subjacente original é acessível através do atributo :attr:"
"`__wrapped__`. Isto é útil para introspeção, para contornar a cache ou para "
"reencapsular a função com uma cache diferente."

#: ../../library/functools.rst:199
msgid ""
"The cache keeps references to the arguments and return values until they age "
"out of the cache or until the cache is cleared."
msgstr ""
"A cache mantém referências aos argumentos e valores de retorno até que saiam "
"da cache ou até que a cache seja limpa."

#: ../../library/functools.rst:202
msgid ""
"If a method is cached, the ``self`` instance argument is included in the "
"cache.  See :ref:`faq-cache-method-calls`"
msgstr ""
"Se um método for armazenado em cache, o argumento de instância ``self`` é "
"incluído na cache. Consulte :ref:`faq-cache-method-calls`"

#: ../../library/functools.rst:205
msgid ""
"An `LRU (least recently used) cache <https://en.wikipedia.org/wiki/"
"Cache_replacement_policies#Least_recently_used_(LRU)>`_ works best when the "
"most recent calls are the best predictors of upcoming calls (for example, "
"the most popular articles on a news server tend to change each day).  The "
"cache's size limit assures that the cache does not grow without bound on "
"long-running processes such as web servers."
msgstr ""

#: ../../library/functools.rst:212
msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call (such as generators and async functions), or impure "
"functions such as time() or random()."
msgstr ""
"Em geral, a cache LRU só deve ser usada quando se deseja reutilizar valores "
"previamente calculados. Consequentemente, não faz sentido armazenar em cache "
"funções com efeitos colaterais, funções que precisam de criar objetos "
"mutáveis distintos em cada chamada (como geradores e funções assíncronas), "
"ou funções impuras como time() ou random()."

#: ../../library/functools.rst:218
msgid "Example of an LRU cache for static web content::"
msgstr "Exemplo de uma cache LRU para conteúdo web estático::"

#: ../../library/functools.rst:237
msgid ""
"Example of efficiently computing `Fibonacci numbers <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ using a cache to implement a `dynamic "
"programming <https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"Exemplo de cálculo eficiente de `números de Fibonacci <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ usando uma cache para implementar uma técnica "
"de `programação dinâmica <https://en.wikipedia.org/wiki/"
"Dynamic_programming>`_::"

#: ../../library/functools.rst:257
msgid "Added the *typed* option."
msgstr "Adicionada a opção *typed*."

#: ../../library/functools.rst:260
msgid "Added the *user_function* option."
msgstr "Adicionada a opção *user_function*."

#: ../../library/functools.rst:263
msgid "Added the function :func:`!cache_parameters`"
msgstr "Adicionada a função :func:`!cache_parameters`"

#: ../../library/functools.rst:268
msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr ""
"Dada uma classe que define um ou mais métodos de ordenação de comparação "
"rica, este decorador de classe fornece o restante. Isto simplifica o esforço "
"envolvido na especificação de todas as possíveis operações de comparação "
"rica:"

#: ../../library/functools.rst:272
msgid ""
"The class must define one of :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, "
"or :meth:`__ge__`. In addition, the class should supply an :meth:`__eq__` "
"method."
msgstr ""

#: ../../library/functools.rst:296
msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack "
"traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six "
"rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"Embora este decorador facilite a criação de tipos totalmente ordenados e bem "
"comportados, isso *acarreta* um custo de execução mais lenta e rastos de "
"pilha mais complexos para os métodos de comparação derivados. Se a análise "
"de desempenho indicar que isto é um gargalo para uma determinada aplicação, "
"a implementação de todos os seis métodos de comparação rica em vez disso é "
"provável que forneça um aumento fácil de velocidade."

#: ../../library/functools.rst:305
msgid ""
"This decorator makes no attempt to override methods that have been declared "
"in the class *or its superclasses*. Meaning that if a superclass defines a "
"comparison operator, *total_ordering* will not implement it again, even if "
"the original method is abstract."
msgstr ""
"Este decorador não tenta substituir métodos que tenham sido declarados na "
"classe *ou nas suas superclasses*. Isto significa que se uma superclasse "
"definir um operador de comparação, *total_ordering* não o implementará "
"novamente, mesmo que o método original seja abstrato."

#: ../../library/functools.rst:312
msgid ""
"Returning NotImplemented from the underlying comparison function for "
"unrecognised types is now supported."
msgstr ""

#: ../../library/functools.rst:318
msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"Retorna um novo :ref:`objeto parcial<partial-objects>` que, quando chamado, "
"se comportará como *func* chamado com os argumentos posicionais *args* e "
"argumentos de palavra-chave *keywords*. Se mais argumentos forem fornecidos "
"à chamada, eles são anexados a *args*. Se argumentos adicionais de palavra-"
"chave forem fornecidos, eles estendem e substituem *keywords*. "
"Aproximadamente equivalente a::"

#: ../../library/functools.rst:334
msgid ""
"The :func:`partial` is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords resulting "
"in a new object with a simplified signature.  For example, :func:`partial` "
"can be used to create a callable that behaves like the :func:`int` function "
"where the *base* argument defaults to two:"
msgstr ""

#: ../../library/functools.rst:349
msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like :class:"
"`partial` except that it is designed to be used as a method definition "
"rather than being directly callable."
msgstr ""
"Retorna um novo descritor :class:`partialmethod` que se comporta como :class:"
"`partial`, exceto que é projetado para ser usado como uma definição de "
"método em vez de ser diretamente chamável."

#: ../../library/functools.rst:353
msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr ""
"*func* deve ser um :term:`descritor` ou um objeto chamável (objetos que são "
"ambos, como funções normais, são tratados como descritores)."

#: ../../library/functools.rst:356
msgid ""
"When *func* is a descriptor (such as a normal Python function, :func:"
"`classmethod`, :func:`staticmethod`, :func:`abstractmethod` or another "
"instance of :class:`partialmethod`), calls to ``__get__`` are delegated to "
"the underlying descriptor, and an appropriate :ref:`partial object<partial-"
"objects>` returned as the result."
msgstr ""

#: ../../library/functools.rst:362
msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as "
"a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the :class:"
"`partialmethod` constructor."
msgstr ""
"Quando *func* é um objeto chamável não descritor, um método ligado "
"apropriado é criado dinamicamente. Isto comporta-se como uma função Python "
"normal quando usada como método: o argumento *self* será inserido como o "
"primeiro argumento posicional, mesmo antes dos *args* e *keywords* "
"fornecidos ao construtor :class:`partialmethod`."

#: ../../library/functools.rst:393
msgid ""
"Apply *function* of two arguments cumulatively to the items of *iterable*, "
"from left to right, so as to reduce the iterable to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *iterable*.  If the "
"optional *initializer* is present, it is placed before the items of the "
"iterable in the calculation, and serves as a default when the iterable is "
"empty.  If *initializer* is not given and *iterable* contains only one item, "
"the first item is returned."
msgstr ""

#: ../../library/functools.rst:402
msgid "Roughly equivalent to::"
msgstr "Aproximadamente equivalente a::"

#: ../../library/functools.rst:414
msgid ""
"See :func:`itertools.accumulate` for an iterator that yields all "
"intermediate values."
msgstr ""
"Consulte :func:`itertools.accumulate` para um iterador que produz todos os "
"valores intermédios."

#: ../../library/functools.rst:419
msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr "Transforma uma função numa :term:`função genérica <single dispatch>`."

#: ../../library/functools.rst:422
msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. When defining a function using ``@singledispatch``, note that the "
"dispatch happens on the type of the first argument::"
msgstr ""
"Para definir uma função genérica, decore-a com o decorador "
"``@singledispatch``. Ao definir uma função usando ``@singledispatch``, note "
"que o despacho acontece no tipo do primeiro argumento::"

#: ../../library/functools.rst:433
msgid ""
"To add overloaded implementations to the function, use the :func:`register` "
"attribute of the generic function, which can be used as a decorator.  For "
"functions annotated with types, the decorator will infer the type of the "
"first argument automatically::"
msgstr ""

#: ../../library/functools.rst:451
msgid ":data:`types.UnionType` and :data:`typing.Union` can also be used::"
msgstr ""

#: ../../library/functools.rst:468
msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr ""
"Para código que não usa anotações de tipo, o argumento de tipo apropriado "
"pode ser passado explicitamente para o próprio decorador::"

#: ../../library/functools.rst:479
msgid ""
"To enable registering :term:`lambdas<lambda>` and pre-existing functions, "
"the :func:`register` attribute can also be used in a functional form::"
msgstr ""

#: ../../library/functools.rst:487
msgid ""
"The :func:`register` attribute returns the undecorated function. This "
"enables decorator stacking, :mod:`pickling<pickle>`, and the creation of "
"unit tests for each variant independently::"
msgstr ""

#: ../../library/functools.rst:501
msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr ""
"Quando chamada, a função genérica faz o despacho com base no tipo do "
"primeiro argumento::"

#: ../../library/functools.rst:521
msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original "
"function decorated with ``@singledispatch`` is registered for the base :"
"class:`object` type, which means it is used if no better implementation is "
"found."
msgstr ""
"Quando não há uma implementação registada para um tipo específico, a sua "
"ordem de resolução de métodos é usada para encontrar uma implementação mais "
"genérica. A função original decorada com ``@singledispatch`` é registada "
"para o tipo base :class:`object`, o que significa que é usada se nenhuma "
"implementação melhor for encontrada."

#: ../../library/functools.rst:527
msgid ""
"If an implementation is registered to an :term:`abstract base class`, "
"virtual subclasses of the base class will be dispatched to that "
"implementation::"
msgstr ""
"Se uma implementação for registada numa :term:`classe base abstrata`, as "
"subclasses virtuais da classe base serão despachadas para essa "
"implementação::"

#: ../../library/functools.rst:542
msgid ""
"To check which implementation the generic function will choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr ""
"Para verificar qual implementação a função genérica escolherá para um tipo "
"dado, use o atributo ``dispatch()``::"

#: ../../library/functools.rst:550
msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr ""
"Para aceder a todas as implementações registadas, use o atributo de apenas "
"leitura ``registry``::"

#: ../../library/functools.rst:564
msgid "The :func:`register` attribute now supports using type annotations."
msgstr ""

#: ../../library/functools.rst:567
msgid ""
"The :func:`register` attribute now supports :data:`types.UnionType` and :"
"data:`typing.Union` as type annotations."
msgstr ""

#: ../../library/functools.rst:574
msgid ""
"Transform a method into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr "Transforma um método numa :term:`função genérica <single dispatch>`."

#: ../../library/functools.rst:577
msgid ""
"To define a generic method, decorate it with the ``@singledispatchmethod`` "
"decorator. When defining a function using ``@singledispatchmethod``, note "
"that the dispatch happens on the type of the first non-*self* or non-*cls* "
"argument::"
msgstr ""

#: ../../library/functools.rst:595
msgid ""
"``@singledispatchmethod`` supports nesting with other decorators such as :"
"func:`@classmethod<classmethod>`. Note that to allow for ``dispatcher."
"register``, ``singledispatchmethod`` must be the *outer most* decorator. "
"Here is the ``Negator`` class with the ``neg`` methods bound to the class, "
"rather than an instance of the class::"
msgstr ""

#: ../../library/functools.rst:617
msgid ""
"The same pattern can be used for other similar decorators: :func:"
"`@staticmethod<staticmethod>`, :func:`@abstractmethod<abc.abstractmethod>`, "
"and others."
msgstr ""

#: ../../library/functools.rst:626
msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's ``__module__``, ``__name__``, "
"``__qualname__``, ``__annotations__`` and ``__doc__``, the documentation "
"string) and ``WRAPPER_UPDATES`` (which updates the wrapper function's "
"``__dict__``, i.e. the instance dictionary)."
msgstr ""

#: ../../library/functools.rst:636
msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"Para permitir o acesso à função original para introspeção e outros fins (por "
"exemplo, contornar um decorador de cache como :func:`lru_cache`), esta "
"função adiciona automaticamente um atributo ``__wrapped__`` ao wrapper que "
"se refere à função que está a ser encapsulada."

#: ../../library/functools.rst:641
msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"O principal uso pretendido para esta função é em funções :term:`decoradoras` "
"que encapsulam a função decorada e retornam o wrapper. Se a função wrapper "
"não for atualizada, os metadados da função retornada refletirão a definição "
"do wrapper em vez da definição da função original, o que é tipicamente menos "
"útil."

#: ../../library/functools.rst:647
msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object "
"being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` pode ser usado com objetos chamáveis que não sejam "
"funções. Quaisquer atributos nomeados em *assigned* ou *updated* que estejam "
"em falta no objeto a ser encapsulado são ignorados (ou seja, esta função não "
"tentará defini-los na função wrapper). :exc:`AttributeError` ainda é "
"levantado se a função wrapper em si estiver em falta de quaisquer atributos "
"nomeados em *updated*."

#: ../../library/functools.rst:653
msgid ""
"The ``__wrapped__`` attribute is now automatically added. The "
"``__annotations__`` attribute is now copied by default. Missing attributes "
"no longer trigger an :exc:`AttributeError`."
msgstr ""

#: ../../library/functools.rst:658
msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see :issue:"
"`17482`)"
msgstr ""
"O atributo ``__wrapped__`` agora refere-se sempre à função encapsulada, "
"mesmo que essa função tenha definido um atributo ``__wrapped__``. (ver :"
"issue:`17482`)"

#: ../../library/functools.rst:666
msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"Esta é uma função de conveniência para invocar :func:`update_wrapper` como "
"um decorador de função ao definir uma função wrapper. É equivalente a "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. Por exemplo::"

#: ../../library/functools.rst:692
msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original :func:"
"`example` would have been lost."
msgstr ""

#: ../../library/functools.rst:700
msgid ":class:`partial` Objects"
msgstr "Objetos :class:`partial`"

#: ../../library/functools.rst:702
msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ""
"Os objetos :class:`partial` são objetos chamáveis criados por :func:"
"`partial`. Eles têm três atributos de apenas leitura:"

#: ../../library/functools.rst:708
msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be "
"forwarded to :attr:`func` with new arguments and keywords."
msgstr ""
"Um objeto chamável ou função. As chamadas para o objeto :class:`partial` "
"serão encaminhadas para :attr:`func` com novos argumentos e palavras-chave."

#: ../../library/functools.rst:714
msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr ""
"Os argumentos posicionais mais à esquerda que serão prefixados aos "
"argumentos posicionais fornecidos a uma chamada de objeto :class:`partial`."

#: ../../library/functools.rst:720
msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object "
"is called."
msgstr ""
"Os argumentos de palavra-chave que serão fornecidos quando o objeto :class:"
"`partial` for chamado."

#: ../../library/functools.rst:723
msgid ""
":class:`partial` objects are like :class:`function` objects in that they are "
"callable, weak referenceable, and can have attributes.  There are some "
"important differences.  For instance, the :attr:`~definition.__name__` and :"
"attr:`__doc__` attributes are not created automatically.  Also, :class:"
"`partial` objects defined in classes behave like static methods and do not "
"transform into bound methods during instance attribute look-up."
msgstr ""
