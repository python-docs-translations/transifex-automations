# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-09 17:38+0000\n"
"PO-Revision-Date: 2025-09-22 15:57+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/contextlib.rst:2
msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ""
":mod:`!contextlib` --- Utilitários para contextos de instruções :keyword:`!"
"with`"

#: ../../library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**Código-fonte:** :source:`Lib/contextlib.py`"

#: ../../library/contextlib.rst:11
msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"Este módulo fornece utilitários para tarefas comuns envolvendo a instrução :"
"keyword:`with`. Para mais informações, veja também :ref:`typecontextmanager` "
"e :ref:`context-managers`."

#: ../../library/contextlib.rst:17
msgid "Utilities"
msgstr "Utilitários"

#: ../../library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr "Funções e classes fornecidas:"

#: ../../library/contextlib.rst:23
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
"Uma :term:`classe base abstrata` para classes que implementam :meth:`object."
"__enter__` e :meth:`object.__exit__`. Uma implementação predefinida para :"
"meth:`object.__enter__` é fornecida, que devolve ``self``, enquanto :meth:"
"`object.__exit__` é um método abstrato que, por predefinição, devolve "
"``None``. Veja também a definição de :ref:`typecontextmanager`."

#: ../../library/contextlib.rst:34
msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
"Uma :term:`classe base abstrata` para classes que implementam :meth:`object."
"__aenter__` e :meth:`object.__aexit__`. Uma implementação predefinida para :"
"meth:`object.__aenter__` é fornecida, que devolve ``self``, enquanto :meth:"
"`object.__aexit__` é um método abstrato que, por predefinição, devolve "
"``None``. Veja também a definição de :ref:`async-context-managers`."

#: ../../library/contextlib.rst:46
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""

#: ../../library/contextlib.rst:50
msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``"
msgstr ""

#: ../../library/contextlib.rst:54
msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""
"Um exemplo abstrato seria o seguinte para garantir a gestão correta de "
"recursos::"

#: ../../library/contextlib.rst:69
msgid "The function can then be used like this::"
msgstr "A função pode então ser usada assim::"

#: ../../library/contextlib.rst:75
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"A função decorada deve devolver um iterador :term:`gerador` quando chamada. "
"Este iterador deve produzir exatamente um valor, que será ligado aos alvos "
"na cláusula :keyword:`!as` da instrução :keyword:`with`, se houver."

#: ../../library/contextlib.rst:79
msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"No ponto em que o gerador produz, o bloco aninhado na instrução :keyword:"
"`with` é executado. O gerador é então retomado após o bloco ser saído. Se "
"uma exceção não tratada ocorrer no bloco, é relançada dentro do gerador no "
"ponto em que o yield ocorreu. Assim, pode usar uma instrução :keyword:"
"`try`... :keyword:`except`... :keyword:`finally` para capturar o erro (se "
"houver), ou garantir que alguma limpeza seja feita. Se uma exceção for "
"capturada apenas para a registar ou para realizar alguma ação (em vez de a "
"suprimir totalmente), o gerador deve relançar essa exceção. Caso contrário, "
"o gestor de contexto do gerador indicará à instrução :keyword:`!with` que a "
"exceção foi tratada, e a execução será retomada com a instrução "
"imediatamente seguinte à instrução :keyword:`!with`."

#: ../../library/contextlib.rst:91
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` usa :class:`ContextDecorator`, de modo que os "
"gestores de contexto que cria podem ser usados como decoradores, bem como em "
"instruções :keyword:`with`. Quando usado como decorador, uma nova instância "
"de gerador é implicitamente criada em cada chamada de função (isto permite "
"que os gestores de contexto \"de uso único\" criados por :func:"
"`contextmanager` cumpram o requisito de que os gestores de contexto suportem "
"múltiplas invocações para serem usados como decoradores)."

#: ../../library/contextlib.rst:98
msgid "Use of :class:`ContextDecorator`."
msgstr "Uso de :class:`ContextDecorator`."

#: ../../library/contextlib.rst:104
msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
"Semelhante a :func:`~contextlib.contextmanager`, mas cria um :ref:`gestor de "
"contexto assíncrono <async-context-managers>`."

#: ../../library/contextlib.rst:107
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`__aenter__` and :meth:"
"`__aexit__` methods. It must be applied to an :term:`asynchronous generator` "
"function."
msgstr ""

#: ../../library/contextlib.rst:113
msgid "A simple example::"
msgstr "Um exemplo simples::"

#: ../../library/contextlib.rst:131
msgid ""
"Context managers defined with :func:`asynccontextmanager` can be used either "
"as decorators or with :keyword:`async with` statements::"
msgstr ""
"Os gestores de contexto definidos com :func:`asynccontextmanager` podem ser "
"usados como decoradores ou com instruções :keyword:`async with`::"

#: ../../library/contextlib.rst:149
msgid ""
"When used as a decorator, a new generator instance is implicitly created on "
"each function call. This allows the otherwise \"one-shot\" context managers "
"created by :func:`asynccontextmanager` to meet the requirement that context "
"managers support multiple invocations in order to be used as decorators."
msgstr ""
"Quando usado como decorador, uma nova instância de gerador é implicitamente "
"criada em cada chamada de função. Isto permite que os gestores de contexto "
"\"de uso único\" criados por :func:`asynccontextmanager` cumpram o requisito "
"de que os gestores de contexto suportem múltiplas invocações para serem "
"usados como decoradores."

#: ../../library/contextlib.rst:154
msgid ""
"Async context managers created with :func:`asynccontextmanager` can be used "
"as decorators."
msgstr ""
"Os gestores de contexto assíncronos criados com :func:`asynccontextmanager` "
"podem ser usados como decoradores."

#: ../../library/contextlib.rst:161
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""
"Devolve um gestor de contexto que fecha *thing* após a conclusão do bloco. "
"Isto é basicamente equivalente a::"

#: ../../library/contextlib.rst:173
msgid "And lets you write code like this::"
msgstr "E permite escrever código como este::"

#: ../../library/contextlib.rst:182
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"sem necessidade de fechar explicitamente ``page``. Mesmo que ocorra um erro, "
"``page.close()`` será chamado quando o bloco :keyword:`with` for saído."

#: ../../library/contextlib.rst:188
msgid ""
"Return an async context manager that calls the ``aclose()`` method of "
"*thing* upon completion of the block.  This is basically equivalent to::"
msgstr ""
"Devolve um gestor de contexto assíncrono que chama o método ``aclose()`` de "
"*thing* após a conclusão do bloco. Isto é basicamente equivalente a::"

#: ../../library/contextlib.rst:200
msgid ""
"Significantly, ``aclosing()`` supports deterministic cleanup of async "
"generators when they happen to exit early by :keyword:`break` or an "
"exception.  For example::"
msgstr ""
"Significativamente, ``aclosing()`` suporta limpeza determinística de "
"geradores assíncronos quando saem antecipadamente por :keyword:`break` ou "
"uma exceção. Por exemplo::"

#: ../../library/contextlib.rst:211
msgid ""
"This pattern ensures that the generator's async exit code is executed in the "
"same context as its iterations (so that exceptions and context variables "
"work as expected, and the exit code isn't run after the lifetime of some "
"task it depends on)."
msgstr ""
"Este padrão garante que o código de saída assíncrono do gerador é executado "
"no mesmo contexto que as suas iterações (para que exceções e variáveis de "
"contexto funcionem como esperado, e o código de saída não seja executado "
"após o tempo de vida de alguma tarefa da qual depende)."

#: ../../library/contextlib.rst:223
msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"Devolve um gestor de contexto que devolve *enter_result* de ``__enter__``, "
"mas que, de resto, não faz nada. Destina-se a ser usado como substituto para "
"um gestor de contexto opcional, por exemplo::"

#: ../../library/contextlib.rst:237
msgid "An example using *enter_result*::"
msgstr "Um exemplo usando *enter_result*::"

#: ../../library/contextlib.rst:250
msgid ""
"It can also be used as a stand-in for :ref:`asynchronous context managers "
"<async-context-managers>`::"
msgstr ""
"Também pode ser usado como substituto para :ref:`gestores de contexto "
"assíncronos <async-context-managers>`::"

#: ../../library/contextlib.rst:266
msgid ":term:`asynchronous context manager` support was added."
msgstr "Foi adicionado suporte para :term:`gestor de contexto assíncrono`."

#: ../../library/contextlib.rst:273
msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a :keyword:`!with` statement and then resumes "
"execution with the first statement following the end of the :keyword:`!with` "
"statement."
msgstr ""
"Devolve um gestor de contexto que suprime quaisquer das exceções "
"especificadas se ocorrerem no corpo de uma instrução :keyword:`!with` e, em "
"seguida, retoma a execução com a primeira instrução seguinte ao final da "
"instrução :keyword:`!with`."

#: ../../library/contextlib.rst:278
msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr ""
"Como qualquer outro mecanismo que suprime completamente exceções, este "
"gestor de contexto deve ser usado apenas para cobrir erros muito específicos "
"onde continuar silenciosamente com a execução do programa é sabidamente a "
"coisa certa a fazer."

#: ../../library/contextlib.rst:283
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/contextlib.rst:293
msgid "This code is equivalent to::"
msgstr "Este código é equivalente a::"

#: ../../library/contextlib.rst:305 ../../library/contextlib.rst:345
#: ../../library/contextlib.rst:355
msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "Este gestor de contexto é :ref:`reentrante <reentrant-cms>`."

#: ../../library/contextlib.rst:312
msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""
"Gestor de contexto para redirecionar temporariamente :data:`sys.stdout` para "
"outro ficheiro ou objeto semelhante a ficheiro."

#: ../../library/contextlib.rst:315
msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""
"Esta ferramenta adiciona flexibilidade a funções ou classes existentes cuja "
"saída está fixa para stdout."

#: ../../library/contextlib.rst:318
msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object. The replacement stream is returned from the "
"``__enter__`` method and so is available as the target of the :keyword:"
"`with` statement::"
msgstr ""
"Por exemplo, a saída de :func:`help` normalmente é enviada para *sys."
"stdout*. Pode capturar essa saída numa string redirecionando a saída para um "
"objeto :class:`io.StringIO`. O fluxo de substituição é devolvido pelo método "
"``__enter__`` e, portanto, está disponível como alvo da instrução :keyword:"
"`with`::"

#: ../../library/contextlib.rst:328
msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr ""
"Para enviar a saída de :func:`help` para um ficheiro no disco, redirecione a "
"saída para um ficheiro regular::"

#: ../../library/contextlib.rst:335
msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr "Para enviar a saída de :func:`help` para *sys.stderr*::"

#: ../../library/contextlib.rst:340
msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
"Note que o efeito colateral global em :data:`sys.stdout` significa que este "
"gestor de contexto não é adequado para uso em código de biblioteca e na "
"maioria das aplicações com threads. Também não tem efeito na saída de "
"subprocessos. No entanto, ainda é uma abordagem útil para muitos scripts "
"utilitários."

#: ../../library/contextlib.rst:352
msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
"Semelhante a :func:`~contextlib.redirect_stdout`, mas redirecionando :data:"
"`sys.stderr` para outro ficheiro ou objeto semelhante a ficheiro."

#: ../../library/contextlib.rst:362
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""
"Uma classe base que permite que um gestor de contexto também seja usado como "
"um decorador."

#: ../../library/contextlib.rst:364
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"Os gestores de contexto que herdam de ``ContextDecorator`` têm de "
"implementar ``__enter__`` e ``__exit__`` normalmente. ``__exit__`` mantém o "
"seu tratamento opcional de exceções, mesmo quando usado como decorador."

#: ../../library/contextlib.rst:368
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
"``ContextDecorator`` é usado por :func:`contextmanager`, por isso obtém esta "
"funcionalidade automaticamente."

#: ../../library/contextlib.rst:371
msgid "Example of ``ContextDecorator``::"
msgstr "Exemplo de ``ContextDecorator``::"

#: ../../library/contextlib.rst:384 ../../library/contextlib.rst:456
msgid "The class can then be used like this::"
msgstr "A classe pode então ser usada assim::"

#: ../../library/contextlib.rst:402
msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr ""
"Esta alteração é apenas açúcar sintático para qualquer construção da "
"seguinte forma::"

#: ../../library/contextlib.rst:408
msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` permite-lhe escrever em vez disso::"

#: ../../library/contextlib.rst:414
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"Torna claro que o ``cm`` se aplica a toda a função, em vez de apenas a uma "
"parte dela (e poupar um nível de indentação também é bom)."

#: ../../library/contextlib.rst:417
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"Os gestores de contexto existentes que já têm uma classe base podem ser "
"estendidos usando ``ContextDecorator`` como uma classe mixin::"

#: ../../library/contextlib.rst:430
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"Como a função decorada deve poder ser chamada várias vezes, o gestor de "
"contexto subjacente deve suportar uso em múltiplas instruções :keyword:"
"`with`. Se não for o caso, então a construção original com a instrução :"
"keyword:`!with` explícita dentro da função deve ser usada."

#: ../../library/contextlib.rst:440
msgid ""
"Similar to :class:`ContextDecorator` but only for asynchronous functions."
msgstr ""
"Semelhante a :class:`ContextDecorator`, mas apenas para funções assíncronas."

#: ../../library/contextlib.rst:442
msgid "Example of ``AsyncContextDecorator``::"
msgstr "Exemplo de ``AsyncContextDecorator``::"

#: ../../library/contextlib.rst:481
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"Um gestor de contexto concebido para facilitar a combinação programática de "
"outros gestores de contexto e funções de limpeza, especialmente aquelas que "
"são opcionais ou de outra forma orientadas por dados de entrada."

#: ../../library/contextlib.rst:485
msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr ""
"Por exemplo, um conjunto de ficheiros pode ser facilmente tratado numa única "
"instrução with da seguinte forma::"

#: ../../library/contextlib.rst:494
msgid ""
"The :meth:`__enter__` method returns the :class:`ExitStack` instance, and "
"performs no additional operations."
msgstr ""

#: ../../library/contextlib.rst:497
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"Cada instância mantém uma pilha de callbacks registados que são chamados em "
"ordem inversa quando a instância é fechada (explícita ou implicitamente no "
"final de uma instrução :keyword:`with`). Note que os callbacks *não* são "
"invocados implicitamente quando a instância da pilha de contexto é recolhida "
"pelo garbage collector."

#: ../../library/contextlib.rst:502
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""
"Este modelo de pilha é usado para que os gestores de contexto que adquirem "
"os seus recursos no método ``__init__`` (como objetos de ficheiro) possam "
"ser tratados corretamente."

#: ../../library/contextlib.rst:506
msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"Como os callbacks registados são invocados na ordem inversa do registo, isto "
"acaba por se comportar como se múltiplas instruções :keyword:`with` "
"aninhadas tivessem sido usadas com o conjunto de callbacks registados. Isto "
"até se estende ao tratamento de exceções - se um callback interno suprimir "
"ou substituir uma exceção, então os callbacks externos receberão argumentos "
"baseados nesse estado atualizado."

#: ../../library/contextlib.rst:513
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"Esta é uma API de nível relativamente baixo que trata dos detalhes de "
"desempilhar corretamente a pilha de callbacks de saída. Fornece uma base "
"adequada para gestores de contexto de nível superior que manipulam a pilha "
"de saída de formas específicas da aplicação."

#: ../../library/contextlib.rst:522
msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own :"
"meth:`__enter__` method."
msgstr ""

#: ../../library/contextlib.rst:526
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""
"Estes gestores de contexto podem suprimir exceções tal como normalmente "
"fariam se usados diretamente como parte de uma instrução :keyword:`with`."

#: ../../library/contextlib.rst:531
msgid "Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr ""

#: ../../library/contextlib.rst:533
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own :meth:"
"`__exit__` method."
msgstr ""

#: ../../library/contextlib.rst:537
msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""

#: ../../library/contextlib.rst:541
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr ""

#: ../../library/contextlib.rst:544
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""
"O objeto passado é devolvido pela função, permitindo que este método seja "
"usado como um decorador de função."

#: ../../library/contextlib.rst:549
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr ""
"Aceita uma função de callback arbitrária e argumentos e adiciona-a à pilha "
"de callbacks."

#: ../../library/contextlib.rst:552
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""
"Ao contrário dos outros métodos, os callbacks adicionados desta forma não "
"podem suprimir exceções (uma vez que nunca recebem os detalhes da exceção)."

#: ../../library/contextlib.rst:555
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""
"O callback passado é devolvido pela função, permitindo que este método seja "
"usado como um decorador de função."

#: ../../library/contextlib.rst:560
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"Transfere a pilha de callbacks para uma nova instância :class:`ExitStack` e "
"devolve-a. Nenhum callback é invocado por esta operação - em vez disso, "
"serão agora invocados quando a nova pilha for fechada (explícita ou "
"implicitamente no final de uma instrução :keyword:`with`)."

#: ../../library/contextlib.rst:565
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""
"Por exemplo, um grupo de ficheiros pode ser aberto como uma operação \"tudo "
"ou nada\" da seguinte forma::"

#: ../../library/contextlib.rst:579
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""
"Desempilha imediatamente a pilha de callbacks, invocando callbacks na ordem "
"inversa do registo. Para quaisquer gestores de contexto e callbacks de saída "
"registados, os argumentos passados indicarão que nenhuma exceção ocorreu."

#: ../../library/contextlib.rst:586
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
"Um :ref:`gestor de contexto assíncrono <async-context-managers>`, semelhante "
"a :class:`ExitStack`, que suporta a combinação de gestores de contexto "
"síncronos e assíncronos, bem como ter corrotinas para lógica de limpeza."

#: ../../library/contextlib.rst:591
msgid ""
"The :meth:`close` method is not implemented, :meth:`aclose` must be used "
"instead."
msgstr ""

#: ../../library/contextlib.rst:596
msgid ""
"Similar to :meth:`enter_context` but expects an asynchronous context manager."
msgstr ""

#: ../../library/contextlib.rst:601
msgid ""
"Similar to :meth:`push` but expects either an asynchronous context manager "
"or a coroutine function."
msgstr ""

#: ../../library/contextlib.rst:606
msgid "Similar to :meth:`callback` but expects a coroutine function."
msgstr ""

#: ../../library/contextlib.rst:610
msgid "Similar to :meth:`close` but properly handles awaitables."
msgstr ""

#: ../../library/contextlib.rst:612
msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr "Continuando o exemplo para :func:`asynccontextmanager`::"

#: ../../library/contextlib.rst:624
msgid "Examples and Recipes"
msgstr "Exemplos e Receitas"

#: ../../library/contextlib.rst:626
msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""
"Esta secção descreve alguns exemplos e receitas para fazer uso efetivo das "
"ferramentas fornecidas por :mod:`contextlib`."

#: ../../library/contextlib.rst:631
msgid "Supporting a variable number of context managers"
msgstr "Suportar um número variável de gestores de contexto"

#: ../../library/contextlib.rst:633
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
"O caso de uso primário para :class:`ExitStack` é o dado na documentação da "
"classe: suportar um número variável de gestores de contexto e outras "
"operações de limpeza numa única instrução :keyword:`with`. A variabilidade "
"pode vir do número de gestores de contexto necessários ser determinado pela "
"entrada do utilizador (como abrir uma coleção de ficheiros especificada pelo "
"utilizador), ou de alguns dos gestores de contexto serem opcionais::"

#: ../../library/contextlib.rst:648
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"Como mostrado, :class:`ExitStack` também torna bastante fácil usar "
"instruções :keyword:`with` para gerir recursos arbitrários que não suportam "
"nativamente o protocolo de gestão de contexto."

#: ../../library/contextlib.rst:654
msgid "Catching exceptions from ``__enter__`` methods"
msgstr "Capturar exceções de métodos ``__enter__``"

#: ../../library/contextlib.rst:656
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"Às vezes é desejável capturar exceções de uma implementação de método "
"``__enter__``, *sem* capturar inadvertidamente exceções do corpo da "
"instrução :keyword:`with` ou do método ``__exit__`` do gestor de contexto. "
"Ao usar :class:`ExitStack`, os passos no protocolo de gestão de contexto "
"podem ser separados ligeiramente para permitir isto::"

#: ../../library/contextlib.rst:671
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"Na verdade, a necessidade de fazer isto é provável que indique que a API "
"subjacente deveria fornecer uma interface de gestão de recursos direta para "
"uso com instruções :keyword:`try`/:keyword:`except`/:keyword:`finally`, mas "
"nem todas as APIs são bem concebidas nesse aspeto. Quando um gestor de "
"contexto é a única API de gestão de recursos fornecida, então :class:"
"`ExitStack` pode facilitar o tratamento de várias situações que não podem "
"ser tratadas diretamente numa instrução :keyword:`with`."

#: ../../library/contextlib.rst:681
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "Limpeza numa implementação ``__enter__``"

#: ../../library/contextlib.rst:683
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`__enter__` implementation fail."
msgstr ""

#: ../../library/contextlib.rst:687
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"Aqui está um exemplo de como fazer isto para um gestor de contexto que "
"aceita funções de aquisição e libertação de recursos, juntamente com uma "
"função de validação opcional, e as mapeia para o protocolo de gestão de "
"contexto::"

#: ../../library/contextlib.rst:727
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "Substituir qualquer uso de ``try-finally`` e variáveis de flag"

#: ../../library/contextlib.rst:729
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"Um padrão que às vezes verá é uma instrução ``try-finally`` com uma variável "
"de flag para indicar se o corpo da cláusula ``finally`` deve ou não ser "
"executado. Na sua forma mais simples (que não pode já ser tratada apenas "
"usando uma cláusula ``except`` em vez disso), parece algo como isto::"

#: ../../library/contextlib.rst:743
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"Como com qualquer código baseado em instruções ``try``, isto pode causar "
"problemas para desenvolvimento e revisão, porque o código de configuração e "
"o código de limpeza podem acabar separados por secções de código "
"arbitrariamente longas."

#: ../../library/contextlib.rst:747
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` torna possível registar um callback para execução no "
"final de uma instrução ``with``, e depois decidir mais tarde ignorar a "
"execução desse callback::"

#: ../../library/contextlib.rst:759
msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""

#: ../../library/contextlib.rst:762
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""
"Se uma aplicação específica usar muito este padrão, pode ser simplificado "
"ainda mais por meio de uma pequena classe auxiliar::"

#: ../../library/contextlib.rst:780
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"Se a limpeza do recurso não estiver já agrupada num função independente, "
"ainda é possível usar a forma de decorador de :meth:`ExitStack.callback` "
"para declarar a limpeza do recurso antecipadamente::"

#: ../../library/contextlib.rst:795
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""
"Devido à forma como o protocolo de decorador funciona, uma função de "
"callback declarada desta forma não pode aceitar quaisquer parâmetros. Em vez "
"disso, quaisquer recursos a serem libertados devem ser acessados como "
"variáveis de closure."

#: ../../library/contextlib.rst:801
msgid "Using a context manager as a function decorator"
msgstr "Usar um gestor de contexto como um decorador de função"

#: ../../library/contextlib.rst:803
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` torna possível usar um gestor de contexto tanto "
"numa instrução ``with`` comum como também como um decorador de função."

#: ../../library/contextlib.rst:806
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"Por exemplo, às vezes é útil envolver funções ou grupos de instruções com um "
"registador que pode acompanhar o tempo de entrada e o tempo de saída. Em vez "
"de escrever tanto um decorador de função como um gestor de contexto para a "
"tarefa, herdar de :class:`ContextDecorator` fornece ambas as capacidades "
"numa única definição::"

#: ../../library/contextlib.rst:827
msgid "Instances of this class can be used as both a context manager::"
msgstr "Instâncias desta classe podem ser usadas como um gestor de contexto::"

#: ../../library/contextlib.rst:833
msgid "And also as a function decorator::"
msgstr "E também como um decorador de função::"

#: ../../library/contextlib.rst:840
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`__enter__`. If that value is needed, then it is still necessary to use an "
"explicit ``with`` statement."
msgstr ""

#: ../../library/contextlib.rst:848
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - A instrução 'with'"

#: ../../library/contextlib.rst:848
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""
"A especificação, contexto e exemplos para a instrução :keyword:`with` do "
"Python."

#: ../../library/contextlib.rst:854
msgid "Single use, reusable and reentrant context managers"
msgstr "Gestores de contexto de uso único, reutilizáveis e reentrantes"

#: ../../library/contextlib.rst:856
msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"A maioria dos gestores de contexto são escritos de forma a que só possam ser "
"usados efetivamente numa instrução :keyword:`with` uma vez. Estes gestores "
"de contexto de uso único devem ser criados de novo cada vez que são usados - "
"tentar usá-los uma segunda vez desencadeará uma exceção ou não funcionará "
"corretamente."

#: ../../library/contextlib.rst:862
msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""
"Esta limitação comum significa que é geralmente aconselhável criar gestores "
"de contexto diretamente no cabeçalho da instrução :keyword:`with` onde são "
"usados (como mostrado em todos os exemplos de uso acima)."

#: ../../library/contextlib.rst:866
msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"Os ficheiros são um exemplo de gestores de contexto efetivamente de uso "
"único, uma vez que a primeira instrução :keyword:`with` fechará o ficheiro, "
"impedindo quaisquer operações de IO adicionais usando esse objeto de "
"ficheiro."

#: ../../library/contextlib.rst:870
msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
"Os gestores de contexto criados usando :func:`contextmanager` também são "
"gestores de contexto de uso único e reclamarão sobre o gerador subjacente "
"que falha ao produzir se for feita uma tentativa de os usar uma segunda vez::"

#: ../../library/contextlib.rst:898
msgid "Reentrant context managers"
msgstr "Gestores de contexto reentrantes"

#: ../../library/contextlib.rst:900
msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"Gestores de contexto mais sofisticados podem ser \"reentrantes\". Estes "
"gestores de contexto podem não só ser usados em múltiplas instruções :"
"keyword:`with`, mas também podem ser usados *dentro* de uma instrução :"
"keyword:`!with` que já está a usar o mesmo gestor de contexto."

#: ../../library/contextlib.rst:905
msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress` and :func:`redirect_stdout`. Here's a very simple "
"example of reentrant use::"
msgstr ""

#: ../../library/contextlib.rst:924
msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""
"Exemplos do mundo real de reentrada são mais propensos a envolver múltiplas "
"funções a chamarem-se umas às outras e, portanto, serem muito mais "
"complicados do que este exemplo."

#: ../../library/contextlib.rst:928
msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"Note também que ser reentrante *não* é a mesma coisa que ser thread-safe. :"
"func:`redirect_stdout`, por exemplo, definitivamente não é thread-safe, pois "
"faz uma modificação global no estado do sistema ao ligar :data:`sys.stdout` "
"a um fluxo diferente."

#: ../../library/contextlib.rst:937
msgid "Reusable context managers"
msgstr "Gestores de contexto reutilizáveis"

#: ../../library/contextlib.rst:939
msgid ""
"Distinct from both single use and reentrant context managers are "
"\"reusable\" context managers (or, to be completely explicit, \"reusable, "
"but not reentrant\" context managers, since reentrant context managers are "
"also reusable). These context managers support being used multiple times, "
"but will fail (or otherwise not work correctly) if the specific context "
"manager instance has already been used in a containing with statement."
msgstr ""
"Distintos tanto dos gestores de contexto de uso único como dos reentrantes "
"estão os gestores de contexto \"reutilizáveis\" (ou, para ser completamente "
"explícito, gestores de contexto \"reutilizáveis, mas não reentrantes\", uma "
"vez que os gestores de contexto reentrantes também são reutilizáveis). Estes "
"gestores de contexto suportam ser usados várias vezes, mas falharão (ou não "
"funcionarão corretamente) se a instância específica do gestor de contexto já "
"tiver sido usada numa instrução with contenedora."

#: ../../library/contextlib.rst:946
msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` é um exemplo de um gestor de contexto reutilizável, "
"mas não reentrante (para um bloqueio reentrante, é necessário usar :class:"
"`threading.RLock` em vez disso)."

#: ../../library/contextlib.rst:950
msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"Outro exemplo de um gestor de contexto reutilizável, mas não reentrante, é :"
"class:`ExitStack`, pois invoca *todos* os callbacks atualmente registados ao "
"sair de qualquer instrução with, independentemente de onde esses callbacks "
"foram adicionados::"

#: ../../library/contextlib.rst:981
msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"Como a saída do exemplo mostra, reutilizar um único objeto de pilha em "
"várias instruções with funciona corretamente, mas tentar aninhá-las fará com "
"que a pilha seja limpa no final da instrução with mais interna, o que é "
"improvável de ser um comportamento desejável."

#: ../../library/contextlib.rst:986
msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
"Usar instâncias separadas de :class:`ExitStack` em vez de reutilizar uma "
"única instância evita esse problema::"
