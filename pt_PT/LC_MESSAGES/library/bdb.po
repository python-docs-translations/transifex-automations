# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-05 16:42+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/bdb.rst:2
msgid ":mod:`bdb` --- Debugger framework"
msgstr ""

#: ../../library/bdb.rst:7
msgid "**Source code:** :source:`Lib/bdb.py`"
msgstr "**Código-fonte:** :source:`Lib/bdb.py`"

#: ../../library/bdb.rst:11
msgid ""
"The :mod:`bdb` module handles basic debugger functions, like setting "
"breakpoints or managing execution via the debugger."
msgstr ""
"O módulo :mod:`bdb` trata das funções básicas de depuração, como definir "
"pontos de interrupção ou gerir a execução através do depurador."

#: ../../library/bdb.rst:14
msgid "The following exception is defined:"
msgstr "A seguinte exceção é definida:"

#: ../../library/bdb.rst:18
msgid "Exception raised by the :class:`Bdb` class for quitting the debugger."
msgstr "Exceção levantada pela classe :class:`Bdb` para sair do depurador."

#: ../../library/bdb.rst:21
msgid "The :mod:`bdb` module also defines two classes:"
msgstr "O módulo :mod:`bdb` também define duas classes:"

#: ../../library/bdb.rst:25
msgid ""
"This class implements temporary breakpoints, ignore counts, disabling and "
"(re-)enabling, and conditionals."
msgstr ""
"Esta classe implementa pontos de interrupção temporários, contagens de "
"ignorar, desativação e reativação, e condicionais."

#: ../../library/bdb.rst:28
msgid ""
"Breakpoints are indexed by number through a list called :attr:`bpbynumber` "
"and by ``(file, line)`` pairs through :attr:`bplist`.  The former points to "
"a single instance of class :class:`Breakpoint`.  The latter points to a list "
"of such instances since there may be more than one breakpoint per line."
msgstr ""
"Os pontos de interrupção são indexados por número através de uma lista "
"chamada :attr:`bpbynumber` e por pares ``(ficheiro, linha)`` através de :"
"attr:`bplist`. O primeiro aponta para uma única instância da classe :class:"
"`Breakpoint`. O último aponta para uma lista de tais instâncias, uma vez que "
"pode haver mais do que um ponto de interrupção por linha."

#: ../../library/bdb.rst:33
msgid ""
"When creating a breakpoint, its associated :attr:`file name <file>` should "
"be in canonical form.  If a :attr:`funcname` is defined, a breakpoint :attr:"
"`hit <hits>` will be counted when the first line of that function is "
"executed.  A :attr:`conditional <cond>` breakpoint always counts a :attr:"
"`hit <hits>`."
msgstr ""
"Ao criar um ponto de interrupção, o seu :attr:`nome de ficheiro <file>` "
"associado deve estar em forma canónica. Se um :attr:`funcname` for definido, "
"um :attr:`hit <hits>` de ponto de interrupção será contado quando a primeira "
"linha dessa função for executada. Um ponto de interrupção :attr:`condicional "
"<cond>` conta sempre um :attr:`hit <hits>`."

#: ../../library/bdb.rst:39
msgid ":class:`Breakpoint` instances have the following methods:"
msgstr "As instâncias :class:`Breakpoint` têm os seguintes métodos:"

#: ../../library/bdb.rst:43
msgid ""
"Delete the breakpoint from the list associated to a file/line.  If it is the "
"last breakpoint in that position, it also deletes the entry for the file/"
"line."
msgstr ""
"Apaga o ponto de interrupção da lista associada a um ficheiro/linha. Se for "
"o último ponto de interrupção nessa posição, também apaga a entrada para o "
"ficheiro/linha."

#: ../../library/bdb.rst:50
msgid "Mark the breakpoint as enabled."
msgstr "Marca o ponto de interrupção como ativado."

#: ../../library/bdb.rst:55
msgid "Mark the breakpoint as disabled."
msgstr "Marca o ponto de interrupção como desativado."

#: ../../library/bdb.rst:60
msgid ""
"Return a string with all the information about the breakpoint, nicely "
"formatted:"
msgstr ""
"Retorna uma string com toda a informação sobre o ponto de interrupção, bem "
"formatada:"

#: ../../library/bdb.rst:63
msgid "Breakpoint number."
msgstr "Número do ponto de interrupção."

#: ../../library/bdb.rst:64
msgid "Temporary status (del or keep)."
msgstr "Estado temporário (del ou keep)."

#: ../../library/bdb.rst:65
msgid "File/line position."
msgstr "Posição ficheiro/linha."

#: ../../library/bdb.rst:66
msgid "Break condition."
msgstr "Condição de interrupção."

#: ../../library/bdb.rst:67
msgid "Number of times to ignore."
msgstr "Número de vezes a ignorar."

#: ../../library/bdb.rst:68
msgid "Number of times hit."
msgstr "Número de vezes atingido."

#: ../../library/bdb.rst:74
msgid ""
"Print the output of :meth:`bpformat` to the file *out*, or if it is "
"``None``, to standard output."
msgstr ""
"Imprime a saída de :meth:`bpformat` para o ficheiro *out*, ou se for "
"``None``, para a saída padrão."

#: ../../library/bdb.rst:77
msgid ":class:`Breakpoint` instances have the following attributes:"
msgstr "As instâncias :class:`Breakpoint` têm os seguintes atributos:"

#: ../../library/bdb.rst:81
msgid "File name of the :class:`Breakpoint`."
msgstr "Nome do ficheiro do :class:`Breakpoint`."

#: ../../library/bdb.rst:85
msgid "Line number of the :class:`Breakpoint` within :attr:`file`."
msgstr "Número da linha do :class:`Breakpoint` dentro de :attr:`file`."

#: ../../library/bdb.rst:89
msgid "True if a :class:`Breakpoint` at (file, line) is temporary."
msgstr ""

#: ../../library/bdb.rst:93
msgid "Condition for evaluating a :class:`Breakpoint` at (file, line)."
msgstr "Condição para avaliar um :class:`Breakpoint` em (ficheiro, linha)."

#: ../../library/bdb.rst:97
msgid ""
"Function name that defines whether a :class:`Breakpoint` is hit upon "
"entering the function."
msgstr ""
"Nome da função que define se um :class:`Breakpoint` é atingido ao entrar na "
"função."

#: ../../library/bdb.rst:102
msgid "True if :class:`Breakpoint` is enabled."
msgstr ""

#: ../../library/bdb.rst:106
msgid "Numeric index for a single instance of a :class:`Breakpoint`."
msgstr "Índice numérico para uma única instância de um :class:`Breakpoint`."

#: ../../library/bdb.rst:110
msgid ""
"Dictionary of :class:`Breakpoint` instances indexed by (:attr:`file`, :attr:"
"`line`) tuples."
msgstr ""
"Dicionário de instâncias :class:`Breakpoint` indexadas por tuplos (:attr:"
"`file`, :attr:`line`)."

#: ../../library/bdb.rst:115
msgid "Number of times to ignore a :class:`Breakpoint`."
msgstr "Número de vezes para ignorar um :class:`Breakpoint`."

#: ../../library/bdb.rst:119
msgid "Count of the number of times a :class:`Breakpoint` has been hit."
msgstr "Contagem do número de vezes que um :class:`Breakpoint` foi atingido."

#: ../../library/bdb.rst:123
msgid "The :class:`Bdb` class acts as a generic Python debugger base class."
msgstr ""
"A classe :class:`Bdb` atua como uma classe base genérica de depurador Python."

#: ../../library/bdb.rst:125
msgid ""
"This class takes care of the details of the trace facility; a derived class "
"should implement user interaction.  The standard debugger class (:class:`pdb."
"Pdb`) is an example."
msgstr ""
"Esta classe trata dos detalhes da funcionalidade de rastreio; uma classe "
"derivada deve implementar a interação com o utilizador. A classe de "
"depurador padrão (:class:`pdb.Pdb`) é um exemplo."

#: ../../library/bdb.rst:129
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. Whether a frame is considered to "
"originate in a certain module is determined by the ``__name__`` in the frame "
"globals."
msgstr ""
"O argumento *skip*, se fornecido, deve ser um iterável de padrões de nomes "
"de módulos no estilo glob. O depurador não entrará em quadros que se "
"originem num módulo que corresponda a um destes padrões. Se um quadro é "
"considerado originário de um certo módulo é determinado pelo ``__name__`` "
"nos globais do quadro."

#: ../../library/bdb.rst:135
msgid "Added the *skip* parameter."
msgstr "Adicionado o parâmetro *skip*."

#: ../../library/bdb.rst:138
msgid ""
"The following methods of :class:`Bdb` normally don't need to be overridden."
msgstr ""
"Os seguintes métodos de :class:`Bdb` normalmente não precisam de ser "
"substituídos."

#: ../../library/bdb.rst:142
msgid "Return canonical form of *filename*."
msgstr "Retorna a forma canónica de *filename*."

#: ../../library/bdb.rst:144
msgid ""
"For real file names, the canonical form is an operating-system-dependent, :"
"func:`case-normalized <os.path.normcase>` :func:`absolute path <os.path."
"abspath>`. A *filename* with angle brackets, such as ``\"<stdin>\"`` "
"generated in interactive mode, is returned unchanged."
msgstr ""
"Para nomes de ficheiros reais, a forma canónica é um caminho absoluto "
"normalizado, dependente do sistema operativo, :func:`case-normalized <os."
"path.normcase>` :func:`absolute path <os.path.abspath>`. Um *filename* com "
"parênteses angulares, como ``\"<stdin>\"`` gerado no modo interativo, é "
"retornado inalterado."

#: ../../library/bdb.rst:151
msgid ""
"Set the :attr:`!botframe`, :attr:`!stopframe`, :attr:`!returnframe` and :"
"attr:`quitting <Bdb.set_quit>` attributes with values ready to start "
"debugging."
msgstr ""
"Define os atributos :attr:`!botframe`, :attr:`!stopframe`, :attr:`!"
"returnframe` e :attr:`quitting <Bdb.set_quit>` com valores prontos para "
"iniciar a depuração."

#: ../../library/bdb.rst:156
msgid ""
"This function is installed as the trace function of debugged frames.  Its "
"return value is the new trace function (in most cases, that is, itself)."
msgstr ""
"Esta função é instalada como a função de rastreio dos quadros depurados. O "
"seu valor de retorno é a nova função de rastreio (na maioria dos casos, ou "
"seja, ela própria)."

#: ../../library/bdb.rst:159
msgid ""
"The default implementation decides how to dispatch a frame, depending on the "
"type of event (passed as a string) that is about to be executed. *event* can "
"be one of the following:"
msgstr ""
"A implementação padrão decide como despachar um quadro, dependendo do tipo "
"de evento (passado como uma string) que está prestes a ser executado. "
"*event* pode ser um dos seguintes:"

#: ../../library/bdb.rst:163
msgid "``\"line\"``: A new line of code is going to be executed."
msgstr "``\"line\"``: Uma nova linha de código vai ser executada."

#: ../../library/bdb.rst:164
msgid ""
"``\"call\"``: A function is about to be called, or another code block "
"entered."
msgstr ""
"``\"call\"``: Uma função está prestes a ser chamada, ou outro bloco de "
"código é inserido."

#: ../../library/bdb.rst:166
msgid "``\"return\"``: A function or other code block is about to return."
msgstr ""
"``\"return\"``: Uma função ou outro bloco de código está prestes a retornar."

#: ../../library/bdb.rst:167
msgid "``\"exception\"``: An exception has occurred."
msgstr "``\"exception\"``: Uma exceção ocorreu."

#: ../../library/bdb.rst:168
msgid "``\"c_call\"``: A C function is about to be called."
msgstr "``\"c_call\"``: Uma função C está prestes a ser chamada."

#: ../../library/bdb.rst:169
msgid "``\"c_return\"``: A C function has returned."
msgstr "``\"c_return\"``: Uma função C retornou."

#: ../../library/bdb.rst:170
msgid "``\"c_exception\"``: A C function has raised an exception."
msgstr "``\"c_exception\"``: Uma função C levantou uma exceção."

#: ../../library/bdb.rst:172
msgid ""
"For the Python events, specialized functions (see below) are called.  For "
"the C events, no action is taken."
msgstr ""
"Para os eventos Python, funções especializadas (ver abaixo) são chamadas. "
"Para os eventos C, nenhuma ação é tomada."

#: ../../library/bdb.rst:175
msgid "The *arg* parameter depends on the previous event."
msgstr "O parâmetro *arg* depende do evento anterior."

#: ../../library/bdb.rst:177
msgid ""
"See the documentation for :func:`sys.settrace` for more information on the "
"trace function.  For more information on code and frame objects, refer to :"
"ref:`types`."
msgstr ""
"Consulte a documentação para :func:`sys.settrace` para mais informações "
"sobre a função de rastreio. Para mais informações sobre objetos de código e "
"quadro, consulte :ref:`types`."

#: ../../library/bdb.rst:183
msgid ""
"If the debugger should stop on the current line, invoke the :meth:"
"`user_line` method (which should be overridden in subclasses). Raise a :exc:"
"`BdbQuit` exception if the :attr:`quitting  <Bdb.set_quit>` flag is set "
"(which can be set from :meth:`user_line`).  Return a reference to the :meth:"
"`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Se o depurador deve parar na linha atual, invoca o método :meth:`user_line` "
"(que deve ser substituído em subclasses). Levanta uma exceção :exc:`BdbQuit` "
"se a flag :attr:`quitting <Bdb.set_quit>` estiver definida (que pode ser "
"definida a partir de :meth:`user_line`). Retorna uma referência ao método :"
"meth:`trace_dispatch` para rastreio adicional nesse âmbito."

#: ../../library/bdb.rst:191
msgid ""
"If the debugger should stop on this function call, invoke the :meth:"
"`user_call` method (which should be overridden in subclasses). Raise a :exc:"
"`BdbQuit` exception if the :attr:`quitting  <Bdb.set_quit>` flag is set "
"(which can be set from :meth:`user_call`).  Return a reference to the :meth:"
"`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Se o depurador deve parar nesta chamada de função, invoca o método :meth:"
"`user_call` (que deve ser substituído em subclasses). Levanta uma exceção :"
"exc:`BdbQuit` se a flag :attr:`quitting <Bdb.set_quit>` estiver definida "
"(que pode ser definida a partir de :meth:`user_call`). Retorna uma "
"referência ao método :meth:`trace_dispatch` para rastreio adicional nesse "
"âmbito."

#: ../../library/bdb.rst:199
msgid ""
"If the debugger should stop on this function return, invoke the :meth:"
"`user_return` method (which should be overridden in subclasses). Raise a :"
"exc:`BdbQuit` exception if the :attr:`quitting  <Bdb.set_quit>` flag is set "
"(which can be set from :meth:`user_return`).  Return a reference to the :"
"meth:`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Se o depurador deve parar neste retorno de função, invoca o método :meth:"
"`user_return` (que deve ser substituído em subclasses). Levanta uma exceção :"
"exc:`BdbQuit` se a flag :attr:`quitting <Bdb.set_quit>` estiver definida "
"(que pode ser definida a partir de :meth:`user_return`). Retorna uma "
"referência ao método :meth:`trace_dispatch` para rastreio adicional nesse "
"âmbito."

#: ../../library/bdb.rst:207
msgid ""
"If the debugger should stop at this exception, invokes the :meth:"
"`user_exception` method (which should be overridden in subclasses). Raise a :"
"exc:`BdbQuit` exception if the :attr:`quitting  <Bdb.set_quit>` flag is set "
"(which can be set from :meth:`user_exception`).  Return a reference to the :"
"meth:`trace_dispatch` method for further tracing in that scope."
msgstr ""
"Se o depurador deve parar nesta exceção, invoca o método :meth:"
"`user_exception` (que deve ser substituído em subclasses). Levanta uma "
"exceção :exc:`BdbQuit` se a flag :attr:`quitting <Bdb.set_quit>` estiver "
"definida (que pode ser definida a partir de :meth:`user_exception`). Retorna "
"uma referência ao método :meth:`trace_dispatch` para rastreio adicional "
"nesse âmbito."

#: ../../library/bdb.rst:213
msgid ""
"Normally derived classes don't override the following methods, but they may "
"if they want to redefine the definition of stopping and breakpoints."
msgstr ""
"Normalmente, as classes derivadas não substituem os seguintes métodos, mas "
"podem fazê-lo se quiserem redefinir a definição de paragem e pontos de "
"interrupção."

#: ../../library/bdb.rst:218
msgid "Return True if *module_name* matches any skip pattern."
msgstr ""

#: ../../library/bdb.rst:222
msgid "Return True if *frame* is below the starting frame in the stack."
msgstr ""

#: ../../library/bdb.rst:226
msgid "Return True if there is an effective breakpoint for this line."
msgstr ""

#: ../../library/bdb.rst:228
msgid ""
"Check whether a line or function breakpoint exists and is in effect.  Delete "
"temporary breakpoints based on information from :func:`effective`."
msgstr ""
"Verifica se existe um ponto de interrupção de linha ou função e se está em "
"vigor. Apaga pontos de interrupção temporários com base em informações de :"
"func:`effective`."

#: ../../library/bdb.rst:233
msgid "Return True if any breakpoint exists for *frame*'s filename."
msgstr ""

#: ../../library/bdb.rst:235
msgid ""
"Derived classes should override these methods to gain control over debugger "
"operation."
msgstr ""
"As classes derivadas devem substituir estes métodos para obter controlo "
"sobre a operação do depurador."

#: ../../library/bdb.rst:240
msgid ""
"Called from :meth:`dispatch_call` if a break might stop inside the called "
"function."
msgstr ""
"Chamado a partir de :meth:`dispatch_call` se uma interrupção puder parar "
"dentro da função chamada."

#: ../../library/bdb.rst:245
msgid ""
"Called from :meth:`dispatch_line` when either :meth:`stop_here` or :meth:"
"`break_here` returns ``True``."
msgstr ""
"Chamado a partir de :meth:`dispatch_line` quando :meth:`stop_here` ou :meth:"
"`break_here` retorna ``True``."

#: ../../library/bdb.rst:250
msgid ""
"Called from :meth:`dispatch_return` when :meth:`stop_here` returns ``True``."
msgstr ""
"Chamado a partir de :meth:`dispatch_return` quando :meth:`stop_here` retorna "
"``True``."

#: ../../library/bdb.rst:254
msgid ""
"Called from :meth:`dispatch_exception` when :meth:`stop_here` returns "
"``True``."
msgstr ""
"Chamado a partir de :meth:`dispatch_exception` quando :meth:`stop_here` "
"retorna ``True``."

#: ../../library/bdb.rst:259
msgid "Handle how a breakpoint must be removed when it is a temporary one."
msgstr ""
"Trata de como um ponto de interrupção deve ser removido quando é temporário."

#: ../../library/bdb.rst:261
msgid "This method must be implemented by derived classes."
msgstr "Este método deve ser implementado por classes derivadas."

#: ../../library/bdb.rst:264
msgid ""
"Derived classes and clients can call the following methods to affect the "
"stepping state."
msgstr ""
"As classes derivadas e clientes podem chamar os seguintes métodos para "
"afetar o estado de execução passo a passo."

#: ../../library/bdb.rst:269
msgid "Stop after one line of code."
msgstr "Parar após uma linha de código."

#: ../../library/bdb.rst:273
msgid "Stop on the next line in or below the given frame."
msgstr "Parar na próxima linha dentro ou abaixo do quadro dado."

#: ../../library/bdb.rst:277
msgid "Stop when returning from the given frame."
msgstr "Parar ao retornar do quadro dado."

#: ../../library/bdb.rst:281
msgid ""
"Stop when the line with the *lineno* greater than the current one is reached "
"or when returning from current frame."
msgstr ""
"Parar quando a linha com o *lineno* maior que a atual for atingida ou ao "
"retornar do quadro atual."

#: ../../library/bdb.rst:286
msgid ""
"Start debugging from *frame*.  If *frame* is not specified, debugging starts "
"from caller's frame."
msgstr ""
"Iniciar depuração a partir de *frame*. Se *frame* não for especificado, a "
"depuração começa a partir do quadro do chamador."

#: ../../library/bdb.rst:291
msgid ""
"Stop only at breakpoints or when finished.  If there are no breakpoints, set "
"the system trace function to ``None``."
msgstr ""
"Parar apenas em pontos de interrupção ou quando terminado. Se não houver "
"pontos de interrupção, define a função de rastreio do sistema para ``None``."

#: ../../library/bdb.rst:298
msgid ""
"Set the :attr:`!quitting` attribute to ``True``.  This raises :exc:`BdbQuit` "
"in the next call to one of the :meth:`!dispatch_\\*` methods."
msgstr ""
"Define o atributo :attr:`!quitting` para ``True``. Isto levanta :exc:"
"`BdbQuit` na próxima chamada a um dos métodos :meth:`!dispatch_\\*`."

#: ../../library/bdb.rst:302
msgid ""
"Derived classes and clients can call the following methods to manipulate "
"breakpoints.  These methods return a string containing an error message if "
"something went wrong, or ``None`` if all is well."
msgstr ""
"As classes derivadas e clientes podem chamar os seguintes métodos para "
"manipular pontos de interrupção. Estes métodos retornam uma string contendo "
"uma mensagem de erro se algo correr mal, ou ``None`` se tudo estiver bem."

#: ../../library/bdb.rst:308
msgid ""
"Set a new breakpoint.  If the *lineno* line doesn't exist for the *filename* "
"passed as argument, return an error message.  The *filename* should be in "
"canonical form, as described in the :meth:`canonic` method."
msgstr ""
"Define um novo ponto de interrupção. Se a linha *lineno* não existir para o "
"*filename* passado como argumento, retorna uma mensagem de erro. O "
"*filename* deve estar em forma canónica, como descrito no método :meth:"
"`canonic`."

#: ../../library/bdb.rst:314
msgid ""
"Delete the breakpoints in *filename* and *lineno*.  If none were set, return "
"an error message."
msgstr ""
"Apaga os pontos de interrupção em *filename* e *lineno*. Se nenhum estiver "
"definido, retorna uma mensagem de erro."

#: ../../library/bdb.rst:319
msgid ""
"Delete the breakpoint which has the index *arg* in the :attr:`Breakpoint."
"bpbynumber`.  If *arg* is not numeric or out of range, return an error "
"message."
msgstr ""
"Apaga o ponto de interrupção que tem o índice *arg* em :attr:`Breakpoint."
"bpbynumber`. Se *arg* não for numérico ou estiver fora do intervalo, retorna "
"uma mensagem de erro."

#: ../../library/bdb.rst:325
msgid ""
"Delete all breakpoints in *filename*.  If none were set, return an error "
"message."
msgstr ""
"Apaga todos os pontos de interrupção em *filename*. Se nenhum estiver "
"definido, retorna uma mensagem de erro."

#: ../../library/bdb.rst:330
msgid ""
"Delete all existing breakpoints.  If none were set, return an error message."
msgstr ""
"Apaga todos os pontos de interrupção existentes. Se nenhum estiver definido, "
"retorna uma mensagem de erro."

#: ../../library/bdb.rst:335
msgid ""
"Return a breakpoint specified by the given number.  If *arg* is a string, it "
"will be converted to a number.  If *arg* is a non-numeric string, if the "
"given breakpoint never existed or has been deleted, a :exc:`ValueError` is "
"raised."
msgstr ""
"Retorna um ponto de interrupção especificado pelo número dado. Se *arg* for "
"uma string, será convertido para um número. Se *arg* for uma string não "
"numérica, se o ponto de interrupção dado nunca existiu ou foi apagado, é "
"levantada uma exceção :exc:`ValueError`."

#: ../../library/bdb.rst:344
msgid "Return True if there is a breakpoint for *lineno* in *filename*."
msgstr ""

#: ../../library/bdb.rst:348
msgid ""
"Return all breakpoints for *lineno* in *filename*, or an empty list if none "
"are set."
msgstr ""
"Retorna todos os pontos de interrupção para *lineno* em *filename*, ou uma "
"lista vazia se nenhum estiver definido."

#: ../../library/bdb.rst:353
msgid "Return all breakpoints in *filename*, or an empty list if none are set."
msgstr ""
"Retorna todos os pontos de interrupção em *filename*, ou uma lista vazia se "
"nenhum estiver definido."

#: ../../library/bdb.rst:357
msgid "Return all breakpoints that are set."
msgstr "Retorna todos os pontos de interrupção que estão definidos."

#: ../../library/bdb.rst:360
msgid ""
"Derived classes and clients can call the following methods to get a data "
"structure representing a stack trace."
msgstr ""
"As classes derivadas e clientes podem chamar os seguintes métodos para obter "
"uma estrutura de dados que representa um rastreio de pilha."

#: ../../library/bdb.rst:365
msgid "Return a list of (frame, lineno) tuples in a stack trace, and a size."
msgstr ""
"Retorna uma lista de tuplos (frame, lineno) num rastreio de pilha, e um "
"tamanho."

#: ../../library/bdb.rst:367
msgid ""
"The most recently called frame is last in the list. The size is the number "
"of frames below the frame where the debugger was invoked."
msgstr ""
"O quadro chamado mais recentemente é o último na lista. O tamanho é o número "
"de quadros abaixo do quadro onde o depurador foi invocado."

#: ../../library/bdb.rst:372
msgid ""
"Return a string with information about a stack entry, which is a ``(frame, "
"lineno)`` tuple.  The return string contains:"
msgstr ""
"Retorna uma string com informações sobre uma entrada de pilha, que é um "
"tuplo ``(frame, lineno)``. A string retornada contém:"

#: ../../library/bdb.rst:375
msgid "The canonical filename which contains the frame."
msgstr "O nome canónico do ficheiro que contém o quadro."

#: ../../library/bdb.rst:376
msgid "The function name or ``\"<lambda>\"``."
msgstr "O nome da função ou ``\"<lambda>\"``."

#: ../../library/bdb.rst:377
msgid "The input arguments."
msgstr "Os argumentos de entrada."

#: ../../library/bdb.rst:378
msgid "The return value."
msgstr "O valor de retorno."

#: ../../library/bdb.rst:379
msgid "The line of code (if it exists)."
msgstr "A linha de código (se existir)."

#: ../../library/bdb.rst:382
msgid ""
"The following two methods can be called by clients to use a debugger to "
"debug a :term:`statement`, given as a string."
msgstr ""
"Os seguintes dois métodos podem ser chamados por clientes para usar um "
"depurador para depurar uma :term:`instrução`, dada como uma string."

#: ../../library/bdb.rst:387
msgid ""
"Debug a statement executed via the :func:`exec` function.  *globals* "
"defaults to :attr:`!__main__.__dict__`, *locals* defaults to *globals*."
msgstr ""
"Depura uma instrução executada através da função :func:`exec`. *globals* tem "
"como padrão :attr:`!__main__.__dict__`, *locals* tem como padrão *globals*."

#: ../../library/bdb.rst:392
msgid ""
"Debug an expression executed via the :func:`eval` function.  *globals* and "
"*locals* have the same meaning as in :meth:`run`."
msgstr ""
"Depura uma expressão executada através da função :func:`eval`. *globals* e "
"*locals* têm o mesmo significado que em :meth:`run`."

#: ../../library/bdb.rst:397
msgid "For backwards compatibility.  Calls the :meth:`run` method."
msgstr "Para compatibilidade retroativa. Chama o método :meth:`run`."

#: ../../library/bdb.rst:401
msgid "Debug a single function call, and return its result."
msgstr "Depura uma única chamada de função e retorna o seu resultado."

#: ../../library/bdb.rst:404
msgid "Finally, the module defines the following functions:"
msgstr "Finalmente, o módulo define as seguintes funções:"

#: ../../library/bdb.rst:408
msgid ""
"Return True if we should break here, depending on the way the :class:"
"`Breakpoint` *b* was set."
msgstr ""

#: ../../library/bdb.rst:411
msgid ""
"If it was set via line number, it checks if :attr:`b.line <bdb.Breakpoint."
"line>` is the same as the one in *frame*. If the breakpoint was set via :"
"attr:`function name <bdb.Breakpoint.funcname>`, we have to check we are in "
"the right *frame* (the right function) and if we are on its first executable "
"line."
msgstr ""
"Se foi definido através do número da linha, verifica se :attr:`b.line <bdb."
"Breakpoint.line>` é o mesmo que o de *frame*. Se o ponto de interrupção foi "
"definido através do :attr:`nome da função <bdb.Breakpoint.funcname>`, temos "
"de verificar se estamos no *frame* correto (a função correta) e se estamos "
"na sua primeira linha executável."

#: ../../library/bdb.rst:420
msgid ""
"Return ``(active breakpoint, delete temporary flag)`` or ``(None, None)`` as "
"the breakpoint to act upon."
msgstr ""
"Retorna ``(ponto de interrupção ativo, flag de apagar temporário)`` ou "
"``(None, None)`` como o ponto de interrupção a atuar."

#: ../../library/bdb.rst:423
msgid ""
"The *active breakpoint* is the first entry in :attr:`bplist <bdb.Breakpoint."
"bplist>` for the (:attr:`file <bdb.Breakpoint.file>`, :attr:`line <bdb."
"Breakpoint.line>`) (which must exist) that is :attr:`enabled <bdb.Breakpoint."
"enabled>`, for which :func:`checkfuncname` is True, and that has neither a "
"False :attr:`condition <bdb.Breakpoint.cond>` nor positive :attr:`ignore "
"<bdb.Breakpoint.ignore>` count.  The *flag*, meaning that a temporary "
"breakpoint should be deleted, is False only when the :attr:`cond <bdb."
"Breakpoint.cond>` cannot be evaluated (in which case, :attr:`ignore <bdb."
"Breakpoint.ignore>` count is ignored)."
msgstr ""

#: ../../library/bdb.rst:434
msgid "If no such entry exists, then (None, None) is returned."
msgstr ""

#: ../../library/bdb.rst:439
msgid "Start debugging with a :class:`Bdb` instance from caller's frame."
msgstr ""
"Iniciar depuração com uma instância :class:`Bdb` a partir do quadro do "
"chamador."

#: ../../library/bdb.rst:296
msgid "quitting (bdb.Bdb attribute)"
msgstr "a sair (atributo bdb.Bdb)"
