# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 14:29+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Tipos integrados"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"As secções seguintes descrevem os tipos padrão que estão integrados no "
"interpretador."

#: ../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Os principais tipos integrados são numéricos, sequências, mapeamentos, "
"classes, instâncias e exceções."

#: ../../library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Algumas classes de coleções são mutáveis. Os métodos que adicionam, subtraem "
"ou reorganizam os seus membros *in-place* e não retornam um item específico, "
"nunca retornam a instância da coleção em si, mas sim ``None``."

#: ../../library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Algumas operações são suportadas por vários tipos de objetos; em particular, "
"praticamente todos os objetos podem ser comparados para igualdade, testados "
"para valor de verdade e convertidos para uma *string* (com a função :func:"
"`repr` ou a função ligeiramente diferente :func:`str`). Esta última função é "
"usada implicitamente quando um objeto é escrito pela função :func:`print`."

#: ../../library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Teste de valor de verdade"

#: ../../library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Qualquer objeto pode ser testado para valor de verdade, para uso numa "
"condição :keyword:`if` ou :keyword:`while` ou como operando das operações "
"booleanas abaixo."

#: ../../library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`~object."
"__len__` method that returns zero, when called with the object. [1]_  Here "
"are most of the built-in objects considered false:"
msgstr ""
"Por predefinição, um objeto é considerado verdadeiro a menos que a sua "
"classe defina um método :meth:`~object.__bool__` que retorne ``False`` ou um "
"método :meth:`~object.__len__` que retorne zero, quando chamado com o "
"objeto. [1]_ Aqui estão a maioria dos objetos integrados considerados falsos:"

#: ../../library/stdtypes.rst:56
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "constantes definidas como falsas: ``None`` e ``False``"

#: ../../library/stdtypes.rst:58
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"zero de qualquer tipo numérico: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: ../../library/stdtypes.rst:61
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"sequências e coleções vazias: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: ../../library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Operações e funções integradas que têm um resultado booleano retornam sempre "
"``0`` ou ``False`` para falso e ``1`` ou ``True`` para verdadeiro, a menos "
"que seja indicado o contrário. (Exceção importante: as operações booleanas "
"``or`` e ``and`` retornam sempre um dos seus operandos.)"

#: ../../library/stdtypes.rst:79
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Operações booleanas --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: ../../library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Estas são as operações booleanas, ordenadas por prioridade ascendente:"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:144
#: ../../library/stdtypes.rst:276 ../../library/stdtypes.rst:366
#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:963
#: ../../library/stdtypes.rst:1182
msgid "Operation"
msgstr "Operação"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:276
#: ../../library/stdtypes.rst:366 ../../library/stdtypes.rst:416
#: ../../library/stdtypes.rst:963 ../../library/stdtypes.rst:1182
msgid "Result"
msgstr "Resultado"

#: ../../library/stdtypes.rst:86 ../../library/stdtypes.rst:276
#: ../../library/stdtypes.rst:416 ../../library/stdtypes.rst:963
#: ../../library/stdtypes.rst:1182 ../../library/stdtypes.rst:2812
#: ../../library/stdtypes.rst:4032
msgid "Notes"
msgstr "Notas"

#: ../../library/stdtypes.rst:88
msgid "``x or y``"
msgstr "``x or y``"

#: ../../library/stdtypes.rst:88
msgid "if *x* is true, then *x*, else *y*"
msgstr "se *x* for verdadeiro, então *x*, senão *y*"

#: ../../library/stdtypes.rst:88 ../../library/stdtypes.rst:965
#: ../../library/stdtypes.rst:968 ../../library/stdtypes.rst:1197
#: ../../library/stdtypes.rst:2818 ../../library/stdtypes.rst:4038
msgid "\\(1)"
msgstr "(1)"

#: ../../library/stdtypes.rst:91
msgid "``x and y``"
msgstr "``x and y``"

#: ../../library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr "se *x* for falso, então *x*, senão *y*"

#: ../../library/stdtypes.rst:91 ../../library/stdtypes.rst:289
#: ../../library/stdtypes.rst:309 ../../library/stdtypes.rst:1208
#: ../../library/stdtypes.rst:2822 ../../library/stdtypes.rst:2824
#: ../../library/stdtypes.rst:4042 ../../library/stdtypes.rst:4044
msgid "\\(2)"
msgstr "(2)"

#: ../../library/stdtypes.rst:94
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "se *x* for falso, então ``True``, senão ``False``"

#: ../../library/stdtypes.rst:94 ../../library/stdtypes.rst:2826
#: ../../library/stdtypes.rst:2828 ../../library/stdtypes.rst:2830
#: ../../library/stdtypes.rst:2832 ../../library/stdtypes.rst:4046
#: ../../library/stdtypes.rst:4048 ../../library/stdtypes.rst:4050
#: ../../library/stdtypes.rst:4052
msgid "\\(3)"
msgstr "(3)"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:320
#: ../../library/stdtypes.rst:434 ../../library/stdtypes.rst:1007
#: ../../library/stdtypes.rst:1212 ../../library/stdtypes.rst:2858
#: ../../library/stdtypes.rst:4082
msgid "Notes:"
msgstr "Notas:"

#: ../../library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Este é um operador de curto-circuito, por isso só avalia o segundo argumento "
"se o primeiro for falso."

#: ../../library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Este é um operador de curto-circuito, por isso só avalia o segundo argumento "
"se o primeiro for verdadeiro."

#: ../../library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` tem uma prioridade inferior a operadores não booleanos, por isso "
"``not a == b`` é interpretado como ``not (a == b)``, e ``a == not b`` é um "
"erro de sintaxe."

#: ../../library/stdtypes.rst:121
msgid "Comparisons"
msgstr "Comparações"

#: ../../library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Existem oito operações de comparação em Python. Todas têm a mesma prioridade "
"(que é superior à das operações booleanas). As comparações podem ser "
"encadeadas arbitrariamente; por exemplo, ``x < y <= z`` é equivalente a ``x "
"< y and y <= z``, exceto que *y* é avaliado apenas uma vez (mas em ambos os "
"casos *z* não é avaliado se ``x < y`` for falso)."

#: ../../library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr "Esta tabela resume as operações de comparação:"

#: ../../library/stdtypes.rst:144 ../../library/stdtypes.rst:2644
#: ../../library/stdtypes.rst:2789 ../../library/stdtypes.rst:2812
#: ../../library/stdtypes.rst:4009 ../../library/stdtypes.rst:4032
msgid "Meaning"
msgstr "Significado"

#: ../../library/stdtypes.rst:146
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:146
msgid "strictly less than"
msgstr "estritamente menor que"

#: ../../library/stdtypes.rst:148
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:148
msgid "less than or equal"
msgstr "menor ou igual"

#: ../../library/stdtypes.rst:150
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:150
msgid "strictly greater than"
msgstr "estritamente maior que"

#: ../../library/stdtypes.rst:152
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:152
msgid "greater than or equal"
msgstr "maior ou igual"

#: ../../library/stdtypes.rst:154
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:154
msgid "equal"
msgstr "igual"

#: ../../library/stdtypes.rst:156
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:156
msgid "not equal"
msgstr "não igual"

#: ../../library/stdtypes.rst:158
msgid "``is``"
msgstr "``is``"

#: ../../library/stdtypes.rst:158
msgid "object identity"
msgstr "identidade de objeto"

#: ../../library/stdtypes.rst:160
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:160
msgid "negated object identity"
msgstr "identidade de objeto negada"

#: ../../library/stdtypes.rst:167
msgid ""
"Unless stated otherwise, objects of different types never compare equal. The "
"``==`` operator is always defined but for some object types (for example, "
"class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, ``>`` and "
"``>=`` operators are only defined where they make sense; for example, they "
"raise a :exc:`TypeError` exception when one of the arguments is a complex "
"number."
msgstr ""

#: ../../library/stdtypes.rst:181
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Instâncias não idênticas de uma classe normalmente são consideradas não "
"iguais, a menos que a classe defina o método :meth:`~object.__eq__`."

#: ../../library/stdtypes.rst:184
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Instâncias de uma classe não podem ser ordenadas em relação a outras "
"instâncias da mesma classe, ou outros tipos de objetos, a menos que a classe "
"defina métodos suficientes entre :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__` e :meth:`~object.__ge__` (em geral, :meth:"
"`~object.__lt__` e :meth:`~object.__eq__` são suficientes, se pretender os "
"significados convencionais dos operadores de comparação)."

#: ../../library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"O comportamento dos operadores :keyword:`is` e :keyword:`is not` não pode "
"ser personalizado; também podem ser aplicados a quaisquer dois objetos e "
"nunca lançam uma exceção."

#: ../../library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`~object.__contains__` method."
msgstr ""
"Duas operações adicionais com a mesma prioridade sintática, :keyword:`in` e :"
"keyword:`not in`, são suportadas por tipos que são :term:`iteráveis` ou "
"implementam o método :meth:`~object.__contains__`."

#: ../../library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Tipos numéricos --- :class:`int`, :class:`float`, :class:`complex`"

#: ../../library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating-"
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating-point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating-point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating-point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Existem três tipos numéricos distintos: :dfn:`inteiros`, :dfn:`números de "
"ponto flutuante` e :dfn:`números complexos`. Além disso, os booleanos são um "
"subtipo de inteiros. Os inteiros têm precisão ilimitada. Os números de ponto "
"flutuante são geralmente implementados usando :c:expr:`double` em C; "
"informações sobre a precisão e representação interna dos números de ponto "
"flutuante para a máquina na qual o programa está a ser executado estão "
"disponíveis em :data:`sys.float_info`. Os números complexos têm uma parte "
"real e imaginária, que são cada uma um número de ponto flutuante. Para "
"extrair estas partes de um número complexo *z*, use ``z.real`` e ``z.imag``. "
"(A biblioteca padrão inclui os tipos numéricos adicionais :mod:`fractions."
"Fraction`, para racionais, e :mod:`decimal.Decimal`, para números de ponto "
"flutuante com precisão definível pelo utilizador.)"

#: ../../library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating-point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Os números são criados por literais numéricos ou como resultado de funções e "
"operadores integrados. Literais inteiros não adornados (incluindo números "
"hexadecimais, octais e binários) produzem inteiros. Literais numéricos que "
"contêm um ponto decimal ou um sinal de expoente produzem números de ponto "
"flutuante. Acrescentar ``'j'`` ou ``'J'`` a um literal numérico produz um "
"número imaginário (um número complexo com uma parte real zero), que pode ser "
"adicionado a um inteiro ou *float* para obter um número complexo com partes "
"real e imaginária."

#: ../../library/stdtypes.rst:263
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""

#: ../../library/stdtypes.rst:269
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Os construtores :func:`int`, :func:`float` e :func:`complex` podem ser "
"usados para produzir números de um tipo específico."

#: ../../library/stdtypes.rst:272
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Todos os tipos numéricos (exceto complexos) suportam as seguintes operações "
"(para prioridades das operações, consulte :ref:`operator-summary`):"

#: ../../library/stdtypes.rst:276
msgid "Full documentation"
msgstr "Documentação completa"

#: ../../library/stdtypes.rst:278
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:278
msgid "sum of *x* and *y*"
msgstr "soma de *x* e *y*"

#: ../../library/stdtypes.rst:280
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:280
msgid "difference of *x* and *y*"
msgstr "diferença entre *x* e *y*"

#: ../../library/stdtypes.rst:282
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:282
msgid "product of *x* and *y*"
msgstr "produto de *x* e *y*"

#: ../../library/stdtypes.rst:284
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:284
msgid "quotient of *x* and *y*"
msgstr "quociente de *x* e *y*"

#: ../../library/stdtypes.rst:286
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:286
msgid "floored quotient of *x* and *y*"
msgstr "quociente arredondado para baixo de *x* e *y*"

#: ../../library/stdtypes.rst:286
msgid "\\(1)\\(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:289
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:289
msgid "remainder of ``x / y``"
msgstr "resto de ``x / y``"

#: ../../library/stdtypes.rst:291
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:291
msgid "*x* negated"
msgstr "*x* negado"

#: ../../library/stdtypes.rst:293
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:293
msgid "*x* unchanged"
msgstr "*x* inalterado"

#: ../../library/stdtypes.rst:295
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:295
msgid "absolute value or magnitude of *x*"
msgstr "valor absoluto ou magnitude de *x*"

#: ../../library/stdtypes.rst:295
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/stdtypes.rst:298
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:298
msgid "*x* converted to integer"
msgstr "*x* convertido para inteiro"

#: ../../library/stdtypes.rst:298
msgid "\\(3)\\(6)"
msgstr "(3)(6)"

#: ../../library/stdtypes.rst:298
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/stdtypes.rst:300
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:300
msgid "*x* converted to floating point"
msgstr "*x* convertido para ponto flutuante"

#: ../../library/stdtypes.rst:300
msgid "\\(4)\\(6)"
msgstr "(4)(6)"

#: ../../library/stdtypes.rst:300
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/stdtypes.rst:302
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../library/stdtypes.rst:302
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"um número complexo com parte real *re*, parte imaginária *im*. *im* é zero "
"por predefinição."

#: ../../library/stdtypes.rst:302 ../../library/stdtypes.rst:2820
#: ../../library/stdtypes.rst:4069
msgid "\\(6)"
msgstr "(6)"

#: ../../library/stdtypes.rst:302
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/stdtypes.rst:306
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:306
msgid "conjugate of the complex number *c*"
msgstr "conjugado do número complexo *c*"

#: ../../library/stdtypes.rst:309
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:309
msgid "the pair ``(x // y, x % y)``"
msgstr "o par ``(x // y, x % y)``"

#: ../../library/stdtypes.rst:309
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/stdtypes.rst:311
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:311 ../../library/stdtypes.rst:313
msgid "*x* to the power *y*"
msgstr "*x* elevado a *y*"

#: ../../library/stdtypes.rst:311 ../../library/stdtypes.rst:313
#: ../../library/stdtypes.rst:2845 ../../library/stdtypes.rst:2848
#: ../../library/stdtypes.rst:2851 ../../library/stdtypes.rst:4065
#: ../../library/stdtypes.rst:4072
msgid "\\(5)"
msgstr "(5)"

#: ../../library/stdtypes.rst:311
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/stdtypes.rst:313
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:323
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Também referido como divisão inteira. Para operandos do tipo :class:`int`, o "
"resultado tem o tipo :class:`int`. Para operandos do tipo :class:`float`, o "
"resultado tem o tipo :class:`float`. Em geral, o resultado é um inteiro, "
"embora o tipo do resultado não seja necessariamente :class:`int`. O "
"resultado é sempre arredondado para menos infinito: ``1//2`` é ``0``, "
"``(-1)//2`` é ``-1``, ``1//(-2)`` é ``-1``, e ``(-1)//(-2)`` é ``0``."

#: ../../library/stdtypes.rst:331
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Não aplicável a números complexos. Em vez disso, converta para *floats* "
"usando :func:`abs`, se apropriado."

#: ../../library/stdtypes.rst:342
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"A conversão de :class:`float` para :class:`int` trunca, descartando a parte "
"fracionária. Consulte as funções :func:`math.floor` e :func:`math.ceil` para "
"conversões alternativas."

#: ../../library/stdtypes.rst:347
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float também aceita as *strings* \"nan\" e \"inf\" com um prefixo opcional "
"\"+\" ou \"-\" para Not a Number (NaN) e infinito positivo ou negativo."

#: ../../library/stdtypes.rst:351
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"O Python define ``pow(0, 0)`` e ``0 ** 0`` como ``1``, como é comum em "
"linguagens de programação."

#: ../../library/stdtypes.rst:355
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Os literais numéricos aceites incluem os dígitos ``0`` a ``9`` ou qualquer "
"equivalente Unicode (pontos de código com a propriedade ``Nd``)."

#: ../../library/stdtypes.rst:358
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"Consulte `o Padrão Unicode <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ para uma lista completa de pontos de código com a "
"propriedade ``Nd``."

#: ../../library/stdtypes.rst:362
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Todos os tipos :class:`numbers.Real` (:class:`int` e :class:`float`) também "
"incluem as seguintes operações:"

#: ../../library/stdtypes.rst:368
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(x) <math.trunc>`"

#: ../../library/stdtypes.rst:368
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* truncado para :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:371
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../../library/stdtypes.rst:371
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* arredondado a *n* dígitos, arredondando metade para par. Se *n* for "
"omitido, o valor predefinido é 0."

#: ../../library/stdtypes.rst:375
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(x) <math.floor>`"

#: ../../library/stdtypes.rst:375
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "o maior :class:`~numbers.Integral` <= *x*"

#: ../../library/stdtypes.rst:378
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:378
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "o menor :class:`~numbers.Integral` >= *x*"

#: ../../library/stdtypes.rst:382
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Para operações numéricas adicionais, consulte os módulos :mod:`math` e :mod:"
"`cmath`."

#: ../../library/stdtypes.rst:391
msgid "Bitwise Operations on Integer Types"
msgstr "Operações bit a bit em tipos inteiros"

#: ../../library/stdtypes.rst:405
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"As operações bit a bit só fazem sentido para inteiros. O resultado das "
"operações bit a bit é calculado como se fosse realizado em complemento para "
"dois com um número infinito de bits de sinal."

#: ../../library/stdtypes.rst:409
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"As prioridades das operações bit a bit binárias são todas inferiores às "
"operações numéricas e superiores às comparações; a operação unária ``~`` tem "
"a mesma prioridade que as outras operações numéricas unárias (``+`` e ``-``)."

#: ../../library/stdtypes.rst:413
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Esta tabela lista as operações bit a bit ordenadas por prioridade ascendente:"

#: ../../library/stdtypes.rst:418
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:418
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "OR bit a bit de *x* e *y*"

#: ../../library/stdtypes.rst:418 ../../library/stdtypes.rst:421
#: ../../library/stdtypes.rst:424 ../../library/stdtypes.rst:2834
#: ../../library/stdtypes.rst:2838 ../../library/stdtypes.rst:4054
#: ../../library/stdtypes.rst:4058
msgid "\\(4)"
msgstr "(4)"

#: ../../library/stdtypes.rst:421
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:421
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "XOR bit a bit de *x* e *y*"

#: ../../library/stdtypes.rst:424
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:424
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "AND bit a bit de *x* e *y*"

#: ../../library/stdtypes.rst:427
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:427
msgid "*x* shifted left by *n* bits"
msgstr "*x* deslocado à esquerda por *n* bits"

#: ../../library/stdtypes.rst:427
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:429
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:429
msgid "*x* shifted right by *n* bits"
msgstr "*x* deslocado à direita por *n* bits"

#: ../../library/stdtypes.rst:429
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:431
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:431
msgid "the bits of *x* inverted"
msgstr "os bits de *x* invertidos"

#: ../../library/stdtypes.rst:437
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Contagens de deslocamento negativas são ilegais e causam uma exceção :exc:"
"`ValueError`."

#: ../../library/stdtypes.rst:440
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr ""
"Um deslocamento à esquerda por *n* bits é equivalente à multiplicação por "
"``pow(2, n)``."

#: ../../library/stdtypes.rst:443
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Um deslocamento à direita por *n* bits é equivalente à divisão inteira por "
"``pow(2, n)``."

#: ../../library/stdtypes.rst:446
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Realizar estes cálculos com pelo menos um bit extra de extensão de sinal "
"numa representação finita de complemento para dois (uma largura de bits de "
"trabalho de ``1 + max(x.bit_length(), y.bit_length())`` ou mais) é "
"suficiente para obter o mesmo resultado como se houvesse um número infinito "
"de bits de sinal."

#: ../../library/stdtypes.rst:453
msgid "Additional Methods on Integer Types"
msgstr "Métodos adicionais em tipos inteiros"

#: ../../library/stdtypes.rst:455
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"O tipo int implementa a :class:`numbers.Integral` :term:`classe base "
"abstrata`. Além disso, fornece alguns métodos adicionais:"

#: ../../library/stdtypes.rst:460
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Retorna o número de bits necessários para representar um inteiro em binário, "
"excluindo o sinal e os zeros à esquerda:"

#: ../../library/stdtypes.rst:463
msgid ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"
msgstr ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"

#: ../../library/stdtypes.rst:469
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Mais precisamente, se ``x`` não for zero, então ``x.bit_length()`` é o único "
"inteiro positivo ``k`` tal que ``2**(k-1) <= abs(x) < 2**k``. De forma "
"equivalente, quando ``abs(x)`` é suficientemente pequeno para ter um "
"logaritmo corretamente arredondado, então ``k = 1 + int(log(abs(x), 2))``. "
"Se ``x`` for zero, então ``x.bit_length()`` retorna ``0``."

#: ../../library/stdtypes.rst:475 ../../library/stdtypes.rst:498
#: ../../library/stdtypes.rst:543 ../../library/stdtypes.rst:587
msgid "Equivalent to::"
msgstr "Equivalente a::"

#: ../../library/stdtypes.rst:477
msgid ""
"def bit_length(self):\n"
"    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove leading zeros and minus sign\n"
"    return len(s)       # len('100101') --> 6"
msgstr ""
"def bit_length(self):\n"
"    s = bin(self)       # representação binária: bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove zeros à esquerda e sinal de menos\n"
"    return len(s)       # len('100101') --> 6"

#: ../../library/stdtypes.rst:486
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Retorna o número de uns na representação binária do valor absoluto do "
"inteiro. Isto também é conhecido como contagem de população. Exemplo:"

#: ../../library/stdtypes.rst:490
msgid ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"
msgstr ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"

#: ../../library/stdtypes.rst:500
msgid ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"
msgstr ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"

#: ../../library/stdtypes.rst:507
msgid "Return an array of bytes representing an integer."
msgstr "Retorna um *array* de bytes que representa um inteiro."

#: ../../library/stdtypes.rst:519
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"O inteiro é representado usando *length* bytes, e o valor predefinido é 1. "
"Uma exceção :exc:`OverflowError` é lançada se o inteiro não for "
"representável com o número dado de bytes."

#: ../../library/stdtypes.rst:523
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"O argumento *byteorder* determina a ordem dos bytes usada para representar o "
"inteiro, e o valor predefinido é ``\"big\"``. Se *byteorder* for "
"``\"big\"``, o byte mais significativo está no início do *array* de bytes. "
"Se *byteorder* for ``\"little\"``, o byte mais significativo está no final "
"do *array* de bytes."

#: ../../library/stdtypes.rst:529
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"O argumento *signed* determina se o complemento para dois é usado para "
"representar o inteiro. Se *signed* for ``False`` e for fornecido um inteiro "
"negativo, é lançada uma exceção :exc:`OverflowError`. O valor predefinido "
"para *signed* é ``False``."

#: ../../library/stdtypes.rst:534
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""
"Os valores predefinidos podem ser usados para converter convenientemente um "
"inteiro num objeto de byte único:"

#: ../../library/stdtypes.rst:537
msgid ""
">>> (65).to_bytes()\n"
"b'A'"
msgstr ""
">>> (65).to_bytes()\n"
"b'A'"

#: ../../library/stdtypes.rst:540
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"No entanto, ao usar os argumentos predefinidos, não tente converter um valor "
"maior que 255 ou obterá uma exceção :exc:`OverflowError`."

#: ../../library/stdtypes.rst:545
msgid ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"
msgstr ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"

#: ../../library/stdtypes.rst:556
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr ""
"Adicionados valores de argumento predefinidos para ``length`` e "
"``byteorder``."

#: ../../library/stdtypes.rst:561
msgid "Return the integer represented by the given array of bytes."
msgstr "Retorna o inteiro representado pelo *array* de bytes fornecido."

#: ../../library/stdtypes.rst:574
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"O argumento *bytes* deve ser um :term:`objeto do tipo bytes` ou um iterável "
"que produz bytes."

#: ../../library/stdtypes.rst:577
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"O argumento *byteorder* determina a ordem dos bytes usada para representar o "
"inteiro, e o valor predefinido é ``\"big\"``. Se *byteorder* for "
"``\"big\"``, o byte mais significativo está no início do *array* de bytes. "
"Se *byteorder* for ``\"little\"``, o byte mais significativo está no final "
"do *array* de bytes. Para solicitar a ordem de bytes nativa do sistema "
"hospedeiro, use :data:`sys.byteorder` como o valor da ordem de bytes."

#: ../../library/stdtypes.rst:584
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"O argumento *signed* indica se o complemento para dois é usado para "
"representar o inteiro."

#: ../../library/stdtypes.rst:589
msgid ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"
msgstr ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"

#: ../../library/stdtypes.rst:604
msgid "Added default argument value for ``byteorder``."
msgstr "Adicionado valor de argumento predefinido para ``byteorder``."

#: ../../library/stdtypes.rst:609
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr ""
"Retorna um par de inteiros cuja razão é igual ao inteiro original e tem um "
"denominador positivo. A razão inteira de inteiros (números inteiros) é "
"sempre o inteiro como numerador e ``1`` como denominador."

#: ../../library/stdtypes.rst:618
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr ""
"Retorna ``True``. Existe para compatibilidade de tipo pato com :meth:`float."
"is_integer`."

#: ../../library/stdtypes.rst:623
msgid "Additional Methods on Float"
msgstr "Métodos adicionais em Float"

#: ../../library/stdtypes.rst:625
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"O tipo float implementa a :class:`numbers.Real` :term:`classe base "
"abstrata`. float também tem os seguintes métodos adicionais."

#: ../../library/stdtypes.rst:630
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises :"
"exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"Retorna um par de inteiros cuja razão é exatamente igual ao float original. "
"A razão está nos termos mais baixos e tem um denominador positivo. Lança :"
"exc:`OverflowError` em infinitos e :exc:`ValueError` em NaNs."

#: ../../library/stdtypes.rst:637
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Retorna ``True`` se a instância float for finita com valor integral, e "
"``False`` caso contrário:"

#: ../../library/stdtypes.rst:640
msgid ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"
msgstr ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"

#: ../../library/stdtypes.rst:645
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Dois métodos suportam conversão para e a partir de *strings* hexadecimais. "
"Como os floats do Python são armazenados internamente como números binários, "
"converter um float para ou a partir de uma *string* decimal geralmente "
"envolve um pequeno erro de arredondamento. Em contraste, as *strings* "
"hexadecimais permitem representação e especificação exatas de números de "
"ponto flutuante. Isto pode ser útil na depuração e em trabalho numérico."

#: ../../library/stdtypes.rst:656
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Retorna uma representação de um número de ponto flutuante como uma *string* "
"hexadecimal. Para números de ponto flutuante finitos, esta representação "
"incluirá sempre um ``0x`` inicial e um ``p`` final e expoente."

#: ../../library/stdtypes.rst:664
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Método de classe para retornar o float representado por uma *string* "
"hexadecimal *s*. A *string* *s* pode ter espaços em branco iniciais e finais."

#: ../../library/stdtypes.rst:669
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Note que :meth:`float.hex` é um método de instância, enquanto :meth:`float."
"fromhex` é um método de classe."

#: ../../library/stdtypes.rst:672
msgid "A hexadecimal string takes the form::"
msgstr "Uma *string* hexadecimal tem a forma:"

#: ../../library/stdtypes.rst:674
msgid "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"
msgstr "[sinal] ['0x'] inteiro ['.' fração] ['p' expoente]"

#: ../../library/stdtypes.rst:676
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"onde o ``sign`` opcional pode ser ``+`` ou ``-``, ``integer`` e ``fraction`` "
"são *strings* de dígitos hexadecimais, e ``exponent`` é um inteiro decimal "
"com um sinal inicial opcional. A caixa não é significativa, e deve haver "
"pelo menos um dígito hexadecimal no inteiro ou na fração. Esta sintaxe é "
"semelhante à sintaxe especificada na secção 6.4.4.2 do padrão C99, e também "
"à sintaxe usada no Java 1.5 e posteriores. Em particular, a saída de :meth:"
"`float.hex` pode ser usada como um literal de ponto flutuante hexadecimal em "
"código C ou Java, e as *strings* hexadecimais produzidas pelo carácter de "
"formato ``%a`` do C ou pelo ``Double.toHexString`` do Java são aceites por :"
"meth:`float.fromhex`."

#: ../../library/stdtypes.rst:689
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Note que o expoente é escrito em decimal em vez de hexadecimal, e que indica "
"a potência de 2 pela qual multiplicar o coeficiente. Por exemplo, a *string* "
"hexadecimal ``0x3.a7p10`` representa o número de ponto flutuante ``(3 + "
"10./16 + 7./16**2) * 2.0**10``, ou ``3740.0``:"

#: ../../library/stdtypes.rst:695
msgid ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"
msgstr ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"

#: ../../library/stdtypes.rst:699
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Aplicar a conversão inversa a ``3740.0`` dá uma *string* hexadecimal "
"diferente que representa o mesmo número:"

#: ../../library/stdtypes.rst:702
msgid ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"
msgstr ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"

#: ../../library/stdtypes.rst:709
msgid "Hashing of numeric types"
msgstr "Hashing de tipos numéricos"

#: ../../library/stdtypes.rst:711
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`~sys.hash_info."
"modulus` attribute of :data:`sys.hash_info`."
msgstr ""
"Para números ``x`` e ``y``, possivelmente de tipos diferentes, é um "
"requisito que ``hash(x) == hash(y)`` sempre que ``x == y`` (consulte a "
"documentação do método :meth:`~object.__hash__` para mais detalhes). Para "
"facilitar a implementação e a eficiência em vários tipos numéricos "
"(incluindo :class:`int`, :class:`float`, :class:`decimal.Decimal` e :class:"
"`fractions.Fraction`), o *hash* do Python para tipos numéricos é baseado "
"numa única função matemática que é definida para qualquer número racional, e "
"portanto aplica-se a todas as instâncias de :class:`int` e :class:`fractions."
"Fraction`, e a todas as instâncias finitas de :class:`float` e :class:"
"`decimal.Decimal`. Essencialmente, esta função é dada pela redução módulo "
"``P`` para um primo fixo ``P``. O valor de ``P`` é disponibilizado ao Python "
"como o atributo :attr:`~sys.hash_info.modulus` de :data:`sys.hash_info`."

#: ../../library/stdtypes.rst:726
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Atualmente, o primo usado é ``P = 2**31 - 1`` em máquinas com *longs* C de "
"32 bits e ``P = 2**61 - 1`` em máquinas com *longs* C de 64 bits."

#: ../../library/stdtypes.rst:729
msgid "Here are the rules in detail:"
msgstr "Aqui estão as regras em detalhe:"

#: ../../library/stdtypes.rst:731
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Se ``x = m / n`` for um número racional não negativo e ``n`` não for "
"divisível por ``P``, defina ``hash(x)`` como ``m * invmod(n, P) % P``, onde "
"``invmod(n, P)`` dá o inverso de ``n`` módulo ``P``."

#: ../../library/stdtypes.rst:735
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Se ``x = m / n`` for um número racional não negativo e ``n`` for divisível "
"por ``P`` (mas ``m`` não for), então ``n`` não tem inverso módulo ``P`` e a "
"regra acima não se aplica; neste caso, defina ``hash(x)`` como o valor "
"constante ``sys.hash_info.inf``."

#: ../../library/stdtypes.rst:740
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Se ``x = m / n`` for um número racional negativo, defina ``hash(x)`` como ``-"
"hash(-x)``. Se o *hash* resultante for ``-1``, substitua-o por ``-2``."

#: ../../library/stdtypes.rst:744
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"Os valores específicos ``sys.hash_info.inf`` e ``-sys.hash_info.inf`` são "
"usados como valores de *hash* para infinito positivo ou negativo "
"(respetivamente)."

#: ../../library/stdtypes.rst:748
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Para um número :class:`complex` ``z``, os valores de *hash* das partes real "
"e imaginária são combinados calculando ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)``, reduzido módulo ``2**sys.hash_info.width`` de modo a que "
"esteja no intervalo ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info."
"width - 1))``. Novamente, se o resultado for ``-1``, é substituído por "
"``-2``."

#: ../../library/stdtypes.rst:756
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Para clarificar as regras acima, aqui está algum código Python de exemplo, "
"equivalente ao *hash* integrado, para calcular o *hash* de um número "
"racional, :class:`float`, ou :class:`complex`:"

#: ../../library/stdtypes.rst:761
msgid ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove common factors of P.  (Unnecessary if m and n already "
"coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n"
"        # pow(n, P-2, P) gives the inverse of n modulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z."
"imag)\n"
"    # do a signed reduction modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"
msgstr ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Calcula o *hash* de um número racional m / n.\n"
"\n"
"    Assume que m e n são inteiros, com n positivo.\n"
"    Equivalente a hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove fatores comuns de P. (Desnecessário se m e n já forem primos "
"entre si.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # Teorema de Fermat: pow(n, P-1, P) é 1, por isso\n"
"        # pow(n, P-2, P) dá o inverso de n módulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Calcula o *hash* de um float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Calcula o *hash* de um número complexo z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z."
"imag)\n"
"    # faz uma redução com sinal módulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"

#: ../../library/stdtypes.rst:812
msgid "Boolean Type - :class:`bool`"
msgstr "Tipo booleano - :class:`bool`"

#: ../../library/stdtypes.rst:814
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr ""
"Os booleanos representam valores de verdade. O tipo :class:`bool` tem "
"exatamente duas instâncias constantes: ``True`` e ``False``."

#: ../../library/stdtypes.rst:822
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""
"A função integrada :func:`bool` converte qualquer valor para um booleano, se "
"o valor puder ser interpretado como um valor de verdade (consulte a secção :"
"ref:`truth` acima)."

#: ../../library/stdtypes.rst:825
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and "
"``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"Para operações lógicas, use os :ref:`operadores booleanos <boolean>` "
"``and``, ``or`` e ``not``. Ao aplicar os operadores bit a bit ``&``, ``|``, "
"``^`` a dois booleanos, retornam um booleano equivalente às operações "
"lógicas \"and\", \"or\", \"xor\". No entanto, os operadores lógicos ``and``, "
"``or`` e ``!=`` devem ser preferidos em relação a ``&``, ``|`` e ``^``."

#: ../../library/stdtypes.rst:834
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise "
"an error in Python 3.16."
msgstr ""
"O uso do operador de inversão bit a bit ``~`` está obsoleto e lançará um "
"erro no Python 3.16."

#: ../../library/stdtypes.rst:837
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and "
"1, respectively. However, relying on this is discouraged; explicitly convert "
"using :func:`int` instead."
msgstr ""
":class:`bool` é uma subclasse de :class:`int` (consulte :ref:"
"`typesnumeric`). Em muitos contextos numéricos, ``False`` e ``True`` "
"comportam-se como os inteiros 0 e 1, respetivamente. No entanto, confiar "
"nisto é desencorajado; converta explicitamente usando :func:`int`."

#: ../../library/stdtypes.rst:845
msgid "Iterator Types"
msgstr "Tipos de iterador"

#: ../../library/stdtypes.rst:853
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"O Python suporta o conceito de iteração sobre contentores. Isto é "
"implementado usando dois métodos distintos; estes são usados para permitir "
"que classes definidas pelo utilizador suportem iteração. As sequências, "
"descritas abaixo com mais detalhe, suportam sempre os métodos de iteração."

#: ../../library/stdtypes.rst:858
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Um método precisa de ser definido para objetos contentor para fornecer "
"suporte :term:`iterável`:"

#: ../../library/stdtypes.rst:865
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Retorna um objeto :term:`iterador`. O objeto é obrigado a suportar o "
"protocolo de iterador descrito abaixo. Se um contentor suportar diferentes "
"tipos de iteração, podem ser fornecidos métodos adicionais para solicitar "
"especificamente iteradores para esses tipos de iteração. (Um exemplo de um "
"objeto que suporta múltiplas formas de iteração seria uma estrutura de "
"árvore que suporta travessia em largura e em profundidade.) Este método "
"corresponde ao slot :c:member:`~PyTypeObject.tp_iter` da estrutura de tipo "
"para objetos Python na API Python/C."

#: ../../library/stdtypes.rst:874
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Os objetos iteradores em si são obrigados a suportar os seguintes dois "
"métodos, que juntos formam o :dfn:`protocolo de iterador`:"

#: ../../library/stdtypes.rst:880
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Retorna o próprio objeto :term:`iterador`. Isto é necessário para permitir "
"que tanto contentores como iteradores sejam usados com as instruções :"
"keyword:`for` e :keyword:`in`. Este método corresponde ao slot :c:member:"
"`~PyTypeObject.tp_iter` da estrutura de tipo para objetos Python na API "
"Python/C."

#: ../../library/stdtypes.rst:889
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Retorna o próximo item do :term:`iterador`. Se não houver mais itens, lança "
"a exceção :exc:`StopIteration`. Este método corresponde ao slot :c:member:"
"`~PyTypeObject.tp_iternext` da estrutura de tipo para objetos Python na API "
"Python/C."

#: ../../library/stdtypes.rst:894
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"O Python define vários objetos iteradores para suportar iteração sobre tipos "
"de sequência gerais e específicos, dicionários e outras formas mais "
"especializadas. Os tipos específicos não são importantes além da sua "
"implementação do protocolo de iterador."

#: ../../library/stdtypes.rst:899
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Uma vez que o método :meth:`~iterator.__next__` de um iterador lança :exc:"
"`StopIteration`, deve continuar a fazê-lo em chamadas subsequentes. "
"Implementações que não obedecem a esta propriedade são consideradas "
"defeituosas."

#: ../../library/stdtypes.rst:907
msgid "Generator Types"
msgstr "Tipos de gerador"

#: ../../library/stdtypes.rst:909
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`~object.__iter__` method "
"is implemented as a generator, it will automatically return an iterator "
"object (technically, a generator object) supplying the :meth:`~iterator."
"__iter__` and :meth:`~generator.__next__` methods. More information about "
"generators can be found in :ref:`the documentation for the yield expression "
"<yieldexpr>`."
msgstr ""
"Os :term:`geradores` do Python fornecem uma forma conveniente de implementar "
"o protocolo de iterador. Se o método :meth:`~object.__iter__` de um objeto "
"contentor for implementado como um gerador, retornará automaticamente um "
"objeto iterador (tecnicamente, um objeto gerador) que fornece os métodos :"
"meth:`~iterator.__iter__` e :meth:`~generator.__next__`. Mais informações "
"sobre geradores podem ser encontradas em :ref:`a documentação para a "
"expressão yield <yieldexpr>`. "

#: ../../library/stdtypes.rst:921
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Tipos de sequência --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../../library/stdtypes.rst:923
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Existem três tipos básicos de sequência: listas, tuplos e objetos de "
"intervalo. Tipos de sequência adicionais adaptados para processamento de :"
"ref:`dados binários <binaryseq>` e :ref:`strings de texto <textseq>` são "
"descritos em secções dedicadas."

#: ../../library/stdtypes.rst:932
msgid "Common Sequence Operations"
msgstr "Operações comuns de sequência"

#: ../../library/stdtypes.rst:936
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"As operações na tabela seguinte são suportadas pela maioria dos tipos de "
"sequência, tanto mutáveis como imutáveis. A ABC :class:`collections.abc."
"Sequence` é fornecida para facilitar a implementação correta destas "
"operações em tipos de sequência personalizados."

#: ../../library/stdtypes.rst:941
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Esta tabela lista as operações de sequência ordenadas por prioridade "
"ascendente. Na tabela, *s* e *t* são sequências do mesmo tipo, *n*, *i*, *j* "
"e *k* são inteiros e *x* é um objeto arbitrário que cumpre quaisquer "
"restrições de tipo e valor impostas por *s*."

#: ../../library/stdtypes.rst:946
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"As operações ``in`` e ``not in`` têm as mesmas prioridades que as operações "
"de comparação. As operações ``+`` (concatenação) e ``*`` (repetição) têm a "
"mesma prioridade que as operações numéricas correspondentes. [3]_"

#: ../../library/stdtypes.rst:965
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:965
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` se um item de *s* for igual a *x*, senão ``False``"

#: ../../library/stdtypes.rst:968
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:968
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` se um item de *s* for igual a *x*, senão ``True``"

#: ../../library/stdtypes.rst:971
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:971
msgid "the concatenation of *s* and *t*"
msgstr "a concatenação de *s* e *t*"

#: ../../library/stdtypes.rst:971
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../../library/stdtypes.rst:974
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` ou ``n * s``"

#: ../../library/stdtypes.rst:974
msgid "equivalent to adding *s* to itself *n* times"
msgstr "equivalente a adicionar *s* a si mesmo *n* vezes"

#: ../../library/stdtypes.rst:974
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../../library/stdtypes.rst:977
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:977
msgid "*i*\\ th item of *s*, origin 0"
msgstr "item *i* de *s*, origem 0"

#: ../../library/stdtypes.rst:977
msgid "(3)(8)"
msgstr "(3)(8)"

#: ../../library/stdtypes.rst:979
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:979
msgid "slice of *s* from *i* to *j*"
msgstr "fatia de *s* de *i* a *j*"

#: ../../library/stdtypes.rst:979
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:981
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:981
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "fatia de *s* de *i* a *j* com passo *k*"

#: ../../library/stdtypes.rst:981
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:984
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:984
msgid "length of *s*"
msgstr "comprimento de *s*"

#: ../../library/stdtypes.rst:986
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:986
msgid "smallest item of *s*"
msgstr "menor item de *s*"

#: ../../library/stdtypes.rst:988
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:988
msgid "largest item of *s*"
msgstr "maior item de *s*"

#: ../../library/stdtypes.rst:991
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Sequências do mesmo tipo também suportam comparações. Em particular, tuplos "
"e listas são comparados lexicograficamente comparando elementos "
"correspondentes. Isto significa que para serem iguais, todos os elementos "
"devem ser iguais e as duas sequências devem ser do mesmo tipo e ter o mesmo "
"comprimento. (Para mais detalhes, consulte :ref:`comparisons` na referência "
"da linguagem.)"

#: ../../library/stdtypes.rst:1001
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Iteradores diretos e invertidos sobre sequências mutáveis acedem a valores "
"usando um índice. Esse índice continuará a avançar (ou recuar) mesmo que a "
"sequência subjacente seja mutada. O iterador termina apenas quando é "
"encontrado um :exc:`IndexError` ou um :exc:`StopIteration` (ou quando o "
"índice cai abaixo de zero)."

#: ../../library/stdtypes.rst:1010
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Embora as operações ``in`` e ``not in`` sejam usadas apenas para testes de "
"contenção simples no caso geral, algumas sequências especializadas (como :"
"class:`str`, :class:`bytes` e :class:`bytearray`) também as usam para testes "
"de subsequência:"

#: ../../library/stdtypes.rst:1015
msgid ""
">>> \"gg\" in \"eggs\"\n"
"True"
msgstr ""
">>> \"gg\" in \"eggs\"\n"
"True"

#: ../../library/stdtypes.rst:1019
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Valores de *n* menores que ``0`` são tratados como ``0`` (o que produz uma "
"sequência vazia do mesmo tipo que *s*). Note que os itens na sequência *s* "
"não são copiados; são referenciados várias vezes. Isto muitas vezes assombra "
"programadores Python iniciantes; considere:"

#: ../../library/stdtypes.rst:1024
msgid ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"
msgstr ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"

#: ../../library/stdtypes.rst:1031
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"O que aconteceu é que ``[[]]`` é uma lista de um elemento contendo uma lista "
"vazia, por isso os três elementos de ``[[]] * 3`` são referências a esta "
"única lista vazia. Modificar qualquer um dos elementos de ``lists`` modifica "
"esta única lista. Pode criar uma lista de listas diferentes desta forma:"

#: ../../library/stdtypes.rst:1036
msgid ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"
msgstr ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"

#: ../../library/stdtypes.rst:1043
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Mais explicações estão disponíveis na entrada da FAQ :ref:`faq-"
"multidimensional-list`."

#: ../../library/stdtypes.rst:1047
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Se *i* ou *j* for negativo, o índice é relativo ao final da sequência *s*: "
"``len(s) + i`` ou ``len(s) + j`` é substituído. Mas note que ``-0`` ainda é "
"``0``."

#: ../../library/stdtypes.rst:1052
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"A fatia de *s* de *i* a *j* é definida como a sequência de itens com índice "
"*k* tal que ``i <= k < j``. Se *i* ou *j* for maior que ``len(s)``, use "
"``len(s)``. Se *i* for omitido ou ``None``, use ``0``. Se *j* for omitido ou "
"``None``, use ``len(s)``. Se *i* for maior ou igual a *j*, a fatia está "
"vazia."

#: ../../library/stdtypes.rst:1059
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"A fatia de *s* de *i* a *j* com passo *k* é definida como a sequência de "
"itens com índice ``x = i + n*k`` tal que ``0 <= n < (j-i)/k``. Em outras "
"palavras, os índices são ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` e assim por "
"diante, parando quando *j* é atingido (mas nunca incluindo *j*). Quando *k* "
"é positivo, *i* e *j* são reduzidos a ``len(s)`` se forem maiores. Quando "
"*k* é negativo, *i* e *j* são reduzidos a ``len(s) - 1`` se forem maiores. "
"Se *i* ou *j* forem omitidos ou ``None``, tornam-se valores \"fim\" (que fim "
"depende do sinal de *k*). Note que *k* não pode ser zero. Se *k* for "
"``None``, é tratado como ``1``."

#: ../../library/stdtypes.rst:1070
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"A concatenação de sequências imutáveis resulta sempre num novo objeto. Isto "
"significa que construir uma sequência por concatenação repetida terá um "
"custo de tempo de execução quadrático no comprimento total da sequência. "
"Para obter um custo de tempo de execução linear, deve mudar para uma das "
"alternativas abaixo:"

#: ../../library/stdtypes.rst:1075
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"se estiver a concatenar objetos :class:`str`, pode construir uma lista e "
"usar :meth:`str.join` no final ou escrever para uma instância :class:`io."
"StringIO` e recuperar o seu valor quando completo"

#: ../../library/stdtypes.rst:1079
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"se estiver a concatenar objetos :class:`bytes`, pode usar de forma "
"semelhante :meth:`bytes.join` ou :class:`io.BytesIO`, ou pode fazer "
"concatenação *in-place* com um objeto :class:`bytearray`. Os objetos :class:"
"`bytearray` são mutáveis e têm um mecanismo eficiente de sobrealocação"

#: ../../library/stdtypes.rst:1084
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"se estiver a concatenar objetos :class:`tuple`, estenda uma :class:`list`"

#: ../../library/stdtypes.rst:1086
msgid "for other types, investigate the relevant class documentation"
msgstr "para outros tipos, consulte a documentação da classe relevante"

#: ../../library/stdtypes.rst:1090
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Alguns tipos de sequência (como :class:`range`) só suportam sequências de "
"itens que seguem padrões específicos, e por isso não suportam concatenação "
"ou repetição de sequências."

#: ../../library/stdtypes.rst:1095
msgid "An :exc:`IndexError` is raised if *i* is outside the sequence range."
msgstr ""
"Uma exceção :exc:`IndexError` é lançada se *i* estiver fora do intervalo da "
"sequência."

#: ../../library/stdtypes.rst:1098
msgid "Sequence Methods"
msgstr "Métodos de sequência"

#: ../../library/stdtypes.rst:1099
msgid "Sequence types also support the following methods:"
msgstr "Os tipos de sequência também suportam os seguintes métodos:"

#: ../../library/stdtypes.rst:1109
msgid "Return the total number of occurrences of *value* in *sequence*."
msgstr "Retorna o número total de ocorrências de *value* em *sequence*."

#: ../../library/stdtypes.rst:1119
msgid "Return the index of the first occurrence of *value* in *sequence*."
msgstr "Retorna o índice da primeira ocorrência de *value* em *sequence*."

#: ../../library/stdtypes.rst:1121 ../../library/stdtypes.rst:1305
msgid "Raises :exc:`ValueError` if *value* is not found in *sequence*."
msgstr "Lança :exc:`ValueError` se *value* não for encontrado em *sequence*."

#: ../../library/stdtypes.rst:1123
msgid ""
"The *start* or *stop* arguments allow for efficient searching of subsections "
"of the sequence, beginning at *start* and ending at *stop*. This is roughly "
"equivalent to ``start + sequence[start:stop].index(value)``, only without "
"copying any data."
msgstr ""
"Os argumentos *start* ou *stop* permitem uma pesquisa eficiente de "
"subsecções da sequência, começando em *start* e terminando em *stop*. Isto é "
"aproximadamente equivalente a ``start + sequence[start:stop].index(value)``, "
"mas sem copiar quaisquer dados."

#: ../../library/stdtypes.rst:1129
msgid ""
"Not all sequence types support passing the *start* and *stop* arguments."
msgstr ""
"Nem todos os tipos de sequência suportam a passagem dos argumentos *start* e "
"*stop*."

#: ../../library/stdtypes.rst:1135
msgid "Immutable Sequence Types"
msgstr "Tipos de sequência imutável"

#: ../../library/stdtypes.rst:1142
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"A única operação que os tipos de sequência imutáveis geralmente implementam "
"e que não é também implementada pelos tipos de sequência mutáveis é o "
"suporte para a função integrada :func:`hash`."

#: ../../library/stdtypes.rst:1146
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Este suporte permite que sequências imutáveis, como instâncias :class:"
"`tuple`, sejam usadas como chaves :class:`dict` e armazenadas em instâncias :"
"class:`set` e :class:`frozenset`."

#: ../../library/stdtypes.rst:1150
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Tentar calcular o *hash* de uma sequência imutável que contenha valores não "
"hasháveis resultará em :exc:`TypeError`."

#: ../../library/stdtypes.rst:1157
msgid "Mutable Sequence Types"
msgstr "Tipos de sequência mutável"

#: ../../library/stdtypes.rst:1164
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"As operações na tabela seguinte são definidas em tipos de sequência "
"mutáveis. A ABC :class:`collections.abc.MutableSequence` é fornecida para "
"facilitar a implementação correta destas operações em tipos de sequência "
"personalizados."

#: ../../library/stdtypes.rst:1168
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Na tabela, *s* é uma instância de um tipo de sequência mutável, *t* é "
"qualquer objeto iterável e *x* é um objeto arbitrário que cumpre quaisquer "
"restrições de tipo e valor impostas por *s* (por exemplo, :class:`bytearray` "
"só aceita inteiros que cumprem a restrição de valor ``0 <= x <= 255``)."

#: ../../library/stdtypes.rst:1184
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1184
msgid "item *i* of *s* is replaced by *x*"
msgstr "o item *i* de *s* é substituído por *x*"

#: ../../library/stdtypes.rst:1187
msgid "``del s[i]``"
msgstr "``del s[i]``"

#: ../../library/stdtypes.rst:1187
msgid "removes item *i* of *s*"
msgstr "remove o item *i* de *s*"

#: ../../library/stdtypes.rst:1189
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1189
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"a fatia de *s* de *i* a *j* é substituída pelo conteúdo do iterável *t*"

#: ../../library/stdtypes.rst:1193
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1193
msgid ""
"removes the elements of ``s[i:j]`` from the list (same as ``s[i:j] = []``)"
msgstr "remove os elementos de ``s[i:j]`` da lista (igual a ``s[i:j] = []``)"

#: ../../library/stdtypes.rst:1197
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1197
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "os elementos de ``s[i:j:k]`` são substituídos pelos de *t*"

#: ../../library/stdtypes.rst:1200
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1200
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "remove os elementos de ``s[i:j:k]`` da lista"

#: ../../library/stdtypes.rst:1203
msgid "``s += t``"
msgstr "``s += t``"

#: ../../library/stdtypes.rst:1203
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"estende *s* com o conteúdo de *t* (na maior parte igual a ``s[len(s):len(s)] "
"= t``)"

#: ../../library/stdtypes.rst:1208
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1208
msgid "updates *s* with its contents repeated *n* times"
msgstr "atualiza *s* com o seu conteúdo repetido *n* vezes"

#: ../../library/stdtypes.rst:1215
msgid ""
"If *k* is not equal to ``1``, *t* must have the same length as the slice it "
"is replacing."
msgstr ""
"Se *k* não for igual a ``1``, *t* deve ter o mesmo comprimento que a fatia "
"que está a substituir."

#: ../../library/stdtypes.rst:1218
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"O valor *n* é um inteiro, ou um objeto que implementa :meth:`~object."
"__index__`. Valores zero e negativos de *n* limpam a sequência. Os itens na "
"sequência não são copiados; são referenciados várias vezes, como explicado "
"para ``s * n`` em :ref:`typesseq-common`."

#: ../../library/stdtypes.rst:1224
msgid "Mutable Sequence Methods"
msgstr "Métodos de sequência mutável"

#: ../../library/stdtypes.rst:1225
msgid "Mutable sequence types also support the following methods:"
msgstr "Os tipos de sequência mutável também suportam os seguintes métodos:"

#: ../../library/stdtypes.rst:1234
msgid ""
"Append *value* to the end of the sequence This is equivalent to writing "
"``seq[len(seq):len(seq)] = [value]``."
msgstr ""
"Acrescenta *value* ao final da sequência. Isto é equivalente a escrever "
"``seq[len(seq):len(seq)] = [value]``."

#: ../../library/stdtypes.rst:1246
msgid ""
"Remove all items from *sequence*. This is equivalent to writing ``del "
"sequence[:]``."
msgstr ""
"Remove todos os itens de *sequence*. Isto é equivalente a escrever ``del "
"sequence[:]``."

#: ../../library/stdtypes.rst:1258
msgid ""
"Create a shallow copy of *sequence*. This is equivalent to writing "
"``sequence[:]``."
msgstr ""
"Cria uma cópia superficial de *sequence*. Isto é equivalente a escrever "
"``sequence[:]``."

#: ../../library/stdtypes.rst:1261
msgid ""
"The :meth:`!copy` method is not part of the :class:`~collections.abc."
"MutableSequence` :class:`~abc.ABC`, but most concrete mutable sequence types "
"provide it."
msgstr ""
"O método :meth:`!copy` não faz parte da :class:`~collections.abc."
"MutableSequence` :class:`~abc.ABC`, mas a maioria dos tipos de sequência "
"mutável concretos fornecem-no."

#: ../../library/stdtypes.rst:1272
msgid ""
"Extend *sequence* with the contents of *iterable*. For the most part, this "
"is the same as writing ``seq[len(seq):len(seq)] = iterable``."
msgstr ""
"Estende *sequence* com o conteúdo de *iterable*. Na maior parte, isto é o "
"mesmo que escrever ``seq[len(seq):len(seq)] = iterable``."

#: ../../library/stdtypes.rst:1283
msgid ""
"Insert *value* into *sequence* at the given *index*. This is equivalent to "
"writing ``sequence[index:index] = [value]``."
msgstr ""
"Insere *value* em *sequence* no *index* dado. Isto é equivalente a escrever "
"``sequence[index:index] = [value]``."

#: ../../library/stdtypes.rst:1293
msgid ""
"Retrieve the item at *index* and also removes it from *sequence*. By "
"default, the last item in *sequence* is removed and returned."
msgstr ""
"Recupera o item em *index* e também o remove de *sequence*. Por "
"predefinição, o último item em *sequence* é removido e retornado."

#: ../../library/stdtypes.rst:1303
msgid "Remove the first item from *sequence* where ``sequence[i] == value``."
msgstr "Remove o primeiro item de *sequence* onde ``sequence[i] == value``."

#: ../../library/stdtypes.rst:1314
msgid ""
"Reverse the items of *sequence* in place. This method maintains economy of "
"space when reversing a large sequence. To remind users that it operates by "
"side-effect, it returns ``None``."
msgstr ""
"Inverte os itens de *sequence* *in-place*. Este método mantém a economia de "
"espaço ao inverter uma grande sequência. Para lembrar os utilizadores de que "
"opera por efeito lateral, retorna ``None``."

#: ../../library/stdtypes.rst:1322
msgid "Lists"
msgstr "Listas"

#: ../../library/stdtypes.rst:1326
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"As listas são sequências mutáveis, tipicamente usadas para armazenar "
"coleções de itens homogéneos (onde o grau preciso de semelhança variará "
"conforme a aplicação)."

#: ../../library/stdtypes.rst:1332
msgid "Lists may be constructed in several ways:"
msgstr "As listas podem ser construídas de várias formas:"

#: ../../library/stdtypes.rst:1334
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "Usando um par de parênteses retos para denotar a lista vazia: ``[]``"

#: ../../library/stdtypes.rst:1335
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Usando parênteses retos, separando itens com vírgulas: ``[a]``, ``[a, b, c]``"

#: ../../library/stdtypes.rst:1336
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Usando uma *list comprehension*: ``[x for x in iterable]``"

#: ../../library/stdtypes.rst:1337
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Usando o construtor de tipo: ``list()`` ou ``list(iterable)``"

#: ../../library/stdtypes.rst:1339
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"O construtor cria uma lista cujos itens são os mesmos e na mesma ordem que "
"os itens de *iterable*. *iterable* pode ser uma sequência, um contentor que "
"suporta iteração, ou um objeto iterador. Se *iterable* já for uma lista, é "
"feita uma cópia e retornada, semelhante a ``iterable[:]``. Por exemplo, "
"``list('abc')`` retorna ``['a', 'b', 'c']`` e ``list( (1, 2, 3) )`` retorna "
"``[1, 2, 3]``. Se nenhum argumento for fornecido, o construtor cria uma nova "
"lista vazia, ``[]``."

#: ../../library/stdtypes.rst:1348
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Muitas outras operações também produzem listas, incluindo a função "
"integrada :func:`sorted`."

#: ../../library/stdtypes.rst:1351
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"As listas implementam todas as operações de sequência :ref:`comuns <typesseq-"
"common>` e :ref:`mutáveis <typesseq-mutable>`. As listas também fornecem o "
"seguinte método adicional:"

#: ../../library/stdtypes.rst:1357
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Este método ordena a lista *in-place*, usando apenas comparações ``<`` entre "
"itens. As exceções não são suprimidas - se alguma operação de comparação "
"falhar, toda a operação de ordenação falhará (e a lista provavelmente ficará "
"num estado parcialmente modificado)."

#: ../../library/stdtypes.rst:1362
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` aceita dois argumentos que só podem ser passados por palavra-"
"chave (:ref:`argumentos apenas por palavra-chave <keyword-only_parameter>`):"

#: ../../library/stdtypes.rst:1365
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key* especifica uma função de um argumento que é usada para extrair uma "
"chave de comparação de cada elemento da lista (por exemplo, ``key=str."
"lower``). A chave correspondente a cada item na lista é calculada uma vez e "
"depois usada para todo o processo de ordenação. O valor predefinido ``None`` "
"significa que os itens da lista são ordenados diretamente sem calcular um "
"valor de chave separado."

#: ../../library/stdtypes.rst:1372
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"A utilidade :func:`functools.cmp_to_key` está disponível para converter uma "
"função *cmp* no estilo 2.x para uma função *key*."

#: ../../library/stdtypes.rst:1375
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* é um valor booleano. Se definido como ``True``, os elementos da "
"lista são ordenados como se cada comparação fosse invertida."

#: ../../library/stdtypes.rst:1378
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Este método modifica a sequência *in-place* para economizar espaço ao "
"ordenar uma grande sequência. Para lembrar os utilizadores de que opera por "
"efeito lateral, não retorna a sequência ordenada (use :func:`sorted` para "
"solicitar explicitamente uma nova instância de lista ordenada)."

#: ../../library/stdtypes.rst:1383
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"O método :meth:`sort` é garantidamente estável. Uma ordenação é estável se "
"garantir não alterar a ordem relativa de elementos que comparam igual --- "
"isto é útil para ordenação em múltiplas passagens (por exemplo, ordenar por "
"departamento, depois por nível salarial)."

#: ../../library/stdtypes.rst:1388
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Para exemplos de ordenação e um breve tutorial sobre ordenação, consulte :"
"ref:`sortinghowto`."

#: ../../library/stdtypes.rst:1392
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Enquanto uma lista está a ser ordenada, o efeito de tentar mutar, ou mesmo "
"inspecionar, a lista é indefinido. A implementação C do Python faz com que a "
"lista pareça vazia durante a operação, e lança :exc:`ValueError` se "
"conseguir detetar que a lista foi mutada durante a ordenação."

#: ../../library/stdtypes.rst:1401
msgid "Tuples"
msgstr "Tuplos"

#: ../../library/stdtypes.rst:1405
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Os tuplos são sequências imutáveis, tipicamente usadas para armazenar "
"coleções de dados heterogéneos (como os 2-tuplos produzidos pela função "
"integrada :func:`enumerate`). Os tuplos também são usados em casos onde é "
"necessária uma sequência imutável de dados homogéneos (como permitir "
"armazenamento numa instância :class:`set` ou :class:`dict`)."

#: ../../library/stdtypes.rst:1413
msgid "Tuples may be constructed in a number of ways:"
msgstr "Os tuplos podem ser construídos de várias formas:"

#: ../../library/stdtypes.rst:1415
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "Usando um par de parênteses para denotar o tuplo vazio: ``()``"

#: ../../library/stdtypes.rst:1416
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "Usando uma vírgula final para um tuplo singular: ``a,`` ou ``(a,)``"

#: ../../library/stdtypes.rst:1417
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Separando itens com vírgulas: ``a, b, c`` ou ``(a, b, c)``"

#: ../../library/stdtypes.rst:1418
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Usando a função integrada :func:`tuple`: ``tuple()`` ou ``tuple(iterable)``"

#: ../../library/stdtypes.rst:1420
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"O construtor cria um tuplo cujos itens são os mesmos e na mesma ordem que os "
"itens de *iterable*. *iterable* pode ser uma sequência, um contentor que "
"suporta iteração, ou um objeto iterador. Se *iterable* já for um tuplo, é "
"retornado inalterado. Por exemplo, ``tuple('abc')`` retorna ``('a', 'b', "
"'c')`` e ``tuple( [1, 2, 3] )`` retorna ``(1, 2, 3)``. Se nenhum argumento "
"for fornecido, o construtor cria um novo tuplo vazio, ``()``."

#: ../../library/stdtypes.rst:1428
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Note que é na verdade a vírgula que cria um tuplo, não os parênteses. Os "
"parênteses são opcionais, exceto no caso do tuplo vazio, ou quando são "
"necessários para evitar ambiguidade sintática. Por exemplo, ``f(a, b, c)`` é "
"uma chamada de função com três argumentos, enquanto ``f((a, b, c))`` é uma "
"chamada de função com um 3-tuplo como argumento único."

#: ../../library/stdtypes.rst:1434
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Os tuplos implementam todas as :ref:`operações comuns <typesseq-common>` de "
"sequência."

#: ../../library/stdtypes.rst:1437
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Para coleções heterogéneas de dados onde o acesso por nome é mais claro do "
"que o acesso por índice, :func:`collections.namedtuple` pode ser uma escolha "
"mais apropriada do que um simples objeto tuplo."

#: ../../library/stdtypes.rst:1445
msgid "Ranges"
msgstr "Intervalos"

#: ../../library/stdtypes.rst:1449
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"O tipo :class:`range` representa uma sequência imutável de números e é "
"comumente usado para iterar um número específico de vezes em ciclos :keyword:"
"`for`."

#: ../../library/stdtypes.rst:1456
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Os argumentos para o construtor de intervalo devem ser inteiros (ou o :class:"
"`int` integrado ou qualquer objeto que implemente o método especial :meth:"
"`~object.__index__`). Se o argumento *step* for omitido, o valor predefinido "
"é ``1``. Se o argumento *start* for omitido, o valor predefinido é ``0``. Se "
"*step* for zero, é lançada uma exceção :exc:`ValueError`."

#: ../../library/stdtypes.rst:1462
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Para um *step* positivo, o conteúdo de um intervalo ``r`` é determinado pela "
"fórmula ``r[i] = start + step*i`` onde ``i >= 0`` e ``r[i] < stop``."

#: ../../library/stdtypes.rst:1466
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Para um *step* negativo, o conteúdo do intervalo ainda é determinado pela "
"fórmula ``r[i] = start + step*i``, mas as restrições são ``i >= 0`` e ``r[i] "
"> stop``."

#: ../../library/stdtypes.rst:1470
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Um objeto de intervalo estará vazio se ``r[0]`` não cumprir a restrição de "
"valor. Os intervalos suportam índices negativos, mas estes são interpretados "
"como indexação a partir do final da sequência determinada pelos índices "
"positivos."

#: ../../library/stdtypes.rst:1475
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Intervalos que contêm valores absolutos maiores que :data:`sys.maxsize` são "
"permitidos, mas algumas funcionalidades (como :func:`len`) podem lançar uma "
"exceção :exc:`OverflowError`."

#: ../../library/stdtypes.rst:1479
msgid "Range examples::"
msgstr "Exemplos de intervalos:"

#: ../../library/stdtypes.rst:1481
msgid ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"
msgstr ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"

#: ../../library/stdtypes.rst:1496
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Os intervalos implementam todas as :ref:`operações comuns <typesseq-common>` "
"de sequência, exceto concatenação e repetição (devido ao facto de os objetos "
"de intervalo só poderem representar sequências que seguem um padrão estrito "
"e a repetição e concatenação geralmente violam esse padrão)."

#: ../../library/stdtypes.rst:1503
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr ""
"O valor do parâmetro *start* (ou ``0`` se o parâmetro não foi fornecido)"

#: ../../library/stdtypes.rst:1508
msgid "The value of the *stop* parameter"
msgstr "O valor do parâmetro *stop*"

#: ../../library/stdtypes.rst:1512
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr ""
"O valor do parâmetro *step* (ou ``1`` se o parâmetro não foi fornecido)"

#: ../../library/stdtypes.rst:1515
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"A vantagem do tipo :class:`range` sobre uma :class:`list` ou :class:`tuple` "
"regular é que um objeto :class:`range` ocupará sempre a mesma (pequena) "
"quantidade de memória, independentemente do tamanho do intervalo que "
"representa (uma vez que armazena apenas os valores ``start``, ``stop`` e "
"``step``, calculando itens individuais e subintervalos conforme necessário)."

#: ../../library/stdtypes.rst:1521
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Os objetos de intervalo implementam a ABC :class:`collections.abc.Sequence` "
"e fornecem funcionalidades como testes de contenção, pesquisa de índice de "
"elemento, fatiamento e suporte para índices negativos (consulte :ref:"
"`typesseq`):"

#: ../../library/stdtypes.rst:1541
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Testar objetos de intervalo para igualdade com ``==`` e ``!=`` compara-os "
"como sequências. Ou seja, dois objetos de intervalo são considerados iguais "
"se representarem a mesma sequência de valores. (Note que dois objetos de "
"intervalo que comparam igual podem ter atributos :attr:`~range.start`, :attr:"
"`~range.stop` e :attr:`~range.step` diferentes, por exemplo ``range(0) == "
"range(2, 1, 3)`` ou ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: ../../library/stdtypes.rst:1548
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Implementa a ABC de Sequência. Suporta fatiamento e índices negativos. Testa "
"objetos :class:`int` para pertencerem em tempo constante em vez de iterar "
"por todos os itens."

#: ../../library/stdtypes.rst:1554
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Define '==' e '!=' para comparar objetos de intervalo com base na sequência "
"de valores que definem (em vez de comparar com base na identidade do objeto)."

#: ../../library/stdtypes.rst:1559
msgid ""
"Added the :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Adicionados os atributos :attr:`~range.start`, :attr:`~range.stop` e :attr:"
"`~range.step`."

#: ../../library/stdtypes.rst:1564
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ shows how to implement a lazy version of range "
"suitable for floating-point applications."
msgstr ""
"A `receita linspace <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ mostra como implementar uma versão preguiçosa de "
"intervalo adequada para aplicações de ponto flutuante."

#: ../../library/stdtypes.rst:1576
msgid "Text Sequence Type --- :class:`str`"
msgstr "Tipo de sequência de texto --- :class:`str`"

#: ../../library/stdtypes.rst:1578
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Os dados textuais em Python são manipulados com objetos :class:`str`, ou :"
"dfn:`strings`. As *strings* são sequências :ref:`imutáveis <typesseq>` de "
"pontos de código Unicode. Os literais de *string* são escritos de várias "
"formas:"

#: ../../library/stdtypes.rst:1583
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Aspas simples: ``'allows embedded \"double\" quotes'``"

#: ../../library/stdtypes.rst:1584
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Aspas duplas: ``\"allows embedded 'single' quotes\"``"

#: ../../library/stdtypes.rst:1585
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Triplas aspas: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"

#: ../../library/stdtypes.rst:1587
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"As *strings* com aspas triplas podem abrangem várias linhas - todo o espaço "
"em branco associado será incluído no literal da *string*."

#: ../../library/stdtypes.rst:1590
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Literais de *string* que fazem parte de uma única expressão e têm apenas "
"espaços em branco entre eles serão implicitamente convertidos num único "
"literal de *string*. Ou seja, ``(\"spam \" \"eggs\") == \"spam eggs\"``."

#: ../../library/stdtypes.rst:1594
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported :ref:`escape sequences <escape-sequences>`, and the "
"``r`` (\"raw\") prefix that disables most escape sequence processing."
msgstr ""
"Consulte :ref:`strings` para mais informações sobre as várias formas de "
"literais de *string*, incluindo :ref:`sequências de escape <escape-"
"sequences>`, e o prefixo ``r`` (\"raw\") que desativa a maior parte do "
"processamento de sequências de escape."

#: ../../library/stdtypes.rst:1598
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"As *strings* também podem ser criadas a partir de outros objetos usando o "
"construtor :class:`str`."

#: ../../library/stdtypes.rst:1601
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Como não existe um tipo \"caractere\" separado, indexar uma *string* produz "
"*strings* de comprimento 1. Ou seja, para uma *string* não vazia *s*, ``s[0] "
"== s[0:1]``."

#: ../../library/stdtypes.rst:1607
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Também não existe um tipo de *string* mutável, mas :meth:`str.join` ou :"
"class:`io.StringIO` podem ser usados para construir *strings* de forma "
"eficiente a partir de múltiplos fragmentos."

#: ../../library/stdtypes.rst:1611
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Para compatibilidade com a série Python 2, o prefixo ``u`` é novamente "
"permitido em literais de *string*. Não tem efeito no significado dos "
"literais de *string* e não pode ser combinado com o prefixo ``r``."

#: ../../library/stdtypes.rst:1625
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Retorna uma versão :ref:`string <textseq>` de *object*. Se *object* não for "
"fornecido, retorna a *string* vazia. Caso contrário, o comportamento de "
"``str()`` depende de *encoding* ou *errors* serem fornecidos, como se segue."

#: ../../library/stdtypes.rst:1629
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :func:"
"`repr(object) <repr>`."
msgstr ""
"Se nem *encoding* nem *errors* forem fornecidos, ``str(object)`` retorna :"
"meth:`type(object).__str__(object) <object.__str__>`, que é a representação "
"de *string* \"informal\" ou bem imprimível de *object*. Para objetos de "
"*string*, esta é a própria *string*. Se *object* não tiver um método :meth:"
"`~object.__str__`, então :func:`str` recorre a retornar :func:`repr(object) "
"<repr>`."

#: ../../library/stdtypes.rst:1641
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Se pelo menos um de *encoding* ou *errors* for fornecido, *object* deve ser "
"um :term:`objeto do tipo bytes` (por exemplo, :class:`bytes` ou :class:"
"`bytearray`). Neste caso, se *object* for um objeto :class:`bytes` (ou :"
"class:`bytearray`), então ``str(bytes, encoding, errors)`` é equivalente a :"
"meth:`bytes.decode(encoding, errors) <bytes.decode>`. Caso contrário, o "
"objeto de bytes subjacente ao objeto de buffer é obtido antes de chamar :"
"meth:`bytes.decode`. Consulte :ref:`binaryseq` e :ref:`bufferobjects` para "
"informações sobre objetos de buffer."

#: ../../library/stdtypes.rst:1650
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Passar um objeto :class:`bytes` para :func:`str` sem os argumentos "
"*encoding* ou *errors* enquadra-se no primeiro caso de retorno da "
"representação informal de *string* (consulte também a opção de linha de "
"comandos :option:`-b` do Python). Por exemplo:"

#: ../../library/stdtypes.rst:1655
msgid ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""
msgstr ""
">>> str(b'Zoot!')\n"
"'b'Zoot!''"

#: ../../library/stdtypes.rst:1658
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Para mais informações sobre a classe ``str`` e os seus métodos, consulte :"
"ref:`textseq` e a secção :ref:`string-methods` abaixo. Para produzir "
"*strings* formatadas, consulte as secções :ref:`f-strings` e :ref:"
"`formatstrings`. Além disso, consulte a secção :ref:`stringservices`."

#: ../../library/stdtypes.rst:1670
msgid "String Methods"
msgstr "Métodos de *string*"

#: ../../library/stdtypes.rst:1675
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"As *strings* implementam todas as :ref:`operações comuns <typesseq-common>` "
"de sequência, juntamente com os métodos adicionais descritos abaixo."

#: ../../library/stdtypes.rst:1678
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"As *strings* também suportam dois estilos de formatação de *strings*, um que "
"fornece um grande grau de flexibilidade e personalização (consulte :meth:"
"`str.format`, :ref:`formatstrings` e :ref:`string-formatting`) e outro "
"baseado na formatação no estilo C ``printf``, que lida com uma gama mais "
"estreita de tipos e é um pouco mais difícil de usar corretamente, mas é "
"geralmente mais rápido para os casos que pode lidar (:ref:`old-string-"
"formatting`)."

#: ../../library/stdtypes.rst:1685
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"A secção :ref:`textservices` da biblioteca padrão abrange vários outros "
"módulos que fornecem várias utilidades relacionadas com texto (incluindo "
"suporte para expressões regulares no módulo :mod:`re`)."

#: ../../library/stdtypes.rst:1691
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Retorna uma cópia da *string* com o primeiro caractere em maiúscula e o "
"resto em minúsculas."

#: ../../library/stdtypes.rst:1694
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"O primeiro caractere é agora colocado em título em vez de maiúscula. Isto "
"significa que caracteres como dígrafos terão apenas a sua primeira letra "
"maiúscula, em vez de todo o caractere."

#: ../../library/stdtypes.rst:1701
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Retorna uma cópia da *string* em *casefold*. *Strings* em *casefold* podem "
"ser usadas para correspondência sem distinção de maiúsculas/minúsculas."

#: ../../library/stdtypes.rst:1704
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"*Casefold* é semelhante a converter para minúsculas, mas mais agressivo, "
"porque destina-se a remover todas as distinções de maiúsculas/minúsculas "
"numa *string*. Por exemplo, a letra minúscula alemã ``'ß'`` é equivalente a "
"``\"ss\"``. Como já está em minúscula, :meth:`lower` não faria nada a "
"``'ß'``; :meth:`casefold` converte-a para ``\"ss\"``."

#: ../../library/stdtypes.rst:1710
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.1.0/ch03.pdf>`__."
msgstr ""

#: ../../library/stdtypes.rst:1719
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``.  For example::"
msgstr ""
"Retorna centrado numa *string* de comprimento *width*. O preenchimento é "
"feito usando o *fillchar* especificado (o valor predefinido é um espaço "
"ASCII). A *string* original é retornada se *width* for menor ou igual a "
"``len(s)``. Por exemplo:"

#: ../../library/stdtypes.rst:1723
msgid ""
">>> 'Python'.center(10)\n"
"'  Python  '\n"
">>> 'Python'.center(10, '-')\n"
"'--Python--'\n"
">>> 'Python'.center(4)\n"
"'Python'"
msgstr ""
">>> 'Python'.center(10)\n"
"'  Python  '\n"
">>> 'Python'.center(10, '-')\n"
"'--Python--'\n"
">>> 'Python'.center(4)\n"
"'Python'"

#: ../../library/stdtypes.rst:1733
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Retorna o número de ocorrências não sobrepostas da substring *sub* no "
"intervalo [*start*, *end*]. Os argumentos opcionais *start* e *end* são "
"interpretados como na notação de fatia."

#: ../../library/stdtypes.rst:1737
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one. For example::"
msgstr ""
"Se *sub* estiver vazia, retorna o número de *strings* vazias entre "
"caracteres, que é o comprimento da *string* mais um. Por exemplo:"

#: ../../library/stdtypes.rst:1740
msgid ""
">>> 'spam, spam, spam'.count('spam')\n"
"3\n"
">>> 'spam, spam, spam'.count('spam', 5)\n"
"2\n"
">>> 'spam, spam, spam'.count('spam', 5, 10)\n"
"1\n"
">>> 'spam, spam, spam'.count('eggs')\n"
"0\n"
">>> 'spam, spam, spam'.count('')\n"
"17"
msgstr ""
">>> 'spam, spam, spam'.count('spam')\n"
"3\n"
">>> 'spam, spam, spam'.count('spam', 5)\n"
"2\n"
">>> 'spam, spam, spam'.count('spam', 5, 10)\n"
"1\n"
">>> 'spam, spam, spam'.count('eggs')\n"
"0\n"
">>> 'spam, spam, spam'.count('')\n"
"17"

#: ../../library/stdtypes.rst:1753
msgid "Return the string encoded to :class:`bytes`."
msgstr "Retorna a *string* codificada para :class:`bytes`."

#: ../../library/stdtypes.rst:1755 ../../library/stdtypes.rst:3208
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""
"*encoding* é ``'utf-8'`` por predefinição; consulte :ref:`standard-"
"encodings` para valores possíveis."

#: ../../library/stdtypes.rst:1758
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* controla como os erros de codificação são tratados. Se for "
"``'strict'`` (o valor predefinido), é lançada uma exceção :exc:"
"`UnicodeError`. Outros valores possíveis são ``'ignore'``, ``'replace'``, "
"``'xmlcharrefreplace'``, ``'backslashreplace'`` e qualquer outro nome "
"registado através de :func:`codecs.register_error`. Consulte :ref:`error-"
"handlers` para mais detalhes."

#: ../../library/stdtypes.rst:1765
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used. For example::"
msgstr ""
"Por razões de desempenho, o valor de *errors* não é verificado quanto à "
"validade a menos que ocorra um erro de codificação, :ref:`devmode` esteja "
"ativado ou uma :ref:`compilação de depuração <debug-build>` seja usada. Por "
"exemplo:"

#: ../../library/stdtypes.rst:1771
msgid ""
">>> encoded_str_to_bytes = 'Python'.encode()\n"
">>> type(encoded_str_to_bytes)\n"
"<class 'bytes'>\n"
">>> encoded_str_to_bytes\n"
"b'Python'"
msgstr ""
">>> encoded_str_to_bytes = 'Python'.encode()\n"
">>> type(encoded_str_to_bytes)\n"
"<class 'bytes'>\n"
">>> encoded_str_to_bytes\n"
"b'Python'"

#: ../../library/stdtypes.rst:1778 ../../library/stdtypes.rst:3227
msgid "Added support for keyword arguments."
msgstr "Adicionado suporte para argumentos de palavra-chave."

#: ../../library/stdtypes.rst:1781 ../../library/stdtypes.rst:3230
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""
"O valor do argumento *errors* é agora verificado em :ref:`devmode` e em :ref:"
"`modo de depuração <debug-build>`."

#: ../../library/stdtypes.rst:1788
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position. Using *start* and *end* is "
"equivalent to ``str[start:end].endswith(suffix)``. For example::"
msgstr ""
"Retorna ``True`` se a *string* terminar com o *suffix* especificado, caso "
"contrário retorna ``False``. *suffix* também pode ser um tuplo de sufixos a "
"procurar. Com *start* opcional, teste a partir dessa posição. Com *end* "
"opcional, pare de comparar nessa posição. Usar *start* e *end* é equivalente "
"a ``str[start:end].endswith(suffix)``. Por exemplo:"

#: ../../library/stdtypes.rst:1794
msgid ""
">>> 'Python'.endswith('on')\n"
"True\n"
">>> 'a tuple of suffixes'.endswith(('at', 'in'))\n"
"False\n"
">>> 'a tuple of suffixes'.endswith(('at', 'es'))\n"
"True\n"
">>> 'Python is amazing'.endswith('is', 0, 9)\n"
"True"
msgstr ""
">>> 'Python'.endswith('on')\n"
"True\n"
">>> 'a tuple of suffixes'.endswith(('at', 'in'))\n"
"False\n"
">>> 'a tuple of suffixes'.endswith(('at', 'es'))\n"
"True\n"
">>> 'Python is amazing'.endswith('is', 0, 9)\n"
"True"

#: ../../library/stdtypes.rst:1803
msgid "See also :meth:`startswith` and :meth:`removesuffix`."
msgstr "Consulte também :meth:`startswith` e :meth:`removesuffix`."

#: ../../library/stdtypes.rst:1808
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed. For example::"
msgstr ""
"Retorna uma cópia da *string* onde todos os caracteres de tabulação são "
"substituídos por um ou mais espaços, dependendo da coluna atual e do tamanho "
"de tabulação dado. As posições de tabulação ocorrem a cada *tabsize* "
"caracteres (o valor predefinido é 8, dando posições de tabulação nas colunas "
"0, 8, 16, etc.). Para expandir a *string*, a coluna atual é definida como "
"zero e a *string* é examinada caractere a caractere. Se o caractere for uma "
"tabulação (``\\t``), um ou mais caracteres de espaço são inseridos no "
"resultado até que a coluna atual seja igual à próxima posição de tabulação. "
"(O próprio caractere de tabulação não é copiado.) Se o caractere for uma "
"nova linha (``\\n``) ou retorno (``\\r``), é copiado e a coluna atual é "
"redefinida para zero. Qualquer outro caractere é copiado inalterado e a "
"coluna atual é incrementada em um, independentemente de como o caractere é "
"representado quando impresso. Por exemplo:"

#: ../../library/stdtypes.rst:1821
msgid ""
">>> '01\\t012\\t0123\\t01234'.expandtabs()\n"
"'01      012     0123    01234'\n"
">>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"'01  012 0123    01234'\n"
">>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n"
"01  012\n"
"0123    01234"
msgstr ""
">>> '01\\t012\\t0123\\t01234'.expandtabs()\n"
"'01      012     0123    01234'\n"
">>> '01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"'01  012 0123    01234'\n"
">>> print('01\\t012\\n0123\\t01234'.expandtabs(4))\n"
"01  012\n"
"0123    01234"

#: ../../library/stdtypes.rst:1832
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found. For "
"example::"
msgstr ""
"Retorna o índice mais baixo na *string* onde a substring *sub* é encontrada "
"dentro da fatia ``s[start:end]``. Os argumentos opcionais *start* e *end* "
"são interpretados como na notação de fatia. Retorna ``-1`` se *sub* não for "
"encontrada. Por exemplo:"

#: ../../library/stdtypes.rst:1837
msgid ""
">>> 'spam, spam, spam'.find('sp')\n"
"0\n"
">>> 'spam, spam, spam'.find('sp', 5)\n"
"6"
msgstr ""
">>> 'spam, spam, spam'.find('sp')\n"
"0\n"
">>> 'spam, spam, spam'.find('sp', 5)\n"
"6"

#: ../../library/stdtypes.rst:1842
msgid "See also :meth:`rfind` and :meth:`index`."
msgstr "Consulte também :meth:`rfind` e :meth:`index`."

#: ../../library/stdtypes.rst:1846
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"O método :meth:`~str.find` deve ser usado apenas se precisar de saber a "
"posição de *sub*. Para verificar se *sub* é uma substring ou não, use o "
"operador :keyword:`in`:"

#: ../../library/stdtypes.rst:1850
msgid ""
">>> 'Py' in 'Python'\n"
"True"
msgstr ""
">>> 'Py' in 'Python'\n"
"True"

#: ../../library/stdtypes.rst:1856
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument. For example:"
msgstr ""

#: ../../library/stdtypes.rst:1863
msgid ""
">>> \"The sum of 1 + 2 is {0}\".format(1+2)\n"
"'The sum of 1 + 2 is 3'\n"
">>> \"The sum of {a} + {b} is {answer}\".format(answer=1+2, a=1, b=2)\n"
"'The sum of 1 + 2 is 3'\n"
">>> \"{1} expects the {0} Inquisition!\".format(\"Spanish\", \"Nobody\")\n"
"'Nobody expects the Spanish Inquisition!'"
msgstr ""

#: ../../library/stdtypes.rst:1872
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Consulte :ref:`formatstrings` para uma descrição das várias opções de "
"formatação que podem ser especificadas em *strings* de formato."

#: ../../library/stdtypes.rst:1876
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Ao formatar um número (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` e subclasses) com o tipo ``n`` (ex: ``'{:n}'."
"format(1234)``), a função define temporariamente a localização ``LC_CTYPE`` "
"para a localização ``LC_NUMERIC`` para descodificar os campos "
"``decimal_point`` e ``thousands_sep`` de :c:func:`localeconv` se forem não-"
"ASCII ou maiores que 1 byte, e a localização ``LC_NUMERIC`` for diferente da "
"localização ``LC_CTYPE``. Esta alteração temporária afeta outras *threads*."

#: ../../library/stdtypes.rst:1885
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Ao formatar um número com o tipo ``n``, a função define temporariamente a "
"localização ``LC_CTYPE`` para a localização ``LC_NUMERIC`` em alguns casos."

#: ../../library/stdtypes.rst:1893
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Semelhante a ``str.format(**mapping)``, exceto que ``mapping`` é usado "
"diretamente e não é copiado para um :class:`dict`. Isto é útil se, por "
"exemplo, ``mapping`` for uma subclasse de dicionário:"

#: ../../library/stdtypes.rst:1909
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found. For example:"
msgstr ""

#: ../../library/stdtypes.rst:1912
msgid ""
">>> 'spam, spam, spam'.index('eggs')\n"
"Traceback (most recent call last):\n"
"  File \"<python-input-0>\", line 1, in <module>\n"
"    'spam, spam, spam'.index('eggs')\n"
"    ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^\n"
"ValueError: substring not found"
msgstr ""

#: ../../library/stdtypes.rst:1921
msgid "See also :meth:`rindex`."
msgstr ""

#: ../../library/stdtypes.rst:1926
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Retorna ``True`` se todos os caracteres na *string* forem alfanuméricos e "
"houver pelo menos um caractere, ``False`` caso contrário. Um caractere ``c`` "
"é alfanumérico se uma das seguintes funções retornar ``True``: ``c."
"isalpha()``, ``c.isdecimal()``, ``c.isdigit()`` ou ``c.isnumeric()``."

#: ../../library/stdtypes.rst:1934
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic "
"property defined in the section 4.10 'Letters, Alphabetic, and Ideographic' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode15.1.0/ch04."
"pdf>`_. For example:"
msgstr ""

#: ../../library/stdtypes.rst:1943
msgid ""
">>> 'Letters and spaces'.isalpha()\n"
"False\n"
">>> 'LettersOnly'.isalpha()\n"
"True\n"
">>> 'µ'.isalpha()  # non-ASCII characters can be considered alphabetical "
"too\n"
"True"
msgstr ""

#: ../../library/stdtypes.rst:1952
msgid "See :ref:`unicode-properties`."
msgstr ""

#: ../../library/stdtypes.rst:1957
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F. For example:"
msgstr ""

#: ../../library/stdtypes.rst:1961
msgid ""
">>> 'ASCII characters'.isascii()\n"
"True\n"
">>> 'µ'.isascii()\n"
"False"
msgstr ""

#: ../../library/stdtypes.rst:1973
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, such as U+0660, ARABIC-"
"INDIC DIGIT ZERO.  Formally a decimal character is a character in the "
"Unicode General Category \"Nd\". For example:"
msgstr ""

#: ../../library/stdtypes.rst:1980
msgid ""
">>> '0123456789'.isdecimal()\n"
"True\n"
">>> '٠١٢٣٤٥٦٧٨٩'.isdecimal()  # Arabic-Indic digits zero to nine\n"
"True\n"
">>> 'alphabetic'.isdecimal()\n"
"False"
msgstr ""

#: ../../library/stdtypes.rst:1992
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Retorna ``True`` se todos os caracteres na *string* forem dígitos e houver "
"pelo menos um caractere, ``False`` caso contrário. Dígitos incluem "
"caracteres decimais e dígitos que necessitam de tratamento especial, como os "
"dígitos sobrescritos de compatibilidade. Isto abrange dígitos que não podem "
"ser usados para formar números em base 10, como os números Kharosthi. "
"Formalmente, um dígito é um caractere que tem o valor de propriedade "
"Numeric_Type=Digit ou Numeric_Type=Decimal."

#: ../../library/stdtypes.rst:2002
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Retorna ``True`` se a *string* for um identificador válido de acordo com a "
"definição da linguagem, secção :ref:`identifiers`."

#: ../../library/stdtypes.rst:2005
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"A função :func:`keyword.iskeyword` pode ser usada para testar se a *string* "
"``s`` é um identificador reservado, como :keyword:`def` e :keyword:`class`."

#: ../../library/stdtypes.rst:2008
msgid "Example: ::"
msgstr "Exemplo:"

#: ../../library/stdtypes.rst:2011
msgid ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"
msgstr ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"

#: ../../library/stdtypes.rst:2021
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Retorna ``True`` se todos os caracteres com caixa [4]_ na *string* forem "
"minúsculos e houver pelo menos um caractere com caixa, ``False`` caso "
"contrário."

#: ../../library/stdtypes.rst:2027
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric. For example:"
msgstr ""

#: ../../library/stdtypes.rst:2035
msgid ""
">>> '0123456789'.isnumeric()\n"
"True\n"
">>> '٠١٢٣٤٥٦٧٨٩'.isnumeric()  # Arabic-indic digit zero to nine\n"
"True\n"
">>> '⅕'.isnumeric()  # Vulgar fraction one fifth\n"
"True\n"
">>> '²'.isdecimal(), '²'.isdigit(),  '²'.isnumeric()\n"
"(False, True, True)"
msgstr ""

#: ../../library/stdtypes.rst:2046
msgid ""
"See also :meth:`isdecimal` and :meth:`isdigit`. Numeric characters are a "
"superset of decimal numbers."
msgstr ""

#: ../../library/stdtypes.rst:2052
msgid ""
"Return ``True`` if all characters in the string are printable, ``False`` if "
"it contains at least one non-printable character."
msgstr ""
"Retorna ``True`` se todos os caracteres na *string* forem imprimíveis, "
"``False`` se contiver pelo menos um caractere não imprimível."

#: ../../library/stdtypes.rst:2055
msgid ""
"Here \"printable\" means the character is suitable for :func:`repr` to use "
"in its output; \"non-printable\" means that :func:`repr` on built-in types "
"will hex-escape the character.  It has no bearing on the handling of strings "
"written to :data:`sys.stdout` or :data:`sys.stderr`."
msgstr ""
"Aqui, \"imprimível\" significa que o caractere é adequado para :func:`repr` "
"usar na sua saída; \"não imprimível\" significa que :func:`repr` em tipos "
"integrados fará escape hexadecimal do caractere. Não tem qualquer influência "
"no tratamento de *strings* escritas para :data:`sys.stdout` ou :data:`sys."
"stderr`."

#: ../../library/stdtypes.rst:2060
msgid ""
"The printable characters are those which in the Unicode character database "
"(see :mod:`unicodedata`) have a general category in group Letter, Mark, "
"Number, Punctuation, or Symbol (L, M, N, P, or S); plus the ASCII space "
"0x20. Nonprintable characters are those in group Separator or Other (Z or "
"C), except the ASCII space."
msgstr ""
"Os caracteres imprimíveis são aqueles que, na base de dados de caracteres "
"Unicode (consulte :mod:`unicodedata`), têm uma categoria geral no grupo "
"Letter, Mark, Number, Punctuation ou Symbol (L, M, N, P ou S); além do "
"espaço ASCII 0x20. Caracteres não imprimíveis são aqueles no grupo Separator "
"ou Other (Z ou C), exceto o espaço ASCII."

#: ../../library/stdtypes.rst:2066 ../../library/stdtypes.rst:2093
#: ../../library/stdtypes.rst:2148 ../../library/stdtypes.rst:2651
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/stdtypes.rst:2068
msgid ""
">>> ''.isprintable(), ' '.isprintable()\n"
"(True, True)\n"
">>> '\\t'.isprintable(), '\\n'.isprintable()\n"
"(False, False)"
msgstr ""

#: ../../library/stdtypes.rst:2078
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Retorna ``True`` se houver apenas caracteres de espaço em branco na *string* "
"e houver pelo menos um caractere, ``False`` caso contrário."

#: ../../library/stdtypes.rst:2081
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Um caractere é *whitespace* se, na base de dados de caracteres Unicode "
"(consulte :mod:`unicodedata`), a sua categoria geral for ``Zs`` "
"(\"Separator, space\"), ou a sua classe bidirecional for uma de ``WS``, "
"``B`` ou ``S``."

#: ../../library/stdtypes.rst:2089
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Retorna ``True`` se a *string* for uma *string* em título e houver pelo "
"menos um caractere, por exemplo, caracteres maiúsculos só podem seguir "
"caracteres sem caixa e caracteres minúsculos só podem seguir caracteres com "
"caixa. Retorna ``False`` caso contrário."

#: ../../library/stdtypes.rst:2095
msgid ""
">>> 'Spam, Spam, Spam'.istitle()\n"
"True\n"
">>> 'spam, spam, spam'.istitle()\n"
"False\n"
">>> 'SPAM, SPAM, SPAM'.istitle()\n"
"False"
msgstr ""

#: ../../library/stdtypes.rst:2104
msgid "See also :meth:`title`."
msgstr ""

#: ../../library/stdtypes.rst:2109
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Retorna ``True`` se todos os caracteres com caixa [4]_ na *string* forem "
"maiúsculos e houver pelo menos um caractere com caixa, ``False`` caso "
"contrário."

#: ../../library/stdtypes.rst:2127
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method. For example:"
msgstr ""

#: ../../library/stdtypes.rst:2132
msgid ""
">>> ', '.join(['spam', 'spam', 'spam'])\n"
"'spam, spam, spam'\n"
">>> '-'.join('Python')\n"
"'P-y-t-h-o-n'"
msgstr ""

#: ../../library/stdtypes.rst:2139
msgid "See also :meth:`split`."
msgstr ""

#: ../../library/stdtypes.rst:2144
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:2150
msgid ""
">>> 'Python'.ljust(10)\n"
"'Python    '\n"
">>> 'Python'.ljust(10, '.')\n"
"'Python....'\n"
">>> 'Monty Python'.ljust(10, '.')\n"
"'Monty Python'"
msgstr ""

#: ../../library/stdtypes.rst:2159
msgid "See also :meth:`rjust`."
msgstr ""

#: ../../library/stdtypes.rst:2164
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Retorna uma cópia da *string* com todos os caracteres com caixa [4]_ "
"convertidos para minúsculas."

#: ../../library/stdtypes.rst:2167
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.1.0/ch03.pdf>`__."
msgstr ""

#: ../../library/stdtypes.rst:2174
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Retorna uma cópia da *string* com os caracteres iniciais removidos. O "
"argumento *chars* é uma *string* que especifica o conjunto de caracteres a "
"serem removidos. Se for omitido ou ``None``, o argumento *chars* remove "
"espaços em branco por predefinição. O argumento *chars* não é um prefixo; em "
"vez disso, todas as combinações dos seus valores são removidas:"

#: ../../library/stdtypes.rst:2179
msgid ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"
msgstr ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"

#: ../../library/stdtypes.rst:2184
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Consulte :meth:`str.removeprefix` para um método que removerá uma única "
"*string* de prefixo em vez de todos os caracteres de um conjunto. Por "
"exemplo:"

#: ../../library/stdtypes.rst:2187
msgid ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"
msgstr ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"

#: ../../library/stdtypes.rst:2196
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Este método estático retorna uma tabela de tradução utilizável para :meth:"
"`str.translate`."

#: ../../library/stdtypes.rst:2198
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Se houver apenas um argumento, deve ser um dicionário que mapeia ordinais "
"Unicode (inteiros) ou caracteres (*strings* de comprimento 1) para ordinais "
"Unicode, *strings* (de comprimentos arbitrários) ou ``None``. As chaves de "
"caractere serão então convertidas para ordinais."

#: ../../library/stdtypes.rst:2203
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in *from* will be mapped to the "
"character at the same position in *to*.  If there is a third argument, it "
"must be a string, whose characters will be mapped to ``None`` in the result."
msgstr ""
"Se houver dois argumentos, devem ser *strings* de comprimento igual, e no "
"dicionário resultante, cada caractere em *from* será mapeado para o "
"caractere na mesma posição em *to*. Se houver um terceiro argumento, deve "
"ser uma *string*, cujos caracteres serão mapeados para ``None`` no resultado."

#: ../../library/stdtypes.rst:2211
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Divide a *string* na primeira ocorrência de *sep* e retorna um 3-tuplo "
"contendo a parte antes do separador, o separador em si e a parte após o "
"separador. Se o separador não for encontrado, retorna um 3-tuplo contendo a "
"própria *string*, seguida por duas *strings* vazias."

#: ../../library/stdtypes.rst:2219
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Se a *string* começar com a *string* *prefix*, retorna "
"``string[len(prefix):]``. Caso contrário, retorna uma cópia da *string* "
"original:"

#: ../../library/stdtypes.rst:2223
msgid ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"
msgstr ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"

#: ../../library/stdtypes.rst:2233
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Se a *string* terminar com a *string* *suffix* e esse *suffix* não estiver "
"vazio, retorna ``string[:-len(suffix)]``. Caso contrário, retorna uma cópia "
"da *string* original:"

#: ../../library/stdtypes.rst:2237
msgid ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"
msgstr ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"

#: ../../library/stdtypes.rst:2247
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If *count* is given, only the first *count* occurrences are "
"replaced. If *count* is not specified or ``-1``, then all occurrences are "
"replaced."
msgstr ""
"Retorna uma cópia da *string* com todas as ocorrências da substring *old* "
"substituídas por *new*. Se *count* for fornecido, apenas as primeiras "
"*count* ocorrências são substituídas. Se *count* não for especificado ou for "
"``-1``, então todas as ocorrências são substituídas."

#: ../../library/stdtypes.rst:2251
msgid "*count* is now supported as a keyword argument."
msgstr "*count* é agora suportado como um argumento de palavra-chave."

#: ../../library/stdtypes.rst:2257
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Retorna o índice mais alto na *string* onde a substring *sub* é encontrada, "
"de modo que *sub* esteja contida em ``s[start:end]``. Os argumentos "
"opcionais *start* e *end* são interpretados como na notação de fatia. "
"Retorna ``-1`` em caso de falha."

#: ../../library/stdtypes.rst:2264
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Semelhante a :meth:`rfind`, mas lança :exc:`ValueError` quando a substring "
"*sub* não for encontrada."

#: ../../library/stdtypes.rst:2270
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Retorna a *string* alinhada à direita numa *string* de comprimento *width*. "
"O preenchimento é feito usando o *fillchar* especificado (o valor "
"predefinido é um espaço ASCII). A *string* original é retornada se *width* "
"for menor ou igual a ``len(s)``."

#: ../../library/stdtypes.rst:2277
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Divide a *string* na última ocorrência de *sep* e retorna um 3-tuplo "
"contendo a parte antes do separador, o separador em si e a parte após o "
"separador. Se o separador não for encontrado, retorna um 3-tuplo contendo "
"duas *strings* vazias, seguido da própria *string*."

#: ../../library/stdtypes.rst:2285
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Retorna uma lista das palavras na *string*, usando *sep* como a *string* de "
"delimitador. Se *maxsplit* for fornecido, no máximo *maxsplit* divisões são "
"feitas, as mais à *direita*. Se *sep* não for especificado ou for ``None``, "
"qualquer *string* de espaço em branco é um separador. Exceto pela divisão a "
"partir da direita, :meth:`rsplit` comporta-se como :meth:`split`, que é "
"descrita em detalhe abaixo."

#: ../../library/stdtypes.rst:2294
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Retorna uma cópia da *string* com os caracteres finais removidos. O "
"argumento *chars* é uma *string* que especifica o conjunto de caracteres a "
"serem removidos. Se for omitido ou ``None``, o argumento *chars* remove "
"espaços em branco por predefinição. O argumento *chars* não é um sufixo; em "
"vez disso, todas as combinações dos seus valores são removidas:"

#: ../../library/stdtypes.rst:2299
msgid ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"
msgstr ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"

#: ../../library/stdtypes.rst:2304
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Consulte :meth:`str.removesuffix` para um método que remove uma única "
"*string* de sufixo em vez de todos os caracteres de um conjunto. Por exemplo:"

#: ../../library/stdtypes.rst:2307
msgid ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"
msgstr ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"

#: ../../library/stdtypes.rst:2314
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Retorna uma lista das palavras na *string*, usando *sep* como a *string* de "
"delimitador. Se *maxsplit* for fornecido, no máximo *maxsplit* divisões são "
"feitas (assim, a lista terá no máximo ``maxsplit+1`` elementos). Se "
"*maxsplit* não for especificado ou for ``-1``, não há limite no número de "
"divisões (todas as divisões possíveis são feitas)."

#: ../../library/stdtypes.rst:2320
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"as a single delimiter (to split with multiple delimiters, use :func:`re."
"split`). Splitting an empty string with a specified separator returns "
"``['']``."
msgstr ""
"Se *sep* for fornecido, delimitadores consecutivos não são agrupados e são "
"considerados como delimitadores de *strings* vazias (por exemplo, ``'1,,2'."
"split(',')`` retorna ``['1', '', '2']``). O argumento *sep* pode consistir "
"em vários caracteres como um único delimitador (para dividir com múltiplos "
"delimitadores, use :func:`re.split`). Dividir uma *string* vazia com um "
"separador especificado retorna ``['']``."

#: ../../library/stdtypes.rst:2327 ../../library/stdtypes.rst:2345
#: ../../library/stdtypes.rst:2357 ../../library/stdtypes.rst:2411
#: ../../library/stdtypes.rst:2479 ../../library/stdtypes.rst:2549
#: ../../library/stdtypes.rst:3543 ../../library/stdtypes.rst:3561
#: ../../library/stdtypes.rst:3651 ../../library/stdtypes.rst:3667
#: ../../library/stdtypes.rst:3692 ../../library/stdtypes.rst:3706
#: ../../library/stdtypes.rst:3734 ../../library/stdtypes.rst:3748
#: ../../library/stdtypes.rst:3766 ../../library/stdtypes.rst:3793
#: ../../library/stdtypes.rst:3816 ../../library/stdtypes.rst:3843
#: ../../library/stdtypes.rst:3885 ../../library/stdtypes.rst:3909
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/stdtypes.rst:2329
msgid ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"
msgstr ""

#: ../../library/stdtypes.rst:2338
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Se *sep* não for especificado ou for ``None``, um algoritmo de divisão "
"diferente é aplicado: sequências consecutivas de espaços em branco são "
"consideradas como um único separador, e o resultado não conterá *strings* "
"vazias no início ou no fim se a *string* tiver espaços em branco iniciais ou "
"finais. Consequentemente, dividir uma *string* vazia ou uma *string* "
"composta apenas por espaços em branco com um separador ``None`` retorna "
"``[]``."

#: ../../library/stdtypes.rst:2347
msgid ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"
msgstr ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"

#: ../../library/stdtypes.rst:2354
msgid ""
"If *sep* is not specified or is ``None`` and  *maxsplit* is ``0``, only "
"leading runs of consecutive whitespace are considered."
msgstr ""
"Se *sep* não for especificado ou for ``None`` e *maxsplit* for ``0``, apenas "
"sequências iniciais de espaços em branco consecutivos são consideradas."

#: ../../library/stdtypes.rst:2359
msgid ""
">>> \"\".split(None, 0)\n"
"[]\n"
">>> \"   \".split(None, 0)\n"
"[]\n"
">>> \"   foo   \".split(maxsplit=0)\n"
"['foo   ']"
msgstr ""
">>> \"\".split(None, 0)\n"
"[]\n"
">>> \"   \".split(None, 0)\n"
"[]\n"
">>> \"   foo   \".split(maxsplit=0)\n"
"['foo   ']"

#: ../../library/stdtypes.rst:2366
msgid "See also :meth:`join`."
msgstr ""

#: ../../library/stdtypes.rst:2374
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Retorna uma lista das linhas na *string*, quebrando nos limites de linha. As "
"quebras de linha não são incluídas na lista resultante, a menos que "
"*keepends* seja fornecido e verdadeiro."

#: ../../library/stdtypes.rst:2378
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Este método divide nos seguintes limites de linha. Em particular, os limites "
"são um superconjunto de :term:`novas linhas universais`."

#: ../../library/stdtypes.rst:2382
msgid "Representation"
msgstr "Representação"

#: ../../library/stdtypes.rst:2382
msgid "Description"
msgstr "Descrição"

#: ../../library/stdtypes.rst:2384
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:2384
msgid "Line Feed"
msgstr "Alimentação de linha"

#: ../../library/stdtypes.rst:2386
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:2386
msgid "Carriage Return"
msgstr "Retorno de carro"

#: ../../library/stdtypes.rst:2388
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:2388
msgid "Carriage Return + Line Feed"
msgstr "Retorno de carro + Alimentação de linha"

#: ../../library/stdtypes.rst:2390
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` ou ``\\x0b``"

#: ../../library/stdtypes.rst:2390
msgid "Line Tabulation"
msgstr "Tabulação de linha"

#: ../../library/stdtypes.rst:2392
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` ou ``\\x0c``"

#: ../../library/stdtypes.rst:2392
msgid "Form Feed"
msgstr "Alimentação de formulário"

#: ../../library/stdtypes.rst:2394
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:2394
msgid "File Separator"
msgstr "Separador de ficheiro"

#: ../../library/stdtypes.rst:2396
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:2396
msgid "Group Separator"
msgstr "Separador de grupo"

#: ../../library/stdtypes.rst:2398
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:2398
msgid "Record Separator"
msgstr "Separador de registo"

#: ../../library/stdtypes.rst:2400
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:2400
msgid "Next Line (C1 Control Code)"
msgstr "Próxima linha (Código de controlo C1)"

#: ../../library/stdtypes.rst:2402
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:2402
msgid "Line Separator"
msgstr "Separador de linha"

#: ../../library/stdtypes.rst:2404
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:2404
msgid "Paragraph Separator"
msgstr "Separador de parágrafo"

#: ../../library/stdtypes.rst:2409
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` e ``\\f`` adicionados à lista de limites de linha."

#: ../../library/stdtypes.rst:2413
msgid ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"
msgstr ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"

#: ../../library/stdtypes.rst:2418
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Ao contrário de :meth:`~str.split` quando uma *string* delimitadora *sep* é "
"fornecida, este método retorna uma lista vazia para a *string* vazia, e uma "
"quebra de linha terminal não resulta numa linha extra:"

#: ../../library/stdtypes.rst:2422
msgid ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"
msgstr ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"

#: ../../library/stdtypes.rst:2427
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Para comparação, ``split('\\n')`` dá:"

#: ../../library/stdtypes.rst:2429
msgid ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"
msgstr ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"

#: ../../library/stdtypes.rst:2437
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Retorna ``True`` se a *string* começar com o *prefix*, caso contrário "
"retorna ``False``. *prefix* também pode ser um tuplo de prefixos a procurar. "
"Com *start* opcional, testa a *string* a partir dessa posição. Com *end* "
"opcional, para de comparar a *string* nessa posição."

#: ../../library/stdtypes.rst:2445
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Retorna uma cópia da *string* com os caracteres iniciais e finais removidos. "
"O argumento *chars* é uma *string* que especifica o conjunto de caracteres a "
"serem removidos. Se for omitido ou ``None``, o argumento *chars* remove "
"espaços em branco por predefinição. O argumento *chars* não é um prefixo ou "
"sufixo; em vez disso, todas as combinações dos seus valores são removidas:"

#: ../../library/stdtypes.rst:2451
msgid ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"
msgstr ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"

#: ../../library/stdtypes.rst:2456
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Os valores mais externos de *chars* nos extremos inicial e final são "
"removidos da *string*. Os caracteres são removidos do início até encontrar "
"um caractere da *string* que não esteja contido no conjunto de caracteres em "
"*chars*. Uma ação semelhante ocorre no extremo final. Por exemplo:"

#: ../../library/stdtypes.rst:2462
msgid ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"
msgstr ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"

#: ../../library/stdtypes.rst:2469
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Retorna uma cópia da *string* com caracteres maiúsculos convertidos para "
"minúsculos e vice-versa. Note que não é necessariamente verdade que ``s."
"swapcase().swapcase() == s``."

#: ../../library/stdtypes.rst:2476
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Retorna uma versão da *string* em que as palavras começam com um caractere "
"maiúsculo e os restantes caracteres são minúsculos."

#: ../../library/stdtypes.rst:2481
msgid ""
">>> 'Hello world'.title()\n"
"'Hello World'"
msgstr ""
">>> 'Hello world'.title()\n"
"'Hello World'"

#: ../../library/stdtypes.rst:2484 ../../library/stdtypes.rst:3853
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"O algoritmo usa uma definição simples e independente de linguagem de uma "
"palavra como grupos de letras consecutivas. A definição funciona em muitos "
"contextos, mas significa que apóstrofos em contrações e possessivos formam "
"limites de palavras, o que pode não ser o resultado desejado:"

#: ../../library/stdtypes.rst:2489
msgid ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""

#: ../../library/stdtypes.rst:2492
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"A função :func:`string.capwords` não tem este problema, pois divide as "
"palavras apenas por espaços."

#: ../../library/stdtypes.rst:2495
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Alternativamente, uma solução alternativa para apóstrofos pode ser "
"construída usando expressões regulares:"

#: ../../library/stdtypes.rst:2498
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""

#: ../../library/stdtypes.rst:2507
msgid "See also :meth:`istitle`."
msgstr "Consulte também :meth:`istitle`."

#: ../../library/stdtypes.rst:2512
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or :"
"term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Retorna uma cópia da *string* em que cada caractere foi mapeado através da "
"tabela de tradução fornecida. A tabela deve ser um objeto que implemente a "
"indexação via :meth:`~object.__getitem__`, tipicamente um :term:`mapeamento` "
"ou :term:`sequência`. Quando indexado por um ordinal Unicode (um inteiro), o "
"objeto tabela pode fazer uma das seguintes ações: retornar um ordinal "
"Unicode ou uma *string*, para mapear o caractere para um ou mais outros "
"caracteres; retornar ``None``, para remover o caractere da *string* de "
"retorno; ou lançar uma exceção :exc:`LookupError`, para mapear o caractere "
"para si mesmo."

#: ../../library/stdtypes.rst:2521
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Pode usar :meth:`str.maketrans` para criar um mapa de tradução a partir de "
"mapeamentos de caractere para caractere em diferentes formatos."

#: ../../library/stdtypes.rst:2524
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Consulte também o módulo :mod:`codecs` para uma abordagem mais flexível a "
"mapeamentos de caracteres personalizados."

#: ../../library/stdtypes.rst:2530
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Retorna uma cópia da *string* com todos os caracteres com caixa [4]_ "
"convertidos para maiúsculas. Note que ``s.upper().isupper()`` pode ser "
"``False`` se ``s`` contiver caracteres sem caixa ou se a categoria Unicode "
"dos caracteres resultantes não for \"Lu\" (Letra, maiúscula), mas por "
"exemplo \"Lt\" (Letra, título)."

#: ../../library/stdtypes.rst:2536
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode15.1.0/ch03.pdf>`__."
msgstr ""

#: ../../library/stdtypes.rst:2543
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Retorna uma cópia da *string* preenchida à esquerda com dígitos ASCII "
"``'0'`` para criar uma *string* de comprimento *width*. Um prefixo de sinal "
"inicial (``'+'``/``'-'``) é tratado inserindo o preenchimento *depois* do "
"caractere de sinal em vez de antes. A *string* original é retornada se "
"*width* for menor ou igual a ``len(s)``."

#: ../../library/stdtypes.rst:2551
msgid ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"
msgstr ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"

#: ../../library/stdtypes.rst:2572
msgid "Formatted String Literals (f-strings)"
msgstr "Literais de *string* formatadas (f-strings)"

#: ../../library/stdtypes.rst:2575
msgid ""
"The :keyword:`await` and :keyword:`async for` can be used in expressions "
"within f-strings."
msgstr ""
"Os operadores :keyword:`await` e :keyword:`async for` podem ser usados em "
"expressões dentro de f-strings."

#: ../../library/stdtypes.rst:2578
msgid "Added the debugging operator (``=``)"
msgstr "Adicionado o operador de depuração (``=``)"

#: ../../library/stdtypes.rst:2580
msgid ""
"Many restrictions on expressions within f-strings have been removed. "
"Notably, nested strings, comments, and backslashes are now permitted."
msgstr ""
"Muitas restrições em expressões dentro de f-strings foram removidas. "
"Notavelmente, *strings* aninhadas, comentários e barras invertidas são agora "
"permitidos."

#: ../../library/stdtypes.rst:2584
msgid ""
"An :dfn:`f-string` (formally a :dfn:`formatted string literal`) is a string "
"literal that is prefixed with ``f`` or ``F``. This type of string literal "
"allows embedding arbitrary Python expressions within *replacement fields*, "
"which are delimited by curly brackets (``{}``). These expressions are "
"evaluated at runtime, similarly to :meth:`str.format`, and are converted "
"into regular :class:`str` objects. For example:"
msgstr ""
"Uma :dfn:`f-string` (formalmente um :dfn:`literal de *string* formatada`) é "
"um literal de *string* que é prefixado com ``f`` ou ``F``. Este tipo de "
"literal de *string* permite incorporar expressões Python arbitrárias dentro "
"de *campos de substituição*, que são delimitados por chavetas (``{}``). "
"Estas expressões são avaliadas em tempo de execução, de forma semelhante a :"
"meth:`str.format`, e são convertidas em objetos :class:`str` regulares. Por "
"exemplo:"

#: ../../library/stdtypes.rst:2592
msgid ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"
msgstr ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"

#: ../../library/stdtypes.rst:2599
msgid "It is also possible to use a multi line f-string:"
msgstr "Também é possível usar uma f-string de várias linhas:"

#: ../../library/stdtypes.rst:2601
msgid ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"
msgstr ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"

#: ../../library/stdtypes.rst:2607
msgid ""
"A single opening curly bracket, ``'{'``, marks a *replacement field* that "
"can contain any Python expression:"
msgstr ""
"Uma única chaveta de abertura, ``'{'``, marca um *campo de substituição* que "
"pode conter qualquer expressão Python:"

#: ../../library/stdtypes.rst:2610
msgid ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"
msgstr ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"

#: ../../library/stdtypes.rst:2616
msgid "To include a literal ``{`` or ``}``, use a double bracket:"
msgstr "Para incluir uma chaveta literal ``{`` ou ``}``, use chavetas duplas:"

#: ../../library/stdtypes.rst:2618
msgid ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"
msgstr ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"

#: ../../library/stdtypes.rst:2624
msgid ""
"Functions can also be used, and :ref:`format specifiers <formatstrings>`:"
msgstr ""
"Funções também podem ser usadas, e :ref:`especificadores de formato "
"<formatstrings>`:"

#: ../../library/stdtypes.rst:2626
msgid ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"
msgstr ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"

#: ../../library/stdtypes.rst:2632
msgid "Any non-string expression is converted using :func:`str`, by default:"
msgstr ""
"Qualquer expressão não-*string* é convertida usando :func:`str`, por "
"predefinição:"

#: ../../library/stdtypes.rst:2634
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"

#: ../../library/stdtypes.rst:2640
msgid ""
"To use an explicit conversion, use the ``!`` (exclamation mark) operator, "
"followed by any of the valid formats, which are:"
msgstr ""
"Para usar uma conversão explícita, use o operador ``!`` (ponto de "
"exclamação), seguido por qualquer um dos formatos válidos, que são:"

#: ../../library/stdtypes.rst:2644 ../../library/stdtypes.rst:2812
#: ../../library/stdtypes.rst:4032
msgid "Conversion"
msgstr "Conversão"

#: ../../library/stdtypes.rst:2646
msgid "``!a``"
msgstr "``!a``"

#: ../../library/stdtypes.rst:2646
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/stdtypes.rst:2647
msgid "``!r``"
msgstr "``!r``"

#: ../../library/stdtypes.rst:2647
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/stdtypes.rst:2648
msgid "``!s``"
msgstr "``!s``"

#: ../../library/stdtypes.rst:2648
msgid ":func:`str`"
msgstr ":func:`str`"

#: ../../library/stdtypes.rst:2653
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"

#: ../../library/stdtypes.rst:2664
msgid ""
"While debugging it may be helpful to see both the expression and its value, "
"by using the equals sign (``=``) after the expression. This preserves spaces "
"within the brackets, and can be used with a converter. By default, the "
"debugging operator uses the :func:`repr` (``!r``) conversion. For example:"
msgstr ""
"Durante a depuração, pode ser útil ver tanto a expressão como o seu valor, "
"usando o sinal de igual (``=``) após a expressão. Isto preserva os espaços "
"dentro das chavetas e pode ser usado com um conversor. Por predefinição, o "
"operador de depuração usa a conversão :func:`repr` (``!r``). Por exemplo:"

#: ../../library/stdtypes.rst:2670
msgid ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"
msgstr ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"

#: ../../library/stdtypes.rst:2681
msgid ""
"Once the output has been evaluated, it can be formatted using a :ref:`format "
"specifier <formatstrings>` following a colon (``':'``). After the expression "
"has been evaluated, and possibly converted to a string, the :meth:`!"
"__format__` method of the result is called with the format specifier, or the "
"empty string if no format specifier is given. The formatted result is then "
"used as the final value for the replacement field. For example:"
msgstr ""
"Depois de a saída ter sido avaliada, pode ser formatada usando um :ref:"
"`format specifier  <formatstrings>` após um dois pontos (``':'``). Depois de "
"a expressão ter sido avaliada, e possivelmente convertida para uma *string*, "
"o método :meth:`!__format__` do resultado é chamado com o especificador de "
"formato, ou a *string* vazia se nenhum especificador de formato for "
"fornecido. O resultado formatado é então usado como o valor final para o "
"campo de substituição. Por exemplo:"

#: ../../library/stdtypes.rst:2689
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"

#: ../../library/stdtypes.rst:2701
msgid "``printf``-style String Formatting"
msgstr "Formatação de *string* no estilo ``printf``"

#: ../../library/stdtypes.rst:2714
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""

#: ../../library/stdtypes.rst:2722
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"function in the C language. For example:"
msgstr ""
"Os objetos *string* têm uma operação incorporada única: o operador ``%`` "
"(módulo). Isto também é conhecido como o operador de *formatação* ou "
"*interpolação* de *string*. Dado ``format % values`` (onde *format* é uma "
"*string*), as especificações de conversão ``%`` em *format* são substituídas "
"por zero ou mais elementos de *values*. O efeito é semelhante ao uso da "
"função :c:func:`sprintf` na linguagem C. Por exemplo:"

#: ../../library/stdtypes.rst:2729
msgid ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."
msgstr ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."

#: ../../library/stdtypes.rst:2734
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *format* requer um único argumento, *values* pode ser um objeto não-"
"tuplo. [5]_ Caso contrário, *values* deve ser um tuplo com exatamente o "
"número de itens especificado pela *string* de formato, ou um único objeto de "
"mapeamento (por exemplo, um dicionário)."

#: ../../library/stdtypes.rst:2744 ../../library/stdtypes.rst:3964
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Um especificador de conversão contém dois ou mais caracteres e tem os "
"seguintes componentes, que devem ocorrer nesta ordem:"

#: ../../library/stdtypes.rst:2747 ../../library/stdtypes.rst:3967
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "O caractere ``'%'``, que marca o início do especificador."

#: ../../library/stdtypes.rst:2749 ../../library/stdtypes.rst:3969
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Chave de mapeamento (opcional), consistindo numa sequência de caracteres "
"entre parênteses (por exemplo, ``(somename)``)."

#: ../../library/stdtypes.rst:2752 ../../library/stdtypes.rst:3972
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Flags de conversão (opcionais), que afetam o resultado de alguns tipos de "
"conversão."

#: ../../library/stdtypes.rst:2755 ../../library/stdtypes.rst:3975
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Largura mínima do campo (opcional). Se especificado como ``'*'`` "
"(asterisco), a largura real é lida do próximo elemento do tuplo em *values*, "
"e o objeto a converter vem depois da largura mínima do campo e da precisão "
"opcional."

#: ../../library/stdtypes.rst:2759 ../../library/stdtypes.rst:3979
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Precisão (opcional), dada como um ``'.'`` (ponto) seguido da precisão. Se "
"especificado como ``'*'`` (um asterisco), a precisão real é lida do próximo "
"elemento do tuplo em *values*, e o valor a converter vem depois da precisão."

#: ../../library/stdtypes.rst:2764 ../../library/stdtypes.rst:3984
msgid "Length modifier (optional)."
msgstr "Modificador de comprimento (opcional)."

#: ../../library/stdtypes.rst:2766 ../../library/stdtypes.rst:3986
msgid "Conversion type."
msgstr "Tipo de conversão."

#: ../../library/stdtypes.rst:2768
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando o argumento da direita é um dicionário (ou outro tipo de mapeamento), "
"então os formatos na *string* *devem* incluir uma chave de mapeamento entre "
"parênteses para esse dicionário inserida imediatamente após o caractere "
"``'%'``. A chave de mapeamento seleciona o valor a ser formatado a partir do "
"mapeamento. Por exemplo:"

#: ../../library/stdtypes.rst:2777 ../../library/stdtypes.rst:3997
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"Neste caso, não podem ocorrer especificadores ``*`` num formato (uma vez que "
"requerem uma lista de parâmetros sequencial)."

#: ../../library/stdtypes.rst:2780 ../../library/stdtypes.rst:4000
msgid "The conversion flag characters are:"
msgstr "Os caracteres de flag de conversão são:"

#: ../../library/stdtypes.rst:2789 ../../library/stdtypes.rst:4009
msgid "Flag"
msgstr "Flag"

#: ../../library/stdtypes.rst:2791 ../../library/stdtypes.rst:4011
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:2791 ../../library/stdtypes.rst:4011
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"A conversão de valor usará a \"forma alternativa\" (onde definida abaixo)."

#: ../../library/stdtypes.rst:2794 ../../library/stdtypes.rst:4014
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:2794 ../../library/stdtypes.rst:4014
msgid "The conversion will be zero padded for numeric values."
msgstr "A conversão será preenchida com zeros para valores numéricos."

#: ../../library/stdtypes.rst:2796 ../../library/stdtypes.rst:4016
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:2796 ../../library/stdtypes.rst:4016
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"O valor convertido é alinhado à esquerda (substitui a conversão ``'0'`` se "
"ambos forem fornecidos)."

#: ../../library/stdtypes.rst:2799 ../../library/stdtypes.rst:4019
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:2799 ../../library/stdtypes.rst:4019
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(um espaço) Um espaço em branco deve ser deixado antes de um número positivo "
"(ou *string* vazia) produzido por uma conversão com sinal."

#: ../../library/stdtypes.rst:2802 ../../library/stdtypes.rst:4022
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:2802 ../../library/stdtypes.rst:4022
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Um caractere de sinal (``'+'`` ou ``'-'``) precederá a conversão (substitui "
"uma flag de \"espaço\")."

#: ../../library/stdtypes.rst:2806 ../../library/stdtypes.rst:4026
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Um modificador de comprimento (``h``, ``l`` ou ``L``) pode estar presente, "
"mas é ignorado, uma vez que não é necessário para Python -- por exemplo, "
"``%ld`` é idêntico a ``%d``."

#: ../../library/stdtypes.rst:2809 ../../library/stdtypes.rst:4029
msgid "The conversion types are:"
msgstr "Os tipos de conversão são:"

#: ../../library/stdtypes.rst:2814 ../../library/stdtypes.rst:4034
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:2814 ../../library/stdtypes.rst:2816
#: ../../library/stdtypes.rst:4034 ../../library/stdtypes.rst:4036
msgid "Signed integer decimal."
msgstr "Decimal inteiro com sinal."

#: ../../library/stdtypes.rst:2816 ../../library/stdtypes.rst:4036
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:2818 ../../library/stdtypes.rst:4038
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:2818 ../../library/stdtypes.rst:4038
msgid "Signed octal value."
msgstr "Valor octal com sinal."

#: ../../library/stdtypes.rst:2820 ../../library/stdtypes.rst:4040
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:2820 ../../library/stdtypes.rst:4040
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Tipo obsoleto -- é idêntico a ``'d'``."

#: ../../library/stdtypes.rst:2822 ../../library/stdtypes.rst:4042
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:2822 ../../library/stdtypes.rst:4042
msgid "Signed hexadecimal (lowercase)."
msgstr "Hexadecimal com sinal (minúsculas)."

#: ../../library/stdtypes.rst:2824 ../../library/stdtypes.rst:4044
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:2824 ../../library/stdtypes.rst:4044
msgid "Signed hexadecimal (uppercase)."
msgstr "Hexadecimal com sinal (maiúsculas)."

#: ../../library/stdtypes.rst:2826 ../../library/stdtypes.rst:4046
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:2826 ../../library/stdtypes.rst:4046
msgid "Floating-point exponential format (lowercase)."
msgstr "Formato exponencial de ponto flutuante (minúsculas)."

#: ../../library/stdtypes.rst:2828 ../../library/stdtypes.rst:4048
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:2828 ../../library/stdtypes.rst:4048
msgid "Floating-point exponential format (uppercase)."
msgstr "Formato exponencial de ponto flutuante (maiúsculas)."

#: ../../library/stdtypes.rst:2830 ../../library/stdtypes.rst:4050
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:2830 ../../library/stdtypes.rst:2832
#: ../../library/stdtypes.rst:4050 ../../library/stdtypes.rst:4052
msgid "Floating-point decimal format."
msgstr "Formato decimal de ponto flutuante."

#: ../../library/stdtypes.rst:2832 ../../library/stdtypes.rst:4052
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:2834 ../../library/stdtypes.rst:4054
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:2834 ../../library/stdtypes.rst:4054
msgid ""
"Floating-point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato de ponto flutuante. Usa formato exponencial minúsculo se o expoente "
"for menor que -4 ou não for menor que a precisão, formato decimal caso "
"contrário."

#: ../../library/stdtypes.rst:2838 ../../library/stdtypes.rst:4058
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:2838 ../../library/stdtypes.rst:4058
msgid ""
"Floating-point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato de ponto flutuante. Usa formato exponencial maiúsculo se o expoente "
"for menor que -4 ou não for menor que a precisão, formato decimal caso "
"contrário."

#: ../../library/stdtypes.rst:2842 ../../library/stdtypes.rst:4062
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:2842
msgid "Single character (accepts integer or single character string)."
msgstr "Caractere único (aceita inteiro ou *string* de caractere único)."

#: ../../library/stdtypes.rst:2845 ../../library/stdtypes.rst:4075
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:2845
msgid "String (converts any Python object using :func:`repr`)."
msgstr "*String* (converte qualquer objeto Python usando :func:`repr`)."

#: ../../library/stdtypes.rst:2848 ../../library/stdtypes.rst:4069
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:2848
msgid "String (converts any Python object using :func:`str`)."
msgstr "*String* (converte qualquer objeto Python usando :func:`str`)."

#: ../../library/stdtypes.rst:2851 ../../library/stdtypes.rst:4072
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/stdtypes.rst:2851
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "*String* (converte qualquer objeto Python usando :func:`ascii`)."

#: ../../library/stdtypes.rst:2854 ../../library/stdtypes.rst:4078
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:2854 ../../library/stdtypes.rst:4078
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Nenhum argumento é convertido, resulta num caractere ``'%'`` no resultado."

#: ../../library/stdtypes.rst:2861 ../../library/stdtypes.rst:4085
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"A forma alternativa faz com que um especificador octal inicial (``'0o'``) "
"seja inserido antes do primeiro dígito."

#: ../../library/stdtypes.rst:2865 ../../library/stdtypes.rst:4089
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"A forma alternativa faz com que um ``'0x'`` ou ``'0X'`` inicial (dependendo "
"de se o formato ``'x'`` ou ``'X'`` foi usado) seja inserido antes do "
"primeiro dígito."

#: ../../library/stdtypes.rst:2869 ../../library/stdtypes.rst:4093
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"A forma alternativa faz com que o resultado contenha sempre um ponto "
"decimal, mesmo que não haja dígitos a seguir."

#: ../../library/stdtypes.rst:2872 ../../library/stdtypes.rst:4096
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"A precisão determina o número de dígitos após o ponto decimal e o valor "
"predefinido é 6."

#: ../../library/stdtypes.rst:2876 ../../library/stdtypes.rst:4100
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"A forma alternativa faz com que o resultado contenha sempre um ponto "
"decimal, e os zeros finais não são removidos como seriam de outra forma."

#: ../../library/stdtypes.rst:2879 ../../library/stdtypes.rst:4103
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"A precisão determina o número de dígitos significativos antes e depois do "
"ponto decimal e o valor predefinido é 6."

#: ../../library/stdtypes.rst:2883 ../../library/stdtypes.rst:4107
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Se a precisão for ``N``, a saída é truncada para ``N`` caracteres."

#: ../../library/stdtypes.rst:2886 ../../library/stdtypes.rst:4116
msgid "See :pep:`237`."
msgstr "Consulte :pep:`237`."

#: ../../library/stdtypes.rst:2888
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Como as *strings* Python têm um comprimento explícito, as conversões ``%s`` "
"não assumem que ``'\\0'`` é o fim da *string*."

#: ../../library/stdtypes.rst:2893
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"As conversões ``%f`` para números cujo valor absoluto é superior a 1e50 já "
"não são substituídas por conversões ``%g``."

#: ../../library/stdtypes.rst:2904
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Tipos de sequências binárias --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: ../../library/stdtypes.rst:2912
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Os tipos incorporados principais para manipular dados binários são :class:"
"`bytes` e :class:`bytearray`. Estes são suportados por :class:`memoryview`, "
"que usa o :ref:`protocolo de buffer <bufferobjects>` para aceder à memória "
"de outros objetos binários sem necessidade de fazer uma cópia."

#: ../../library/stdtypes.rst:2917
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"O módulo :mod:`array` suporta armazenamento eficiente de tipos de dados "
"básicos, como inteiros de 32 bits e valores de ponto flutuante de dupla "
"precisão IEEE754."

#: ../../library/stdtypes.rst:2923
msgid "Bytes Objects"
msgstr "Objetos bytes"

#: ../../library/stdtypes.rst:2927
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Os objetos bytes são sequências imutáveis de bytes individuais. Uma vez que "
"muitos protocolos binários principais são baseados na codificação de texto "
"ASCII, os objetos bytes oferecem vários métodos que são válidos apenas ao "
"trabalhar com dados compatíveis com ASCII e estão intimamente relacionados "
"com objetos *string* de várias outras formas."

#: ../../library/stdtypes.rst:2935
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"Primeiramente, a sintaxe para literais bytes é em grande parte a mesma que "
"para literais *string*, exceto que é adicionado um prefixo ``b``:"

#: ../../library/stdtypes.rst:2938
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Aspas simples: ``b'still allows embedded \"double\" quotes'``"

#: ../../library/stdtypes.rst:2939
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "Aspas duplas: ``b\"still allows embedded 'single' quotes\"``"

#: ../../library/stdtypes.rst:2940
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Aspas triplas: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"

#: ../../library/stdtypes.rst:2942
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Apenas caracteres ASCII são permitidos em literais bytes (independentemente "
"da codificação declarada do código-fonte). Quaisquer valores binários acima "
"de 127 devem ser inseridos em literais bytes usando a sequência de escape "
"apropriada."

#: ../../library/stdtypes.rst:2946
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Tal como com literais *string*, literais bytes também podem usar um prefixo "
"``r`` para desativar o processamento de sequências de escape. Consulte :ref:"
"`strings` para mais informações sobre as várias formas de literais bytes, "
"incluindo sequências de escape suportadas."

#: ../../library/stdtypes.rst:2950
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Embora literais e representações bytes sejam baseadas em texto ASCII, os "
"objetos bytes comportam-se na verdade como sequências imutáveis de inteiros, "
"com cada valor na sequência restrito de modo que ``0 <= x < 256`` "
"(tentativas de violar esta restrição irão desencadear :exc:`ValueError`). "
"Isto é feito deliberadamente para enfatizar que, embora muitos formatos "
"binários incluam elementos baseados em ASCII e possam ser manipulados de "
"forma útil com alguns algoritmos orientados a texto, este não é geralmente o "
"caso para dados binários arbitrários (aplicar cegamente algoritmos de "
"processamento de texto a formatos de dados binários que não são compatíveis "
"com ASCII geralmente levará à corrupção de dados)."

#: ../../library/stdtypes.rst:2960
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Além das formas literais, os objetos bytes podem ser criados de várias "
"outras formas:"

#: ../../library/stdtypes.rst:2963
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""
"Um objeto bytes preenchido com zeros de um comprimento especificado: "
"``bytes(10)``"

#: ../../library/stdtypes.rst:2964
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "A partir de um iterável de inteiros: ``bytes(range(20))``"

#: ../../library/stdtypes.rst:2965
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Copiando dados binários existentes através do protocolo de buffer: "
"``bytes(obj)``"

#: ../../library/stdtypes.rst:2967
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Consulte também a função incorporada :ref:`bytes <func-bytes>`...."

#: ../../library/stdtypes.rst:2969
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Uma vez que 2 dígitos hexadecimais correspondem precisamente a um único "
"byte, números hexadecimais são um formato comumente usado para descrever "
"dados binários. Consequentemente, o tipo bytes tem um método de classe "
"adicional para ler dados nesse formato:"

#: ../../library/stdtypes.rst:2975
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Este método de classe :class:`bytes` retorna um objeto bytes, decodificando "
"o objeto *string* fornecido. A *string* deve conter dois dígitos "
"hexadecimais por byte, com espaços em branco ASCII sendo ignorados."

#: ../../library/stdtypes.rst:2982
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` agora ignora todos os espaços em branco ASCII na "
"*string*, não apenas espaços."

#: ../../library/stdtypes.rst:2986
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Existe uma função de conversão inversa para transformar um objeto bytes na "
"sua representação hexadecimal."

#: ../../library/stdtypes.rst:2992 ../../library/stdtypes.rst:3079
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Retorna um objeto *string* contendo dois dígitos hexadecimais para cada byte "
"na instância."

#: ../../library/stdtypes.rst:2998
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"Se quiser tornar a *string* hexadecimal mais fácil de ler, pode especificar "
"um parâmetro de separador de caractere único *sep* para incluir na saída. "
"Por predefinição, este separador será incluído entre cada byte. Um segundo "
"parâmetro opcional *bytes_per_sep* controla o espaçamento. Valores positivos "
"calculam a posição do separador a partir da direita, valores negativos a "
"partir da esquerda."

#: ../../library/stdtypes.rst:3015
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` agora suporta parâmetros opcionais *sep* e *bytes_per_sep* "
"para inserir separadores entre bytes na saída hexadecimal."

#: ../../library/stdtypes.rst:3019
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Uma vez que os objetos bytes são sequências de inteiros (semelhantes a um "
"tuplo), para um objeto bytes *b*, ``b[0]`` será um inteiro, enquanto "
"``b[0:1]`` será um objeto bytes de comprimento 1. (Isto contrasta com "
"*strings* de texto, onde tanto a indexação como a fatiação produzirão uma "
"*string* de comprimento 1)"

#: ../../library/stdtypes.rst:3024
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"A representação de objetos bytes usa o formato literal (``b'...'``), uma vez "
"que é frequentemente mais útil do que, por exemplo, ``bytes([46, 46, 46])``. "
"Pode sempre converter um objeto bytes numa lista de inteiros usando "
"``list(b)``."

#: ../../library/stdtypes.rst:3032
msgid "Bytearray Objects"
msgstr "Objetos bytearray"

#: ../../library/stdtypes.rst:3036
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Os objetos :class:`bytearray` são uma contraparte mutável dos objetos :class:"
"`bytes`."

#: ../../library/stdtypes.rst:3042
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Não existe uma sintaxe literal dedicada para objetos bytearray; em vez "
"disso, estes são sempre criados chamando o construtor:"

#: ../../library/stdtypes.rst:3045
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Criar uma instância vazia: ``bytearray()``"

#: ../../library/stdtypes.rst:3046
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""
"Criar uma instância preenchida com zeros de um comprimento dado: "
"``bytearray(10)``"

#: ../../library/stdtypes.rst:3047
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "A partir de um iterável de inteiros: ``bytearray(range(20))``"

#: ../../library/stdtypes.rst:3048
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Copiar dados binários existentes através do protocolo de buffer: "
"``bytearray(b'Hi!')``"

#: ../../library/stdtypes.rst:3050
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Como os objetos bytearray são mutáveis, suportam as operações de sequência :"
"ref:`mutável <typesseq-mutable>` além das operações comuns de bytes e "
"bytearray descritas em :ref:`bytes-methods`."

#: ../../library/stdtypes.rst:3054
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""
"Consulte também a função incorporada :ref:`bytearray <func-bytearray>`."

#: ../../library/stdtypes.rst:3056
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Uma vez que 2 dígitos hexadecimais correspondem precisamente a um único "
"byte, números hexadecimais são um formato comumente usado para descrever "
"dados binários. Consequentemente, o tipo bytearray tem um método de classe "
"adicional para ler dados nesse formato:"

#: ../../library/stdtypes.rst:3062
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Este método de classe :class:`bytearray` retorna um objeto bytearray, "
"decodificando o objeto *string* fornecido. A *string* deve conter dois "
"dígitos hexadecimais por byte, com espaços em branco ASCII sendo ignorados."

#: ../../library/stdtypes.rst:3069
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
":meth:`bytearray.fromhex` agora ignora todos os espaços em branco ASCII na "
"*string*, não apenas espaços."

#: ../../library/stdtypes.rst:3073
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Existe uma função de conversão inversa para transformar um objeto bytearray "
"na sua representação hexadecimal."

#: ../../library/stdtypes.rst:3087
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Semelhante a :meth:`bytes.hex`, :meth:`bytearray.hex` agora suporta "
"parâmetros opcionais *sep* e *bytes_per_sep* para inserir separadores entre "
"bytes na saída hexadecimal."

#: ../../library/stdtypes.rst:3092
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Uma vez que os objetos bytearray são sequências de inteiros (semelhantes a "
"uma lista), para um objeto bytearray *b*, ``b[0]`` será um inteiro, enquanto "
"``b[0:1]`` será um objeto bytearray de comprimento 1. (Isto contrasta com "
"*strings* de texto, onde tanto a indexação como a fatiação produzirão uma "
"*string* de comprimento 1)"

#: ../../library/stdtypes.rst:3097
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"A representação de objetos bytearray usa o formato literal de bytes "
"(``bytearray(b'...')``), uma vez que é frequentemente mais útil do que, por "
"exemplo, ``bytearray([46, 46, 46])``. Pode sempre converter um objeto "
"bytearray numa lista de inteiros usando ``list(b)``."

#: ../../library/stdtypes.rst:3106
msgid "Bytes and Bytearray Operations"
msgstr "Operações com bytes e bytearray"

#: ../../library/stdtypes.rst:3111
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Tanto os objetos bytes como bytearray suportam as :ref:`operações comuns "
"<typesseq-common>` de sequência. Eles interoperam não apenas com operandos "
"do mesmo tipo, mas com qualquer :term:`objeto semelhante a bytes`. Devido a "
"esta flexibilidade, podem ser misturados livremente em operações sem causar "
"erros. No entanto, o tipo de retorno do resultado pode depender da ordem dos "
"operandos."

#: ../../library/stdtypes.rst:3119
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Os métodos em objetos bytes e bytearray não aceitam *strings* como seus "
"argumentos, assim como os métodos em *strings* não aceitam bytes como seus "
"argumentos. Por exemplo, tem de escrever:"

#: ../../library/stdtypes.rst:3123
msgid ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"
msgstr ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"

#: ../../library/stdtypes.rst:3126
msgid "and::"
msgstr "e:"

#: ../../library/stdtypes.rst:3128
msgid ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"
msgstr ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"

#: ../../library/stdtypes.rst:3131
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Algumas operações com bytes e bytearray assumem o uso de formatos binários "
"compatíveis com ASCII e, portanto, devem ser evitadas ao trabalhar com dados "
"binários arbitrários. Estas restrições são abordadas abaixo."

#: ../../library/stdtypes.rst:3136
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Usar estas operações baseadas em ASCII para manipular dados binários que não "
"estejam armazenados num formato baseado em ASCII pode levar à corrupção de "
"dados."

#: ../../library/stdtypes.rst:3139
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Os seguintes métodos em objetos bytes e bytearray podem ser usados com dados "
"binários arbitrários."

#: ../../library/stdtypes.rst:3145
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Retorna o número de ocorrências não sobrepostas da subsequência *sub* no "
"intervalo [*start*, *end*]. Os argumentos opcionais *start* e *end* são "
"interpretados como na notação de fatia."

#: ../../library/stdtypes.rst:3149 ../../library/stdtypes.rst:3254
#: ../../library/stdtypes.rst:3276 ../../library/stdtypes.rst:3342
#: ../../library/stdtypes.rst:3355
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"A subsequência a procurar pode ser qualquer :term:`objeto semelhante a "
"bytes` ou um inteiro no intervalo 0 a 255."

#: ../../library/stdtypes.rst:3152
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""
"Se *sub* estiver vazia, retorna o número de fatias vazias entre caracteres, "
"que é o comprimento do objeto bytes mais um."

#: ../../library/stdtypes.rst:3155 ../../library/stdtypes.rst:3266
#: ../../library/stdtypes.rst:3279 ../../library/stdtypes.rst:3345
#: ../../library/stdtypes.rst:3358
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "Também aceita um inteiro no intervalo 0 a 255 como a subsequência."

#: ../../library/stdtypes.rst:3162
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Se os dados binários começarem com a *string* *prefix*, retorna "
"``bytes[len(prefix):]``. Caso contrário, retorna uma cópia dos dados "
"binários originais:"

#: ../../library/stdtypes.rst:3166
msgid ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"
msgstr ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"

#: ../../library/stdtypes.rst:3171
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "O *prefix* pode ser qualquer :term:`objeto semelhante a bytes`."

#: ../../library/stdtypes.rst:3175 ../../library/stdtypes.rst:3197
#: ../../library/stdtypes.rst:3330 ../../library/stdtypes.rst:3423
#: ../../library/stdtypes.rst:3437 ../../library/stdtypes.rst:3467
#: ../../library/stdtypes.rst:3481 ../../library/stdtypes.rst:3522
#: ../../library/stdtypes.rst:3592 ../../library/stdtypes.rst:3610
#: ../../library/stdtypes.rst:3638 ../../library/stdtypes.rst:3777
#: ../../library/stdtypes.rst:3832 ../../library/stdtypes.rst:3875
#: ../../library/stdtypes.rst:3896 ../../library/stdtypes.rst:3918
#: ../../library/stdtypes.rst:4120
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"A versão bytearray deste método *não* opera no local - sempre produz um novo "
"objeto, mesmo que nenhuma alteração tenha sido feita."

#: ../../library/stdtypes.rst:3184
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Se os dados binários terminarem com a *string* *suffix* e esse *suffix* não "
"estiver vazio, retorna ``bytes[:-len(suffix)]``. Caso contrário, retorna uma "
"cópia dos dados binários originais:"

#: ../../library/stdtypes.rst:3188
msgid ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"
msgstr ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"

#: ../../library/stdtypes.rst:3193
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "O *suffix* pode ser qualquer :term:`objeto semelhante a bytes`."

#: ../../library/stdtypes.rst:3206
msgid "Return the bytes decoded to a :class:`str`."
msgstr "Retorna os bytes decodificados para uma :class:`str`."

#: ../../library/stdtypes.rst:3211
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*errors* controla como os erros de decodificação são tratados. Se for "
"``'strict'`` (o valor predefinido), é lançada uma exceção :exc:"
"`UnicodeError`. Outros valores possíveis são ``'ignore'``, ``'replace'``, e "
"qualquer outro nome registado através de :func:`codecs.register_error`. "
"Consulte :ref:`error-handlers` para mais detalhes."

#: ../../library/stdtypes.rst:3217
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"Por razões de desempenho, o valor de *errors* não é verificado quanto à "
"validade a menos que ocorra um erro de decodificação, :ref:`devmode` esteja "
"ativado ou uma :ref:`compilação de depuração <debug-build>` seja usada."

#: ../../library/stdtypes.rst:3223
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"Passar o argumento *encoding* para :class:`str` permite decodificar "
"qualquer :term:`objeto semelhante a bytes` diretamente, sem necessidade de "
"criar um objeto temporário :class:`!bytes` ou :class:`!bytearray`."

#: ../../library/stdtypes.rst:3238
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Retorna ``True`` se os dados binários terminarem com o *suffix* "
"especificado, caso contrário retorna ``False``. *suffix* também pode ser um "
"tuplo de sufixos a procurar. Com *start* opcional, teste a partir dessa "
"posição. Com *end* opcional, pare de comparar nessa posição."

#: ../../library/stdtypes.rst:3243
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"O(s) sufixo(s) a procurar pode(m) ser qualquer :term:`objeto semelhante a "
"bytes`."

#: ../../library/stdtypes.rst:3249
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Retorna o índice mais baixo nos dados onde a subsequência *sub* é "
"encontrada, de modo que *sub* esteja contida na fatia ``s[start:end]``. Os "
"argumentos opcionais *start* e *end* são interpretados como na notação de "
"fatia. Retorna ``-1`` se *sub* não for encontrada."

#: ../../library/stdtypes.rst:3259
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"O método :meth:`~bytes.find` deve ser usado apenas se precisar de saber a "
"posição de *sub*. Para verificar se *sub* é uma subsequência ou não, use o "
"operador :keyword:`in`:"

#: ../../library/stdtypes.rst:3263
msgid ""
">>> b'Py' in b'Python'\n"
"True"
msgstr ""
">>> b'Py' in b'Python'\n"
"True"

#: ../../library/stdtypes.rst:3273
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Semelhante a :meth:`~bytes.find`, mas lança :exc:`ValueError` quando a "
"subsequência não for encontrada."

#: ../../library/stdtypes.rst:3286
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Retorna um objeto bytes ou bytearray que é a concatenação das sequências de "
"dados binários em *iterable*. Uma exceção :exc:`TypeError` será lançada se "
"houver valores em *iterable* que não sejam :term:`objetos semelhantes a "
"bytes <bytes-like object>`, incluindo objetos :class:`str`. O separador "
"entre elementos é o conteúdo do objeto bytes ou bytearray que fornece este "
"método."

#: ../../library/stdtypes.rst:3297
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Este método estático retorna uma tabela de tradução utilizável para :meth:"
"`bytes.translate` que mapeará cada caractere em *from* para o caractere na "
"mesma posição em *to*; *from* e *to* devem ser ambos :term:`objetos "
"semelhantes a bytes <bytes-like object>` e ter o mesmo comprimento."

#: ../../library/stdtypes.rst:3308
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Divide a sequência na primeira ocorrência de *sep* e retorna um 3-tuplo "
"contendo a parte antes do separador, o separador em si ou a sua cópia "
"bytearray, e a parte após o separador. Se o separador não for encontrado, "
"retorna um 3-tuplo contendo uma cópia da sequência original, seguida por "
"dois objetos bytes ou bytearray vazios."

#: ../../library/stdtypes.rst:3315 ../../library/stdtypes.rst:3372
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"O separador a procurar pode ser qualquer :term:`objeto semelhante a bytes`."

#: ../../library/stdtypes.rst:3321
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Retorna uma cópia da sequência com todas as ocorrências da subsequência "
"*old* substituídas por *new*. Se o argumento opcional *count* for fornecido, "
"apenas as primeiras *count* ocorrências são substituídas."

#: ../../library/stdtypes.rst:3325
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"A subsequência a procurar e a sua substituição podem ser qualquer :term:"
"`objeto semelhante a bytes`."

#: ../../library/stdtypes.rst:3337
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Retorna o índice mais alto na sequência onde a subsequência *sub* é "
"encontrada, de modo que *sub* esteja contida em ``s[start:end]``. Os "
"argumentos opcionais *start* e *end* são interpretados como na notação de "
"fatia. Retorna ``-1`` em caso de falha."

#: ../../library/stdtypes.rst:3352
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Semelhante a :meth:`~bytes.rfind`, mas lança :exc:`ValueError` quando a "
"subsequência *sub* não for encontrada."

#: ../../library/stdtypes.rst:3365
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Divide a sequência na última ocorrência de *sep* e retorna um 3-tuplo "
"contendo a parte antes do separador, o separador em si ou a sua cópia "
"bytearray, e a parte após o separador. Se o separador não for encontrado, "
"retorna um 3-tuplo contendo dois objetos bytes ou bytearray vazios, seguidos "
"por uma cópia da sequência original."

#: ../../library/stdtypes.rst:3378
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Retorna ``True`` se os dados binários começarem com o *prefix* especificado, "
"caso contrário retorna ``False``. *prefix* também pode ser um tuplo de "
"prefixos a procurar. Com *start* opcional, teste a partir dessa posição. Com "
"*end* opcional, pare de comparar nessa posição."

#: ../../library/stdtypes.rst:3383
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"O(s) prefixo(s) a procurar pode(m) ser qualquer :term:`objeto semelhante a "
"bytes`."

#: ../../library/stdtypes.rst:3389
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Retorna uma cópia do objeto bytes ou bytearray onde todos os bytes que "
"ocorrem no argumento opcional *delete* são removidos, e os bytes restantes "
"foram mapeados através da tabela de tradução fornecida, que deve ser um "
"objeto bytes de comprimento 256."

#: ../../library/stdtypes.rst:3394
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Pode usar o método :func:`bytes.maketrans` para criar uma tabela de tradução."

#: ../../library/stdtypes.rst:3397
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""

#: ../../library/stdtypes.rst:3400
msgid ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"
msgstr ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"

#: ../../library/stdtypes.rst:3403
msgid "*delete* is now supported as a keyword argument."
msgstr "*delete* é agora suportado como argumento nomeado."

#: ../../library/stdtypes.rst:3407
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Os seguintes métodos em objetos bytes e bytearray têm comportamentos "
"predefinidos que assumem o uso de formatos binários compatíveis com ASCII, "
"mas ainda podem ser usados com dados binários arbitrários, passando "
"argumentos apropriados. Note que todos os métodos bytearray nesta secção "
"*não* operam no local, e em vez disso produzem novos objetos."

#: ../../library/stdtypes.rst:3416
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Retorna uma cópia do objeto centrado numa sequência de comprimento *width*. "
"O preenchimento é feito usando o *fillbyte* especificado (o predefinido é um "
"espaço ASCII). Para objetos :class:`bytes`, a sequência original é retornada "
"se *width* for menor ou igual a ``len(s)``."

#: ../../library/stdtypes.rst:3430
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Retorna uma cópia do objeto alinhado à esquerda numa sequência de "
"comprimento *width*. O preenchimento é feito usando o *fillbyte* "
"especificado (o predefinido é um espaço ASCII). Para objetos :class:`bytes`, "
"a sequência original é retornada se *width* for menor ou igual a ``len(s)``."

#: ../../library/stdtypes.rst:3444
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*bytes* argument is a binary sequence specifying the set of byte values to "
"be removed.  If omitted or ``None``, the *bytes* argument defaults to "
"removing ASCII whitespace.  The *bytes* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Retorna uma cópia da sequência com os bytes iniciais especificados "
"removidos. O argumento *bytes* é uma sequência binária que especifica o "
"conjunto de valores de bytes a serem removidos. Se omitido ou ``None``, o "
"argumento *bytes* remove espaços em branco ASCII por predefinição. O "
"argumento *bytes* não é um prefixo; em vez disso, todas as combinações dos "
"seus valores são removidas:"

#: ../../library/stdtypes.rst:3450
msgid ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"
msgstr ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"

#: ../../library/stdtypes.rst:3455
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"A sequência binária de valores de bytes a remover pode ser qualquer :term:"
"`objeto semelhante a bytes`. Consulte :meth:`~bytes.removeprefix` para um "
"método que remove uma única *string* de prefixo em vez de todos os "
"caracteres de um conjunto. Por exemplo:"

#: ../../library/stdtypes.rst:3460
msgid ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"
msgstr ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"

#: ../../library/stdtypes.rst:3474
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Retorna uma cópia do objeto alinhado à direita numa sequência de comprimento "
"*width*. O preenchimento é feito usando o *fillbyte* especificado (o "
"predefinido é um espaço ASCII). Para objetos :class:`bytes`, a sequência "
"original é retornada se *width* for menor ou igual a ``len(s)``."

#: ../../library/stdtypes.rst:3488
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Divide a sequência binária em subsequências do mesmo tipo, usando *sep* como "
"a *string* delimitadora. Se *maxsplit* for fornecido, no máximo *maxsplit* "
"divisões são feitas, as mais à *direita*. Se *sep* não for especificado ou "
"for ``None``, qualquer subsequência composta apenas por espaços em branco "
"ASCII é um separador. Exceto pela divisão a partir da direita, :meth:"
"`rsplit` comporta-se como :meth:`split`, que é descrita em detalhe abaixo."

#: ../../library/stdtypes.rst:3499
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*bytes* argument is a binary sequence specifying the set of byte values to "
"be removed.  If omitted or ``None``, the *bytes* argument defaults to "
"removing ASCII whitespace.  The *bytes* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Retorna uma cópia da sequência com os bytes finais especificados removidos. "
"O argumento *bytes* é uma sequência binária que especifica o conjunto de "
"valores de bytes a serem removidos. Se omitido ou ``None``, o argumento "
"*bytes* remove espaços em branco ASCII por predefinição. O argumento *bytes* "
"não é um sufixo; em vez disso, todas as combinações dos seus valores são "
"removidas:"

#: ../../library/stdtypes.rst:3505
msgid ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"
msgstr ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"

#: ../../library/stdtypes.rst:3510
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"A sequência binária de valores de bytes a remover pode ser qualquer :term:"
"`objeto semelhante a bytes`. Consulte :meth:`~bytes.removesuffix` para um "
"método que remove uma única *string* de sufixo em vez de todos os caracteres "
"de um conjunto. Por exemplo:"

#: ../../library/stdtypes.rst:3515
msgid ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"
msgstr ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"

#: ../../library/stdtypes.rst:3529
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Divide a sequência binária em subsequências do mesmo tipo, usando *sep* como "
"a *string* delimitadora. Se *maxsplit* for fornecido e não negativo, no "
"máximo *maxsplit* divisões são feitas (assim, a lista terá no máximo "
"``maxsplit+1`` elementos). Se *maxsplit* não for especificado ou for ``-1``, "
"não há limite no número de divisões (todas as divisões possíveis são feitas)."

#: ../../library/stdtypes.rst:3535
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence as a single delimiter. Splitting an empty sequence with a "
"specified separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on "
"the type of object being split.  The *sep* argument may be any :term:`bytes-"
"like object`."
msgstr ""
"Se *sep* for fornecido, delimitadores consecutivos não são agrupados e são "
"considerados como delimitadores de subsequências vazias (por exemplo, "
"``b'1,,2'.split(b',')`` retorna ``[b'1', b'', b'2']``). O argumento *sep* "
"pode consistir numa sequência de vários bytes como um único delimitador. "
"Dividir uma sequência vazia com um separador especificado retorna ``[b'']`` "
"ou ``[bytearray(b'')]`` dependendo do tipo de objeto a ser dividido. O "
"argumento *sep* pode ser qualquer :term:`objeto semelhante a bytes`."

#: ../../library/stdtypes.rst:3545
msgid ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"
msgstr ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"

#: ../../library/stdtypes.rst:3554
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Se *sep* não for especificado ou for ``None``, um algoritmo de divisão "
"diferente é aplicado: sequências consecutivas de espaços em branco ASCII são "
"consideradas como um único separador, e o resultado não conterá sequências "
"vazias no início ou no fim se a sequência tiver espaços em branco iniciais "
"ou finais. Consequentemente, dividir uma sequência vazia ou uma sequência "
"composta apenas por espaços em branco ASCII sem um separador especificado "
"retorna ``[]``."

#: ../../library/stdtypes.rst:3564
msgid ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"
msgstr ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"

#: ../../library/stdtypes.rst:3575
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *bytes* argument is a binary sequence specifying the set of "
"byte values to be removed.  If omitted or ``None``, the *bytes* argument "
"defaults to removing ASCII whitespace. The *bytes* argument is not a prefix "
"or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Retorna uma cópia da sequência com os bytes iniciais e finais especificados "
"removidos. O argumento *bytes* é uma sequência binária que especifica o "
"conjunto de valores de bytes a serem removidos. Se omitido ou ``None``, o "
"argumento *bytes* remove espaços em branco ASCII por predefinição. O "
"argumento *bytes* não é um prefixo ou sufixo; em vez disso, todas as "
"combinações dos seus valores são removidas:"

#: ../../library/stdtypes.rst:3582
msgid ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"
msgstr ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"

#: ../../library/stdtypes.rst:3587
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"A sequência binária de valores de bytes a remover pode ser qualquer :term:"
"`objeto semelhante a bytes`."

#: ../../library/stdtypes.rst:3596
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Os seguintes métodos em objetos bytes e bytearray assumem o uso de formatos "
"binários compatíveis com ASCII e não devem ser aplicados a dados binários "
"arbitrários. Note que todos os métodos bytearray nesta secção *não* operam "
"no local, e em vez disso produzem novos objetos."

#: ../../library/stdtypes.rst:3604
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Retorna uma cópia da sequência com cada byte interpretado como um caractere "
"ASCII, e o primeiro byte em maiúscula e o resto em minúsculas. Valores de "
"bytes não-ASCII são passados sem alteração."

#: ../../library/stdtypes.rst:3617
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Retorna uma cópia da sequência onde todos os caracteres de tabulação ASCII "
"são substituídos por um ou mais espaços ASCII, dependendo da coluna atual e "
"do tamanho de tabulação dado. As posições de tabulação ocorrem a cada "
"*tabsize* bytes (o predefinido é 8, dando posições de tabulação nas colunas "
"0, 8, 16, etc.). Para expandir a sequência, a coluna atual é definida como "
"zero e a sequência é examinada byte a byte. Se o byte for um caractere de "
"tabulação ASCII (``b'\\t'``), um ou mais caracteres de espaço são inseridos "
"no resultado até que a coluna atual seja igual à próxima posição de "
"tabulação. (O próprio caractere de tabulação não é copiado.) Se o byte atual "
"for uma nova linha ASCII (``b'\\n'``) ou retorno de carro (``b'\\r'``), é "
"copiado e a coluna atual é redefinida para zero. Qualquer outro valor de "
"byte é copiado sem alteração e a coluna atual é incrementada em um, "
"independentemente de como o valor do byte é representado quando impresso:"

#: ../../library/stdtypes.rst:3631
msgid ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"
msgstr ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"

#: ../../library/stdtypes.rst:3645
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Retorna ``True`` se todos os bytes na sequência forem caracteres alfabéticos "
"ASCII ou dígitos decimais ASCII e a sequência não estiver vazia, ``False`` "
"caso contrário. Caracteres alfabéticos ASCII são aqueles valores de bytes na "
"sequência ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. "
"Dígitos decimais ASCII são aqueles valores de bytes na sequência "
"``b'0123456789'``."

#: ../../library/stdtypes.rst:3653
msgid ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"
msgstr ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"

#: ../../library/stdtypes.rst:3662
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Retorna ``True`` se todos os bytes na sequência forem caracteres alfabéticos "
"ASCII e a sequência não estiver vazia, ``False`` caso contrário. Caracteres "
"alfabéticos ASCII são aqueles valores de bytes na sequência "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../../library/stdtypes.rst:3669
msgid ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"
msgstr ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"

#: ../../library/stdtypes.rst:3678
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Retorna ``True`` se a sequência estiver vazia ou todos os bytes na sequência "
"forem ASCII, ``False`` caso contrário. Bytes ASCII estão no intervalo 0-0x7F."

#: ../../library/stdtypes.rst:3688
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Retorna ``True`` se todos os bytes na sequência forem dígitos decimais ASCII "
"e a sequência não estiver vazia, ``False`` caso contrário. Dígitos decimais "
"ASCII são aqueles valores de bytes na sequência ``b'0123456789'``."

#: ../../library/stdtypes.rst:3694
msgid ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"
msgstr ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"

#: ../../library/stdtypes.rst:3703
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Retorna ``True`` se houver pelo menos um caractere ASCII minúsculo na "
"sequência e nenhum caractere ASCII maiúsculo, ``False`` caso contrário."

#: ../../library/stdtypes.rst:3708
msgid ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"
msgstr ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"

#: ../../library/stdtypes.rst:3713 ../../library/stdtypes.rst:3755
#: ../../library/stdtypes.rst:3771 ../../library/stdtypes.rst:3821
#: ../../library/stdtypes.rst:3890
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Caracteres ASCII minúsculos são aqueles valores de bytes na sequência "
"``b'abcdefghijklmnopqrstuvwxyz'``. Caracteres ASCII maiúsculos são aqueles "
"valores de bytes na sequência ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: ../../library/stdtypes.rst:3721
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Retorna ``True`` se todos os bytes na sequência forem espaços em branco "
"ASCII e a sequência não estiver vazia, ``False`` caso contrário. Caracteres "
"de espaço em branco ASCII são aqueles valores de bytes na sequência ``b' "
"\\t\\n\\r\\x0b\\f'`` (espaço, tabulação, nova linha, retorno de carro, "
"tabulação vertical, alimentação de formulário)."

#: ../../library/stdtypes.rst:3730
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Retorna ``True`` se a sequência estiver em título ASCII e a sequência não "
"estiver vazia, ``False`` caso contrário. Consulte :meth:`bytes.title` para "
"mais detalhes sobre a definição de \"titlecase\"."

#: ../../library/stdtypes.rst:3736
msgid ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"
msgstr ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"

#: ../../library/stdtypes.rst:3745
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Retorna ``True`` se houver pelo menos um caractere alfabético ASCII "
"maiúsculo na sequência e nenhum caractere ASCII minúsculo, ``False`` caso "
"contrário."

#: ../../library/stdtypes.rst:3750
msgid ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"
msgstr ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"

#: ../../library/stdtypes.rst:3763
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Retorna uma cópia da sequência com todos os caracteres ASCII maiúsculos "
"convertidos para os seus correspondentes minúsculos."

#: ../../library/stdtypes.rst:3768
msgid ""
">>> b'Hello World'.lower()\n"
"b'hello world'"
msgstr ""
">>> b'Hello World'.lower()\n"
"b'hello world'"

#: ../../library/stdtypes.rst:3788
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Retorna uma lista das linhas na sequência binária, quebrando nos limites de "
"linha ASCII. Este método usa a abordagem :term:`novas linhas universais` "
"para dividir linhas. As quebras de linha não são incluídas na lista "
"resultante, a menos que *keepends* seja fornecido e verdadeiro."

#: ../../library/stdtypes.rst:3795
msgid ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"
msgstr ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"

#: ../../library/stdtypes.rst:3800
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Ao contrário de :meth:`~bytes.split` quando uma *string* delimitadora *sep* "
"é fornecida, este método retorna uma lista vazia para a *string* vazia, e "
"uma quebra de linha terminal não resulta numa linha extra:"

#: ../../library/stdtypes.rst:3804
msgid ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"
msgstr ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"

#: ../../library/stdtypes.rst:3813
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Retorna uma cópia da sequência com todos os caracteres ASCII minúsculos "
"convertidos para os seus correspondentes maiúsculos e vice-versa."

#: ../../library/stdtypes.rst:3818
msgid ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"
msgstr ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"

#: ../../library/stdtypes.rst:3825
msgid ""
"Unlike :func:`str.swapcase`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"Ao contrário de :func:`str.swapcase`, é sempre o caso que ``bin.swapcase()."
"swapcase() == bin`` para as versões binárias. As conversões de caixa são "
"simétricas em ASCII, embora isso não seja geralmente verdadeiro para pontos "
"de código Unicode arbitrários."

#: ../../library/stdtypes.rst:3839
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Retorna uma versão da sequência binária em que as palavras começam com um "
"caractere ASCII maiúsculo e os restantes caracteres são minúsculos. Valores "
"de bytes sem caixa são deixados sem modificação."

#: ../../library/stdtypes.rst:3845
msgid ""
">>> b'Hello world'.title()\n"
"b'Hello World'"
msgstr ""
">>> b'Hello world'.title()\n"
"b'Hello World'"

#: ../../library/stdtypes.rst:3848
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Caracteres ASCII minúsculos são aqueles valores de bytes na sequência "
"``b'abcdefghijklmnopqrstuvwxyz'``. Caracteres ASCII maiúsculos são aqueles "
"valores de bytes na sequência ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Todos os "
"outros valores de bytes são sem caixa."

#: ../../library/stdtypes.rst:3858
msgid ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""

#: ../../library/stdtypes.rst:3861
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Uma solução alternativa para apóstrofos pode ser construída usando "
"expressões regulares:"

#: ../../library/stdtypes.rst:3863
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""

#: ../../library/stdtypes.rst:3882
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Retorna uma cópia da sequência com todos os caracteres ASCII minúsculos "
"convertidos para os seus correspondentes maiúsculos."

#: ../../library/stdtypes.rst:3887
msgid ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"
msgstr ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"

#: ../../library/stdtypes.rst:3903
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Retorna uma cópia da sequência preenchida à esquerda com dígitos ASCII "
"``b'0'`` para criar uma sequência de comprimento *width*. Um prefixo de "
"sinal inicial (``b'+'``/ ``b'-'``) é tratado inserindo o preenchimento "
"*depois* do caractere de sinal em vez de antes. Para objetos :class:`bytes`, "
"a sequência original é retornada se *width* for menor ou igual a "
"``len(seq)``."

#: ../../library/stdtypes.rst:3911
msgid ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"
msgstr ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"

#: ../../library/stdtypes.rst:3925
msgid "``printf``-style Bytes Formatting"
msgstr "Formatação de bytes no estilo ``printf``"

#: ../../library/stdtypes.rst:3942
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"As operações de formatação descritas aqui apresentam várias particularidades "
"que levam a vários erros comuns (como falhar ao exibir tuplos e dicionários "
"corretamente). Se o valor a ser impresso puder ser um tuplo ou dicionário, "
"encapsule-o num tuplo."

#: ../../library/stdtypes.rst:3947
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Os objetos bytes (``bytes``/``bytearray``) têm uma operação incorporada "
"única: o operador ``%`` (módulo). Isto também é conhecido como o operador de "
"*formatação* ou *interpolação* de bytes. Dado ``format % values`` (onde "
"*format* é um objeto bytes), as especificações de conversão ``%`` em "
"*format* são substituídas por zero ou mais elementos de *values*. O efeito é "
"semelhante ao uso da função :c:func:`sprintf` na linguagem C."

#: ../../library/stdtypes.rst:3954
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *format* requer um único argumento, *values* pode ser um objeto não-"
"tuplo. [5]_ Caso contrário, *values* deve ser um tuplo com exatamente o "
"número de itens especificado pelo objeto bytes de formato, ou um único "
"objeto de mapeamento (por exemplo, um dicionário)."

#: ../../library/stdtypes.rst:3988
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando o argumento da direita é um dicionário (ou outro tipo de mapeamento), "
"então os formatos no objeto bytes *devem* incluir uma chave de mapeamento "
"entre parênteses para esse dicionário inserida imediatamente após o "
"caractere ``'%'``. A chave de mapeamento seleciona o valor a ser formatado a "
"partir do mapeamento. Por exemplo:"

#: ../../library/stdtypes.rst:4040
msgid "\\(8)"
msgstr "(8)"

#: ../../library/stdtypes.rst:4062
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Byte único (aceita inteiro ou objetos de byte único)."

#: ../../library/stdtypes.rst:4065
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/stdtypes.rst:4065
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`~object.__bytes__`)."
msgstr ""
"Bytes (qualquer objeto que segue o :ref:`protocolo de buffer "
"<bufferobjects>` ou tem :meth:`~object.__bytes__`)."

#: ../../library/stdtypes.rst:4069
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'s'`` é um alias para ``'b'`` e deve ser usado apenas para bases de código "
"Python2/3."

#: ../../library/stdtypes.rst:4072
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Bytes (converte qualquer objeto Python usando ``repr(obj).encode('ascii', "
"'backslashreplace')``)."

#: ../../library/stdtypes.rst:4075
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"``'r'`` é um alias para ``'a'`` e deve ser usado apenas para bases de código "
"Python2/3."

#: ../../library/stdtypes.rst:4075
msgid "\\(7)"
msgstr "(7)"

#: ../../library/stdtypes.rst:4110
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` está obsoleto, mas não será removido durante a série 3.x."

#: ../../library/stdtypes.rst:4113
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` está obsoleto, mas não será removido durante a série 3.x."

#: ../../library/stdtypes.rst:4125
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Adicionar formatação % a bytes e bytearray"

#: ../../library/stdtypes.rst:4132
msgid "Memory Views"
msgstr "Vistas de memória"

#: ../../library/stdtypes.rst:4134
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Os objetos :class:`memoryview` permitem que o código Python aceda aos dados "
"internos de um objeto que suporta o :ref:`protocolo de buffer "
"<bufferobjects>` sem copiar."

#: ../../library/stdtypes.rst:4140
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Cria uma :class:`memoryview` que referencia *object*. *object* deve suportar "
"o protocolo de buffer. Objetos incorporados que suportam o protocolo de "
"buffer incluem :class:`bytes` e :class:`bytearray`."

#: ../../library/stdtypes.rst:4144
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
"Uma :class:`memoryview` tem a noção de um *elemento*, que é a unidade de "
"memória atómica manipulada pelo *object* de origem. Para muitos tipos "
"simples, como :class:`bytes` e :class:`bytearray`, um elemento é um único "
"byte, mas outros tipos, como :class:`array.array`, podem ter elementos "
"maiores."

#: ../../library/stdtypes.rst:4149
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is "
"equal to the number of elements in the view."
msgstr ""
"``len(view)`` é igual ao comprimento de :class:`~memoryview.tolist`, que é a "
"representação de lista aninhada da vista. Se ``view.ndim = 1``, isto é igual "
"ao número de elementos na vista."

#: ../../library/stdtypes.rst:4153
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""
"Se ``view.ndim == 0``, ``len(view)`` agora lança :exc:`TypeError` em vez de "
"retornar 1."

#: ../../library/stdtypes.rst:4156
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"O atributo :class:`~memoryview.itemsize` dar-lhe-á o número de bytes num "
"único elemento."

#: ../../library/stdtypes.rst:4159
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Uma :class:`memoryview` suporta fatiamento e indexação para expor os seus "
"dados. O fatiamento unidimensional resultará numa subvista:"

#: ../../library/stdtypes.rst:4162
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"
msgstr ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"

#: ../../library/stdtypes.rst:4172
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Se :class:`~memoryview.format` for um dos especificadores de formato nativos "
"do módulo :mod:`struct`, a indexação com um inteiro ou um tuplo de inteiros "
"também é suportada e retorna um único *elemento* com o tipo correto. Vistas "
"de memória unidimensionais podem ser indexadas com um inteiro ou um tuplo de "
"um inteiro. Vistas de memória multidimensionais podem ser indexadas com "
"tuplos de exatamente *ndim* inteiros, onde *ndim* é o número de dimensões. "
"Vistas de memória zero-dimensionais podem ser indexadas com o tuplo vazio."

#: ../../library/stdtypes.rst:4181
msgid "Here is an example with a non-byte format::"
msgstr "Aqui está um exemplo com um formato não-byte:"

#: ../../library/stdtypes.rst:4183
msgid ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"
msgstr ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"

#: ../../library/stdtypes.rst:4193
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Se o objeto subjacente for gravável, a memoryview suporta atribuição de "
"fatia unidimensional. O redimensionamento não é permitido:"

#: ../../library/stdtypes.rst:4196
msgid ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different "
"structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"
msgstr ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different "
"structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"

#: ../../library/stdtypes.rst:4214
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"Vistas de memória unidimensionais de tipos :term:`hashable` (apenas leitura) "
"com formatos 'B', 'b' ou 'c' também são hashable. O hash é definido como "
"``hash(m) == hash(m.tobytes())``:"

#: ../../library/stdtypes.rst:4218
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"
msgstr ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"

#: ../../library/stdtypes.rst:4226
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""
"Vistas de memória unidimensionais podem agora ser fatiadas. Vistas de "
"memória unidimensionais com formatos 'B', 'b' ou 'c' são agora :term:"
"`hashable`."

#: ../../library/stdtypes.rst:4230
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"memoryview é agora registada automaticamente com :class:`collections.abc."
"Sequence`"

#: ../../library/stdtypes.rst:4234
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "memoryviews podem agora ser indexadas com um tuplo de inteiros."

#: ../../library/stdtypes.rst:4237
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` tem vários métodos:"

#: ../../library/stdtypes.rst:4241
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Uma memoryview e um exportador :pep:`3118` são iguais se as suas formas "
"forem equivalentes e se todos os valores correspondentes forem iguais quando "
"os códigos de formato dos operandos forem interpretados usando a sintaxe :"
"mod:`struct`."

#: ../../library/stdtypes.rst:4245
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Para o subconjunto de *strings* de formato :mod:`struct` atualmente "
"suportadas por :meth:`tolist`, ``v`` e ``w`` são iguais se ``v.tolist() == w."
"tolist()``:"

#: ../../library/stdtypes.rst:4248
msgid ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"
msgstr ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"

#: ../../library/stdtypes.rst:4264
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Se qualquer *string* de formato não for suportada pelo módulo :mod:`struct`, "
"então os objetos serão sempre comparados como desiguais (mesmo que as "
"*strings* de formato e os conteúdos do buffer sejam idênticos):"

#: ../../library/stdtypes.rst:4268
msgid ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"
msgstr ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"

#: ../../library/stdtypes.rst:4280
msgid ""
"Note that, as with floating-point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Note que, tal como com números de ponto flutuante, ``v is w`` *não* implica "
"``v == w`` para objetos memoryview."

#: ../../library/stdtypes.rst:4283
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Versões anteriores comparavam a memória bruta, ignorando o formato do item e "
"a estrutura lógica do array."

#: ../../library/stdtypes.rst:4289
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Retorna os dados no buffer como uma *string* de bytes. Isto é equivalente a "
"chamar o construtor :class:`bytes` na memoryview:"

#: ../../library/stdtypes.rst:4292
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"
msgstr ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"

#: ../../library/stdtypes.rst:4298
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Para arrays não contíguos, o resultado é igual à representação de lista "
"achatada com todos os elementos convertidos para bytes. :meth:`tobytes` "
"suporta todas as *strings* de formato, incluindo aquelas que não estão na "
"sintaxe do módulo :mod:`struct`."

#: ../../library/stdtypes.rst:4303
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"*order* pode ser {'C', 'F', 'A'}. Quando *order* é 'C' ou 'F', os dados do "
"array original são convertidos para ordem C ou Fortran. Para vistas "
"contíguas, 'A' retorna uma cópia exata da memória física. Em particular, a "
"ordem Fortran na memória é preservada. Para vistas não contíguas, os dados "
"são convertidos para C primeiro. *order=None* é o mesmo que *order='C'*."

#: ../../library/stdtypes.rst:4313
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""

#: ../../library/stdtypes.rst:4316
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"
msgstr ""

#: ../../library/stdtypes.rst:4322
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""

#: ../../library/stdtypes.rst:4329
msgid "Return the data in the buffer as a list of elements. ::"
msgstr ""

#: ../../library/stdtypes.rst:4331
msgid ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> import array\n"
">>> a = array.array('d', [1.1, 2.2, 3.3])\n"
">>> m = memoryview(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"
msgstr ""

#: ../../library/stdtypes.rst:4339
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""

#: ../../library/stdtypes.rst:4346
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""

#: ../../library/stdtypes.rst:4349
msgid ""
">>> m = memoryview(bytearray(b'abc'))\n"
">>> mm = m.toreadonly()\n"
">>> mm.tolist()\n"
"[97, 98, 99]\n"
">>> mm[0] = 42\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot modify read-only memory\n"
">>> m[0] = 43\n"
">>> mm.tolist()\n"
"[43, 98, 99]"
msgstr ""

#: ../../library/stdtypes.rst:4365
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""

#: ../../library/stdtypes.rst:4371
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release` itself which can be called "
"multiple times)::"
msgstr ""

#: ../../library/stdtypes.rst:4375
msgid ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""

#: ../../library/stdtypes.rst:4382
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""

#: ../../library/stdtypes.rst:4385
msgid ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"97\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""

#: ../../library/stdtypes.rst:4399
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""

#: ../../library/stdtypes.rst:4405
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""

#: ../../library/stdtypes.rst:4411
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr ""

#: ../../library/stdtypes.rst:4413
msgid ""
">>> import array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = memoryview(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.itemsize\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"
msgstr ""

#: ../../library/stdtypes.rst:4434
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr ""

#: ../../library/stdtypes.rst:4436
msgid ""
">>> b = bytearray(b'zyz')\n"
">>> x = memoryview(b)\n"
">>> x[0] = b'a'\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: memoryview: invalid type for format 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"
msgstr ""

#: ../../library/stdtypes.rst:4447
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Conversão de 1D/bytes para 3D/ints para 1D/char com sinal::"

#: ../../library/stdtypes.rst:4449
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"

#: ../../library/stdtypes.rst:4473
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Conversão de 1D/long sem sinal para 2D/long sem sinal::"

#: ../../library/stdtypes.rst:4475
msgid ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"
msgstr ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"

#: ../../library/stdtypes.rst:4487
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"O formato de origem já não está restrito ao converter para uma vista de byte."

#: ../../library/stdtypes.rst:4490
msgid "There are also several readonly attributes available:"
msgstr "Existem também vários atributos apenas de leitura disponíveis:"

#: ../../library/stdtypes.rst:4494
msgid "The underlying object of the memoryview::"
msgstr "O objeto subjacente da memoryview:"

#: ../../library/stdtypes.rst:4496
msgid ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"
msgstr ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"

#: ../../library/stdtypes.rst:4505
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Esta é a "
"quantidade de espaço em bytes que o array usaria numa representação "
"contígua. Não é necessariamente igual a ``len(m)``:"

#: ../../library/stdtypes.rst:4509
msgid ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"
msgstr ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"

#: ../../library/stdtypes.rst:4524
msgid "Multi-dimensional arrays::"
msgstr "Arrays multidimensionais:"

#: ../../library/stdtypes.rst:4526
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"

#: ../../library/stdtypes.rst:4541
msgid "A bool indicating whether the memory is read only."
msgstr "Um booleano que indica se a memória é apenas de leitura."

#: ../../library/stdtypes.rst:4545
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Uma *string* contendo o formato (no estilo do módulo :mod:`struct`) para "
"cada elemento na vista. Uma memoryview pode ser criada a partir de "
"exportadores com *strings* de formato arbitrárias, mas alguns métodos (por "
"exemplo, :meth:`tolist`) estão restritos a formatos de elemento único "
"nativos."

#: ../../library/stdtypes.rst:4550
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"O formato ``'B'`` é agora tratado de acordo com a sintaxe do módulo struct. "
"Isto significa que ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: ../../library/stdtypes.rst:4556
msgid "The size in bytes of each element of the memoryview::"
msgstr "O tamanho em bytes de cada elemento da memoryview:"

#: ../../library/stdtypes.rst:4558
msgid ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"
msgstr ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"

#: ../../library/stdtypes.rst:4569
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Um inteiro que indica quantas dimensões de um array multidimensional a "
"memória representa."

#: ../../library/stdtypes.rst:4574
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Um tuplo de inteiros com o comprimento de :attr:`ndim` que dá a forma da "
"memória como um array N-dimensional."

#: ../../library/stdtypes.rst:4577 ../../library/stdtypes.rst:4585
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Um tuplo vazio em vez de ``None`` quando ndim = 0."

#: ../../library/stdtypes.rst:4582
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Um tuplo de inteiros com o comprimento de :attr:`ndim` que dá o tamanho em "
"bytes para aceder a cada elemento de cada dimensão do array."

#: ../../library/stdtypes.rst:4590
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Usado internamente para arrays no estilo PIL. O valor é apenas informativo."

#: ../../library/stdtypes.rst:4594
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Um booleano que indica se a memória é :term:`contígua` em C."

#: ../../library/stdtypes.rst:4600
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Um booleano que indica se a memória é :term:`contígua` em Fortran."

#: ../../library/stdtypes.rst:4606
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Um booleano que indica se a memória é :term:`contígua`."

#: ../../library/stdtypes.rst:4614
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Tipos de conjuntos --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:4618
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Um objeto :dfn:`set` é uma coleção não ordenada de objetos distintos :term:"
"`hashable`. Usos comuns incluem teste de pertença, remoção de duplicados de "
"uma sequência e cálculo de operações matemáticas como interseção, união, "
"diferença e diferença simétrica. (Para outros contentores, consulte as "
"classes incorporadas :class:`dict`, :class:`list` e :class:`tuple`, e o "
"módulo :mod:`collections`.)"

#: ../../library/stdtypes.rst:4625
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Tal como outras coleções, os conjuntos suportam ``x in set``, ``len(set)`` e "
"``for x in set``. Sendo uma coleção não ordenada, os conjuntos não registam "
"a posição dos elementos ou a ordem de inserção. Consequentemente, os "
"conjuntos não suportam indexação, fatiamento ou outro comportamento "
"semelhante a sequências."

#: ../../library/stdtypes.rst:4630
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Atualmente, existem dois tipos de conjuntos incorporados, :class:`set` e :"
"class:`frozenset`. O tipo :class:`set` é mutável --- o conteúdo pode ser "
"alterado usando métodos como :meth:`~set.add` e :meth:`~set.remove`. Uma vez "
"que é mutável, não tem valor de hash e não pode ser usado como chave de "
"dicionário ou como elemento de outro conjunto. O tipo :class:`frozenset` é "
"imutável e :term:`hashable` --- o seu conteúdo não pode ser alterado após a "
"sua criação; pode, portanto, ser usado como chave de dicionário ou como "
"elemento de outro conjunto."

#: ../../library/stdtypes.rst:4638
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Conjuntos não vazios (não frozensets) podem ser criados colocando uma lista "
"de elementos separados por vírgulas dentro de chavetas, por exemplo: "
"``{'jack', 'sjoerd'}``, além do construtor :class:`set`."

#: ../../library/stdtypes.rst:4642
msgid "The constructors for both classes work the same:"
msgstr "Os construtores para ambas as classes funcionam da mesma forma:"

#: ../../library/stdtypes.rst:4647
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Retorna um novo objeto set ou frozenset cujos elementos são obtidos de "
"*iterable*. Os elementos de um conjunto devem ser :term:`hashable`. Para "
"representar conjuntos de conjuntos, os conjuntos internos devem ser objetos :"
"class:`frozenset`. Se *iterable* não for especificado, um novo conjunto "
"vazio é retornado."

#: ../../library/stdtypes.rst:4653
msgid "Sets can be created by several means:"
msgstr "Os conjuntos podem ser criados de várias formas:"

#: ../../library/stdtypes.rst:4655
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Use uma lista de elementos separados por vírgulas dentro de chavetas: "
"``{'jack', 'sjoerd'}``"

#: ../../library/stdtypes.rst:4656
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Use uma compreensão de conjunto: ``{c for c in 'abracadabra' if c not in "
"'abc'}``"

#: ../../library/stdtypes.rst:4657
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Use o construtor de tipo: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"

#: ../../library/stdtypes.rst:4659
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"As instâncias de :class:`set` e :class:`frozenset` fornecem as seguintes "
"operações:"

#: ../../library/stdtypes.rst:4664
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Retorna o número de elementos no conjunto *s* (cardinalidade de *s*)."

#: ../../library/stdtypes.rst:4668
msgid "Test *x* for membership in *s*."
msgstr "Testa se *x* é membro de *s*."

#: ../../library/stdtypes.rst:4672
msgid "Test *x* for non-membership in *s*."
msgstr "Testa se *x* não é membro de *s*."

#: ../../library/stdtypes.rst:4677
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Retorna ``True`` se o conjunto não tiver elementos em comum com *other*. Os "
"conjuntos são disjuntos se e somente se a sua interseção for o conjunto "
"vazio."

#: ../../library/stdtypes.rst:4684
msgid "Test whether every element in the set is in *other*."
msgstr "Testa se todos os elementos do conjunto estão em *other*."

#: ../../library/stdtypes.rst:4688
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Testa se o conjunto é um subconjunto próprio de *other*, ou seja, ``set <= "
"other and set != other``."

#: ../../library/stdtypes.rst:4695
msgid "Test whether every element in *other* is in the set."
msgstr "Testa se todos os elementos de *other* estão no conjunto."

#: ../../library/stdtypes.rst:4699
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Testa se o conjunto é um superconjunto próprio de *other*, ou seja, ``set >= "
"other and set != other``."

#: ../../library/stdtypes.rst:4706
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Retorna um novo conjunto com elementos do conjunto e de todos os outros."

#: ../../library/stdtypes.rst:4712
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Retorna um novo conjunto com elementos comuns ao conjunto e a todos os "
"outros."

#: ../../library/stdtypes.rst:4718
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Retorna um novo conjunto com elementos no conjunto que não estão nos outros."

#: ../../library/stdtypes.rst:4724
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Retorna um novo conjunto com elementos no conjunto ou em *other*, mas não em "
"ambos."

#: ../../library/stdtypes.rst:4729
msgid "Return a shallow copy of the set."
msgstr "Retorna uma cópia superficial do conjunto."

#: ../../library/stdtypes.rst:4732
msgid ""
"Note, the non-operator versions of :meth:`~frozenset.union`, :meth:"
"`~frozenset.intersection`, :meth:`~frozenset.difference`, :meth:`~frozenset."
"symmetric_difference`, :meth:`~frozenset.issubset`, and :meth:`~frozenset."
"issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../library/stdtypes.rst:4739
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Tanto :class:`set` como :class:`frozenset` suportam comparações conjunto a "
"conjunto. Dois conjuntos são iguais se e somente se cada elemento de cada "
"conjunto estiver contido no outro (cada um é um subconjunto do outro). Um "
"conjunto é menor que outro conjunto se e somente se o primeiro conjunto for "
"um subconjunto próprio do segundo conjunto (é um subconjunto, mas não é "
"igual). Um conjunto é maior que outro conjunto se e somente se o primeiro "
"conjunto for um superconjunto próprio do segundo conjunto (é um "
"superconjunto, mas não é igual)."

#: ../../library/stdtypes.rst:4746
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Instâncias de :class:`set` são comparadas com instâncias de :class:"
"`frozenset` com base nos seus membros. Por exemplo, ``set('abc') == "
"frozenset('abc')`` retorna ``True`` e o mesmo acontece com ``set('abc') in "
"set([frozenset('abc')])``."

#: ../../library/stdtypes.rst:4750
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"As comparações de subconjunto e igualdade não generalizam para uma função de "
"ordenação total. Por exemplo, quaisquer dois conjuntos disjuntos não vazios "
"não são iguais e não são subconjuntos um do outro, então *todos* os "
"seguintes retornam ``False``: ``a<b``, ``a==b`` ou ``a>b``."

#: ../../library/stdtypes.rst:4755
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Uma vez que os conjuntos definem apenas ordenação parcial (relações de "
"subconjunto), a saída do método :meth:`list.sort` é indefinida para listas "
"de conjuntos."

#: ../../library/stdtypes.rst:4758
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Os elementos de um conjunto, tal como as chaves de um dicionário, devem ser :"
"term:`hashable`."

#: ../../library/stdtypes.rst:4760
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Operações binárias que misturam instâncias de :class:`set` com :class:"
"`frozenset` retornam o tipo do primeiro operando. Por exemplo: "
"``frozenset('ab') | set('bc')`` retorna uma instância de :class:`frozenset`."

#: ../../library/stdtypes.rst:4764
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"A tabela seguinte lista operações disponíveis para :class:`set` que não se "
"aplicam a instâncias imutáveis de :class:`frozenset`:"

#: ../../library/stdtypes.rst:4770
msgid "Update the set, adding elements from all others."
msgstr "Atualiza o conjunto, adicionando elementos de todos os outros."

#: ../../library/stdtypes.rst:4775
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Atualiza o conjunto, mantendo apenas elementos encontrados nele e em todos "
"os outros."

#: ../../library/stdtypes.rst:4780
msgid "Update the set, removing elements found in others."
msgstr "Atualiza o conjunto, removendo elementos encontrados nos outros."

#: ../../library/stdtypes.rst:4785
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Atualiza o conjunto, mantendo apenas elementos encontrados em qualquer "
"conjunto, mas não em ambos."

#: ../../library/stdtypes.rst:4789
msgid "Add element *elem* to the set."
msgstr "Adiciona o elemento *elem* ao conjunto."

#: ../../library/stdtypes.rst:4793
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Remove o elemento *elem* do conjunto. Lança :exc:`KeyError` se *elem* não "
"estiver contido no conjunto."

#: ../../library/stdtypes.rst:4798
msgid "Remove element *elem* from the set if it is present."
msgstr "Remove o elemento *elem* do conjunto, se estiver presente."

#: ../../library/stdtypes.rst:4802
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Remove e retorna um elemento arbitrário do conjunto. Lança :exc:`KeyError` "
"se o conjunto estiver vazio."

#: ../../library/stdtypes.rst:4807
msgid "Remove all elements from the set."
msgstr "Remove todos os elementos do conjunto."

#: ../../library/stdtypes.rst:4810
msgid ""
"Note, the non-operator versions of the :meth:`~set.update`, :meth:`~set."
"intersection_update`, :meth:`~set.difference_update`, and :meth:`~set."
"symmetric_difference_update` methods will accept any iterable as an argument."
msgstr ""

#: ../../library/stdtypes.rst:4815
msgid ""
"Note, the *elem* argument to the :meth:`~object.__contains__`, :meth:`~set."
"remove`, and :meth:`~set.discard` methods may be a set.  To support "
"searching for an equivalent frozenset, a temporary one is created from "
"*elem*."
msgstr ""

#: ../../library/stdtypes.rst:4824
msgid "Mapping Types --- :class:`dict`"
msgstr "Tipos de mapeamento --- :class:`dict`"

#: ../../library/stdtypes.rst:4834
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Um objeto :term:`mapping` mapeia valores :term:`hashable` para objetos "
"arbitrários. Os mapeamentos são objetos mutáveis. Atualmente, existe apenas "
"um tipo de mapeamento padrão, o :dfn:`dicionário`. (Para outros contentores, "
"consulte as classes incorporadas :class:`list`, :class:`set` e :class:"
"`tuple`, e o módulo :mod:`collections`.)"

#: ../../library/stdtypes.rst:4840
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"As chaves de um dicionário são valores *quase* arbitrários. Valores que não "
"são :term:`hashable`, ou seja, valores que contêm listas, dicionários ou "
"outros tipos mutáveis (que são comparados por valor em vez de por identidade "
"de objeto) não podem ser usados como chaves. Valores que são iguais na "
"comparação (como ``1``, ``1.0`` e ``True``) podem ser usados indistintamente "
"para indexar a mesma entrada do dicionário."

#: ../../library/stdtypes.rst:4851
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Retorna um novo dicionário inicializado a partir de um argumento posicional "
"opcional e um conjunto possivelmente vazio de argumentos nomeados."

#: ../../library/stdtypes.rst:4854
msgid "Dictionaries can be created by several means:"
msgstr "Os dicionários podem ser criados de várias formas:"

#: ../../library/stdtypes.rst:4856
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Use uma lista de pares ``key: value`` separados por vírgulas dentro de "
"chavetas: ``{'jack': 4098, 'sjoerd': 4127}`` ou ``{4098: 'jack', 4127: "
"'sjoerd'}``"

#: ../../library/stdtypes.rst:4858
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Use uma compreensão de dicionário: ``{}``, ``{x: x ** 2 for x in range(10)}``"

#: ../../library/stdtypes.rst:4859
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Use o construtor de tipo: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"

#: ../../library/stdtypes.rst:4862
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it defines a ``keys()`` method, a "
"dictionary is created by calling :meth:`~object.__getitem__` on the argument "
"with each returned key from the method.  Otherwise, the positional argument "
"must be an :term:`iterable` object.  Each item in the iterable must itself "
"be an iterable with exactly two elements.  The first element of each item "
"becomes a key in the new dictionary, and the second element the "
"corresponding value.  If a key occurs more than once, the last value for "
"that key becomes the corresponding value in the new dictionary."
msgstr ""
"Se nenhum argumento posicional for fornecido, um dicionário vazio é criado. "
"Se um argumento posicional for fornecido e definir um método ``keys()``, um "
"dicionário é criado chamando :meth:`~object.__getitem__` no argumento com "
"cada chave retornada do método. Caso contrário, o argumento posicional deve "
"ser um objeto :term:`iterável`. Cada item no iterável deve ser ele próprio "
"um iterável com exatamente dois elementos. O primeiro elemento de cada item "
"torna-se uma chave no novo dicionário, e o segundo elemento torna-se o valor "
"correspondente. Se uma chave ocorrer mais do que uma vez, o último valor "
"para essa chave torna-se o valor correspondente no novo dicionário."

#: ../../library/stdtypes.rst:4872
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Se argumentos nomeados forem fornecidos, os argumentos nomeados e os seus "
"valores são adicionados ao dicionário criado a partir do argumento "
"posicional. Se uma chave a ser adicionada já estiver presente, o valor do "
"argumento nomeado substitui o valor do argumento posicional."

#: ../../library/stdtypes.rst:4877
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`.  To illustrate dictionary creation and "
"equality, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Os dicionários são iguais se e somente se tiverem os mesmos pares ``(key, "
"value)`` (independentemente da ordem). Comparações de ordem ('<', '<=', "
"'>=', ' >') lançam :exc:`TypeError`. Para ilustrar a criação e igualdade de "
"dicionários, os seguintes exemplos retornam todos um dicionário igual a "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``:"

#: ../../library/stdtypes.rst:4883
msgid ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"
msgstr ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"

#: ../../library/stdtypes.rst:4892
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Fornecer argumentos nomeados como no primeiro exemplo só funciona para "
"chaves que são identificadores Python válidos. Caso contrário, quaisquer "
"chaves válidas podem ser usadas."

#: ../../library/stdtypes.rst:4895
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Os dicionários preservam a ordem de inserção. Note que atualizar uma chave "
"não afeta a ordem. Chaves adicionadas após a eliminação são inseridas no fim:"

#: ../../library/stdtypes.rst:4898
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"
msgstr ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"

#: ../../library/stdtypes.rst:4913
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"A ordem do dicionário é garantida como sendo a ordem de inserção. Este "
"comportamento era um detalhe de implementação do CPython desde a versão 3.6."

#: ../../library/stdtypes.rst:4917
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Estas são as operações que os dicionários suportam (e, portanto, os tipos de "
"mapeamento personalizados também devem suportar):"

#: ../../library/stdtypes.rst:4922
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "Retorna uma lista de todas as chaves usadas no dicionário *d*."

#: ../../library/stdtypes.rst:4926
msgid "Return the number of items in the dictionary *d*."
msgstr "Retorna o número de itens no dicionário *d*."

#: ../../library/stdtypes.rst:4930
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Retorna o item de *d* com a chave *key*. Lança uma exceção :exc:`KeyError` "
"se *key* não estiver no mapeamento."

#: ../../library/stdtypes.rst:4935
msgid ""
"If a subclass of dict defines a method :meth:`~object.__missing__` and *key* "
"is not present, the ``d[key]`` operation calls that method with the key "
"*key* as argument.  The ``d[key]`` operation then returns or raises whatever "
"is returned or raised by the ``__missing__(key)`` call. No other operations "
"or methods invoke :meth:`~object.__missing__`. If :meth:`~object."
"__missing__` is not defined, :exc:`KeyError` is raised. :meth:`~object."
"__missing__` must be a method; it cannot be an instance variable::"
msgstr ""
"Se uma subclasse de dict definir um método :meth:`~object.__missing__` e "
"*key* não estiver presente, a operação ``d[key]`` chama esse método com a "
"chave *key* como argumento. A operação ``d[key]`` retorna ou lança o que for "
"retornado ou lançado pela chamada ``__missing__(key)``. Nenhuma outra "
"operação ou método invoca :meth:`~object.__missing__`. Se :meth:`~object."
"__missing__` não for definido, é lançada uma exceção :exc:`KeyError`. :meth:"
"`~object.__missing__` deve ser um método; não pode ser uma variável de "
"instância:"

#: ../../library/stdtypes.rst:4943
msgid ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"
msgstr ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"

#: ../../library/stdtypes.rst:4954
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`. A different :meth:`!__missing__` method is used by :class:"
"`collections.defaultdict`."
msgstr ""
"O exemplo acima mostra parte da implementação de :class:`collections."
"Counter`. Um método :meth:`!__missing__` diferente é usado por :class:"
"`collections.defaultdict`."

#: ../../library/stdtypes.rst:4961
msgid "Set ``d[key]`` to *value*."
msgstr "Define ``d[key]`` para *value*."

#: ../../library/stdtypes.rst:4965
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Remove ``d[key]`` de *d*. Lança uma exceção :exc:`KeyError` se *key* não "
"estiver no mapeamento."

#: ../../library/stdtypes.rst:4970
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""
"Retorna ``True`` se *d* tiver uma chave *key*, caso contrário ``False``."

#: ../../library/stdtypes.rst:4974
msgid "Equivalent to ``not key in d``."
msgstr "Equivalente a ``not key in d``."

#: ../../library/stdtypes.rst:4978
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Retorna um iterador sobre as chaves do dicionário. Isto é um atalho para "
"``iter(d.keys())``."

#: ../../library/stdtypes.rst:4983
msgid "Remove all items from the dictionary."
msgstr "Remove todos os itens do dicionário."

#: ../../library/stdtypes.rst:4987
msgid "Return a shallow copy of the dictionary."
msgstr "Retorna uma cópia superficial do dicionário."

#: ../../library/stdtypes.rst:4991
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Cria um novo dicionário com chaves de *iterable* e valores definidos para "
"*value*."

#: ../../library/stdtypes.rst:4993
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
":meth:`fromkeys` é um método de classe que retorna um novo dicionário. "
"*value* é ``None`` por predefinição. Todos os valores referem-se a apenas "
"uma única instância, por isso geralmente não faz sentido que *value* seja um "
"objeto mutável como uma lista vazia. Para obter valores distintos, use uma :"
"ref:`compreensão de dicionário <dict>`."

#: ../../library/stdtypes.rst:5001
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Retorna o valor para *key* se *key* estiver no dicionário, caso contrário "
"*default*. Se *default* não for fornecido, é ``None`` por predefinição, por "
"isso este método nunca lança uma exceção :exc:`KeyError`."

#: ../../library/stdtypes.rst:5007
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Retorna uma nova vista dos itens do dicionário (pares ``(key, value)``). "
"Consulte a :ref:`documentação dos objetos de vista <dict-views>`."

#: ../../library/stdtypes.rst:5012
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Retorna uma nova vista das chaves do dicionário. Consulte a :ref:"
"`documentação dos objetos de vista <dict-views>`."

#: ../../library/stdtypes.rst:5018
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Se *key* estiver no dicionário, remove-o e retorna o seu valor, caso "
"contrário retorna *default*. Se *default* não for fornecido e *key* não "
"estiver no dicionário, é lançada uma exceção :exc:`KeyError`."

#: ../../library/stdtypes.rst:5024
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Remove e retorna um par ``(key, value)`` do dicionário. Os pares são "
"retornados por ordem :abbr:`LIFO (último a entrar, primeiro a sair)`."

#: ../../library/stdtypes.rst:5027
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` é útil para iterar de forma destrutiva sobre um dicionário, "
"como é frequentemente usado em algoritmos de conjuntos. Se o dicionário "
"estiver vazio, chamar :meth:`popitem` lança uma exceção :exc:`KeyError`."

#: ../../library/stdtypes.rst:5031
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"A ordem LIFO é agora garantida. Em versões anteriores, :meth:`popitem` "
"retornava um par chave/valor arbitrário."

#: ../../library/stdtypes.rst:5037
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Retorna um iterador reverso sobre as chaves do dicionário. Isto é um atalho "
"para ``reversed(d.keys())``."

#: ../../library/stdtypes.rst:5044
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Se *key* estiver no dicionário, retorna o seu valor. Se não, insere *key* "
"com um valor de *default* e retorna *default*. *default* é ``None`` por "
"predefinição."

#: ../../library/stdtypes.rst:5052
msgid ""
"Update the dictionary with the key/value pairs from *mapping* or *iterable* "
"and *kwargs*, overwriting existing keys.  Return ``None``."
msgstr ""
"Atualiza o dicionário com os pares chave/valor de *mapping* ou *iterable* e "
"*kwargs*, sobrescrevendo chaves existentes. Retorna ``None``."

#: ../../library/stdtypes.rst:5055
msgid ""
":meth:`update` accepts either another object with a ``keys()`` method (in "
"which case :meth:`~object.__getitem__` is called with every key returned "
"from the method) or an iterable of key/value pairs (as tuples or other "
"iterables of length two). If keyword arguments are specified, the dictionary "
"is then updated with those key/value pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` aceita outro objeto com um método ``keys()`` (caso em que :"
"meth:`~object.__getitem__` é chamado com cada chave retornada do método) ou "
"um iterável de pares chave/valor (como tuplos ou outros iteráveis de "
"comprimento dois). Se argumentos nomeados forem especificados, o dicionário "
"é então atualizado com esses pares chave/valor: ``d.update(red=1, blue=2)``."

#: ../../library/stdtypes.rst:5063
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Retorna uma nova vista dos valores do dicionário. Consulte a :ref:"
"`documentação dos objetos de vista <dict-views>`."

#: ../../library/stdtypes.rst:5066
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Uma comparação de igualdade entre uma vista ``dict.values()`` e outra sempre "
"retornará ``False``. Isto também se aplica ao comparar ``dict.values()`` "
"consigo próprio:"

#: ../../library/stdtypes.rst:5070
msgid ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"
msgstr ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"

#: ../../library/stdtypes.rst:5076
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Cria um novo dicionário com as chaves e valores fundidos de *d* e *other*, "
"que devem ser ambos dicionários. Os valores de *other* têm prioridade quando "
"*d* e *other* partilham chaves."

#: ../../library/stdtypes.rst:5084
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Atualiza o dicionário *d* com chaves e valores de *other*, que pode ser um :"
"term:`mapeamento` ou um :term:`iterável` de pares chave/valor. Os valores de "
"*other* têm prioridade quando *d* e *other* partilham chaves."

#: ../../library/stdtypes.rst:5090
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Dicionários e vistas de dicionário são reversíveis:"

#: ../../library/stdtypes.rst:5092
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"
msgstr ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"

#: ../../library/stdtypes.rst:5102
msgid "Dictionaries are now reversible."
msgstr "Os dicionários são agora reversíveis."

#: ../../library/stdtypes.rst:5107
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType` pode ser usado para criar uma vista apenas "
"de leitura de um :class:`dict`."

#: ../../library/stdtypes.rst:5114
msgid "Dictionary view objects"
msgstr "Objetos de vista de dicionário"

#: ../../library/stdtypes.rst:5116
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Os objetos retornados por :meth:`dict.keys`, :meth:`dict.values` e :meth:"
"`dict.items` são *objetos de vista*. Eles fornecem uma vista dinâmica nas "
"entradas do dicionário, o que significa que quando o dicionário muda, a "
"vista reflete essas mudanças."

#: ../../library/stdtypes.rst:5121
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"As vistas de dicionário podem ser iteradas para produzir os seus dados "
"respetivos e suportam testes de pertença:"

#: ../../library/stdtypes.rst:5126
msgid "Return the number of entries in the dictionary."
msgstr "Retorna o número de entradas no dicionário."

#: ../../library/stdtypes.rst:5130
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Retorna um iterador sobre as chaves, valores ou itens (representados como "
"tuplos de ``(key, value)``) no dicionário."

#: ../../library/stdtypes.rst:5133
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"As chaves e valores são iterados por ordem de inserção. Isto permite a "
"criação de pares ``(value, key)`` usando :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``. Outra forma de criar a mesma lista é ``pairs = [(v, "
"k) for (k, v) in d.items()]``."

#: ../../library/stdtypes.rst:5138
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Iterar vistas enquanto se adicionam ou eliminam entradas no dicionário pode "
"lançar uma exceção :exc:`RuntimeError` ou falhar ao iterar sobre todas as "
"entradas."

#: ../../library/stdtypes.rst:5141
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "A ordem do dicionário é garantida como sendo a ordem de inserção."

#: ../../library/stdtypes.rst:5146
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Retorna ``True`` se *x* estiver nas chaves, valores ou itens do dicionário "
"subjacente (no último caso, *x* deve ser um tuplo ``(key, value)``)."

#: ../../library/stdtypes.rst:5151
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Retorna um iterador reverso sobre as chaves, valores ou itens do dicionário. "
"A vista será iterada por ordem inversa da inserção."

#: ../../library/stdtypes.rst:5154
msgid "Dictionary views are now reversible."
msgstr "As vistas de dicionário são agora reversíveis."

#: ../../library/stdtypes.rst:5159
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Retorna um :class:`types.MappingProxyType` que encapsula o dicionário "
"original ao qual a vista se refere."

#: ../../library/stdtypes.rst:5164
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`. "
"Items views also have set-like operations since the (key, value) pairs are "
"unique and the keys are hashable. If all values in an items view are "
"hashable as well, then the items view can interoperate with other sets. "
"(Values views are not treated as set-like since the entries are generally "
"not unique.)  For set-like views, all of the operations defined for the "
"abstract base class :class:`collections.abc.Set` are available (for example, "
"``==``, ``<``, or ``^``).  While using set operators, set-like views accept "
"any iterable as the other operand, unlike sets which only accept sets as the "
"input."
msgstr ""
"As vistas de chaves são semelhantes a conjuntos, uma vez que as suas "
"entradas são únicas e :term:`hashable`. As vistas de itens também têm "
"operações semelhantes a conjuntos, uma vez que os pares (chave, valor) são "
"únicos e as chaves são hashable. Se todos os valores numa vista de itens "
"também forem hashable, então a vista de itens pode interoperar com outros "
"conjuntos. (As vistas de valores não são tratadas como semelhantes a "
"conjuntos, uma vez que as entradas geralmente não são únicas.) Para vistas "
"semelhantes a conjuntos, todas as operações definidas para a classe base "
"abstrata :class:`collections.abc.Set` estão disponíveis (por exemplo, "
"``==``, ``<`` ou ``^``). Ao usar operadores de conjunto, vistas semelhantes "
"a conjuntos aceitam qualquer iterável como o outro operando, ao contrário "
"dos conjuntos, que só aceitam conjuntos como entrada."

#: ../../library/stdtypes.rst:5176
msgid "An example of dictionary view usage::"
msgstr "Um exemplo de uso de vistas de dicionário:"

#: ../../library/stdtypes.rst:5178
msgid ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # keys and values are iterated over in the same order (insertion order)\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # view objects are dynamic and reflect dict changes\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # set operations\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # get back a read-only proxy for the original dictionary\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"
msgstr ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteração\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # chaves e valores são iterados na mesma ordem (ordem de inserção)\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # objetos de vista são dinâmicos e refletem alterações no dicionário\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # operações de conjunto\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # obter um proxy apenas de leitura para o dicionário original\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"

#: ../../library/stdtypes.rst:5220
msgid "Context Manager Types"
msgstr "Tipos de Gestor de Contexto"

#: ../../library/stdtypes.rst:5227
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"A instrução :keyword:`with` do Python suporta o conceito de um contexto de "
"execução definido por um gestor de contexto. Isto é implementado usando um "
"par de métodos que permitem que classes definidas pelo utilizador definam um "
"contexto de execução que é iniciado antes da execução do corpo da instrução "
"e terminado quando a instrução termina:"

#: ../../library/stdtypes.rst:5235
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Inicia o contexto de execução e retorna este objeto ou outro objeto "
"relacionado com o contexto de execução. O valor retornado por este método é "
"associado ao identificador na cláusula :keyword:`!as` das instruções :"
"keyword:`with` que usam este gestor de contexto."

#: ../../library/stdtypes.rst:5240
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Um exemplo de um gestor de contexto que retorna a si próprio é um objeto :"
"term:`ficheiro`. Os objetos de ficheiro retornam a si próprios de "
"__enter__() para permitir que :func:`open` seja usado como a expressão de "
"contexto numa instrução :keyword:`with`."

#: ../../library/stdtypes.rst:5244
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Um exemplo de um gestor de contexto que retorna um objeto relacionado é o "
"retornado por :func:`decimal.localcontext`. Estes gestores definem o "
"contexto decimal ativo para uma cópia do contexto decimal original e depois "
"retornam a cópia. Isto permite que sejam feitas alterações ao contexto "
"decimal atual no corpo da instrução :keyword:`with` sem afetar o código fora "
"da instrução :keyword:`!with`."

#: ../../library/stdtypes.rst:5254
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Sai do contexto de execução e retorna um sinalizador booleano que indica se "
"qualquer exceção que tenha ocorrido deve ser suprimida. Se uma exceção "
"ocorreu durante a execução do corpo da instrução :keyword:`with`, os "
"argumentos contêm o tipo de exceção, valor e informações de traceback. Caso "
"contrário, os três argumentos são ``None``."

#: ../../library/stdtypes.rst:5259
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished executing."
msgstr ""

#: ../../library/stdtypes.rst:5264
msgid ""
"If this method raises an exception while handling an earlier exception from "
"the :keyword:`with` block, the new exception is raised, and the original "
"exception is stored in its :attr:`~BaseException.__context__` attribute."
msgstr ""

#: ../../library/stdtypes.rst:5268
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`~object."
"__exit__` method has actually failed."
msgstr ""
"A exceção passada não deve ser relançada explicitamente - em vez disso, este "
"método deve retornar um valor falso para indicar que o método foi concluído "
"com sucesso e não deseja suprimir a exceção lançada. Isto permite que o "
"código de gestão de contexto detete facilmente se um método :meth:`~object."
"__exit__` falhou ou não."

#: ../../library/stdtypes.rst:5274
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"O Python define vários gestores de contexto para suportar sincronização "
"fácil de threads, fechamento imediato de ficheiros ou outros objetos, e "
"manipulação mais simples do contexto aritmético decimal ativo. Os tipos "
"específicos não são tratados de forma especial além da sua implementação do "
"protocolo de gestão de contexto. Consulte o módulo :mod:`contextlib` para "
"alguns exemplos."

#: ../../library/stdtypes.rst:5280
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Os :term:`geradores` do Python e o decorador :class:`contextlib."
"contextmanager` fornecem uma forma conveniente de implementar estes "
"protocolos. Se uma função geradora for decorada com o decorador :class:"
"`contextlib.contextmanager`, retornará um gestor de contexto que implementa "
"os métodos necessários :meth:`~contextmanager.__enter__` e :meth:"
"`~contextmanager.__exit__`, em vez do iterador produzido por uma função "
"geradora não decorada."

#: ../../library/stdtypes.rst:5287
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Note que não existe um slot específico para qualquer um destes métodos na "
"estrutura de tipo para objetos Python na API Python/C. Tipos de extensão que "
"pretendam definir estes métodos devem fornecê-los como um método Python "
"acessível normal. Comparado com o overhead de configuração do contexto de "
"execução, o overhead de uma única pesquisa no dicionário de classe é "
"negligenciável."

#: ../../library/stdtypes.rst:5295
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Tipos de Anotação de Tipo --- :ref:`Alias Genérico <types-genericalias>`, :"
"ref:`União <types-union>`"

#: ../../library/stdtypes.rst:5300
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"Os tipos incorporados principais para :term:`anotações de tipo <annotation>` "
"são :ref:`Alias Genérico <types-genericalias>` e :ref:`União <types-union>`."

#: ../../library/stdtypes.rst:5307
msgid "Generic Alias Type"
msgstr "Tipo Alias Genérico"

#: ../../library/stdtypes.rst:5313
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"Os objetos ``GenericAlias`` são geralmente criados por :ref:`subscrito "
"<subscriptions>` de uma classe. São mais frequentemente usados com :ref:"
"`classes de contentores <sequence-types>`, como :class:`list` ou :class:"
"`dict`. Por exemplo, ``list[int]`` é um objeto ``GenericAlias`` criado ao "
"subscrever a classe ``list`` com o argumento :class:`int`. Os objetos "
"``GenericAlias`` são destinados principalmente para uso com :term:`anotações "
"de tipo <annotation>`."

#: ../../library/stdtypes.rst:5323
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"É geralmente possível subscrever uma classe apenas se a classe implementar o "
"método especial :meth:`~object.__class_getitem__`."

#: ../../library/stdtypes.rst:5326
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Um objeto ``GenericAlias`` atua como um proxy para um :term:`tipo genérico`, "
"implementando *genéricos parametrizados*."

#: ../../library/stdtypes.rst:5329
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"Para uma classe de contentor, o(s) argumento(s) fornecido(s) a um :ref:"
"`subscrito <subscriptions>` da classe pode(m) indicar o(s) tipo(s) dos "
"elementos que um objeto contém. Por exemplo, ``set[bytes]`` pode ser usado "
"em anotações de tipo para significar um :class:`set` em que todos os "
"elementos são do tipo :class:`bytes`."

#: ../../library/stdtypes.rst:5335
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"Para uma classe que define :meth:`~object.__class_getitem__` mas não é um "
"contentor, o(s) argumento(s) fornecido(s) a um subscrito da classe "
"indicará(ão) frequentemente o(s) tipo(s) de retorno de um ou mais métodos "
"definidos num objeto. Por exemplo, :mod:`expressões regulares <re>` podem "
"ser usadas tanto no tipo de dados :class:`str` como no tipo de dados :class:"
"`bytes`:"

#: ../../library/stdtypes.rst:5341
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Se ``x = re.search('foo', 'foo')``, ``x`` será um objeto :ref:`re.Match "
"<match-objects>` onde os valores de retorno de ``x.group(0)`` e ``x[0]`` "
"serão ambos do tipo :class:`str`. Podemos representar este tipo de objeto em "
"anotações de tipo com o ``GenericAlias`` ``re.Match[str]``."

#: ../../library/stdtypes.rst:5347
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Se ``y = re.search(b'bar', b'bar')``, (note o ``b`` para :class:`bytes`), "
"``y`` também será uma instância de ``re.Match``, mas os valores de retorno "
"de ``y.group(0)`` e ``y[0]`` serão ambos do tipo :class:`bytes`. Em "
"anotações de tipo, representaríamos esta variedade de objetos :ref:`re.Match "
"<match-objects>` com ``re.Match[bytes]``."

#: ../../library/stdtypes.rst:5353
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"Os objetos ``GenericAlias`` são instâncias da classe :class:`types."
"GenericAlias`, que também pode ser usada para criar objetos ``GenericAlias`` "
"diretamente."

#: ../../library/stdtypes.rst:5359
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Cria um ``GenericAlias`` que representa um tipo ``T`` parametrizado pelos "
"tipos *X*, *Y*, e mais, dependendo do ``T`` usado. Por exemplo, uma função "
"que espera uma :class:`list` contendo elementos :class:`float`:"

#: ../../library/stdtypes.rst:5364
msgid ""
"def average(values: list[float]) -> float:\n"
"    return sum(values) / len(values)"
msgstr ""
"def média(valores: list[float]) -> float:\n"
"    return sum(valores) / len(valores)"

#: ../../library/stdtypes.rst:5367
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Outro exemplo para objetos :term:`mapeamento`, usando um :class:`dict`, que "
"é um tipo genérico que espera dois parâmetros de tipo representando o tipo "
"de chave e o tipo de valor. Neste exemplo, a função espera um ``dict`` com "
"chaves do tipo :class:`str` e valores do tipo :class:`int`:"

#: ../../library/stdtypes.rst:5372
msgid ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."
msgstr ""
"def enviar_pedido_post(url: str, corpo: dict[str, int]) -> None:\n"
"    ..."

#: ../../library/stdtypes.rst:5375
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"As funções incorporadas :func:`isinstance` e :func:`issubclass` não aceitam "
"tipos ``GenericAlias`` para o seu segundo argumento:"

#: ../../library/stdtypes.rst:5378
msgid ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argumento 2 não pode ser um genérico parametrizado"

#: ../../library/stdtypes.rst:5383
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"O ambiente de execução do Python não impõe :term:`anotações de tipo "
"<annotation>`. Isto aplica-se a tipos genéricos e aos seus parâmetros de "
"tipo. Ao criar um objeto contentor a partir de um ``GenericAlias``, os "
"elementos no contentor não são verificados em relação ao seu tipo. Por "
"exemplo, o seguinte código é desencorajado, mas será executado sem erros:"

#: ../../library/stdtypes.rst:5389
msgid ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"
msgstr ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"

#: ../../library/stdtypes.rst:5393
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Além disso, os genéricos parametrizados apagam os parâmetros de tipo durante "
"a criação do objeto:"

#: ../../library/stdtypes.rst:5396
msgid ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"
msgstr ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"

#: ../../library/stdtypes.rst:5404
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Chamar :func:`repr` ou :func:`str` num genérico mostra o tipo parametrizado:"

#: ../../library/stdtypes.rst:5406
msgid ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"
msgstr ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"

#: ../../library/stdtypes.rst:5412
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"O método :meth:`~object.__getitem__` de contentores genéricos lançará uma "
"exceção para evitar erros como ``dict[str][str]``:"

#: ../../library/stdtypes.rst:5415
msgid ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] is not a generic class"
msgstr ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] não é uma classe genérica"

#: ../../library/stdtypes.rst:5420
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"No entanto, tais expressões são válidas quando são usadas :ref:`variáveis de "
"tipo <generics>`. O índice deve ter tantos elementos quantos os itens de "
"variável de tipo no atributo :attr:`~genericalias.__args__` do objeto "
"``GenericAlias``:"

#: ../../library/stdtypes.rst:5424
msgid ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"
msgstr ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"

#: ../../library/stdtypes.rst:5431
msgid "Standard Generic Classes"
msgstr "Classes Genéricas Padrão"

#: ../../library/stdtypes.rst:5433
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"As seguintes classes da biblioteca padrão suportam genéricos parametrizados. "
"Esta lista não é exaustiva."

#: ../../library/stdtypes.rst:5436
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: ../../library/stdtypes.rst:5437
msgid ":class:`list`"
msgstr ":class:`list`"

#: ../../library/stdtypes.rst:5438
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: ../../library/stdtypes.rst:5439
msgid ":class:`set`"
msgstr ":class:`set`"

#: ../../library/stdtypes.rst:5440
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: ../../library/stdtypes.rst:5441
msgid ":class:`type`"
msgstr ":class:`type`"

#: ../../library/stdtypes.rst:5442
msgid ":class:`asyncio.Future`"
msgstr ":class:`asyncio.Future`"

#: ../../library/stdtypes.rst:5443
msgid ":class:`asyncio.Task`"
msgstr ":class:`asyncio.Task`"

#: ../../library/stdtypes.rst:5444
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: ../../library/stdtypes.rst:5445
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: ../../library/stdtypes.rst:5446
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: ../../library/stdtypes.rst:5447
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: ../../library/stdtypes.rst:5448
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: ../../library/stdtypes.rst:5449
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: ../../library/stdtypes.rst:5450
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: ../../library/stdtypes.rst:5451
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: ../../library/stdtypes.rst:5452
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: ../../library/stdtypes.rst:5453
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: ../../library/stdtypes.rst:5454
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: ../../library/stdtypes.rst:5455
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: ../../library/stdtypes.rst:5456
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: ../../library/stdtypes.rst:5457
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: ../../library/stdtypes.rst:5458
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: ../../library/stdtypes.rst:5459
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: ../../library/stdtypes.rst:5460
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: ../../library/stdtypes.rst:5461
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: ../../library/stdtypes.rst:5462
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: ../../library/stdtypes.rst:5463
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: ../../library/stdtypes.rst:5464
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: ../../library/stdtypes.rst:5465
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: ../../library/stdtypes.rst:5466
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: ../../library/stdtypes.rst:5467
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: ../../library/stdtypes.rst:5468
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: ../../library/stdtypes.rst:5469
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: ../../library/stdtypes.rst:5470
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: ../../library/stdtypes.rst:5471
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: ../../library/stdtypes.rst:5472
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: ../../library/stdtypes.rst:5473
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: ../../library/stdtypes.rst:5474
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: ../../library/stdtypes.rst:5475
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: ../../library/stdtypes.rst:5476
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: ../../library/stdtypes.rst:5477
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: ../../library/stdtypes.rst:5478
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: ../../library/stdtypes.rst:5479
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: ../../library/stdtypes.rst:5480
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: ../../library/stdtypes.rst:5481
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: ../../library/stdtypes.rst:5482
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: ../../library/stdtypes.rst:5483
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: ../../library/stdtypes.rst:5484
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: ../../library/stdtypes.rst:5485
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: ../../library/stdtypes.rst:5486
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: ../../library/stdtypes.rst:5487
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: ../../library/stdtypes.rst:5488
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: ../../library/stdtypes.rst:5489
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: ../../library/stdtypes.rst:5490
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: ../../library/stdtypes.rst:5491
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: ../../library/stdtypes.rst:5496
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Atributos Especiais de objetos ``GenericAlias``"

#: ../../library/stdtypes.rst:5498
msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Todos os genéricos parametrizados implementam atributos especiais apenas de "
"leitura."

#: ../../library/stdtypes.rst:5502
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Este atributo aponta para a classe genérica não parametrizada:"

#: ../../library/stdtypes.rst:5504
msgid ""
">>> list[int].__origin__\n"
"<class 'list'>"
msgstr ""
">>> list[int].__origin__\n"
"<class 'list'>"

#: ../../library/stdtypes.rst:5510
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Este atributo é um :class:`tuple` (possivelmente de comprimento 1) de tipos "
"genéricos passados ao :meth:`~object.__class_getitem__` original da classe "
"genérica:"

#: ../../library/stdtypes.rst:5514
msgid ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"
msgstr ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"

#: ../../library/stdtypes.rst:5520
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Este atributo é um tuplo calculado de forma preguiçosa (possivelmente vazio) "
"de variáveis de tipo únicas encontradas em ``__args__``:"

#: ../../library/stdtypes.rst:5523
msgid ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"
msgstr ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"

#: ../../library/stdtypes.rst:5531
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Um objeto ``GenericAlias`` com parâmetros :class:`typing.ParamSpec` pode não "
"ter ``__parameters__`` corretos após a substituição porque :class:`typing."
"ParamSpec` é destinado principalmente para verificação de tipo estática."

#: ../../library/stdtypes.rst:5538
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""
"Um booleano que é verdadeiro se o alias tiver sido desempacotado usando o "
"operador ``*`` (consulte :data:`~typing.TypeVarTuple`)."

#: ../../library/stdtypes.rst:5546
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Dicas de Tipo"

#: ../../library/stdtypes.rst:5547
msgid "Introducing Python's framework for type annotations."
msgstr "Introdução ao framework do Python para anotações de tipo."

#: ../../library/stdtypes.rst:5549
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Dicas de Tipo para Genéricos em Coleções Padrão"

#: ../../library/stdtypes.rst:5550
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Introdução da capacidade de parametrizar nativamente classes da biblioteca "
"padrão, desde que implementem o método especial de classe :meth:`~object."
"__class_getitem__`."

#: ../../library/stdtypes.rst:5554
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
":ref:`Generics`, :ref:`genéricos definidos pelo utilizador <user-defined-"
"generics>` e :class:`typing.Generic`"

#: ../../library/stdtypes.rst:5555
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Documentação sobre como implementar classes genéricas que podem ser "
"parametrizadas em tempo de execução e compreendidas por verificadores de "
"tipo estáticos."

#: ../../library/stdtypes.rst:5564
msgid "Union Type"
msgstr "Tipo União"

#: ../../library/stdtypes.rst:5570
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""

#: ../../library/stdtypes.rst:5577
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Define um objeto união que contém os tipos *X*, *Y*, e assim por diante. ``X "
"| Y`` significa X ou Y. É equivalente a ``typing.Union[X, Y]``. Por exemplo, "
"a seguinte função espera um argumento do tipo :class:`int` ou :class:`float`:"

#: ../../library/stdtypes.rst:5582
msgid ""
"def square(number: int | float) -> int | float:\n"
"    return number ** 2"
msgstr ""
"def quadrado(número: int | float) -> int | float:\n"
"    return número ** 2"

#: ../../library/stdtypes.rst:5587
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""
"O operando ``|`` não pode ser usado em tempo de execução para definir uniões "
"onde um ou mais membros é uma referência antecipada. Por exemplo, ``int | "
"\"Foo\"``, onde ``\"Foo\"`` é uma referência a uma classe ainda não "
"definida, falhará em tempo de execução. Para uniões que incluem referências "
"antecipadas, apresente toda a expressão como uma *string*, por exemplo, "
"``\"int | Foo\"``."

#: ../../library/stdtypes.rst:5595
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Os objetos união podem ser testados para igualdade com outros objetos união. "
"Detalhes:"

#: ../../library/stdtypes.rst:5597
msgid "Unions of unions are flattened::"
msgstr "Uniões de uniões são achatadas:"

#: ../../library/stdtypes.rst:5599
msgid "(int | str) | float == int | str | float"
msgstr "(int | str) | float == int | str | float"

#: ../../library/stdtypes.rst:5601
msgid "Redundant types are removed::"
msgstr "Tipos redundantes são removidos:"

#: ../../library/stdtypes.rst:5603
msgid "int | str | int == int | str"
msgstr "int | str | int == int | str"

#: ../../library/stdtypes.rst:5605
msgid "When comparing unions, the order is ignored::"
msgstr "Ao comparar uniões, a ordem é ignorada:"

#: ../../library/stdtypes.rst:5607
msgid "int | str == str | int"
msgstr "int | str == str | int"

#: ../../library/stdtypes.rst:5609
msgid "It is compatible with :data:`typing.Union`::"
msgstr ""

#: ../../library/stdtypes.rst:5611
msgid "int | str == typing.Union[int, str]"
msgstr ""

#: ../../library/stdtypes.rst:5613
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Tipos opcionais podem ser escritos como uma união com ``None``:"

#: ../../library/stdtypes.rst:5615
msgid "str | None == typing.Optional[str]"
msgstr "str | None == typing.Optional[str]"

#: ../../library/stdtypes.rst:5620
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Chamadas a :func:`isinstance` e :func:`issubclass` também são suportadas com "
"um objeto união:"

#: ../../library/stdtypes.rst:5623
msgid ""
">>> isinstance(\"\", int | str)\n"
"True"
msgstr ""
">>> isinstance(\"\", int | str)\n"
"True"

#: ../../library/stdtypes.rst:5626
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"No entanto, :ref:`genéricos parametrizados <types-genericalias>` em objetos "
"união não podem ser verificados:"

#: ../../library/stdtypes.rst:5629
msgid ""
">>> isinstance(1, int | list[int])  # short-circuit evaluation\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance(1, int | list[int])  # avaliação de curto-circuito\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argumento 2 não pode ser um genérico parametrizado"

#: ../../library/stdtypes.rst:5636
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""

#: ../../library/stdtypes.rst:5640
msgid ""
">>> import types\n"
">>> isinstance(int | str, types.UnionType)\n"
"True\n"
">>> types.UnionType()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot create 'types.UnionType' instances"
msgstr ""

#: ../../library/stdtypes.rst:5649
msgid ""
"The :meth:`!__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`!__or__`, the Union may "
"override it:"
msgstr ""
"O método :meth:`!__or__` para objetos de tipo foi adicionado para suportar a "
"sintaxe ``X | Y``. Se uma metaclasse implementar :meth:`!__or__`, a União "
"pode substituí-lo:"

#: ../../library/stdtypes.rst:5653
msgid ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Hello\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Hello'\n"
">>> int | C\n"
"int | C"
msgstr ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Olá\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Olá'\n"
">>> int | C\n"
"int | C"

#: ../../library/stdtypes.rst:5669
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- PEP que propõe a sintaxe ``X | Y`` e o tipo União."

#: ../../library/stdtypes.rst:5677
msgid "Other Built-in Types"
msgstr "Outros Tipos Incorporados"

#: ../../library/stdtypes.rst:5679
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"O interpretador suporta vários outros tipos de objetos. A maioria destes "
"suporta apenas uma ou duas operações."

#: ../../library/stdtypes.rst:5686
msgid "Modules"
msgstr "Módulos"

#: ../../library/stdtypes.rst:5688
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"A única operação especial num módulo é o acesso a atributos: ``m.name``, "
"onde *m* é um módulo e *name* acede a um nome definido na tabela de símbolos "
"de *m*. Os atributos do módulo podem ser atribuídos. (Note que a instrução :"
"keyword:`import` não é, estritamente falando, uma operação num objeto de "
"módulo; ``import foo`` não requer que exista um objeto de módulo chamado "
"*foo*, mas sim uma *definição* (externa) para um módulo chamado *foo* em "
"algum lugar.)"

#: ../../library/stdtypes.rst:5695
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Um atributo especial de cada módulo é :attr:`~object.__dict__`. Este é o "
"dicionário que contém a tabela de símbolos do módulo. Modificar este "
"dicionário alterará efetivamente a tabela de símbolos do módulo, mas a "
"atribuição direta ao atributo :attr:`~object.__dict__` não é possível (pode "
"escrever ``m.__dict__['a'] = 1``, que define ``m.a`` como ``1``, mas não "
"pode escrever ``m.__dict__ = {}``). Modificar :attr:`~object.__dict__` "
"diretamente não é recomendado."

#: ../../library/stdtypes.rst:5703
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Os módulos incorporados no interpretador são escritos assim: ``<module "
"'sys' (built-in)>``. Se carregados a partir de um ficheiro, são escritos "
"como ``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../../library/stdtypes.rst:5711
msgid "Classes and Class Instances"
msgstr "Classes e Instâncias de Classe"

#: ../../library/stdtypes.rst:5713
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Consulte :ref:`objects` e :ref:`class` para mais informações."

#: ../../library/stdtypes.rst:5719
msgid "Functions"
msgstr "Funções"

#: ../../library/stdtypes.rst:5721
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Os objetos função são criados por definições de função. A única operação num "
"objeto função é chamá-lo: ``func(argument-list)``."

#: ../../library/stdtypes.rst:5724
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Existem realmente dois tipos de objetos função: funções incorporadas e "
"funções definidas pelo utilizador. Ambas suportam a mesma operação (chamar a "
"função), mas a implementação é diferente, daí os diferentes tipos de objeto."

#: ../../library/stdtypes.rst:5728
msgid "See :ref:`function` for more information."
msgstr "Consulte :ref:`function` para mais informações."

#: ../../library/stdtypes.rst:5734
msgid "Methods"
msgstr "Métodos"

#: ../../library/stdtypes.rst:5738
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: :ref:`built-in methods <builtin-methods>` (such as :meth:"
"`~list.append` on lists) and :ref:`class instance method <instance-"
"methods>`. Built-in methods are described with the types that support them."
msgstr ""
"Os métodos são funções que são chamadas usando a notação de atributo. "
"Existem dois tipos: :ref:`métodos incorporados <builtin-methods>` (como :"
"meth:`~list.append` em listas) e :ref:`métodos de instância de classe "
"<instance-methods>`. Os métodos incorporados são descritos com os tipos que "
"os suportam."

#: ../../library/stdtypes.rst:5744
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :ref:"
"`instance method <instance-methods>`) object. When called, it will add the "
"``self`` argument to the argument list.  Bound methods have two special read-"
"only attributes: :attr:`m.__self__ <method.__self__>` is the object on which "
"the method operates, and :attr:`m.__func__ <method.__func__>` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` "
"is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Se aceder a um método (uma função definida num espaço de nomes de classe) "
"através de uma instância, obtém um objeto especial: um objeto :dfn:`método "
"ligado` (também chamado de :ref:`método de instância <instance-methods>`). "
"Quando chamado, adicionará o argumento ``self`` à lista de argumentos. Os "
"métodos ligados têm dois atributos especiais apenas de leitura: :attr:`m."
"__self__ <method.__self__>` é o objeto no qual o método opera, e :attr:`m."
"__func__ <method.__func__>` é a função que implementa o método. Chamar "
"``m(arg-1, arg-2, ..., arg-n)`` é completamente equivalente a chamar ``m."
"__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."

#: ../../library/stdtypes.rst:5755
msgid ""
"Like :ref:`function objects <user-defined-funcs>`, bound method objects "
"support getting arbitrary attributes.  However, since method attributes are "
"actually stored on the underlying function object (:attr:`method.__func__`), "
"setting method attributes on bound methods is disallowed.  Attempting to set "
"an attribute on a method results in an :exc:`AttributeError` being raised.  "
"In order to set a method attribute, you need to explicitly set it on the "
"underlying function object:"
msgstr ""
"Tal como os :ref:`objetos função <user-defined-funcs>`, os objetos método "
"ligado suportam a obtenção de atributos arbitrários. No entanto, uma vez que "
"os atributos do método são realmente armazenados no objeto função subjacente "
"(:attr:`method.__func__`), a definição de atributos do método em métodos "
"ligados não é permitida. Tentar definir um atributo num método resulta no "
"lançamento de uma exceção :exc:`AttributeError`. Para definir um atributo de "
"método, é necessário defini-lo explicitamente no objeto função subjacente:"

#: ../../library/stdtypes.rst:5763
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # não é possível definir no "
"método\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: o objeto 'method' não tem o atributo 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"

#: ../../library/stdtypes.rst:5778
msgid "See :ref:`instance-methods` for more information."
msgstr "Consulte :ref:`instance-methods` para mais informações."

#: ../../library/stdtypes.rst:5786
msgid "Code Objects"
msgstr "Objetos código"

#: ../../library/stdtypes.rst:5792
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`~function.__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Os objetos código são usados pela implementação para representar código "
"Python \"pseudo-compilado\" executável, como o corpo de uma função. Diferem "
"dos objetos função porque não contêm uma referência ao seu ambiente de "
"execução global. Os objetos código são retornados pela função incorporada :"
"func:`compile` e podem ser extraídos de objetos função através do seu "
"atributo :attr:`~function.__code__`. Consulte também o módulo :mod:`code`."

#: ../../library/stdtypes.rst:5799
msgid ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and "
"``\"__code__\"``."
msgstr ""
"Aceder a :attr:`~function.__code__` lança um :ref:`evento de auditoria "
"<auditing>` ``object.__getattr__`` com os argumentos ``obj`` e "
"``\"__code__\"``."

#: ../../library/stdtypes.rst:5806
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Um objeto código pode ser executado ou avaliado passando-o (em vez de uma "
"*string* de origem) às funções incorporadas :func:`exec` ou :func:`eval`."

#: ../../library/stdtypes.rst:5809
msgid "See :ref:`types` for more information."
msgstr "Consulte :ref:`types` para mais informações."

#: ../../library/stdtypes.rst:5815
msgid "Type Objects"
msgstr "Objetos Tipo"

#: ../../library/stdtypes.rst:5821
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Os objetos tipo representam os vários tipos de objetos. O tipo de um objeto "
"é acedido pela função incorporada :func:`type`. Não existem operações "
"especiais em tipos. O módulo padrão :mod:`types` define nomes para todos os "
"tipos incorporados padrão."

#: ../../library/stdtypes.rst:5826
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Os tipos são escritos assim: ``<class 'int'>``."

#: ../../library/stdtypes.rst:5832
msgid "The Null Object"
msgstr "O Objeto Nulo"

#: ../../library/stdtypes.rst:5834
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Este objeto é retornado por funções que não retornam explicitamente um "
"valor. Não suporta operações especiais. Existe exatamente um objeto nulo, "
"chamado ``None`` (um nome incorporado). ``type(None)()`` produz o mesmo "
"singleton."

#: ../../library/stdtypes.rst:5838
msgid "It is written as ``None``."
msgstr "É escrito como ``None``."

#: ../../library/stdtypes.rst:5845
msgid "The Ellipsis Object"
msgstr "O Objeto Reticências"

#: ../../library/stdtypes.rst:5847
msgid ""
"This object is commonly used to indicate that something is omitted. It "
"supports no special operations.  There is exactly one ellipsis object, "
"named :const:`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces "
"the :const:`Ellipsis` singleton."
msgstr ""
"Este objeto é comumente usado para indicar que algo foi omitido. Não suporta "
"operações especiais. Existe exatamente um objeto reticências, chamado :const:"
"`Ellipsis` (um nome incorporado). ``type(Ellipsis)()`` produz o singleton :"
"const:`Ellipsis`."

#: ../../library/stdtypes.rst:5852
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "É escrito como ``Ellipsis`` ou ``...``."

#: ../../library/stdtypes.rst:5854
msgid ""
"In typical use, ``...`` as the ``Ellipsis`` object appears in a few "
"different places, for instance:"
msgstr ""
"Em uso típico, ``...`` como o objeto ``Ellipsis`` aparece em alguns lugares "
"diferentes, por exemplo:"

#: ../../library/stdtypes.rst:5857
msgid ""
"In type annotations, such as :ref:`callable arguments <annotating-"
"callables>` or :ref:`tuple elements <annotating-tuples>`."
msgstr ""
"Em anotações de tipo, como :ref:`argumentos chamáveis <annotating-"
"callables>` ou :ref:`elementos de tuplo <annotating-tuples>`."

#: ../../library/stdtypes.rst:5860
msgid ""
"As the body of a function instead of a :ref:`pass statement <tut-pass>`."
msgstr ""
"Como o corpo de uma função em vez de uma :ref:`instrução pass <tut-pass>`."

#: ../../library/stdtypes.rst:5862
msgid ""
"In third-party libraries, such as `Numpy's slicing and striding <https://"
"numpy.org/doc/stable/user/basics.indexing.html#slicing-and-striding>`_."
msgstr ""
"Em bibliotecas de terceiros, como `fatiamento e passos do Numpy <https://"
"numpy.org/doc/stable/user/basics.indexing.html#slicing-and-striding>`_."

#: ../../library/stdtypes.rst:5865
msgid ""
"Python also uses three dots in ways that are not ``Ellipsis`` objects, for "
"instance:"
msgstr ""
"O Python também usa três pontos de formas que não são objetos ``Ellipsis``, "
"por exemplo:"

#: ../../library/stdtypes.rst:5867
msgid ""
"Doctest's :const:`ELLIPSIS <doctest.ELLIPSIS>`, as a pattern for missing "
"content."
msgstr ""
":const:`ELLIPSIS <doctest.ELLIPSIS>` do Doctest, como um padrão para "
"conteúdo em falta."

#: ../../library/stdtypes.rst:5869
msgid ""
"The default Python prompt of the :term:`interactive` shell when partial "
"input is incomplete."
msgstr ""
"O prompt padrão do Python na :term:`shell interativa` quando a entrada "
"parcial está incompleta."

#: ../../library/stdtypes.rst:5871
msgid ""
"Lastly, the Python documentation often uses three dots in conventional "
"English usage to mean omitted content, even in code examples that also use "
"them as the ``Ellipsis``."
msgstr ""
"Por fim, a documentação do Python muitas vezes usa três pontos no uso "
"convencional do inglês para significar conteúdo omitido, mesmo em exemplos "
"de código que também os usam como ``Ellipsis``."

#: ../../library/stdtypes.rst:5879
msgid "The NotImplemented Object"
msgstr "O Objeto NotImplemented"

#: ../../library/stdtypes.rst:5881
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one :data:`NotImplemented` object. :code:"
"`type(NotImplemented)()` produces the singleton instance."
msgstr ""
"Este objeto é retornado de comparações e operações binárias quando são "
"solicitadas a operar em tipos que não suportam. Consulte :ref:`comparisons` "
"para mais informações. Existe exatamente um objeto :data:`NotImplemented`. :"
"code:`type(NotImplemented)()` produz a instância singleton."

#: ../../library/stdtypes.rst:5886
msgid "It is written as :code:`NotImplemented`."
msgstr "É escrito como :code:`NotImplemented`."

#: ../../library/stdtypes.rst:5892
msgid "Internal Objects"
msgstr "Objetos Internos"

#: ../../library/stdtypes.rst:5894
msgid ""
"See :ref:`types` for this information.  It describes :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, and "
"slice objects."
msgstr ""
"Consulte :ref:`types` para esta informação. Descreve :ref:`objetos de quadro "
"de pilha <frame-objects>`, :ref:`objetos de traceback <traceback-objects>`, "
"e objetos de fatia."

#: ../../library/stdtypes.rst:5902
msgid "Special Attributes"
msgstr "Atributos Especiais"

#: ../../library/stdtypes.rst:5904
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"A implementação adiciona alguns atributos especiais apenas de leitura a "
"vários tipos de objetos, onde são relevantes. Alguns destes não são "
"reportados pela função incorporada :func:`dir`."

#: ../../library/stdtypes.rst:5911
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "O nome da classe, função, método, descritor ou instância de gerador."

#: ../../library/stdtypes.rst:5917
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"O :term:`nome qualificado` da classe, função, método, descritor ou instância "
"de gerador."

#: ../../library/stdtypes.rst:5925
msgid "The name of the module in which a class or function was defined."
msgstr "O nome do módulo no qual uma classe ou função foi definida."

#: ../../library/stdtypes.rst:5930
msgid ""
"The documentation string of a class or function, or ``None`` if undefined."
msgstr ""
"A *string* de documentação de uma classe ou função, ou ``None`` se não "
"estiver definida."

#: ../../library/stdtypes.rst:5935
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :"
"ref:`type aliases <type-aliases>`. For classes and functions that are not "
"generic, this will be an empty tuple."
msgstr ""
"Os :ref:`parâmetros de tipo <type-params>` de classes genéricas, funções e :"
"ref:`alias de tipo <type-aliases>`. Para classes e funções que não são "
"genéricas, isto será um tuplo vazio."

#: ../../library/stdtypes.rst:5945
msgid "Integer string conversion length limitation"
msgstr "Limitação de comprimento de conversão de *string* para inteiro"

#: ../../library/stdtypes.rst:5947
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"O CPython tem um limite global para conversão entre :class:`int` e :class:"
"`str` para mitigar ataques de negação de serviço. Este limite aplica-se "
"*apenas* a bases numéricas decimais ou outras que não sejam potências de "
"dois. As conversões hexadecimal, octal e binária são ilimitadas. O limite "
"pode ser configurado."

#: ../../library/stdtypes.rst:5952
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"O tipo :class:`int` no CPython é um número de comprimento arbitrário "
"armazenado em forma binária (comumente conhecido como \"bignum\"). Não "
"existe nenhum algoritmo que possa converter uma *string* para um inteiro "
"binário ou um inteiro binário para uma *string* em tempo linear, *a menos "
"que* a base seja uma potência de 2. Mesmo os melhores algoritmos conhecidos "
"para a base 10 têm complexidade sub-quadrática. Converter um valor grande "
"como ``int('1' * 500_000)`` pode demorar mais de um segundo num CPU rápido."

#: ../../library/stdtypes.rst:5959
msgid ""
"Limiting conversion size offers a practical way to avoid :cve:`2020-10735`."
msgstr ""
"Limitar o tamanho da conversão oferece uma forma prática de evitar :cve:"
"`2020-10735`."

#: ../../library/stdtypes.rst:5961
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""
"O limite é aplicado ao número de caracteres de dígitos na *string* de "
"entrada ou saída quando um algoritmo de conversão não linear estiver "
"envolvido. Os underscores e o sinal não são contados para o limite."

#: ../../library/stdtypes.rst:5965
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""
"Quando uma operação exceder o limite, é lançada uma exceção :exc:"
"`ValueError`:"

#: ../../library/stdtypes.rst:5967
msgid ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion: "
"value has 5432 digits; use sys.set_int_max_str_digits() to increase the "
"limit\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion; "
"use sys.set_int_max_str_digits() to increase the limit\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited."
msgstr ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # Ilustrativo, este é o valor "
"predefinido.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Excede o limite (4300 dígitos) para conversão de *string* para "
"inteiro: o valor tem 5432 dígitos; use sys.set_int_max_str_digits() para "
"aumentar o limite\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Excede o limite (4300 dígitos) para conversão de *string* para "
"inteiro; use sys.set_int_max_str_digits() para aumentar o limite\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal é ilimitado."

#: ../../library/stdtypes.rst:5987
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"O limite predefinido é de 4300 dígitos, conforme fornecido em :data:`sys."
"int_info.default_max_str_digits <sys.int_info>`. O limite mais baixo que "
"pode ser configurado é de 640 dígitos, conforme fornecido em :data:`sys."
"int_info.str_digits_check_threshold <sys.int_info>`."

#: ../../library/stdtypes.rst:5992
msgid "Verification:"
msgstr "Verificação:"

#: ../../library/stdtypes.rst:5994
msgid ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."
msgstr ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."

#: ../../library/stdtypes.rst:6007
msgid "Affected APIs"
msgstr "APIs Afetadas"

#: ../../library/stdtypes.rst:6009
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""
"A limitação aplica-se apenas a conversões potencialmente lentas entre :class:"
"`int` e :class:`str` ou :class:`bytes`:"

#: ../../library/stdtypes.rst:6012
msgid "``int(string)`` with default base 10."
msgstr "``int(string)`` com base predefinida 10."

#: ../../library/stdtypes.rst:6013
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(string, base)`` para todas as bases que não são potências de 2."

#: ../../library/stdtypes.rst:6014
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: ../../library/stdtypes.rst:6015
msgid "``repr(integer)``."
msgstr "``repr(integer)``."

#: ../../library/stdtypes.rst:6016
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"qualquer outra conversão de *string* para base 10, por exemplo "
"``f\"{integer}\"``, ``\"{}\".format(integer)``, ou ``b\"%d\" % integer``."

#: ../../library/stdtypes.rst:6019
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "As limitações não se aplicam a funções com um algoritmo linear:"

#: ../../library/stdtypes.rst:6021
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(string, base)`` com base 2, 4, 8, 16 ou 32."

#: ../../library/stdtypes.rst:6022
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` e :func:`int.to_bytes`."

#: ../../library/stdtypes.rst:6023
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: ../../library/stdtypes.rst:6024
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` para números hexadecimais, octais e binários."

#: ../../library/stdtypes.rst:6025
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` para :class:`float`."

#: ../../library/stdtypes.rst:6026
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` para :class:`decimal.Decimal`."

#: ../../library/stdtypes.rst:6029
msgid "Configuring the limit"
msgstr "Configurar o limite"

#: ../../library/stdtypes.rst:6031
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""
"Antes do Python iniciar, pode usar uma variável de ambiente ou uma flag de "
"linha de comandos do interpretador para configurar o limite:"

#: ../../library/stdtypes.rst:6034
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`, por exemplo, ``PYTHONINTMAXSTRDIGITS=640 "
"python3`` para definir o limite para 640 ou ``PYTHONINTMAXSTRDIGITS=0 "
"python3`` para desativar a limitação."

#: ../../library/stdtypes.rst:6037
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`, por exemplo, ``python3 -X "
"int_max_str_digits=640``"

#: ../../library/stdtypes.rst:6039
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits` contém o valor de :envvar:"
"`PYTHONINTMAXSTRDIGITS` ou :option:`-X int_max_str_digits <-X>`. Se tanto a "
"variável de ambiente como a opção ``-X`` estiverem definidas, a opção ``-X`` "
"tem precedência. Um valor de *-1* indica que ambas não foram definidas, "
"portanto, um valor de :data:`sys.int_info.default_max_str_digits` foi usado "
"durante a inicialização."

#: ../../library/stdtypes.rst:6045
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""
"No código, pode inspecionar o limite atual e definir um novo usando estas "
"APIs do :mod:`sys`:"

#: ../../library/stdtypes.rst:6048
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
":func:`sys.get_int_max_str_digits` e :func:`sys.set_int_max_str_digits` são "
"um *getter* e um *setter* para o limite em todo o interpretador. Os "
"subinterpretadores têm o seu próprio limite."

#: ../../library/stdtypes.rst:6052
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""
"Informações sobre o predefinido e o mínimo podem ser encontradas em :data:"
"`sys.int_info`:"

#: ../../library/stdtypes.rst:6054
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` é o limite "
"predefinido compilado."

#: ../../library/stdtypes.rst:6056
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` é o valor "
"mínimo aceite para o limite (exceto 0, que o desativa)."

#: ../../library/stdtypes.rst:6063
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Definir um limite baixo *pode* levar a problemas. Embora raro, existe código "
"que contém constantes inteiras em decimal na sua origem que excedem o limite "
"mínimo. Uma consequência de definir o limite é que o código-fonte Python "
"contendo literais inteiros decimais mais longos do que o limite encontrará "
"um erro durante a análise, geralmente na inicialização, no momento da "
"importação ou até mesmo no momento da instalação - sempre que um ``.pyc`` "
"atualizado não existir para o código. Uma solução alternativa para código-"
"fonte que contém tais constantes grandes é convertê-las para a forma "
"hexadecimal ``0x``, pois não tem limite."

#: ../../library/stdtypes.rst:6072
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Teste a sua aplicação minuciosamente se usar um limite baixo. Certifique-se "
"de que os seus testes são executados com o limite definido cedo através da "
"variável de ambiente ou flag, de modo a que se aplique durante a "
"inicialização e até mesmo durante qualquer passo de instalação que possa "
"invocar o Python para pré-compilar ficheiros ``.py`` para ficheiros ``.pyc``."

#: ../../library/stdtypes.rst:6078
msgid "Recommended configuration"
msgstr "Configuração recomendada"

#: ../../library/stdtypes.rst:6080
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"O valor predefinido :data:`sys.int_info.default_max_str_digits` é esperado "
"ser razoável para a maioria das aplicações. Se a sua aplicação necessitar de "
"um limite diferente, defina-o a partir do seu ponto de entrada principal "
"usando código agnóstico à versão do Python, uma vez que estas APIs foram "
"adicionadas em lançamentos de patches de segurança em versões anteriores à "
"3.12."

#: ../../library/stdtypes.rst:6085
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/stdtypes.rst:6087
msgid ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     upper_bound = 68000\n"
"...     lower_bound = 4004\n"
"...     current_limit = sys.get_int_max_str_digits()\n"
"...     if current_limit == 0 or current_limit > upper_bound:\n"
"...         sys.set_int_max_str_digits(upper_bound)\n"
"...     elif current_limit < lower_bound:\n"
"...         sys.set_int_max_str_digits(lower_bound)"
msgstr ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     limite_superior = 68000\n"
"...     limite_inferior = 4004\n"
"...     limite_atual = sys.get_int_max_str_digits()\n"
"...     if limite_atual == 0 or limite_atual > limite_superior:\n"
"...         sys.set_int_max_str_digits(limite_superior)\n"
"...     elif limite_atual < limite_inferior:\n"
"...         sys.set_int_max_str_digits(limite_inferior)"

#: ../../library/stdtypes.rst:6097
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "Se precisar de desativá-lo completamente, defina-o para ``0``."

#: ../../library/stdtypes.rst:6101
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/stdtypes.rst:6102
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Informações adicionais sobre estes métodos especiais podem ser encontradas "
"no Manual de Referência do Python (:ref:`customization`)."

#: ../../library/stdtypes.rst:6105
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Como consequência, a lista ``[1, 2]`` é considerada igual a ``[1.0, 2.0]``, "
"e o mesmo aplica-se a tuplos."

#: ../../library/stdtypes.rst:6108
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Devem tê-los, uma vez que o analisador não consegue determinar o tipo dos "
"operandos."

#: ../../library/stdtypes.rst:6110
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Caracteres com caixa são aqueles cuja propriedade de categoria geral é uma "
"de \"Lu\" (Letra, maiúscula), \"Ll\" (Letra, minúscula) ou \"Lt\" (Letra, "
"título)."

#: ../../library/stdtypes.rst:6113
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Para formatar apenas um tuplo, deve, portanto, fornecer um tuplo singleton "
"cujo único elemento seja o tuplo a ser formatado."

#: ../../library/stdtypes.rst:13
msgid "built-in"
msgstr "incorporado"

#: ../../library/stdtypes.rst:13 ../../library/stdtypes.rst:316
#: ../../library/stdtypes.rst:393 ../../library/stdtypes.rst:950
#: ../../library/stdtypes.rst:1137 ../../library/stdtypes.rst:1159
#: ../../library/stdtypes.rst:1174 ../../library/stdtypes.rst:4826
#: ../../library/stdtypes.rst:5817
msgid "types"
msgstr "types"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:1174
#: ../../library/stdtypes.rst:4826
msgid "statement"
msgstr "instrução"

#: ../../library/stdtypes.rst:34
msgid "if"
msgstr "se"

#: ../../library/stdtypes.rst:34
msgid "while"
msgstr "enquanto"

#: ../../library/stdtypes.rst:34
msgid "truth"
msgstr "verdade"

#: ../../library/stdtypes.rst:34
msgid "value"
msgstr "valor"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:817
msgid "Boolean"
msgstr "Booleano"

#: ../../library/stdtypes.rst:34 ../../library/stdtypes.rst:81
#: ../../library/stdtypes.rst:393
msgid "operations"
msgstr "operações"

#: ../../library/stdtypes.rst:34
msgid "false"
msgstr "falso"

#: ../../library/stdtypes.rst:44
msgid "true"
msgstr "verdadeiro"

#: ../../library/stdtypes.rst:52
msgid "None (Built-in object)"
msgstr "None (Objeto incorporado)"

#: ../../library/stdtypes.rst:52
msgid "False (Built-in object)"
msgstr "False (Objeto incorporado)"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
#: ../../library/stdtypes.rst:123 ../../library/stdtypes.rst:195
#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:393
#: ../../library/stdtypes.rst:950
msgid "operator"
msgstr "operator"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "or"
msgstr "ou"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:98
msgid "and"
msgstr "e"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:817
msgid "False"
msgstr "Falso"

#: ../../library/stdtypes.rst:64 ../../library/stdtypes.rst:817
msgid "True"
msgstr "Verdadeiro"

#: ../../library/stdtypes.rst:98
msgid "not"
msgstr "não"

#: ../../library/stdtypes.rst:123
msgid "chaining"
msgstr "encadeamento"

#: ../../library/stdtypes.rst:123
msgid "comparisons"
msgstr "comparações"

#: ../../library/stdtypes.rst:123
msgid "comparison"
msgstr "comparação"

#: ../../library/stdtypes.rst:123
msgid "=="
msgstr "=="

#: ../../library/stdtypes.rst:123
msgid "< (less)"
msgstr "< (menor)"

#: ../../library/stdtypes.rst:123
msgid "<="
msgstr "<="

#: ../../library/stdtypes.rst:123
msgid "> (greater)"
msgstr "> (maior)"

#: ../../library/stdtypes.rst:123
msgid ">="
msgstr ">="

#: ../../library/stdtypes.rst:123
msgid "!="
msgstr "!="

#: ../../library/stdtypes.rst:123
msgid "is"
msgstr "é"

#: ../../library/stdtypes.rst:123
msgid "is not"
msgstr "não é"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:934 ../../library/stdtypes.rst:1137
#: ../../library/stdtypes.rst:1159 ../../library/stdtypes.rst:1324
#: ../../library/stdtypes.rst:1403 ../../library/stdtypes.rst:1447
#: ../../library/stdtypes.rst:1568 ../../library/stdtypes.rst:1604
#: ../../library/stdtypes.rst:2906 ../../library/stdtypes.rst:2925
#: ../../library/stdtypes.rst:3034 ../../library/stdtypes.rst:4616
#: ../../library/stdtypes.rst:4826 ../../library/stdtypes.rst:5309
#: ../../library/stdtypes.rst:5566 ../../library/stdtypes.rst:5736
#: ../../library/stdtypes.rst:5781
msgid "object"
msgstr "objeto"

#: ../../library/stdtypes.rst:163 ../../library/stdtypes.rst:208
#: ../../library/stdtypes.rst:229 ../../library/stdtypes.rst:316
#: ../../library/stdtypes.rst:335
msgid "numeric"
msgstr "numérico"

#: ../../library/stdtypes.rst:163
msgid "objects"
msgstr "objetos"

#: ../../library/stdtypes.rst:163
msgid "comparing"
msgstr "comparando"

#: ../../library/stdtypes.rst:173
msgid "__eq__() (instance method)"
msgstr "__eq__() (método de instância)"

#: ../../library/stdtypes.rst:173
msgid "__ne__() (instance method)"
msgstr "__ne__() (método de instância)"

#: ../../library/stdtypes.rst:173
msgid "__lt__() (instance method)"
msgstr "__lt__() (método de instância)"

#: ../../library/stdtypes.rst:173
msgid "__le__() (instance method)"
msgstr "__le__() (método de instância)"

#: ../../library/stdtypes.rst:173
msgid "__gt__() (instance method)"
msgstr "__gt__() (método de instância)"

#: ../../library/stdtypes.rst:173
msgid "__ge__() (instance method)"
msgstr "__ge__() (método de instância)"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:950
msgid "in"
msgstr "em"

#: ../../library/stdtypes.rst:195 ../../library/stdtypes.rst:950
msgid "not in"
msgstr "não em"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
#: ../../library/stdtypes.rst:393
msgid "integer"
msgstr "inteiro"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "floating-point"
msgstr "ponto flutuante"

#: ../../library/stdtypes.rst:208 ../../library/stdtypes.rst:229
msgid "complex number"
msgstr "número complexo"

#: ../../library/stdtypes.rst:208
msgid "C"
msgstr "C"

#: ../../library/stdtypes.rst:208
msgid "language"
msgstr "linguagem"

#: ../../library/stdtypes.rst:229
msgid "literals"
msgstr "literais"

#: ../../library/stdtypes.rst:229
msgid "hexadecimal"
msgstr "hexadecimal"

#: ../../library/stdtypes.rst:229
msgid "octal"
msgstr "octal"

#: ../../library/stdtypes.rst:229
msgid "binary"
msgstr "binário"

#: ../../library/stdtypes.rst:246
msgid "arithmetic"
msgstr "aritmética"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:950
#: ../../library/stdtypes.rst:1137 ../../library/stdtypes.rst:4826
#: ../../library/stdtypes.rst:5788 ../../library/stdtypes.rst:5802
#: ../../library/stdtypes.rst:5817
msgid "built-in function"
msgstr "função incorporada"

#: ../../library/stdtypes.rst:246
msgid "int"
msgstr "int"

#: ../../library/stdtypes.rst:246
msgid "float"
msgstr "float"

#: ../../library/stdtypes.rst:246
msgid "complex"
msgstr "complex"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2782
#: ../../library/stdtypes.rst:4002
msgid "+ (plus)"
msgstr "+ (mais)"

#: ../../library/stdtypes.rst:246
msgid "unary operator"
msgstr "operador unário"

#: ../../library/stdtypes.rst:246
msgid "binary operator"
msgstr "operador binário"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2782
#: ../../library/stdtypes.rst:4002
msgid "- (minus)"
msgstr "- (menos)"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2739
#: ../../library/stdtypes.rst:3959
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../library/stdtypes.rst:246
msgid "/ (slash)"
msgstr "/ (barra)"

#: ../../library/stdtypes.rst:246
msgid "//"
msgstr "//"

#: ../../library/stdtypes.rst:246 ../../library/stdtypes.rst:2703
#: ../../library/stdtypes.rst:3927
msgid "% (percent)"
msgstr "% (percentagem)"

#: ../../library/stdtypes.rst:246
msgid "**"
msgstr "**"

#: ../../library/stdtypes.rst:316 ../../library/stdtypes.rst:393
#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1174
#: ../../library/stdtypes.rst:4826
msgid "operations on"
msgstr "operações em"

#: ../../library/stdtypes.rst:316
msgid "conjugate() (complex number method)"
msgstr "conjugate() (método de número complexo)"

#: ../../library/stdtypes.rst:335 ../../library/stdtypes.rst:1672
#: ../../library/stdtypes.rst:2906 ../../library/stdtypes.rst:5817
msgid "module"
msgstr "módulo"

#: ../../library/stdtypes.rst:335
msgid "math"
msgstr "math"

#: ../../library/stdtypes.rst:335
msgid "floor() (in module math)"
msgstr "floor() (no módulo math)"

#: ../../library/stdtypes.rst:335
msgid "ceil() (in module math)"
msgstr "ceil() (no módulo math)"

#: ../../library/stdtypes.rst:335
msgid "trunc() (in module math)"
msgstr "trunc() (no módulo math)"

#: ../../library/stdtypes.rst:335
msgid "conversions"
msgstr "conversões"

#: ../../library/stdtypes.rst:393
msgid "bitwise"
msgstr "bit a bit"

#: ../../library/stdtypes.rst:393
msgid "shifting"
msgstr "deslocamento"

#: ../../library/stdtypes.rst:393
msgid "masking"
msgstr "mascaramento"

#: ../../library/stdtypes.rst:393
msgid "| (vertical bar)"
msgstr "| (barra vertical)"

#: ../../library/stdtypes.rst:393
msgid "^ (caret)"
msgstr "^ (acento circunflexo)"

#: ../../library/stdtypes.rst:393
msgid "& (ampersand)"
msgstr "& (e comercial)"

#: ../../library/stdtypes.rst:393
msgid "<<"
msgstr "<<"

#: ../../library/stdtypes.rst:393
msgid ">>"
msgstr ">>"

#: ../../library/stdtypes.rst:393
msgid "~ (tilde)"
msgstr "~ (til)"

#: ../../library/stdtypes.rst:817
msgid "values"
msgstr "valores"

#: ../../library/stdtypes.rst:847
msgid "iterator protocol"
msgstr "protocolo de iterador"

#: ../../library/stdtypes.rst:847 ../../library/stdtypes.rst:5222
msgid "protocol"
msgstr "protocolo"

#: ../../library/stdtypes.rst:847
msgid "iterator"
msgstr "iterador"

#: ../../library/stdtypes.rst:847 ../../library/stdtypes.rst:934
#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1137
#: ../../library/stdtypes.rst:1159 ../../library/stdtypes.rst:1174
msgid "sequence"
msgstr "sequência"

#: ../../library/stdtypes.rst:847
msgid "iteration"
msgstr "iteração"

#: ../../library/stdtypes.rst:847
msgid "container"
msgstr "contentor"

#: ../../library/stdtypes.rst:847
msgid "iteration over"
msgstr "iteração sobre"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:4826
msgid "len"
msgstr "len"

#: ../../library/stdtypes.rst:950
msgid "min"
msgstr "mínimo"

#: ../../library/stdtypes.rst:950
msgid "max"
msgstr "máximo"

#: ../../library/stdtypes.rst:950
msgid "concatenation"
msgstr "concatenação"

#: ../../library/stdtypes.rst:950
msgid "operation"
msgstr "operação"

#: ../../library/stdtypes.rst:950
msgid "repetition"
msgstr "repetição"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1174
msgid "subscript"
msgstr "índice"

#: ../../library/stdtypes.rst:950 ../../library/stdtypes.rst:1174
msgid "slice"
msgstr "fatia"

#: ../../library/stdtypes.rst:997
msgid "loop"
msgstr "ciclo"

#: ../../library/stdtypes.rst:997
msgid "over mutable sequence"
msgstr "sobre sequência mutável"

#: ../../library/stdtypes.rst:997
msgid "mutable sequence"
msgstr "sequência mutável"

#: ../../library/stdtypes.rst:997
msgid "loop over"
msgstr "ciclo sobre"

#: ../../library/stdtypes.rst:1137
msgid "immutable"
msgstr "imutável"

#: ../../library/stdtypes.rst:1137 ../../library/stdtypes.rst:1403
msgid "tuple"
msgstr "tupla"

#: ../../library/stdtypes.rst:1137
msgid "hash"
msgstr "hash"

#: ../../library/stdtypes.rst:1159
msgid "mutable"
msgstr "mutável"

#: ../../library/stdtypes.rst:1159 ../../library/stdtypes.rst:1174
#: ../../library/stdtypes.rst:1324
msgid "list"
msgstr "lista"

#: ../../library/stdtypes.rst:1159 ../../library/stdtypes.rst:2906
#: ../../library/stdtypes.rst:3034 ../../library/stdtypes.rst:3108
#: ../../library/stdtypes.rst:3927
msgid "bytearray"
msgstr "bytearray"

#: ../../library/stdtypes.rst:1174 ../../library/stdtypes.rst:4826
#: ../../library/stdtypes.rst:5566 ../../library/stdtypes.rst:5817
msgid "type"
msgstr "tipo"

#: ../../library/stdtypes.rst:1174
msgid "assignment"
msgstr "atribuição"

#: ../../library/stdtypes.rst:1174 ../../library/stdtypes.rst:4826
msgid "del"
msgstr "del"

#: ../../library/stdtypes.rst:1447
msgid "range"
msgstr "intervalo"

#: ../../library/stdtypes.rst:1568 ../../library/stdtypes.rst:1617
#: ../../library/stdtypes.rst:1664 ../../library/stdtypes.rst:2557
#: ../../library/stdtypes.rst:2703
msgid "string"
msgstr "string"

#: ../../library/stdtypes.rst:1568
msgid "text sequence type"
msgstr "tipo de sequência de texto"

#: ../../library/stdtypes.rst:1568 ../../library/stdtypes.rst:1617
#: ../../library/stdtypes.rst:1637
msgid "str (built-in class)"
msgstr "str (classe incorporada)"

#: ../../library/stdtypes.rst:1568
msgid "(see also string)"
msgstr "(ver também string)"

#: ../../library/stdtypes.rst:1604
msgid "io.StringIO"
msgstr "io.StringIO"

#: ../../library/stdtypes.rst:1637 ../../library/stdtypes.rst:2898
msgid "buffer protocol"
msgstr "protocolo de buffer"

#: ../../library/stdtypes.rst:1637 ../../library/stdtypes.rst:2906
#: ../../library/stdtypes.rst:2925 ../../library/stdtypes.rst:3108
#: ../../library/stdtypes.rst:3927
msgid "bytes"
msgstr "bytes"

#: ../../library/stdtypes.rst:1664 ../../library/stdtypes.rst:3108
msgid "methods"
msgstr "métodos"

#: ../../library/stdtypes.rst:1672
msgid "re"
msgstr "re"

#: ../../library/stdtypes.rst:2369 ../../library/stdtypes.rst:3781
msgid "universal newlines"
msgstr "novas linhas universais"

#: ../../library/stdtypes.rst:2369
msgid "str.splitlines method"
msgstr "método str.splitlines"

#: ../../library/stdtypes.rst:2557
msgid "! formatted string literal"
msgstr "literal de string formatada"

#: ../../library/stdtypes.rst:2557
msgid "formatted string literals"
msgstr "literais de string formatadas"

#: ../../library/stdtypes.rst:2557
msgid "! f-string"
msgstr "f-string"

#: ../../library/stdtypes.rst:2557
msgid "f-strings"
msgstr "*f-strings*"

#: ../../library/stdtypes.rst:2557
msgid "fstring"
msgstr "f-string"

#: ../../library/stdtypes.rst:2557
msgid "interpolated string literal"
msgstr "literal de string interpolada"

#: ../../library/stdtypes.rst:2557
msgid "formatted literal"
msgstr "literal formatada"

#: ../../library/stdtypes.rst:2557
msgid "interpolated literal"
msgstr "literal interpolada"

#: ../../library/stdtypes.rst:2557
msgid "{} (curly brackets)"
msgstr "{} (chavetas)"

#: ../../library/stdtypes.rst:2557
msgid "in formatted string literal"
msgstr "em literal de string formatada"

#: ../../library/stdtypes.rst:2557
msgid "! (exclamation mark)"
msgstr "! (ponto de exclamação)"

#: ../../library/stdtypes.rst:2557
msgid ": (colon)"
msgstr ": (dois pontos)"

#: ../../library/stdtypes.rst:2557
msgid "= (equals)"
msgstr "= (igual)"

#: ../../library/stdtypes.rst:2557
msgid "for help in debugging using string literals"
msgstr "para ajuda na depuração usando literais de string"

#: ../../library/stdtypes.rst:2703
msgid "formatting, string (%)"
msgstr "formatação, string (%)"

#: ../../library/stdtypes.rst:2703
msgid "interpolation, string (%)"
msgstr "interpolação, string (%)"

#: ../../library/stdtypes.rst:2703
msgid "formatting, printf"
msgstr "formatação, printf"

#: ../../library/stdtypes.rst:2703
msgid "interpolation, printf"
msgstr "interpolação, printf"

#: ../../library/stdtypes.rst:2703 ../../library/stdtypes.rst:3927
msgid "printf-style formatting"
msgstr "formatação estilo printf"

#: ../../library/stdtypes.rst:2703 ../../library/stdtypes.rst:3927
msgid "sprintf-style formatting"
msgstr "formatação estilo sprintf"

#: ../../library/stdtypes.rst:2739 ../../library/stdtypes.rst:3959
msgid "() (parentheses)"
msgstr "() (parênteses)"

#: ../../library/stdtypes.rst:2739 ../../library/stdtypes.rst:2782
#: ../../library/stdtypes.rst:3959 ../../library/stdtypes.rst:4002
msgid "in printf-style formatting"
msgstr "em formatação estilo printf"

#: ../../library/stdtypes.rst:2739 ../../library/stdtypes.rst:3959
msgid ". (dot)"
msgstr ". (ponto)"

#: ../../library/stdtypes.rst:2782 ../../library/stdtypes.rst:4002
msgid "# (hash)"
msgstr "# (cerquilha)"

#: ../../library/stdtypes.rst:2782 ../../library/stdtypes.rst:4002
msgid "space"
msgstr "espaço"

#: ../../library/stdtypes.rst:2898
msgid "binary sequence types"
msgstr "tipos de sequências binárias"

#: ../../library/stdtypes.rst:2906
msgid "memoryview"
msgstr "memoryview"

#: ../../library/stdtypes.rst:2906
msgid "array"
msgstr "array"

#: ../../library/stdtypes.rst:3781
msgid "bytes.splitlines method"
msgstr "método bytes.splitlines"

#: ../../library/stdtypes.rst:3781
msgid "bytearray.splitlines method"
msgstr "método bytearray.splitlines"

#: ../../library/stdtypes.rst:3927
msgid "formatting"
msgstr "formatação"

#: ../../library/stdtypes.rst:3927
msgid "bytes (%)"
msgstr "bytes (%)"

#: ../../library/stdtypes.rst:3927
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: ../../library/stdtypes.rst:3927
msgid "interpolation"
msgstr "interpolação"

#: ../../library/stdtypes.rst:4616
msgid "set"
msgstr "conjunto"

#: ../../library/stdtypes.rst:4826
msgid "mapping"
msgstr "mapeamento"

#: ../../library/stdtypes.rst:4826
msgid "dictionary"
msgstr "dicionário"

#: ../../library/stdtypes.rst:4933
msgid "__missing__()"
msgstr "__missing__()"

#: ../../library/stdtypes.rst:5222
msgid "context manager"
msgstr "gestor de contexto"

#: ../../library/stdtypes.rst:5222
msgid "context management protocol"
msgstr "protocolo de gestão de contexto"

#: ../../library/stdtypes.rst:5222
msgid "context management"
msgstr "gestão de contexto"

#: ../../library/stdtypes.rst:5297
msgid "annotation"
msgstr "anotação"

#: ../../library/stdtypes.rst:5297
msgid "type annotation; type hint"
msgstr "anotação de tipo; dica de tipo"

#: ../../library/stdtypes.rst:5309
msgid "GenericAlias"
msgstr "GenericAlias"

#: ../../library/stdtypes.rst:5309
msgid "Generic"
msgstr "Genérico"

#: ../../library/stdtypes.rst:5309
msgid "Alias"
msgstr "Alias"

#: ../../library/stdtypes.rst:5566
msgid "Union"
msgstr "União"

#: ../../library/stdtypes.rst:5566
msgid "union"
msgstr "união"

#: ../../library/stdtypes.rst:5736
msgid "method"
msgstr "método"

#: ../../library/stdtypes.rst:5781
msgid "code"
msgstr "código"

#: ../../library/stdtypes.rst:5781
msgid "code object"
msgstr "objeto código"

#: ../../library/stdtypes.rst:5788
msgid "compile"
msgstr "compile"

#: ../../library/stdtypes.rst:5788
msgid "__code__ (function object attribute)"
msgstr "__code__ (atributo de objeto função)"

#: ../../library/stdtypes.rst:5802
msgid "exec"
msgstr "exec"

#: ../../library/stdtypes.rst:5802
msgid "eval"
msgstr "eval"

#: ../../library/stdtypes.rst:5841
msgid "..."
msgstr "..."

#: ../../library/stdtypes.rst:5841
msgid "ellipsis literal"
msgstr "literal de reticências"
