# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-05 14:19+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/threading.rst:2
msgid ":mod:`!threading` --- Thread-based parallelism"
msgstr ":mod:`!threading` --- Paralelismo baseado em threads"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Código-fonte:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr ""
"Este módulo constrói interfaces de threads de nível superior sobre o módulo "
"de nível inferior :mod:`_thread`."

#: ../../library/threading.rst:194 ../../library/threading.rst:293
#: ../../library/threading.rst:678 ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Disponibilidade"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Este módulo não funciona ou não está disponível em WebAssembly. Consulte :"
"ref:`wasm-availability` para mais informações."

#: ../../library/threading.rst:17
msgid "Introduction"
msgstr "Introdução"

#: ../../library/threading.rst:19
msgid ""
"The :mod:`!threading` module provides a way to run multiple `threads "
"<https://en.wikipedia.org/wiki/Thread_(computing)>`_ (smaller units of a "
"process) concurrently within a single process. It allows for the creation "
"and management of threads, making it possible to execute tasks in parallel, "
"sharing memory space. Threads are particularly useful when tasks are I/O "
"bound, such as file operations or making network requests, where much of the "
"time is spent waiting for external resources."
msgstr ""
"O módulo :mod:`!threading` fornece uma forma de executar múltiplas `threads "
"<https://en.wikipedia.org/wiki/Thread_(computing)>`_` (unidades mais "
"pequenas de um processo) concorrentemente dentro de um único processo. "
"Permite a criação e gestão de threads, tornando possível executar tarefas em "
"paralelo, partilhando o espaço de memória. As threads são particularmente "
"úteis quando as tarefas são limitadas por I/O, como operações de ficheiros "
"ou pedidos de rede, onde grande parte do tempo é gasto à espera de recursos "
"externos."

#: ../../library/threading.rst:27
msgid ""
"A typical use case for :mod:`!threading` includes managing a pool of worker "
"threads that can process multiple tasks concurrently.  Here's a basic "
"example of creating and starting threads using :class:`~threading.Thread`::"
msgstr ""
"Um caso de uso típico para :mod:`!threading` inclui a gestão de um conjunto "
"de threads de trabalho que podem processar múltiplas tarefas "
"concorrentemente. Aqui está um exemplo básico de criação e início de threads "
"usando :class:`~threading.Thread`:"

#: ../../library/threading.rst:31
msgid ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"    print(f\"crawl started for {link}\")\n"
"    time.sleep(delay)  # Blocking I/O (simulating a network request)\n"
"    print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"    \"https://python.org\",\n"
"    \"https://docs.python.org\",\n"
"    \"https://peps.python.org\",\n"
"]\n"
"\n"
"# Start threads for each link\n"
"threads = []\n"
"for link in links:\n"
"    # Using `args` to pass positional arguments and `kwargs` for keyword "
"arguments\n"
"    t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"    threads.append(t)\n"
"\n"
"# Start each thread\n"
"for t in threads:\n"
"    t.start()\n"
"\n"
"# Wait for all threads to finish\n"
"for t in threads:\n"
"    t.join()"
msgstr ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"    print(f\"início do crawl para {link}\")\n"
"    time.sleep(delay)  # I/O bloqueante (simulando um pedido de rede)\n"
"    print(f\"fim do crawl para {link}\")\n"
"\n"
"links = [\n"
"    \"https://python.org\",\n"
"    \"https://docs.python.org\",\n"
"    \"https://peps.python.org\",\n"
"]\n"
"\n"
"# Iniciar threads para cada link\n"
"threads = []\n"
"for link in links:\n"
"    # Usar `args` para passar argumentos posicionais e `kwargs` para "
"argumentos nomeados\n"
"    t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"    threads.append(t)\n"
"\n"
"# Iniciar cada thread\n"
"for t in threads:\n"
"    t.start()\n"
"\n"
"# Esperar que todas as threads terminem\n"
"for t in threads:\n"
"    t.join()"

#: ../../library/threading.rst:60
msgid "This module used to be optional, it is now always available."
msgstr "Este módulo costumava ser opcional, agora está sempre disponível."

#: ../../library/threading.rst:65
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` oferece uma interface de "
"nível superior para enviar tarefas para uma thread em segundo plano sem "
"bloquear a execução da thread chamadora, enquanto ainda é possível recuperar "
"os seus resultados quando necessário."

#: ../../library/threading.rst:69
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""
":mod:`queue` fornece uma interface segura para threads para trocar dados "
"entre threads em execução."

#: ../../library/threading.rst:72
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""
":mod:`asyncio` oferece uma abordagem alternativa para alcançar concorrência "
"a nível de tarefa sem exigir o uso de múltiplas threads do sistema operativo."

#: ../../library/threading.rst:77
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""
"Na série Python 2.x, este módulo continha nomes ``camelCase`` para alguns "
"métodos e funções. Estes estão obsoleto desde o Python 3.10, mas ainda são "
"suportados para compatibilidade com o Python 2.5 e versões anteriores."

#: ../../library/threading.rst:84
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"No CPython, devido ao :term:`Global Interpreter Lock <global interpreter "
"lock>`, apenas uma thread pode executar código Python de cada vez (embora "
"certas bibliotecas orientadas para desempenho possam superar esta "
"limitação). Se pretender que a sua aplicação utilize melhor os recursos "
"computacionais de máquinas multi-núcleo, é aconselhado a usar :mod:"
"`multiprocessing` ou :class:`concurrent.futures.ProcessPoolExecutor`. No "
"entanto, as threads ainda são um modelo apropriado se pretender executar "
"múltiplas tarefas limitadas por I/O simultaneamente."

#: ../../library/threading.rst:95
msgid "GIL and performance considerations"
msgstr "Considerações sobre o GIL e desempenho"

#: ../../library/threading.rst:97
msgid ""
"Unlike the :mod:`multiprocessing` module, which uses separate processes to "
"bypass the :term:`global interpreter lock` (GIL), the threading module "
"operates within a single process, meaning that all threads share the same "
"memory space. However, the GIL limits the performance gains of threading "
"when it comes to CPU-bound tasks, as only one thread can execute Python "
"bytecode at a time. Despite this, threads remain a useful tool for achieving "
"concurrency in many scenarios."
msgstr ""
"Ao contrário do módulo :mod:`multiprocessing`, que usa processos separados "
"para contornar o :term:`global interpreter lock` (GIL), o módulo threading "
"opera dentro de um único processo, o que significa que todas as threads "
"partilham o mesmo espaço de memória. No entanto, o GIL limita os ganhos de "
"desempenho das threads quando se trata de tarefas limitadas pela CPU, uma "
"vez que apenas uma thread pode executar bytecode Python de cada vez. Apesar "
"disso, as threads continuam a ser uma ferramenta útil para alcançar "
"concorrência em muitos cenários."

#: ../../library/threading.rst:105
msgid ""
"As of Python 3.13, :term:`free-threaded <free threading>` builds can disable "
"the GIL, enabling true parallel execution of threads, but this feature is "
"not available by default (see :pep:`703`)."
msgstr ""
"A partir do Python 3.13, as compilações :term:`free-threaded <free "
"threading>` podem desativar o GIL, permitindo a execução paralela real de "
"threads, mas esta funcionalidade não está disponível por predefinição "
"(consulte :pep:`703`)."

#: ../../library/threading.rst:112
msgid "Reference"
msgstr "Referência"

#: ../../library/threading.rst:114
msgid "This module defines the following functions:"
msgstr "Este módulo define as seguintes funções:"

#: ../../library/threading.rst:119
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Devolve o número de objetos :class:`Thread` atualmente ativos. O número "
"devolvido é igual ao comprimento da lista devolvida por :func:`.enumerate`."

#: ../../library/threading.rst:122
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "A função ``activeCount`` é um alias obsoleto para esta função."

#: ../../library/threading.rst:127
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`!threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"Devolve o objeto :class:`Thread` atual, correspondente à thread de controlo "
"do chamador. Se a thread de controlo do chamador não foi criada através do "
"módulo :mod:`!threading`, é devolvido um objeto thread fictício com "
"funcionalidade limitada."

#: ../../library/threading.rst:132
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr "A função ``currentThread`` é um alias obsoleto para esta função."

#: ../../library/threading.rst:137
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "Trata exceções não capturadas levantadas por :func:`Thread.run`."

#: ../../library/threading.rst:139
msgid "The *args* argument has the following attributes:"
msgstr "O argumento *args* tem os seguintes atributos:"

#: ../../library/threading.rst:141
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: Tipo de exceção."

#: ../../library/threading.rst:142
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*: Valor da exceção, pode ser ``None``."

#: ../../library/threading.rst:143
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: Traceback da exceção, pode ser ``None``."

#: ../../library/threading.rst:144
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*thread*: Thread que levantou a exceção, pode ser ``None``."

#: ../../library/threading.rst:146
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"Se *exc_type* for :exc:`SystemExit`, a exceção é ignorada silenciosamente. "
"Caso contrário, a exceção é impressa em :data:`sys.stderr`."

#: ../../library/threading.rst:149
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""

#: ../../library/threading.rst:152
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` pode ser substituída para controlar como as "
"exceções não capturadas levantadas por :func:`Thread.run` são tratadas."

#: ../../library/threading.rst:155
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr ""
"Armazenar *exc_value* usando um gancho personalizado pode criar um ciclo de "
"referência. Deve ser limpo explicitamente para quebrar o ciclo de referência "
"quando a exceção já não for necessária."

#: ../../library/threading.rst:159
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"Armazenar *thread* usando um gancho personalizado pode ressuscitá-lo se for "
"definido para um objeto que está a ser finalizado. Evite armazenar *thread* "
"após o gancho personalizado ser concluído para evitar ressuscitar objetos."

#: ../../library/threading.rst:164
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` trata exceções não capturadas."

#: ../../library/threading.rst:170
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"Contém o valor original de :func:`threading.excepthook`. É guardado para que "
"o valor original possa ser restaurado caso venha a ser substituído por "
"objetos quebrados ou alternativos."

#: ../../library/threading.rst:178
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Devolve o 'identificador de thread' da thread atual. Este é um inteiro não "
"nulo. O seu valor não tem significado direto; é destinado a ser usado como "
"um cookie mágico, por exemplo, para indexar um dicionário de dados "
"específicos de thread. Os identificadores de thread podem ser reciclados "
"quando uma thread termina e outra thread é criada."

#: ../../library/threading.rst:189
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Devolve o ID de thread integral nativo da thread atual atribuído pelo "
"kernel. Este é um inteiro não negativo. O seu valor pode ser usado para "
"identificar de forma única esta thread em todo o sistema (até que a thread "
"termine, após o que o valor pode ser reciclado pelo sistema operativo)."

#: ../../library/threading.rst:198
msgid "Added support for GNU/kFreeBSD."
msgstr "Adicionado suporte para GNU/kFreeBSD."

#: ../../library/threading.rst:204
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""
"Devolve uma lista de todos os objetos :class:`Thread` atualmente ativos. A "
"lista inclui threads daemónicas e objetos de thread fictícios criados por :"
"func:`current_thread`. Exclui threads terminadas e threads que ainda não "
"foram iniciadas. No entanto, a thread principal faz sempre parte do "
"resultado, mesmo quando terminada."

#: ../../library/threading.rst:213
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Devolve o objeto :class:`Thread` principal. Em condições normais, a thread "
"principal é a thread a partir da qual o interpretador Python foi iniciado."

#: ../../library/threading.rst:224
msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"Define uma função de rastreamento para todas as threads iniciadas a partir "
"do módulo :mod:`!threading`. A função *func* será passada para :func:`sys."
"settrace` para cada thread, antes de o seu método :meth:`~Thread.run` ser "
"chamado."

#: ../../library/threading.rst:230
msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr ""
"Define uma função de rastreamento para todas as threads iniciadas a partir "
"do módulo :mod:`!threading` e todas as threads Python que estão atualmente "
"em execução."

#: ../../library/threading.rst:233
msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"A função *func* será passada para :func:`sys.settrace` para cada thread, "
"antes de o seu método :meth:`~Thread.run` ser chamado."

#: ../../library/threading.rst:244
msgid "Get the trace function as set by :func:`settrace`."
msgstr "Obtém a função de rastreamento definida por :func:`settrace`."

#: ../../library/threading.rst:253
msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"Define uma função de perfil para todas as threads iniciadas a partir do "
"módulo :mod:`!threading`. A função *func* será passada para :func:`sys."
"setprofile` para cada thread, antes de o seu método :meth:`~Thread.run` ser "
"chamado."

#: ../../library/threading.rst:259
msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr ""
"Define uma função de perfil para todas as threads iniciadas a partir do "
"módulo :mod:`!threading` e todas as threads Python que estão atualmente em "
"execução."

#: ../../library/threading.rst:262
msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"A função *func* será passada para :func:`sys.setprofile` para cada thread, "
"antes de o seu método :meth:`~Thread.run` ser chamado."

#: ../../library/threading.rst:271
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "Obtém a função de perfil definida por :func:`setprofile`."

#: ../../library/threading.rst:278
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Devolve o tamanho da pilha de thread usado ao criar novas threads. O "
"argumento opcional *size* especifica o tamanho da pilha a ser usado para "
"threads criadas posteriormente, e deve ser 0 (usar o valor predefinido da "
"plataforma ou configurado) ou um valor inteiro positivo de pelo menos 32.768 "
"(32 KiB). Se *size* não for especificado, é usado 0. Se a alteração do "
"tamanho da pilha da thread não for suportada, é levantado um :exc:"
"`RuntimeError`. Se o tamanho da pilha especificado for inválido, é levantado "
"um :exc:`ValueError` e o tamanho da pilha permanece inalterado. 32 KiB é "
"atualmente o valor mínimo suportado para o tamanho da pilha para garantir "
"espaço de pilha suficiente para o próprio interpretador. Note que algumas "
"plataformas podem ter restrições específicas sobre os valores para o tamanho "
"da pilha, como exigir um tamanho mínimo de pilha > 32 KiB ou exigir alocação "
"em múltiplos do tamanho da página de memória do sistema - a documentação da "
"plataforma deve ser consultada para obter mais informações (páginas de 4 KiB "
"são comuns; usar múltiplos de 4096 para o tamanho da pilha é a abordagem "
"sugerida na ausência de informações mais específicas)."

#: ../../library/threading.rst:295
msgid "Unix platforms with POSIX threads support."
msgstr "Plataformas Unix com suporte para threads POSIX."

#: ../../library/threading.rst:298
msgid "This module also defines the following constant:"
msgstr "Este módulo também define a seguinte constante:"

#: ../../library/threading.rst:302
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"O valor máximo permitido para o parâmetro *timeout* de funções bloqueantes (:"
"meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Especificar um timeout maior que este valor levantará um :exc:"
"`OverflowError`."

#: ../../library/threading.rst:310
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr ""
"Este módulo define várias classes, que são detalhadas nas secções abaixo."

#: ../../library/threading.rst:313
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"O design deste módulo é vagamente baseado no modelo de threads do Java. No "
"entanto, enquanto o Java faz com que bloqueios e variáveis de condição sejam "
"comportamentos básicos de cada objeto, em Python, eles são objetos "
"separados. A classe :class:`Thread` do Python suporta um subconjunto do "
"comportamento da classe Thread do Java; atualmente, não há prioridades, não "
"há grupos de threads, e as threads não podem ser destruídas, paradas, "
"suspensas, retomadas ou interrompidas. Os métodos estáticos da classe Thread "
"do Java, quando implementados, são mapeados para funções a nível de módulo."

#: ../../library/threading.rst:321
msgid "All of the methods described below are executed atomically."
msgstr "Todos os métodos descritos abaixo são executados atomicamente."

#: ../../library/threading.rst:325
msgid "Thread-local data"
msgstr "Dados locais de thread"

#: ../../library/threading.rst:327
msgid ""
"Thread-local data is data whose values are thread specific. If you have data "
"that you want to be local to a thread, create a :class:`local` object and "
"use its attributes::"
msgstr ""
"Dados locais de thread são dados cujos valores são específicos de thread. Se "
"tiver dados que deseja que sejam locais a uma thread, crie um objeto :class:"
"`local` e use os seus atributos:"

#: ../../library/threading.rst:331
msgid ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"

#: ../../library/threading.rst:336
msgid "You can also access the :class:`local`-object's dictionary::"
msgstr "Também pode aceder ao dicionário do objeto :class:`local`:"

#: ../../library/threading.rst:338
msgid ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"
msgstr ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"

#: ../../library/threading.rst:345
msgid "If we access the data in a different thread::"
msgstr "Se acedermos aos dados em uma thread diferente:"

#: ../../library/threading.rst:347
msgid ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"
msgstr ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"

#: ../../library/threading.rst:361
msgid ""
"we get different data.  Furthermore, changes made in the other thread don't "
"affect data seen in this thread::"
msgstr ""
"obtemos dados diferentes. Além disso, as alterações feitas na outra thread "
"não afetam os dados vistos nesta thread:"

#: ../../library/threading.rst:364
msgid ""
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata.number\n"
"42"

#: ../../library/threading.rst:367
msgid ""
"Of course, values you get from a :class:`local` object, including their :"
"attr:`~object.__dict__` attribute, are for whatever thread was current at "
"the time the attribute was read.  For that reason, you generally don't want "
"to save these values across threads, as they apply only to the thread they "
"came from."
msgstr ""
"Claro, os valores que obtém de um objeto :class:`local`, incluindo o seu "
"atributo :attr:`~object.__dict__`, são para qualquer thread que estava ativa "
"no momento em que o atributo foi lido. Por essa razão, geralmente não deseja "
"guardar esses valores entre threads, pois eles se aplicam apenas à thread de "
"onde vieram."

#: ../../library/threading.rst:373
msgid ""
"You can create custom :class:`local` objects by subclassing the :class:"
"`local` class::"
msgstr ""
"Pode criar objetos :class:`local` personalizados ao criar subclasses da "
"classe :class:`local`:"

#: ../../library/threading.rst:376
msgid ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"
msgstr ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"

#: ../../library/threading.rst:383
msgid ""
"This can be useful to support default values, methods and initialization.  "
"Note that if you define an :py:meth:`~object.__init__` method, it will be "
"called each time the :class:`local` object is used in a separate thread.  "
"This is necessary to initialize each thread's dictionary."
msgstr ""
"Isto pode ser útil para suportar valores predefinidos, métodos e "
"inicialização. Note que se definir um método :py:meth:`~object.__init__`, "
"ele será chamado cada vez que o objeto :class:`local` for usado em uma "
"thread separada. Isto é necessário para inicializar o dicionário de cada "
"thread."

#: ../../library/threading.rst:389
msgid "Now if we create a :class:`local` object::"
msgstr "Agora, se criarmos um objeto :class:`local`:"

#: ../../library/threading.rst:391
msgid ">>> mydata = MyLocal(color='red')"
msgstr ">>> mydata = MyLocal(color='red')"

#: ../../library/threading.rst:393
msgid "we have a default number::"
msgstr "temos um número predefinido:"

#: ../../library/threading.rst:395
msgid ""
">>> mydata.number\n"
"2"
msgstr ""
">>> mydata.number\n"
"2"

#: ../../library/threading.rst:398
msgid "an initial color::"
msgstr "uma cor inicial:"

#: ../../library/threading.rst:400
msgid ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"
msgstr ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"

#: ../../library/threading.rst:404
msgid "And a method that operates on the data::"
msgstr "E um método que opera nos dados:"

#: ../../library/threading.rst:406
msgid ""
">>> mydata.squared()\n"
"4"
msgstr ""
">>> mydata.squared()\n"
"4"

#: ../../library/threading.rst:409
msgid "As before, we can access the data in a separate thread::"
msgstr "Como antes, podemos aceder aos dados em uma thread separada:"

#: ../../library/threading.rst:411
msgid ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"
msgstr ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"

#: ../../library/threading.rst:418
msgid "without affecting this thread's data::"
msgstr "sem afetar os dados desta thread:"

#: ../../library/threading.rst:420
msgid ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: 'MyLocal' object has no attribute 'color'"
msgstr ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: o objeto 'MyLocal' não tem o atributo 'color'"

#: ../../library/threading.rst:427
msgid ""
"Note that subclasses can define :term:`__slots__`, but they are not thread "
"local. They are shared across threads::"
msgstr ""
"Note que as subclasses podem definir :term:`__slots__`, mas não são locais "
"de thread. São partilhados entre threads:"

#: ../../library/threading.rst:430
msgid ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"
msgstr ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"

#: ../../library/threading.rst:437
msgid "So, the separate thread::"
msgstr "Portanto, a thread separada:"

#: ../../library/threading.rst:439
msgid ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"
msgstr ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"

#: ../../library/threading.rst:443
msgid "affects what we see::"
msgstr "afeta o que vemos:"

#: ../../library/threading.rst:445
msgid ""
">>> mydata.number\n"
"11"
msgstr ""
">>> mydata.number\n"
"11"

#: ../../library/threading.rst:451
msgid "A class that represents thread-local data."
msgstr "Uma classe que representa dados locais de thread."

#: ../../library/threading.rst:457
msgid "Thread objects"
msgstr "Objetos Thread"

#: ../../library/threading.rst:459
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the "
"``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""
"A classe :class:`Thread` representa uma atividade que é executada numa "
"thread de controlo separada. Existem duas formas de especificar a atividade: "
"passando um objeto chamável para o construtor ou substituindo o método :meth:"
"`~Thread.run` numa subclasse. Nenhum outro método (exceto o construtor) deve "
"ser substituído numa subclasse. Em outras palavras, *apenas* substitua os "
"métodos ``__init__()`` e :meth:`~Thread.run` desta classe."

#: ../../library/threading.rst:466
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"Uma vez criado um objeto thread, a sua atividade deve ser iniciada chamando "
"o método :meth:`~Thread.start` da thread. Isto invoca o método :meth:"
"`~Thread.run` numa thread de controlo separada."

#: ../../library/threading.rst:470
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"Uma vez iniciada a atividade da thread, a thread é considerada 'ativa'. "
"Deixa de estar ativa quando o seu método :meth:`~Thread.run` termina — "
"normalmente ou levantando uma exceção não tratada. O método :meth:`~Thread."
"is_alive` verifica se a thread está ativa."

#: ../../library/threading.rst:475
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"Outras threads podem chamar o método :meth:`~Thread.join` de uma thread. "
"Isto bloqueia a thread chamadora até que a thread cujo método :meth:`~Thread."
"join` é chamado termine."

#: ../../library/threading.rst:479
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"Uma thread tem um nome. O nome pode ser passado para o construtor e lido ou "
"alterado através do atributo :attr:`~Thread.name`."

#: ../../library/threading.rst:482
msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""
"Se o método :meth:`~Thread.run` levantar uma exceção, :func:`threading."
"excepthook` é chamado para tratá-la. Por predefinição, :func:`threading."
"excepthook` ignora silenciosamente :exc:`SystemExit`."

#: ../../library/threading.rst:486
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"Uma thread pode ser marcada como uma \"thread daemon\". O significado desta "
"marcação é que todo o programa Python termina quando apenas threads daemon "
"permanecem. O valor inicial é herdado da thread que a criou. A marcação pode "
"ser definida através da propriedade :attr:`~Thread.daemon` ou do argumento "
"*daemon* do construtor."

#: ../../library/threading.rst:493
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"As threads daemon são abruptamente paradas no encerramento. Os seus recursos "
"(como ficheiros abertos, transações de base de dados, etc.) podem não ser "
"libertados corretamente. Se pretender que as suas threads parem de forma "
"elegante, faça-as não daemon e use um mecanismo de sinalização adequado, "
"como um :class:`Event`."

#: ../../library/threading.rst:498
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"Existe um objeto \"thread principal\"; isto corresponde à thread de controlo "
"inicial no programa Python. Não é uma thread daemon."

#: ../../library/threading.rst:501
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""
"Existe a possibilidade de serem criados \"objetos thread fictícios\". Estes "
"são objetos thread correspondentes a \"threads alienígenas\", que são "
"threads de controlo iniciadas fora do módulo threading, como diretamente a "
"partir de código C. Os objetos thread fictícios têm funcionalidade limitada; "
"são sempre considerados ativos e daemon, e não podem ser :ref:`unidos <meth-"
"thread-join>`. Nunca são eliminados, uma vez que é impossível detetar a "
"terminação de threads alienígenas."

#: ../../library/threading.rst:512
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Este construtor deve ser sempre chamado com argumentos nomeados. Os "
"argumentos são:"

#: ../../library/threading.rst:515
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:`!"
"ThreadGroup` class is implemented."
msgstr ""
"*group* deve ser ``None``; reservado para extensão futura quando uma classe :"
"class:`!ThreadGroup` for implementada."

#: ../../library/threading.rst:518
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* é o objeto chamável a ser invocado pelo método :meth:`run`. O valor "
"predefinido é ``None``, o que significa que nada é chamado."

#: ../../library/threading.rst:521
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*name* é o nome da thread. Por predefinição, é construído um nome único da "
"forma \"Thread-*N*\" onde *N* é um número decimal pequeno, ou \"Thread-*N* "
"(target)\" onde \"target\" é ``target.__name__`` se o argumento *target* for "
"especificado."

#: ../../library/threading.rst:526
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr ""
"*args* é uma lista ou tuplo de argumentos para a invocação do alvo. O valor "
"predefinido é ``()``."

#: ../../library/threading.rst:528
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* é um dicionário de argumentos nomeados para a invocação do alvo. O "
"valor predefinido é ``{}``."

#: ../../library/threading.rst:531
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"Se não for ``None``, *daemon* define explicitamente se a thread é daemon. Se "
"for ``None`` (o valor predefinido), a propriedade daemon é herdada da thread "
"atual."

#: ../../library/threading.rst:535
msgid ""
"*context* is the :class:`~contextvars.Context` value to use when starting "
"the thread.  The default value is ``None`` which indicates that the :data:"
"`sys.flags.thread_inherit_context` flag controls the behaviour.  If the flag "
"is true, threads will start with a copy of the context of the caller of :"
"meth:`~Thread.start`.  If false, they will start with an empty context.  To "
"explicitly start with an empty context, pass a new instance of :class:"
"`~contextvars.Context()`.  To explicitly start with a copy of the current "
"context, pass the value from :func:`~contextvars.copy_context`. The flag "
"defaults true on free-threaded builds and false otherwise."
msgstr ""
"*context* é o valor :class:`~contextvars.Context` a ser usado ao iniciar a "
"thread. O valor predefinido é ``None``, o que indica que a flag :data:`sys."
"flags.thread_inherit_context` controla o comportamento. Se a flag for "
"verdadeira, as threads iniciarão com uma cópia do contexto do chamador de :"
"meth:`~Thread.start`. Se for falsa, iniciarão com um contexto vazio. Para "
"iniciar explicitamente com um contexto vazio, passe uma nova instância de :"
"class:`~contextvars.Context()`. Para iniciar explicitamente com uma cópia do "
"contexto atual, passe o valor de :func:`~contextvars.copy_context`. A flag é "
"verdadeira por predefinição em compilações free-threaded e falsa caso "
"contrário."

#: ../../library/threading.rst:545
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"Se a subclasse substituir o construtor, deve garantir que invoca o "
"construtor da classe base (``Thread.__init__()``) antes de fazer qualquer "
"outra coisa com a thread."

#: ../../library/threading.rst:549
msgid "Added the *daemon* parameter."
msgstr "Adicionado o parâmetro *daemon*."

#: ../../library/threading.rst:552
msgid "Use the *target* name if *name* argument is omitted."
msgstr "Use o nome *target* se o argumento *name* for omitido."

#: ../../library/threading.rst:555
msgid "Added the *context* parameter."
msgstr "Adicionado o parâmetro *context*."

#: ../../library/threading.rst:560
msgid "Start the thread's activity."
msgstr "Inicia a atividade da thread."

#: ../../library/threading.rst:562
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Deve ser chamado no máximo uma vez por objeto thread. Organiza para que o "
"método :meth:`~Thread.run` do objeto seja invocado numa thread de controlo "
"separada."

#: ../../library/threading.rst:566
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"Este método levantará um :exc:`RuntimeError` se for chamado mais do que uma "
"vez no mesmo objeto thread."

#: ../../library/threading.rst:569
msgid ""
"If supported, set the operating system thread name to :attr:`threading."
"Thread.name`. The name can be truncated depending on the operating system "
"thread name limits."
msgstr ""
"Se suportado, define o nome da thread do sistema operativo para :attr:"
"`threading.Thread.name`. O nome pode ser truncado dependendo dos limites do "
"nome da thread do sistema operativo."

#: ../../library/threading.rst:573
msgid "Set the operating system thread name."
msgstr "Define o nome da thread do sistema operativo."

#: ../../library/threading.rst:578
msgid "Method representing the thread's activity."
msgstr "Método que representa a atividade da thread."

#: ../../library/threading.rst:580
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Pode substituir este método numa subclasse. O método :meth:`run` padrão "
"invoca o objeto chamável passado para o construtor do objeto como argumento "
"*target*, se houver, com argumentos posicionais e nomeados retirados dos "
"argumentos *args* e *kwargs*, respetivamente."

#: ../../library/threading.rst:585
msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr ""
"Usar uma lista ou tuplo como argumento *args* passado para :class:`Thread` "
"pode alcançar o mesmo efeito."

#: ../../library/threading.rst:588
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/threading.rst:590
msgid ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"
msgstr ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"

#: ../../library/threading.rst:602
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Espera até que a thread termine. Isto bloqueia a thread chamadora até que a "
"thread cujo método :meth:`~Thread.join` é chamado termine — normalmente ou "
"através de uma exceção não tratada — ou até que ocorra o timeout opcional."

#: ../../library/threading.rst:607
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"Quando o argumento *timeout* está presente e não é ``None``, deve ser um "
"número de vírgula flutuante que especifica um timeout para a operação em "
"segundos (ou frações destes). Como :meth:`~Thread.join` sempre devolve "
"``None``, deve chamar :meth:`~Thread.is_alive` após :meth:`~Thread.join` "
"para decidir se ocorreu um timeout — se a thread ainda estiver ativa, a "
"chamada :meth:`~Thread.join` expirou."

#: ../../library/threading.rst:614
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Quando o argumento *timeout* não está presente ou é ``None``, a operação "
"bloqueará até que a thread termine."

#: ../../library/threading.rst:617
msgid "A thread can be joined many times."
msgstr "Uma thread pode ser unida várias vezes."

#: ../../library/threading.rst:619
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` levanta um :exc:`RuntimeError` se for feita uma "
"tentativa de unir a thread atual, pois isso causaria um impasse. Também é um "
"erro tentar :meth:`~Thread.join` uma thread antes de ela ter sido iniciada, "
"e tais tentativas levantam a mesma exceção."

#: ../../library/threading.rst:624
msgid ""
"If an attempt is made to join a running daemonic thread in late stages of :"
"term:`Python finalization <interpreter shutdown>` :meth:`!join` raises a :"
"exc:`PythonFinalizationError`."
msgstr ""
"Se for feita uma tentativa de unir uma thread daemon em execução em estágios "
"avançados da :term:`finalização do Python <interpreter shutdown>`, :meth:`!"
"join` levanta um :exc:`PythonFinalizationError`."

#: ../../library/threading.rst:630
msgid "May raise :exc:`PythonFinalizationError`."
msgstr "Pode levantar :exc:`PythonFinalizationError`."

#: ../../library/threading.rst:634
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"Uma string usada apenas para fins de identificação. Não tem semântica. "
"Várias threads podem ter o mesmo nome. O nome inicial é definido pelo "
"construtor."

#: ../../library/threading.rst:638
msgid ""
"On some platforms, the thread name is set at the operating system level when "
"the thread starts, so that it is visible in task managers. This name may be "
"truncated to fit in a system-specific limit (for example, 15 bytes on Linux "
"or 63 bytes on macOS)."
msgstr ""
"Em algumas plataformas, o nome da thread é definido ao nível do sistema "
"operativo quando a thread inicia, de modo a que seja visível nos gestores de "
"tarefas. Este nome pode ser truncado para caber num limite específico do "
"sistema (por exemplo, 15 bytes no Linux ou 63 bytes no macOS)."

#: ../../library/threading.rst:643
msgid ""
"Changes to *name* are only reflected at the OS level when the currently "
"running thread is renamed. (Setting the *name* attribute of a different "
"thread only updates the Python Thread object.)"
msgstr ""
"As alterações ao *name* só são refletidas ao nível do sistema operativo "
"quando a thread atualmente em execução é renomeada. (Definir o atributo "
"*name* de uma thread diferente atualiza apenas o objeto Thread do Python.)"

#: ../../library/threading.rst:650
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"API getter/setter obsoleta para :attr:`~Thread.name`; use-a diretamente como "
"uma propriedade."

#: ../../library/threading.rst:657
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"O 'identificador de thread' desta thread ou ``None`` se a thread não tiver "
"sido iniciada. Este é um inteiro não nulo. Veja a função :func:`get_ident`. "
"Os identificadores de thread podem ser reciclados quando uma thread termina "
"e outra thread é criada. O identificador está disponível mesmo após a thread "
"ter terminado."

#: ../../library/threading.rst:665
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"O ID da Thread (``TID``) desta thread, conforme atribuído pelo sistema "
"operativo (kernel). Este é um inteiro não negativo, ou ``None`` se a thread "
"não tiver sido iniciada. Veja a função :func:`get_native_id`. Este valor "
"pode ser usado para identificar de forma única esta thread em todo o sistema "
"(até que a thread termine, após o que o valor pode ser reciclado pelo "
"sistema operativo)."

#: ../../library/threading.rst:674
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""
"Semelhante aos IDs de Processo, os IDs de Thread são válidos (garantidamente "
"únicos em todo o sistema) desde o momento em que a thread é criada até que a "
"thread seja terminada."

#: ../../library/threading.rst:684
msgid "Return whether the thread is alive."
msgstr "Devolve se a thread está ativa."

#: ../../library/threading.rst:686
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Este método devolve ``True`` logo antes do método :meth:`~Thread.run` "
"iniciar até logo após o método :meth:`~Thread.run` terminar. A função do "
"módulo :func:`.enumerate` devolve uma lista de todas as threads ativas."

#: ../../library/threading.rst:692
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""
"Um valor booleano que indica se esta thread é uma thread daemon (``True``) "
"ou não (``False``). Isto deve ser definido antes de :meth:`~Thread.start` "
"ser chamado, caso contrário é levantado um :exc:`RuntimeError`. O seu valor "
"inicial é herdado da thread que a criou; a thread principal não é uma thread "
"daemon e, portanto, todas as threads criadas na thread principal têm por "
"predefinição :attr:`~Thread.daemon` = ``False``."

#: ../../library/threading.rst:699
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"Todo o programa Python termina quando não restam threads não daemon ativas."

#: ../../library/threading.rst:704
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""
"API getter/setter obsoleta para :attr:`~Thread.daemon`; use-a diretamente "
"como uma propriedade."

#: ../../library/threading.rst:713
msgid "Lock objects"
msgstr "Objetos Lock"

#: ../../library/threading.rst:715
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"Um lock primitivo é um primitivo de sincronização que não é possuído por uma "
"thread específica quando bloqueado. Em Python, é atualmente o primitivo de "
"sincronização de nível mais baixo disponível, implementado diretamente pelo "
"módulo de extensão :mod:`_thread`."

#: ../../library/threading.rst:720
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"Um lock primitivo está em um de dois estados, \"bloqueado\" ou "
"\"desbloqueado\". É criado no estado desbloqueado. Tem dois métodos "
"básicos, :meth:`~Lock.acquire` e :meth:`~Lock.release`. Quando o estado está "
"desbloqueado, :meth:`~Lock.acquire` muda o estado para bloqueado e retorna "
"imediatamente. Quando o estado está bloqueado, :meth:`~Lock.acquire` "
"bloqueia até que uma chamada a :meth:`~Lock.release` noutra thread o mude "
"para desbloqueado, então a chamada :meth:`~Lock.acquire` redefine-o para "
"bloqueado e retorna. O método :meth:`~Lock.release` só deve ser chamado no "
"estado bloqueado; muda o estado para desbloqueado e retorna imediatamente. "
"Se for feita uma tentativa de libertar um lock desbloqueado, será levantado "
"um :exc:`RuntimeError`."

#: ../../library/threading.rst:731
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Os locks também suportam o :ref:`protocolo de gestão de contexto <with-"
"locks>`."

#: ../../library/threading.rst:733
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""

#: ../../library/threading.rst:738
msgid "All methods are executed atomically."
msgstr "Todos os métodos são executados atomicamente."

#: ../../library/threading.rst:743
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"A classe que implementa objetos de bloqueio primitivo. Uma vez que uma "
"thread adquire um bloqueio, tentativas subsequentes para adquiri-lo "
"bloqueiam, até que seja libertado; qualquer thread pode libertá-lo."

#: ../../library/threading.rst:747
msgid ""
"``Lock`` is now a class. In earlier Pythons, ``Lock`` was a factory function "
"which returned an instance of the underlying private lock type."
msgstr ""
"``Lock`` agora é uma classe. Em versões anteriores do Python, ``Lock`` era "
"uma função fábrica que devolvia uma instância do tipo de bloqueio privado "
"subjacente."

#: ../../library/threading.rst:755 ../../library/threading.rst:849
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Adquire um bloqueio, bloqueante ou não bloqueante."

#: ../../library/threading.rst:757
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"Quando invocado com o argumento *blocking* definido como ``True`` "
"(predefinição), bloqueia até que o bloqueio seja desbloqueado, depois define-"
"o como bloqueado e devolve ``True``."

#: ../../library/threading.rst:760
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"Quando invocado com o argumento *blocking* definido como ``False``, não "
"bloqueia. Se uma chamada com *blocking* definido como ``True`` bloquearia, "
"devolve ``False`` imediatamente; caso contrário, define o bloqueio como "
"bloqueado e devolve ``True``."

#: ../../library/threading.rst:764
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"Quando invocado com o argumento *timeout* de ponto flutuante definido para "
"um valor positivo, bloqueia durante, no máximo, o número de segundos "
"especificado por *timeout* e enquanto o bloqueio não puder ser adquirido. Um "
"argumento *timeout* de ``-1`` especifica uma espera ilimitada. É proibido "
"especificar um *timeout* quando *blocking* é ``False``."

#: ../../library/threading.rst:770
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"O valor de retorno é ``True`` se o bloqueio for adquirido com sucesso, "
"``False`` se não for (por exemplo, se o *timeout* expirar)."

#: ../../library/threading.rst:773 ../../library/threading.rst:887
#: ../../library/threading.rst:1147
msgid "The *timeout* parameter is new."
msgstr "O parâmetro *timeout* é novo."

#: ../../library/threading.rst:776
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""
"A aquisição de bloqueio agora pode ser interrompida por sinais em POSIX se a "
"implementação de threading subjacente o suportar."

#: ../../library/threading.rst:780
msgid "Lock acquisition can now be interrupted by signals on Windows."
msgstr ""
"A aquisição de bloqueio agora pode ser interrompida por sinais no Windows."

#: ../../library/threading.rst:786
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"Liberta um bloqueio. Isto pode ser chamado a partir de qualquer thread, não "
"apenas da thread que adquiriu o bloqueio."

#: ../../library/threading.rst:789
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"Quando o bloqueio está bloqueado, redefine-o para desbloqueado e retorna. Se "
"outras threads estão bloqueadas à espera que o bloqueio seja desbloqueado, "
"permite que exatamente uma delas prossiga."

#: ../../library/threading.rst:793
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"Quando invocado num bloqueio desbloqueado, é levantada uma exceção :exc:"
"`RuntimeError`."

#: ../../library/threading.rst:795 ../../library/threading.rst:903
msgid "There is no return value."
msgstr "Não há valor de retorno."

#: ../../library/threading.rst:799
msgid "Return ``True`` if the lock is acquired."
msgstr "Devolve ``True`` se o bloqueio estiver adquirido."

#: ../../library/threading.rst:806
msgid "RLock objects"
msgstr "Objetos RLock"

#: ../../library/threading.rst:808
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"Um bloqueio reentrante é um primitivo de sincronização que pode ser "
"adquirido várias vezes pela mesma thread. Internamente, utiliza os conceitos "
"de \"thread proprietária\" e \"nível de recursão\" além do estado bloqueado/"
"desbloqueado usado por bloqueios primitivos. No estado bloqueado, alguma "
"thread possui o bloqueio; no estado desbloqueado, nenhuma thread o possui."

#: ../../library/threading.rst:814
msgid ""
"Threads call a lock's :meth:`~RLock.acquire` method to lock it, and its :"
"meth:`~Lock.release` method to unlock it."
msgstr ""
"As threads chamam o método :meth:`~RLock.acquire` de um bloqueio para "
"bloqueá-lo e o seu método :meth:`~Lock.release` para desbloqueá-lo."

#: ../../library/threading.rst:819
msgid ""
"Reentrant locks support the :ref:`context management protocol <with-locks>`, "
"so it is recommended to use :keyword:`with` instead of manually calling :"
"meth:`~RLock.acquire` and :meth:`~RLock.release` to handle acquiring and "
"releasing the lock for a block of code."
msgstr ""
"Os bloqueios reentrantes suportam o :ref:`protocolo de gestão de contexto "
"<with-locks>`, pelo que é recomendado usar :keyword:`with` em vez de chamar "
"manualmente :meth:`~RLock.acquire` e :meth:`~RLock.release` para lidar com a "
"aquisição e libertação do bloqueio para um bloco de código."

#: ../../library/threading.rst:824
msgid ""
"RLock's :meth:`~RLock.acquire`/:meth:`~RLock.release` call pairs may be "
"nested, unlike Lock's :meth:`~Lock.acquire`/:meth:`~Lock.release`. Only the "
"final :meth:`~RLock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to an unlocked state and allows another thread blocked "
"in :meth:`~RLock.acquire` to proceed."
msgstr ""
"Os pares de chamadas :meth:`~RLock.acquire`/:meth:`~RLock.release` de RLock "
"podem ser aninhados, ao contrário dos pares :meth:`~Lock.acquire`/:meth:"
"`~Lock.release` de Lock. Apenas o :meth:`~RLock.release` final (o :meth:"
"`~Lock.release` do par mais externo) redefine o bloqueio para um estado "
"desbloqueado e permite que outra thread bloqueada em :meth:`~RLock.acquire` "
"prossiga."

#: ../../library/threading.rst:830
msgid ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` must be used in pairs: each "
"acquire must have a release in the thread that has acquired the lock. "
"Failing to call release as many times the lock has been acquired can lead to "
"deadlock."
msgstr ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` devem ser usados em pares: "
"cada aquisição deve ter uma libertação na thread que adquiriu o bloqueio. "
"Falhar em chamar a libertação tantas vezes quantas o bloqueio foi adquirido "
"pode levar a um impasse."

#: ../../library/threading.rst:837
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"Esta classe implementa objetos de bloqueio reentrante. Um bloqueio "
"reentrante deve ser libertado pela thread que o adquiriu. Uma vez que uma "
"thread adquire um bloqueio reentrante, a mesma thread pode adquiri-lo "
"novamente sem bloquear; a thread deve libertá-lo uma vez por cada vez que o "
"adquiriu."

#: ../../library/threading.rst:842
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"Note que ``RLock`` é, na verdade, uma função fábrica que devolve uma "
"instância da versão mais eficiente da classe concreta RLock que é suportada "
"pela plataforma."

#: ../../library/threading.rst:853
msgid ":ref:`Using RLock as a context manager <with-locks>`"
msgstr ":ref:`Usar RLock como gestor de contexto <with-locks>`"

#: ../../library/threading.rst:854
msgid ""
"Recommended over manual :meth:`!acquire` and :meth:`release` calls whenever "
"practical."
msgstr ""
"Recomendado em vez de chamadas manuais :meth:`!acquire` e :meth:`release` "
"sempre que prático."

#: ../../library/threading.rst:858
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default):"
msgstr ""
"Quando invocado com o argumento *blocking* definido como ``True`` "
"(predefinição):"

#: ../../library/threading.rst:860 ../../library/threading.rst:872
msgid "If no thread owns the lock, acquire the lock and return immediately."
msgstr ""
"Se nenhuma thread possui o bloqueio, adquire o bloqueio e retorna "
"imediatamente."

#: ../../library/threading.rst:862
msgid ""
"If another thread owns the lock, block until we are able to acquire lock, or "
"*timeout*, if set to a positive float value."
msgstr ""
"Se outra thread possui o bloqueio, bloqueia até que possamos adquirir o "
"bloqueio, ou *timeout*, se definido para um valor positivo de ponto "
"flutuante."

#: ../../library/threading.rst:865
msgid ""
"If the same thread owns the lock, acquire the lock again, and return "
"immediately. This is the difference between :class:`Lock` and :class:`!"
"RLock`; :class:`Lock` handles this case the same as the previous, blocking "
"until the lock can be acquired."
msgstr ""
"Se a mesma thread possui o bloqueio, adquire o bloqueio novamente e retorna "
"imediatamente. Esta é a diferença entre :class:`Lock` e :class:`!RLock`; :"
"class:`Lock` trata deste caso da mesma forma que o anterior, bloqueando até "
"que o bloqueio possa ser adquirido."

#: ../../library/threading.rst:870
msgid "When invoked with the *blocking* argument set to ``False``:"
msgstr "Quando invocado com o argumento *blocking* definido como ``False``:"

#: ../../library/threading.rst:874
msgid "If another thread owns the lock, return immediately."
msgstr "Se outra thread possui o bloqueio, retorna imediatamente."

#: ../../library/threading.rst:876
msgid ""
"If the same thread owns the lock, acquire the lock again and return "
"immediately."
msgstr ""
"Se a mesma thread possui o bloqueio, adquire o bloqueio novamente e retorna "
"imediatamente."

#: ../../library/threading.rst:879
msgid ""
"In all cases, if the thread was able to acquire the lock, return ``True``. "
"If the thread was unable to acquire the lock (i.e. if not blocking or the "
"timeout was reached) return ``False``."
msgstr ""
"Em todos os casos, se a thread conseguiu adquirir o bloqueio, devolve "
"``True``. Se a thread não conseguiu adquirir o bloqueio (ou seja, se não "
"estiver bloqueante ou o timeout foi atingido), devolve ``False``."

#: ../../library/threading.rst:883
msgid ""
"If called multiple times, failing to call :meth:`~RLock.release` as many "
"times may lead to deadlock. Consider using :class:`!RLock` as a context "
"manager rather than calling acquire/release directly."
msgstr ""
"Se chamado várias vezes, falhar em chamar :meth:`~RLock.release` tantas "
"vezes pode levar a um impasse. Considere usar :class:`!RLock` como um gestor "
"de contexto em vez de chamar diretamente acquire/release."

#: ../../library/threading.rst:893
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"Liberta um bloqueio, decrementando o nível de recursão. Se após o decremento "
"for zero, redefine o bloqueio para desbloqueado (não possuído por nenhuma "
"thread), e se outras threads estão bloqueadas à espera que o bloqueio seja "
"desbloqueado, permite que exatamente uma delas prossiga. Se após o "
"decremento o nível de recursão ainda for diferente de zero, o bloqueio "
"permanece bloqueado e possuído pela thread chamadora."

#: ../../library/threading.rst:899
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is not "
"acquired."
msgstr ""
"Chame este método apenas quando a thread chamadora possui o bloqueio. Uma "
"exceção :exc:`RuntimeError` é levantada se este método for chamado quando o "
"bloqueio não está adquirido."

#: ../../library/threading.rst:908 ../../library/threading.rst:1007
msgid "Return a boolean indicating whether this object is locked right now."
msgstr ""
"Devolve um booleano que indica se este objeto está bloqueado neste momento."

#: ../../library/threading.rst:916
msgid "Condition objects"
msgstr "Objetos Condition"

#: ../../library/threading.rst:918
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"Uma variável de condição está sempre associada a algum tipo de bloqueio; "
"este pode ser passado ou um será criado por predefinição. Passar um bloqueio "
"é útil quando várias variáveis de condição devem partilhar o mesmo bloqueio. "
"O bloqueio faz parte do objeto de condição: não precisa de o acompanhar "
"separadamente."

#: ../../library/threading.rst:923
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"Uma variável de condição obedece ao :ref:`protocolo de gestão de contexto "
"<with-locks>`: usar a instrução ``with`` adquire o bloqueio associado "
"durante a duração do bloco encerrado. Os métodos :meth:`~Condition.acquire` "
"e :meth:`~Condition.release` também chamam os métodos correspondentes do "
"bloqueio associado."

#: ../../library/threading.rst:929
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"Outros métodos devem ser chamados com o bloqueio associado mantido. O "
"método :meth:`~Condition.wait` liberta o bloqueio e depois bloqueia até que "
"outra thread o desperte chamando :meth:`~Condition.notify` ou :meth:"
"`~Condition.notify_all`. Uma vez despertado, :meth:`~Condition.wait` "
"readquire o bloqueio e retorna. Também é possível especificar um timeout."

#: ../../library/threading.rst:935
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
"O método :meth:`~Condition.notify` desperta uma das threads à espera da "
"variável de condição, se alguma estiver à espera. O método :meth:`~Condition."
"notify_all` desperta todas as threads à espera da variável de condição."

#: ../../library/threading.rst:939
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"Nota: os métodos :meth:`~Condition.notify` e :meth:`~Condition.notify_all` "
"não libertam o bloqueio; isto significa que a thread ou threads despertadas "
"não retornarão da sua chamada :meth:`~Condition.wait` imediatamente, mas "
"apenas quando a thread que chamou :meth:`~Condition.notify` ou :meth:"
"`~Condition.notify_all` finalmente renunciar à posse do bloqueio."

#: ../../library/threading.rst:945
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"O estilo típico de programação usando variáveis de condição utiliza o "
"bloqueio para sincronizar o acesso a algum estado partilhado; threads que "
"estão interessadas numa mudança particular de estado chamam :meth:"
"`~Condition.wait` repetidamente até verem o estado desejado, enquanto "
"threads que modificam o estado chamam :meth:`~Condition.notify` ou :meth:"
"`~Condition.notify_all` quando alteram o estado de tal forma que possa ser "
"um estado desejado para um dos que aguardam. Por exemplo, o seguinte código "
"é uma situação genérica de produtor-consumidor com capacidade de buffer "
"ilimitada:"

#: ../../library/threading.rst:954
msgid ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"
msgstr ""
"# Consumir um item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produzir um item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"

#: ../../library/threading.rst:965
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"O ciclo ``while`` que verifica a condição da aplicação é necessário porque :"
"meth:`~Condition.wait` pode retornar após um tempo arbitrariamente longo, e "
"a condição que motivou a chamada :meth:`~Condition.notify` pode já não ser "
"verdadeira. Isto é inerente à programação multi-thread. O método :meth:"
"`~Condition.wait_for` pode ser usado para automatizar a verificação da "
"condição e facilita o cálculo de timeouts:"

#: ../../library/threading.rst:972
msgid ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"
msgstr ""
"# Consumir um item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"

#: ../../library/threading.rst:977
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
"Para escolher entre :meth:`~Condition.notify` e :meth:`~Condition."
"notify_all`, considere se uma mudança de estado pode ser interessante para "
"apenas uma ou várias threads à espera. Por exemplo, numa situação típica de "
"produtor-consumidor, adicionar um item ao buffer só precisa de despertar uma "
"thread consumidora."

#: ../../library/threading.rst:985
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""
"Esta classe implementa objetos de variável de condição. Uma variável de "
"condição permite que uma ou mais threads aguardem até serem notificadas por "
"outra thread."

#: ../../library/threading.rst:988
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"Se o argumento *lock* for fornecido e não for ``None``, deve ser um objeto :"
"class:`Lock` ou :class:`RLock`, e é usado como o bloqueio subjacente. Caso "
"contrário, um novo objeto :class:`RLock` é criado e usado como o bloqueio "
"subjacente."

#: ../../library/threading.rst:992 ../../library/threading.rst:1122
#: ../../library/threading.rst:1168 ../../library/threading.rst:1220
#: ../../library/threading.rst:1288
msgid "changed from a factory function to a class."
msgstr "mudou de uma função fábrica para uma classe."

#: ../../library/threading.rst:997
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"Adquire o bloqueio subjacente. Este método chama o método correspondente no "
"bloqueio subjacente; o valor de retorno é o que quer que esse método retorne."

#: ../../library/threading.rst:1002
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"Liberta o bloqueio subjacente. Este método chama o método correspondente no "
"bloqueio subjacente; não há valor de retorno."

#: ../../library/threading.rst:1013
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"Aguarda até ser notificado ou até que ocorra um timeout. Se a thread "
"chamadora não tiver adquirido o bloqueio quando este método é chamado, é "
"levantada uma exceção :exc:`RuntimeError`."

#: ../../library/threading.rst:1017
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"Este método liberta o bloqueio subjacente e depois bloqueia até ser "
"despertado por uma chamada :meth:`notify` ou :meth:`notify_all` para a mesma "
"variável de condição noutra thread, ou até que ocorra o timeout opcional. "
"Uma vez despertado ou após o timeout, readquire o bloqueio e retorna."

#: ../../library/threading.rst:1022
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"Quando o argumento *timeout* está presente e não é ``None``, deve ser um "
"número de ponto flutuante que especifica um timeout para a operação em "
"segundos (ou frações destes)."

#: ../../library/threading.rst:1026
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"Quando o bloqueio subjacente é um :class:`RLock`, não é libertado usando o "
"seu método :meth:`release`, uma vez que isto pode não desbloquear realmente "
"o bloqueio quando foi adquirido várias vezes de forma recursiva. Em vez "
"disso, é usada uma interface interna da classe :class:`RLock`, que o "
"desbloqueia mesmo quando foi adquirido várias vezes de forma recursiva. "
"Outra interface interna é então usada para restaurar o nível de recursão "
"quando o bloqueio é readquirido."

#: ../../library/threading.rst:1034
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""
"O valor de retorno é ``True`` a menos que um *timeout* dado expire, caso em "
"que é ``False``."

#: ../../library/threading.rst:1037 ../../library/threading.rst:1253
msgid "Previously, the method always returned ``None``."
msgstr "Anteriormente, o método sempre retornava ``None``."

#: ../../library/threading.rst:1042
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"Aguarda até que uma condição avalie para verdadeiro. *predicate* deve ser um "
"objeto chamável cujo resultado será interpretado como um valor booleano. Um "
"*timeout* pode ser fornecido, dando o tempo máximo de espera."

#: ../../library/threading.rst:1046
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"Este método utilitário pode chamar :meth:`wait` repetidamente até que o "
"predicado seja satisfeito, ou até que ocorra um timeout. O valor de retorno "
"é o último valor de retorno do predicado e avaliará para ``False`` se o "
"método atingir o timeout."

#: ../../library/threading.rst:1051
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"Ignorando a funcionalidade de timeout, chamar este método é aproximadamente "
"equivalente a escrever:"

#: ../../library/threading.rst:1054
msgid ""
"while not predicate():\n"
"    cv.wait()"
msgstr ""
"while not predicate():\n"
"    cv.wait()"

#: ../../library/threading.rst:1057
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"Portanto, as mesmas regras aplicam-se como com :meth:`wait`: O bloqueio deve "
"ser mantido quando chamado e é readquirido ao retornar. O predicado é "
"avaliado com o bloqueio mantido."

#: ../../library/threading.rst:1065
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Por predefinição, desperta uma thread à espera desta condição, se houver "
"alguma. Se a thread chamadora não tiver adquirido o bloqueio quando este "
"método é chamado, é levantada uma exceção :exc:`RuntimeError`."

#: ../../library/threading.rst:1069
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"Este método desperta no máximo *n* das threads à espera da variável de "
"condição; é uma operação sem efeito se nenhuma thread estiver à espera."

#: ../../library/threading.rst:1072
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"A implementação atual desperta exatamente *n* threads, se pelo menos *n* "
"threads estiverem à espera. No entanto, não é seguro confiar neste "
"comportamento. Uma implementação futura e otimizada pode ocasionalmente "
"despertar mais do que *n* threads."

#: ../../library/threading.rst:1077
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"Nota: uma thread despertada não retorna realmente da sua chamada :meth:"
"`wait` até que possa readquirir o bloqueio. Uma vez que :meth:`notify` não "
"liberta o bloqueio, o seu chamador deve fazê-lo."

#: ../../library/threading.rst:1083
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Desperta todas as threads à espera desta condição. Este método age como :"
"meth:`notify`, mas desperta todas as threads à espera em vez de uma. Se a "
"thread chamadora não tiver adquirido o bloqueio quando este método é "
"chamado, é levantada uma exceção :exc:`RuntimeError`."

#: ../../library/threading.rst:1088
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "O método ``notifyAll`` é um alias obsoleto para este método."

#: ../../library/threading.rst:1094
msgid "Semaphore objects"
msgstr "Objetos Semaphore"

#: ../../library/threading.rst:1096
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"Este é um dos primitivos de sincronização mais antigos na história da "
"ciência da computação, inventado pelo pioneiro cientista da computação "
"holandês Edsger W. Dijkstra (ele usou os nomes ``P()`` e ``V()`` em vez de :"
"meth:`~Semaphore.acquire` e :meth:`~Semaphore.release`)."

#: ../../library/threading.rst:1101
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"Um semáforo gere um contador interno que é decrementado por cada chamada :"
"meth:`~Semaphore.acquire` e incrementado por cada chamada :meth:`~Semaphore."
"release`. O contador nunca pode ser inferior a zero; quando :meth:"
"`~Semaphore.acquire` encontra que é zero, bloqueia, aguardando até que "
"alguma outra thread chame :meth:`~Semaphore.release`."

#: ../../library/threading.rst:1107
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Os semáforos também suportam o :ref:`protocolo de gestão de contexto <with-"
"locks>`."

#: ../../library/threading.rst:1112
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""
"Esta classe implementa objetos de semáforo. Um semáforo gere um contador "
"atómico que representa o número de chamadas :meth:`release` menos o número "
"de chamadas :meth:`acquire`, mais um valor inicial. O método :meth:`acquire` "
"bloqueia, se necessário, até que possa retornar sem tornar o contador "
"negativo. Se não for fornecido, *value* tem o valor predefinido de 1."

#: ../../library/threading.rst:1118
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"O argumento opcional fornece o valor inicial *value* para o contador "
"interno; o valor predefinido é ``1``. Se o *value* fornecido for menor que "
"0, é levantada uma exceção :exc:`ValueError`."

#: ../../library/threading.rst:1127
msgid "Acquire a semaphore."
msgstr "Adquire um semáforo."

#: ../../library/threading.rst:1129
msgid "When invoked without arguments:"
msgstr "Quando invocado sem argumentos:"

#: ../../library/threading.rst:1131
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""
"Se o contador interno for maior que zero na entrada, decrementa-o em um e "
"retorna ``True`` imediatamente."

#: ../../library/threading.rst:1133
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"Se o contador interno for zero na entrada, bloqueia até ser despertado por "
"uma chamada a :meth:`~Semaphore.release`. Uma vez despertado (e o contador "
"for maior que 0), decrementa o contador em 1 e retorna ``True``. Exatamente "
"uma thread será despertada por cada chamada a :meth:`~Semaphore.release`. A "
"ordem em que as threads são despertadas não deve ser confiável."

#: ../../library/threading.rst:1139
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""
"Quando invocado com *blocking* definido como ``False``, não bloqueia. Se uma "
"chamada sem um argumento bloquearia, retorna ``False`` imediatamente; caso "
"contrário, faz a mesma coisa que quando chamado sem argumentos e retorna "
"``True``."

#: ../../library/threading.rst:1143
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"Quando invocado com um *timeout* diferente de ``None``, bloqueará durante no "
"máximo *timeout* segundos. Se a aquisição não for concluída com sucesso "
"nesse intervalo, retorna ``False``. Caso contrário, retorna ``True``."

#: ../../library/threading.rst:1152
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""
"Liberta um semáforo, incrementando o contador interno em *n*. Quando era "
"zero na entrada e outras threads estão à espera que se torne maior que zero "
"novamente, desperta *n* dessas threads."

#: ../../library/threading.rst:1156
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""
"Adicionado o parâmetro *n* para libertar várias threads à espera de uma só "
"vez."

#: ../../library/threading.rst:1162
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"Classe que implementa objetos de semáforo limitado. Um semáforo limitado "
"verifica para garantir que o seu valor atual não excede o seu valor inicial. "
"Se exceder, é levantada uma exceção :exc:`ValueError`. Na maioria das "
"situações, os semáforos são usados para proteger recursos com capacidade "
"limitada. Se o semáforo for libertado demasiadas vezes, é um sinal de um "
"erro. Se não for fornecido, *value* tem o valor predefinido de 1."

#: ../../library/threading.rst:1175
msgid ":class:`Semaphore` example"
msgstr "Exemplo de :class:`Semaphore`"

#: ../../library/threading.rst:1177
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"Os semáforos são frequentemente usados para proteger recursos com capacidade "
"limitada, por exemplo, um servidor de base de dados. Em qualquer situação em "
"que o tamanho do recurso é fixo, deve usar um semáforo limitado. Antes de "
"criar quaisquer threads de trabalho, a sua thread principal inicializaria o "
"semáforo:"

#: ../../library/threading.rst:1182
msgid ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"
msgstr ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"

#: ../../library/threading.rst:1186
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"Uma vez criadas, as threads de trabalho chamam os métodos acquire e release "
"do semáforo quando precisam de se conectar ao servidor:"

#: ../../library/threading.rst:1189
msgid ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"
msgstr ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... usar a ligação ...\n"
"    finally:\n"
"        conn.close()"

#: ../../library/threading.rst:1196
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"O uso de um semáforo limitado reduz a probabilidade de que um erro de "
"programação que faz com que o semáforo seja libertado mais vezes do que é "
"adquirido passe despercebido."

#: ../../library/threading.rst:1203
msgid "Event objects"
msgstr "Objetos Event"

#: ../../library/threading.rst:1205
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"Este é um dos mecanismos mais simples para comunicação entre threads: uma "
"thread sinaliza um evento e outras threads aguardam por ele."

#: ../../library/threading.rst:1208
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"Um objeto de evento gere uma flag interna que pode ser definida como "
"verdadeira com o método :meth:`~Event.set` e redefinida como falsa com o "
"método :meth:`~Event.clear`. O método :meth:`~Event.wait` bloqueia até que a "
"flag seja verdadeira."

#: ../../library/threading.rst:1215
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"Classe que implementa objetos de evento. Um evento gere uma flag que pode "
"ser definida como verdadeira com o método :meth:`~Event.set` e redefinida "
"como falsa com o método :meth:`clear`. O método :meth:`wait` bloqueia até "
"que a flag seja verdadeira. A flag é inicialmente falsa."

#: ../../library/threading.rst:1225
msgid "Return ``True`` if and only if the internal flag is true."
msgstr "Devolve ``True`` se e somente se a flag interna for verdadeira."

#: ../../library/threading.rst:1227
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "O método ``isSet`` é um alias obsoleto para este método."

#: ../../library/threading.rst:1231
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"Define a flag interna como verdadeira. Todas as threads à espera que se "
"torne verdadeira são despertadas. Threads que chamam :meth:`wait` uma vez "
"que a flag é verdadeira não bloquearão de todo."

#: ../../library/threading.rst:1237
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"Redefine a flag interna como falsa. Posteriormente, threads que chamam :meth:"
"`wait` bloquearão até que :meth:`.set` seja chamado para definir a flag "
"interna como verdadeira novamente."

#: ../../library/threading.rst:1243
msgid ""
"Block as long as the internal flag is false and the timeout, if given, has "
"not expired. The return value represents the reason that this blocking "
"method returned; ``True`` if returning because the internal flag is set to "
"true, or ``False`` if a timeout is given and the internal flag did not "
"become true within the given wait time."
msgstr ""
"Bloqueia enquanto a flag interna for falsa e o timeout, se fornecido, não "
"tiver expirado. O valor de retorno representa a razão pela qual este método "
"bloqueante retornou; ``True`` se retornar porque a flag interna foi definida "
"como verdadeira, ou ``False`` se um timeout for fornecido e a flag interna "
"não se tornar verdadeira dentro do tempo de espera fornecido."

#: ../../library/threading.rst:1249
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds, or "
"fractions thereof."
msgstr ""
"Quando o argumento timeout está presente e não é ``None``, deve ser um "
"número de ponto flutuante que especifica um timeout para a operação em "
"segundos, ou frações destes."

#: ../../library/threading.rst:1260
msgid "Timer objects"
msgstr "Objetos Timer"

#: ../../library/threading.rst:1262
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"Esta classe representa uma ação que deve ser executada apenas após ter "
"passado uma certa quantidade de tempo — um temporizador. :class:`Timer` é "
"uma subclasse de :class:`Thread` e, como tal, também funciona como um "
"exemplo de criação de threads personalizadas."

#: ../../library/threading.rst:1266
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""
"Os temporizadores são iniciados, como as threads, chamando o seu método :"
"meth:`Timer.start <Thread.start>`. O temporizador pode ser parado (antes de "
"a sua ação ter começado) chamando o método :meth:`~Timer.cancel`. O "
"intervalo que o temporizador aguardará antes de executar a sua ação pode não "
"ser exatamente o mesmo que o intervalo especificado pelo utilizador."

#: ../../library/threading.rst:1272
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/threading.rst:1274
msgid ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"
msgstr ""
"def hello():\n"
"    print(\"olá, mundo\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # após 30 segundos, \"olá, mundo\" será impresso"

#: ../../library/threading.rst:1283
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"Cria um temporizador que executará a *function* com argumentos *args* e "
"argumentos nomeados *kwargs*, após terem passado *interval* segundos. Se "
"*args* for ``None`` (o predefinido), então uma lista vazia será usada. Se "
"*kwargs* for ``None`` (o predefinido), então um dicionário vazio será usado."

#: ../../library/threading.rst:1293
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"Para o temporizador e cancela a execução da ação do temporizador. Isto só "
"funcionará se o temporizador ainda estiver na sua fase de espera."

#: ../../library/threading.rst:1298
msgid "Barrier objects"
msgstr "Objetos Barrier"

#: ../../library/threading.rst:1302
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"Esta classe fornece um primitivo de sincronização simples para uso por um "
"número fixo de threads que precisam de esperar umas pelas outras. Cada uma "
"das threads tenta passar a barreira chamando o método :meth:`~Barrier.wait` "
"e bloqueará até que todas as threads tenham feito as suas chamadas :meth:"
"`~Barrier.wait`. Neste ponto, as threads são libertadas simultaneamente."

#: ../../library/threading.rst:1308
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""
"A barreira pode ser reutilizada qualquer número de vezes para o mesmo número "
"de threads."

#: ../../library/threading.rst:1310
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"Como exemplo, aqui está uma forma simples de sincronizar uma thread cliente "
"e uma thread servidor:"

#: ../../library/threading.rst:1312
msgid ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"
msgstr ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"

#: ../../library/threading.rst:1330
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"Cria um objeto de barreira para um número de *parties* de threads. Uma "
"*action*, quando fornecida, é um objeto chamável a ser chamado por uma das "
"threads quando forem libertadas. *timeout* é o valor de timeout predefinido "
"se nenhum for especificado para o método :meth:`wait`."

#: ../../library/threading.rst:1337
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"Passa a barreira. Quando todas as threads participantes da barreira chamarem "
"esta função, todas são libertadas simultaneamente. Se um *timeout* for "
"fornecido, é usado em preferência a qualquer um que tenha sido fornecido ao "
"construtor da classe."

#: ../../library/threading.rst:1342
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"O valor de retorno é um inteiro no intervalo de 0 a *parties* -- 1, "
"diferente para cada thread. Isto pode ser usado para selecionar uma thread "
"para fazer alguma manutenção especial, por exemplo:"

#: ../../library/threading.rst:1346
msgid ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"
msgstr ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Apenas uma thread precisa de imprimir isto\n"
"    print(\"passou a barreira\")"

#: ../../library/threading.rst:1351
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"Se uma *action* foi fornecida ao construtor, uma das threads terá chamado "
"essa ação antes de ser libertada. Se esta chamada levantar um erro, a "
"barreira é colocada no estado quebrado."

#: ../../library/threading.rst:1355
msgid "If the call times out, the barrier is put into the broken state."
msgstr ""
"Se a chamada atingir o timeout, a barreira é colocada no estado quebrado."

#: ../../library/threading.rst:1357
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""
"Este método pode levantar uma exceção :class:`BrokenBarrierError` se a "
"barreira for quebrada ou reiniciada enquanto uma thread está à espera."

#: ../../library/threading.rst:1362
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Devolve a barreira ao estado predefinido, vazio. Qualquer thread à espera "
"receberá a exceção :class:`BrokenBarrierError`."

#: ../../library/threading.rst:1365
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""
"Note que usar esta função pode exigir alguma sincronização externa se houver "
"outras threads cujo estado seja desconhecido. Se uma barreira for quebrada, "
"pode ser melhor simplesmente deixá-la e criar uma nova."

#: ../../library/threading.rst:1371
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"Coloca a barreira num estado quebrado. Isto faz com que quaisquer chamadas "
"ativas ou futuras a :meth:`wait` falhem com a exceção :class:"
"`BrokenBarrierError`. Use isto, por exemplo, se uma das threads precisar de "
"abortar, para evitar bloquear a aplicação."

#: ../../library/threading.rst:1376
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"Pode ser preferível simplesmente criar a barreira com um valor de *timeout* "
"razoável para proteger automaticamente contra uma das threads sair do "
"controle."

#: ../../library/threading.rst:1382
msgid "The number of threads required to pass the barrier."
msgstr "O número de threads necessárias para passar a barreira."

#: ../../library/threading.rst:1386
msgid "The number of threads currently waiting in the barrier."
msgstr "O número de threads atualmente à espera na barreira."

#: ../../library/threading.rst:1390
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "Um booleano que é ``True`` se a barreira estiver no estado quebrado."

#: ../../library/threading.rst:1395
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Esta exceção, uma subclasse de :exc:`RuntimeError`, é levantada quando o "
"objeto :class:`Barrier` é reiniciado ou quebrado."

#: ../../library/threading.rst:1402
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr "Usar bloqueios, condições e semáforos na instrução :keyword:`!with`"

#: ../../library/threading.rst:1404
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered, "
"and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""
"Todos os objetos fornecidos por este módulo que têm métodos ``acquire`` e "
"``release`` podem ser usados como gestores de contexto para uma instrução :"
"keyword:`with`. O método ``acquire`` será chamado quando o bloco for "
"entrado, e ``release`` será chamado quando o bloco for saído. Portanto, o "
"seguinte trecho:"

#: ../../library/threading.rst:1410
msgid ""
"with some_lock:\n"
"    # do something..."
msgstr ""
"with some_lock:\n"
"    # fazer algo..."

#: ../../library/threading.rst:1413
msgid "is equivalent to::"
msgstr "é equivalente a::"

#: ../../library/threading.rst:1415
msgid ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"
msgstr ""
"some_lock.acquire()\n"
"try:\n"
"    # fazer algo...\n"
"finally:\n"
"    some_lock.release()"

#: ../../library/threading.rst:1421
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"Atualmente, os objetos :class:`Lock`, :class:`RLock`, :class:`Condition`, :"
"class:`Semaphore` e :class:`BoundedSemaphore` podem ser usados como gestores "
"de contexto para instruções :keyword:`with`."

#: ../../library/threading.rst:222 ../../library/threading.rst:240
msgid "trace function"
msgstr "função de rastreamento"

#: ../../library/threading.rst:240
msgid "debugger"
msgstr "depurador"

#: ../../library/threading.rst:251 ../../library/threading.rst:269
msgid "profile function"
msgstr "função de perfil"
