# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-05 15:07+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-task.rst:6
msgid "Coroutines and Tasks"
msgstr "Corrotinas e Tarefas"

#: ../../library/asyncio-task.rst:8
msgid ""
"This section outlines high-level asyncio APIs to work with coroutines and "
"Tasks."
msgstr ""
"Esta secção descreve as APIs de alto nível do asyncio para trabalhar com "
"corrotinas e Tarefas."

#: ../../library/asyncio-task.rst:19 ../../library/asyncio-task.rst:148
msgid "Coroutines"
msgstr "Corrotinas"

#: ../../library/asyncio-task.rst:21
msgid "**Source code:** :source:`Lib/asyncio/coroutines.py`"
msgstr "**Código-fonte:** :source:`Lib/asyncio/coroutines.py`"

#: ../../library/asyncio-task.rst:25
msgid ""
":term:`Coroutines <coroutine>` declared with the async/await syntax is the "
"preferred way of writing asyncio applications.  For example, the following "
"snippet of code prints \"hello\", waits 1 second, and then prints \"world\"::"
msgstr ""
"As :term:`corrotinas <coroutine>` declaradas com a sintaxe async/await são a "
"forma preferida de escrever aplicações asyncio. Por exemplo, o seguinte "
"trecho de código imprime \"olá\", espera 1 segundo, e depois imprime "
"\"mundo\":"

#: ../../library/asyncio-task.rst:30
msgid ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('hello')\n"
"...     await asyncio.sleep(1)\n"
"...     print('world')\n"
"\n"
">>> asyncio.run(main())\n"
"hello\n"
"world"
msgstr ""
">>> import asyncio\n"
"\n"
">>> async def main():\n"
"...     print('olá')\n"
"...     await asyncio.sleep(1)\n"
"...     print('mundo')\n"
"\n"
">>> asyncio.run(main())\n"
"olá\n"
"mundo"

#: ../../library/asyncio-task.rst:41
msgid ""
"Note that simply calling a coroutine will not schedule it to be executed::"
msgstr ""
"Note que chamar simplesmente uma corrotina não a agendará para ser executada:"

#: ../../library/asyncio-task.rst:44
msgid ""
">>> main()\n"
"<coroutine object main at 0x1053bb7c8>"
msgstr ""
">>> main()\n"
"<objeto corrotina main em 0x1053bb7c8>"

#: ../../library/asyncio-task.rst:47
msgid "To actually run a coroutine, asyncio provides the following mechanisms:"
msgstr ""
"Para executar realmente uma corrotina, o asyncio fornece os seguintes "
"mecanismos:"

#: ../../library/asyncio-task.rst:49
msgid ""
"The :func:`asyncio.run` function to run the top-level entry point \"main()\" "
"function (see the above example.)"
msgstr ""
"A função :func:`asyncio.run` para executar o ponto de entrada de nível "
"superior \"main()\" (veja o exemplo acima)."

#: ../../library/asyncio-task.rst:52
msgid ""
"Awaiting on a coroutine.  The following snippet of code will print \"hello\" "
"after waiting for 1 second, and then print \"world\" after waiting for "
"*another* 2 seconds::"
msgstr ""
"Aguardar uma corrotina. O seguinte trecho de código imprimirá \"olá\" após "
"esperar 1 segundo, e depois imprimirá \"mundo\" após esperar *mais* 2 "
"segundos:"

#: ../../library/asyncio-task.rst:56
msgid ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'hello')\n"
"    await say_after(2, 'world')\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"import time\n"
"\n"
"async def say_after(delay, what):\n"
"    await asyncio.sleep(delay)\n"
"    print(what)\n"
"\n"
"async def main():\n"
"    print(f\"iniciado às {time.strftime('%X')}\")\n"
"\n"
"    await say_after(1, 'olá')\n"
"    await say_after(2, 'mundo')\n"
"\n"
"    print(f\"terminado às {time.strftime('%X')}\")\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:73
msgid "Expected output::"
msgstr "Saída esperada::"

#: ../../library/asyncio-task.rst:75
msgid ""
"started at 17:13:52\n"
"hello\n"
"world\n"
"finished at 17:13:55"
msgstr ""
"iniciado às 17:13:52\n"
"olá\n"
"mundo\n"
"terminado às 17:13:55"

#: ../../library/asyncio-task.rst:80
msgid ""
"The :func:`asyncio.create_task` function to run coroutines concurrently as "
"asyncio :class:`Tasks <Task>`."
msgstr ""
"A função :func:`asyncio.create_task` para executar corrotinas "
"concorrentemente como :class:`Tarefas <Task>` do asyncio."

#: ../../library/asyncio-task.rst:83
msgid ""
"Let's modify the above example and run two ``say_after`` coroutines "
"*concurrently*::"
msgstr ""
"Vamos modificar o exemplo acima e executar duas corrotinas ``say_after`` "
"*concorrentemente*:"

#: ../../library/asyncio-task.rst:86
msgid ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'hello'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'world'))\n"
"\n"
"    print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # Wait until both tasks are completed (should take\n"
"    # around 2 seconds.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    task1 = asyncio.create_task(\n"
"        say_after(1, 'olá'))\n"
"\n"
"    task2 = asyncio.create_task(\n"
"        say_after(2, 'mundo'))\n"
"\n"
"    print(f\"iniciado às {time.strftime('%X')}\")\n"
"\n"
"    # Aguardar até que ambas as tarefas estejam concluídas (deve demorar\n"
"    # cerca de 2 segundos.)\n"
"    await task1\n"
"    await task2\n"
"\n"
"    print(f\"terminado às {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:102
msgid ""
"Note that expected output now shows that the snippet runs 1 second faster "
"than before::"
msgstr ""
"Note que a saída esperada agora mostra que o trecho é executado 1 segundo "
"mais rápido do que antes:"

#: ../../library/asyncio-task.rst:105
msgid ""
"started at 17:14:32\n"
"hello\n"
"world\n"
"finished at 17:14:34"
msgstr ""
"iniciado às 17:14:32\n"
"olá\n"
"mundo\n"
"terminado às 17:14:34"

#: ../../library/asyncio-task.rst:110
msgid ""
"The :class:`asyncio.TaskGroup` class provides a more modern alternative to :"
"func:`create_task`. Using this API, the last example becomes::"
msgstr ""
"A classe :class:`asyncio.TaskGroup` fornece uma alternativa mais moderna a :"
"func:`create_task`. Usando esta API, o último exemplo torna-se:"

#: ../../library/asyncio-task.rst:114
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'hello'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'world'))\n"
"\n"
"        print(f\"started at {time.strftime('%X')}\")\n"
"\n"
"    # The await is implicit when the context manager exits.\n"
"\n"
"    print(f\"finished at {time.strftime('%X')}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(\n"
"            say_after(1, 'olá'))\n"
"\n"
"        task2 = tg.create_task(\n"
"            say_after(2, 'mundo'))\n"
"\n"
"        print(f\"iniciado às {time.strftime('%X')}\")\n"
"\n"
"    # O await é implícito quando o gestor de contexto sai.\n"
"\n"
"    print(f\"terminado às {time.strftime('%X')}\")"

#: ../../library/asyncio-task.rst:128
msgid "The timing and output should be the same as for the previous version."
msgstr "O tempo e a saída devem ser os mesmos que na versão anterior."

#: ../../library/asyncio-task.rst:130
msgid ":class:`asyncio.TaskGroup`."
msgstr ":class:`asyncio.TaskGroup`."

#: ../../library/asyncio-task.rst:137
msgid "Awaitables"
msgstr "Objetos aguardáveis"

#: ../../library/asyncio-task.rst:139
msgid ""
"We say that an object is an **awaitable** object if it can be used in an :"
"keyword:`await` expression.  Many asyncio APIs are designed to accept "
"awaitables."
msgstr ""
"Dizemos que um objeto é um objeto **aguardável** se pode ser usado numa "
"expressão :keyword:`await`. Muitas APIs do asyncio são concebidas para "
"aceitar objetos aguardáveis."

#: ../../library/asyncio-task.rst:143
msgid ""
"There are three main types of *awaitable* objects: **coroutines**, "
"**Tasks**, and **Futures**."
msgstr ""
"Existem três tipos principais de objetos *aguardáveis*: **corrotinas**, "
"**Tarefas** e **Futures**."

#: ../../library/asyncio-task.rst:149
msgid ""
"Python coroutines are *awaitables* and therefore can be awaited from other "
"coroutines::"
msgstr ""
"As corrotinas Python são *aguardáveis* e, portanto, podem ser aguardadas a "
"partir de outras corrotinas:"

#: ../../library/asyncio-task.rst:152
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nothing happens if we just call \"nested()\".\n"
"    # A coroutine object is created but not awaited,\n"
"    # so it *won't run at all*.\n"
"    nested()  # will raise a \"RuntimeWarning\".\n"
"\n"
"    # Let's do it differently now and await it:\n"
"    print(await nested())  # will print \"42\".\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Nada acontece se simplesmente chamarmos \"nested()\".\n"
"    # Um objeto corrotina é criado mas não é aguardado,\n"
"    # por isso *não será executado*.\n"
"    nested()  # irá levantar um \"RuntimeWarning\".\n"
"\n"
"    # Vamos fazer de forma diferente agora e aguardá-lo:\n"
"    print(await nested())  # irá imprimir \"42\".\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:170
msgid ""
"In this documentation the term \"coroutine\" can be used for two closely "
"related concepts:"
msgstr ""
"Nesta documentação, o termo \"corrotina\" pode ser usado para dois conceitos "
"intimamente relacionados:"

#: ../../library/asyncio-task.rst:173
msgid "a *coroutine function*: an :keyword:`async def` function;"
msgstr "uma *função corrotina*: uma função :keyword:`async def`;"

#: ../../library/asyncio-task.rst:175
msgid ""
"a *coroutine object*: an object returned by calling a *coroutine function*."
msgstr ""
"um *objeto corrotina*: um objeto devolvido pela chamada de uma *função "
"corrotina*."

#: ../../library/asyncio-task.rst:180
msgid "Tasks"
msgstr "Tarefas"

#: ../../library/asyncio-task.rst:181
msgid "*Tasks* are used to schedule coroutines *concurrently*."
msgstr "*Tarefas* são usadas para agendar corrotinas *concorrentemente*."

#: ../../library/asyncio-task.rst:183
msgid ""
"When a coroutine is wrapped into a *Task* with functions like :func:`asyncio."
"create_task` the coroutine is automatically scheduled to run soon::"
msgstr ""
"Quando uma corrotina é envolvida numa *Tarefa* com funções como :func:"
"`asyncio.create_task`, a corrotina é automaticamente agendada para ser "
"executada em breve:"

#: ../../library/asyncio-task.rst:187
msgid ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Schedule nested() to run soon concurrently\n"
"    # with \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" can now be used to cancel \"nested()\", or\n"
"    # can simply be awaited to wait until it is complete:\n"
"    await task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def nested():\n"
"    return 42\n"
"\n"
"async def main():\n"
"    # Agendar nested() para ser executada em breve concorrentemente\n"
"    # com \"main()\".\n"
"    task = asyncio.create_task(nested())\n"
"\n"
"    # \"task\" pode agora ser usada para cancelar \"nested()\", ou\n"
"    # pode simplesmente ser aguardada até estar completa:\n"
"    await task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:205
msgid "Futures"
msgstr "Futures"

#: ../../library/asyncio-task.rst:206
msgid ""
"A :class:`Future` is a special **low-level** awaitable object that "
"represents an **eventual result** of an asynchronous operation."
msgstr ""
"Um :class:`Future` é um objeto aguardável **de baixo nível** especial que "
"representa um **resultado eventual** de uma operação assíncrona."

#: ../../library/asyncio-task.rst:209
msgid ""
"When a Future object is *awaited* it means that the coroutine will wait "
"until the Future is resolved in some other place."
msgstr ""
"Quando um objeto Future é *aguardado*, significa que a corrotina aguardará "
"até que o Future seja resolvido noutro local."

#: ../../library/asyncio-task.rst:212
msgid ""
"Future objects in asyncio are needed to allow callback-based code to be used "
"with async/await."
msgstr ""
"Os objetos Future no asyncio são necessários para permitir que o código "
"baseado em callbacks seja usado com async/await."

#: ../../library/asyncio-task.rst:215
msgid ""
"Normally **there is no need** to create Future objects at the application "
"level code."
msgstr ""
"Normalmente, **não há necessidade** de criar objetos Future ao nível do "
"código da aplicação."

#: ../../library/asyncio-task.rst:218
msgid ""
"Future objects, sometimes exposed by libraries and some asyncio APIs, can be "
"awaited::"
msgstr ""
"Objetos Future, por vezes expostos por bibliotecas e algumas APIs do "
"asyncio, podem ser aguardados:"

#: ../../library/asyncio-task.rst:221
msgid ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # this is also valid:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"
msgstr ""
"async def main():\n"
"    await function_that_returns_a_future_object()\n"
"\n"
"    # isto também é válido:\n"
"    await asyncio.gather(\n"
"        function_that_returns_a_future_object(),\n"
"        some_python_coroutine()\n"
"    )"

#: ../../library/asyncio-task.rst:230
msgid ""
"A good example of a low-level function that returns a Future object is :meth:"
"`loop.run_in_executor`."
msgstr ""
"Um bom exemplo de uma função de baixo nível que devolve um objeto Future é :"
"meth:`loop.run_in_executor`."

#: ../../library/asyncio-task.rst:235
msgid "Creating Tasks"
msgstr "Criar Tarefas"

#: ../../library/asyncio-task.rst:237
msgid "**Source code:** :source:`Lib/asyncio/tasks.py`"
msgstr "**Código-fonte:** :source:`Lib/asyncio/tasks.py`"

#: ../../library/asyncio-task.rst:243
msgid ""
"Wrap the *coro* :ref:`coroutine <coroutine>` into a :class:`Task` and "
"schedule its execution.  Return the Task object."
msgstr ""
"Envolve a *coro* :ref:`corrotina <coroutine>` numa :class:`Task` e agenda a "
"sua execução. Devolve o objeto Tarefa."

#: ../../library/asyncio-task.rst:246
msgid ""
"If *name* is not ``None``, it is set as the name of the task using :meth:"
"`Task.set_name`."
msgstr ""

#: ../../library/asyncio-task.rst:249
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. The current context "
"copy is created when no *context* is provided."
msgstr ""
"Um argumento opcional apenas por palavra-chave *context* permite especificar "
"um :class:`contextvars.Context` personalizado para a *coro* ser executada. "
"Uma cópia do contexto atual é criada quando nenhum *context* é fornecido."

#: ../../library/asyncio-task.rst:253
msgid ""
"The task is executed in the loop returned by :func:`get_running_loop`, :exc:"
"`RuntimeError` is raised if there is no running loop in current thread."
msgstr ""
"A tarefa é executada no loop devolvido por :func:`get_running_loop`; :exc:"
"`RuntimeError` é levantado se não houver um loop em execução na thread atual."

#: ../../library/asyncio-task.rst:259
msgid ""
":meth:`asyncio.TaskGroup.create_task` is a new alternative leveraging "
"structural concurrency; it allows for waiting for a group of related tasks "
"with strong safety guarantees."
msgstr ""
":meth:`asyncio.TaskGroup.create_task` é uma nova alternativa que aproveita a "
"concorrência estruturada; permite aguardar por um grupo de tarefas "
"relacionadas com fortes garantias de segurança."

#: ../../library/asyncio-task.rst:265
msgid ""
"Save a reference to the result of this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done. For reliable \"fire-and-forget\" background "
"tasks, gather them in a collection::"
msgstr ""
"Guarde uma referência ao resultado desta função, para evitar que uma tarefa "
"desapareça durante a execução. O loop de eventos mantém apenas referências "
"fracas às tarefas. Uma tarefa que não seja referenciada noutro local pode "
"ser recolhida pelo garbage collector a qualquer momento, mesmo antes de "
"estar concluída. Para tarefas de fundo \"fire-and-forget\" confiáveis, "
"agrupe-as numa coleção:"

#: ../../library/asyncio-task.rst:272
msgid ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Add task to the set. This creates a strong reference.\n"
"    background_tasks.add(task)\n"
"\n"
"    # To prevent keeping references to finished tasks forever,\n"
"    # make each task remove its own reference from the set after\n"
"    # completion:\n"
"    task.add_done_callback(background_tasks.discard)"
msgstr ""
"background_tasks = set()\n"
"\n"
"for i in range(10):\n"
"    task = asyncio.create_task(some_coro(param=i))\n"
"\n"
"    # Adicionar tarefa ao conjunto. Isto cria uma referência forte.\n"
"    background_tasks.add(task)\n"
"\n"
"    # Para evitar manter referências a tarefas concluídas para sempre,\n"
"    # fazer com que cada tarefa remova a sua própria referência do conjunto "
"após\n"
"    # a conclusão:\n"
"    task.add_done_callback(background_tasks.discard)"

#: ../../library/asyncio-task.rst:287 ../../library/asyncio-task.rst:1193
msgid "Added the *name* parameter."
msgstr "Adicionado o parâmetro *name*."

#: ../../library/asyncio-task.rst:290 ../../library/asyncio-task.rst:1200
msgid "Added the *context* parameter."
msgstr "Adicionado o parâmetro *context*."

#: ../../library/asyncio-task.rst:295
msgid "Task Cancellation"
msgstr "Cancelamento de Tarefas"

#: ../../library/asyncio-task.rst:297
msgid ""
"Tasks can easily and safely be cancelled. When a task is cancelled, :exc:"
"`asyncio.CancelledError` will be raised in the task at the next opportunity."
msgstr ""
"As tarefas podem ser facilmente e com segurança canceladas. Quando uma "
"tarefa é cancelada, :exc:`asyncio.CancelledError` será levantada na tarefa "
"na próxima oportunidade."

#: ../../library/asyncio-task.rst:301
msgid ""
"It is recommended that coroutines use ``try/finally`` blocks to robustly "
"perform clean-up logic. In case :exc:`asyncio.CancelledError` is explicitly "
"caught, it should generally be propagated when clean-up is complete. :exc:"
"`asyncio.CancelledError` directly subclasses :exc:`BaseException` so most "
"code will not need to be aware of it."
msgstr ""
"Recomenda-se que as corrotinas usem blocos ``try/finally`` para executar de "
"forma robusta a lógica de limpeza. Caso :exc:`asyncio.CancelledError` seja "
"explicitamente capturada, deve geralmente ser propagada quando a limpeza "
"estiver completa. :exc:`asyncio.CancelledError` é uma subclasse direta de :"
"exc:`BaseException`, por isso a maioria do código não precisará de estar "
"ciente dela."

#: ../../library/asyncio-task.rst:307
msgid ""
"The asyncio components that enable structured concurrency, like :class:"
"`asyncio.TaskGroup` and :func:`asyncio.timeout`, are implemented using "
"cancellation internally and might misbehave if a coroutine swallows :exc:"
"`asyncio.CancelledError`. Similarly, user code should not generally call :"
"meth:`uncancel <asyncio.Task.uncancel>`. However, in cases when suppressing :"
"exc:`asyncio.CancelledError` is truly desired, it is necessary to also call "
"``uncancel()`` to completely remove the cancellation state."
msgstr ""
"Os componentes do asyncio que permitem concorrência estruturada, como :class:"
"`asyncio.TaskGroup` e :func:`asyncio.timeout`, são implementados usando "
"cancelamento internamente e podem comportar-se mal se uma corrotina "
"suprimir :exc:`asyncio.CancelledError`. Da mesma forma, o código do "
"utilizador não deve geralmente chamar :meth:`uncancel <asyncio.Task."
"uncancel>`. No entanto, em casos em que suprimir :exc:`asyncio."
"CancelledError` é realmente desejado, é necessário também chamar "
"``uncancel()`` para remover completamente o estado de cancelamento."

#: ../../library/asyncio-task.rst:319
msgid "Task Groups"
msgstr "Grupos de Tarefas"

#: ../../library/asyncio-task.rst:321
msgid ""
"Task groups combine a task creation API with a convenient and reliable way "
"to wait for all tasks in the group to finish."
msgstr ""
"Os grupos de tarefas combinam uma API de criação de tarefas com uma forma "
"conveniente e confiável de aguardar que todas as tarefas do grupo terminem."

#: ../../library/asyncio-task.rst:326
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` holding a "
"group of tasks. Tasks can be added to the group using :meth:`create_task`. "
"All tasks are awaited when the context manager exits."
msgstr ""
"Um :ref:`gestor de contexto assíncrono <async-context-managers>` que contém "
"um grupo de tarefas. As tarefas podem ser adicionadas ao grupo usando :meth:"
"`create_task`. Todas as tarefas são aguardadas quando o gestor de contexto "
"sai."

#: ../../library/asyncio-task.rst:335
msgid ""
"Create a task in this task group. The signature matches that of :func:"
"`asyncio.create_task`. If the task group is inactive (e.g. not yet entered, "
"already finished, or in the process of shutting down), we will close the "
"given ``coro``."
msgstr ""
"Cria uma tarefa neste grupo de tarefas. A assinatura corresponde à de :func:"
"`asyncio.create_task`. Se o grupo de tarefas estiver inativo (por exemplo, "
"ainda não entrado, já terminado, ou em processo de encerramento), fecharemos "
"a ``coro`` dada."

#: ../../library/asyncio-task.rst:343
msgid "Close the given coroutine if the task group is not active."
msgstr "Fecha a corrotina dada se o grupo de tarefas não estiver ativo."

#: ../../library/asyncio-task.rst:345 ../../library/asyncio-task.rst:551
#: ../../library/asyncio-task.rst:724 ../../library/asyncio-task.rst:782
#: ../../library/asyncio-task.rst:808 ../../library/asyncio-task.rst:849
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/asyncio-task.rst:347
msgid ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Both tasks have completed now: {task1.result()}, {task2."
"result()}\")"
msgstr ""
"async def main():\n"
"    async with asyncio.TaskGroup() as tg:\n"
"        task1 = tg.create_task(some_coro(...))\n"
"        task2 = tg.create_task(another_coro(...))\n"
"    print(f\"Ambas as tarefas estão agora concluídas: {task1.result()}, "
"{task2.result()}\")"

#: ../../library/asyncio-task.rst:353
msgid ""
"The ``async with`` statement will wait for all tasks in the group to finish. "
"While waiting, new tasks may still be added to the group (for example, by "
"passing ``tg`` into one of the coroutines and calling ``tg.create_task()`` "
"in that coroutine). Once the last task has finished and the ``async with`` "
"block is exited, no new tasks may be added to the group."
msgstr ""
"A instrução ``async with`` aguardará que todas as tarefas do grupo terminem. "
"Enquanto aguarda, novas tarefas ainda podem ser adicionadas ao grupo (por "
"exemplo, passando ``tg`` para uma das corrotinas e chamando ``tg."
"create_task()`` nessa corrotina). Uma vez que a última tarefa tenha "
"terminado e o bloco ``async with`` seja saído, não podem ser adicionadas "
"novas tarefas ao grupo."

#: ../../library/asyncio-task.rst:360
msgid ""
"The first time any of the tasks belonging to the group fails with an "
"exception other than :exc:`asyncio.CancelledError`, the remaining tasks in "
"the group are cancelled. No further tasks can then be added to the group. At "
"this point, if the body of the ``async with`` statement is still active (i."
"e., :meth:`~object.__aexit__` hasn't been called yet), the task directly "
"containing the ``async with`` statement is also cancelled. The resulting :"
"exc:`asyncio.CancelledError` will interrupt an ``await``, but it will not "
"bubble out of the containing ``async with`` statement."
msgstr ""
"Na primeira vez que qualquer uma das tarefas pertencentes ao grupo falha com "
"uma exceção diferente de :exc:`asyncio.CancelledError`, as tarefas restantes "
"no grupo são canceladas. Não podem ser adicionadas mais tarefas ao grupo. "
"Neste ponto, se o corpo da instrução ``async with`` ainda estiver ativo (ou "
"seja, :meth:`~object.__aexit__` ainda não foi chamado), a tarefa que contém "
"diretamente a instrução ``async with`` também é cancelada. A :exc:`asyncio."
"CancelledError` resultante irá interromper um ``await``, mas não se "
"propagará para fora da instrução ``async with``."

#: ../../library/asyncio-task.rst:370
msgid ""
"Once all tasks have finished, if any tasks have failed with an exception "
"other than :exc:`asyncio.CancelledError`, those exceptions are combined in "
"an :exc:`ExceptionGroup` or :exc:`BaseExceptionGroup` (as appropriate; see "
"their documentation) which is then raised."
msgstr ""
"Uma vez que todas as tarefas tenham terminado, se alguma tarefa falhou com "
"uma exceção diferente de :exc:`asyncio.CancelledError`, essas exceções são "
"combinadas num :exc:`ExceptionGroup` ou :exc:`BaseExceptionGroup` (conforme "
"apropriado; veja a sua documentação), que é então levantado."

#: ../../library/asyncio-task.rst:377
msgid ""
"Two base exceptions are treated specially: If any task fails with :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit`, the task group still cancels the "
"remaining tasks and waits for them, but then the initial :exc:"
"`KeyboardInterrupt` or :exc:`SystemExit` is re-raised instead of :exc:"
"`ExceptionGroup` or :exc:`BaseExceptionGroup`."
msgstr ""
"Duas exceções base são tratadas de forma especial: Se alguma tarefa falhar "
"com :exc:`KeyboardInterrupt` ou :exc:`SystemExit`, o grupo de tarefas ainda "
"cancela as tarefas restantes e aguarda por elas, mas depois a :exc:"
"`KeyboardInterrupt` ou :exc:`SystemExit` inicial é levantada novamente em "
"vez de :exc:`ExceptionGroup` ou :exc:`BaseExceptionGroup`."

#: ../../library/asyncio-task.rst:383
msgid ""
"If the body of the ``async with`` statement exits with an exception (so :"
"meth:`~object.__aexit__` is called with an exception set), this is treated "
"the same as if one of the tasks failed: the remaining tasks are cancelled "
"and then waited for, and non-cancellation exceptions are grouped into an "
"exception group and raised. The exception passed into :meth:`~object."
"__aexit__`, unless it is :exc:`asyncio.CancelledError`, is also included in "
"the exception group. The same special case is made for :exc:"
"`KeyboardInterrupt` and :exc:`SystemExit` as in the previous paragraph."
msgstr ""
"Se o corpo da instrução ``async with`` sair com uma exceção (portanto, :meth:"
"`~object.__aexit__` é chamado com uma exceção definida), isto é tratado da "
"mesma forma que se uma das tarefas falhasse: as tarefas restantes são "
"canceladas e depois aguardadas, e as exceções não de cancelamento são "
"agrupadas num grupo de exceções e levantadas. A exceção passada para :meth:"
"`~object.__aexit__`, a menos que seja :exc:`asyncio.CancelledError`, também "
"é incluída no grupo de exceções. O mesmo caso especial é feito para :exc:"
"`KeyboardInterrupt` e :exc:`SystemExit` como no parágrafo anterior."

#: ../../library/asyncio-task.rst:395
msgid ""
"Task groups are careful not to mix up the internal cancellation used to "
"\"wake up\" their :meth:`~object.__aexit__` with cancellation requests for "
"the task in which they are running made by other parties. In particular, "
"when one task group is syntactically nested in another, and both experience "
"an exception in one of their child tasks simultaneously, the inner task "
"group will process its exceptions, and then the outer task group will "
"receive another cancellation and process its own exceptions."
msgstr ""
"Os grupos de tarefas têm cuidado para não confundir o cancelamento interno "
"usado para \"acordar\" o seu :meth:`~object.__aexit__` com pedidos de "
"cancelamento para a tarefa na qual estão a ser executados feitos por outras "
"partes. Em particular, quando um grupo de tarefas está sintaticamente "
"aninhado noutro, e ambos experimentam uma exceção numa das suas tarefas "
"filhas simultaneamente, o grupo de tarefas interno processará as suas "
"exceções, e depois o grupo de tarefas externo receberá outro cancelamento e "
"processará as suas próprias exceções."

#: ../../library/asyncio-task.rst:403
msgid ""
"In the case where a task group is cancelled externally and also must raise "
"an :exc:`ExceptionGroup`, it will call the parent task's :meth:`~asyncio."
"Task.cancel` method. This ensures that a :exc:`asyncio.CancelledError` will "
"be raised at the next :keyword:`await`, so the cancellation is not lost."
msgstr ""
"No caso em que um grupo de tarefas é cancelado externamente e também deve "
"levantar um :exc:`ExceptionGroup`, chamará o método :meth:`~asyncio.Task."
"cancel` da tarefa pai. Isto garante que um :exc:`asyncio.CancelledError` "
"será levantado no próximo :keyword:`await`, para que o cancelamento não se "
"perca."

#: ../../library/asyncio-task.rst:409
msgid ""
"Task groups preserve the cancellation count reported by :meth:`asyncio.Task."
"cancelling`."
msgstr ""
"Os grupos de tarefas preservam a contagem de cancelamentos reportada por :"
"meth:`asyncio.Task.cancelling`."

#: ../../library/asyncio-task.rst:414
msgid ""
"Improved handling of simultaneous internal and external cancellations and "
"correct preservation of cancellation counts."
msgstr ""
"Melhoria no tratamento de cancelamentos internos e externos simultâneos e "
"preservação correta das contagens de cancelamentos."

#: ../../library/asyncio-task.rst:418
msgid "Terminating a Task Group"
msgstr "Terminar um Grupo de Tarefas"

#: ../../library/asyncio-task.rst:420
msgid ""
"While terminating a task group is not natively supported by the standard "
"library, termination can be achieved by adding an exception-raising task to "
"the task group and ignoring the raised exception:"
msgstr ""
"Embora a terminação de um grupo de tarefas não seja nativamente suportada "
"pela biblioteca padrão, a terminação pode ser alcançada adicionando uma "
"tarefa que levanta uma exceção ao grupo de tarefas e ignorando a exceção "
"levantada:"

#: ../../library/asyncio-task.rst:424
msgid ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exception raised to terminate a task group.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Used to force termination of a task group.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Task {task_id}: start')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Task {task_id}: done')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # spawn some tasks\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # sleep for 1 second\n"
"            await asyncio.sleep(1)\n"
"            # add an exception-raising task to force the group to terminate\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"from asyncio import TaskGroup\n"
"\n"
"class TerminateTaskGroup(Exception):\n"
"    \"\"\"Exceção levantada para terminar um grupo de tarefas.\"\"\"\n"
"\n"
"async def force_terminate_task_group():\n"
"    \"\"\"Usado para forçar a terminação de um grupo de tarefas.\"\"\"\n"
"    raise TerminateTaskGroup()\n"
"\n"
"async def job(task_id, sleep_time):\n"
"    print(f'Tarefa {task_id}: início')\n"
"    await asyncio.sleep(sleep_time)\n"
"    print(f'Tarefa {task_id}: concluída')\n"
"\n"
"async def main():\n"
"    try:\n"
"        async with TaskGroup() as group:\n"
"            # criar algumas tarefas\n"
"            group.create_task(job(1, 0.5))\n"
"            group.create_task(job(2, 1.5))\n"
"            # dormir por 1 segundo\n"
"            await asyncio.sleep(1)\n"
"            # adicionar uma tarefa que levanta uma exceção para forçar o "
"grupo a terminar\n"
"            group.create_task(force_terminate_task_group())\n"
"    except* TerminateTaskGroup:\n"
"        pass\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-task.rst:456
msgid "Expected output:"
msgstr "Saída esperada:"

#: ../../library/asyncio-task.rst:458
msgid ""
"Task 1: start\n"
"Task 2: start\n"
"Task 1: done"
msgstr ""
"Tarefa 1: início\n"
"Tarefa 2: início\n"
"Tarefa 1: concluída"

#: ../../library/asyncio-task.rst:465
msgid "Sleeping"
msgstr "Dormir"

#: ../../library/asyncio-task.rst:470
msgid "Block for *delay* seconds."
msgstr "Bloquear por *delay* segundos."

#: ../../library/asyncio-task.rst:472
msgid ""
"If *result* is provided, it is returned to the caller when the coroutine "
"completes."
msgstr ""
"Se *result* for fornecido, é devolvido ao chamador quando a corrotina "
"termina."

#: ../../library/asyncio-task.rst:475
msgid ""
"``sleep()`` always suspends the current task, allowing other tasks to run."
msgstr ""
"``sleep()`` sempre suspende a tarefa atual, permitindo que outras tarefas "
"sejam executadas."

#: ../../library/asyncio-task.rst:478
msgid ""
"Setting the delay to 0 provides an optimized path to allow other tasks to "
"run. This can be used by long-running functions to avoid blocking the event "
"loop for the full duration of the function call."
msgstr ""
"Definir o atraso para 0 fornece um caminho otimizado para permitir que "
"outras tarefas sejam executadas. Isto pode ser usado por funções de longa "
"duração para evitar bloquear o loop de eventos durante toda a duração da "
"chamada da função."

#: ../../library/asyncio-task.rst:484
msgid ""
"Example of coroutine displaying the current date every second for 5 seconds::"
msgstr ""
"Exemplo de corrotina que mostra a data atual a cada segundo durante 5 "
"segundos:"

#: ../../library/asyncio-task.rst:487
msgid ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"
msgstr ""
"import asyncio\n"
"import datetime\n"
"\n"
"async def display_date():\n"
"    loop = asyncio.get_running_loop()\n"
"    end_time = loop.time() + 5.0\n"
"    while True:\n"
"        print(datetime.datetime.now())\n"
"        if (loop.time() + 1.0) >= end_time:\n"
"            break\n"
"        await asyncio.sleep(1)\n"
"\n"
"asyncio.run(display_date())"

#: ../../library/asyncio-task.rst:502 ../../library/asyncio-task.rst:600
#: ../../library/asyncio-task.rst:699 ../../library/asyncio-task.rst:874
#: ../../library/asyncio-task.rst:929 ../../library/asyncio-task.rst:986
msgid "Removed the *loop* parameter."
msgstr "Removido o parâmetro *loop*."

#: ../../library/asyncio-task.rst:505
msgid "Raises :exc:`ValueError` if *delay* is :data:`~math.nan`."
msgstr "Levanta :exc:`ValueError` se *delay* for :data:`~math.nan`."

#: ../../library/asyncio-task.rst:510
msgid "Running Tasks Concurrently"
msgstr "Executar Tarefas Concorrentemente"

#: ../../library/asyncio-task.rst:514
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* sequence "
"*concurrently*."
msgstr ""
"Executa :ref:`objetos aguardáveis <asyncio-awaitables>` na sequência *aws* "
"*concorrentemente*."

#: ../../library/asyncio-task.rst:517
msgid ""
"If any awaitable in *aws* is a coroutine, it is automatically scheduled as a "
"Task."
msgstr ""
"Se algum aguardável em *aws* for uma corrotina, é automaticamente agendado "
"como uma Tarefa."

#: ../../library/asyncio-task.rst:520
msgid ""
"If all awaitables are completed successfully, the result is an aggregate "
"list of returned values.  The order of result values corresponds to the "
"order of awaitables in *aws*."
msgstr ""
"Se todos os aguardáveis forem concluídos com sucesso, o resultado é uma "
"lista agregada de valores devolvidos. A ordem dos valores do resultado "
"corresponde à ordem dos aguardáveis em *aws*."

#: ../../library/asyncio-task.rst:524
msgid ""
"If *return_exceptions* is ``False`` (default), the first raised exception is "
"immediately propagated to the task that awaits on ``gather()``.  Other "
"awaitables in the *aws* sequence **won't be cancelled** and will continue to "
"run."
msgstr ""
"Se *return_exceptions* for ``False`` (predefinição), a primeira exceção "
"levantada é imediatamente propagada para a tarefa que aguarda em "
"``gather()``. Outros aguardáveis na sequência *aws* **não serão cancelados** "
"e continuarão a ser executados."

#: ../../library/asyncio-task.rst:529
msgid ""
"If *return_exceptions* is ``True``, exceptions are treated the same as "
"successful results, and aggregated in the result list."
msgstr ""
"Se *return_exceptions* for ``True``, as exceções são tratadas da mesma forma "
"que resultados bem-sucedidos, e agregadas na lista de resultados."

#: ../../library/asyncio-task.rst:532
msgid ""
"If ``gather()`` is *cancelled*, all submitted awaitables (that have not "
"completed yet) are also *cancelled*."
msgstr ""
"Se ``gather()`` for *cancelado*, todos os aguardáveis submetidos (que ainda "
"não foram concluídos) também são *cancelados*."

#: ../../library/asyncio-task.rst:535
msgid ""
"If any Task or Future from the *aws* sequence is *cancelled*, it is treated "
"as if it raised :exc:`CancelledError` -- the ``gather()`` call is **not** "
"cancelled in this case.  This is to prevent the cancellation of one "
"submitted Task/Future to cause other Tasks/Futures to be cancelled."
msgstr ""
"Se qualquer Tarefa ou Future da sequência *aws* for *cancelada*, é tratada "
"como se tivesse levantado :exc:`CancelledError` — a chamada ``gather()`` "
"**não** é cancelada neste caso. Isto é para evitar que o cancelamento de uma "
"Tarefa/Future submetida cause o cancelamento de outras Tarefas/Futures."

#: ../../library/asyncio-task.rst:542
msgid ""
"A new alternative to create and run tasks concurrently and wait for their "
"completion is :class:`asyncio.TaskGroup`. *TaskGroup* provides stronger "
"safety guarantees than *gather* for scheduling a nesting of subtasks: if a "
"task (or a subtask, a task scheduled by a task) raises an exception, "
"*TaskGroup* will, while *gather* will not, cancel the remaining scheduled "
"tasks)."
msgstr ""
"Uma nova alternativa para criar e executar tarefas concorrentemente e "
"aguardar pela sua conclusão é :class:`asyncio.TaskGroup`. *TaskGroup* "
"fornece garantias de segurança mais fortes do que *gather* para agendar um "
"aninhamento de subtarefas: se uma tarefa (ou uma subtarefa, uma tarefa "
"agendada por uma tarefa) levantar uma exceção, *TaskGroup* cancelará as "
"tarefas agendadas restantes, enquanto *gather* não o fará."

#: ../../library/asyncio-task.rst:553
msgid ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Task {name}: Compute factorial({number}), currently i={i}..."
"\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Task {name}: factorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Schedule three calls *concurrently*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     Task A: Compute factorial(2), currently i=2...\n"
"#     Task B: Compute factorial(3), currently i=2...\n"
"#     Task C: Compute factorial(4), currently i=2...\n"
"#     Task A: factorial(2) = 2\n"
"#     Task B: Compute factorial(3), currently i=3...\n"
"#     Task C: Compute factorial(4), currently i=3...\n"
"#     Task B: factorial(3) = 6\n"
"#     Task C: Compute factorial(4), currently i=4...\n"
"#     Task C: factorial(4) = 24\n"
"#     [2, 6, 24]"
msgstr ""
"import asyncio\n"
"\n"
"async def factorial(name, number):\n"
"    f = 1\n"
"    for i in range(2, number + 1):\n"
"        print(f\"Tarefa {name}: Calcular fatorial({number}), atualmente "
"i={i}...\")\n"
"        await asyncio.sleep(1)\n"
"        f *= i\n"
"    print(f\"Tarefa {name}: fatorial({number}) = {f}\")\n"
"    return f\n"
"\n"
"async def main():\n"
"    # Agendar três chamadas *concorrentemente*:\n"
"    L = await asyncio.gather(\n"
"        factorial(\"A\", 2),\n"
"        factorial(\"B\", 3),\n"
"        factorial(\"C\", 4),\n"
"    )\n"
"    print(L)\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Saída esperada:\n"
"#\n"
"#     Tarefa A: Calcular fatorial(2), atualmente i=2...\n"
"#     Tarefa B: Calcular fatorial(3), atualmente i=2...\n"
"#     Tarefa C: Calcular fatorial(4), atualmente i=2...\n"
"#     Tarefa A: fatorial(2) = 2\n"
"#     Tarefa B: Calcular fatorial(3), atualmente i=3...\n"
"#     Tarefa C: Calcular fatorial(4), atualmente i=3...\n"
"#     Tarefa B: fatorial(3) = 6\n"
"#     Tarefa C: Calcular fatorial(4), atualmente i=4...\n"
"#     Tarefa C: fatorial(4) = 24\n"
"#     [2, 6, 24]"

#: ../../library/asyncio-task.rst:589
msgid ""
"If *return_exceptions* is false, cancelling gather() after it has been "
"marked done won't cancel any submitted awaitables. For instance, gather can "
"be marked done after propagating an exception to the caller, therefore, "
"calling ``gather.cancel()`` after catching an exception (raised by one of "
"the awaitables) from gather won't cancel any other awaitables."
msgstr ""
"Se *return_exceptions* for falso, cancelar gather() depois de ter sido "
"marcado como concluído não cancelará quaisquer aguardáveis submetidos. Por "
"exemplo, gather pode ser marcado como concluído após propagar uma exceção "
"para o chamador, portanto, chamar ``gather.cancel()`` após capturar uma "
"exceção (levantada por um dos aguardáveis) de gather não cancelará quaisquer "
"outros aguardáveis."

#: ../../library/asyncio-task.rst:596
msgid ""
"If the *gather* itself is cancelled, the cancellation is propagated "
"regardless of *return_exceptions*."
msgstr ""
"Se o próprio *gather* for cancelado, o cancelamento é propagado "
"independentemente de *return_exceptions*."

#: ../../library/asyncio-task.rst:603
msgid ""
"Deprecation warning is emitted if no positional arguments are provided or "
"not all positional arguments are Future-like objects and there is no running "
"event loop."
msgstr ""
"É emitido um aviso de descontinuação se não forem fornecidos argumentos "
"posicionais ou se nem todos os argumentos posicionais forem objetos do tipo "
"Future e não houver um loop de eventos em execução."

#: ../../library/asyncio-task.rst:612
msgid "Eager Task Factory"
msgstr "Fábrica de Tarefas Eager"

#: ../../library/asyncio-task.rst:616
msgid "A task factory for eager task execution."
msgstr "Uma fábrica de tarefas para execução eager."

#: ../../library/asyncio-task.rst:618
msgid ""
"When using this factory (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), coroutines begin execution "
"synchronously during :class:`Task` construction. Tasks are only scheduled on "
"the event loop if they block. This can be a performance improvement as the "
"overhead of loop scheduling is avoided for coroutines that complete "
"synchronously."
msgstr ""
"Ao usar esta fábrica (via :meth:`loop.set_task_factory(asyncio."
"eager_task_factory) <loop.set_task_factory>`), as corrotinas começam a "
"execução de forma síncrona durante a construção de :class:`Task`. As tarefas "
"são agendadas no loop de eventos apenas se bloquearem. Isto pode ser uma "
"melhoria de desempenho, uma vez que a sobrecarga do agendamento do loop é "
"evitada para corrotinas que são concluídas de forma síncrona."

#: ../../library/asyncio-task.rst:624
msgid ""
"A common example where this is beneficial is coroutines which employ caching "
"or memoization to avoid actual I/O when possible."
msgstr ""
"Um exemplo comum em que isto é benéfico são corrotinas que empregam caching "
"ou memoização para evitar I/O real sempre que possível."

#: ../../library/asyncio-task.rst:629
msgid ""
"Immediate execution of the coroutine is a semantic change. If the coroutine "
"returns or raises, the task is never scheduled to the event loop. If the "
"coroutine execution blocks, the task is scheduled to the event loop. This "
"change may introduce behavior changes to existing applications. For example, "
"the application's task execution order is likely to change."
msgstr ""
"A execução imediata da corrotina é uma mudança semântica. Se a corrotina "
"devolver ou levantar uma exceção, a tarefa nunca é agendada no loop de "
"eventos. Se a execução da corrotina bloquear, a tarefa é agendada no loop de "
"eventos. Esta mudança pode introduzir alterações de comportamento em "
"aplicações existentes. Por exemplo, a ordem de execução das tarefas da "
"aplicação provavelmente mudará."

#: ../../library/asyncio-task.rst:640
msgid ""
"Create an eager task factory, similar to :func:`eager_task_factory`, using "
"the provided *custom_task_constructor* when creating a new task instead of "
"the default :class:`Task`."
msgstr ""
"Cria uma fábrica de tarefas eager, semelhante a :func:`eager_task_factory`, "
"usando o *custom_task_constructor* fornecido ao criar uma nova tarefa em vez "
"do :class:`Task` predefinido."

#: ../../library/asyncio-task.rst:644
msgid ""
"*custom_task_constructor* must be a *callable* with the signature matching "
"the signature of :class:`Task.__init__ <Task>`. The callable must return a :"
"class:`asyncio.Task`-compatible object."
msgstr ""
"*custom_task_constructor* deve ser um *callable* com a assinatura "
"correspondente à assinatura de :class:`Task.__init__ <Task>`. O callable "
"deve devolver um objeto compatível com :class:`asyncio.Task`."

#: ../../library/asyncio-task.rst:648
msgid ""
"This function returns a *callable* intended to be used as a task factory of "
"an event loop via :meth:`loop.set_task_factory(factory) <loop."
"set_task_factory>`)."
msgstr ""
"Esta função devolve um *callable* destinado a ser usado como uma fábrica de "
"tarefas de um loop de eventos via :meth:`loop.set_task_factory(factory) "
"<loop.set_task_factory>`)."

#: ../../library/asyncio-task.rst:655
msgid "Shielding From Cancellation"
msgstr "Proteção Contra Cancelamento"

#: ../../library/asyncio-task.rst:659
msgid ""
"Protect an :ref:`awaitable object <asyncio-awaitables>` from being :meth:"
"`cancelled <Task.cancel>`."
msgstr ""
"Protege um :ref:`objeto aguardável <asyncio-awaitables>` de ser :meth:"
"`cancelado <Task.cancel>`."

#: ../../library/asyncio-task.rst:662 ../../library/asyncio-task.rst:829
msgid "If *aw* is a coroutine it is automatically scheduled as a Task."
msgstr "Se *aw* for uma corrotina, é automaticamente agendada como uma Tarefa."

#: ../../library/asyncio-task.rst:664
msgid "The statement::"
msgstr "A instrução::"

#: ../../library/asyncio-task.rst:666
msgid ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"
msgstr ""
"task = asyncio.create_task(something())\n"
"res = await shield(task)"

#: ../../library/asyncio-task.rst:669
msgid "is equivalent to::"
msgstr "é equivalente a::"

#: ../../library/asyncio-task.rst:671
msgid "res = await something()"
msgstr "res = await something()"

#: ../../library/asyncio-task.rst:673
msgid ""
"*except* that if the coroutine containing it is cancelled, the Task running "
"in ``something()`` is not cancelled.  From the point of view of "
"``something()``, the cancellation did not happen. Although its caller is "
"still cancelled, so the \"await\" expression still raises a :exc:"
"`CancelledError`."
msgstr ""
"*exceto* que se a corrotina que a contém for cancelada, a Tarefa em execução "
"em ``something()`` não é cancelada. Do ponto de vista de ``something()``, o "
"cancelamento não ocorreu. Embora o seu chamador ainda esteja cancelado, por "
"isso a expressão \"await\" ainda levanta uma :exc:`CancelledError`."

#: ../../library/asyncio-task.rst:679
msgid ""
"If ``something()`` is cancelled by other means (i.e. from within itself) "
"that would also cancel ``shield()``."
msgstr ""
"Se ``something()`` for cancelado por outros meios (por exemplo, a partir de "
"si próprio), isso também cancelaria ``shield()``."

#: ../../library/asyncio-task.rst:682
msgid ""
"If it is desired to completely ignore cancellation (not recommended) the "
"``shield()`` function should be combined with a try/except clause, as "
"follows::"
msgstr ""
"Se for desejado ignorar completamente o cancelamento (não recomendado), a "
"função ``shield()`` deve ser combinada com uma cláusula try/except, como se "
"segue:"

#: ../../library/asyncio-task.rst:686
msgid ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"
msgstr ""
"task = asyncio.create_task(something())\n"
"try:\n"
"    res = await shield(task)\n"
"except CancelledError:\n"
"    res = None"

#: ../../library/asyncio-task.rst:694
msgid ""
"Save a reference to tasks passed to this function, to avoid a task "
"disappearing mid-execution. The event loop only keeps weak references to "
"tasks. A task that isn't referenced elsewhere may get garbage collected at "
"any time, even before it's done."
msgstr ""
"Guarde uma referência às tarefas passadas para esta função, para evitar que "
"uma tarefa desapareça durante a execução. O loop de eventos mantém apenas "
"referências fracas às tarefas. Uma tarefa que não seja referenciada noutro "
"local pode ser recolhida pelo garbage collector a qualquer momento, mesmo "
"antes de estar concluída."

#: ../../library/asyncio-task.rst:702
msgid ""
"Deprecation warning is emitted if *aw* is not Future-like object and there "
"is no running event loop."
msgstr ""
"É emitido um aviso de descontinuação se *aw* não for um objeto do tipo "
"Future e não houver um loop de eventos em execução."

#: ../../library/asyncio-task.rst:708
msgid "Timeouts"
msgstr "Timeouts"

#: ../../library/asyncio-task.rst:712
msgid ""
"Return an :ref:`asynchronous context manager <async-context-managers>` that "
"can be used to limit the amount of time spent waiting on something."
msgstr ""
"Devolve um :ref:`gestor de contexto assíncrono <async-context-managers>` que "
"pode ser usado para limitar a quantidade de tempo gasto à espera de algo."

#: ../../library/asyncio-task.rst:716
msgid ""
"*delay* can either be ``None``, or a float/int number of seconds to wait. If "
"*delay* is ``None``, no time limit will be applied; this can be useful if "
"the delay is unknown when the context manager is created."
msgstr ""
"*delay* pode ser ``None`` ou um número float/int de segundos para esperar. "
"Se *delay* for ``None``, nenhum limite de tempo será aplicado; isto pode ser "
"útil se o atraso for desconhecido quando o gestor de contexto é criado."

#: ../../library/asyncio-task.rst:721
msgid ""
"In either case, the context manager can be rescheduled after creation using :"
"meth:`Timeout.reschedule`."
msgstr ""
"Em qualquer dos casos, o gestor de contexto pode ser reagendado após a "
"criação usando :meth:`Timeout.reschedule`."

#: ../../library/asyncio-task.rst:726
msgid ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"
msgstr ""
"async def main():\n"
"    async with asyncio.timeout(10):\n"
"        await long_running_task()"

#: ../../library/asyncio-task.rst:730
msgid ""
"If ``long_running_task`` takes more than 10 seconds to complete, the context "
"manager will cancel the current task and handle the resulting :exc:`asyncio."
"CancelledError` internally, transforming it into a :exc:`TimeoutError` which "
"can be caught and handled."
msgstr ""
"Se ``long_running_task`` demorar mais de 10 segundos a concluir, o gestor de "
"contexto cancelará a tarefa atual e tratará o :exc:`asyncio.CancelledError` "
"resultante internamente, transformando-o num :exc:`TimeoutError` que pode "
"ser capturado e tratado."

#: ../../library/asyncio-task.rst:737
msgid ""
"The :func:`asyncio.timeout` context manager is what transforms the :exc:"
"`asyncio.CancelledError` into a :exc:`TimeoutError`, which means the :exc:"
"`TimeoutError` can only be caught *outside* of the context manager."
msgstr ""
"O gestor de contexto :func:`asyncio.timeout` é o que transforma o :exc:"
"`asyncio.CancelledError` num :exc:`TimeoutError`, o que significa que o :exc:"
"`TimeoutError` só pode ser capturado *fora* do gestor de contexto."

#: ../../library/asyncio-task.rst:742
msgid "Example of catching :exc:`TimeoutError`::"
msgstr "Exemplo de captura de :exc:`TimeoutError`:"

#: ../../library/asyncio-task.rst:744
msgid ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        async with asyncio.timeout(10):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"A operação longa expirou, mas nós tratámos disso.\")\n"
"\n"
"    print(\"Esta instrução será executada independentemente.\")"

#: ../../library/asyncio-task.rst:753
msgid ""
"The context manager produced by :func:`asyncio.timeout` can be rescheduled "
"to a different deadline and inspected."
msgstr ""
"O gestor de contexto produzido por :func:`asyncio.timeout` pode ser "
"reagendado para um prazo diferente e inspecionado."

#: ../../library/asyncio-task.rst:758
msgid ""
"An :ref:`asynchronous context manager <async-context-managers>` for "
"cancelling overdue coroutines."
msgstr ""
"Um :ref:`gestor de contexto assíncrono <async-context-managers>` para "
"cancelar corrotinas atrasadas."

#: ../../library/asyncio-task.rst:761
msgid ""
"``when`` should be an absolute time at which the context should time out, as "
"measured by the event loop's clock:"
msgstr ""
"``when`` deve ser um tempo absoluto no qual o contexto deve expirar, "
"conforme medido pelo relógio do loop de eventos:"

#: ../../library/asyncio-task.rst:764
msgid "If ``when`` is ``None``, the timeout will never trigger."
msgstr "Se ``when`` for ``None``, o timeout nunca será acionado."

#: ../../library/asyncio-task.rst:765
msgid ""
"If ``when < loop.time()``, the timeout will trigger on the next iteration of "
"the event loop."
msgstr ""
"Se ``when < loop.time()``, o timeout será acionado na próxima iteração do "
"loop de eventos."

#: ../../library/asyncio-task.rst:770
msgid ""
"Return the current deadline, or ``None`` if the current deadline is not set."
msgstr ""
"Devolve o prazo atual, ou ``None`` se o prazo atual não estiver definido."

#: ../../library/asyncio-task.rst:775
msgid "Reschedule the timeout."
msgstr "Reagendar o timeout."

#: ../../library/asyncio-task.rst:779
msgid "Return whether the context manager has exceeded its deadline (expired)."
msgstr "Devolve se o gestor de contexto excedeu o seu prazo (expirou)."

#: ../../library/asyncio-task.rst:784
msgid ""
"async def main():\n"
"    try:\n"
"        # We do not know the timeout when starting, so we pass ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # We know the timeout now, so we reschedule it.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Looks like we haven't finished on time.\")"
msgstr ""
"async def main():\n"
"    try:\n"
"        # Não sabemos o timeout ao iniciar, por isso passamos ``None``.\n"
"        async with asyncio.timeout(None) as cm:\n"
"            # Sabemos o timeout agora, por isso reagendamos.\n"
"            new_deadline = get_running_loop().time() + 10\n"
"            cm.reschedule(new_deadline)\n"
"\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        pass\n"
"\n"
"    if cm.expired():\n"
"        print(\"Parece que não terminámos a tempo.\")"

#: ../../library/asyncio-task.rst:799
msgid "Timeout context managers can be safely nested."
msgstr "Os gestores de contexto de timeout podem ser aninhados com segurança."

#: ../../library/asyncio-task.rst:805
msgid ""
"Similar to :func:`asyncio.timeout`, except *when* is the absolute time to "
"stop waiting, or ``None``."
msgstr ""
"Semelhante a :func:`asyncio.timeout`, exceto que *when* é o tempo absoluto "
"para parar de esperar, ou ``None``."

#: ../../library/asyncio-task.rst:810
msgid ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"The long operation timed out, but we've handled it.\")\n"
"\n"
"    print(\"This statement will run regardless.\")"
msgstr ""
"async def main():\n"
"    loop = get_running_loop()\n"
"    deadline = loop.time() + 20\n"
"    try:\n"
"        async with asyncio.timeout_at(deadline):\n"
"            await long_running_task()\n"
"    except TimeoutError:\n"
"        print(\"A operação longa expirou, mas nós tratámos disso.\")\n"
"\n"
"    print(\"Esta instrução será executada independentemente.\")"

#: ../../library/asyncio-task.rst:826
msgid ""
"Wait for the *aw* :ref:`awaitable <asyncio-awaitables>` to complete with a "
"timeout."
msgstr ""
"Aguardar que o *aw* :ref:`aguardável <asyncio-awaitables>` seja concluído "
"com um timeout."

#: ../../library/asyncio-task.rst:831
msgid ""
"*timeout* can either be ``None`` or a float or int number of seconds to wait "
"for.  If *timeout* is ``None``, block until the future completes."
msgstr ""
"*timeout* pode ser ``None`` ou um número float ou int de segundos para "
"esperar. Se *timeout* for ``None``, bloqueia até que o futuro seja concluído."

#: ../../library/asyncio-task.rst:835
msgid ""
"If a timeout occurs, it cancels the task and raises :exc:`TimeoutError`."
msgstr "Se ocorrer um timeout, cancela a tarefa e levanta :exc:`TimeoutError`."

#: ../../library/asyncio-task.rst:838
msgid ""
"To avoid the task :meth:`cancellation <Task.cancel>`, wrap it in :func:"
"`shield`."
msgstr ""
"Para evitar o :meth:`cancelamento <Task.cancel>` da tarefa, envolva-a em :"
"func:`shield`."

#: ../../library/asyncio-task.rst:841
msgid ""
"The function will wait until the future is actually cancelled, so the total "
"wait time may exceed the *timeout*. If an exception happens during "
"cancellation, it is propagated."
msgstr ""
"A função aguardará até que o futuro seja realmente cancelado, por isso o "
"tempo total de espera pode exceder o *timeout*. Se ocorrer uma exceção "
"durante o cancelamento, ela é propagada."

#: ../../library/asyncio-task.rst:845
msgid "If the wait is cancelled, the future *aw* is also cancelled."
msgstr "Se a espera for cancelada, o futuro *aw* também é cancelado."

#: ../../library/asyncio-task.rst:851
msgid ""
"async def eternity():\n"
"    # Sleep for one hour\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Wait for at most 1 second\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     timeout!"
msgstr ""
"async def eternity():\n"
"    # Dormir por uma hora\n"
"    await asyncio.sleep(3600)\n"
"    print('yay!')\n"
"\n"
"async def main():\n"
"    # Aguardar no máximo 1 segundo\n"
"    try:\n"
"        await asyncio.wait_for(eternity(), timeout=1.0)\n"
"    except TimeoutError:\n"
"        print('timeout!')\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Saída esperada:\n"
"#\n"
"#     timeout!"

#: ../../library/asyncio-task.rst:869
msgid ""
"When *aw* is cancelled due to a timeout, ``wait_for`` waits for *aw* to be "
"cancelled.  Previously, it raised :exc:`TimeoutError` immediately."
msgstr ""
"Quando *aw* é cancelado devido a um timeout, ``wait_for`` aguarda que *aw* "
"seja cancelado. Anteriormente, levantava :exc:`TimeoutError` imediatamente."

#: ../../library/asyncio-task.rst:877
msgid "Raises :exc:`TimeoutError` instead of :exc:`asyncio.TimeoutError`."
msgstr "Levanta :exc:`TimeoutError` em vez de :exc:`asyncio.TimeoutError`."

#: ../../library/asyncio-task.rst:882
msgid "Waiting Primitives"
msgstr "Primitivas de Espera"

#: ../../library/asyncio-task.rst:887
msgid ""
"Run :class:`~asyncio.Future` and :class:`~asyncio.Task` instances in the "
"*aws* iterable concurrently and block until the condition specified by "
"*return_when*."
msgstr ""
"Executa instâncias :class:`~asyncio.Future` e :class:`~asyncio.Task` no "
"iterável *aws* concorrentemente e bloqueia até que a condição especificada "
"por *return_when* seja atingida."

#: ../../library/asyncio-task.rst:891
msgid "The *aws* iterable must not be empty."
msgstr "O iterável *aws* não pode estar vazio."

#: ../../library/asyncio-task.rst:893
msgid "Returns two sets of Tasks/Futures: ``(done, pending)``."
msgstr "Devolve dois conjuntos de Tarefas/Futures: ``(done, pending)``."

#: ../../library/asyncio-task.rst:895
msgid "Usage::"
msgstr "Utilização::"

#: ../../library/asyncio-task.rst:897
msgid "done, pending = await asyncio.wait(aws)"
msgstr "done, pending = await asyncio.wait(aws)"

#: ../../library/asyncio-task.rst:899
msgid ""
"*timeout* (a float or int), if specified, can be used to control the maximum "
"number of seconds to wait before returning."
msgstr ""
"*timeout* (um float ou int), se especificado, pode ser usado para controlar "
"o número máximo de segundos a esperar antes de devolver."

#: ../../library/asyncio-task.rst:902
msgid ""
"Note that this function does not raise :exc:`TimeoutError`. Futures or Tasks "
"that aren't done when the timeout occurs are simply returned in the second "
"set."
msgstr ""
"Note que esta função não levanta :exc:`TimeoutError`. Futures ou Tarefas que "
"não estejam concluídas quando o timeout ocorre são simplesmente devolvidas "
"no segundo conjunto."

#: ../../library/asyncio-task.rst:906
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indica quando esta função deve devolver. Deve ser uma das "
"seguintes constantes:"

#: ../../library/asyncio-task.rst:912
msgid "Constant"
msgstr "Constante"

#: ../../library/asyncio-task.rst:913
msgid "Description"
msgstr "Descrição"

#: ../../library/asyncio-task.rst:916
msgid "The function will return when any future finishes or is cancelled."
msgstr "A função devolverá quando qualquer futuro terminar ou for cancelado."

#: ../../library/asyncio-task.rst:919
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"A função devolverá quando qualquer futuro terminar levantando uma exceção. "
"Se nenhum futuro levantar uma exceção, então é equivalente a :const:"
"`ALL_COMPLETED`."

#: ../../library/asyncio-task.rst:924
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"A função devolverá quando todos os futuros terminarem ou forem cancelados."

#: ../../library/asyncio-task.rst:926
msgid ""
"Unlike :func:`~asyncio.wait_for`, ``wait()`` does not cancel the futures "
"when a timeout occurs."
msgstr ""
"Ao contrário de :func:`~asyncio.wait_for`, ``wait()`` não cancela os futuros "
"quando ocorre um timeout."

#: ../../library/asyncio-task.rst:932
msgid "Passing coroutine objects to ``wait()`` directly is forbidden."
msgstr "Passar objetos corrotina diretamente para ``wait()`` é proibido."

#: ../../library/asyncio-task.rst:935 ../../library/asyncio-task.rst:993
msgid "Added support for generators yielding tasks."
msgstr "Adicionado suporte para geradores que produzem tarefas."

#: ../../library/asyncio-task.rst:941
msgid ""
"Run :ref:`awaitable objects <asyncio-awaitables>` in the *aws* iterable "
"concurrently. The returned object can be iterated to obtain the results of "
"the awaitables as they finish."
msgstr ""
"Executa :ref:`objetos aguardáveis <asyncio-awaitables>` no iterável *aws* "
"concorrentemente. O objeto devolvido pode ser iterado para obter os "
"resultados dos aguardáveis à medida que terminam."

#: ../../library/asyncio-task.rst:945
msgid ""
"The object returned by ``as_completed()`` can be iterated as an :term:"
"`asynchronous iterator` or a plain :term:`iterator`. When asynchronous "
"iteration is used, the originally-supplied awaitables are yielded if they "
"are tasks or futures. This makes it easy to correlate previously-scheduled "
"tasks with their results. Example::"
msgstr ""
"O objeto devolvido por ``as_completed()`` pode ser iterado como um :term:"
"`iterador assíncrono` ou um :term:`iterador` simples. Quando a iteração "
"assíncrona é usada, os aguardáveis originalmente fornecidos são produzidos "
"se forem tarefas ou futuros. Isto facilita a correlação de tarefas "
"previamente agendadas com os seus resultados. Exemplo:"

#: ../../library/asyncio-task.rst:951
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect is done. The result can be obtained by\n"
"    # awaiting it or calling earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"IPv6 connection established.\")\n"
"    else:\n"
"        print(\"IPv4 connection established.\")"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"async for earliest_connect in as_completed(tasks):\n"
"    # earliest_connect está concluído. O resultado pode ser obtido\n"
"    # aguardando-o ou chamando earliest_connect.result()\n"
"    reader, writer = await earliest_connect\n"
"\n"
"    if earliest_connect is ipv6_connect:\n"
"        print(\"Ligação IPv6 estabelecida.\")\n"
"    else:\n"
"        print(\"Ligação IPv4 estabelecida.\")"

#: ../../library/asyncio-task.rst:965
msgid ""
"During asynchronous iteration, implicitly-created tasks will be yielded for "
"supplied awaitables that aren't tasks or futures."
msgstr ""
"Durante a iteração assíncrona, tarefas implicitamente criadas serão "
"produzidas para aguardáveis fornecidos que não sejam tarefas ou futuros."

#: ../../library/asyncio-task.rst:968
msgid ""
"When used as a plain iterator, each iteration yields a new coroutine that "
"returns the result or raises the exception of the next completed awaitable. "
"This pattern is compatible with Python versions older than 3.13::"
msgstr ""
"Quando usado como um iterador simples, cada iteração produz uma nova "
"corrotina que devolve o resultado ou levanta a exceção do próximo aguardável "
"concluído. Este padrão é compatível com versões do Python anteriores à 3.13:"

#: ../../library/asyncio-task.rst:972
msgid ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect is not one of the original task objects. It must be\n"
"    # awaited to obtain the result value or raise the exception of the\n"
"    # awaitable that finishes next.\n"
"    reader, writer = await next_connect"
msgstr ""
"ipv4_connect = create_task(open_connection(\"127.0.0.1\", 80))\n"
"ipv6_connect = create_task(open_connection(\"::1\", 80))\n"
"tasks = [ipv4_connect, ipv6_connect]\n"
"\n"
"for next_connect in as_completed(tasks):\n"
"    # next_connect não é um dos objetos de tarefa originais. Deve ser\n"
"    # aguardado para obter o valor do resultado ou levantar a exceção do\n"
"    # aguardável que termina a seguir.\n"
"    reader, writer = await next_connect"

#: ../../library/asyncio-task.rst:982
msgid ""
"A :exc:`TimeoutError` is raised if the timeout occurs before all awaitables "
"are done. This is raised by the ``async for`` loop during asynchronous "
"iteration or by the coroutines yielded during plain iteration."
msgstr ""
"Um :exc:`TimeoutError` é levantado se o timeout ocorrer antes de todos os "
"aguardáveis estarem concluídos. Isto é levantado pelo loop ``async for`` "
"durante a iteração assíncrona ou pelas corrotinas produzidas durante a "
"iteração simples."

#: ../../library/asyncio-task.rst:989
msgid ""
"Deprecation warning is emitted if not all awaitable objects in the *aws* "
"iterable are Future-like objects and there is no running event loop."
msgstr ""
"É emitido um aviso de descontinuação se nem todos os objetos aguardáveis no "
"iterável *aws* forem objetos do tipo Future e não houver um loop de eventos "
"em execução."

#: ../../library/asyncio-task.rst:996
msgid ""
"The result can now be used as either an :term:`asynchronous iterator` or as "
"a plain :term:`iterator` (previously it was only a plain iterator)."
msgstr ""
"O resultado pode agora ser usado como um :term:`iterador assíncrono` ou como "
"um :term:`iterador` simples (anteriormente era apenas um iterador simples)."

#: ../../library/asyncio-task.rst:1002
msgid "Running in Threads"
msgstr "Execução em Threads"

#: ../../library/asyncio-task.rst:1007
msgid "Asynchronously run function *func* in a separate thread."
msgstr "Executa assincronamente a função *func* numa thread separada."

#: ../../library/asyncio-task.rst:1009
msgid ""
"Any \\*args and \\*\\*kwargs supplied for this function are directly passed "
"to *func*. Also, the current :class:`contextvars.Context` is propagated, "
"allowing context variables from the event loop thread to be accessed in the "
"separate thread."
msgstr ""
"Quaisquer \\*args e \\*\\*kwargs fornecidos para esta função são passados "
"diretamente para *func*. Além disso, o :class:`contextvars.Context` atual é "
"propagado, permitindo que as variáveis de contexto da thread do loop de "
"eventos sejam acedidas na thread separada."

#: ../../library/asyncio-task.rst:1014
msgid ""
"Return a coroutine that can be awaited to get the eventual result of *func*."
msgstr ""
"Devolve uma corrotina que pode ser aguardada para obter o resultado eventual "
"de *func*."

#: ../../library/asyncio-task.rst:1016
msgid ""
"This coroutine function is primarily intended to be used for executing IO-"
"bound functions/methods that would otherwise block the event loop if they "
"were run in the main thread. For example::"
msgstr ""
"Esta função corrotina é destinada principalmente a ser usada para executar "
"funções/métodos limitados por I/O que, de outra forma, bloqueariam o loop de "
"eventos se fossem executados na thread principal. Por exemplo:"

#: ../../library/asyncio-task.rst:1020
msgid ""
"def blocking_io():\n"
"    print(f\"start blocking_io at {time.strftime('%X')}\")\n"
"    # Note that time.sleep() can be replaced with any blocking\n"
"    # IO-bound operation, such as file operations.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io complete at {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"started main at {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"finished main at {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"# started main at 19:50:53\n"
"# start blocking_io at 19:50:53\n"
"# blocking_io complete at 19:50:54\n"
"# finished main at 19:50:54"
msgstr ""
"def blocking_io():\n"
"    print(f\"iniciar blocking_io às {time.strftime('%X')}\")\n"
"    # Note que time.sleep() pode ser substituído por qualquer operação\n"
"    # limitada por I/O, como operações de ficheiros.\n"
"    time.sleep(1)\n"
"    print(f\"blocking_io concluído às {time.strftime('%X')}\")\n"
"\n"
"async def main():\n"
"    print(f\"iniciado main às {time.strftime('%X')}\")\n"
"\n"
"    await asyncio.gather(\n"
"        asyncio.to_thread(blocking_io),\n"
"        asyncio.sleep(1))\n"
"\n"
"    print(f\"terminado main às {time.strftime('%X')}\")\n"
"\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Saída esperada:\n"
"#\n"
"# iniciado main às 19:50:53\n"
"# iniciar blocking_io às 19:50:53\n"
"# blocking_io concluído às 19:50:54\n"
"# terminado main às 19:50:54"

#: ../../library/asyncio-task.rst:1046
msgid ""
"Directly calling ``blocking_io()`` in any coroutine would block the event "
"loop for its duration, resulting in an additional 1 second of run time. "
"Instead, by using ``asyncio.to_thread()``, we can run it in a separate "
"thread without blocking the event loop."
msgstr ""
"Chamar diretamente ``blocking_io()`` em qualquer corrotina bloquearia o loop "
"de eventos durante a sua duração, resultando num segundo adicional de tempo "
"de execução. Em vez disso, usando ``asyncio.to_thread()``, podemos executá-"
"lo numa thread separada sem bloquear o loop de eventos."

#: ../../library/asyncio-task.rst:1053
msgid ""
"Due to the :term:`GIL`, ``asyncio.to_thread()`` can typically only be used "
"to make IO-bound functions non-blocking. However, for extension modules that "
"release the GIL or alternative Python implementations that don't have one, "
"``asyncio.to_thread()`` can also be used for CPU-bound functions."
msgstr ""
"Devido ao :term:`GIL`, ``asyncio.to_thread()`` pode tipicamente ser usado "
"apenas para tornar funções limitadas por I/O não bloqueantes. No entanto, "
"para módulos de extensão que libertam o GIL ou implementações alternativas "
"do Python que não o têm, ``asyncio.to_thread()`` também pode ser usado para "
"funções limitadas pela CPU."

#: ../../library/asyncio-task.rst:1062
msgid "Scheduling From Other Threads"
msgstr "Agendamento a partir de Outras Threads"

#: ../../library/asyncio-task.rst:1066
msgid "Submit a coroutine to the given event loop.  Thread-safe."
msgstr "Submeter uma corrotina ao loop de eventos dado. Thread-safe."

#: ../../library/asyncio-task.rst:1068
msgid ""
"Return a :class:`concurrent.futures.Future` to wait for the result from "
"another OS thread."
msgstr ""
"Devolve um :class:`concurrent.futures.Future` para aguardar o resultado de "
"outra thread do SO."

#: ../../library/asyncio-task.rst:1071
msgid ""
"This function is meant to be called from a different OS thread than the one "
"where the event loop is running.  Example::"
msgstr ""
"Esta função destina-se a ser chamada a partir de uma thread do SO diferente "
"daquela em que o loop de eventos está a ser executado. Exemplo:"

#: ../../library/asyncio-task.rst:1074
msgid ""
"# Create a coroutine\n"
"coro = asyncio.sleep(1, result=3)\n"
"\n"
"# Submit the coroutine to a given loop\n"
"future = asyncio.run_coroutine_threadsafe(coro, loop)\n"
"\n"
"# Wait for the result with an optional timeout argument\n"
"assert future.result(timeout) == 3"
msgstr ""

#: ../../library/asyncio-task.rst:1083
msgid ""
"If an exception is raised in the coroutine, the returned Future will be "
"notified.  It can also be used to cancel the task in the event loop::"
msgstr ""
"Se uma exceção for levantada na corrotina, o Future devolvido será "
"notificado. Também pode ser usado para cancelar a tarefa no loop de eventos:"

#: ../../library/asyncio-task.rst:1087
msgid ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('The coroutine took too long, cancelling the task...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'The coroutine raised an exception: {exc!r}')\n"
"else:\n"
"    print(f'The coroutine returned: {result!r}')"
msgstr ""
"try:\n"
"    result = future.result(timeout)\n"
"except TimeoutError:\n"
"    print('A corrotina demorou demasiado, a cancelar a tarefa...')\n"
"    future.cancel()\n"
"except Exception as exc:\n"
"    print(f'A corrotina levantou uma exceção: {exc!r}')\n"
"else:\n"
"    print(f'A corrotina devolveu: {result!r}')"

#: ../../library/asyncio-task.rst:1097
msgid ""
"See the :ref:`concurrency and multithreading <asyncio-multithreading>` "
"section of the documentation."
msgstr ""
"Consulte a secção :ref:`concorrência e multithreading <asyncio-"
"multithreading>` da documentação."

#: ../../library/asyncio-task.rst:1100
msgid ""
"Unlike other asyncio functions this function requires the *loop* argument to "
"be passed explicitly."
msgstr ""
"Ao contrário de outras funções do asyncio, esta função requer que o "
"argumento *loop* seja passado explicitamente."

#: ../../library/asyncio-task.rst:1107
msgid "Introspection"
msgstr "Introspeção"

#: ../../library/asyncio-task.rst:1112
msgid ""
"Return the currently running :class:`Task` instance, or ``None`` if no task "
"is running."
msgstr ""
"Devolve a instância :class:`Task` atualmente em execução, ou ``None`` se "
"nenhuma tarefa estiver em execução."

#: ../../library/asyncio-task.rst:1115
msgid ""
"If *loop* is ``None`` :func:`get_running_loop` is used to get the current "
"loop."
msgstr ""
"Se *loop* for ``None``, :func:`get_running_loop` é usado para obter o loop "
"atual."

#: ../../library/asyncio-task.rst:1123
msgid "Return a set of not yet finished :class:`Task` objects run by the loop."
msgstr ""
"Devolve um conjunto de objetos :class:`Task` ainda não concluídos executados "
"pelo loop."

#: ../../library/asyncio-task.rst:1126
msgid ""
"If *loop* is ``None``, :func:`get_running_loop` is used for getting current "
"loop."
msgstr ""
"Se *loop* for ``None``, :func:`get_running_loop` é usado para obter o loop "
"atual."

#: ../../library/asyncio-task.rst:1134
msgid "Return ``True`` if *obj* is a coroutine object."
msgstr "Devolve ``True`` se *obj* for um objeto corrotina."

#: ../../library/asyncio-task.rst:1141
msgid "Task Object"
msgstr "Objeto Tarefa"

#: ../../library/asyncio-task.rst:1145
msgid ""
"A :class:`Future-like <Future>` object that runs a Python :ref:`coroutine "
"<coroutine>`.  Not thread-safe."
msgstr ""
"Um objeto :class:`semelhante a Future <Future>` que executa uma :ref:"
"`corrotina <coroutine>` do Python. Não é thread-safe."

#: ../../library/asyncio-task.rst:1148
msgid ""
"Tasks are used to run coroutines in event loops. If a coroutine awaits on a "
"Future, the Task suspends the execution of the coroutine and waits for the "
"completion of the Future.  When the Future is *done*, the execution of the "
"wrapped coroutine resumes."
msgstr ""
"As Tarefas são usadas para executar corrotinas em loops de eventos. Se uma "
"corrotina aguardar um Future, a Tarefa suspende a execução da corrotina e "
"aguarda a conclusão do Future. Quando o Future estiver *concluído*, a "
"execução da corrotina envolvida retoma."

#: ../../library/asyncio-task.rst:1154
msgid ""
"Event loops use cooperative scheduling: an event loop runs one Task at a "
"time.  While a Task awaits for the completion of a Future, the event loop "
"runs other Tasks, callbacks, or performs IO operations."
msgstr ""
"Os loops de eventos usam agendamento cooperativo: um loop de eventos executa "
"uma Tarefa de cada vez. Enquanto uma Tarefa aguarda a conclusão de um "
"Future, o loop de eventos executa outras Tarefas, callbacks ou realiza "
"operações de I/O."

#: ../../library/asyncio-task.rst:1159
msgid ""
"Use the high-level :func:`asyncio.create_task` function to create Tasks, or "
"the low-level :meth:`loop.create_task` or :func:`ensure_future` functions.  "
"Manual instantiation of Tasks is discouraged."
msgstr ""
"Use a função de alto nível :func:`asyncio.create_task` para criar Tarefas, "
"ou as funções de baixo nível :meth:`loop.create_task` ou :func:"
"`ensure_future`. A instanciação manual de Tarefas é desencorajada."

#: ../../library/asyncio-task.rst:1164
msgid ""
"To cancel a running Task use the :meth:`cancel` method.  Calling it will "
"cause the Task to throw a :exc:`CancelledError` exception into the wrapped "
"coroutine.  If a coroutine is awaiting on a Future object during "
"cancellation, the Future object will be cancelled."
msgstr ""
"Para cancelar uma Tarefa em execução, use o método :meth:`cancel`. Chamá-lo "
"fará com que a Tarefa lance uma exceção :exc:`CancelledError` na corrotina "
"envolvida. Se uma corrotina estiver a aguardar um objeto Future durante o "
"cancelamento, o objeto Future será cancelado."

#: ../../library/asyncio-task.rst:1169
msgid ""
":meth:`cancelled` can be used to check if the Task was cancelled. The method "
"returns ``True`` if the wrapped coroutine did not suppress the :exc:"
"`CancelledError` exception and was actually cancelled."
msgstr ""
":meth:`cancelled` pode ser usado para verificar se a Tarefa foi cancelada. O "
"método devolve ``True`` se a corrotina envolvida não suprimiu a exceção :exc:"
"`CancelledError` e foi realmente cancelada."

#: ../../library/asyncio-task.rst:1174
msgid ""
":class:`asyncio.Task` inherits from :class:`Future` all of its APIs except :"
"meth:`Future.set_result` and :meth:`Future.set_exception`."
msgstr ""
":class:`asyncio.Task` herda de :class:`Future` todas as suas APIs, exceto :"
"meth:`Future.set_result` e :meth:`Future.set_exception`."

#: ../../library/asyncio-task.rst:1178
msgid ""
"An optional keyword-only *context* argument allows specifying a custom :"
"class:`contextvars.Context` for the *coro* to run in. If no *context* is "
"provided, the Task copies the current context and later runs its coroutine "
"in the copied context."
msgstr ""
"Um argumento opcional apenas por palavra-chave *context* permite especificar "
"um :class:`contextvars.Context` personalizado para a *coro* ser executada. "
"Se nenhum *context* for fornecido, a Tarefa copia o contexto atual e mais "
"tarde executa a sua corrotina no contexto copiado."

#: ../../library/asyncio-task.rst:1183
msgid ""
"An optional keyword-only *eager_start* argument allows eagerly starting the "
"execution of the :class:`asyncio.Task` at task creation time. If set to "
"``True`` and the event loop is running, the task will start executing the "
"coroutine immediately, until the first time the coroutine blocks. If the "
"coroutine returns or raises without blocking, the task will be finished "
"eagerly and will skip scheduling to the event loop."
msgstr ""
"Um argumento opcional apenas por palavra-chave *eager_start* permite iniciar "
"imediatamente a execução da :class:`asyncio.Task` no momento da criação da "
"tarefa. Se definido como ``True`` e o loop de eventos estiver em execução, a "
"tarefa começará a executar a corrotina imediatamente, até à primeira vez que "
"a corrotina bloquear. Se a corrotina devolver ou levantar uma exceção sem "
"bloquear, a tarefa será concluída imediatamente e não será agendada para o "
"loop de eventos."

#: ../../library/asyncio-task.rst:1190
msgid "Added support for the :mod:`contextvars` module."
msgstr "Adicionado suporte para o módulo :mod:`contextvars`."

#: ../../library/asyncio-task.rst:1196
msgid ""
"Deprecation warning is emitted if *loop* is not specified and there is no "
"running event loop."
msgstr ""
"É emitido um aviso de descontinuação se *loop* não for especificado e não "
"houver um loop de eventos em execução."

#: ../../library/asyncio-task.rst:1203
msgid "Added the *eager_start* parameter."
msgstr "Adicionado o parâmetro *eager_start*."

#: ../../library/asyncio-task.rst:1208
msgid "Return ``True`` if the Task is *done*."
msgstr "Devolve ``True`` se a Tarefa estiver *concluída*."

#: ../../library/asyncio-task.rst:1210
msgid ""
"A Task is *done* when the wrapped coroutine either returned a value, raised "
"an exception, or the Task was cancelled."
msgstr ""
"Uma Tarefa está *concluída* quando a corrotina envolvida devolveu um valor, "
"levantou uma exceção, ou a Tarefa foi cancelada."

#: ../../library/asyncio-task.rst:1215
msgid "Return the result of the Task."
msgstr "Devolve o resultado da Tarefa."

#: ../../library/asyncio-task.rst:1217
msgid ""
"If the Task is *done*, the result of the wrapped coroutine is returned (or "
"if the coroutine raised an exception, that exception is re-raised.)"
msgstr ""
"Se a Tarefa estiver *concluída*, o resultado da corrotina envolvida é "
"devolvido (ou se a corrotina levantou uma exceção, essa exceção é levantada "
"novamente)."

#: ../../library/asyncio-task.rst:1221 ../../library/asyncio-task.rst:1235
msgid ""
"If the Task has been *cancelled*, this method raises a :exc:`CancelledError` "
"exception."
msgstr ""
"Se a Tarefa tiver sido *cancelada*, este método levanta uma exceção :exc:"
"`CancelledError`."

#: ../../library/asyncio-task.rst:1224
msgid ""
"If the Task's result isn't yet available, this method raises an :exc:"
"`InvalidStateError` exception."
msgstr ""
"Se o resultado da Tarefa ainda não estiver disponível, este método levanta "
"uma exceção :exc:`InvalidStateError`."

#: ../../library/asyncio-task.rst:1229
msgid "Return the exception of the Task."
msgstr "Devolve a exceção da Tarefa."

#: ../../library/asyncio-task.rst:1231
msgid ""
"If the wrapped coroutine raised an exception that exception is returned.  If "
"the wrapped coroutine returned normally this method returns ``None``."
msgstr ""
"Se a corrotina envolvida levantou uma exceção, essa exceção é devolvida. Se "
"a corrotina envolvida devolveu normalmente, este método devolve ``None``."

#: ../../library/asyncio-task.rst:1238
msgid ""
"If the Task isn't *done* yet, this method raises an :exc:`InvalidStateError` "
"exception."
msgstr ""
"Se a Tarefa ainda não estiver *concluída*, este método levanta uma exceção :"
"exc:`InvalidStateError`."

#: ../../library/asyncio-task.rst:1243
msgid "Add a callback to be run when the Task is *done*."
msgstr ""
"Adiciona um callback para ser executado quando a Tarefa estiver *concluída*."

#: ../../library/asyncio-task.rst:1245 ../../library/asyncio-task.rst:1254
msgid "This method should only be used in low-level callback-based code."
msgstr ""
"Este método deve ser usado apenas em código de baixo nível baseado em "
"callbacks."

#: ../../library/asyncio-task.rst:1247
msgid ""
"See the documentation of :meth:`Future.add_done_callback` for more details."
msgstr ""
"Consulte a documentação de :meth:`Future.add_done_callback` para mais "
"detalhes."

#: ../../library/asyncio-task.rst:1252
msgid "Remove *callback* from the callbacks list."
msgstr "Remove *callback* da lista de callbacks."

#: ../../library/asyncio-task.rst:1256
msgid ""
"See the documentation of :meth:`Future.remove_done_callback` for more "
"details."
msgstr ""
"Consulte a documentação de :meth:`Future.remove_done_callback` para mais "
"detalhes."

#: ../../library/asyncio-task.rst:1261
msgid "Return the list of stack frames for this Task."
msgstr "Devolve a lista de frames de pilha para esta Tarefa."

#: ../../library/asyncio-task.rst:1263
msgid ""
"If the wrapped coroutine is not done, this returns the stack where it is "
"suspended.  If the coroutine has completed successfully or was cancelled, "
"this returns an empty list. If the coroutine was terminated by an exception, "
"this returns the list of traceback frames."
msgstr ""
"Se a corrotina envolvida não estiver concluída, isto devolve a pilha onde "
"está suspensa. Se a corrotina tiver sido concluída com sucesso ou foi "
"cancelada, isto devolve uma lista vazia. Se a corrotina foi terminada por "
"uma exceção, isto devolve a lista de frames de traceback."

#: ../../library/asyncio-task.rst:1269
msgid "The frames are always ordered from oldest to newest."
msgstr "Os frames são sempre ordenados do mais antigo para o mais recente."

#: ../../library/asyncio-task.rst:1271
msgid "Only one stack frame is returned for a suspended coroutine."
msgstr "Apenas um frame de pilha é devolvido para uma corrotina suspensa."

#: ../../library/asyncio-task.rst:1273
msgid ""
"The optional *limit* argument sets the maximum number of frames to return; "
"by default all available frames are returned. The ordering of the returned "
"list differs depending on whether a stack or a traceback is returned: the "
"newest frames of a stack are returned, but the oldest frames of a traceback "
"are returned.  (This matches the behavior of the traceback module.)"
msgstr ""
"O argumento opcional *limit* define o número máximo de frames a devolver; "
"por predefinição, todos os frames disponíveis são devolvidos. A ordenação da "
"lista devolvida difere dependendo se uma pilha ou um traceback é devolvido: "
"os frames mais recentes de uma pilha são devolvidos, mas os frames mais "
"antigos de um traceback são devolvidos. (Isto corresponde ao comportamento "
"do módulo traceback)."

#: ../../library/asyncio-task.rst:1282
msgid "Print the stack or traceback for this Task."
msgstr "Imprime a pilha ou traceback para esta Tarefa."

#: ../../library/asyncio-task.rst:1284
msgid ""
"This produces output similar to that of the traceback module for the frames "
"retrieved by :meth:`get_stack`."
msgstr ""
"Isto produz saída semelhante à do módulo traceback para os frames obtidos "
"por :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1287
msgid "The *limit* argument is passed to :meth:`get_stack` directly."
msgstr "O argumento *limit* é passado diretamente para :meth:`get_stack`."

#: ../../library/asyncio-task.rst:1289
msgid ""
"The *file* argument is an I/O stream to which the output is written; by "
"default output is written to :data:`sys.stdout`."
msgstr ""
"O argumento *file* é um fluxo de I/O para o qual a saída é escrita; por "
"predefinição, a saída é escrita para :data:`sys.stdout`."

#: ../../library/asyncio-task.rst:1294
msgid "Return the coroutine object wrapped by the :class:`Task`."
msgstr "Devolve o objeto corrotina envolvido pela :class:`Task`."

#: ../../library/asyncio-task.rst:1298
msgid ""
"This will return ``None`` for Tasks which have already completed eagerly. "
"See the :ref:`Eager Task Factory <eager-task-factory>`."
msgstr ""
"Isto devolverá ``None`` para Tarefas que já tenham sido concluídas "
"imediatamente. Consulte :ref:`Fábrica de Tarefas Eager <eager-task-factory>`."

#: ../../library/asyncio-task.rst:1305
msgid "Newly added eager task execution means result may be ``None``."
msgstr ""
"A execução de tarefas eager recentemente adicionada significa que o "
"resultado pode ser ``None``."

#: ../../library/asyncio-task.rst:1309
msgid ""
"Return the :class:`contextvars.Context` object associated with the task."
msgstr "Devolve o objeto :class:`contextvars.Context` associado à tarefa."

#: ../../library/asyncio-task.rst:1316
msgid "Return the name of the Task."
msgstr "Devolve o nome da Tarefa."

#: ../../library/asyncio-task.rst:1318
msgid ""
"If no name has been explicitly assigned to the Task, the default asyncio "
"Task implementation generates a default name during instantiation."
msgstr ""
"Se nenhum nome tiver sido atribuído explicitamente à Tarefa, a implementação "
"predefinida da Tarefa asyncio gera um nome predefinido durante a "
"instanciação."

#: ../../library/asyncio-task.rst:1326
msgid "Set the name of the Task."
msgstr "Define o nome da Tarefa."

#: ../../library/asyncio-task.rst:1328
msgid ""
"The *value* argument can be any object, which is then converted to a string."
msgstr ""
"O argumento *value* pode ser qualquer objeto, que é então convertido para "
"uma string."

#: ../../library/asyncio-task.rst:1331
msgid ""
"In the default Task implementation, the name will be visible in the :func:"
"`repr` output of a task object."
msgstr ""
"Na implementação predefinida da Tarefa, o nome será visível na saída :func:"
"`repr` de um objeto tarefa."

#: ../../library/asyncio-task.rst:1338
msgid "Request the Task to be cancelled."
msgstr "Solicita o cancelamento da Tarefa."

#: ../../library/asyncio-task.rst:1340
msgid ""
"If the Task is already *done* or *cancelled*, return ``False``, otherwise, "
"return ``True``."
msgstr ""
"Se a Tarefa já estiver *concluída* ou *cancelada*, devolve ``False``; caso "
"contrário, devolve ``True``."

#: ../../library/asyncio-task.rst:1343
msgid ""
"The method arranges for a :exc:`CancelledError` exception to be thrown into "
"the wrapped coroutine on the next cycle of the event loop."
msgstr ""
"O método organiza para que uma exceção :exc:`CancelledError` seja lançada na "
"corrotina envolvida no próximo ciclo do loop de eventos."

#: ../../library/asyncio-task.rst:1346
msgid ""
"The coroutine then has a chance to clean up or even deny the request by "
"suppressing the exception with a :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally` block. Therefore, unlike :meth:"
"`Future.cancel`, :meth:`Task.cancel` does not guarantee that the Task will "
"be cancelled, although suppressing cancellation completely is not common and "
"is actively discouraged.  Should the coroutine nevertheless decide to "
"suppress the cancellation, it needs to call :meth:`Task.uncancel` in "
"addition to catching the exception."
msgstr ""
"A corrotina tem então a oportunidade de limpar ou até negar o pedido "
"suprimindo a exceção com um bloco :keyword:`try` ... ... ``except "
"CancelledError`` ... :keyword:`finally`. Portanto, ao contrário de :meth:"
"`Future.cancel`, :meth:`Task.cancel` não garante que a Tarefa será "
"cancelada, embora suprimir completamente o cancelamento não seja comum e "
"seja ativamente desencorajado. Se a corrotina decidir, apesar de tudo, "
"suprimir o cancelamento, precisa de chamar :meth:`Task.uncancel` além de "
"capturar a exceção."

#: ../../library/asyncio-task.rst:1356
msgid "Added the *msg* parameter."
msgstr "Adicionado o parâmetro *msg*."

#: ../../library/asyncio-task.rst:1359
msgid "The ``msg`` parameter is propagated from cancelled task to its awaiter."
msgstr ""
"O parâmetro ``msg`` é propagado da tarefa cancelada para o seu aguardador."

#: ../../library/asyncio-task.rst:1364
msgid ""
"The following example illustrates how coroutines can intercept the "
"cancellation request::"
msgstr ""
"O exemplo seguinte ilustra como as corrotinas podem interceptar o pedido de "
"cancelamento:"

#: ../../library/asyncio-task.rst:1367
msgid ""
"async def cancel_me():\n"
"    print('cancel_me(): before sleep')\n"
"\n"
"    try:\n"
"        # Wait for 1 hour\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancel sleep')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): after sleep')\n"
"\n"
"async def main():\n"
"    # Create a \"cancel_me\" Task\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Wait for 1 second\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me is cancelled now\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Expected output:\n"
"#\n"
"#     cancel_me(): before sleep\n"
"#     cancel_me(): cancel sleep\n"
"#     cancel_me(): after sleep\n"
"#     main(): cancel_me is cancelled now"
msgstr ""
"async def cancel_me():\n"
"    print('cancel_me(): antes de dormir')\n"
"\n"
"    try:\n"
"        # Aguardar 1 hora\n"
"        await asyncio.sleep(3600)\n"
"    except asyncio.CancelledError:\n"
"        print('cancel_me(): cancelar sono')\n"
"        raise\n"
"    finally:\n"
"        print('cancel_me(): depois de dormir')\n"
"\n"
"async def main():\n"
"    # Criar uma Tarefa \"cancel_me\"\n"
"    task = asyncio.create_task(cancel_me())\n"
"\n"
"    # Aguardar 1 segundo\n"
"    await asyncio.sleep(1)\n"
"\n"
"    task.cancel()\n"
"    try:\n"
"        await task\n"
"    except asyncio.CancelledError:\n"
"        print(\"main(): cancel_me foi cancelado agora\")\n"
"\n"
"asyncio.run(main())\n"
"\n"
"# Saída esperada:\n"
"#\n"
"#     cancel_me(): antes de dormir\n"
"#     cancel_me(): cancelar sono\n"
"#     cancel_me(): depois de dormir\n"
"#     main(): cancel_me foi cancelado agora"

#: ../../library/asyncio-task.rst:1403
msgid "Return ``True`` if the Task is *cancelled*."
msgstr "Devolve ``True`` se a Tarefa estiver *cancelada*."

#: ../../library/asyncio-task.rst:1405
msgid ""
"The Task is *cancelled* when the cancellation was requested with :meth:"
"`cancel` and the wrapped coroutine propagated the :exc:`CancelledError` "
"exception thrown into it."
msgstr ""
"A Tarefa está *cancelada* quando o cancelamento foi solicitado com :meth:"
"`cancel` e a corrotina envolvida propagou a exceção :exc:`CancelledError` "
"lançada nela."

#: ../../library/asyncio-task.rst:1411
msgid "Decrement the count of cancellation requests to this Task."
msgstr "Decrementa a contagem de pedidos de cancelamento para esta Tarefa."

#: ../../library/asyncio-task.rst:1413
msgid "Returns the remaining number of cancellation requests."
msgstr "Devolve o número restante de pedidos de cancelamento."

#: ../../library/asyncio-task.rst:1415
msgid ""
"Note that once execution of a cancelled task completed, further calls to :"
"meth:`uncancel` are ineffective."
msgstr ""
"Note que, uma vez concluída a execução de uma tarefa cancelada, chamadas "
"adicionais para :meth:`uncancel` são ineficazes."

#: ../../library/asyncio-task.rst:1420
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  In particular, if a Task gets successfully uncancelled, this "
"allows for elements of structured concurrency like :ref:`taskgroups` and :"
"func:`asyncio.timeout` to continue running, isolating cancellation to the "
"respective structured block. For example::"
msgstr ""
"Este método é usado pelos internos do asyncio e não é esperado que seja "
"usado por código do utilizador final. Em particular, se uma Tarefa for "
"cancelada com sucesso, isto permite que elementos de concorrência "
"estruturada como :ref:`taskgroups` e :func:`asyncio.timeout` continuem a "
"executar, isolando o cancelamento para o respetivo bloco estruturado. Por "
"exemplo:"

#: ../../library/asyncio-task.rst:1427
msgid ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Structured block affected by the timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"There was a timeout\")\n"
"    # Outer code not affected by the timeout:\n"
"    await unrelated_code()"
msgstr ""
"async def make_request_with_timeout():\n"
"    try:\n"
"        async with asyncio.timeout(1):\n"
"            # Bloco estruturado afetado pelo timeout:\n"
"            await make_request()\n"
"            await make_another_request()\n"
"    except TimeoutError:\n"
"        log(\"Ocorreu um timeout\")\n"
"    # Código externo não afetado pelo timeout:\n"
"    await unrelated_code()"

#: ../../library/asyncio-task.rst:1438
msgid ""
"While the block with ``make_request()`` and ``make_another_request()`` might "
"get cancelled due to the timeout, ``unrelated_code()`` should continue "
"running even in case of the timeout.  This is implemented with :meth:"
"`uncancel`.  :class:`TaskGroup` context managers use :func:`uncancel` in a "
"similar fashion."
msgstr ""
"Embora o bloco com ``make_request()`` e ``make_another_request()`` possa ser "
"cancelado devido ao timeout, ``unrelated_code()`` deve continuar a executar "
"mesmo em caso de timeout. Isto é implementado com :meth:`uncancel`. Os "
"gestores de contexto :class:`TaskGroup` usam :func:`uncancel` de forma "
"semelhante."

#: ../../library/asyncio-task.rst:1444
msgid ""
"If end-user code is, for some reason, suppressing cancellation by catching :"
"exc:`CancelledError`, it needs to call this method to remove the "
"cancellation state."
msgstr ""
"Se o código do utilizador final, por alguma razão, estiver a suprimir o "
"cancelamento capturando :exc:`CancelledError`, precisa de chamar este método "
"para remover o estado de cancelamento."

#: ../../library/asyncio-task.rst:1448
msgid ""
"When this method decrements the cancellation count to zero, the method "
"checks if a previous :meth:`cancel` call had arranged for :exc:"
"`CancelledError` to be thrown into the task. If it hasn't been thrown yet, "
"that arrangement will be rescinded (by resetting the internal "
"``_must_cancel`` flag)."
msgstr ""
"Quando este método decrementa a contagem de cancelamentos para zero, o "
"método verifica se uma chamada anterior a :meth:`cancel` tinha organizado "
"para que :exc:`CancelledError` fosse lançado na tarefa. Se ainda não tiver "
"sido lançado, esse arranjo será revogado (redefinindo a flag interna "
"``_must_cancel``)."

#: ../../library/asyncio-task.rst:1454
msgid "Changed to rescind pending cancellation requests upon reaching zero."
msgstr ""
"Alterado para revogar pedidos de cancelamento pendentes ao atingir zero."

#: ../../library/asyncio-task.rst:1459
msgid ""
"Return the number of pending cancellation requests to this Task, i.e., the "
"number of calls to :meth:`cancel` less the number of :meth:`uncancel` calls."
msgstr ""
"Devolve o número de pedidos de cancelamento pendentes para esta Tarefa, ou "
"seja, o número de chamadas para :meth:`cancel` menos o número de chamadas "
"para :meth:`uncancel`."

#: ../../library/asyncio-task.rst:1463
msgid ""
"Note that if this number is greater than zero but the Task is still "
"executing, :meth:`cancelled` will still return ``False``. This is because "
"this number can be lowered by calling :meth:`uncancel`, which can lead to "
"the task not being cancelled after all if the cancellation requests go down "
"to zero."
msgstr ""
"Note que, se este número for maior que zero, mas a Tarefa ainda estiver a "
"ser executada, :meth:`cancelled` ainda devolverá ``False``. Isto porque este "
"número pode ser reduzido chamando :meth:`uncancel`, o que pode levar a que a "
"tarefa não seja cancelada, afinal, se os pedidos de cancelamento descerem a "
"zero."

#: ../../library/asyncio-task.rst:1469
msgid ""
"This method is used by asyncio's internals and isn't expected to be used by "
"end-user code.  See :meth:`uncancel` for more details."
msgstr ""
"Este método é usado pelos internos do asyncio e não é esperado que seja "
"usado por código do utilizador final. Consulte :meth:`uncancel` para mais "
"detalhes."
