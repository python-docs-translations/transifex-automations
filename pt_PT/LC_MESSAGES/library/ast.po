# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-01 17:26+0000\n"
"PO-Revision-Date: 2025-09-22 15:57+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ""

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Código-fonte:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"O módulo :mod:`ast` ajuda as aplicações Python a processar árvores da "
"gramática de sintaxe abstrata do Python. A própria sintaxe abstrata pode "
"mudar com cada lançamento do Python; este módulo ajuda a descobrir "
"programaticamente como é a gramática atual."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Uma árvore de sintaxe abstrata pode ser gerada passando :data:`ast."
"PyCF_ONLY_AST` como uma *flag* para a função integrada :func:`compile`, ou "
"usando o auxiliar :func:`parse` fornecido neste módulo. O resultado será uma "
"árvore de objetos cujas classes herdam todas de :class:`ast.AST`. Uma árvore "
"de sintaxe abstrata pode ser compilada num objeto de código Python usando a "
"função integrada :func:`compile`."

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr ""

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "A gramática abstrata está atualmente definida como se segue:"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Classes de nós"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`above <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Existe uma classe definida para cada símbolo do lado esquerdo na gramática "
"abstrata (por exemplo, :class:`ast.stmt` ou :class:`ast.expr`). Além disso, "
"existe uma classe definida para cada construtor do lado direito; estas "
"classes herdam das classes para as árvores do lado esquerdo. Por exemplo, :"
"class:`ast.BinOp` herda de :class:`ast.expr`. Para regras de produção com "
"alternativas (também conhecidas como \"somas\"), a classe do lado esquerdo é "
"abstrata: apenas instâncias de nós construtores específicos são criadas."

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Cada instância de uma classe concreta tem um atributo para cada nó filho, do "
"tipo definido na gramática. Por exemplo, instâncias de :class:`ast.BinOp` "
"têm um atributo :attr:`left` do tipo :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Se estes atributos forem marcados como opcionais na gramática (usando um "
"ponto de interrogação), o valor pode ser ``None``. Se os atributos puderem "
"ter zero ou mais valores (marcados com um asterisco), os valores são "
"representados como listas Python. Todos os atributos possíveis devem estar "
"presentes e ter valores válidos ao compilar uma AST com :func:`compile`."

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of source text span (1-indexed so the first line is line "
"1) and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""
"Instâncias de subclasses de :class:`ast.expr` e :class:`ast.stmt` têm os "
"atributos :attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno` e :attr:"
"`end_col_offset`. Os atributos :attr:`lineno` e :attr:`end_lineno` são os "
"números da primeira e última linha do intervalo de texto-fonte (indexado a "
"1, portanto a primeira linha é a linha 1) e os atributos :attr:`col_offset` "
"e :attr:`end_col_offset` são os deslocamentos de byte UTF-8 correspondentes "
"do primeiro e último *tokens* que geraram o nó. O deslocamento UTF-8 é "
"registado porque o analisador usa UTF-8 internamente."

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Note que as posições finais não são obrigatórias pelo compilador e são, "
"portanto, opcionais. O deslocamento final é *depois* do último símbolo, por "
"exemplo, pode-se obter o segmento de origem de um nó de expressão de uma "
"linha usando ``source_line[node.col_offset : node.end_col_offset]``."

#: ../../library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"O construtor de uma classe :class:`ast.T` analisa os seus argumentos da "
"seguinte forma:"

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Se houver argumentos posicionais, deve haver tantos quanto os itens em :attr:"
"`T._fields`; eles serão atribuídos como atributos com esses nomes."

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Se houver argumentos de palavra-chave, eles definirão os atributos com os "
"mesmos nomes para os valores dados."

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Por exemplo, para criar e preencher um nó :class:`ast.UnaryOp`, pode usar: ::"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr ""

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "A classe :class:`ast.Constant` é agora usada para todas as constantes."

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Índices simples são representados pelo seu valor, fatias estendidas são "
"representadas como tuplos."

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meantime, instantiating "
"them will return an instance of a different class."
msgstr ""

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"As descrições das classes específicas de nós apresentadas aqui foram "
"inicialmente adaptadas do fantástico projeto `Green Tree Snakes <https://"
"greentreesnakes.readthedocs.io/en/latest/>`__ e de todos os seus "
"colaboradores."

#: ../../library/ast.rst:150
msgid "Literals"
msgstr "Literais"

#: ../../library/ast.rst:154
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""

#: ../../library/ast.rst:168
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Nó que representa um único campo de formatação numa f-*string*. Se a "
"*string* contiver um único campo de formatação e nada mais, o nó pode ser "
"isolado; caso contrário, aparece em :class:`JoinedStr`."

#: ../../library/ast.rst:172
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``value`` é qualquer nó de expressão (como um literal, uma variável ou uma "
"chamada de função)."

#: ../../library/ast.rst:174
msgid "``conversion`` is an integer:"
msgstr "``conversion`` é um inteiro:"

#: ../../library/ast.rst:176
msgid "-1: no formatting"
msgstr "-1: sem formatação"

#: ../../library/ast.rst:177
msgid "115: ``!s`` string formatting"
msgstr ""

#: ../../library/ast.rst:178
msgid "114: ``!r`` repr formatting"
msgstr ""

#: ../../library/ast.rst:179
msgid "97: ``!a`` ascii formatting"
msgstr ""

#: ../../library/ast.rst:181
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` é um nó :class:`JoinedStr` que representa a formatação do "
"valor, ou ``None`` se nenhuma formatação foi especificada. Tanto "
"``conversion`` como ``format_spec`` podem ser definidos ao mesmo tempo."

#: ../../library/ast.rst:188
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"Uma f-*string*, composta por uma série de nós :class:`FormattedValue` e :"
"class:`Constant`."

#: ../../library/ast.rst:217
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"Uma lista ou tuplo. ``elts`` contém uma lista de nós que representam os "
"elementos. ``ctx`` é :class:`Store` se o contentor for um alvo de atribuição "
"(por exemplo, ``(x,y)=something``), e :class:`Load` caso contrário."

#: ../../library/ast.rst:243
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"Um conjunto. ``elts`` contém uma lista de nós que representam os elementos "
"do conjunto."

#: ../../library/ast.rst:258
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"Um dicionário. ``keys`` e ``values`` contêm listas de nós que representam as "
"chaves e os valores, respetivamente, por ordem correspondente (o que seria "
"devolvido ao chamar :code:`dictionary.keys()` e :code:`dictionary.values()`)."

#: ../../library/ast.rst:262
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Ao fazer a descompactação de dicionários usando literais de dicionário, a "
"expressão a ser expandida vai para a lista ``values``, com um ``None`` na "
"posição correspondente em ``keys``."

#: ../../library/ast.rst:280
msgid "Variables"
msgstr "Variáveis"

#: ../../library/ast.rst:284
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Um nome de variável. ``id`` contém o nome como uma *string*, e ``ctx`` é um "
"dos seguintes tipos."

#: ../../library/ast.rst:292
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"As referências a variáveis podem ser usadas para carregar o valor de uma "
"variável, para atribuir um novo valor a ela, ou para a apagar. As "
"referências a variáveis recebem um contexto para distinguir estes casos."

#: ../../library/ast.rst:325
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"Uma referência a uma variável ``*var``. ``value`` contém a variável, "
"tipicamente um nó :class:`Name`. Este tipo deve ser usado ao construir um "
"nó :class:`Call` com ``*args``."

#: ../../library/ast.rst:348
msgid "Expressions"
msgstr "Expressões"

#: ../../library/ast.rst:352
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"Quando uma expressão, como uma chamada de função, aparece como uma "
"declaração por si só, com o seu valor de retorno não usado ou armazenado, é "
"envolvida neste contentor. ``value`` contém um dos outros nós nesta secção, "
"um :class:`Constant`, um :class:`Name`, um :class:`Lambda`, um :class:"
"`Yield` ou um nó :class:`YieldFrom`."

#: ../../library/ast.rst:371
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"Uma operação unária. ``op`` é o operador, e ``operand`` é qualquer nó de "
"expressão."

#: ../../library/ast.rst:380
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Tokens de operadores unários. :class:`Not` é a palavra-chave ``not``, :class:"
"`Invert` é o operador ``~``."

#: ../../library/ast.rst:394
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"Uma operação binária (como adição ou divisão). ``op`` é o operador, e "
"``left`` e ``right`` são quaisquer nós de expressão."

#: ../../library/ast.rst:421
msgid "Binary operator tokens."
msgstr "Tokens de operadores binários."

#: ../../library/ast.rst:426
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"Uma operação booleana, 'or' ou 'and'. ``op`` é :class:`Or` ou :class:`And`. "
"``values`` são os valores envolvidos. Operações consecutivas com o mesmo "
"operador, como ``a or b or c``, são colapsadas num único nó com vários "
"valores."

#: ../../library/ast.rst:431
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Isto não inclui ``not``, que é um :class:`UnaryOp`."

#: ../../library/ast.rst:447
msgid "Boolean operator tokens."
msgstr "Tokens de operadores booleanos."

#: ../../library/ast.rst:452
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"Uma comparação de dois ou mais valores. ``left`` é o primeiro valor na "
"comparação, ``ops`` é a lista de operadores, e ``comparators`` é a lista de "
"valores após o primeiro elemento na comparação."

#: ../../library/ast.rst:481
msgid "Comparison operator tokens."
msgstr "Tokens de operadores de comparação."

#: ../../library/ast.rst:486
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Uma chamada de função. ``func`` é a função, que será frequentemente um "
"objeto :class:`Name` ou :class:`Attribute`. Dos argumentos:"

#: ../../library/ast.rst:489
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` contém uma lista dos argumentos passados por posição."

#: ../../library/ast.rst:490
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing arguments "
"passed by keyword."
msgstr ""

#: ../../library/ast.rst:493
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""

#: ../../library/ast.rst:517
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Um argumento de palavra-chave para uma chamada de função ou definição de "
"classe. ``arg`` é uma *string* bruta do nome do parâmetro, ``value`` é um nó "
"a passar."

#: ../../library/ast.rst:523
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Uma expressão como ``a if b else c``. Cada campo contém um nó único, por "
"isso, no exemplo seguinte, todos os três são nós :class:`Name`."

#: ../../library/ast.rst:538
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Acesso a atributo, por exemplo, ``d.keys``. ``value`` é um nó, tipicamente "
"um :class:`Name`. ``attr`` é uma *string* simples que dá o nome do atributo, "
"e ``ctx`` é :class:`Load`, :class:`Store` ou :class:`Del` conforme a forma "
"como o atributo é acionado."

#: ../../library/ast.rst:555
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Uma expressão nomeada. Este nó AST é produzido pelo operador de expressões "
"de atribuição (também conhecido como operador walrus). Ao contrário do nó :"
"class:`Assign`, em que o primeiro argumento pode ser vários nós, neste caso, "
"tanto ``target`` como ``value`` devem ser nós únicos."

#: ../../library/ast.rst:570
msgid "Subscripting"
msgstr "Indexação"

#: ../../library/ast.rst:574
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Uma indexação, como ``l[1]``. ``value`` é o objeto indexado (geralmente uma "
"sequência ou mapeamento). ``slice`` é um índice, fatia ou chave. Pode ser "
"um :class:`Tuple` e conter um :class:`Slice`. ``ctx`` é :class:`Load`, :"
"class:`Store` ou :class:`Del` conforme a ação realizada com a indexação."

#: ../../library/ast.rst:598
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Fatia regular (na forma ``lower:upper`` ou ``lower:upper:step``). Pode "
"ocorrer apenas dentro do campo *slice* de :class:`Subscript`, diretamente ou "
"como um elemento de :class:`Tuple`."

#: ../../library/ast.rst:615
msgid "Comprehensions"
msgstr "Compreensões"

#: ../../library/ast.rst:622
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"Compreensões de listas e conjuntos, expressões geradoras e compreensões de "
"dicionários. ``elt`` (ou ``key`` e ``value``) é um nó único que representa a "
"parte que será avaliada para cada item."

#: ../../library/ast.rst:626
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` é uma lista de nós :class:`comprehension`."

#: ../../library/ast.rst:668
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"Uma cláusula ``for`` numa compreensão. ``target`` é a referência a usar para "
"cada elemento - tipicamente um nó :class:`Name` ou :class:`Tuple`. ``iter`` "
"é o objeto sobre o qual iterar. ``ifs`` é uma lista de expressões de teste: "
"cada cláusula ``for`` pode ter vários ``ifs``."

#: ../../library/ast.rst:673
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` indica que uma compreensão é assíncrona (usando um ``async "
"for`` em vez de ``for``). O valor é um inteiro (0 ou 1)."

#: ../../library/ast.rst:739
msgid "Statements"
msgstr "Declarações"

#: ../../library/ast.rst:743
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"Uma atribuição. ``targets`` é uma lista de nós, e ``value`` é um nó único."

#: ../../library/ast.rst:745
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Múltiplos nós em ``targets`` representa a atribuição do mesmo valor a cada "
"um. A descompactação é representada colocando um :class:`Tuple` ou :class:"
"`List` dentro de ``targets``."

#: ../../library/ast.rst:751 ../../library/ast.rst:1038
#: ../../library/ast.rst:1211 ../../library/ast.rst:1632
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` é uma *string* opcional com a anotação de tipo como um "
"comentário."

#: ../../library/ast.rst:781
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""

#: ../../library/ast.rst:836
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Atribuição aumentada, como ``a += 1``. No exemplo seguinte, ``target`` é um "
"nó :class:`Name` para ``x`` (com o contexto :class:`Store`), ``op`` é :class:"
"`Add`, e ``value`` é um :class:`Constant` com o valor 1."

#: ../../library/ast.rst:841
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""
"O atributo ``target`` não pode ser da classe :class:`Tuple` ou :class:"
"`List`, ao contrário dos alvos de :class:`Assign`."

#: ../../library/ast.rst:858
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Uma declaração ``raise``. ``exc`` é o objeto de exceção a ser gerado, "
"normalmente um :class:`Call` ou :class:`Name`, ou ``None`` para um ``raise`` "
"autónomo. ``cause`` é a parte opcional para ``y`` em ``raise x from y``."

#: ../../library/ast.rst:875
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Uma afirmação. ``test`` contém a condição, como um nó :class:`Compare`. "
"``msg`` contém a mensagem de falha."

#: ../../library/ast.rst:891
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Representa uma declaração ``del``. ``targets`` é uma lista de nós, como nós :"
"class:`Name`, :class:`Attribute` ou :class:`Subscript`."

#: ../../library/ast.rst:909
msgid "A ``pass`` statement."
msgstr "Uma declaração ``pass``."

#: ../../library/ast.rst:920
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Outras declarações que são aplicáveis apenas dentro de funções ou ciclos são "
"descritas noutras secções."

#: ../../library/ast.rst:924
msgid "Imports"
msgstr "Importações"

#: ../../library/ast.rst:928
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr ""
"Uma declaração de importação. ``names`` é uma lista de nós :class:`alias`."

#: ../../library/ast.rst:945
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Representa ``from x import y``. ``module`` é uma *string* bruta do nome "
"'from', sem quaisquer pontos iniciais, ou ``None`` para declarações como "
"``from . import foo``. ``level`` é um inteiro que contém o nível da "
"importação relativa (0 significa importação absoluta)."

#: ../../library/ast.rst:967
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Ambos os parâmetros são *strings* brutas dos nomes. ``asname`` pode ser "
"``None`` se o nome regular for usado."

#: ../../library/ast.rst:984
msgid "Control flow"
msgstr "Controlo de fluxo"

#: ../../library/ast.rst:987
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Cláusulas opcionais como ``else`` são armazenadas como uma lista vazia se "
"não estiverem presentes."

#: ../../library/ast.rst:992
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"Uma declaração ``if``. ``test`` contém um nó único, como um nó :class:"
"`Compare`. ``body`` e ``orelse`` contêm cada um uma lista de nós."

#: ../../library/ast.rst:995
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"As cláusulas ``elif`` não têm uma representação especial na AST, mas "
"aparecem como nós :class:`If` extra dentro da secção ``orelse`` da anterior."

#: ../../library/ast.rst:1030
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""

#: ../../library/ast.rst:1064
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr ""
"Um ciclo ``while``. ``test`` contém a condição, como um nó :class:`Compare`."

#: ../../library/ast.rst:1091
msgid "The ``break`` and ``continue`` statements."
msgstr "As declarações ``break`` e ``continue``."

#: ../../library/ast.rst:1126
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"Blocos ``try``. Todos os atributos são listas de nós a executar, exceto "
"``handlers``, que é uma lista de nós :class:`ExceptHandler`."

#: ../../library/ast.rst:1172
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"Uma cláusula ``except`` única. ``type`` é o tipo de exceção que irá "
"corresponder, tipicamente um nó :class:`Name` (ou ``None`` para uma cláusula "
"``except:`` genérica). ``name`` é uma *string* bruta para o nome que contém "
"a exceção, ou ``None`` se a cláusula não tiver ``as foo``. ``body`` é uma "
"lista de nós."

#: ../../library/ast.rst:1206
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Um bloco ``with``. ``items`` é uma lista de nós :class:`withitem` que "
"representam os gestores de contexto, e ``body`` é o bloco indentado dentro "
"do contexto."

#: ../../library/ast.rst:1216
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"Um único gestor de contexto num bloco ``with``. ``context_expr`` é o gestor "
"de contexto, frequentemente um nó :class:`Call`. ``optional_vars`` é um :"
"class:`Name`, :class:`Tuple` ou :class:`List` para a parte ``as foo``, ou "
"``None`` se não for usado."

#: ../../library/ast.rst:1249
msgid "Pattern matching"
msgstr "Correspondência de padrões"

#: ../../library/ast.rst:1254
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an "
"iterable of :class:`match_case` nodes with the different cases."
msgstr ""
"Uma declaração ``match``. ``subject`` contém o assunto da correspondência (o "
"objeto que está a ser correspondido com os casos) e ``cases`` contém um "
"iterável de nós :class:`match_case` com os diferentes casos."

#: ../../library/ast.rst:1260
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the :class:"
"`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""
"Um único padrão de caso numa declaração ``match``. ``pattern`` contém o "
"padrão de correspondência com o qual o assunto será correspondido. Note que "
"os nós :class:`AST` produzidos para padrões diferem daqueles produzidos para "
"expressões, mesmo quando partilham a mesma sintaxe."

#: ../../library/ast.rst:1265
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if the "
"pattern matches the subject."
msgstr ""
"O atributo ``guard`` contém uma expressão que será avaliada se o padrão "
"corresponder ao assunto."

#: ../../library/ast.rst:1268
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and the "
"result of evaluating the guard expression is true."
msgstr ""
"``body`` contém uma lista de nós a executar se o padrão corresponder e o "
"resultado da avaliação da expressão de guarda for verdadeiro."

#: ../../library/ast.rst:1311
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is an "
"expression node. Permitted value nodes are restricted as described in the "
"match statement documentation. This pattern succeeds if the match subject is "
"equal to the evaluated value."
msgstr ""
"Um padrão literal ou de valor de correspondência que compara por igualdade. "
"``value`` é um nó de expressão. Os nós de valor permitidos são restritos "
"como descritos na documentação da declaração de correspondência. Este padrão "
"tem sucesso se o assunto da correspondência for igual ao valor avaliado."

#: ../../library/ast.rst:1338
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""
"Um padrão literal de correspondência que compara por identidade. ``value`` é "
"o singleton a ser comparado: ``None``, ``True``, ou ``False``. Este padrão "
"tem sucesso se o assunto da correspondência for a constante dada."

#: ../../library/ast.rst:1363
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be matched "
"against the subject elements if the subject is a sequence. Matches a "
"variable length sequence if one of the subpatterns is a ``MatchStar`` node, "
"otherwise matches a fixed length sequence."
msgstr ""
"Um padrão de sequência de correspondência. ``patterns`` contém os padrões a "
"serem correspondidos com os elementos do assunto se o assunto for uma "
"sequência. Corresponde a uma sequência de comprimento variável se um dos "
"subpadrões for um nó ``MatchStar``, caso contrário corresponde a uma "
"sequência de comprimento fixo."

#: ../../library/ast.rst:1394
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern is "
"successful."
msgstr ""
"Corresponde ao resto da sequência num padrão de sequência de correspondência "
"de comprimento variável. Se ``name`` não for ``None``, uma lista contendo os "
"elementos restantes da sequência é ligada a esse nome se o padrão de "
"sequência global for bem-sucedido."

#: ../../library/ast.rst:1434
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an "
"optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the match "
"statement documentation."
msgstr ""
"Um padrão de mapeamento de correspondência. ``keys`` é uma sequência de nós "
"de expressão. ``patterns`` é uma sequência correspondente de nós de padrão. "
"``rest`` é um nome opcional que pode ser especificado para capturar os "
"elementos de mapeamento restantes. As expressões de chave permitidas são "
"restritas como descrito na documentação da declaração de correspondência."

#: ../../library/ast.rst:1440
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to each "
"key matches the corresponding subpattern. If ``rest`` is not ``None``, a "
"dict containing the remaining mapping elements is bound to that name if the "
"overall mapping pattern is successful."
msgstr ""
"Este padrão tem sucesso se o assunto for um mapeamento, todas as expressões "
"de chave avaliadas estiverem presentes no mapeamento, e o valor "
"correspondente a cada chave corresponder ao subpadrão correspondente. Se "
"``rest`` não for ``None``, um dicionário contendo os elementos de mapeamento "
"restantes é ligado a esse nome se o padrão de mapeamento global for bem-"
"sucedido."

#: ../../library/ast.rst:1480
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class to "
"be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` are "
"the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""
"Um padrão de correspondência de classe. ``cls`` é uma expressão que dá a "
"classe nominal a ser correspondida. ``patterns`` é uma sequência de nós de "
"padrão a serem correspondidos com a sequência de atributos de "
"correspondência de padrão definidos pela classe. ``kwd_attrs`` é uma "
"sequência de atributos adicionais a serem correspondidos (especificados como "
"argumentos de palavra-chave no padrão de classe), ``kwd_patterns`` são os "
"padrões correspondentes (especificados como valores de palavra-chave no "
"padrão de classe)."

#: ../../library/ast.rst:1487
msgid ""
"This pattern succeeds if the subject is an instance of the nominated class, "
"all positional patterns match the corresponding class-defined attributes, "
"and any specified keyword attributes match their corresponding pattern."
msgstr ""
"Este padrão tem sucesso se o assunto for uma instância da classe nomeada, "
"todos os padrões posicionais corresponderem aos atributos correspondentes "
"definidos pela classe, e quaisquer atributos de palavra-chave especificados "
"corresponderem aos seus padrões correspondentes."

#: ../../library/ast.rst:1491
msgid ""
"Note: classes may define a property that returns self in order to match a "
"pattern node against the instance being matched. Several builtin types are "
"also matched that way, as described in the match statement documentation."
msgstr ""
"Nota: as classes podem definir uma propriedade que devolve self para "
"corresponder um nó de padrão à instância que está a ser correspondida. "
"Vários tipos integrados também são correspondidos dessa forma, como descrito "
"na documentação da declaração de correspondência."

#: ../../library/ast.rst:1544
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If the "
"pattern is ``None``, the node represents a capture pattern (i.e a bare name) "
"and will always succeed."
msgstr ""
"Um padrão \"as-pattern\", padrão de captura ou padrão curinga. ``pattern`` "
"contém o padrão de correspondência com o qual o assunto será correspondido. "
"Se o padrão for ``None``, o nó representa um padrão de captura (ou seja, um "
"nome simples) e terá sempre sucesso."

#: ../../library/ast.rst:1549
msgid ""
"The ``name`` attribute contains the name that will be bound if the pattern "
"is successful. If ``name`` is ``None``, ``pattern`` must also be ``None`` "
"and the node represents the wildcard pattern."
msgstr ""
"O atributo ``name`` contém o nome que será ligado se o padrão for bem-"
"sucedido. Se ``name`` for ``None``, ``pattern`` também deve ser ``None`` e o "
"nó representa o padrão curinga."

#: ../../library/ast.rst:1585
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to "
"succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will be "
"matched against the subject."
msgstr ""
"Um padrão \"or-pattern\". Um or-pattern corresponde a cada um dos seus "
"subpadrões, por sua vez, ao assunto, até que um tenha sucesso. O or-pattern "
"é então considerado bem-sucedido. Se nenhum dos subpadrões tiver sucesso, o "
"or-pattern falha. O atributo ``patterns`` contém uma lista de nós de padrão "
"de correspondência que serão correspondidos com o assunto."

#: ../../library/ast.rst:1617
msgid "Function and class definitions"
msgstr "Definições de funções e classes"

#: ../../library/ast.rst:1621
msgid "A function definition."
msgstr "Uma definição de função."

#: ../../library/ast.rst:1623
msgid "``name`` is a raw string of the function name."
msgstr "``name`` é uma *string* bruta do nome da função."

#: ../../library/ast.rst:1624
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` é um nó :class:`arguments`."

#: ../../library/ast.rst:1625
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` é a lista de nós dentro da função."

#: ../../library/ast.rst:1626
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` é a lista de decoradores a serem aplicados, armazenados "
"do mais externo para o mais interno (ou seja, o primeiro na lista será "
"aplicado por último)."

#: ../../library/ast.rst:1628
msgid "``returns`` is the return annotation."
msgstr "``returns`` é a anotação de retorno."

#: ../../library/ast.rst:1637
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``lambda`` é uma definição mínima de função que pode ser usada dentro de uma "
"expressão. Ao contrário de :class:`FunctionDef`, ``body`` contém um nó único."

#: ../../library/ast.rst:1661
msgid "The arguments for a function."
msgstr "Os argumentos para uma função."

#: ../../library/ast.rst:1663
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` e ``kwonlyargs`` são listas de nós :class:`arg`."

#: ../../library/ast.rst:1664
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` e ``kwarg`` são nós únicos :class:`arg`, referindo-se aos "
"parâmetros ``*args, **kwargs``."

#: ../../library/ast.rst:1666
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` é uma lista de valores predefinidos para argumentos apenas "
"de palavra-chave. Se um for ``None``, o argumento correspondente é "
"obrigatório."

#: ../../library/ast.rst:1668
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` é uma lista de valores predefinidos para argumentos que podem "
"ser passados posicionalmente. Se houver menos valores predefinidos, eles "
"correspondem aos últimos n argumentos."

#: ../../library/ast.rst:1675
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""

#: ../../library/ast.rst:1681
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr ""
"``type_comment`` é uma *string* opcional com a anotação de tipo como um "
"comentário."

#: ../../library/ast.rst:1725
msgid "A ``return`` statement."
msgstr "Uma declaração ``return``."

#: ../../library/ast.rst:1740
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""

#: ../../library/ast.rst:1765
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"Declarações ``global`` e ``nonlocal``. ``names`` é uma lista de *strings* "
"brutas."

#: ../../library/ast.rst:1792
msgid "A class definition."
msgstr "Uma definição de classe."

#: ../../library/ast.rst:1794
msgid "``name`` is a raw string for the class name"
msgstr "``name`` é uma *string* bruta para o nome da classe."

#: ../../library/ast.rst:1795
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr ""
"``bases`` é uma lista de nós para classes base explicitamente especificadas."

#: ../../library/ast.rst:1796
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://www.python.org/dev/peps/pep-3115/>`_."
msgstr ""

#: ../../library/ast.rst:1799
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function call. "
"starargs will be expanded to join the list of base classes, and kwargs will "
"be passed to the metaclass."
msgstr ""

#: ../../library/ast.rst:1802
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""
"``body`` é uma lista de nós que representam o código dentro da definição da "
"classe."

#: ../../library/ast.rst:1804
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` é uma lista de nós, como em :class:`FunctionDef`."

#: ../../library/ast.rst:1833
msgid "Async and await"
msgstr "Async e await"

#: ../../library/ast.rst:1837
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"Uma definição de função ``async def``. Tem os mesmos campos que :class:"
"`FunctionDef`."

#: ../../library/ast.rst:1843
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Uma expressão ``await``. ``value`` é o que espera. Apenas válida no corpo de "
"um :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:1876
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Ciclos ``async for`` e gestores de contexto ``async with``. Têm os mesmos "
"campos que :class:`For` e :class:`With`, respetivamente. Apenas válidos no "
"corpo de um :class:`AsyncFunctionDef`."

#: ../../library/ast.rst:1881
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""

#: ../../library/ast.rst:1889
msgid ":mod:`ast` Helpers"
msgstr ""

#: ../../library/ast.rst:1891
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Além das classes de nós, o módulo :mod:`ast` define estas funções e classes "
"utilitárias para percorrer árvores de sintaxe abstrata:"

#: ../../library/ast.rst:1896
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""

#: ../../library/ast.rst:1899
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""

#: ../../library/ast.rst:1909
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Além disso, se ``mode`` for ``'func_type'``, a sintaxe de entrada é "
"modificada para corresponder aos comentários de tipo de assinatura :pep:"
"`484`, por exemplo, ``(str, int) -> List[str]``."

#: ../../library/ast.rst:1913
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""

#: ../../library/ast.rst:1920
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr ""

#: ../../library/ast.rst:1923
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Note que analisar com sucesso o código-fonte num objeto AST não garante que "
"o código-fonte fornecido seja código Python válido que possa ser executado, "
"uma vez que a etapa de compilação pode gerar exceções adicionais :exc:"
"`SyntaxError`. Por exemplo, a origem ``return 42`` gera um nó AST válido "
"para uma declaração de retorno, mas não pode ser compilada sozinha (precisa "
"de estar dentro de um nó de função)."

#: ../../library/ast.rst:1930
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"Em particular, :func:`ast.parse` não fará quaisquer verificações de âmbito, "
"que a etapa de compilação faz."

#: ../../library/ast.rst:1934
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"É possível fazer com que o interpretador Python falhe com uma *string* "
"suficientemente grande/complexa devido a limitações de profundidade de pilha "
"no compilador AST do Python."

#: ../../library/ast.rst:1938
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""
"Adicionado ``type_comments``, ``mode='func_type'`` e ``feature_version``."

#: ../../library/ast.rst:1944
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Desfazer a análise de um objeto :class:`ast.AST` e gerar uma *string* com "
"código que produziria um objeto :class:`ast.AST` equivalente se analisado "
"novamente com :func:`ast.parse`."

#: ../../library/ast.rst:1949
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"A *string* de código produzida não será necessariamente igual ao código "
"original que gerou o objeto :class:`ast.AST` (sem quaisquer otimizações do "
"compilador, como tuplos/sets imutáveis constantes)."

#: ../../library/ast.rst:1954
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Tentar desfazer a análise de uma expressão altamente complexa resultaria "
"numa :exc:`RecursionError`."

#: ../../library/ast.rst:1962
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"Avaliar um nó de expressão ou uma *string* contendo apenas um literal Python "
"ou uma exibição de contentor. A *string* ou nó fornecido pode consistir "
"apenas nas seguintes estruturas literais Python: *strings*, bytes, números, "
"tuplos, listas, dicionários, conjuntos, booleanos, ``None`` e ``Ellipsis``."

#: ../../library/ast.rst:1967
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""
"Isto pode ser usado para avaliar *strings* contendo valores Python sem a "
"necessidade de analisar os valores manualmente. Não é capaz de avaliar "
"expressões arbitrariamente complexas, por exemplo, envolvendo operadores ou "
"indexação."

#: ../../library/ast.rst:1972
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""
"Esta função foi documentada como \"segura\" no passado sem definir o que "
"isso significava. Isso era enganador. Isto é especificamente concebido para "
"não executar código Python, ao contrário da :func:`eval` mais geral. Não há "
"espaço de nomes, procuras de nomes ou capacidade de chamar para fora. Mas "
"não está livre de ataques: uma entrada relativamente pequena pode levar à "
"exaustão de memória ou à exaustão da pilha C, fazendo com que o processo "
"falhe. Há também a possibilidade de negação de serviço por consumo excessivo "
"de CPU em algumas entradas. Chamar isto em dados não confiáveis não é "
"recomendado."

#: ../../library/ast.rst:1982
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"É possível fazer com que o interpretador Python falhe devido a limitações de "
"profundidade de pilha no compilador AST do Python."

#: ../../library/ast.rst:1985
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` and :exc:`RecursionError` depending on the malformed input."
msgstr ""
"Pode gerar :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, :exc:"
"`MemoryError` e :exc:`RecursionError` dependendo da entrada malformada."

#: ../../library/ast.rst:1989
msgid "Now allows bytes and set literals."
msgstr "Agora permite literais de bytes e conjuntos."

#: ../../library/ast.rst:1992
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "Agora suporta a criação de conjuntos vazios com ``'set()'``."

#: ../../library/ast.rst:1995
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""
"Para entradas de *string*, os espaços e tabulações iniciais são agora "
"removidos."

#: ../../library/ast.rst:2001
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Devolve a docstring do nó *node* dado (que deve ser um nó :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef` ou :class:"
"`Module`), ou ``None`` se não tiver docstring. Se *clean* for verdadeiro, "
"limpa a indentação da docstring com :func:`inspect.cleandoc`."

#: ../../library/ast.rst:2007
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` é agora suportado."

#: ../../library/ast.rst:2013
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""

#: ../../library/ast.rst:2017
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Se *padded* for ``True``, a primeira linha de uma declaração de várias "
"linhas será preenchida com espaços para corresponder à sua posição original."

#: ../../library/ast.rst:2025
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""

#: ../../library/ast.rst:2034
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Incrementa o número da linha e o número da linha final de cada nó na árvore, "
"começando em *node*, por *n*. Isto é útil para \"mover código\" para uma "
"localização diferente num ficheiro."

#: ../../library/ast.rst:2041
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""

#: ../../library/ast.rst:2048
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Devolve um tuplo de ``(fieldname, value)`` para cada campo em ``node."
"_fields`` que esteja presente em *node*."

#: ../../library/ast.rst:2054
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Devolve todos os nós filhos diretos de *node*, ou seja, todos os campos que "
"são nós e todos os itens de campos que são listas de nós."

#: ../../library/ast.rst:2060
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Devolve recursivamente todos os nós descendentes na árvore, começando em "
"*node* (incluindo *node* próprio), sem ordem especificada. Isto é útil se "
"apenas quiser modificar nós no local e não se importar com o contexto."

#: ../../library/ast.rst:2067
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Uma classe base de visitante de nós que percorre a árvore de sintaxe "
"abstrata e chama uma função de visitante para cada nó encontrado. Esta "
"função pode devolver um valor que é encaminhado pelo método :meth:`visit`."

#: ../../library/ast.rst:2071
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Esta classe destina-se a ser subclassificada, com a subclasse a adicionar "
"métodos de visitante."

#: ../../library/ast.rst:2076
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Visitar um nó. A implementação predefinida chama o método chamado :samp:"
"`self.visit_{classname}` onde *classname* é o nome da classe do nó, ou :meth:"
"`generic_visit` se esse método não existir."

#: ../../library/ast.rst:2082
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Este visitante chama :meth:`visit` em todos os filhos do nó."

#: ../../library/ast.rst:2084
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Note que os nós filhos de nós que têm um método de visitante personalizado "
"não serão visitados a menos que o visitante chame :meth:`generic_visit` ou "
"os visite ele próprio."

#: ../../library/ast.rst:2088
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"Não utilize o :class:`NodeVisitor` se pretender aplicar alterações aos nós "
"durante a travessia. Para isso, existe um visitante especial (:class:"
"`NodeTransformer`) que permite modificações."

#: ../../library/ast.rst:2094
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""

#: ../../library/ast.rst:2102
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"Uma subclasse de :class:`NodeVisitor` que percorre a árvore de sintaxe "
"abstrata e permite a modificação de nós."

#: ../../library/ast.rst:2105
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
"O :class:`NodeTransformer` percorrerá a AST e usará o valor de retorno dos "
"métodos de visitante para substituir ou remover o nó antigo. Se o valor de "
"retorno do método de visitante for ``None``, o nó será removido da sua "
"localização; caso contrário, será substituído pelo valor de retorno. O valor "
"de retorno pode ser o nó original, caso em que não ocorre substituição."

#: ../../library/ast.rst:2111
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Aqui está um exemplo de transformador que reescreve todas as ocorrências de "
"procuras de nome (``foo``) para ``data['foo']``: :"

#: ../../library/ast.rst:2123
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""

#: ../../library/ast.rst:2127
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Para nós que faziam parte de uma coleção de declarações (que se aplica a "
"todos os nós de declaração), o visitante também pode devolver uma lista de "
"nós em vez de apenas um nó único."

#: ../../library/ast.rst:2131
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""

#: ../../library/ast.rst:2139
msgid "Usually you use the transformer like this::"
msgstr "Normalmente, utiliza o transformador assim: :"

#: ../../library/ast.rst:2146
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Devolve um dump formatado da árvore em *node*. Isto é principalmente útil "
"para fins de depuração. Se *annotate_fields* for verdadeiro (por "
"predefinição), a *string* devolvida mostrará os nomes e os valores para os "
"campos. Se *annotate_fields* for falso, a *string* resultante será mais "
"compacta, omitindo nomes de campos não ambíguos. Atributos como números de "
"linha e deslocamentos de coluna não são descarregados por predefinição. Se "
"isto for pretendido, *include_attributes* pode ser definido como verdadeiro."

#: ../../library/ast.rst:2154
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Se *indent* for um inteiro não negativo ou uma *string*, então a árvore será "
"impressa com formatação com esse nível de indentação. Um nível de indentação "
"de 0, negativo ou ``\"\"`` apenas inserirá novas linhas. ``None`` "
"(predefinição) seleciona a representação de linha única. Usar um inteiro "
"positivo para indentação indentará esse número de espaços por nível. Se "
"*indent* for uma *string* (como ``\"\\t\"``), essa *string* é usada para "
"indentar cada nível."

#: ../../library/ast.rst:2161
msgid "Added the *indent* option."
msgstr "Adicionada a opção *indent*."

#: ../../library/ast.rst:2168
msgid "Compiler Flags"
msgstr ""

#: ../../library/ast.rst:2170
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"As seguintes *flags* podem ser passadas para :func:`compile` para alterar os "
"efeitos na compilação de um programa:"

#: ../../library/ast.rst:2175
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Ativa o suporte para ``await`` de nível superior, ``async for``, ``async "
"with`` e compreensões assíncronas."

#: ../../library/ast.rst:2182
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Gera e devolve uma árvore de sintaxe abstrata em vez de devolver um objeto "
"de código compilado."

#: ../../library/ast.rst:2187
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Ativa o suporte para comentários de tipo no estilo :pep:`484` e :pep:`526` "
"(``# type: <type>``, ``# type: ignore <stuff>``)."

#: ../../library/ast.rst:2196
msgid "Command-Line Usage"
msgstr ""

#: ../../library/ast.rst:2200
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"O módulo :mod:`ast` pode ser executado como um script a partir da linha de "
"comandos. É tão simples como:"

#: ../../library/ast.rst:2207
msgid "The following options are accepted:"
msgstr "As seguintes opções são aceites:"

#: ../../library/ast.rst:2213
msgid "Show the help message and exit."
msgstr "Mostra a mensagem de ajuda e sai."

#: ../../library/ast.rst:2218
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Especifica que tipo de código deve ser compilado, como o argumento *mode* "
"em :func:`parse`."

#: ../../library/ast.rst:2223
msgid "Don't parse type comments."
msgstr "Não analisar comentários de tipo."

#: ../../library/ast.rst:2227
msgid "Include attributes such as line numbers and column offsets."
msgstr "Incluir atributos como números de linha e deslocamentos de coluna."

#: ../../library/ast.rst:2232
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Indentação dos nós na AST (número de espaços)."

#: ../../library/ast.rst:2234
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Se :file:`infile` for especificado, o seu conteúdo é analisado para AST e "
"descarregado para stdout. Caso contrário, o conteúdo é lido de stdin."

#: ../../library/ast.rst:2240
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, um recurso "
"de documentação externo, tem bons detalhes sobre como trabalhar com ASTs do "
"Python."

#: ../../library/ast.rst:2243
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"anota ASTs do Python com as posições de *tokens* e texto no código-fonte que "
"os gerou. Isto é útil para ferramentas que fazem transformações de código-"
"fonte."

#: ../../library/ast.rst:2248
msgid ""
"`leoAst.py <https://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:2252
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ analisa código como uma Árvore de "
"Sintaxe Concreta que parece uma árvore AST e mantém todos os detalhes de "
"formatação. É útil para construir aplicações de refatoração automatizada "
"(codemod) e linters."

#: ../../library/ast.rst:2257
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
