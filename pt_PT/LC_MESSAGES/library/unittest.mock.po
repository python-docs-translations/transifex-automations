# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-17 16:12+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/unittest.mock.rst:2
msgid ":mod:`!unittest.mock` --- mock object library"
msgstr ":mod:`!unittest.mock` --- biblioteca de objetos mock"

#: ../../library/unittest.mock.rst:12
msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**Código-fonte:** :source:`Lib/unittest/mock.py`"

#: ../../library/unittest.mock.rst:16
msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` é uma biblioteca para testes em Python. Permite-lhe "
"substituir partes do seu sistema em teste por objetos mock e fazer "
"afirmações sobre como foram usados."

#: ../../library/unittest.mock.rst:20
msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` fornece uma classe principal :class:`Mock` que elimina "
"a necessidade de criar vários stubs em toda a sua suite de testes. Após "
"realizar uma ação, pode fazer afirmações sobre quais métodos/atributos foram "
"usados e os argumentos com que foram chamados. Também pode especificar "
"valores de retorno e definir atributos necessários da forma habitual."

#: ../../library/unittest.mock.rst:26
msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"Além disso, mock fornece um decorador :func:`patch` que trata da "
"substituição de atributos a nível de módulo e classe dentro do âmbito de um "
"teste, juntamente com :const:`sentinel` para criar objetos únicos. Veja o "
"`guia rápido`_ para alguns exemplos de como usar :class:`Mock`, :class:"
"`MagicMock` e :func:`patch`."

#: ../../library/unittest.mock.rst:32
msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock é concebido para ser usado com :mod:`unittest` e é baseado no padrão "
"'ação -> afirmação' em vez do 'gravar -> reproduzir' usado por muitos "
"frameworks de mock."

#: ../../library/unittest.mock.rst:36
msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as :pypi:`mock` on PyPI."
msgstr ""
"Existe uma retroportagem de :mod:`unittest.mock` para versões anteriores do "
"Python, disponível como :pypi:`mock` no PyPI."

#: ../../library/unittest.mock.rst:41
msgid "Quick Guide"
msgstr "Guia Rápido"

#: ../../library/unittest.mock.rst:59
msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
"Os objetos :class:`Mock` e :class:`MagicMock` criam todos os atributos e "
"métodos à medida que os acede e armazenam detalhes sobre como foram usados. "
"Pode configurá-los para especificar valores de retorno ou limitar quais "
"atributos estão disponíveis e, em seguida, fazer afirmações sobre como foram "
"usados:"

#: ../../library/unittest.mock.rst:71
msgid ""
":attr:`~Mock.side_effect` allows you to perform side effects, including "
"raising an exception when a mock is called:"
msgstr ""
":attr:`~Mock.side_effect` permite-lhe realizar efeitos secundários, "
"incluindo lançar uma exceção quando um mock é chamado:"

#: ../../library/unittest.mock.rst:92
msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"Mock tem muitas outras formas de o configurar e controlar o seu "
"comportamento. Por exemplo, o argumento *spec* configura o mock para obter a "
"sua especificação de outro objeto. Tentar aceder a atributos ou métodos no "
"mock que não existam no spec falhará com um :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:97
msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
"O decorador/gestor de contexto :func:`patch` facilita a simulação de classes "
"ou objetos num módulo em teste. O objeto que especificar será substituído "
"por um mock (ou outro objeto) durante o teste e restaurado quando o teste "
"terminar::"

#: ../../library/unittest.mock.rst:101
msgid ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"
msgstr ""
">>> from unittest.mock import patch\n"
">>> @patch('module.ClassName2')\n"
"... @patch('module.ClassName1')\n"
"... def test(MockClass1, MockClass2):\n"
"...     module.ClassName1()\n"
"...     module.ClassName2()\n"
"...     assert MockClass1 is module.ClassName1\n"
"...     assert MockClass2 is module.ClassName2\n"
"...     assert MockClass1.called\n"
"...     assert MockClass2.called\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:116
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"Quando aninha decoradores patch, os mocks são passados para a função "
"decorada na mesma ordem em que foram aplicados (a ordem normal *Python* em "
"que os decoradores são aplicados). Isto significa de baixo para cima, por "
"isso no exemplo acima o mock para ``module.ClassName1`` é passado primeiro."

#: ../../library/unittest.mock.rst:121
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"Com :func:`patch`, é importante substituir objetos no espaço de nomes onde "
"são procurados. Isto é normalmente simples, mas para um guia rápido leia :"
"ref:`onde substituir <where-to-patch>`."

#: ../../library/unittest.mock.rst:125
msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr ""
"Além de um decorador, :func:`patch` pode ser usado como um gestor de "
"contexto numa declaração with:"

#: ../../library/unittest.mock.rst:135
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Também existe :func:`patch.dict` para definir valores num dicionário apenas "
"durante um âmbito e restaurar o dicionário para o seu estado original quando "
"o teste termina:"

#: ../../library/unittest.mock.rst:146
msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"Mock suporta a simulação de :ref:`métodos mágicos <magic-methods>` do "
"Python. A forma mais fácil de usar métodos mágicos é com a classe :class:"
"`MagicMock`. Permite-lhe fazer coisas como:"

#: ../../library/unittest.mock.rst:156
msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"Mock permite-lhe atribuir funções (ou outras instâncias Mock) a métodos "
"mágicos e elas serão chamadas apropriadamente. A classe :class:`MagicMock` é "
"apenas uma variante de Mock que tem todos os métodos mágicos pré-criados "
"para si (bem, todos os úteis, de qualquer forma)."

#: ../../library/unittest.mock.rst:161
msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr ""
"O seguinte é um exemplo de uso de métodos mágicos com a classe Mock normal:"

#: ../../library/unittest.mock.rst:169
msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"Para garantir que os objetos mock nos seus testes têm a mesma API que os "
"objetos que estão a substituir, pode usar :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing pode ser feito através do argumento *autospec* "
"para patch, ou da função :func:`create_autospec`. Auto-speccing cria objetos "
"mock que têm os mesmos atributos e métodos que os objetos que estão a "
"substituir, e quaisquer funções e métodos (incluindo construtores) têm a "
"mesma assinatura de chamada que o objeto real."

#: ../../library/unittest.mock.rst:177
msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr ""
"Isto garante que os seus mocks falharão da mesma forma que o seu código de "
"produção se forem usados incorretamente:"

#: ../../library/unittest.mock.rst:193
msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` também pode ser usado em classes, onde copia a "
"assinatura do método ``__init__``, e em objetos chamáveis onde copia a "
"assinatura do método ``__call__``."

#: ../../library/unittest.mock.rst:200
msgid "The Mock Class"
msgstr "A Classe Mock"

#: ../../library/unittest.mock.rst:211
msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` é um objeto mock flexível destinado a substituir o uso de "
"stubs e dobles de teste em todo o seu código. Os mocks são chamáveis e criam "
"atributos como novos mocks quando os acede [#]_. Aceder ao mesmo atributo "
"sempre devolverá o mesmo mock. Os mocks registam como os usa, permitindo-lhe "
"fazer afirmações sobre o que o seu código fez a eles."

#: ../../library/unittest.mock.rst:217
msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` é uma subclasse de :class:`Mock` com todos os métodos "
"mágicos pré-criados e prontos a usar. Também existem variantes não "
"chamáveis, úteis quando está a simular objetos que não são chamáveis: :class:"
"`NonCallableMock` e :class:`NonCallableMagicMock`."

#: ../../library/unittest.mock.rst:222
msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
"Os decoradores :func:`patch` facilitam a substituição temporária de classes "
"num módulo específico por um objeto :class:`Mock`. Por predefinição, :func:"
"`patch` criará um :class:`MagicMock` para si. Pode especificar uma classe "
"alternativa de :class:`Mock` usando o argumento *new_callable* para :func:"
"`patch`."

#: ../../library/unittest.mock.rst:230
msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"Cria um novo objeto :class:`Mock`. :class:`Mock` aceita vários argumentos "
"opcionais que especificam o comportamento do objeto Mock:"

#: ../../library/unittest.mock.rst:233
msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*: Isto pode ser uma lista de strings ou um objeto existente (uma "
"classe ou instância) que atua como especificação para o objeto mock. Se "
"passar um objeto, uma lista de strings é formada chamando dir no objeto "
"(excluindo atributos e métodos mágicos não suportados). Aceder a qualquer "
"atributo não nesta lista lançará um :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:239
msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~object."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""
"Se *spec* for um objeto (em vez de uma lista de strings), então :attr:"
"`~object.__class__` devolve a classe do objeto spec. Isto permite que os "
"mocks passem nos testes :func:`isinstance`."

#: ../../library/unittest.mock.rst:243
msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*: Uma variante mais rigorosa de *spec*. Se usado, tentar *definir* "
"ou obter um atributo no mock que não exista no objeto passado como "
"*spec_set* lançará um :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:247
msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*: Uma função a ser chamada sempre que o Mock for chamado. Veja "
"o atributo :attr:`~Mock.side_effect`. Útil para lançar exceções ou alterar "
"dinamicamente valores de retorno. A função é chamada com os mesmos "
"argumentos que o mock, e a menos que retorne :data:`DEFAULT`, o valor de "
"retorno desta função é usado como o valor de retorno."

#: ../../library/unittest.mock.rst:253
msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr ""
"Alternativamente, *side_effect* pode ser uma classe de exceção ou instância. "
"Neste caso, a exceção será lançada quando o mock for chamado."

#: ../../library/unittest.mock.rst:256
msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr ""
"Se *side_effect* for um iterável, então cada chamada ao mock devolverá o "
"próximo valor do iterável."

#: ../../library/unittest.mock.rst:259
msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr "Um *side_effect* pode ser limpo definindo-o como ``None``."

#: ../../library/unittest.mock.rst:261
msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*: O valor devolvido quando o mock é chamado. Por predefinição, "
"é um novo Mock (criado no primeiro acesso). Veja o atributo :attr:"
"`return_value`."

#: ../../library/unittest.mock.rst:265
msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*unsafe*: Por predefinição, aceder a qualquer atributo cujo nome comece com "
"*assert*, *assret*, *asert*, *aseert* ou *assrt* lançará um :exc:"
"`AttributeError`. Passar ``unsafe=True`` permitirá o acesso a estes "
"atributos."

#: ../../library/unittest.mock.rst:272
msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*wraps*: Item para o objeto mock envolver. Se *wraps* não for ``None``, "
"então chamar o Mock passará a chamada para o objeto envolvido (devolvendo o "
"resultado real). O acesso a atributos no mock devolverá um objeto Mock que "
"envolve o atributo correspondente do objeto envolvido (portanto, tentar "
"aceder a um atributo que não exista lançará um :exc:`AttributeError`)."

#: ../../library/unittest.mock.rst:279
msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr ""
"Se o mock tiver um *return_value* explícito definido, então as chamadas não "
"são passadas para o objeto envolvido e o *return_value* é devolvido em vez "
"disso."

#: ../../library/unittest.mock.rst:282
msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr ""
"*name*: Se o mock tiver um nome, então ele será usado na representação do "
"mock. Isto pode ser útil para depuração. O nome é propagado para os mocks "
"filhos."

#: ../../library/unittest.mock.rst:286
msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"Os mocks também podem ser chamados com argumentos de palavra-chave "
"arbitrários. Estes serão usados para definir atributos no mock após a sua "
"criação. Veja o método :meth:`configure_mock` para detalhes."

#: ../../library/unittest.mock.rst:292
msgid "Assert that the mock was called at least once."
msgstr "Afirma que o mock foi chamado pelo menos uma vez."

#: ../../library/unittest.mock.rst:303
msgid "Assert that the mock was called exactly once."
msgstr "Afirma que o mock foi chamado exatamente uma vez."

#: ../../library/unittest.mock.rst:321
msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr ""
"Este método é uma forma conveniente de afirmar que a última chamada foi "
"feita de uma determinada forma:"

#: ../../library/unittest.mock.rst:331
msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr ""
"Afirma que o mock foi chamado exatamente uma vez e que essa chamada foi "
"feita com os argumentos especificados."

#: ../../library/unittest.mock.rst:346
msgid "assert the mock has been called with the specified arguments."
msgstr "afirma que o mock foi chamado com os argumentos especificados."

#: ../../library/unittest.mock.rst:348
msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""
"A afirmação passa se o mock já *alguma vez* foi chamado, ao contrário de :"
"meth:`assert_called_with` e :meth:`assert_called_once_with` que só passam se "
"a chamada for a mais recente, e no caso de :meth:`assert_called_once_with` "
"também deve ser a única chamada."

#: ../../library/unittest.mock.rst:361
msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr ""
"afirma que o mock foi chamado com as chamadas especificadas. A lista :attr:"
"`mock_calls` é verificada para as chamadas."

#: ../../library/unittest.mock.rst:364
msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr ""
"Se *any_order* for falso, então as chamadas devem ser sequenciais. Pode "
"haver chamadas extra antes ou depois das chamadas especificadas."

#: ../../library/unittest.mock.rst:368
msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr ""
"Se *any_order* for verdadeiro, então as chamadas podem estar em qualquer "
"ordem, mas devem todas aparecer em :attr:`mock_calls`."

#: ../../library/unittest.mock.rst:383
msgid "Assert the mock was never called."
msgstr "Afirma que o mock nunca foi chamado."

#: ../../library/unittest.mock.rst:398
msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr ""
"O método reset_mock redefine todos os atributos de chamada num objeto mock:"

#: ../../library/unittest.mock.rst:400
msgid ""
">>> mock = Mock(return_value=None)\n"
">>> mock('hello')\n"
">>> mock.called\n"
"True\n"
">>> mock.reset_mock()\n"
">>> mock.called\n"
"False"
msgstr ""
">>> mock = Mock(return_value=None)\n"
">>> mock('olá')\n"
">>> mock.called\n"
"True\n"
">>> mock.reset_mock()\n"
">>> mock.called\n"
"False"

#: ../../library/unittest.mock.rst:410
msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object."
msgstr ""
"Isto pode ser útil quando quer fazer uma série de afirmações que reutilizam "
"o mesmo objeto."

#: ../../library/unittest.mock.rst:413
msgid ""
"*return_value* parameter when set to ``True`` resets :attr:`return_value`:"
msgstr ""
"O parâmetro *return_value* quando definido como ``True`` redefine :attr:"
"`return_value`:"

#: ../../library/unittest.mock.rst:415
msgid ""
">>> mock = Mock(return_value=5)\n"
">>> mock('hello')\n"
"5\n"
">>> mock.reset_mock(return_value=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""
">>> mock = Mock(return_value=5)\n"
">>> mock('olá')\n"
"5\n"
">>> mock.reset_mock(return_value=True)\n"
">>> mock('olá')\n"
"<Mock name='mock()' id='...'>"

#: ../../library/unittest.mock.rst:424
msgid ""
"*side_effect* parameter when set to ``True`` resets :attr:`side_effect`:"
msgstr ""
"O parâmetro *side_effect* quando definido como ``True`` redefine :attr:"
"`side_effect`:"

#: ../../library/unittest.mock.rst:426
msgid ""
">>> mock = Mock(side_effect=ValueError)\n"
">>> mock('hello')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError\n"
">>> mock.reset_mock(side_effect=True)\n"
">>> mock('hello')\n"
"<Mock name='mock()' id='...'>"
msgstr ""
">>> mock = Mock(side_effect=ValueError)\n"
">>> mock('olá')\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError\n"
">>> mock.reset_mock(side_effect=True)\n"
">>> mock('olá')\n"
"<Mock name='mock()' id='...'>"

#: ../../library/unittest.mock.rst:437
msgid ""
"Note that :meth:`reset_mock` *doesn't* clear the :attr:`return_value`, :attr:"
"`side_effect` or any child attributes you have set using normal assignment "
"by default."
msgstr ""
"Note que :meth:`reset_mock` *não* limpa o :attr:`return_value`, :attr:"
"`side_effect` ou quaisquer atributos filhos que tenha definido usando "
"atribuição normal por predefinição."

#: ../../library/unittest.mock.rst:441
msgid "Child mocks are reset as well."
msgstr "Os mocks filhos também são redefinidos."

#: ../../library/unittest.mock.rst:443
msgid "Added two keyword-only arguments to the reset_mock function."
msgstr ""
"Adicionados dois argumentos apenas de palavra-chave à função reset_mock."

#: ../../library/unittest.mock.rst:448
msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr ""
"Adiciona uma especificação a um mock. *spec* pode ser um objeto ou uma lista "
"de strings. Apenas atributos em *spec* podem ser obtidos como atributos do "
"mock."

#: ../../library/unittest.mock.rst:452
msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr ""
"Se *spec_set* for verdadeiro, então apenas atributos no spec podem ser "
"definidos."

#: ../../library/unittest.mock.rst:457
msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"Anexa um mock como um atributo deste, substituindo o seu nome e pai. "
"Chamadas para o mock anexado serão registadas nos atributos :attr:"
"`method_calls` e :attr:`mock_calls` deste."

#: ../../library/unittest.mock.rst:464
msgid "Set attributes on the mock through keyword arguments."
msgstr "Define atributos no mock através de argumentos de palavra-chave."

#: ../../library/unittest.mock.rst:466
msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr ""
"Atributos, valores de retorno e efeitos secundários podem ser definidos em "
"mocks filhos usando notação de ponto padrão e desempacotando um dicionário "
"na chamada do método:"

#: ../../library/unittest.mock.rst:480
msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "A mesma coisa pode ser alcançada na chamada do construtor para mocks:"

#: ../../library/unittest.mock.rst:493
msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ""
":meth:`configure_mock` existe para facilitar a configuração após a criação "
"do mock."

#: ../../library/unittest.mock.rst:499
msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
"Os objetos :class:`Mock` limitam os resultados de ``dir(some_mock)`` a "
"resultados úteis. Para mocks com um *spec*, isto inclui todos os atributos "
"permitidos para o mock."

#: ../../library/unittest.mock.rst:503
msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr ""
"Veja :data:`FILTER_DIR` para saber o que esta filtragem faz e como desativá-"
"la."

#: ../../library/unittest.mock.rst:509
msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"Cria os mocks filhos para atributos e valor de retorno. Por predefinição, os "
"mocks filhos serão do mesmo tipo que o pai. Subclasses de Mock podem querer "
"substituir isto para personalizar a forma como os mocks filhos são criados."

#: ../../library/unittest.mock.rst:514
msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr ""
"Para mocks não chamáveis, a variante chamável será usada (em vez de qualquer "
"subclasse personalizada)."

#: ../../library/unittest.mock.rst:520
msgid "A boolean representing whether or not the mock object has been called:"
msgstr "Um booleano que representa se o objeto mock foi chamado ou não:"

#: ../../library/unittest.mock.rst:531
msgid "An integer telling you how many times the mock object has been called:"
msgstr "Um inteiro que indica quantas vezes o objeto mock foi chamado:"

#: ../../library/unittest.mock.rst:543
msgid "Set this to configure the value returned by calling the mock:"
msgstr "Defina isto para configurar o valor devolvido ao chamar o mock:"

#: ../../library/unittest.mock.rst:550
msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr ""
"O valor de retorno predefinido é um objeto mock e pode configurá-lo da forma "
"habitual:"

#: ../../library/unittest.mock.rst:559
msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` também pode ser definido no construtor:"

#: ../../library/unittest.mock.rst:570
msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"Isto pode ser uma função a ser chamada quando o mock é chamado, um iterável "
"ou uma exceção (classe ou instância) a ser lançada."

#: ../../library/unittest.mock.rst:573
msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"Se passar uma função, esta será chamada com os mesmos argumentos que o mock "
"e, a menos que a função retorne o singleton :data:`DEFAULT`, a chamada ao "
"mock retornará o que a função retornar. Se a função retornar :data:"
"`DEFAULT`, então o mock retornará o seu valor normal (de :attr:"
"`return_value`)."

#: ../../library/unittest.mock.rst:579
msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"Se passar um iterável, este é usado para obter um iterador que deve produzir "
"um valor em cada chamada. Este valor pode ser uma instância de exceção a ser "
"lançada ou um valor a ser devolvido da chamada ao mock (o tratamento de :"
"data:`DEFAULT` é idêntico ao caso da função)."

#: ../../library/unittest.mock.rst:584
msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr ""
"Um exemplo de um mock que lança uma exceção (para testar o tratamento de "
"exceções de uma API):"

#: ../../library/unittest.mock.rst:594
msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr "Usar :attr:`side_effect` para devolver uma sequência de valores:"

#: ../../library/unittest.mock.rst:601
msgid "Using a callable:"
msgstr "Usar um chamável:"

#: ../../library/unittest.mock.rst:611
msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ""
":attr:`side_effect` pode ser definido no construtor. Aqui está um exemplo "
"que adiciona um ao valor com que o mock é chamado e o devolve:"

#: ../../library/unittest.mock.rst:621
msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "Definir :attr:`side_effect` para ``None`` limpa-o:"

#: ../../library/unittest.mock.rst:635
msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""

#: ../../library/unittest.mock.rst:668
msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args`, juntamente com membros das listas :attr:"
"`call_args_list`, :attr:`method_calls` e :attr:`mock_calls` são objetos :"
"data:`call`. Estes são tuplos, por isso podem ser desempacotados para obter "
"os argumentos individuais e fazer afirmações mais complexas. Veja :ref:"
"`chamadas como tuplos <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:674
msgid "Added ``args`` and ``kwargs`` properties."
msgstr "Adicionadas propriedades ``args`` e ``kwargs``."

#: ../../library/unittest.mock.rst:680
msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"Esta é uma lista de todas as chamadas feitas ao objeto mock em sequência "
"(por isso o comprimento da lista é o número de vezes que foi chamado). Antes "
"de quaisquer chamadas terem sido feitas, é uma lista vazia. O objeto :data:"
"`call` pode ser usado para construir convenientemente listas de chamadas "
"para comparar com :attr:`call_args_list`."

#: ../../library/unittest.mock.rst:696
msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Os membros de :attr:`call_args_list` são objetos :data:`call`. Estes podem "
"ser desempacotados como tuplos para obter os argumentos individuais. Veja :"
"ref:`chamadas como tuplos <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:703
msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr ""
"Além de rastrear chamadas para si mesmos, os mocks também rastreiam chamadas "
"para métodos e atributos, e *seus* métodos e atributos:"

#: ../../library/unittest.mock.rst:714
msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Os membros de :attr:`method_calls` são objetos :data:`call`. Estes podem ser "
"desempacotados como tuplos para obter os argumentos individuais. Veja :ref:"
"`chamadas como tuplos <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:721
msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls` regista *todas* as chamadas para o objeto mock, os seus "
"métodos, métodos mágicos *e* mocks de valor de retorno."

#: ../../library/unittest.mock.rst:739
msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Os membros de :attr:`mock_calls` são objetos :data:`call`. Estes podem ser "
"desempacotados como tuplos para obter os argumentos individuais. Veja :ref:"
"`chamadas como tuplos <calls-as-tuples>`."

#: ../../library/unittest.mock.rst:745
msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ""
"A forma como :attr:`mock_calls` são registados significa que, onde são "
"feitas chamadas aninhadas, os parâmetros das chamadas ancestrais não são "
"registados e, por isso, sempre compararão como iguais:"

#: ../../library/unittest.mock.rst:759
msgid ""
"Normally the :attr:`!__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`!spec`, :attr:`!__class__` returns the spec "
"class instead. This allows mock objects to pass :func:`isinstance` tests for "
"the object they are replacing / masquerading as:"
msgstr ""
"Normalmente, o atributo :attr:`!__class__` de um objeto devolve o seu tipo. "
"Para um objeto mock com um :attr:`!spec`, :attr:`!__class__` devolve a "
"classe spec em vez disso. Isto permite que os objetos mock passem nos "
"testes :func:`isinstance` para o objeto que estão a substituir/encobrir:"

#: ../../library/unittest.mock.rst:768
msgid ""
":attr:`!__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`!__class__` pode ser atribuído, isto permite que um mock passe numa "
"verificação :func:`isinstance` sem o forçar a usar um spec:"

#: ../../library/unittest.mock.rst:778
msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"Uma versão não chamável de :class:`Mock`. Os parâmetros do construtor têm o "
"mesmo significado de :class:`Mock`, com exceção de *return_value* e "
"*side_effect* que não têm significado num mock não chamável."

#: ../../library/unittest.mock.rst:782
msgid ""
"Mock objects that use a class or an instance as a :attr:`!spec` or :attr:`!"
"spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"Objetos mock que usam uma classe ou uma instância como :attr:`!spec` ou :"
"attr:`!spec_set` são capazes de passar testes :func:`isinstance`:"

#: ../../library/unittest.mock.rst:792
msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
"As classes :class:`Mock` têm suporte para simular métodos mágicos. Veja :ref:"
"`métodos mágicos <magic-methods>` para mais detalhes."

#: ../../library/unittest.mock.rst:795
msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"As classes mock e os decoradores :func:`patch` aceitam todos argumentos de "
"palavra-chave arbitrários para configuração. Para os decoradores :func:"
"`patch`, as palavras-chave são passadas para o construtor do mock que está a "
"ser criado. Os argumentos de palavra-chave são para configurar atributos do "
"mock:"

#: ../../library/unittest.mock.rst:806
msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"O valor de retorno e o efeito secundário de mocks filhos podem ser definidos "
"da mesma forma, usando notação com pontos. Como não pode usar nomes com "
"pontos diretamente numa chamada, tem de criar um dicionário e desempacotá-lo "
"usando ``**``:"

#: ../../library/unittest.mock.rst:821
msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"Um mock chamável que foi criado com um *spec* (ou um *spec_set*) irá "
"introspecionar a assinatura do objeto de especificação ao corresponder "
"chamadas para o mock. Portanto, pode corresponder aos argumentos da chamada "
"real independentemente de terem sido passados posicionalmente ou por nome::"

#: ../../library/unittest.mock.rst:826
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, c=3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(1, 2, 3)\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock.rst:834
msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"Isto aplica-se a :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` e :meth:`~Mock."
"assert_any_call`. Quando :ref:`auto-speccing`, também se aplicará a chamadas "
"de métodos no objeto mock."

#: ../../library/unittest.mock.rst:839
msgid "Added signature introspection on specced and autospecced mock objects."
msgstr ""
"Adicionada introspeção de assinatura em objetos mock com spec e autospecced."

#: ../../library/unittest.mock.rst:845
msgid ""
"A mock intended to be used as a :class:`property`, or other :term:"
"`descriptor`, on a class. :class:`PropertyMock` provides :meth:`~object."
"__get__` and :meth:`~object.__set__` methods so you can specify a return "
"value when it is fetched."
msgstr ""
"Um mock destinado a ser usado como uma :class:`property`, ou outro :term:"
"`descritor`, numa classe. :class:`PropertyMock` fornece métodos :meth:"
"`~object.__get__` e :meth:`~object.__set__` para que possa especificar um "
"valor de retorno quando é obtido."

#: ../../library/unittest.mock.rst:850
msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"Obter uma instância :class:`PropertyMock` de um objeto chama o mock, sem "
"argumentos. Defini-la chama o mock com o valor a ser definido. ::"

#: ../../library/unittest.mock.rst:853
msgid ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'something'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"
msgstr ""
">>> class Foo:\n"
"...     @property\n"
"...     def foo(self):\n"
"...         return 'algo'\n"
"...     @foo.setter\n"
"...     def foo(self, value):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Foo.foo', new_callable=PropertyMock) as mock_foo:\n"
"...     mock_foo.return_value = 'mockity-mock'\n"
"...     this_foo = Foo()\n"
"...     print(this_foo.foo)\n"
"...     this_foo.foo = 6\n"
"...\n"
"mockity-mock\n"
">>> mock_foo.mock_calls\n"
"[call(), call(6)]"

#: ../../library/unittest.mock.rst:871
msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr ""
"Devido à forma como os atributos mock são armazenados, não pode anexar "
"diretamente um :class:`PropertyMock` a um objeto mock. Em vez disso, pode "
"anexá-lo ao objeto tipo mock::"

#: ../../library/unittest.mock.rst:875
msgid ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"
msgstr ""
">>> m = MagicMock()\n"
">>> p = PropertyMock(return_value=3)\n"
">>> type(m).foo = p\n"
">>> m.foo\n"
"3\n"
">>> p.assert_called_once_with()"

#: ../../library/unittest.mock.rst:884
msgid ""
"If an :exc:`AttributeError` is raised by :class:`PropertyMock`, it will be "
"interpreted as a missing descriptor and :meth:`~object.__getattr__` will be "
"called on the parent mock::"
msgstr ""
"Se um :exc:`AttributeError` for lançado por :class:`PropertyMock`, será "
"interpretado como um descritor em falta e :meth:`~object.__getattr__` será "
"chamado no mock pai::"

#: ../../library/unittest.mock.rst:888
msgid ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"
msgstr ""
">>> m = MagicMock()\n"
">>> no_attribute = PropertyMock(side_effect=AttributeError)\n"
">>> type(m).my_property = no_attribute\n"
">>> m.my_property\n"
"<MagicMock name='mock.my_property' id='140165240345424'>"

#: ../../library/unittest.mock.rst:894
msgid "See :meth:`~object.__getattr__` for details."
msgstr "Veja :meth:`~object.__getattr__` para mais detalhes."

#: ../../library/unittest.mock.rst:899
msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""
"Uma versão assíncrona de :class:`MagicMock`. O objeto :class:`AsyncMock` "
"comportar-se-á de forma a que o objeto seja reconhecido como uma função "
"assíncrona, e o resultado de uma chamada é um objeto aguardável."

#: ../../library/unittest.mock.rst:909
msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"O resultado de ``mock()`` é uma função assíncrona que terá o resultado de "
"``side_effect`` ou ``return_value`` depois de aguardada:"

#: ../../library/unittest.mock.rst:912
msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr ""
"se ``side_effect`` for uma função, a função assíncrona devolverá o resultado "
"dessa função,"

#: ../../library/unittest.mock.rst:914
msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr ""
"se ``side_effect`` for uma exceção, a função assíncrona lançará a exceção,"

#: ../../library/unittest.mock.rst:916
msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"se ``side_effect`` for um iterável, a função assíncrona devolverá o próximo "
"valor do iterável, no entanto, se a sequência de resultados estiver "
"esgotada, ``StopAsyncIteration`` é lançado imediatamente,"

#: ../../library/unittest.mock.rst:919
msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""
"se ``side_effect`` não estiver definido, a função assíncrona devolverá o "
"valor definido por ``return_value``, portanto, por predefinição, a função "
"assíncrona devolve um novo objeto :class:`AsyncMock`."

#: ../../library/unittest.mock.rst:924
msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""
"Definir o *spec* de um :class:`Mock` ou :class:`MagicMock` para uma função "
"assíncrona resultará num objeto corrotina a ser devolvido após a chamada."

#: ../../library/unittest.mock.rst:936
msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""
"Definir o *spec* de um :class:`Mock`, :class:`MagicMock` ou :class:"
"`AsyncMock` para uma classe com funções assíncronas e síncronas detetará "
"automaticamente as funções síncronas e definirá-as como :class:`MagicMock` "
"(se o mock pai for :class:`AsyncMock` ou :class:`MagicMock`) ou :class:"
"`Mock` (se o mock pai for :class:`Mock`). Todas as funções assíncronas "
"serão :class:`AsyncMock`."

#: ../../library/unittest.mock.rst:964
msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr ""
"Afirma que o mock foi aguardado pelo menos uma vez. Note que isto é separado "
"do objeto ter sido chamado, a palavra-chave ``await`` deve ser usada:"

#: ../../library/unittest.mock.rst:983
msgid "Assert that the mock was awaited exactly once."
msgstr "Afirma que o mock foi aguardado exatamente uma vez."

#: ../../library/unittest.mock.rst:999
msgid "Assert that the last await was with the specified arguments."
msgstr "Afirma que a última espera foi com os argumentos especificados."

#: ../../library/unittest.mock.rst:1016
msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr ""
"Afirma que o mock foi aguardado exatamente uma vez e com os argumentos "
"especificados."

#: ../../library/unittest.mock.rst:1033
msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr "Afirma que o mock já foi aguardado com os argumentos especificados."

#: ../../library/unittest.mock.rst:1049
msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr ""
"Afirma que o mock foi aguardado com as chamadas especificadas. A lista :attr:"
"`await_args_list` é verificada para as esperas."

#: ../../library/unittest.mock.rst:1052
msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr ""
"Se *any_order* for falso, então as esperas devem ser sequenciais. Pode haver "
"chamadas extra antes ou depois das esperas especificadas."

#: ../../library/unittest.mock.rst:1056
msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr ""
"Se *any_order* for verdadeiro, então as esperas podem estar em qualquer "
"ordem, mas devem todas aparecer em :attr:`await_args_list`."

#: ../../library/unittest.mock.rst:1076
msgid "Assert that the mock was never awaited."
msgstr "Afirma que o mock nunca foi aguardado."

#: ../../library/unittest.mock.rst:1083
msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"Veja :func:`Mock.reset_mock`. Também define :attr:`await_count` para 0, :"
"attr:`await_args` para None e limpa :attr:`await_args_list`."

#: ../../library/unittest.mock.rst:1088
msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr "Um inteiro que regista quantas vezes o objeto mock foi aguardado."

#: ../../library/unittest.mock.rst:1103
msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr ""
"Isto é ``None`` (se o mock não foi aguardado), ou os argumentos com que o "
"mock foi aguardado pela última vez. Funciona da mesma forma que :attr:`Mock."
"call_args`."

#: ../../library/unittest.mock.rst:1121
msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr ""
"Esta é uma lista de todas as esperas feitas ao objeto mock em sequência (por "
"isso o comprimento da lista é o número de vezes que foi aguardado). Antes de "
"quaisquer esperas terem sido feitas, é uma lista vazia."

#: ../../library/unittest.mock.rst:1140
msgid "Calling"
msgstr "Chamada"

#: ../../library/unittest.mock.rst:1142
msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"Os objetos Mock são chamáveis. A chamada devolverá o valor definido como o "
"atributo :attr:`~Mock.return_value`. O valor de retorno predefinido é um "
"novo objeto Mock; é criado na primeira vez que o valor de retorno é acedido "
"(seja explicitamente ou chamando o Mock) - mas é armazenado e o mesmo é "
"devolvido cada vez."

#: ../../library/unittest.mock.rst:1148
msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"As chamadas feitas ao objeto serão registadas nos atributos como :attr:"
"`~Mock.call_args` e :attr:`~Mock.call_args_list`."

#: ../../library/unittest.mock.rst:1151
msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`!side_effect` raises an exception the call "
"is still recorded."
msgstr ""
"Se :attr:`~Mock.side_effect` estiver definido, será chamado após a chamada "
"ter sido registada, por isso, se :attr:`!side_effect` lançar uma exceção, a "
"chamada ainda é registada."

#: ../../library/unittest.mock.rst:1155
msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"A forma mais simples de fazer com que um mock lance uma exceção quando "
"chamado é tornar :attr:`~Mock.side_effect` uma classe de exceção ou "
"instância:"

#: ../../library/unittest.mock.rst:1173
msgid ""
"If :attr:`~Mock.side_effect` is a function then whatever that function "
"returns is what calls to the mock return. The :attr:`!side_effect` function "
"is called with the same arguments as the mock. This allows you to vary the "
"return value of the call dynamically, based on the input:"
msgstr ""
"Se :attr:`~Mock.side_effect` for uma função, então o que essa função "
"devolver será o que as chamadas ao mock devolvem. A função :attr:`!"
"side_effect` é chamada com os mesmos argumentos que o mock. Isto permite-lhe "
"variar o valor de retorno da chamada dinamicamente, com base na entrada:"

#: ../../library/unittest.mock.rst:1189
msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`~Mock.return_value` from inside :attr:`~Mock.side_effect`, or "
"return :data:`DEFAULT`:"
msgstr ""
"Se quiser que o mock ainda devolva o valor de retorno predefinido (um novo "
"mock), ou qualquer valor de retorno definido, então há duas formas de o "
"fazer. Ou devolve :attr:`~Mock.return_value` a partir de dentro de :attr:"
"`~Mock.side_effect`, ou devolve :data:`DEFAULT`:"

#: ../../library/unittest.mock.rst:1208
msgid ""
"To remove a :attr:`~Mock.side_effect`, and return to the default behaviour, "
"set the :attr:`!side_effect` to ``None``:"
msgstr ""
"Para remover um :attr:`~Mock.side_effect` e voltar ao comportamento "
"predefinido, defina o :attr:`!side_effect` para ``None``:"

#: ../../library/unittest.mock.rst:1222
msgid ""
"The :attr:`~Mock.side_effect` can also be any iterable object. Repeated "
"calls to the mock will return values from the iterable (until the iterable "
"is exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
"O :attr:`~Mock.side_effect` também pode ser qualquer objeto iterável. "
"Chamadas repetidas ao mock devolverão valores do iterável (até que o "
"iterável esteja esgotado e seja lançada uma :exc:`StopIteration`):"

#: ../../library/unittest.mock.rst:1238
msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr ""
"Se algum dos membros do iterável forem exceções, serão lançadas em vez de "
"devolvidas::"

#: ../../library/unittest.mock.rst:1241
msgid ""
">>> iterable = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iterable)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"
msgstr ""
">>> iteravel = (33, ValueError, 66)\n"
">>> m = MagicMock(side_effect=iteravel)\n"
">>> m()\n"
"33\n"
">>> m()\n"
"Traceback (most recent call last):\n"
" ...\n"
"ValueError\n"
">>> m()\n"
"66"

#: ../../library/unittest.mock.rst:1256
msgid "Deleting Attributes"
msgstr "Eliminar Atributos"

#: ../../library/unittest.mock.rst:1258
msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr ""
"Os objetos Mock criam atributos conforme necessário. Isto permite-lhes "
"fingir ser objetos de qualquer tipo."

#: ../../library/unittest.mock.rst:1261
msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`!spec` for a mock, but that isn't always "
"convenient."
msgstr ""
"Pode querer que um objeto mock devolva ``False`` a uma chamada :func:"
"`hasattr`, ou lance um :exc:`AttributeError` quando um atributo é obtido. "
"Pode fazer isto fornecendo um objeto como um :attr:`!spec` para um mock, mas "
"isso nem sempre é conveniente."

#: ../../library/unittest.mock.rst:1265
msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"Pode \"bloquear\" atributos eliminando-os. Uma vez eliminados, aceder a um "
"atributo lançará um :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:1282
msgid "Mock names and the name attribute"
msgstr "Nomes de Mock e o atributo name"

#: ../../library/unittest.mock.rst:1284
msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"Como \"name\" é um argumento para o construtor :class:`Mock`, se quiser que "
"o seu objeto mock tenha um atributo \"name\", não pode simplesmente passá-lo "
"no momento da criação. Há duas alternativas. Uma opção é usar :meth:`~Mock."
"configure_mock`::"

#: ../../library/unittest.mock.rst:1289
msgid ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='my_name')\n"
">>> mock.name\n"
"'my_name'"
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.configure_mock(name='meu_nome')\n"
">>> mock.name\n"
"'meu_nome'"

#: ../../library/unittest.mock.rst:1294
msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr ""
"Uma opção mais simples é simplesmente definir o atributo \"name\" após a "
"criação do mock::"

#: ../../library/unittest.mock.rst:1296
msgid ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""
msgstr ""
">>> mock = MagicMock()\n"
">>> mock.name = \"foo\""

#: ../../library/unittest.mock.rst:1301
msgid "Attaching Mocks as Attributes"
msgstr "Anexar Mocks como Atributos"

#: ../../library/unittest.mock.rst:1303
msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"Quando anexa um mock como um atributo de outro mock (ou como o valor de "
"retorno), este torna-se um \"filho\" desse mock. As chamadas ao filho são "
"registadas nos atributos :attr:`~Mock.method_calls` e :attr:`~Mock."
"mock_calls` do pai. Isto é útil para configurar mocks filhos e depois anexá-"
"los ao pai, ou para anexar mocks a um pai que regista todas as chamadas aos "
"filhos e permite fazer afirmações sobre a ordem das chamadas entre mocks:"

#: ../../library/unittest.mock.rst:1321
msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"A exceção a isto é se o mock tiver um nome. Isto permite-lhe evitar o "
"\"parenting\" se, por alguma razão, não quiser que isso aconteça."

#: ../../library/unittest.mock.rst:1332
msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
"Os mocks criados para si por :func:`patch` recebem automaticamente nomes. "
"Para anexar mocks que têm nomes a um pai, usa o método :meth:`~Mock."
"attach_mock`::"

#: ../../library/unittest.mock.rst:1336
msgid ""
">>> thing1 = object()\n"
">>> thing2 = object()\n"
">>> parent = MagicMock()\n"
">>> with patch('__main__.thing1', return_value=None) as child1:\n"
"...     with patch('__main__.thing2', return_value=None) as child2:\n"
"...         parent.attach_mock(child1, 'child1')\n"
"...         parent.attach_mock(child2, 'child2')\n"
"...         child1('one')\n"
"...         child2('two')\n"
"...\n"
">>> parent.mock_calls\n"
"[call.child1('one'), call.child2('two')]"
msgstr ""
">>> coisa1 = object()\n"
">>> coisa2 = object()\n"
">>> pai = MagicMock()\n"
">>> with patch('__main__.coisa1', return_value=None) as filho1:\n"
"...     with patch('__main__.coisa2', return_value=None) as filho2:\n"
"...         pai.attach_mock(filho1, 'filho1')\n"
"...         pai.attach_mock(filho2, 'filho2')\n"
"...         filho1('um')\n"
"...         filho2('dois')\n"
"...\n"
">>> pai.mock_calls\n"
"[call.filho1('um'), call.filho2('dois')]"

#: ../../library/unittest.mock.rst:1350
msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"As únicas exceções são os métodos mágicos e atributos (aqueles que têm "
"duplos sublinhados no início e no fim). Mock não cria estes, mas em vez "
"disso lança um :exc:`AttributeError`. Isto porque o interpretador muitas "
"vezes solicita implicitamente estes métodos e fica *muito* confuso ao "
"receber um novo objeto Mock quando espera um método mágico. Se precisar de "
"suporte para métodos mágicos, veja :ref:`métodos mágicos <magic-methods>`."

#: ../../library/unittest.mock.rst:1359
msgid "The patchers"
msgstr "Os patchers"

#: ../../library/unittest.mock.rst:1361
msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"Os decoradores patch são usados para substituir objetos apenas dentro do "
"âmbito da função que decoram. Eles tratam automaticamente da remoção da "
"substituição para si, mesmo que sejam lançadas exceções. Todas estas funções "
"também podem ser usadas em declarações with ou como decoradores de classe."

#: ../../library/unittest.mock.rst:1368
msgid "patch"
msgstr "patch"

#: ../../library/unittest.mock.rst:1372
msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr ""
"A chave é fazer a substituição no espaço de nomes correto. Veja a secção "
"`onde substituir`_."

#: ../../library/unittest.mock.rst:1376
msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` atua como um decorador de função, decorador de classe ou um "
"gestor de contexto. Dentro do corpo da função ou da declaração with, o "
"*target* é substituído com um objeto *new*. Quando a função/declaração with "
"termina, a substituição é desfeita."

#: ../../library/unittest.mock.rst:1381
msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"Se *new* for omitido, então o alvo é substituído por um :class:`AsyncMock` "
"se o objeto substituído for uma função assíncrona ou um :class:`MagicMock` "
"caso contrário. Se :func:`patch` for usado como um decorador e *new* for "
"omitido, o mock criado é passado como um argumento extra para a função "
"decorada. Se :func:`patch` for usado como um gestor de contexto, o mock "
"criado é devolvido pelo gestor de contexto."

#: ../../library/unittest.mock.rst:1389
msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*target* deve ser uma string na forma ``'package.module.ClassName'``. O "
"*target* é importado e o objeto especificado é substituído pelo objeto "
"*new*, por isso o *target* deve ser importável a partir do ambiente de onde "
"está a chamar :func:`patch`. O alvo é importado quando a função decorada é "
"executada, não no momento da decoração."

#: ../../library/unittest.mock.rst:1395
msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr ""
"Os argumentos de palavra-chave *spec* e *spec_set* são passados para o :"
"class:`MagicMock` se o patch estiver a criar um para si."

#: ../../library/unittest.mock.rst:1398
msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"Além disso, pode passar ``spec=True`` ou ``spec_set=True``, o que faz com "
"que o patch passe o objeto a ser simulado como o objeto spec/spec_set."

#: ../../library/unittest.mock.rst:1401
msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""
"*new_callable* permite-lhe especificar uma classe diferente, ou um objeto "
"chamável, que será chamado para criar o objeto *new*. Por predefinição, :"
"class:`AsyncMock` é usado para funções assíncronas e :class:`MagicMock` para "
"o resto."

#: ../../library/unittest.mock.rst:1405
msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"Uma forma mais poderosa de *spec* é *autospec*. Se definir "
"``autospec=True``, então o mock será criado com um spec do objeto a ser "
"substituído. Todos os atributos do mock também terão o spec do atributo "
"correspondente do objeto a ser substituído. Métodos e funções a serem "
"simulados terão os seus argumentos verificados e lançarão um :exc:"
"`TypeError` se forem chamados com a assinatura errada. Para mocks que "
"substituem uma classe, o seu valor de retorno (a 'instância') terá o mesmo "
"spec que a classe. Veja a função :func:`create_autospec` e :ref:`auto-"
"speccing`."

#: ../../library/unittest.mock.rst:1415
msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"Em vez de ``autospec=True``, pode passar ``autospec=some_object`` para usar "
"um objeto arbitrário como o spec em vez do que está a ser substituído."

#: ../../library/unittest.mock.rst:1418
msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"Por predefinição, :func:`patch` falhará ao substituir atributos que não "
"existem. Se passar ``create=True`` e o atributo não existir, o patch criará "
"o atributo para si quando a função substituída for chamada e eliminá-lo-á "
"novamente após a função substituída ter terminado. Isto é útil para escrever "
"testes contra atributos que o seu código de produção cria em tempo de "
"execução. Está desativado por predefinição porque pode ser perigoso. Com "
"isto ativado, pode escrever testes que passam contra APIs que não existem "
"realmente!"

#: ../../library/unittest.mock.rst:1428
msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr ""
"Se estiver a substituir builtins num módulo, não precisa de passar "
"``create=True``, será adicionado por predefinição."

#: ../../library/unittest.mock.rst:1432
msgid ""
"Patch can be used as a :class:`~unittest.TestCase` class decorator. It works "
"by decorating each test method in the class. This reduces the boilerplate "
"code when your test methods share a common patchings set. :func:`patch` "
"finds tests by looking for method names that start with ``patch."
"TEST_PREFIX``. By default this is ``'test'``, which matches the way :mod:"
"`unittest` finds tests. You can specify an alternative prefix by setting "
"``patch.TEST_PREFIX``."
msgstr ""
"Patch pode ser usado como um decorador de classe :class:`~unittest."
"TestCase`. Funciona decorando cada método de teste na classe. Isto reduz o "
"código repetitivo quando os seus métodos de teste partilham um conjunto "
"comum de substituições. :func:`patch` encontra testes procurando nomes de "
"métodos que comecem com ``patch.TEST_PREFIX``. Por predefinição, isto é "
"``'test'``, o que corresponde à forma como :mod:`unittest` encontra testes. "
"Pode especificar um prefixo alternativo definindo ``patch.TEST_PREFIX``."

#: ../../library/unittest.mock.rst:1439
msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"Patch pode ser usado como um gestor de contexto, com a declaração with. "
"Aqui, a substituição aplica-se ao bloco indentado após a declaração with. Se "
"usar \"as\", então o objeto substituído será ligado ao nome após o \"as\"; "
"muito útil se :func:`patch` estiver a criar um objeto mock para si."

#: ../../library/unittest.mock.rst:1444
msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` aceita argumentos de palavra-chave arbitrários. Estes serão "
"passados para :class:`AsyncMock` se o objeto substituído for assíncrono, "
"para :class:`MagicMock` caso contrário, ou para *new_callable* se "
"especificado."

#: ../../library/unittest.mock.rst:1448
msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``, ``patch.multiple(...)`` e ``patch.object(...)`` estão "
"disponíveis para casos de uso alternativos."

#: ../../library/unittest.mock.rst:1451
msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ""
":func:`patch` como decorador de função, criando o mock para si e passando-o "
"para a função decorada::"

#: ../../library/unittest.mock.rst:1454
msgid ""
">>> @patch('__main__.SomeClass')\n"
"... def function(normal_argument, mock_class):\n"
"...     print(mock_class is SomeClass)\n"
"...\n"
">>> function(None)\n"
"True"
msgstr ""
">>> @patch('__main__.AlgumaClasse')\n"
"... def funcao(argumento_normal, mock_classe):\n"
"...     print(mock_classe is AlgumaClasse)\n"
"...\n"
">>> funcao(None)\n"
"True"

#: ../../library/unittest.mock.rst:1461
msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"Substituir uma classe substitui a classe por uma *instância* :class:"
"`MagicMock`. Se a classe for instanciada no código em teste, então será o :"
"attr:`~Mock.return_value` do mock que será usado."

#: ../../library/unittest.mock.rst:1465
msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"Se a classe for instanciada várias vezes, pode usar :attr:`~Mock."
"side_effect` para devolver um novo mock cada vez. Alternativamente, pode "
"definir o *return_value* para ser qualquer coisa que quiser."

#: ../../library/unittest.mock.rst:1469
msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`~Mock.return_value`. For example::"
msgstr ""
"Para configurar valores de retorno em métodos de *instâncias* na classe "
"substituída, deve fazê-lo no :attr:`~Mock.return_value`. Por exemplo::"

#: ../../library/unittest.mock.rst:1472
msgid ""
">>> class Class:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Class') as MockClass:\n"
"...     instance = MockClass.return_value\n"
"...     instance.method.return_value = 'foo'\n"
"...     assert Class() is instance\n"
"...     assert Class().method() == 'foo'\n"
"..."
msgstr ""
">>> class Classe:\n"
"...     def metodo(self):\n"
"...         pass\n"
"...\n"
">>> with patch('__main__.Classe') as MockClasse:\n"
"...     instancia = MockClasse.return_value\n"
"...     instancia.metodo.return_value = 'foo'\n"
"...     assert Classe() is instancia\n"
"...     assert Classe().metodo() == 'foo'\n"
"..."

#: ../../library/unittest.mock.rst:1483
msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"Se usar *spec* ou *spec_set* e :func:`patch` estiver a substituir uma "
"*classe*, então o valor de retorno do mock criado terá o mesmo spec. ::"

#: ../../library/unittest.mock.rst:1486
msgid ""
">>> Original = Class\n"
">>> patcher = patch('__main__.Class', spec=True)\n"
">>> MockClass = patcher.start()\n"
">>> instance = MockClass()\n"
">>> assert isinstance(instance, Original)\n"
">>> patcher.stop()"
msgstr ""
">>> Original = Classe\n"
">>> patcher = patch('__main__.Classe', spec=True)\n"
">>> MockClasse = patcher.start()\n"
">>> instancia = MockClasse()\n"
">>> assert isinstance(instancia, Original)\n"
">>> patcher.stop()"

#: ../../library/unittest.mock.rst:1493
msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"O argumento *new_callable* é útil quando quer usar uma classe alternativa à :"
"class:`MagicMock` predefinida para o mock criado. Por exemplo, se quiser que "
"seja usado um :class:`NonCallableMock`::"

#: ../../library/unittest.mock.rst:1497
msgid ""
">>> thing = object()\n"
">>> with patch('__main__.thing', new_callable=NonCallableMock) as "
"mock_thing:\n"
"...     assert thing is mock_thing\n"
"...     thing()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: 'NonCallableMock' object is not callable"
msgstr ""
">>> coisa = object()\n"
">>> with patch('__main__.coisa', new_callable=NonCallableMock) as "
"mock_coisa:\n"
"...     assert coisa is mock_coisa\n"
"...     coisa()\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: o objeto 'NonCallableMock' não é chamável"

#: ../../library/unittest.mock.rst:1506
msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr ""
"Outro caso de uso pode ser substituir um objeto por uma instância :class:`io."
"StringIO`::"

#: ../../library/unittest.mock.rst:1508
msgid ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Something')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Something\\n'\n"
"...\n"
">>> test()"
msgstr ""
">>> from io import StringIO\n"
">>> def foo():\n"
"...     print('Algo')\n"
"...\n"
">>> @patch('sys.stdout', new_callable=StringIO)\n"
"... def test(mock_stdout):\n"
"...     foo()\n"
"...     assert mock_stdout.getvalue() == 'Algo\\n'\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:1519
msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"Quando :func:`patch` está a criar um mock para si, é comum que a primeira "
"coisa que precise de fazer seja configurar o mock. Alguma dessa configuração "
"pode ser feita na chamada ao patch. Quaisquer palavras-chave arbitrárias que "
"passar na chamada serão usadas para definir atributos no mock criado::"

#: ../../library/unittest.mock.rst:1524
msgid ""
">>> patcher = patch('__main__.thing', first='one', second='two')\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.first\n"
"'one'\n"
">>> mock_thing.second\n"
"'two'"
msgstr ""
">>> patcher = patch('__main__.coisa', primeiro='um', segundo='dois')\n"
">>> mock_coisa = patcher.start()\n"
">>> mock_coisa.primeiro\n"
"'um'\n"
">>> mock_coisa.segundo\n"
"'dois'"

#: ../../library/unittest.mock.rst:1531
msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"Além de atributos nos atributos do mock criado, como :attr:`~Mock."
"return_value` e :attr:`~Mock.side_effect`, os atributos de mocks filhos "
"também podem ser configurados. Estes não são sintaticamente válidos para "
"passar diretamente como argumentos de palavra-chave, mas um dicionário com "
"estas chaves ainda pode ser expandido numa chamada :func:`patch` usando "
"``**``::"

#: ../../library/unittest.mock.rst:1537
msgid ""
">>> config = {'method.return_value': 3, 'other.side_effect': KeyError}\n"
">>> patcher = patch('__main__.thing', **config)\n"
">>> mock_thing = patcher.start()\n"
">>> mock_thing.method()\n"
"3\n"
">>> mock_thing.other()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"
msgstr ""
">>> config = {'metodo.return_value': 3, 'outro.side_effect': KeyError}\n"
">>> patcher = patch('__main__.coisa', **config)\n"
">>> mock_coisa = patcher.start()\n"
">>> mock_coisa.metodo()\n"
"3\n"
">>> mock_coisa.outro()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError"

#: ../../library/unittest.mock.rst:1547
msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr ""
"Por predefinição, tentar substituir uma função num módulo (ou um método ou "
"atributo numa classe) que não existe falhará com :exc:`AttributeError`::"

#: ../../library/unittest.mock.rst:1550
msgid ""
">>> @patch('sys.non_existing_attribute', 42)\n"
"... def test():\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> does not have the attribute "
"'non_existing_attribute'"
msgstr ""
">>> @patch('sys.atributo_inexistente', 42)\n"
"... def test():\n"
"...     assert sys.atributo_inexistente == 42\n"
"...\n"
">>> test()\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: <module 'sys' (built-in)> não tem o atributo "
"'atributo_inexistente'"

#: ../../library/unittest.mock.rst:1559
msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr ""
"mas adicionar ``create=True`` na chamada a :func:`patch` fará com que o "
"exemplo anterior funcione como esperado::"

#: ../../library/unittest.mock.rst:1562
msgid ""
">>> @patch('sys.non_existing_attribute', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.non_existing_attribute == 42\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('sys.atributo_inexistente', 42, create=True)\n"
"... def test(mock_stdout):\n"
"...     assert sys.atributo_inexistente == 42\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock.rst:1570
msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ""
":func:`patch` agora devolve um :class:`AsyncMock` se o alvo for uma função "
"assíncrona."

#: ../../library/unittest.mock.rst:1574
msgid "patch.object"
msgstr "patch.object"

#: ../../library/unittest.mock.rst:1578
msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr ""
"substitui o membro nomeado (*atributo*) num objeto (*target*) com um objeto "
"mock."

#: ../../library/unittest.mock.rst:1581
msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` pode ser usado como um decorador, decorador de classe "
"ou um gestor de contexto. Os argumentos *new*, *spec*, *create*, *spec_set*, "
"*autospec* e *new_callable* têm o mesmo significado que para :func:`patch`. "
"Tal como :func:`patch`, :func:`patch.object` aceita argumentos de palavra-"
"chave arbitrários para configurar o objeto mock que cria."

#: ../../library/unittest.mock.rst:1587
msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"Quando usado como um decorador de classe, :func:`patch.object` respeita "
"``patch.TEST_PREFIX`` para escolher quais métodos envolver."

#: ../../library/unittest.mock.rst:1590
msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"Pode chamar :func:`patch.object` com três argumentos ou dois argumentos. A "
"forma com três argumentos recebe o objeto a ser substituído, o nome do "
"atributo e o objeto para substituir o atributo."

#: ../../library/unittest.mock.rst:1594
msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr ""
"Ao chamar com a forma de dois argumentos, omite o objeto de substituição e "
"um mock é criado para si e passado como um argumento extra para a função "
"decorada:"

#: ../../library/unittest.mock.rst:1605
msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"*spec*, *create* e os outros argumentos para :func:`patch.object` têm o "
"mesmo significado que para :func:`patch`."

#: ../../library/unittest.mock.rst:1610
msgid "patch.dict"
msgstr "patch.dict"

#: ../../library/unittest.mock.rst:1614
msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test."
msgstr ""

#: ../../library/unittest.mock.rst:1617
msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr ""
"*in_dict* pode ser um dicionário ou um contentor semelhante a um mapeamento. "
"Se for um mapeamento, então deve pelo menos suportar obter, definir e "
"eliminar itens, além de iterar sobre chaves."

#: ../../library/unittest.mock.rst:1621
msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr ""
"*in_dict* também pode ser uma string que especifica o nome do dicionário, "
"que será então obtido importando-o."

#: ../../library/unittest.mock.rst:1624
msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* pode ser um dicionário de valores a definir no dicionário. *values* "
"também pode ser um iterável de pares ``(key, value)``."

#: ../../library/unittest.mock.rst:1627
msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr ""
"Se *clear* for verdadeiro, então o dicionário será limpo antes de os novos "
"valores serem definidos."

#: ../../library/unittest.mock.rst:1630
msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ""
":func:`patch.dict` também pode ser chamado com argumentos de palavra-chave "
"arbitrários para definir valores no dicionário."

#: ../../library/unittest.mock.rst:1635
msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ""
":func:`patch.dict` agora devolve o dicionário substituído quando usado como "
"um gestor de contexto."

#: ../../library/unittest.mock.rst:1638
msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ""
":func:`patch.dict` pode ser usado como um gestor de contexto, decorador ou "
"decorador de classe:"

#: ../../library/unittest.mock.rst:1649
msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""
"Quando usado como um decorador de classe, :func:`patch.dict` respeita "
"``patch.TEST_PREFIX`` (predefinido para ``'test'``) para escolher quais "
"métodos envolver:"

#: ../../library/unittest.mock.rst:1660
msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"Se quiser usar um prefixo diferente para o seu teste, pode informar os "
"patchers do prefixo diferente definindo ``patch.TEST_PREFIX``. Para mais "
"detalhes sobre como alterar o valor, veja :ref:`test-prefix`."

#: ../../library/unittest.mock.rst:1664
msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ""
":func:`patch.dict` pode ser usado para adicionar membros a um dicionário, ou "
"simplesmente permitir que um teste altere um dicionário, e garantir que o "
"dicionário é restaurado quando o teste termina."

#: ../../library/unittest.mock.rst:1685
msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr ""
"Palavras-chave podem ser usadas na chamada :func:`patch.dict` para definir "
"valores no dicionário:"

#: ../../library/unittest.mock.rst:1695
msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` and either :meth:`~container."
"__iter__` or :meth:`~object.__contains__`."
msgstr ""
":func:`patch.dict` pode ser usado com objetos semelhantes a dicionários que "
"não são realmente dicionários. No mínimo, devem suportar obtenção, definição "
"e eliminação de itens, e iteração ou teste de pertinência. Isto corresponde "
"aos métodos mágicos :meth:`~object.__getitem__`, :meth:`~object."
"__setitem__`, :meth:`~object.__delitem__` e :meth:`~container.__iter__` ou :"
"meth:`~object.__contains__`."

#: ../../library/unittest.mock.rst:1725
msgid "patch.multiple"
msgstr "patch.multiple"

#: ../../library/unittest.mock.rst:1729
msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr ""
"Realiza várias substituições numa única chamada. Recebe o objeto a ser "
"substituído (seja como um objeto ou uma string para obter o objeto por "
"importação) e argumentos de palavra-chave para as substituições::"

#: ../../library/unittest.mock.rst:1733
msgid ""
"with patch.multiple(settings, FIRST_PATCH='one', SECOND_PATCH='two'):\n"
"    ..."
msgstr ""
"with patch.multiple(definicoes, PRIMEIRA_SUBSTITUICAO='um', "
"SEGUNDA_SUBSTITUICAO='dois'):\n"
"    ..."

#: ../../library/unittest.mock.rst:1736
msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
"Use :data:`DEFAULT` como o valor se quiser que :func:`patch.multiple` crie "
"mocks para si. Neste caso, os mocks criados são passados para uma função "
"decorada por palavra-chave, e um dicionário é devolvido quando :func:`patch."
"multiple` é usado como um gestor de contexto."

#: ../../library/unittest.mock.rst:1741
msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` pode ser usado como um decorador, decorador de classe "
"ou um gestor de contexto. Os argumentos *spec*, *spec_set*, *create*, "
"*autospec* e *new_callable* têm o mesmo significado que para :func:`patch`. "
"Estes argumentos serão aplicados a *todas* as substituições feitas por :func:"
"`patch.multiple`."

#: ../../library/unittest.mock.rst:1746
msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"Quando usado como um decorador de classe, :func:`patch.multiple` respeita "
"``patch.TEST_PREFIX`` para escolher quais métodos envolver."

#: ../../library/unittest.mock.rst:1749
msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"Se quiser que :func:`patch.multiple` crie mocks para si, então pode usar :"
"data:`DEFAULT` como o valor. Se usar :func:`patch.multiple` como um "
"decorador, então os mocks criados são passados para a função decorada por "
"palavra-chave. ::"

#: ../../library/unittest.mock.rst:1753
msgid ""
">>> thing = object()\n"
">>> other = object()\n"
"\n"
">>> @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(thing, other):\n"
"...     assert isinstance(thing, MagicMock)\n"
"...     assert isinstance(other, MagicMock)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> coisa = object()\n"
">>> outro = object()\n"
"\n"
">>> @patch.multiple('__main__', coisa=DEFAULT, outro=DEFAULT)\n"
"... def funcao_teste(coisa, outro):\n"
"...     assert isinstance(coisa, MagicMock)\n"
"...     assert isinstance(outro, MagicMock)\n"
"...\n"
">>> funcao_teste()"

#: ../../library/unittest.mock.rst:1763
msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` pode ser aninhado com outros decoradores ``patch``, "
"mas coloque argumentos passados por palavra-chave *depois* de quaisquer "
"argumentos padrão criados por :func:`patch`::"

#: ../../library/unittest.mock.rst:1766
msgid ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', thing=DEFAULT, other=DEFAULT)\n"
"... def test_function(mock_exit, other, thing):\n"
"...     assert 'other' in repr(other)\n"
"...     assert 'thing' in repr(thing)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> test_function()"
msgstr ""
">>> @patch('sys.exit')\n"
"... @patch.multiple('__main__', coisa=DEFAULT, outro=DEFAULT)\n"
"... def funcao_teste(mock_exit, outro, coisa):\n"
"...     assert 'outro' in repr(outro)\n"
"...     assert 'coisa' in repr(coisa)\n"
"...     assert 'exit' in repr(mock_exit)\n"
"...\n"
">>> funcao_teste()"

#: ../../library/unittest.mock.rst:1775
msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
"Se :func:`patch.multiple` for usado como um gestor de contexto, o valor "
"devolvido pelo gestor de contexto é um dicionário onde os mocks criados são "
"indexados por nome::"

#: ../../library/unittest.mock.rst:1778
msgid ""
">>> with patch.multiple('__main__', thing=DEFAULT, other=DEFAULT) as "
"values:\n"
"...     assert 'other' in repr(values['other'])\n"
"...     assert 'thing' in repr(values['thing'])\n"
"...     assert values['thing'] is thing\n"
"...     assert values['other'] is other\n"
"..."
msgstr ""
">>> with patch.multiple('__main__', coisa=DEFAULT, outro=DEFAULT) as "
"valores:\n"
"...     assert 'outro' in repr(valores['outro'])\n"
"...     assert 'coisa' in repr(valores['coisa'])\n"
"...     assert valores['coisa'] is coisa\n"
"...     assert valores['outro'] is outro\n"
"..."

#: ../../library/unittest.mock.rst:1789
msgid "patch methods: start and stop"
msgstr "métodos patch: start e stop"

#: ../../library/unittest.mock.rst:1791
msgid ""
"All the patchers have :meth:`!start` and :meth:`!stop` methods. These make "
"it simpler to do patching in ``setUp`` methods or where you want to do "
"multiple patches without nesting decorators or with statements."
msgstr ""
"Todos os patchers têm métodos :meth:`!start` e :meth:`!stop`. Estes tornam "
"mais simples fazer substituições em métodos ``setUp`` ou onde quer fazer "
"várias substituições sem aninhar decoradores ou declarações with."

#: ../../library/unittest.mock.rst:1795
msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`!start` to put the patch in place and :meth:`!stop` to undo "
"it."
msgstr ""
"Para os usar, chame :func:`patch`, :func:`patch.object` ou :func:`patch."
"dict` normalmente e mantenha uma referência ao objeto ``patcher`` devolvido. "
"Pode então chamar :meth:`!start` para colocar a substituição em vigor e :"
"meth:`!stop` para desfazê-la."

#: ../../library/unittest.mock.rst:1799
msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ""
"Se estiver a usar :func:`patch` para criar um mock para si, então este será "
"devolvido pela chamada a ``patcher.start``. ::"

#: ../../library/unittest.mock.rst:1802
msgid ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"
msgstr ""
">>> patcher = patch('package.module.ClassName')\n"
">>> from package import module\n"
">>> original = module.ClassName\n"
">>> new_mock = patcher.start()\n"
">>> assert module.ClassName is not original\n"
">>> assert module.ClassName is new_mock\n"
">>> patcher.stop()\n"
">>> assert module.ClassName is original\n"
">>> assert module.ClassName is not new_mock"

#: ../../library/unittest.mock.rst:1813
msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`~unittest.TestCase`::"
msgstr ""
"Um caso de uso típico para isto pode ser fazer várias substituições no "
"método ``setUp`` de um :class:`~unittest.TestCase`::"

#: ../../library/unittest.mock.rst:1816
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Class1')\n"
"...         self.patcher2 = patch('package.module.Class2')\n"
"...         self.MockClass1 = self.patcher1.start()\n"
"...         self.MockClass2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class1 is self.MockClass1\n"
"...         assert package.module.Class2 is self.MockClass2\n"
"...\n"
">>> MyTest('test_something').run()"
msgstr ""
">>> class MeuTeste(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher1 = patch('package.module.Classe1')\n"
"...         self.patcher2 = patch('package.module.Classe2')\n"
"...         self.MockClasse1 = self.patcher1.start()\n"
"...         self.MockClasse2 = self.patcher2.start()\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher1.stop()\n"
"...         self.patcher2.stop()\n"
"...\n"
"...     def test_algo(self):\n"
"...         assert package.module.Classe1 is self.MockClasse1\n"
"...         assert package.module.Classe2 is self.MockClasse2\n"
"...\n"
">>> MeuTeste('test_algo').run()"

#: ../../library/unittest.mock.rst:1835
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Se usar esta técnica, deve garantir que a substituição é \"desfeita\" "
"chamando ``stop``. Isto pode ser mais complicado do que parece, porque se "
"uma exceção for lançada no ``setUp`` então ``tearDown`` não é chamado. :meth:"
"`unittest.TestCase.addCleanup` torna isto mais fácil::"

#: ../../library/unittest.mock.rst:1840
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Class')\n"
"...         self.MockClass = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_something(self):\n"
"...         assert package.module.Class is self.MockClass\n"
"..."
msgstr ""
">>> class MeuTeste(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('package.module.Classe')\n"
"...         self.MockClasse = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...\n"
"...     def test_algo(self):\n"
"...         assert package.module.Classe is self.MockClasse\n"
"..."

#: ../../library/unittest.mock.rst:1850
msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr ""
"Como um bónus adicional, já não precisa de manter uma referência ao objeto "
"``patcher``."

#: ../../library/unittest.mock.rst:1853
msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr ""
"Também é possível parar todas as substituições que foram iniciadas usando :"
"func:`patch.stopall`."

#: ../../library/unittest.mock.rst:1858
msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr ""
"Para todas as substituições ativas. Apenas para substituições iniciadas com "
"``start``."

#: ../../library/unittest.mock.rst:1864
msgid "patch builtins"
msgstr "substituir builtins"

#: ../../library/unittest.mock.rst:1865
msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr ""
"Pode substituir quaisquer builtins dentro de um módulo. O exemplo seguinte "
"substitui a builtin :func:`ord`::"

#: ../../library/unittest.mock.rst:1868
msgid ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"
msgstr ""
">>> @patch('__main__.ord')\n"
"... def test(mock_ord):\n"
"...     mock_ord.return_value = 101\n"
"...     print(ord('c'))\n"
"...\n"
">>> test()\n"
"101"

#: ../../library/unittest.mock.rst:1880
msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

#: ../../library/unittest.mock.rst:1882
msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"Todos os patchers podem ser usados como decoradores de classe. Quando usados "
"desta forma, envolvem cada método de teste na classe. Os patchers reconhecem "
"métodos que começam com ``'test'`` como sendo métodos de teste. Esta é a "
"mesma forma como o :class:`unittest.TestLoader` encontra métodos de teste "
"por predefinição."

#: ../../library/unittest.mock.rst:1887
msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"É possível que queira usar um prefixo diferente para os seus testes. Pode "
"informar os patchers do prefixo diferente definindo ``patch.TEST_PREFIX``::"

#: ../../library/unittest.mock.rst:1890
msgid ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> value = 3\n"
">>>\n"
">>> @patch('__main__.value', 'not three')\n"
"... class Thing:\n"
"...     def foo_one(self):\n"
"...         print(value)\n"
"...     def foo_two(self):\n"
"...         print(value)\n"
"...\n"
">>>\n"
">>> Thing().foo_one()\n"
"not three\n"
">>> Thing().foo_two()\n"
"not three\n"
">>> value\n"
"3"
msgstr ""
">>> patch.TEST_PREFIX = 'foo'\n"
">>> valor = 3\n"
">>>\n"
">>> @patch('__main__.valor', 'não três')\n"
"... class Coisa:\n"
"...     def foo_um(self):\n"
"...         print(valor)\n"
"...     def foo_dois(self):\n"
"...         print(valor)\n"
"...\n"
">>>\n"
">>> Coisa().foo_um()\n"
"não três\n"
">>> Coisa().foo_dois()\n"
"não três\n"
">>> valor\n"
"3"

#: ../../library/unittest.mock.rst:1910
msgid "Nesting Patch Decorators"
msgstr "Aninhar Decoradores Patch"

#: ../../library/unittest.mock.rst:1912
msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr ""
"Se quiser realizar várias substituições, pode simplesmente empilhar os "
"decoradores."

#: ../../library/unittest.mock.rst:1915
msgid "You can stack up multiple patch decorators using this pattern:"
msgstr "Pode empilhar vários decoradores patch usando este padrão:"

#: ../../library/unittest.mock.rst:1931
msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"Note que os decoradores são aplicados de baixo para cima. Esta é a forma "
"padrão como o Python aplica decoradores. A ordem dos mocks criados passados "
"para a sua função de teste corresponde a esta ordem."

#: ../../library/unittest.mock.rst:1939
msgid "Where to patch"
msgstr "Onde substituir"

#: ../../library/unittest.mock.rst:1941
msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` funciona (temporariamente) alterando o objeto para o qual um "
"*nome* aponta por outro. Pode haver muitos nomes a apontar para qualquer "
"objeto individual, por isso, para que a substituição funcione, deve garantir "
"que substitui o nome usado pelo sistema em teste."

#: ../../library/unittest.mock.rst:1946
msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr ""
"O princípio básico é que substitui onde um objeto é *procurado*, o que não é "
"necessariamente o mesmo local onde é definido. Alguns exemplos ajudarão a "
"esclarecer isto."

#: ../../library/unittest.mock.rst:1950
msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr ""
"Imagine que temos um projeto que queremos testar com a seguinte estrutura::"

#: ../../library/unittest.mock.rst:1952
msgid ""
"a.py\n"
"    -> Defines SomeClass\n"
"\n"
"b.py\n"
"    -> from a import SomeClass\n"
"    -> some_function instantiates SomeClass"
msgstr ""
"a.py\n"
"    -> Define AlgumaClasse\n"
"\n"
"b.py\n"
"    -> from a import AlgumaClasse\n"
"    -> alguma_funcao instancia AlgumaClasse"

#: ../../library/unittest.mock.rst:1959
msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do when it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"Agora queremos testar ``some_function``, mas queremos simular ``SomeClass`` "
"usando :func:`patch`. O problema é que quando importamos o módulo b, que "
"teremos de fazer quando este importa ``SomeClass`` do módulo a. Se usarmos :"
"func:`patch` para simular ``a.SomeClass``, não terá efeito no nosso teste; o "
"módulo b já tem uma referência à *verdadeira* ``SomeClass`` e parece que a "
"nossa substituição não teve efeito."

#: ../../library/unittest.mock.rst:1966
msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"A chave é substituir ``SomeClass`` onde é usada (ou onde é procurada). Neste "
"caso, ``some_function`` procurará realmente ``SomeClass`` no módulo b, onde "
"a importámos. A substituição deve ser feita assim::"

#: ../../library/unittest.mock.rst:1970
msgid "@patch('b.SomeClass')"
msgstr "@patch('b.AlgumaClasse')"

#: ../../library/unittest.mock.rst:1972
msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"No entanto, considere o cenário alternativo em que, em vez de ``from a "
"import SomeClass``, o módulo b faz ``import a`` e ``some_function`` usa ``a."
"SomeClass``. Ambas as formas de importação são comuns. Neste caso, a classe "
"que queremos substituir está a ser procurada no módulo e, portanto, temos de "
"substituir ``a.SomeClass`` em vez disso::"

#: ../../library/unittest.mock.rst:1977
msgid "@patch('a.SomeClass')"
msgstr "@patch('a.AlgumaClasse')"

#: ../../library/unittest.mock.rst:1981
msgid "Patching Descriptors and Proxy Objects"
msgstr "Substituir Descritores e Objetos Proxy"

#: ../../library/unittest.mock.rst:1983
msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"Tanto patch_ como patch.object_ substituem e restauram corretamente "
"descritores: métodos de classe, métodos estáticos e propriedades. Deve "
"substituir estes na *classe* em vez de numa instância. Também funcionam com "
"*alguns* objetos que fazem proxy de acesso a atributos, como o `objeto de "
"configurações do django <https://web.archive.org/web/20200603181648/http://"
"www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198>`_."

#: ../../library/unittest.mock.rst:1991
msgid "MagicMock and magic method support"
msgstr "MagicMock e suporte a métodos mágicos"

#: ../../library/unittest.mock.rst:1996
msgid "Mocking Magic Methods"
msgstr "Simular Métodos Mágicos"

#: ../../library/unittest.mock.rst:1998
msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as :"
"term:`\"magic methods\" <magic method>`. This allows mock objects to replace "
"containers or other objects that implement Python protocols."
msgstr ""
":class:`Mock` suporta a simulação dos métodos de protocolo do Python, também "
"conhecidos como :term:`\"métodos mágicos\" <magic method>`. Isto permite que "
"objetos mock substituam contentores ou outros objetos que implementam "
"protocolos Python."

#: ../../library/unittest.mock.rst:2002
msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"Como os métodos mágicos são procurados de forma diferente dos métodos "
"normais [#]_, este suporte foi implementado especialmente. Isto significa "
"que apenas métodos mágicos específicos são suportados. A lista suportada "
"inclui *quase* todos eles. Se faltar algum que precise, por favor informe-"
"nos."

#: ../../library/unittest.mock.rst:2007
msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr ""
"Simula métodos mágicos definindo o método em que está interessado para uma "
"função ou uma instância mock. Se estiver a usar uma função, esta *deve* "
"aceitar ``self`` como o primeiro argumento [#]_."

#: ../../library/unittest.mock.rst:2030
msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr ""
"Um caso de uso para isto é simular objetos usados como gestores de contexto "
"numa declaração :keyword:`with`:"

#: ../../library/unittest.mock.rst:2042
msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"Chamadas a métodos mágicos não aparecem em :attr:`~Mock.method_calls`, mas "
"são registadas em :attr:`~Mock.mock_calls`."

#: ../../library/unittest.mock.rst:2047
msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr ""
"Se usar o argumento de palavra-chave *spec* para criar um mock, então tentar "
"definir um método mágico que não esteja no spec lançará um :exc:"
"`AttributeError`."

#: ../../library/unittest.mock.rst:2050
msgid "The full list of supported magic methods is:"
msgstr "A lista completa de métodos mágicos suportados é:"

#: ../../library/unittest.mock.rst:2052
msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__`` e ``__str__``"

#: ../../library/unittest.mock.rst:2053
msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__`` e ``__subclasses__``"

#: ../../library/unittest.mock.rst:2054
msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``, ``__floor__``, ``__trunc__`` e ``__ceil__``"

#: ../../library/unittest.mock.rst:2055
msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"Comparações: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` e "
"``__ne__``"

#: ../../library/unittest.mock.rst:2057
msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"Métodos de contentor: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` e "
"``__missing__``"

#: ../../library/unittest.mock.rst:2060
msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr ""
"Gestor de contexto: ``__enter__``, ``__exit__``, ``__aenter__`` e "
"``__aexit__``"

#: ../../library/unittest.mock.rst:2061
msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "Métodos numéricos unários: ``__neg__``, ``__pos__`` e ``__invert__``"

#: ../../library/unittest.mock.rst:2062
msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"Os métodos numéricos (incluindo variantes à direita e in-place): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__`` e ``__pow__``"

#: ../../library/unittest.mock.rst:2066
msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr ""
"Métodos de conversão numérica: ``__complex__``, ``__int__``, ``__float__`` e "
"``__index__``"

#: ../../library/unittest.mock.rst:2068
msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "Métodos de descritor: ``__get__``, ``__set__`` e ``__delete__``"

#: ../../library/unittest.mock.rst:2069
msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` e ``__setstate__``"

#: ../../library/unittest.mock.rst:2071
msgid "File system path representation: ``__fspath__``"
msgstr "Representação de caminho do sistema de ficheiros: ``__fspath__``"

#: ../../library/unittest.mock.rst:2072
msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "Métodos de iteração assíncrona: ``__aiter__`` e ``__anext__``"

#: ../../library/unittest.mock.rst:2074
msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "Adicionado suporte para :func:`os.PathLike.__fspath__`."

#: ../../library/unittest.mock.rst:2077
msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"Adicionado suporte para ``__aenter__``, ``__aexit__``, ``__aiter__`` e "
"``__anext__``."

#: ../../library/unittest.mock.rst:2081
msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"Os seguintes métodos existem, mas *não* são suportados, pois estão em uso "
"pelo mock, não podem ser definidos dinamicamente ou podem causar problemas:"

#: ../../library/unittest.mock.rst:2084
msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__`` e ``__new__``"

#: ../../library/unittest.mock.rst:2085
msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"

#: ../../library/unittest.mock.rst:2090
msgid "Magic Mock"
msgstr "Magic Mock"

#: ../../library/unittest.mock.rst:2092
msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"Existem duas variantes de ``MagicMock``: :class:`MagicMock` e :class:"
"`NonCallableMagicMock`."

#: ../../library/unittest.mock.rst:2097
msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the :term:`magic methods <magic method>`. You can use ``MagicMock`` "
"without having to configure the magic methods yourself."
msgstr ""
"``MagicMock`` é uma subclasse de :class:`Mock` com implementações "
"predefinidas da maioria dos :term:`métodos mágicos <magic method>`. Pode "
"usar ``MagicMock`` sem ter de configurar os métodos mágicos manualmente."

#: ../../library/unittest.mock.rst:2101
msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr ""
"Os parâmetros do construtor têm o mesmo significado que para :class:`Mock`."

#: ../../library/unittest.mock.rst:2103
msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr ""
"Se usar os argumentos *spec* ou *spec_set*, então *apenas* os métodos "
"mágicos que existam no spec serão criados."

#: ../../library/unittest.mock.rst:2109
msgid "A non-callable version of :class:`MagicMock`."
msgstr "Uma versão não chamável de :class:`MagicMock`."

#: ../../library/unittest.mock.rst:2111
msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"Os parâmetros do construtor têm o mesmo significado que para :class:"
"`MagicMock`, com exceção de *return_value* e *side_effect*, que não têm "
"significado num mock não chamável."

#: ../../library/unittest.mock.rst:2115
msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr ""
"Os métodos mágicos são configurados com objetos :class:`MagicMock`, por isso "
"pode configurá-los e usá-los da forma habitual:"

#: ../../library/unittest.mock.rst:2125
msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"Por predefinição, muitos dos métodos de protocolo são obrigados a devolver "
"objetos de um tipo específico. Estes métodos são pré-configurados com um "
"valor de retorno predefinido, para que possam ser usados sem que tenha de "
"fazer nada se não estiver interessado no valor de retorno. Ainda pode "
"*definir* o valor de retorno manualmente se quiser alterar o predefinido."

#: ../../library/unittest.mock.rst:2131
msgid "Methods and their defaults:"
msgstr "Métodos e os seus valores predefinidos:"

#: ../../library/unittest.mock.rst:2133
msgid "``__lt__``: :data:`NotImplemented`"
msgstr "``__lt__``: :data:`NotImplemented`"

#: ../../library/unittest.mock.rst:2134
msgid "``__gt__``: :data:`!NotImplemented`"
msgstr "``__gt__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2135
msgid "``__le__``: :data:`!NotImplemented`"
msgstr "``__le__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2136
msgid "``__ge__``: :data:`!NotImplemented`"
msgstr "``__ge__``: :data:`!NotImplemented`"

#: ../../library/unittest.mock.rst:2137
msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

#: ../../library/unittest.mock.rst:2138
msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

#: ../../library/unittest.mock.rst:2139
msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

#: ../../library/unittest.mock.rst:2140
msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

#: ../../library/unittest.mock.rst:2141
msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

#: ../../library/unittest.mock.rst:2142
msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

#: ../../library/unittest.mock.rst:2143
msgid "``__complex__``: ``1j``"
msgstr "``__complex__``: ``1j``"

#: ../../library/unittest.mock.rst:2144
msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1.0``"

#: ../../library/unittest.mock.rst:2145
msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``True``"

#: ../../library/unittest.mock.rst:2146
msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

#: ../../library/unittest.mock.rst:2147
msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: hash predefinido para o mock"

#: ../../library/unittest.mock.rst:2148
msgid "``__str__``: default str for the mock"
msgstr "``__str__``: str predefinido para o mock"

#: ../../library/unittest.mock.rst:2149
msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: sizeof predefinido para o mock"

#: ../../library/unittest.mock.rst:2151
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/unittest.mock.rst:2163
msgid ""
"The two equality methods, :meth:`!__eq__` and :meth:`!__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""
"Os dois métodos de igualdade, :meth:`!__eq__` e :meth:`!__ne__`, são "
"especiais. Eles fazem a comparação de igualdade predefinida com base na "
"identidade, usando o atributo :attr:`~Mock.side_effect`, a menos que altere "
"o seu valor de retorno para devolver outra coisa::"

#: ../../library/unittest.mock.rst:2168
msgid ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"
msgstr ""
">>> MagicMock() == 3\n"
"False\n"
">>> MagicMock() != 3\n"
"True\n"
">>> mock = MagicMock()\n"
">>> mock.__eq__.return_value = True\n"
">>> mock == 3\n"
"True"

#: ../../library/unittest.mock.rst:2177
msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ""
"O valor de retorno de :meth:`MagicMock.__iter__` pode ser qualquer objeto "
"iterável e não é obrigatório ser um iterador:"

#: ../../library/unittest.mock.rst:2187
msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr ""
"Se o valor de retorno *for* um iterador, então iterar sobre ele uma vez irá "
"consumi-lo e iterações subsequentes resultarão numa lista vazia:"

#: ../../library/unittest.mock.rst:2196
msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr ""
"``MagicMock`` tem todos os métodos mágicos suportados configurados, exceto "
"alguns dos mais obscuros e obsoletos. Ainda pode configurar estes se quiser."

#: ../../library/unittest.mock.rst:2199
msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr ""
"Métodos mágicos que são suportados, mas não configurados por predefinição em "
"``MagicMock`` são:"

#: ../../library/unittest.mock.rst:2201
msgid "``__subclasses__``"
msgstr "``__subclasses__``"

#: ../../library/unittest.mock.rst:2202
msgid "``__dir__``"
msgstr "``__dir__``"

#: ../../library/unittest.mock.rst:2203
msgid "``__format__``"
msgstr "``__format__``"

#: ../../library/unittest.mock.rst:2204
msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__`` e ``__delete__``"

#: ../../library/unittest.mock.rst:2205
msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__`` e ``__missing__``"

#: ../../library/unittest.mock.rst:2206
msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` e ``__setstate__``"

#: ../../library/unittest.mock.rst:2208
msgid "``__getformat__``"
msgstr "``__getformat__``"

#: ../../library/unittest.mock.rst:2212
msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"Os métodos mágicos *devem* ser procurados na classe em vez da instância. "
"Diferentes versões do Python são inconsistentes na aplicação desta regra. Os "
"métodos de protocolo suportados devem funcionar com todas as versões "
"suportadas do Python."

#: ../../library/unittest.mock.rst:2216
msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr ""
"A função está basicamente ligada à classe, mas cada instância ``Mock`` é "
"mantida isolada das outras."

#: ../../library/unittest.mock.rst:2221
msgid "Helpers"
msgstr "Auxiliares"

#: ../../library/unittest.mock.rst:2224
msgid "sentinel"
msgstr "sentinela"

#: ../../library/unittest.mock.rst:2228
msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr ""
"O objeto ``sentinel`` fornece uma forma conveniente de fornecer objetos "
"únicos para os seus testes."

#: ../../library/unittest.mock.rst:2231
msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr ""
"Os atributos são criados conforme necessário quando os acede pelo nome. "
"Aceder ao mesmo atributo sempre devolverá o mesmo objeto. Os objetos "
"devolvidos têm uma representação legível para que as mensagens de falha de "
"teste sejam compreensíveis."

#: ../../library/unittest.mock.rst:2235
msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"Os atributos ``sentinel`` agora preservam a sua identidade quando são :mod:"
"`copiados <copy>` ou :mod:`serializados <pickle>`."

#: ../../library/unittest.mock.rst:2239
msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"Às vezes, ao testar, precisa de verificar se um objeto específico é passado "
"como argumento para outro método ou devolvido. Pode ser comum criar objetos "
"sentinela nomeados para testar isto. :data:`sentinel` fornece uma forma "
"conveniente de criar e testar a identidade de objetos como este."

#: ../../library/unittest.mock.rst:2244
msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr ""
"Neste exemplo, fazemos um monkey patch do ``method`` para devolver "
"``sentinel.some_object``:"

#: ../../library/unittest.mock.rst:2256
msgid "DEFAULT"
msgstr "PADRÃO"

#: ../../library/unittest.mock.rst:2261
msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
"O objeto :data:`DEFAULT` é uma sentinela pré-criada (na verdade ``sentinel."
"DEFAULT``). Pode ser usado por funções :attr:`~Mock.side_effect` para "
"indicar que o valor de retorno normal deve ser usado."

#: ../../library/unittest.mock.rst:2267
msgid "call"
msgstr "chamada"

#: ../../library/unittest.mock.rst:2271
msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` é um objeto auxiliar para fazer afirmações mais simples, para "
"comparar com :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:"
"`~Mock.mock_calls` e :attr:`~Mock.method_calls`. :func:`call` também pode "
"ser usado com :meth:`~Mock.assert_has_calls`."

#: ../../library/unittest.mock.rst:2284
msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr ""
"Para um objeto de chamada que representa várias chamadas, :meth:`call_list` "
"devolve uma lista de todas as chamadas intermédias, bem como a chamada final."

#: ../../library/unittest.mock.rst:2288
msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` é particularmente útil para fazer afirmações sobre \"chamadas "
"encadeadas\". Uma chamada encadeada são várias chamadas numa única linha de "
"código. Isto resulta em várias entradas em :attr:`~Mock.mock_calls` num "
"mock. Construir manualmente a sequência de chamadas pode ser tedioso."

#: ../../library/unittest.mock.rst:2293
msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ""
":meth:`~call.call_list` pode construir a sequência de chamadas a partir da "
"mesma chamada encadeada:"

#: ../../library/unittest.mock.rst:2310
msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"Um objeto ``call`` é ou um tuplo de (argumentos posicionais, argumentos de "
"palavra-chave) ou (nome, argumentos posicionais, argumentos de palavra-"
"chave), dependendo de como foi construído. Quando os constrói manualmente, "
"isto não é particularmente interessante, mas os objetos ``call`` que estão "
"nos atributos :attr:`Mock.call_args`, :attr:`Mock.call_args_list` e :attr:"
"`Mock.mock_calls` podem ser introspecionados para obter os argumentos "
"individuais que contêm."

#: ../../library/unittest.mock.rst:2317
msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
"Os objetos ``call`` em :attr:`Mock.call_args` e :attr:`Mock.call_args_list` "
"são duplos de (argumentos posicionais, argumentos de palavra-chave), "
"enquanto os objetos ``call`` em :attr:`Mock.mock_calls`, juntamente com os "
"que constrói, são triplos de (nome, argumentos posicionais, argumentos de "
"palavra-chave)."

#: ../../library/unittest.mock.rst:2322
msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"Pode usar a sua natureza de \"tuplo\" para extrair os argumentos individuais "
"para introspeção e afirmações mais complexas. Os argumentos posicionais são "
"um tuplo (um tuplo vazio se não houver argumentos posicionais) e os "
"argumentos de palavra-chave são um dicionário:"

#: ../../library/unittest.mock.rst:2355
msgid "create_autospec"
msgstr "create_autospec"

#: ../../library/unittest.mock.rst:2359
msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr ""
"Cria um objeto mock usando outro objeto como especificação. Os atributos no "
"mock usarão o atributo correspondente no objeto *spec* como sua "
"especificação."

#: ../../library/unittest.mock.rst:2363
msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr ""
"Funções ou métodos a serem simulados terão os seus argumentos verificados "
"para garantir que são chamados com a assinatura correta."

#: ../../library/unittest.mock.rst:2366
msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"Se *spec_set* for ``True``, então tentar definir atributos que não existam "
"no objeto spec lançará um :exc:`AttributeError`."

#: ../../library/unittest.mock.rst:2369
msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"Se uma classe for usada como especificação, então o valor de retorno do mock "
"(a instância da classe) terá a mesma especificação. Pode usar uma classe "
"como especificação para um objeto de instância passando ``instance=True``. O "
"mock devolvido só será chamável se as instâncias do mock forem chamáveis."

#: ../../library/unittest.mock.rst:2374
msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ""
":func:`create_autospec` também aceita argumentos de palavra-chave "
"arbitrários que são passados para o construtor do mock criado."

#: ../../library/unittest.mock.rst:2377
msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"Veja :ref:`auto-speccing` para exemplos de como usar auto-speccing com :func:"
"`create_autospec` e o argumento *autospec* para :func:`patch`."

#: ../../library/unittest.mock.rst:2383
msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ""
":func:`create_autospec` agora devolve um :class:`AsyncMock` se o alvo for "
"uma função assíncrona."

#: ../../library/unittest.mock.rst:2388
msgid "ANY"
msgstr "QUALQUER"

#: ../../library/unittest.mock.rst:2392
msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"Às vezes, pode precisar de fazer afirmações sobre *alguns* dos argumentos "
"numa chamada a um mock, mas ou não se importa com alguns dos argumentos ou "
"quer extraí-los individualmente de :attr:`~Mock.call_args` e fazer "
"afirmações mais complexas sobre eles."

#: ../../library/unittest.mock.rst:2397
msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"Para ignorar certos argumentos, pode passar objetos que comparam igual a "
"*tudo*. Chamadas a :meth:`~Mock.assert_called_with` e :meth:`~Mock."
"assert_called_once_with` terão sucesso independentemente do que foi passado."

#: ../../library/unittest.mock.rst:2406
msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ""
":data:`ANY` também pode ser usado em comparações com listas de chamadas "
"como :attr:`~Mock.mock_calls`:"

#: ../../library/unittest.mock.rst:2416
msgid ""
":data:`ANY` is not limited to comparisons with call objects and so can also "
"be used in test assertions::"
msgstr ""
":data:`ANY` não está limitado a comparações com objetos de chamada e, "
"portanto, também pode ser usado em afirmações de teste::"

#: ../../library/unittest.mock.rst:2419
msgid ""
"class TestStringMethods(unittest.TestCase):\n"
"\n"
"    def test_split(self):\n"
"        s = 'hello world'\n"
"        self.assertEqual(s.split(), ['hello', ANY])"
msgstr ""
"class TestarMetodosString(unittest.TestCase):\n"
"\n"
"    def testar_dividir(self):\n"
"        s = 'olá mundo'\n"
"        self.assertEqual(s.split(), ['olá', QUALQUER])"

#: ../../library/unittest.mock.rst:2427
msgid "FILTER_DIR"
msgstr "FILTRAR_DIR"

#: ../../library/unittest.mock.rst:2431
msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` é uma variável a nível de módulo que controla a forma "
"como os objetos mock respondem a :func:`dir`. O predefinido é ``True``, que "
"usa a filtragem descrita abaixo, para mostrar apenas membros úteis. Se não "
"gostar desta filtragem ou precisar de a desativar para fins de diagnóstico, "
"defina ``mock.FILTER_DIR = False``."

#: ../../library/unittest.mock.rst:2437
msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"Com a filtragem ativada, ``dir(some_mock)`` mostra apenas atributos úteis e "
"incluirá quaisquer atributos criados dinamicamente que normalmente não "
"seriam mostrados. Se o mock foi criado com um *spec* (ou *autospec*, claro), "
"então todos os atributos do original são mostrados, mesmo que ainda não "
"tenham sido acedidos:"

#: ../../library/unittest.mock.rst:2443
msgid ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."
msgstr ""
">>> dir(Mock())\n"
"['assert_any_call',\n"
" 'assert_called',\n"
" 'assert_called_once',\n"
" 'assert_called_once_with',\n"
" 'assert_called_with',\n"
" 'assert_has_calls',\n"
" 'assert_not_called',\n"
" 'attach_mock',\n"
" ...\n"
">>> from urllib import request\n"
">>> dir(Mock(spec=request))\n"
"['AbstractBasicAuthHandler',\n"
" 'AbstractDigestAuthHandler',\n"
" 'AbstractHTTPHandler',\n"
" 'BaseHandler',\n"
" ..."

#: ../../library/unittest.mock.rst:2464
msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"Muitos dos atributos não muito úteis (privados a :class:`Mock` em vez da "
"coisa a ser simulada) com prefixo de sublinhado e duplo sublinhado foram "
"filtrados do resultado da chamada a :func:`dir` num :class:`Mock`. Se não "
"gostar deste comportamento, pode desativá-lo definindo o interruptor a nível "
"de módulo :data:`FILTER_DIR`:"

#: ../../library/unittest.mock.rst:2470
msgid ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."
msgstr ""
">>> from unittest import mock\n"
">>> mock.FILTER_DIR = False\n"
">>> dir(mock.Mock())\n"
"['_NonCallableMock__get_return_value',\n"
" '_NonCallableMock__get_side_effect',\n"
" '_NonCallableMock__return_value_doc',\n"
" '_NonCallableMock__set_return_value',\n"
" '_NonCallableMock__set_side_effect',\n"
" '__call__',\n"
" '__class__',\n"
" ..."

#: ../../library/unittest.mock.rst:2485
msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :const:`FILTER_DIR`."
msgstr ""
"Alternativamente, pode simplesmente usar ``vars(my_mock)`` (membros da "
"instância) e ``dir(type(my_mock))`` (membros do tipo) para contornar a "
"filtragem independentemente de :const:`FILTER_DIR`."

#: ../../library/unittest.mock.rst:2491
msgid "mock_open"
msgstr "mock_open"

#: ../../library/unittest.mock.rst:2495
msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
"Uma função auxiliar para criar um mock para substituir o uso de :func:"
"`open`. Funciona para :func:`open` chamado diretamente ou usado como um "
"gestor de contexto."

#: ../../library/unittest.mock.rst:2498
msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"O argumento *mock* é o objeto mock a configurar. Se for ``None`` (o "
"predefinido), então um :class:`MagicMock` será criado para si, com a API "
"limitada a métodos ou atributos disponíveis em manipuladores de ficheiros "
"padrão."

#: ../../library/unittest.mock.rst:2502
msgid ""
"*read_data* is a string for the :meth:`~io.RawIOBase.read`, :meth:`~io."
"IOBase.readline`, and :meth:`~io.IOBase.readlines` methods of the file "
"handle to return.  Calls to those methods will take data from *read_data* "
"until it is depleted.  The mock of these methods is pretty simplistic: every "
"time the *mock* is called, the *read_data* is rewound to the start.  If you "
"need more control over the data that you are feeding to the tested code you "
"will need to customize this mock for yourself.  When that is insufficient, "
"one of the in-memory filesystem packages on `PyPI <https://pypi.org>`_ can "
"offer a realistic filesystem for testing."
msgstr ""
"*read_data* é uma string para os métodos :meth:`~io.RawIOBase.read`, :meth:"
"`~io.IOBase.readline` e :meth:`~io.IOBase.readlines` do manipulador de "
"ficheiros devolverem. As chamadas a esses métodos irão obter dados de "
"*read_data* até que este esteja esgotado. O mock destes métodos é bastante "
"simplista: todas as vezes que o *mock* é chamado, o *read_data* é rebobinado "
"para o início. Se precisar de mais controlo sobre os dados que está a "
"fornecer ao código testado, terá de personalizar este mock. Quando isso não "
"for suficiente, um dos pacotes de sistema de ficheiros em memória no `PyPI "
"<https://pypi.org>`_ pode oferecer um sistema de ficheiros realista para "
"testes."

#: ../../library/unittest.mock.rst:2512
msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.RawIOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
"Adicionado suporte para :meth:`~io.IOBase.readline` e :meth:`~io.IOBase."
"readlines`. O mock de :meth:`~io.RawIOBase.read` foi alterado para consumir "
"*read_data* em vez de o devolver em cada chamada."

#: ../../library/unittest.mock.rst:2517
msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data* é agora redefinido em cada chamada ao *mock*."

#: ../../library/unittest.mock.rst:2520
msgid ""
"Added :meth:`~container.__iter__` to implementation so that iteration (such "
"as in for loops) correctly consumes *read_data*."
msgstr ""
"Adicionado :meth:`~container.__iter__` à implementação para que a iteração "
"(como em ciclos for) consuma corretamente *read_data*."

#: ../../library/unittest.mock.rst:2524
msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr ""
"Usar :func:`open` como um gestor de contexto é uma ótima maneira de garantir "
"que os seus manipuladores de ficheiros são fechados corretamente e está a "
"tornar-se comum::"

#: ../../library/unittest.mock.rst:2527
msgid ""
"with open('/some/path', 'w') as f:\n"
"    f.write('something')"
msgstr ""
"with open('/algum/caminho', 'w') as f:\n"
"    f.write('algo')"

#: ../../library/unittest.mock.rst:2530
msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:`~object."
"__enter__` and :meth:`~object.__exit__` called)."
msgstr ""
"O problema é que, mesmo que simule a chamada a :func:`open`, é o *objeto "
"devolvido* que é usado como um gestor de contexto (e tem :meth:`~object."
"__enter__` e :meth:`~object.__exit__` chamados)."

#: ../../library/unittest.mock.rst:2534
msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ""
"Simular gestores de contexto com um :class:`MagicMock` é suficientemente "
"comum e complicado para que uma função auxiliar seja útil. ::"

#: ../../library/unittest.mock.rst:2537
msgid ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('some stuff')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('some stuff'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('some stuff')"
msgstr ""
">>> m = mock_open()\n"
">>> with patch('__main__.open', m):\n"
"...     with open('foo', 'w') as h:\n"
"...         h.write('alguma coisa')\n"
"...\n"
">>> m.mock_calls\n"
"[call('foo', 'w'),\n"
" call().__enter__(),\n"
" call().write('alguma coisa'),\n"
" call().__exit__(None, None, None)]\n"
">>> m.assert_called_once_with('foo', 'w')\n"
">>> handle = m()\n"
">>> handle.write.assert_called_once_with('alguma coisa')"

#: ../../library/unittest.mock.rst:2551
msgid "And for reading files::"
msgstr "E para ler ficheiros::"

#: ../../library/unittest.mock.rst:2553
msgid ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         result = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert result == 'bibble'"
msgstr ""
">>> with patch('__main__.open', mock_open(read_data='bibble')) as m:\n"
"...     with open('foo') as h:\n"
"...         resultado = h.read()\n"
"...\n"
">>> m.assert_called_once_with('foo')\n"
">>> assert resultado == 'bibble'"

#: ../../library/unittest.mock.rst:2564
msgid "Autospeccing"
msgstr "Autospeccing"

#: ../../library/unittest.mock.rst:2566
msgid ""
"Autospeccing is based on the existing :attr:`!spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"Autospeccing é baseado na funcionalidade existente :attr:`!spec` do mock. "
"Limita a API dos mocks à API de um objeto original (o spec), mas é recursivo "
"(implementado de forma preguiçosa) de modo que os atributos dos mocks têm "
"apenas a mesma API que os atributos do spec. Além disso, funções/métodos "
"simulados têm a mesma assinatura de chamada que o original, por isso lançam "
"um :exc:`TypeError` se forem chamados incorretamente."

#: ../../library/unittest.mock.rst:2573
msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr ""
"Antes de explicar como o autospeccing funciona, aqui está o porquê de ser "
"necessário."

#: ../../library/unittest.mock.rst:2575
msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from a "
"flaw which is general to mocking. If you refactor some of your code, rename "
"members and so on, any tests for code that is still using the *old api* but "
"uses mocks instead of the real objects will still pass. This means your "
"tests can all pass even though your code is broken."
msgstr ""
":class:`Mock` é um objeto muito poderoso e flexível, mas sofre de uma falha "
"que é geral na simulação. Se refatorar algum do seu código, renomear "
"membros, etc., quaisquer testes para código que ainda esteja a usar a *API "
"antiga*, mas que use mocks em vez dos objetos reais, ainda passarão. Isto "
"significa que os seus testes podem todos passar mesmo que o seu código "
"esteja quebrado."

#: ../../library/unittest.mock.rst:2583
msgid ""
"Before 3.5, tests with a typo in the word assert would silently pass when "
"they should raise an error. You can still achieve this behavior by passing "
"``unsafe=True`` to Mock."
msgstr ""
"Antes da versão 3.5, testes com um erro ortográfico na palavra assert "
"passavam silenciosamente quando deviam lançar um erro. Ainda pode obter este "
"comportamento passando ``unsafe=True`` para Mock."

#: ../../library/unittest.mock.rst:2586
msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"Note que esta é outra razão pela qual precisa de testes de integração, bem "
"como de testes unitários. Testar tudo isoladamente é bom, mas se não testar "
"como as suas unidades estão \"ligadas\" ainda há muito espaço para bugs que "
"os testes poderiam ter apanhado."

#: ../../library/unittest.mock.rst:2591
msgid ""
":mod:`unittest.mock` already provides a feature to help with this, called "
"speccing. If you use a class or instance as the :attr:`!spec` for a mock "
"then you can only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`unittest.mock` já fornece uma funcionalidade para ajudar com isto, "
"chamada speccing. Se usar uma classe ou instância como o :attr:`!spec` para "
"um mock, então só pode aceder a atributos no mock que existam na classe real:"

#: ../../library/unittest.mock.rst:2602
msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr ""
"O spec aplica-se apenas ao mock em si, por isso ainda temos o mesmo problema "
"com quaisquer métodos no mock:"

#: ../../library/unittest.mock.rst:2605
msgid ""
">>> mock.has_data()\n"
"<mock.Mock object at 0x...>\n"
">>> mock.has_data.assret_called_with()  # Intentional typo!"
msgstr ""

#: ../../library/unittest.mock.rst:2611
msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"O autospeccing resolve este problema. Pode passar ``autospec=True`` para :"
"func:`patch` / :func:`patch.object` ou usar a função :func:`create_autospec` "
"para criar um mock com um spec. Se usar o argumento ``autospec=True`` para :"
"func:`patch`, então o objeto que está a ser substituído será usado como o "
"objeto spec. Como o speccing é feito \"de forma preguiçosa\" (o spec é "
"criado à medida que os atributos no mock são acedidos), pode usá-lo com "
"objetos muito complexos ou profundamente aninhados (como módulos que "
"importam módulos que importam módulos) sem um grande impacto no desempenho."

#: ../../library/unittest.mock.rst:2620
msgid "Here's an example of it in use::"
msgstr "Aqui está um exemplo do seu uso::"

#: ../../library/unittest.mock.rst:2622
msgid ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"
msgstr ""
">>> from urllib import request\n"
">>> patcher = patch('__main__.request', autospec=True)\n"
">>> mock_request = patcher.start()\n"
">>> request is mock_request\n"
"True\n"
">>> mock_request.Request\n"
"<MagicMock name='request.Request' spec='Request' id='...'>"

#: ../../library/unittest.mock.rst:2630
msgid ""
"You can see that :class:`!request.Request` has a spec. :class:`!request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
"Pode ver que :class:`!request.Request` tem um spec. :class:`!request."
"Request` recebe dois argumentos no construtor (um dos quais é *self*). Aqui "
"está o que acontece se tentarmos chamá-lo incorretamente::"

#: ../../library/unittest.mock.rst:2634
msgid ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() takes at least 2 arguments (1 given)"
msgstr ""
">>> req = request.Request()\n"
"Traceback (most recent call last):\n"
" ...\n"
"TypeError: <lambda>() recebe pelo menos 2 argumentos (1 dado)"

#: ../../library/unittest.mock.rst:2639
msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr ""
"O spec também se aplica a classes instanciadas (ou seja, o valor de retorno "
"de mocks com spec)::"

#: ../../library/unittest.mock.rst:2642
msgid ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"
msgstr ""
">>> req = request.Request('foo')\n"
">>> req\n"
"<NonCallableMagicMock name='request.Request()' spec='Request' id='...'>"

#: ../../library/unittest.mock.rst:2646
msgid ""
":class:`!Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`!request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
"Os objetos :class:`!Request` não são chamáveis, por isso o valor de retorno "
"da instanciação do nosso :class:`!request.Request` simulado é um mock não "
"chamável. Com o spec no lugar, quaisquer erros ortográficos nas nossas "
"afirmações lançarão o erro correto::"

#: ../../library/unittest.mock.rst:2650
msgid ""
">>> req.add_header('spam', 'eggs')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_called_with  # Intentional typo!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: Mock object has no attribute 'assret_called_with'\n"
">>> req.add_header.assert_called_with('spam', 'eggs')"
msgstr ""
">>> req.add_header('spam', 'ovos')\n"
"<MagicMock name='request.Request().add_header()' id='...'>\n"
">>> req.add_header.assret_chamado_com  # Erro ortográfico intencional!\n"
"Traceback (most recent call last):\n"
" ...\n"
"AttributeError: O objeto Mock não tem o atributo 'assret_chamado_com'\n"
">>> req.add_header.assert_called_with('spam', 'ovos')"

#: ../../library/unittest.mock.rst:2658
msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"Em muitos casos, poderá simplesmente adicionar ``autospec=True`` às suas "
"chamadas existentes de :func:`patch` e, em seguida, estará protegido contra "
"bugs devido a erros ortográficos e alterações na API."

#: ../../library/unittest.mock.rst:2662
msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"Além de usar *autospec* através de :func:`patch`, existe um :func:"
"`create_autospec` para criar mocks com autospeccing diretamente:"

#: ../../library/unittest.mock.rst:2670
msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"Isto não está isento de advertências e limitações, no entanto, o que explica "
"por que não é o comportamento predefinido. Para saber quais atributos estão "
"disponíveis no objeto spec, o autospeccing tem de introspecionar (aceder a "
"atributos) o spec. À medida que percorre atributos no mock, uma travessia "
"correspondente do objeto original está a acontecer por baixo. Se algum dos "
"seus objetos com spec tiver propriedades ou descritores que possam "
"desencadear a execução de código, pode não ser capaz de usar autospeccing. "
"Por outro lado, é muito melhor projetar os seus objetos de forma a que a "
"introspeção seja segura [#]_."

#: ../../library/unittest.mock.rst:2679
msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`~object.__init__` method and not to exist on the class "
"at all. *autospec* can't know about any dynamically created attributes and "
"restricts the api to visible attributes. ::"
msgstr ""
"Um problema mais sério é que é comum que atributos de instância sejam "
"criados no método :meth:`~object.__init__` e não existam na classe. "
"*autospec* não pode saber sobre quaisquer atributos criados dinamicamente e "
"restringe a API a atributos visíveis. ::"

#: ../../library/unittest.mock.rst:2684
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: Mock object has no attribute 'a'"
msgstr ""
">>> class Algo:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> with patch('__main__.Algo', autospec=True):\n"
"...   coisa = Algo()\n"
"...   coisa.a\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"AttributeError: O objeto Mock não tem o atributo 'a'"

#: ../../library/unittest.mock.rst:2696
msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"Existem algumas formas diferentes de resolver este problema. A mais fácil, "
"mas não necessariamente a menos irritante, é simplesmente definir os "
"atributos necessários no mock após a criação. Só porque *autospeccing* não "
"permite obter atributos que não existam no spec, não o impede de os definir::"

#: ../../library/unittest.mock.rst:2702
msgid ""
">>> with patch('__main__.Something', autospec=True):\n"
"...   thing = Something()\n"
"...   thing.a = 33\n"
"..."
msgstr ""

#: ../../library/unittest.mock.rst:2707
msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"Existe uma versão mais agressiva de *spec* e *autospec* que *impedem* a "
"definição de atributos não existentes. Isto é útil se quiser garantir que o "
"seu código apenas *define* atributos válidos, mas obviamente impede este "
"cenário específico:"

#: ../../library/unittest.mock.rst:2720
msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`~object.__init__`. "
"Note that if you are only setting default attributes in :meth:`!__init__` "
"then providing them via class attributes (shared between instances of "
"course) is faster too. e.g."
msgstr ""
"Provavelmente, a melhor forma de resolver o problema é adicionar atributos "
"de classe como valores predefinidos para membros de instância inicializados "
"em :meth:`~object.__init__`. Note que, se estiver apenas a definir atributos "
"predefinidos em :meth:`!__init__`, fornecê-los através de atributos de "
"classe (partilhados entre instâncias, claro) também é mais rápido. Por "
"exemplo:"

#: ../../library/unittest.mock.rst:2726
msgid ""
"class Something:\n"
"    a = 33"
msgstr ""
"class Algo:\n"
"    a = 33"

#: ../../library/unittest.mock.rst:2731
msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"Isto levanta outra questão. É relativamente comum fornecer um valor "
"predefinido de ``None`` para membros que mais tarde serão um objeto de um "
"tipo diferente. ``None`` seria inútil como um spec porque não permitiria "
"aceder a *nenhum* atributo ou método. Como ``None`` *nunca* será útil como "
"um spec e provavelmente indica um membro que normalmente será de outro tipo, "
"autospec não usa um spec para membros definidos como ``None``. Estes serão "
"apenas mocks normais (bem, MagicMocks):"

#: ../../library/unittest.mock.rst:2746
msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"Se modificar as suas classes de produção para adicionar valores predefinidos "
"não for do seu agrado, então existem mais opções. Uma delas é simplesmente "
"usar uma instância como o spec em vez da classe. A outra é criar uma "
"subclasse da classe de produção e adicionar os valores predefinidos à "
"subclasse sem afetar a classe de produção. Ambas as opções exigem que use um "
"objeto alternativo como o spec. Felizmente, :func:`patch` suporta isto - "
"pode simplesmente passar o objeto alternativo como o argumento *autospec*::"

#: ../../library/unittest.mock.rst:2754
msgid ""
">>> class Something:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class SomethingForTest(Something):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Something', autospec=SomethingForTest)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Something.a' spec='int' id='...'>"
msgstr ""
">>> class Algo:\n"
"...   def __init__(self):\n"
"...     self.a = 33\n"
"...\n"
">>> class AlgoParaTeste(Algo):\n"
"...   a = 33\n"
"...\n"
">>> p = patch('__main__.Algo', autospec=AlgoParaTeste)\n"
">>> mock = p.start()\n"
">>> mock.a\n"
"<NonCallableMagicMock name='Algo.a' spec='int' id='...'>"

#: ../../library/unittest.mock.rst:2767
msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"Isto aplica-se apenas a classes ou objetos já instanciados. Chamar uma "
"classe simulada para criar uma instância mock *não* cria uma instância real. "
"Apenas são feitas pesquisas de atributos - juntamente com chamadas a :func:"
"`dir`. "

#: ../../library/unittest.mock.rst:2772
msgid "Sealing mocks"
msgstr "Selar mocks"

#: ../../library/unittest.mock.rst:2781
msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr ""
"Seal desativará a criação automática de mocks ao aceder a um atributo do "
"mock que está a ser selado ou a qualquer dos seus atributos que já sejam "
"mocks de forma recursiva."

#: ../../library/unittest.mock.rst:2784
msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""
"Se uma instância mock com um nome ou um spec for atribuída a um atributo, "
"não será considerada na cadeia de selagem. Isto permite evitar que a selagem "
"afete parte do objeto mock. ::"

#: ../../library/unittest.mock.rst:2788
msgid ""
">>> mock = Mock()\n"
">>> mock.submock.attribute1 = 2\n"
">>> mock.not_submock = mock.Mock(name=\"sample_name\")\n"
">>> seal(mock)\n"
">>> mock.new_attribute  # This will raise AttributeError.\n"
">>> mock.submock.attribute2  # This will raise AttributeError.\n"
">>> mock.not_submock.attribute2  # This won't raise."
msgstr ""
">>> mock = Mock()\n"
">>> mock.submock.atributo1 = 2\n"
">>> mock.nao_submock = mock.Mock(name=\"nome_exemplo\")\n"
">>> seal(mock)\n"
">>> mock.novo_atributo  # Isto lançará AttributeError.\n"
">>> mock.submock.atributo2  # Isto lançará AttributeError.\n"
">>> mock.nao_submock.atributo2  # Isto não lançará."

#: ../../library/unittest.mock.rst:2800
msgid ""
"Order of precedence of :attr:`!side_effect`, :attr:`!return_value` and "
"*wraps*"
msgstr ""
"Ordem de precedência de :attr:`!side_effect`, :attr:`!return_value` e *wraps*"

#: ../../library/unittest.mock.rst:2802
msgid "The order of their precedence is:"
msgstr "A ordem de precedência é:"

#: ../../library/unittest.mock.rst:2804
msgid ":attr:`~Mock.side_effect`"
msgstr ":attr:`~Mock.side_effect`"

#: ../../library/unittest.mock.rst:2805
msgid ":attr:`~Mock.return_value`"
msgstr ":attr:`~Mock.return_value`"

#: ../../library/unittest.mock.rst:2806
msgid "*wraps*"
msgstr "*wraps*"

#: ../../library/unittest.mock.rst:2808
msgid ""
"If all three are set, mock will return the value from :attr:`~Mock."
"side_effect`, ignoring :attr:`~Mock.return_value` and the wrapped object "
"altogether. If any two are set, the one with the higher precedence will "
"return the value. Regardless of the order of which was set first, the order "
"of precedence remains unchanged."
msgstr ""
"Se todos os três estiverem definidos, o mock devolverá o valor de :attr:"
"`~Mock.side_effect`, ignorando :attr:`~Mock.return_value` e o objeto "
"envolvido. Se quaisquer dois estiverem definidos, o que tiver maior "
"precedência devolverá o valor. Independentemente da ordem em que foram "
"definidos, a ordem de precedência permanece inalterada."

#: ../../library/unittest.mock.rst:2826
msgid ""
"As ``None`` is the default value of :attr:`~Mock.side_effect`, if you "
"reassign its value back to ``None``, the order of precedence will be checked "
"between :attr:`~Mock.return_value` and the wrapped object, ignoring :attr:"
"`~Mock.side_effect`."
msgstr ""
"Como ``None`` é o valor predefinido de :attr:`~Mock.side_effect`, se "
"reatribuir o seu valor de volta para ``None``, a ordem de precedência será "
"verificada entre :attr:`~Mock.return_value` e o objeto envolvido, ignorando :"
"attr:`~Mock.side_effect`."

#: ../../library/unittest.mock.rst:2835
msgid ""
"If the value being returned by :attr:`~Mock.side_effect` is :data:`DEFAULT`, "
"it is ignored and the order of precedence moves to the successor to obtain "
"the value to return."
msgstr ""
"Se o valor a ser devolvido por :attr:`~Mock.side_effect` for :data:"
"`DEFAULT`, este é ignorado e a ordem de precedência passa para o sucessor "
"para obter o valor a devolver."

#: ../../library/unittest.mock.rst:2844
msgid ""
"When :class:`Mock` wraps an object, the default value of :attr:`~Mock."
"return_value` will be :data:`DEFAULT`."
msgstr ""
"Quando :class:`Mock` envolve um objeto, o valor predefinido de :attr:`~Mock."
"return_value` será :data:`DEFAULT`."

#: ../../library/unittest.mock.rst:2853
msgid ""
"The order of precedence will ignore this value and it will move to the last "
"successor which is the wrapped object."
msgstr ""
"A ordem de precedência ignorará este valor e passará para o último sucessor, "
"que é o objeto envolvido."

#: ../../library/unittest.mock.rst:2856
msgid ""
"As the real call is being made to the wrapped object, creating an instance "
"of this mock will return the real instance of the class. The positional "
"arguments, if any, required by the wrapped object must be passed."
msgstr ""
"Como a chamada real está a ser feita ao objeto envolvido, criar uma "
"instância deste mock devolverá a instância real da classe. Os argumentos "
"posicionais, se houver, exigidos pelo objeto envolvido devem ser passados."

#: ../../library/unittest.mock.rst:2874
msgid ""
"But if you assign ``None`` to it, this will not be ignored as it is an "
"explicit assignment. So, the order of precedence will not move to the "
"wrapped object."
msgstr ""
"Mas se atribuir ``None`` a ele, isto não será ignorado, pois é uma "
"atribuição explícita. Portanto, a ordem de precedência não passará para o "
"objeto envolvido."

#: ../../library/unittest.mock.rst:2882
msgid ""
"Even if you set all three at once when initializing the mock, the order of "
"precedence remains the same:"
msgstr ""
"Mesmo que defina os três de uma vez ao inicializar o mock, a ordem de "
"precedência permanece a mesma:"

#: ../../library/unittest.mock.rst:2899
msgid ""
"If :attr:`~Mock.side_effect` is exhausted, the order of precedence will not "
"cause a value to be obtained from the successors. Instead, ``StopIteration`` "
"exception is raised."
msgstr ""
"Se :attr:`~Mock.side_effect` estiver esgotado, a ordem de precedência não "
"fará com que um valor seja obtido dos sucessores. Em vez disso, será lançada "
"uma exceção ``StopIteration``."
