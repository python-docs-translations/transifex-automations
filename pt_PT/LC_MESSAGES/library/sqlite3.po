# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-05 15:59+0000\n"
"PO-Revision-Date: 2025-07-18 19:58+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`!sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`!sqlite3` --- Interface DB-API 2.0 para bases de dados SQLite"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Código-fonte:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:25
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite é uma biblioteca C que fornece uma base de dados baseada em disco "
"leve que não requer um processo de servidor separado e permite aceder à base "
"de dados usando uma variante não padrão da linguagem de consulta SQL. "
"Algumas aplicações podem usar SQLite para armazenamento interno de dados. "
"Também é possível prototipar uma aplicação usando SQLite e depois portar o "
"código para uma base de dados maior, como PostgreSQL ou Oracle."

#: ../../library/sqlite3.rst:32
msgid ""
"The :mod:`!sqlite3` module was written by Gerhard Häring.  It provides an "
"SQL interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`, and requires SQLite 3.7.15 or newer."
msgstr ""

#: ../../library/sqlite3.rst:36
msgid "This document includes four main sections:"
msgstr "Este documento inclui quatro secções principais:"

#: ../../library/sqlite3.rst:38
msgid ":ref:`sqlite3-tutorial` teaches how to use the :mod:`!sqlite3` module."
msgstr ":ref:`sqlite3-tutorial` ensina como usar o módulo :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:39
msgid ""
":ref:`sqlite3-reference` describes the classes and functions this module "
"defines."
msgstr ""
":ref:`sqlite3-reference` descreve as classes e funções que este módulo "
"define."

#: ../../library/sqlite3.rst:41
msgid ":ref:`sqlite3-howtos` details how to handle specific tasks."
msgstr ":ref:`sqlite3-howtos` detalha como lidar com tarefas específicas."

#: ../../library/sqlite3.rst:42
msgid ""
":ref:`sqlite3-explanation` provides in-depth background on transaction "
"control."
msgstr ""
":ref:`sqlite3-explanation` fornece informações detalhadas sobre o controlo "
"de transações."

#: ../../library/sqlite3.rst:47
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:48
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"A página web do SQLite; a documentação descreve a sintaxe e os tipos de "
"dados disponíveis para o dialeto SQL suportado."

#: ../../library/sqlite3.rst:51
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:52
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Tutorial, referência e exemplos para aprender a sintaxe SQL."

#: ../../library/sqlite3.rst:54
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Especificação da API de Base de Dados 2.0"

#: ../../library/sqlite3.rst:55
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP escrita por Marc-André Lemburg."

#: ../../library/sqlite3.rst:68
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/sqlite3.rst:70
msgid ""
"In this tutorial, you will create a database of Monty Python movies using "
"basic :mod:`!sqlite3` functionality. It assumes a fundamental understanding "
"of database concepts, including `cursors`_ and `transactions`_."
msgstr ""
"Neste tutorial, irá criar uma base de dados de filmes Monty Python usando a "
"funcionalidade básica do :mod:`!sqlite3`. Assume um entendimento fundamental "
"de conceitos de bases de dados, incluindo `cursors`_ e `transactions`_."

#: ../../library/sqlite3.rst:75
msgid ""
"First, we need to create a new database and open a database connection to "
"allow :mod:`!sqlite3` to work with it. Call :func:`sqlite3.connect` to "
"create a connection to the database :file:`tutorial.db` in the current "
"working directory, implicitly creating it if it does not exist:"
msgstr ""
"Primeiro, precisamos de criar uma nova base de dados e abrir uma ligação à "
"base de dados para permitir que o :mod:`!sqlite3` trabalhe com ela. Chame :"
"func:`sqlite3.connect` para criar uma ligação à base de dados :file:"
"`tutorial.db` no diretório de trabalho atual, criando-a implicitamente se "
"não existir:"

#: ../../library/sqlite3.rst:81
msgid ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"
msgstr ""
"import sqlite3\n"
"con = sqlite3.connect(\"tutorial.db\")"

#: ../../library/sqlite3.rst:86
msgid ""
"The returned :class:`Connection` object ``con`` represents the connection to "
"the on-disk database."
msgstr ""
"O objeto :class:`Connection` devolvido ``con`` representa a ligação à base "
"de dados em disco."

#: ../../library/sqlite3.rst:89
msgid ""
"In order to execute SQL statements and fetch results from SQL queries, we "
"will need to use a database cursor. Call :meth:`con.cursor() <Connection."
"cursor>` to create the :class:`Cursor`:"
msgstr ""
"Para executar declarações SQL e obter resultados de consultas SQL, "
"precisaremos de usar um cursor de base de dados. Chame :meth:`con.cursor() "
"<Connection.cursor>` para criar o :class:`Cursor`:"

#: ../../library/sqlite3.rst:93
msgid "cur = con.cursor()"
msgstr "cur = con.cursor()"

#: ../../library/sqlite3.rst:97
msgid ""
"Now that we've got a database connection and a cursor, we can create a "
"database table ``movie`` with columns for title, release year, and review "
"score. For simplicity, we can just use column names in the table declaration "
"-- thanks to the `flexible typing`_ feature of SQLite, specifying the data "
"types is optional. Execute the ``CREATE TABLE`` statement by calling :meth:"
"`cur.execute(...) <Cursor.execute>`:"
msgstr ""
"Ahora que temos uma ligação à base de dados e um cursor, podemos criar uma "
"tabela de base de dados ``movie`` com colunas para título, ano de lançamento "
"e pontuação de revisão. Por simplicidade, podemos simplesmente usar nomes de "
"colunas na declaração da tabela — graças à funcionalidade `flexible typing`_ "
"do SQLite, especificar os tipos de dados é opcional. Execute a declaração "
"``CREATE TABLE`` chamando :meth:`cur.execute(...) <Cursor.execute>`:"

#: ../../library/sqlite3.rst:106
msgid "cur.execute(\"CREATE TABLE movie(title, year, score)\")"
msgstr "cur.execute(\"CREATE TABLE movie(title, year, score)\")"

#: ../../library/sqlite3.rst:113
msgid ""
"We can verify that the new table has been created by querying the "
"``sqlite_master`` table built-in to SQLite, which should now contain an "
"entry for the ``movie`` table definition (see `The Schema Table`_ for "
"details). Execute that query by calling :meth:`cur.execute(...) <Cursor."
"execute>`, assign the result to ``res``, and call :meth:`res.fetchone() "
"<Cursor.fetchone>` to fetch the resulting row:"
msgstr ""
"Podemos verificar que a nova tabela foi criada consultando a tabela "
"``sqlite_master`` integrada no SQLite, que agora deve conter uma entrada "
"para a definição da tabela ``movie`` (veja `The Schema Table`_ para "
"detalhes). Execute essa consulta chamando :meth:`cur.execute(...) <Cursor."
"execute>`, atribua o resultado a ``res`` e chame :meth:`res.fetchone() "
"<Cursor.fetchone>` para buscar a linha resultante:"

#: ../../library/sqlite3.rst:121
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"
msgstr ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master\")\n"
">>> res.fetchone()\n"
"('movie',)"

#: ../../library/sqlite3.rst:127
msgid ""
"We can see that the table has been created, as the query returns a :class:"
"`tuple` containing the table's name. If we query ``sqlite_master`` for a non-"
"existent table ``spam``, :meth:`!res.fetchone` will return ``None``:"
msgstr ""
"Podemos ver que a tabela foi criada, pois a consulta devolve um :class:"
"`tuple` contendo o nome da tabela. Se consultarmos ``sqlite_master`` por uma "
"tabela inexistente ``spam``, :meth:`!res.fetchone` devolverá ``None``:"

#: ../../library/sqlite3.rst:132
msgid ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"
msgstr ""
">>> res = cur.execute(\"SELECT name FROM sqlite_master WHERE name='spam'\")\n"
">>> res.fetchone() is None\n"
"True"

#: ../../library/sqlite3.rst:138
msgid ""
"Now, add two rows of data supplied as SQL literals by executing an "
"``INSERT`` statement, once again by calling :meth:`cur.execute(...) <Cursor."
"execute>`:"
msgstr ""
"Agora, adicione duas linhas de dados fornecidas como literais SQL executando "
"uma declaração ``INSERT``, mais uma vez chamando :meth:`cur.execute(...) "
"<Cursor.execute>`:"

#: ../../library/sqlite3.rst:142
msgid ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"
msgstr ""
"cur.execute(\"\"\"\n"
"    INSERT INTO movie VALUES\n"
"        ('Monty Python and the Holy Grail', 1975, 8.2),\n"
"        ('And Now for Something Completely Different', 1971, 7.5)\n"
"\"\"\")"

#: ../../library/sqlite3.rst:150
msgid ""
"The ``INSERT`` statement implicitly opens a transaction, which needs to be "
"committed before changes are saved in the database (see :ref:`sqlite3-"
"controlling-transactions` for details). Call :meth:`con.commit() <Connection."
"commit>` on the connection object to commit the transaction:"
msgstr ""
"A declaração ``INSERT`` abre implicitamente uma transação, que precisa de "
"ser confirmada antes que as alterações sejam guardadas na base de dados "
"(veja :ref:`sqlite3-controlling-transactions` para detalhes). Chame :meth:"
"`con.commit() <Connection.commit>` no objeto de ligação para confirmar a "
"transação:"

#: ../../library/sqlite3.rst:156
msgid "con.commit()"
msgstr "con.commit()"

#: ../../library/sqlite3.rst:160
msgid ""
"We can verify that the data was inserted correctly by executing a ``SELECT`` "
"query. Use the now-familiar :meth:`cur.execute(...) <Cursor.execute>` to "
"assign the result to ``res``, and call :meth:`res.fetchall() <Cursor."
"fetchall>` to return all resulting rows:"
msgstr ""
"Podemos verificar que os dados foram inseridos corretamente executando uma "
"consulta ``SELECT``. Use o agora familiar :meth:`cur.execute(...) <Cursor."
"execute>` para atribuir o resultado a ``res`` e chame :meth:`res.fetchall() "
"<Cursor.fetchall>` para devolver todas as linhas resultantes:"

#: ../../library/sqlite3.rst:166
msgid ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"
msgstr ""
">>> res = cur.execute(\"SELECT score FROM movie\")\n"
">>> res.fetchall()\n"
"[(8.2,), (7.5,)]"

#: ../../library/sqlite3.rst:172
msgid ""
"The result is a :class:`list` of two :class:`!tuple`\\s, one per row, each "
"containing that row's ``score`` value."
msgstr ""
"O resultado é uma :class:`list` de dois :class:`!tuple`\\s, um por linha, "
"cada um contendo o valor ``score`` dessa linha."

#: ../../library/sqlite3.rst:175
msgid ""
"Now, insert three more rows by calling :meth:`cur.executemany(...) <Cursor."
"executemany>`:"
msgstr ""
"Agora, insira mais três linhas chamando :meth:`cur.executemany(...) <Cursor."
"executemany>`:"

#: ../../library/sqlite3.rst:178
msgid ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Remember to commit the transaction after executing INSERT."
msgstr ""
"data = [\n"
"    (\"Monty Python Live at the Hollywood Bowl\", 1982, 7.9),\n"
"    (\"Monty Python's The Meaning of Life\", 1983, 7.5),\n"
"    (\"Monty Python's Life of Brian\", 1979, 8.0),\n"
"]\n"
"cur.executemany(\"INSERT INTO movie VALUES(?, ?, ?)\", data)\n"
"con.commit()  # Lembre-se de confirmar a transação após executar INSERT."

#: ../../library/sqlite3.rst:188
msgid ""
"Notice that ``?`` placeholders are used to bind ``data`` to the query. "
"Always use placeholders instead of :ref:`string formatting <tut-formatting>` "
"to bind Python values to SQL statements, to avoid `SQL injection attacks`_ "
"(see :ref:`sqlite3-placeholders` for more details)."
msgstr ""
"Note que os placeholders ``?`` são usados para ligar ``data`` à consulta. "
"Use sempre placeholders em vez de :ref:`formatação de strings <tut-"
"formatting>` para ligar valores Python a declarações SQL, para evitar "
"`ataques de injeção SQL`_ (veja :ref:`sqlite3-placeholders` para mais "
"detalhes)."

#: ../../library/sqlite3.rst:194
msgid ""
"We can verify that the new rows were inserted by executing a ``SELECT`` "
"query, this time iterating over the results of the query:"
msgstr ""
"Podemos verificar que as novas linhas foram inseridas executando uma "
"consulta ``SELECT``, desta vez iterando sobre os resultados da consulta:"

#: ../../library/sqlite3.rst:198
msgid ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"
msgstr ""
">>> for row in cur.execute(\"SELECT year, title FROM movie ORDER BY "
"year\"):\n"
"...     print(row)\n"
"(1971, 'And Now for Something Completely Different')\n"
"(1975, 'Monty Python and the Holy Grail')\n"
"(1979, \"Monty Python's Life of Brian\")\n"
"(1982, 'Monty Python Live at the Hollywood Bowl')\n"
"(1983, \"Monty Python's The Meaning of Life\")"

#: ../../library/sqlite3.rst:208
msgid ""
"Each row is a two-item :class:`tuple` of ``(year, title)``, matching the "
"columns selected in the query."
msgstr ""
"Cada linha é um :class:`tuple` de dois itens de ``(year, title)``, "
"correspondendo às colunas selecionadas na consulta."

#: ../../library/sqlite3.rst:211
msgid ""
"Finally, verify that the database has been written to disk by calling :meth:"
"`con.close() <Connection.close>` to close the existing connection, opening a "
"new one, creating a new cursor, then querying the database:"
msgstr ""
"Finalmente, verifique que a base de dados foi escrita em disco chamando :"
"meth:`con.close() <Connection.close>` para fechar a ligação existente, "
"abrindo uma nova, criando um novo cursor e depois consultando a base de "
"dados:"

#: ../../library/sqlite3.rst:216
msgid ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'The highest scoring Monty Python movie is {title!r}, released in "
"{year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', "
"released in 1975\n"
">>> new_con.close()"
msgstr ""
">>> con.close()\n"
">>> new_con = sqlite3.connect(\"tutorial.db\")\n"
">>> new_cur = new_con.cursor()\n"
">>> res = new_cur.execute(\"SELECT title, year FROM movie ORDER BY score "
"DESC\")\n"
">>> title, year = res.fetchone()\n"
">>> print(f'O filme Monty Python com maior pontuação é {title!r}, lançado em "
"{year}')\n"
"The highest scoring Monty Python movie is 'Monty Python and the Holy Grail', "
"released in 1975\n"
">>> new_con.close()"

#: ../../library/sqlite3.rst:227
msgid ""
"You've now created an SQLite database using the :mod:`!sqlite3` module, "
"inserted data and retrieved values from it in multiple ways."
msgstr ""
"Agora criou uma base de dados SQLite usando o módulo :mod:`!sqlite3`, "
"inseriu dados e recuperou valores dela de várias formas."

#: ../../library/sqlite3.rst:239
msgid ":ref:`sqlite3-howtos` for further reading:"
msgstr ":ref:`sqlite3-howtos` para leitura adicional:"

#: ../../library/sqlite3.rst:241
msgid ":ref:`sqlite3-placeholders`"
msgstr ":ref:`sqlite3-placeholders`"

#: ../../library/sqlite3.rst:242
msgid ":ref:`sqlite3-adapters`"
msgstr ":ref:`sqlite3-adapters`"

#: ../../library/sqlite3.rst:243
msgid ":ref:`sqlite3-converters`"
msgstr ":ref:`sqlite3-converters`"

#: ../../library/sqlite3.rst:244 ../../library/sqlite3.rst:612
msgid ":ref:`sqlite3-connection-context-manager`"
msgstr ":ref:`sqlite3-connection-context-manager`"

#: ../../library/sqlite3.rst:245
msgid ":ref:`sqlite3-howto-row-factory`"
msgstr ":ref:`sqlite3-howto-row-factory`"

#: ../../library/sqlite3.rst:247
msgid ""
":ref:`sqlite3-explanation` for in-depth background on transaction control."
msgstr ""
":ref:`sqlite3-explanation` para informações detalhadas sobre o controlo de "
"transações."

#: ../../library/sqlite3.rst:252
msgid "Reference"
msgstr "Referência"

#: ../../library/sqlite3.rst:260
msgid "Module functions"
msgstr "Funções do módulo"

#: ../../library/sqlite3.rst:268
msgid "Open a connection to an SQLite database."
msgstr "Abre uma ligação a uma base de dados SQLite."

#: ../../library/sqlite3.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/sqlite3.rst:270
msgid ""
"The path to the database file to be opened. You can pass ``\":memory:\"`` to "
"create an `SQLite database existing only in memory <https://sqlite.org/"
"inmemorydb.html>`_, and open a connection to it."
msgstr ""
"O caminho para o ficheiro da base de dados a ser aberto. Pode passar ``\":"
"memory:\"`` para criar uma `base de dados SQLite que existe apenas em "
"memória <https://sqlite.org/inmemorydb.html>`_, e abrir uma ligação a ela."

#: ../../library/sqlite3.rst:277
msgid ""
"How many seconds the connection should wait before raising an :exc:"
"`OperationalError` when a table is locked. If another connection opens a "
"transaction to modify a table, that table will be locked until the "
"transaction is committed. Default five seconds."
msgstr ""
"Quantos segundos a ligação deve esperar antes de lançar um :exc:"
"`OperationalError` quando uma tabela está bloqueada. Se outra ligação abrir "
"uma transação para modificar uma tabela, essa tabela ficará bloqueada até "
"que a transação seja confirmada. Predefinição de cinco segundos."

#: ../../library/sqlite3.rst:284
msgid ""
"Control whether and how data types not :ref:`natively supported by SQLite "
"<sqlite3-types>` are looked up to be converted to Python types, using the "
"converters registered with :func:`register_converter`. Set it to any "
"combination (using ``|``, bitwise or) of :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES` to enable this. Column names takes precedence over declared "
"types if both flags are set. By default (``0``), type detection is disabled."
msgstr ""
"Controla se e como os tipos de dados não :ref:`nativamente suportados pelo "
"SQLite <sqlite3-types>` são procurados para serem convertidos em tipos "
"Python, usando os conversores registados com :func:`register_converter`. "
"Defina-o para qualquer combinação (usando ``|``, ou bit a bit) de :const:"
"`PARSE_DECLTYPES` e :const:`PARSE_COLNAMES` para ativar isto. Os nomes das "
"colunas têm precedência sobre os tipos declarados se ambas as flags "
"estiverem definidas. Por predefinição (``0``), a deteção de tipos está "
"desativada."

#: ../../library/sqlite3.rst:295
msgid ""
"Control legacy transaction handling behaviour. See :attr:`Connection."
"isolation_level` and :ref:`sqlite3-transaction-control-isolation-level` for "
"more information. Can be ``\"DEFERRED\"`` (default), ``\"EXCLUSIVE\"`` or "
"``\"IMMEDIATE\"``; or ``None`` to disable opening transactions implicitly. "
"Has no effect unless :attr:`Connection.autocommit` is set to :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL` (the default)."
msgstr ""
"Controla o comportamento de manipulação de transações legado. Veja :attr:"
"`Connection.isolation_level` e :ref:`sqlite3-transaction-control-isolation-"
"level` para mais informações. Pode ser ``\"DEFERRED\"`` (predefinição), "
"``\"EXCLUSIVE\"`` ou ``\"IMMEDIATE\"``; ou ``None`` para desativar a "
"abertura de transações implicitamente. Não tem efeito a menos que :attr:"
"`Connection.autocommit` esteja definido para :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL` (a predefinição)."

#: ../../library/sqlite3.rst:305
msgid ""
"If ``True`` (default), :exc:`ProgrammingError` will be raised if the "
"database connection is used by a thread other than the one that created it. "
"If ``False``, the connection may be accessed in multiple threads; write "
"operations may need to be serialized by the user to avoid data corruption. "
"See :attr:`threadsafety` for more information."
msgstr ""
"Se ``True`` (predefinição), :exc:`ProgrammingError` será lançado se a "
"ligação à base de dados for usada por uma thread diferente da que a criou. "
"Se ``False``, a ligação pode ser acedida em múltiplas threads; operações de "
"escrita podem precisar de ser serializadas pelo utilizador para evitar "
"corrupção de dados. Veja :attr:`threadsafety` para mais informações."

#: ../../library/sqlite3.rst:314
msgid ""
"A custom subclass of :class:`Connection` to create the connection with, if "
"not the default :class:`Connection` class."
msgstr ""
"Uma subclasse personalizada de :class:`Connection` para criar a ligação, se "
"não for a classe :class:`Connection` predefinida."

#: ../../library/sqlite3.rst:318
msgid ""
"The number of statements that :mod:`!sqlite3` should internally cache for "
"this connection, to avoid parsing overhead. By default, 128 statements."
msgstr ""
"O número de declarações que o :mod:`!sqlite3` deve armazenar em cache "
"internamente para esta ligação, para evitar sobrecarga de análise. Por "
"predefinição, 128 declarações."

#: ../../library/sqlite3.rst:323
msgid ""
"If set to ``True``, *database* is interpreted as a :abbr:`URI (Uniform "
"Resource Identifier)` with a file path and an optional query string. The "
"scheme part *must* be ``\"file:\"``, and the path can be relative or "
"absolute. The query string allows passing parameters to SQLite, enabling "
"various :ref:`sqlite3-uri-tricks`."
msgstr ""
"Se definido como ``True``, *database* é interpretado como um :abbr:`URI "
"(Uniform Resource Identifier)` com um caminho de ficheiro e uma string de "
"consulta opcional. A parte do esquema *deve* ser ``\"file:\"``, e o caminho "
"pode ser relativo ou absoluto. A string de consulta permite passar "
"parâmetros para o SQLite, ativando vários :ref:`sqlite3-uri-tricks`."

#: ../../library/sqlite3.rst:332
msgid ""
"Control :pep:`249` transaction handling behaviour. See :attr:`Connection."
"autocommit` and :ref:`sqlite3-transaction-control-autocommit` for more "
"information. *autocommit* currently defaults to :const:`~sqlite3."
"LEGACY_TRANSACTION_CONTROL`. The default will change to ``False`` in a "
"future Python release."
msgstr ""
"Controla o comportamento de manipulação de transações :pep:`249`. Veja :attr:"
"`Connection.autocommit` e :ref:`sqlite3-transaction-control-autocommit` para "
"mais informações. *autocommit* atualmente tem como predefinição :const:"
"`~sqlite3.LEGACY_TRANSACTION_CONTROL`. A predefinição mudará para ``False`` "
"numa futura versão do Python."

#: ../../library/sqlite3.rst:0
msgid "Return type"
msgstr "Tipo de retorno"

#: ../../library/sqlite3.rst:343
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Gera um :ref:`evento de auditoria <auditing>` ``sqlite3.connect`` com o "
"argumento ``database``."

#: ../../library/sqlite3.rst:344
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect/handle`` with "
"argument ``connection_handle``."
msgstr ""
"Gera um :ref:`evento de auditoria <auditing>` ``sqlite3.connect/handle`` com "
"o argumento ``connection_handle``."

#: ../../library/sqlite3.rst:346
msgid "Added the *uri* parameter."
msgstr "Adicionado o parâmetro *uri*."

#: ../../library/sqlite3.rst:349
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* agora também pode ser um :term:`objeto tipo caminho`, não apenas "
"uma string."

#: ../../library/sqlite3.rst:352
msgid "Added the ``sqlite3.connect/handle`` auditing event."
msgstr "Adicionado o evento de auditoria ``sqlite3.connect/handle``."

#: ../../library/sqlite3.rst:355
msgid "Added the *autocommit* parameter."
msgstr "Adicionado o parâmetro *autocommit*."

#: ../../library/sqlite3.rst:360
msgid ""
"Return ``True`` if the string *statement* appears to contain one or more "
"complete SQL statements. No syntactic verification or parsing of any kind is "
"performed, other than checking that there are no unclosed string literals "
"and the statement is terminated by a semicolon."
msgstr ""
"Devolve ``True`` se a string *statement* parecer conter uma ou mais "
"declarações SQL completas. Não é realizada nenhuma verificação sintática ou "
"análise de qualquer tipo, além de verificar que não há literais de string "
"não fechados e que a declaração é terminada por um ponto e vírgula."

#: ../../library/sqlite3.rst:366
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/sqlite3.rst:368
msgid ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"
msgstr ""
">>> sqlite3.complete_statement(\"SELECT foo FROM bar;\")\n"
"True\n"
">>> sqlite3.complete_statement(\"SELECT foo\")\n"
"False"

#: ../../library/sqlite3.rst:375
msgid ""
"This function may be useful during command-line input to determine if the "
"entered text seems to form a complete SQL statement, or if additional input "
"is needed before calling :meth:`~Cursor.execute`."
msgstr ""
"Esta função pode ser útil durante a entrada de linha de comando para "
"determinar se o texto inserido parece formar uma declaração SQL completa, ou "
"se é necessária entrada adicional antes de chamar :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:379
msgid ""
"See :func:`!runsource` in :source:`Lib/sqlite3/__main__.py` for real-world "
"use."
msgstr ""
"Veja :func:`!runsource` em :source:`Lib/sqlite3/__main__.py` para uso no "
"mundo real."

#: ../../library/sqlite3.rst:384
msgid ""
"Enable or disable callback tracebacks. By default you will not get any "
"tracebacks in user-defined functions, aggregates, converters, authorizer "
"callbacks etc. If you want to debug them, you can call this function with "
"*flag* set to ``True``. Afterwards, you will get tracebacks from callbacks "
"on :data:`sys.stderr`. Use ``False`` to disable the feature again."
msgstr ""
"Ativar ou desativar tracebacks de callback. Por predefinição, não obterá "
"tracebacks em funções definidas pelo utilizador, agregados, conversores, "
"callbacks de autorização, etc. Se quiser depurá-los, pode chamar esta função "
"com *flag* definido como ``True``. Depois, obterá tracebacks de callbacks "
"em :data:`sys.stderr`. Use ``False`` para desativar a funcionalidade "
"novamente."

#: ../../library/sqlite3.rst:393
msgid ""
"Errors in user-defined function callbacks are logged as unraisable "
"exceptions. Use an :func:`unraisable hook handler <sys.unraisablehook>` for "
"introspection of the failed callback."
msgstr ""
"Erros em callbacks de funções definidas pelo utilizador são registados como "
"exceções não lançáveis. Use um :func:`gestor de hook não lançável <sys."
"unraisablehook>` para introspeção do callback falhado."

#: ../../library/sqlite3.rst:399
msgid ""
"Register an *adapter* :term:`callable` to adapt the Python type *type* into "
"an SQLite type. The adapter is called with a Python object of type *type* as "
"its sole argument, and must return a value of a :ref:`type that SQLite "
"natively understands <sqlite3-types>`."
msgstr ""
"Regista um *adapter* :term:`chamável` para adaptar o tipo Python *type* num "
"tipo SQLite. O adaptador é chamado com um objeto Python do tipo *type* como "
"seu único argumento e deve devolver um valor de um :ref:`tipo que o SQLite "
"entende nativamente <sqlite3-types>`."

#: ../../library/sqlite3.rst:407
msgid ""
"Register the *converter* :term:`callable` to convert SQLite objects of type "
"*typename* into a Python object of a specific type. The converter is invoked "
"for all SQLite values of type *typename*; it is passed a :class:`bytes` "
"object and should return an object of the desired Python type. Consult the "
"parameter *detect_types* of :func:`connect` for information regarding how "
"type detection works."
msgstr ""
"Regista o *conversor* :term:`chamável` para converter objetos SQLite do tipo "
"*typename* num objeto Python de um tipo específico. O conversor é invocado "
"para todos os valores SQLite do tipo *typename*; recebe um objeto :class:"
"`bytes` e deve devolver um objeto do tipo Python desejado. Consulte o "
"parâmetro *detect_types* de :func:`connect` para informações sobre como "
"funciona a deteção de tipos."

#: ../../library/sqlite3.rst:415
msgid ""
"Note: *typename* and the name of the type in your query are matched case-"
"insensitively."
msgstr ""
"Nota: *typename* e o nome do tipo na sua consulta são comparados sem "
"distinção entre maiúsculas e minúsculas."

#: ../../library/sqlite3.rst:422
msgid "Module constants"
msgstr "Constantes do módulo"

#: ../../library/sqlite3.rst:426
msgid ""
"Set :attr:`~Connection.autocommit` to this constant to select old style (pre-"
"Python 3.12) transaction control behaviour. See :ref:`sqlite3-transaction-"
"control-isolation-level` for more information."
msgstr ""
"Defina :attr:`~Connection.autocommit` para esta constante para selecionar o "
"comportamento antigo de controlo de transações (pré-Python 3.12). Veja :ref:"
"`sqlite3-transaction-control-isolation-level` para mais informações."

#: ../../library/sqlite3.rst:432
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function using the declared types for each column. The "
"types are declared when the database table is created. :mod:`!sqlite3` will "
"look up a converter function using the first word of the declared type as "
"the converter dictionary key. For example:"
msgstr ""
"Passe este valor de flag para o parâmetro *detect_types* de :func:`connect` "
"para procurar uma função de conversão usando os tipos declarados para cada "
"coluna. Os tipos são declarados quando a tabela da base de dados é criada. :"
"mod:`!sqlite3` procurará uma função de conversão usando a primeira palavra "
"do tipo declarado como a chave do dicionário de conversores. Por exemplo:"

#: ../../library/sqlite3.rst:440
msgid ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! will look up a converter named \"integer\"\n"
"   p point,                ! will look up a converter named \"point\"\n"
"   n number(10)            ! will look up a converter named \"number\"\n"
" )"
msgstr ""
"CREATE TABLE test(\n"
"   i integer primary key,  ! procurará um conversor chamado \"integer\"\n"
"   p point,                ! procurará um conversor chamado \"point\"\n"
"   n number(10)            ! procurará um conversor chamado \"number\"\n"
" )"

#: ../../library/sqlite3.rst:448
msgid ""
"This flag may be combined with :const:`PARSE_COLNAMES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Esta flag pode ser combinada com :const:`PARSE_COLNAMES` usando o operador "
"``|`` (ou bit a bit)."

#: ../../library/sqlite3.rst:453
msgid ""
"Generated fields (for example ``MAX(p)``) are returned as :class:`str`. Use :"
"const:`!PARSE_COLNAMES` to enforce types for such queries."
msgstr ""
"Campos gerados (por exemplo ``MAX(p)``) são devolvidos como :class:`str`. "
"Use :const:`!PARSE_COLNAMES` para impor tipos para tais consultas."

#: ../../library/sqlite3.rst:458
msgid ""
"Pass this flag value to the *detect_types* parameter of :func:`connect` to "
"look up a converter function by using the type name, parsed from the query "
"column name, as the converter dictionary key. The query column name must be "
"wrapped in double quotes (``\"``) and the type name must be wrapped in "
"square brackets (``[]``)."
msgstr ""
"Passe este valor de flag para o parâmetro *detect_types* de :func:`connect` "
"para procurar uma função de conversão usando o nome do tipo, analisado a "
"partir do nome da coluna da consulta, como a chave do dicionário de "
"conversores. O nome da coluna da consulta deve estar envolvido em aspas "
"duplas (``\"``) e o nome do tipo deve estar envolvido em parênteses retos "
"(``[]``)."

#: ../../library/sqlite3.rst:465
msgid ""
"SELECT MAX(p) as \"p [point]\" FROM test;  ! will look up converter \"point\""
msgstr ""
"SELECT MAX(p) as \"p [point]\" FROM test;  ! procurará o conversor \"point\""

#: ../../library/sqlite3.rst:469
msgid ""
"This flag may be combined with :const:`PARSE_DECLTYPES` using the ``|`` "
"(bitwise or) operator."
msgstr ""
"Esta flag pode ser combinada com :const:`PARSE_DECLTYPES` usando o operador "
"``|`` (ou bit a bit)."

#: ../../library/sqlite3.rst:476
msgid ""
"Flags that should be returned by the *authorizer_callback* :term:`callable` "
"passed to :meth:`Connection.set_authorizer`, to indicate whether:"
msgstr ""
"Flags que devem ser devolvidos pelo *authorizer_callback* :term:`chamável` "
"passado para :meth:`Connection.set_authorizer`, para indicar se:"

#: ../../library/sqlite3.rst:479
msgid "Access is allowed (:const:`!SQLITE_OK`),"
msgstr "O acesso é permitido (:const:`!SQLITE_OK`),"

#: ../../library/sqlite3.rst:480
msgid ""
"The SQL statement should be aborted with an error (:const:`!SQLITE_DENY`)"
msgstr "A declaração SQL deve ser abortada com um erro (:const:`!SQLITE_DENY`)"

#: ../../library/sqlite3.rst:481
msgid ""
"The column should be treated as a ``NULL`` value (:const:`!SQLITE_IGNORE`)"
msgstr ""
"A coluna deve ser tratada como um valor ``NULL`` (:const:`!SQLITE_IGNORE`)"

#: ../../library/sqlite3.rst:485
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Constante de string indicando o nível DB-API suportado. Requerido pela DB-"
"API. Codificado como ``\"2.0\"``."

#: ../../library/sqlite3.rst:490
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`!sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Constante de string indicando o tipo de formatação de marcador de parâmetro "
"esperado pelo módulo :mod:`!sqlite3`. Requerido pela DB-API. Codificado como "
"``\"qmark\"``."

#: ../../library/sqlite3.rst:496
msgid "The ``named`` DB-API parameter style is also supported."
msgstr "O estilo de parâmetro DB-API ``named`` também é suportado."

#: ../../library/sqlite3.rst:500
msgid ""
"Version number of the runtime SQLite library as a :class:`string <str>`."
msgstr ""
"Número da versão da biblioteca SQLite em tempo de execução como uma :class:"
"`string <str>`."

#: ../../library/sqlite3.rst:504
msgid ""
"Version number of the runtime SQLite library as a :class:`tuple` of :class:"
"`integers <int>`."
msgstr ""
"Número da versão da biblioteca SQLite em tempo de execução como um :class:"
"`tuple` de :class:`integers <int>`."

#: ../../library/sqlite3.rst:509
msgid ""
"Integer constant required by the DB-API 2.0, stating the level of thread "
"safety the :mod:`!sqlite3` module supports. This attribute is set based on "
"the default `threading mode <https://sqlite.org/threadsafe.html>`_ the "
"underlying SQLite library is compiled with. The SQLite threading modes are:"
msgstr ""
"Constante inteira requerida pela DB-API 2.0, indicando o nível de segurança "
"de threads que o módulo :mod:`!sqlite3` suporta. Este atributo é definido "
"com base no modo de threading predefinido `modo de threading <https://sqlite."
"org/threadsafe.html>`_ com o qual a biblioteca SQLite subjacente é "
"compilada. Os modos de threading do SQLite são:"

#: ../../library/sqlite3.rst:514
msgid ""
"**Single-thread**: In this mode, all mutexes are disabled and SQLite is "
"unsafe to use in more than a single thread at once."
msgstr ""
"**Single-thread**: Neste modo, todos os mutexes estão desativados e o SQLite "
"não é seguro para usar em mais do que uma thread de cada vez."

#: ../../library/sqlite3.rst:516
msgid ""
"**Multi-thread**: In this mode, SQLite can be safely used by multiple "
"threads provided that no single database connection is used simultaneously "
"in two or more threads."
msgstr ""
"**Multi-thread**: Neste modo, o SQLite pode ser usado com segurança por "
"múltiplas threads, desde que nenhuma ligação única à base de dados seja "
"usada simultaneamente em duas ou mais threads."

#: ../../library/sqlite3.rst:519
msgid ""
"**Serialized**: In serialized mode, SQLite can be safely used by multiple "
"threads with no restriction."
msgstr ""
"**Serialized**: No modo serializado, o SQLite pode ser usado com segurança "
"por múltiplas threads sem restrições."

#: ../../library/sqlite3.rst:522
msgid ""
"The mappings from SQLite threading modes to DB-API 2.0 threadsafety levels "
"are as follows:"
msgstr ""
"Os mapeamentos dos modos de threading do SQLite para os níveis de segurança "
"de threads da DB-API 2.0 são os seguintes:"

#: ../../library/sqlite3.rst:526
msgid "SQLite threading mode"
msgstr "Modo de threading do SQLite"

#: ../../library/sqlite3.rst:526
msgid ":pep:`threadsafety <0249#threadsafety>`"
msgstr ":pep:`threadsafety <0249#threadsafety>`"

#: ../../library/sqlite3.rst:526
msgid "`SQLITE_THREADSAFE`_"
msgstr "`SQLITE_THREADSAFE`_"

#: ../../library/sqlite3.rst:526
msgid "DB-API 2.0 meaning"
msgstr "Significado da DB-API 2.0"

#: ../../library/sqlite3.rst:529
msgid "single-thread"
msgstr "single-thread"

#: ../../library/sqlite3.rst:529
msgid "0"
msgstr "0"

#: ../../library/sqlite3.rst:529
msgid "Threads may not share the module"
msgstr "As threads não podem partilhar o módulo"

#: ../../library/sqlite3.rst:532
msgid "multi-thread"
msgstr "multi-thread"

#: ../../library/sqlite3.rst:532 ../../library/sqlite3.rst:535
msgid "1"
msgstr "1"

#: ../../library/sqlite3.rst:532
msgid "2"
msgstr "2"

#: ../../library/sqlite3.rst:532
msgid "Threads may share the module, but not connections"
msgstr "As threads podem partilhar o módulo, mas não as ligações"

#: ../../library/sqlite3.rst:535
msgid "serialized"
msgstr "serializado"

#: ../../library/sqlite3.rst:535
msgid "3"
msgstr "3"

#: ../../library/sqlite3.rst:535
msgid "Threads may share the module, connections and cursors"
msgstr "As threads podem partilhar o módulo, ligações e cursores"

#: ../../library/sqlite3.rst:541
msgid "Set *threadsafety* dynamically instead of hard-coding it to ``1``."
msgstr "Defina *threadsafety* dinamicamente em vez de o codificar como ``1``."

#: ../../library/sqlite3.rst:546
msgid ""
"Version number of this module as a :class:`string <str>`. This is not the "
"version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:549 ../../library/sqlite3.rst:559
msgid ""
"This constant used to reflect the version number of the ``pysqlite`` "
"package, a third-party library which used to upstream changes to :mod:`!"
"sqlite3`. Today, it carries no meaning or practical value."
msgstr ""

#: ../../library/sqlite3.rst:556
msgid ""
"Version number of this module as a :class:`tuple` of :class:`integers "
"<int>`. This is not the version of the SQLite library."
msgstr ""

#: ../../library/sqlite3.rst:583
msgid ""
"These constants are used for the :meth:`Connection.setconfig` and :meth:"
"`~Connection.getconfig` methods."
msgstr ""
"Estas constantes são usadas para os métodos :meth:`Connection.setconfig` e :"
"meth:`~Connection.getconfig`."

#: ../../library/sqlite3.rst:586
msgid ""
"The availability of these constants varies depending on the version of "
"SQLite Python was compiled with."
msgstr ""
"A disponibilidade destas constantes varia dependendo da versão do SQLite com "
"a qual o Python foi compilado."

#: ../../library/sqlite3.rst:593
msgid "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"
msgstr "https://www.sqlite.org/c3ref/c_dbconfig_defensive.html"

#: ../../library/sqlite3.rst:594
msgid "SQLite docs: Database Connection Configuration Options"
msgstr ""
"Documentação do SQLite: Opções de Configuração de Ligação à Base de Dados"

#: ../../library/sqlite3.rst:600
msgid "Connection objects"
msgstr "Objetos de ligação"

#: ../../library/sqlite3.rst:604
msgid ""
"Each open SQLite database is represented by a ``Connection`` object, which "
"is created using :func:`sqlite3.connect`. Their main purpose is creating :"
"class:`Cursor` objects, and :ref:`sqlite3-controlling-transactions`."
msgstr ""
"Cada base de dados SQLite aberta é representada por um objeto "
"``Connection``, que é criado usando :func:`sqlite3.connect`. O seu principal "
"propósito é criar objetos :class:`Cursor` e :ref:`sqlite3-controlling-"
"transactions`."

#: ../../library/sqlite3.rst:611
msgid ":ref:`sqlite3-connection-shortcuts`"
msgstr ":ref:`sqlite3-connection-shortcuts`"

#: ../../library/sqlite3.rst:614
msgid "An SQLite database connection has the following attributes and methods:"
msgstr ""
"Uma ligação a uma base de dados SQLite tem os seguintes atributos e métodos:"

#: ../../library/sqlite3.rst:618
msgid ""
"Create and return a :class:`Cursor` object. The cursor method accepts a "
"single optional parameter *factory*. If supplied, this must be a :term:"
"`callable` returning an instance of :class:`Cursor` or its subclasses."
msgstr ""
"Cria e devolve um objeto :class:`Cursor`. O método cursor aceita um único "
"parâmetro opcional *factory*. Se fornecido, este deve ser um :term:"
"`chamável` que devolve uma instância de :class:`Cursor` ou das suas "
"subclasses."

#: ../../library/sqlite3.rst:625
msgid ""
"Open a :class:`Blob` handle to an existing :abbr:`BLOB (Binary Large "
"OBject)`."
msgstr ""
"Abre um :class:`Blob` para um :abbr:`BLOB (Binary Large OBject)` existente."

#: ../../library/sqlite3.rst:628
msgid "The name of the table where the blob is located."
msgstr "O nome da tabela onde o blob está localizado."

#: ../../library/sqlite3.rst:631
msgid "The name of the column where the blob is located."
msgstr "O nome da coluna onde o blob está localizado."

#: ../../library/sqlite3.rst:634
msgid "The name of the row where the blob is located."
msgstr ""

#: ../../library/sqlite3.rst:637
msgid ""
"Set to ``True`` if the blob should be opened without write permissions. "
"Defaults to ``False``."
msgstr ""
"Definido como ``True`` se o blob deve ser aberto sem permissões de escrita. "
"Predefinição é ``False``."

#: ../../library/sqlite3.rst:642
msgid ""
"The name of the database where the blob is located. Defaults to ``\"main\"``."
msgstr ""
"O nome da base de dados onde o blob está localizado. Predefinição é "
"``\"main\"``."

#: ../../library/sqlite3.rst:0
msgid "Raises"
msgstr "Lança"

#: ../../library/sqlite3.rst:646
msgid "When trying to open a blob in a ``WITHOUT ROWID`` table."
msgstr "Ao tentar abrir um blob numa tabela ``WITHOUT ROWID``."

#: ../../library/sqlite3.rst:653
msgid ""
"The blob size cannot be changed using the :class:`Blob` class. Use the SQL "
"function ``zeroblob`` to create a blob with a fixed size."
msgstr ""
"O tamanho do blob não pode ser alterado usando a classe :class:`Blob`. Use a "
"função SQL ``zeroblob`` para criar um blob com um tamanho fixo."

#: ../../library/sqlite3.rst:660
msgid ""
"Commit any pending transaction to the database. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was committed by this method."
msgstr ""
"Confirma qualquer transação pendente na base de dados. Se :attr:`autocommit` "
"for ``True``, ou não houver nenhuma transação aberta, este método não faz "
"nada. Se :attr:`!autocommit` for ``False``, uma nova transação é "
"implicitamente aberta se uma transação pendente foi confirmada por este "
"método."

#: ../../library/sqlite3.rst:668
msgid ""
"Roll back to the start of any pending transaction. If :attr:`autocommit` is "
"``True``, or there is no open transaction, this method does nothing. If :"
"attr:`!autocommit` is ``False``, a new transaction is implicitly opened if a "
"pending transaction was rolled back by this method."
msgstr ""
"Reverte para o início de qualquer transação pendente. Se :attr:`autocommit` "
"for ``True``, ou não houver nenhuma transação aberta, este método não faz "
"nada. Se :attr:`!autocommit` for ``False``, uma nova transação é "
"implicitamente aberta se uma transação pendente foi revertida por este "
"método."

#: ../../library/sqlite3.rst:676
msgid ""
"Close the database connection. If :attr:`autocommit` is ``False``, any "
"pending transaction is implicitly rolled back. If :attr:`!autocommit` is "
"``True`` or :data:`LEGACY_TRANSACTION_CONTROL`, no implicit transaction "
"control is executed. Make sure to :meth:`commit` before closing to avoid "
"losing pending changes."
msgstr ""
"Fecha a ligação à base de dados. Se :attr:`autocommit` for ``False``, "
"qualquer transação pendente é implicitamente revertida. Se :attr:`!"
"autocommit` for ``True`` ou :data:`LEGACY_TRANSACTION_CONTROL`, nenhum "
"controlo de transação implícito é executado. Certifique-se de :meth:`commit` "
"antes de fechar para evitar perder alterações pendentes."

#: ../../library/sqlite3.rst:686
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Cria um novo objeto :class:`Cursor` e chama :meth:`~Cursor.execute` nele com "
"o *sql* e *parameters* dados. Devolve o novo objeto cursor."

#: ../../library/sqlite3.rst:692
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Cria um novo objeto :class:`Cursor` e chama :meth:`~Cursor.executemany` nele "
"com o *sql* e *parameters* dados. Devolve o novo objeto cursor."

#: ../../library/sqlite3.rst:698
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Cria um novo objeto :class:`Cursor` e chama :meth:`~Cursor.executescript` "
"nele com o *sql_script* dado. Devolve o novo objeto cursor."

#: ../../library/sqlite3.rst:704
msgid "Create or remove a user-defined SQL function."
msgstr "Cria ou remove uma função SQL definida pelo utilizador."

#: ../../library/sqlite3.rst:706
msgid "The name of the SQL function."
msgstr "O nome da função SQL."

#: ../../library/sqlite3.rst:709
msgid ""
"The number of arguments the SQL function can accept. If ``-1``, it may take "
"any number of arguments."
msgstr ""
"O número de argumentos que a função SQL pode aceitar. Se ``-1``, pode "
"aceitar qualquer número de argumentos."

#: ../../library/sqlite3.rst:713
msgid ""
"A :term:`callable` that is called when the SQL function is invoked. The "
"callable must return :ref:`a type natively supported by SQLite <sqlite3-"
"types>`. Set to ``None`` to remove an existing SQL function."
msgstr ""
"Um :term:`chamável` que é chamado quando a função SQL é invocada. O chamável "
"deve devolver :ref:`um tipo nativamente suportado pelo SQLite <sqlite3-"
"types>`. Defina como ``None`` para remover uma função SQL existente."

#: ../../library/sqlite3.rst:720
msgid ""
"If ``True``, the created SQL function is marked as `deterministic <https://"
"sqlite.org/deterministic.html>`_, which allows SQLite to perform additional "
"optimizations."
msgstr ""
"Se ``True``, a função SQL criada é marcada como `determinística <https://"
"sqlite.org/deterministic.html>`_, o que permite ao SQLite realizar "
"otimizações adicionais."

#: ../../library/sqlite3.rst:725
msgid "If *deterministic* is used with SQLite versions older than 3.8.3."
msgstr ""

#: ../../library/sqlite3.rst:728
msgid "Added the *deterministic* parameter."
msgstr "Adicionado o parâmetro *deterministic*."

#: ../../library/sqlite3.rst:731 ../../library/sqlite3.rst:770
#: ../../library/sqlite3.rst:833 ../../library/sqlite3.rst:1093
#: ../../library/sqlite3.rst:1513 ../../library/sqlite3.rst:1556
msgid "Example:"
msgstr "Exemplo:"

#: ../../library/sqlite3.rst:733
msgid ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"
msgstr ""
">>> import hashlib\n"
">>> def md5sum(t):\n"
"...     return hashlib.md5(t).hexdigest()\n"
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.create_function(\"md5\", 1, md5sum)\n"
">>> for row in con.execute(\"SELECT md5(?)\", (b\"foo\",)):\n"
"...     print(row)\n"
"('acbd18db4cc2f85cedef654fccc4a4d8',)\n"
">>> con.close()"

#: ../../library/sqlite3.rst:748
msgid "Create or remove a user-defined SQL aggregate function."
msgstr "Cria ou remove uma função agregada SQL definida pelo utilizador."

#: ../../library/sqlite3.rst:750
msgid "The name of the SQL aggregate function."
msgstr "O nome da função agregada SQL."

#: ../../library/sqlite3.rst:753
msgid ""
"The number of arguments the SQL aggregate function can accept. If ``-1``, it "
"may take any number of arguments."
msgstr ""
"O número de argumentos que a função agregada SQL pode aceitar. Se ``-1``, "
"pode aceitar qualquer número de argumentos."

#: ../../library/sqlite3.rst:757
msgid ""
"A class must implement the following methods:  * ``step()``: Add a row to "
"the aggregate. * ``finalize()``: Return the final result of the aggregate "
"as   :ref:`a type natively supported by SQLite <sqlite3-types>`.  The number "
"of arguments that the ``step()`` method must accept is controlled by "
"*n_arg*.  Set to ``None`` to remove an existing SQL aggregate function."
msgstr ""
"Uma classe deve implementar os seguintes métodos: * ``step()``: Adiciona uma "
"linha ao agregado. * ``finalize()``: Devolve o resultado final do agregado "
"como :ref:`um tipo nativamente suportado pelo SQLite <sqlite3-types>`. O "
"número de argumentos que o método ``step()`` deve aceitar é controlado por "
"*n_arg*. Defina como ``None`` para remover uma função agregada SQL existente."

#: ../../library/sqlite3.rst:758
msgid "A class must implement the following methods:"
msgstr ""

#: ../../library/sqlite3.rst:760
msgid "``step()``: Add a row to the aggregate."
msgstr ""

#: ../../library/sqlite3.rst:761 ../../library/sqlite3.rst:817
msgid ""
"``finalize()``: Return the final result of the aggregate as :ref:`a type "
"natively supported by SQLite <sqlite3-types>`."
msgstr ""

#: ../../library/sqlite3.rst:764
msgid ""
"The number of arguments that the ``step()`` method must accept is controlled "
"by *n_arg*."
msgstr ""
"O número de argumentos que o método ``step()`` deve aceitar é controlado por "
"*n_arg*."

#: ../../library/sqlite3.rst:767
msgid "Set to ``None`` to remove an existing SQL aggregate function."
msgstr "Defina como ``None`` para remover uma função agregada SQL existente."

#: ../../library/sqlite3.rst:772
msgid ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"
msgstr ""
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.execute(\"CREATE TABLE test(i)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(1)\")\n"
"cur.execute(\"INSERT INTO test(i) VALUES(2)\")\n"
"cur.execute(\"SELECT mysum(i) FROM test\")\n"
"print(cur.fetchone()[0])\n"
"\n"
"con.close()"

#: ../../library/sqlite3.rst:802
msgid "Create or remove a user-defined aggregate window function."
msgstr "Cria ou remove uma função agregada de janela definida pelo utilizador."

#: ../../library/sqlite3.rst:804
msgid "The name of the SQL aggregate window function to create or remove."
msgstr "O nome da função agregada de janela SQL a criar ou remover."

#: ../../library/sqlite3.rst:807
msgid ""
"The number of arguments the SQL aggregate window function can accept. If "
"``-1``, it may take any number of arguments."
msgstr ""
"O número de argumentos que a função agregada de janela SQL pode aceitar. Se "
"``-1``, pode aceitar qualquer número de argumentos."

#: ../../library/sqlite3.rst:811
msgid ""
"A class that must implement the following methods:  * ``step()``: Add a row "
"to the current window. * ``value()``: Return the current value of the "
"aggregate. * ``inverse()``: Remove a row from the current window. * "
"``finalize()``: Return the final result of the aggregate as   :ref:`a type "
"natively supported by SQLite <sqlite3-types>`.  The number of arguments that "
"the ``step()`` and ``value()`` methods must accept is controlled by "
"*num_params*.  Set to ``None`` to remove an existing SQL aggregate window "
"function."
msgstr ""
"Uma classe que deve implementar os seguintes métodos: * ``step()``: Adiciona "
"uma linha à janela atual. * ``value()``: Devolve o valor atual do agregado. "
"* ``inverse()``: Remove uma linha da janela atual. * ``finalize()``: Devolve "
"o resultado final do agregado como :ref:`um tipo nativamente suportado pelo "
"SQLite <sqlite3-types>`. O número de argumentos que os métodos ``step()`` e "
"``value()`` devem aceitar é controlado por *num_params*. Defina como "
"``None`` para remover uma função agregada de janela SQL existente."

#: ../../library/sqlite3.rst:812
msgid "A class that must implement the following methods:"
msgstr "Uma classe que deve implementar os seguintes métodos:"

#: ../../library/sqlite3.rst:814
msgid "``step()``: Add a row to the current window."
msgstr "``step()``: Adiciona uma linha à janela atual."

#: ../../library/sqlite3.rst:815
msgid "``value()``: Return the current value of the aggregate."
msgstr "``value()``: Devolve o valor atual do agregado."

#: ../../library/sqlite3.rst:816
msgid "``inverse()``: Remove a row from the current window."
msgstr "``inverse()``: Remove uma linha da janela atual."

#: ../../library/sqlite3.rst:820
msgid ""
"The number of arguments that the ``step()`` and ``value()`` methods must "
"accept is controlled by *num_params*."
msgstr ""
"O número de argumentos que os métodos ``step()`` e ``value()`` devem aceitar "
"é controlado por *num_params*."

#: ../../library/sqlite3.rst:823
msgid "Set to ``None`` to remove an existing SQL aggregate window function."
msgstr ""
"Defina como ``None`` para remover uma função agregada de janela SQL "
"existente."

#: ../../library/sqlite3.rst:825
msgid ""
"If used with a version of SQLite older than 3.25.0, which does not support "
"aggregate window functions."
msgstr ""
"Se usado com uma versão do SQLite anterior à 3.25.0, que não suporta funções "
"agregadas de janela."

#: ../../library/sqlite3.rst:835
msgid ""
"# Example taken from https://www.sqlite.org/windowfunctions.html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Add a row to the current window.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Return the current value of the aggregate.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove a row from the current window.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Return the final value of the aggregate.\n"
"\n"
"        Any clean-up actions should be placed here.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"# Exemplo retirado de https://www.sqlite.org/windowfunctions."
"html#udfwinfunc\n"
"class WindowSumInt:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        \"\"\"Adiciona uma linha à janela atual.\"\"\"\n"
"        self.count += value\n"
"\n"
"    def value(self):\n"
"        \"\"\"Devolve o valor atual do agregado.\"\"\"\n"
"        return self.count\n"
"\n"
"    def inverse(self, value):\n"
"        \"\"\"Remove uma linha da janela atual.\"\"\"\n"
"        self.count -= value\n"
"\n"
"    def finalize(self):\n"
"        \"\"\"Devolve o valor final do agregado.\n"
"\n"
"        Quaisquer ações de limpeza devem ser colocadas aqui.\n"
"        \"\"\"\n"
"        return self.count\n"
"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE test(x, y)\")\n"
"values = [\n"
"    (\"a\", 4),\n"
"    (\"b\", 5),\n"
"    (\"c\", 3),\n"
"    (\"d\", 8),\n"
"    (\"e\", 1),\n"
"]\n"
"cur.executemany(\"INSERT INTO test VALUES(?, ?)\", values)\n"
"con.create_window_function(\"sumint\", 1, WindowSumInt)\n"
"cur.execute(\"\"\"\n"
"    SELECT x, sumint(y) OVER (\n"
"        ORDER BY x ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n"
"    ) AS sum_y\n"
"    FROM test ORDER BY x\n"
"\"\"\")\n"
"print(cur.fetchall())\n"
"con.close()"

#: ../../library/sqlite3.rst:889
msgid ""
"Create a collation named *name* using the collating function *callable*. "
"*callable* is passed two :class:`string <str>` arguments, and it should "
"return an :class:`integer <int>`:"
msgstr ""
"Cria uma colação com o nome *name* usando a função de colação *callable*. "
"*callable* recebe dois argumentos :class:`string <str>`, e deve devolver um :"
"class:`integer <int>`:"

#: ../../library/sqlite3.rst:893
msgid "``1`` if the first is ordered higher than the second"
msgstr "``1`` se o primeiro for ordenado acima do segundo"

#: ../../library/sqlite3.rst:894
msgid "``-1`` if the first is ordered lower than the second"
msgstr "``-1`` se o primeiro for ordenado abaixo do segundo"

#: ../../library/sqlite3.rst:895
msgid "``0`` if they are ordered equal"
msgstr "``0`` se forem ordenados como iguais"

#: ../../library/sqlite3.rst:897
msgid "The following example shows a reverse sorting collation:"
msgstr "O seguinte exemplo mostra uma colação de ordenação inversa:"

#: ../../library/sqlite3.rst:899
msgid ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"
msgstr ""
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.execute(\"CREATE TABLE test(x)\")\n"
"cur.executemany(\"INSERT INTO test(x) VALUES(?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"SELECT x FROM test ORDER BY x COLLATE reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()"

#: ../../library/sqlite3.rst:925
msgid "Remove a collation function by setting *callable* to ``None``."
msgstr "Remove uma função de colação definindo *callable* como ``None``."

#: ../../library/sqlite3.rst:927
msgid ""
"The collation name can contain any Unicode character.  Earlier, only ASCII "
"characters were allowed."
msgstr ""
"O nome da colação pode conter qualquer carácter Unicode. Anteriormente, "
"apenas caracteres ASCII eram permitidos."

#: ../../library/sqlite3.rst:934
msgid ""
"Call this method from a different thread to abort any queries that might be "
"executing on the connection. Aborted queries will raise an :exc:"
"`OperationalError`."
msgstr ""
"Chame este método a partir de uma thread diferente para abortar quaisquer "
"consultas que possam estar a ser executadas na ligação. As consultas "
"abortadas lançarão um :exc:`OperationalError`."

#: ../../library/sqlite3.rst:941
msgid ""
"Register :term:`callable` *authorizer_callback* to be invoked for each "
"attempt to access a column of a table in the database. The callback should "
"return one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:"
"`SQLITE_IGNORE` to signal how access to the column should be handled by the "
"underlying SQLite library."
msgstr ""
"Regista um :term:`chamável` *authorizer_callback* para ser invocado em cada "
"tentativa de aceder a uma coluna de uma tabela na base de dados. O callback "
"deve devolver um de :const:`SQLITE_OK`, :const:`SQLITE_DENY`, ou :const:"
"`SQLITE_IGNORE` para sinalizar como o acesso à coluna deve ser tratado pela "
"biblioteca SQLite subjacente."

#: ../../library/sqlite3.rst:948
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or ``None`` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or ``None`` if this access attempt is directly from input SQL code."
msgstr ""

#: ../../library/sqlite3.rst:955
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`!sqlite3` "
"module."
msgstr ""
"Consulte a documentação do SQLite sobre os valores possíveis para o primeiro "
"argumento e o significado do segundo e terceiro argumentos dependendo do "
"primeiro. Todas as constantes necessárias estão disponíveis no módulo :mod:`!"
"sqlite3`."

#: ../../library/sqlite3.rst:959
msgid "Passing ``None`` as *authorizer_callback* will disable the authorizer."
msgstr "Passar ``None`` como *authorizer_callback* desativará o autorizador."

#: ../../library/sqlite3.rst:961
msgid "Added support for disabling the authorizer using ``None``."
msgstr "Adicionado suporte para desativar o autorizador usando ``None``."

#: ../../library/sqlite3.rst:967
msgid ""
"Register :term:`callable` *progress_handler* to be invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"Regista um :term:`chamável` *progress_handler* para ser invocado a cada *n* "
"instruções da máquina virtual SQLite. Isto é útil se quiser ser chamado a "
"partir do SQLite durante operações de longa duração, por exemplo, para "
"atualizar uma GUI."

#: ../../library/sqlite3.rst:972
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with ``None`` for *progress_handler*."
msgstr ""
"Se quiser limpar qualquer gestor de progresso previamente instalado, chame o "
"método com ``None`` para *progress_handler*."

#: ../../library/sqlite3.rst:975
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise a :exc:`DatabaseError` "
"exception."
msgstr ""
"Devolver um valor não zero a partir da função do gestor terminará a consulta "
"atualmente em execução e fará com que lance uma exceção :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:982
msgid ""
"Register :term:`callable` *trace_callback* to be invoked for each SQL "
"statement that is actually executed by the SQLite backend."
msgstr ""
"Regista um :term:`chamável` *trace_callback* para ser invocado para cada "
"declaração SQL que é realmente executada pelo backend SQLite."

#: ../../library/sqlite3.rst:985
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the :mod:`!sqlite3` module and the "
"execution of triggers defined in the current database."
msgstr ""
"O único argumento passado ao callback é a declaração (como :class:`str`) que "
"está a ser executada. O valor de retorno do callback é ignorado. Note que o "
"backend não executa apenas declarações passadas aos métodos :meth:`Cursor."
"execute`. Outras fontes incluem a :ref:`gestão de transações <sqlite3-"
"controlling-transactions>` do módulo :mod:`!sqlite3` e a execução de "
"gatilhos definidos na base de dados atual."

#: ../../library/sqlite3.rst:993
msgid "Passing ``None`` as *trace_callback* will disable the trace callback."
msgstr ""
"Passar ``None`` como *trace_callback* desativará o callback de rastreamento."

#: ../../library/sqlite3.rst:996
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Exceções lançadas no callback de rastreamento não são propagadas. Como "
"auxílio de desenvolvimento e depuração, use :meth:`~sqlite3."
"enable_callback_tracebacks` para ativar a impressão de tracebacks de "
"exceções lançadas no callback de rastreamento."

#: ../../library/sqlite3.rst:1006
msgid ""
"Enable the SQLite engine to load SQLite extensions from shared libraries if "
"*enabled* is ``True``; else, disallow loading SQLite extensions. SQLite "
"extensions can define new functions, aggregates or whole new virtual table "
"implementations.  One well-known extension is the fulltext-search extension "
"distributed with SQLite."
msgstr ""
"Permite que o motor SQLite carregue extensões SQLite a partir de bibliotecas "
"partilhadas se *enabled* for ``True``; caso contrário, impede o carregamento "
"de extensões SQLite. As extensões SQLite podem definir novas funções, "
"agregados ou implementações inteiras de novas tabelas virtuais. Uma extensão "
"bem conhecida é a extensão de pesquisa de texto completo distribuída com o "
"SQLite."

#: ../../library/sqlite3.rst:1015
msgid ""
"The :mod:`!sqlite3` module is not built with loadable extension support by "
"default, because some platforms (notably macOS) have SQLite libraries which "
"are compiled without this feature. To get loadable extension support, you "
"must pass the :option:`--enable-loadable-sqlite-extensions` option to :"
"program:`configure`."
msgstr ""
"O módulo :mod:`!sqlite3` não é construído com suporte para extensões "
"carregáveis por predefinição, porque algumas plataformas (notavelmente "
"macOS) têm bibliotecas SQLite que são compiladas sem esta funcionalidade. "
"Para obter suporte para extensões carregáveis, deve passar a opção :option:"
"`--enable-loadable-sqlite-extensions` para :program:`configure`."

#: ../../library/sqlite3.rst:1022
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.enable_load_extension`` "
"with arguments ``connection``, ``enabled``."
msgstr ""
"Gera um :ref:`evento de auditoria <auditing>` ``sqlite3."
"enable_load_extension`` com argumentos ``connection``, ``enabled``."

#: ../../library/sqlite3.rst:1026
msgid "Added the ``sqlite3.enable_load_extension`` auditing event."
msgstr "Adicionado o evento de auditoria ``sqlite3.enable_load_extension``."

#: ../../library/sqlite3.rst:1032
msgid ""
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension loading again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli "
"peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(row)"
msgstr ""
"con.enable_load_extension(True)\n"
"\n"
"# Carregar a extensão de pesquisa de texto completo\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternativamente pode carregar a extensão usando uma chamada de API:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# desativar o carregamento de extensões novamente\n"
"con.enable_load_extension(False)\n"
"\n"
"# exemplo da wiki do SQLite\n"
"con.execute(\"CREATE VIRTUAL TABLE recipe USING fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli stew', 'broccoli "
"peppers cheese tomatoes');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    INSERT INTO recipe (name, ingredients) VALUES('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"SELECT rowid, name, ingredients FROM recipe WHERE "
"name MATCH 'pie'\"):\n"
"    print(row)"

#: ../../library/sqlite3.rst:1058
msgid ""
"Load an SQLite extension from a shared library. Enable extension loading "
"with :meth:`enable_load_extension` before calling this method."
msgstr ""
"Carrega uma extensão SQLite a partir de uma biblioteca partilhada. Ative o "
"carregamento de extensões com :meth:`enable_load_extension` antes de chamar "
"este método."

#: ../../library/sqlite3.rst:1062
msgid "The path to the SQLite extension."
msgstr "O caminho para a extensão SQLite."

#: ../../library/sqlite3.rst:1066
msgid ""
"Entry point name. If ``None`` (the default), SQLite will come up with an "
"entry point name of its own; see the SQLite docs `Loading an Extension`_ for "
"details."
msgstr ""
"Nome do ponto de entrada. Se ``None`` (predefinição), o SQLite criará um "
"nome de ponto de entrada próprio; veja a documentação do SQLite `Loading an "
"Extension`_ para detalhes."

#: ../../library/sqlite3.rst:1075
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.load_extension`` with "
"arguments ``connection``, ``path``."
msgstr ""
"Gera um :ref:`evento de auditoria <auditing>` ``sqlite3.load_extension`` com "
"argumentos ``connection``, ``path``."

#: ../../library/sqlite3.rst:1079
msgid "Added the ``sqlite3.load_extension`` auditing event."
msgstr "Adicionado o evento de auditoria ``sqlite3.load_extension``."

#: ../../library/sqlite3.rst:1082
msgid "Added the *entrypoint* parameter."
msgstr "Adicionado o parâmetro *entrypoint*."

#: ../../library/sqlite3.rst:1089
msgid ""
"Return an :term:`iterator` to dump the database as SQL source code. Useful "
"when saving an in-memory database for later restoration. Similar to the ``."
"dump`` command in the :program:`sqlite3` shell."
msgstr ""
"Devolve um :term:`iterador` para despejar a base de dados como código-fonte "
"SQL. Útil ao guardar uma base de dados em memória para restauração "
"posterior. Semelhante ao comando ``.dump`` na shell :program:`sqlite3`."

#: ../../library/sqlite3.rst:1095
msgid ""
"# Convert file example.db to SQL dump file dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"
msgstr ""
"# Converter ficheiro example.db para ficheiro de despejo SQL dump.sql\n"
"con = sqlite3.connect('example.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)\n"
"con.close()"

#: ../../library/sqlite3.rst:1106 ../../library/sqlite3.rst:1178
msgid ":ref:`sqlite3-howto-encoding`"
msgstr ":ref:`sqlite3-howto-encoding`"

#: ../../library/sqlite3.rst:1111
msgid "Create a backup of an SQLite database."
msgstr "Cria uma cópia de segurança de uma base de dados SQLite."

#: ../../library/sqlite3.rst:1113
msgid ""
"Works even if the database is being accessed by other clients or "
"concurrently by the same connection."
msgstr ""
"Funciona mesmo se a base de dados estiver a ser acedida por outros clientes "
"ou concorrentemente pela mesma ligação."

#: ../../library/sqlite3.rst:1116
msgid "The database connection to save the backup to."
msgstr "A ligação à base de dados para onde salvar a cópia de segurança."

#: ../../library/sqlite3.rst:1119
msgid ""
"The number of pages to copy at a time. If equal to or less than ``0``, the "
"entire database is copied in a single step. Defaults to ``-1``."
msgstr ""
"O número de páginas a copiar de cada vez. Se igual ou inferior a ``0``, toda "
"a base de dados é copiada num único passo. Predefinição é ``-1``."

#: ../../library/sqlite3.rst:1125
msgid ""
"If set to a :term:`callable`, it is invoked with three integer arguments for "
"every backup iteration: the *status* of the last iteration, the *remaining* "
"number of pages still to be copied, and the *total* number of pages. "
"Defaults to ``None``."
msgstr ""
"Se definido como um :term:`chamável`, é invocado com três argumentos "
"inteiros para cada iteração de cópia de segurança: o *status* da última "
"iteração, o número *remaining* de páginas ainda a copiar, e o número *total* "
"de páginas. Predefinição é ``None``."

#: ../../library/sqlite3.rst:1134
msgid ""
"The name of the database to back up. Either ``\"main\"`` (the default) for "
"the main database, ``\"temp\"`` for the temporary database, or the name of a "
"custom database as attached using the ``ATTACH DATABASE`` SQL statement."
msgstr ""
"O nome da base de dados para fazer cópia de segurança. Ou ``\"main\"`` "
"(predefinição) para a base de dados principal, ``\"temp\"`` para a base de "
"dados temporária, ou o nome de uma base de dados personalizada como anexada "
"usando a declaração SQL ``ATTACH DATABASE``."

#: ../../library/sqlite3.rst:1141
msgid ""
"The number of seconds to sleep between successive attempts to back up "
"remaining pages."
msgstr ""
"O número de segundos a dormir entre tentativas sucessivas para fazer cópia "
"de segurança das páginas restantes."

#: ../../library/sqlite3.rst:1145
msgid "Example 1, copy an existing database into another:"
msgstr "Exemplo 1, copiar uma base de dados existente para outra:"

#: ../../library/sqlite3.rst:1147
msgid ""
"def progress(status, remaining, total):\n"
"    print(f'Copied {total-remaining} of {total} pages...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"def progress(status, remaining, total):\n"
"    print(f'Copiadas {total-remaining} de {total} páginas...')\n"
"\n"
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect('backup.db')\n"
"with dst:\n"
"    src.backup(dst, pages=1, progress=progress)\n"
"dst.close()\n"
"src.close()"

#: ../../library/sqlite3.rst:1164
msgid "Example 2, copy an existing database into a transient copy:"
msgstr ""
"Exemplo 2, copiar uma base de dados existente para uma cópia transitória:"

#: ../../library/sqlite3.rst:1166
msgid ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"
msgstr ""
"src = sqlite3.connect('example.db')\n"
"dst = sqlite3.connect(':memory:')\n"
"src.backup(dst)\n"
"dst.close()\n"
"src.close()"

#: ../../library/sqlite3.rst:1182
msgid "Get a connection runtime limit."
msgstr "Obtém um limite de tempo de execução de uma ligação."

#: ../../library/sqlite3.rst:1184
msgid "The `SQLite limit category`_ to be queried."
msgstr "A `categoria de limite SQLite`_ a ser consultada."

#: ../../library/sqlite3.rst:1189 ../../library/sqlite3.rst:1226
msgid "If *category* is not recognised by the underlying SQLite library."
msgstr "Se *category* não for reconhecida pela biblioteca SQLite subjacente."

#: ../../library/sqlite3.rst:1192
msgid ""
"Example, query the maximum length of an SQL statement for :class:"
"`Connection` ``con`` (the default is 1000000000):"
msgstr ""
"Exemplo, consultar o comprimento máximo de uma declaração SQL para :class:"
"`Connection` ``con`` (a predefinição é 1000000000):"

#: ../../library/sqlite3.rst:1202
msgid ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"
msgstr ""
">>> con.getlimit(sqlite3.SQLITE_LIMIT_SQL_LENGTH)\n"
"1000000000"

#: ../../library/sqlite3.rst:1212
msgid ""
"Set a connection runtime limit. Attempts to increase a limit above its hard "
"upper bound are silently truncated to the hard upper bound. Regardless of "
"whether or not the limit was changed, the prior value of the limit is "
"returned."
msgstr ""
"Define um limite de tempo de execução de uma ligação. Tentativas de aumentar "
"um limite acima do seu limite superior rígido são silenciosamente truncadas "
"para o limite superior rígido. Independentemente de o limite ter sido "
"alterado ou não, o valor anterior do limite é devolvido."

#: ../../library/sqlite3.rst:1217
msgid "The `SQLite limit category`_ to be set."
msgstr "A `categoria de limite SQLite`_ a ser definida."

#: ../../library/sqlite3.rst:1220
msgid ""
"The value of the new limit. If negative, the current limit is unchanged."
msgstr ""
"O valor do novo limite. Se negativo, o limite atual permanece inalterado."

#: ../../library/sqlite3.rst:1229
msgid ""
"Example, limit the number of attached databases to 1 for :class:`Connection` "
"``con`` (the default limit is 10):"
msgstr ""
"Exemplo, limitar o número de bases de dados anexadas a 1 para :class:"
"`Connection` ``con`` (o limite predefinido é 10):"

#: ../../library/sqlite3.rst:1232
msgid ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"
msgstr ""
">>> con.setlimit(sqlite3.SQLITE_LIMIT_ATTACHED, 1)\n"
"10\n"
">>> con.getlimit(sqlite3.SQLITE_LIMIT_ATTACHED)\n"
"1"

#: ../../library/sqlite3.rst:1250
msgid "Query a boolean connection configuration option."
msgstr "Consulta uma opção de configuração booleana de ligação."

#: ../../library/sqlite3.rst:1252 ../../library/sqlite3.rst:1263
msgid "A :ref:`SQLITE_DBCONFIG code <sqlite3-dbconfig-constants>`."
msgstr "Um :ref:`código SQLITE_DBCONFIG <sqlite3-dbconfig-constants>`."

#: ../../library/sqlite3.rst:1261
msgid "Set a boolean connection configuration option."
msgstr "Define uma opção de configuração booleana de ligação."

#: ../../library/sqlite3.rst:1266
msgid ""
"``True`` if the configuration option should be enabled (default); ``False`` "
"if it should be disabled."
msgstr ""
"``True`` se a opção de configuração deve ser ativada (predefinição); "
"``False`` se deve ser desativada."

#: ../../library/sqlite3.rst:1274
msgid ""
"Serialize a database into a :class:`bytes` object.  For an ordinary on-disk "
"database file, the serialization is just a copy of the disk file.  For an in-"
"memory database or a \"temp\" database, the serialization is the same "
"sequence of bytes which would be written to disk if that database were "
"backed up to disk."
msgstr ""
"Serializa uma base de dados num objeto :class:`bytes`. Para um ficheiro de "
"base de dados em disco normal, a serialização é apenas uma cópia do ficheiro "
"em disco. Para uma base de dados em memória ou uma base de dados \"temp\", a "
"serialização é a mesma sequência de bytes que seria escrita em disco se essa "
"base de dados fosse guardada em disco."

#: ../../library/sqlite3.rst:1280
msgid "The database name to be serialized. Defaults to ``\"main\"``."
msgstr ""
"O nome da base de dados a ser serializada. Predefinição é ``\"main\"``."

#: ../../library/sqlite3.rst:1288
msgid ""
"This method is only available if the underlying SQLite library has the "
"serialize API."
msgstr ""
"Este método só está disponível se a biblioteca SQLite subjacente tiver a API "
"serialize."

#: ../../library/sqlite3.rst:1296
msgid ""
"Deserialize a :meth:`serialized <serialize>` database into a :class:"
"`Connection`. This method causes the database connection to disconnect from "
"database *name*, and reopen *name* as an in-memory database based on the "
"serialization contained in *data*."
msgstr ""
"Desserializa uma base de dados :meth:`serializada <serialize>` numa :class:"
"`Connection`. Este método faz com que a ligação à base de dados se "
"desconecte da base de dados *name* e reabra *name* como uma base de dados em "
"memória baseada na serialização contida em *data*."

#: ../../library/sqlite3.rst:1302
msgid "A serialized database."
msgstr "Uma base de dados serializada."

#: ../../library/sqlite3.rst:1305
msgid "The database name to deserialize into. Defaults to ``\"main\"``."
msgstr ""
"O nome da base de dados para desserializar. Predefinição é ``\"main\"``."

#: ../../library/sqlite3.rst:1309
msgid ""
"If the database connection is currently involved in a read transaction or a "
"backup operation."
msgstr ""
"Se a ligação à base de dados estiver atualmente envolvida numa transação de "
"leitura ou numa operação de cópia de segurança."

#: ../../library/sqlite3.rst:1313
msgid "If *data* does not contain a valid SQLite database."
msgstr "Se *data* não contiver uma base de dados SQLite válida."

#: ../../library/sqlite3.rst:1316
msgid "If :func:`len(data) <len>` is larger than ``2**63 - 1``."
msgstr "Se :func:`len(data) <len>` for maior que ``2**63 - 1``."

#: ../../library/sqlite3.rst:1321
msgid ""
"This method is only available if the underlying SQLite library has the "
"deserialize API."
msgstr ""
"Este método só está disponível se a biblioteca SQLite subjacente tiver a API "
"deserialize."

#: ../../library/sqlite3.rst:1328
msgid ""
"This attribute controls :pep:`249`-compliant transaction behaviour. :attr:`!"
"autocommit` has three allowed values:"
msgstr ""
"Este atributo controla o comportamento de transações compatível com :pep:"
"`249`. :attr:`!autocommit` tem três valores permitidos:"

#: ../../library/sqlite3.rst:1331
msgid ""
"``False``: Select :pep:`249`-compliant transaction behaviour, implying that :"
"mod:`!sqlite3` ensures a transaction is always open. Use :meth:`commit` and :"
"meth:`rollback` to close transactions."
msgstr ""
"``False``: Seleciona o comportamento de transações compatível com :pep:"
"`249`, implicando que :mod:`!sqlite3` garante que uma transação está sempre "
"aberta. Use :meth:`commit` e :meth:`rollback` para fechar transações."

#: ../../library/sqlite3.rst:1335
msgid "This is the recommended value of :attr:`!autocommit`."
msgstr "Este é o valor recomendado de :attr:`!autocommit`."

#: ../../library/sqlite3.rst:1337
msgid ""
"``True``: Use SQLite's `autocommit mode`_. :meth:`commit` and :meth:"
"`rollback` have no effect in this mode."
msgstr ""
"``True``: Usa o `modo autocommit`_ do SQLite. :meth:`commit` e :meth:"
"`rollback` não têm efeito neste modo."

#: ../../library/sqlite3.rst:1340
msgid ""
":data:`LEGACY_TRANSACTION_CONTROL`: Pre-Python 3.12 (non-:pep:`249`-"
"compliant) transaction control. See :attr:`isolation_level` for more details."
msgstr ""
":data:`LEGACY_TRANSACTION_CONTROL`: Controlo de transações pré-Python 3.12 "
"(não compatível com :pep:`249`). Veja :attr:`isolation_level` para mais "
"detalhes."

#: ../../library/sqlite3.rst:1344
msgid "This is currently the default value of :attr:`!autocommit`."
msgstr "Este é atualmente o valor predefinido de :attr:`!autocommit`."

#: ../../library/sqlite3.rst:1346
msgid ""
"Changing :attr:`!autocommit` to ``False`` will open a new transaction, and "
"changing it to ``True`` will commit any pending transaction."
msgstr ""
"Alterar :attr:`!autocommit` para ``False`` abrirá uma nova transação, e "
"alterá-lo para ``True`` confirmará qualquer transação pendente."

#: ../../library/sqlite3.rst:1349
msgid "See :ref:`sqlite3-transaction-control-autocommit` for more details."
msgstr "Veja :ref:`sqlite3-transaction-control-autocommit` para mais detalhes."

#: ../../library/sqlite3.rst:1353
msgid ""
"The :attr:`isolation_level` attribute has no effect unless :attr:"
"`autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`."
msgstr ""
"O atributo :attr:`isolation_level` não tem efeito a menos que :attr:"
"`autocommit` seja :data:`LEGACY_TRANSACTION_CONTROL`."

#: ../../library/sqlite3.rst:1360
msgid ""
"This read-only attribute corresponds to the low-level SQLite `autocommit "
"mode`_."
msgstr ""
"Este atributo de apenas leitura corresponde ao modo autocommit de baixo "
"nível do SQLite."

#: ../../library/sqlite3.rst:1363
msgid ""
"``True`` if a transaction is active (there are uncommitted changes), "
"``False`` otherwise."
msgstr ""
"``True`` se uma transação estiver ativa (há alterações não confirmadas), "
"``False`` caso contrário."

#: ../../library/sqlite3.rst:1370
msgid ""
"Controls the :ref:`legacy transaction handling mode <sqlite3-transaction-"
"control-isolation-level>` of :mod:`!sqlite3`. If set to ``None``, "
"transactions are never implicitly opened. If set to one of ``\"DEFERRED\"``, "
"``\"IMMEDIATE\"``, or ``\"EXCLUSIVE\"``, corresponding to the underlying "
"`SQLite transaction behaviour`_, :ref:`implicit transaction management "
"<sqlite3-transaction-control-isolation-level>` is performed."
msgstr ""
"Controla o :ref:`modo de manipulação de transações legado <sqlite3-"
"transaction-control-isolation-level>` do :mod:`!sqlite3`. Se definido como "
"``None``, as transações nunca são abertas implicitamente. Se definido como "
"um de ``\"DEFERRED\"``, ``\"IMMEDIATE\"``, ou ``\"EXCLUSIVE\"``, "
"correspondendo ao comportamento de transação subjacente `SQLite transaction "
"behaviour`_, é realizada a :ref:`gestão implícita de transações <sqlite3-"
"transaction-control-isolation-level>`."

#: ../../library/sqlite3.rst:1378
msgid ""
"If not overridden by the *isolation_level* parameter of :func:`connect`, the "
"default is ``\"\"``, which is an alias for ``\"DEFERRED\"``."
msgstr ""
"Se não for substituído pelo parâmetro *isolation_level* de :func:`connect`, "
"a predefinição é ``\"\"``, que é um alias para ``\"DEFERRED\"``."

#: ../../library/sqlite3.rst:1383
msgid ""
"Using :attr:`autocommit` to control transaction handling is recommended over "
"using :attr:`!isolation_level`. :attr:`!isolation_level` has no effect "
"unless :attr:`autocommit` is set to :data:`LEGACY_TRANSACTION_CONTROL` (the "
"default)."
msgstr ""
"Recomenda-se o uso de :attr:`autocommit` para controlar a manipulação de "
"transações em vez de usar :attr:`!isolation_level`. :attr:`!isolation_level` "
"não tem efeito a menos que :attr:`autocommit` esteja definido para :data:"
"`LEGACY_TRANSACTION_CONTROL` (a predefinição)."

#: ../../library/sqlite3.rst:1390
msgid ""
"The initial :attr:`~Cursor.row_factory` for :class:`Cursor` objects created "
"from this connection. Assigning to this attribute does not affect the :attr:"
"`!row_factory` of existing cursors belonging to this connection, only new "
"ones. Is ``None`` by default, meaning each row is returned as a :class:"
"`tuple`."
msgstr ""
"A :attr:`~Cursor.row_factory` inicial para objetos :class:`Cursor` criados a "
"partir desta ligação. Atribuir a este atributo não afeta a :attr:`!"
"row_factory` de cursores existentes pertencentes a esta ligação, apenas os "
"novos. É ``None`` por predefinição, o que significa que cada linha é "
"devolvida como um :class:`tuple`."

#: ../../library/sqlite3.rst:1397 ../../library/sqlite3.rst:1683
#: ../../library/sqlite3.rst:1706
msgid "See :ref:`sqlite3-howto-row-factory` for more details."
msgstr "Veja :ref:`sqlite3-howto-row-factory` para mais detalhes."

#: ../../library/sqlite3.rst:1401
msgid ""
"A :term:`callable` that accepts a :class:`bytes` parameter and returns a "
"text representation of it. The callable is invoked for SQLite values with "
"the ``TEXT`` data type. By default, this attribute is set to :class:`str`."
msgstr ""
"Um :term:`chamável` que aceita um parâmetro :class:`bytes` e devolve uma "
"representação de texto do mesmo. O chamável é invocado para valores SQLite "
"com o tipo de dados ``TEXT``. Por predefinição, este atributo está definido "
"para :class:`str`."

#: ../../library/sqlite3.rst:1406
msgid "See :ref:`sqlite3-howto-encoding` for more details."
msgstr "Veja :ref:`sqlite3-howto-encoding` para mais detalhes."

#: ../../library/sqlite3.rst:1410
msgid ""
"Return the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Devolve o número total de linhas de base de dados que foram modificadas, "
"inseridas ou eliminadas desde que a ligação à base de dados foi aberta."

#: ../../library/sqlite3.rst:1417
msgid "Cursor objects"
msgstr "Objetos Cursor"

#: ../../library/sqlite3.rst:1419
msgid ""
"A ``Cursor`` object represents a `database cursor`_ which is used to execute "
"SQL statements, and manage the context of a fetch operation. Cursors are "
"created using :meth:`Connection.cursor`, or by using any of the :ref:"
"`connection shortcut methods <sqlite3-connection-shortcuts>`."
msgstr ""
"Um objeto ``Cursor`` representa um `cursor de base de dados`_ que é usado "
"para executar declarações SQL e gerir o contexto de uma operação de busca. "
"Os cursores são criados usando :meth:`Connection.cursor`, ou usando qualquer "
"um dos :ref:`métodos de atalho de ligação <sqlite3-connection-shortcuts>`."

#: ../../library/sqlite3.rst:1426
msgid ""
"Cursor objects are :term:`iterators <iterator>`, meaning that if you :meth:"
"`~Cursor.execute` a ``SELECT`` query, you can simply iterate over the cursor "
"to fetch the resulting rows:"
msgstr ""
"Os objetos Cursor são :term:`iteradores <iterator>`, o que significa que se "
"executar uma consulta ``SELECT`` com :meth:`~Cursor.execute`, pode "
"simplesmente iterar sobre o cursor para buscar as linhas resultantes:"

#: ../../library/sqlite3.rst:1437
msgid ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"
msgstr ""
"for row in cur.execute(\"SELECT t FROM data\"):\n"
"    print(row)"

#: ../../library/sqlite3.rst:1451
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "Uma instância :class:`Cursor` tem os seguintes atributos e métodos."

#: ../../library/sqlite3.rst:1458
msgid ""
"Execute a single SQL statement, optionally binding Python values using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""
"Executa uma única declaração SQL, opcionalmente ligando valores Python "
"usando :ref:`placeholders <sqlite3-placeholders>`."

#: ../../library/sqlite3.rst:1462
msgid "A single SQL statement."
msgstr "Uma única declaração SQL."

#: ../../library/sqlite3.rst:1465
msgid ""
"Python values to bind to placeholders in *sql*. A :class:`!dict` if named "
"placeholders are used. A :term:`!sequence` if unnamed placeholders are used. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"Valores Python para ligar a placeholders em *sql*. Um :class:`!dict` se "
"forem usados placeholders nomeados. Uma :term:`!sequence` se forem usados "
"placeholders não nomeados. Veja :ref:`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1472
msgid "If *sql* contains more than one SQL statement."
msgstr ""

#: ../../library/sqlite3.rst:1475
msgid ""
"If :attr:`~Connection.autocommit` is :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` is not ``None``, *sql* is an ``INSERT``, "
"``UPDATE``, ``DELETE``, or ``REPLACE`` statement, and there is no open "
"transaction, a transaction is implicitly opened before executing *sql*."
msgstr ""
"Se :attr:`~Connection.autocommit` for :data:`LEGACY_TRANSACTION_CONTROL`, :"
"attr:`~Connection.isolation_level` não for ``None``, *sql* for uma "
"declaração ``INSERT``, ``UPDATE``, ``DELETE``, ou ``REPLACE``, e não houver "
"nenhuma transação aberta, uma transação é implicitamente aberta antes de "
"executar *sql*."

#: ../../library/sqlite3.rst:1484
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and *parameters* is a sequence instead of a :class:"
"`dict`. Starting with Python 3.14, :exc:`ProgrammingError` will be raised "
"instead."
msgstr ""

#: ../../library/sqlite3.rst:1490
msgid "Use :meth:`executescript` to execute multiple SQL statements."
msgstr "Use :meth:`executescript` para executar múltiplas declarações SQL."

#: ../../library/sqlite3.rst:1494
msgid ""
"For every item in *parameters*, repeatedly execute the :ref:`parameterized "
"<sqlite3-placeholders>` :abbr:`DML (Data Manipulation Language)` SQL "
"statement *sql*."
msgstr ""
"Para cada item em *parameters*, execute repetidamente a declaração SQL :abbr:"
"`DML (Data Manipulation Language)` :ref:`parametrizada <sqlite3-"
"placeholders>` *sql*."

#: ../../library/sqlite3.rst:1498
msgid "Uses the same implicit transaction handling as :meth:`~Cursor.execute`."
msgstr ""
"Usa o mesmo manuseamento implícito de transações que :meth:`~Cursor.execute`."

#: ../../library/sqlite3.rst:1500
msgid "A single SQL DML statement."
msgstr "Uma única declaração SQL DML."

#: ../../library/sqlite3.rst:1503
msgid ""
"An :term:`!iterable` of parameters to bind with the placeholders in *sql*. "
"See :ref:`sqlite3-placeholders`."
msgstr ""
"Um :term:`!iterable` de parâmetros para ligar com os placeholders em *sql*. "
"Veja :ref:`sqlite3-placeholders`."

#: ../../library/sqlite3.rst:1509
msgid ""
"If *sql* contains more than one SQL statement, or is not a DML statement."
msgstr ""

#: ../../library/sqlite3.rst:1515
msgid ""
"rows = [\n"
"    (\"row1\",),\n"
"    (\"row2\",),\n"
"]\n"
"# cur is an sqlite3.Cursor object\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"
msgstr ""
"rows = [\n"
"    (\"linha1\",),\n"
"    (\"linha2\",),\n"
"]\n"
"# cur é um objeto sqlite3.Cursor\n"
"cur.executemany(\"INSERT INTO data VALUES(?)\", rows)"

#: ../../library/sqlite3.rst:1530
msgid ""
"Any resulting rows are discarded, including DML statements with `RETURNING "
"clauses`_."
msgstr ""
"Quaisquer linhas resultantes são descartadas, incluindo declarações DML com "
"`cláusulas RETURNING`_."

#: ../../library/sqlite3.rst:1537
msgid ""
":exc:`DeprecationWarning` is emitted if :ref:`named placeholders <sqlite3-"
"placeholders>` are used and the items in *parameters* are sequences instead "
"of :class:`dict`\\s. Starting with Python 3.14, :exc:`ProgrammingError` will "
"be raised instead."
msgstr ""

#: ../../library/sqlite3.rst:1546
msgid ""
"Execute the SQL statements in *sql_script*. If the :attr:`~Connection."
"autocommit` is :data:`LEGACY_TRANSACTION_CONTROL` and there is a pending "
"transaction, an implicit ``COMMIT`` statement is executed first. No other "
"implicit transaction control is performed; any transaction control must be "
"added to *sql_script*."
msgstr ""
"Executa as declarações SQL em *sql_script*. Se :attr:`~Connection."
"autocommit` for :data:`LEGACY_TRANSACTION_CONTROL` e houver uma transação "
"pendente, uma declaração ``COMMIT`` implícita é executada primeiro. Nenhum "
"outro controlo de transação implícito é realizado; qualquer controlo de "
"transação deve ser adicionado a *sql_script*."

#: ../../library/sqlite3.rst:1554
msgid "*sql_script* must be a :class:`string <str>`."
msgstr "*sql_script* deve ser uma :class:`string <str>`."

#: ../../library/sqlite3.rst:1558
msgid ""
"# cur is an sqlite3.Cursor object\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"
msgstr ""
"# cur é um objeto sqlite3.Cursor\n"
"cur.executescript(\"\"\"\n"
"    BEGIN;\n"
"    CREATE TABLE person(firstname, lastname, age);\n"
"    CREATE TABLE book(title, author, published);\n"
"    CREATE TABLE publisher(name, address);\n"
"    COMMIT;\n"
"\"\"\")"

#: ../../library/sqlite3.rst:1571
msgid ""
"If :attr:`~Cursor.row_factory` is ``None``, return the next row query result "
"set as a :class:`tuple`. Else, pass it to the row factory and return its "
"result. Return ``None`` if no more data is available."
msgstr ""
"Se :attr:`~Cursor.row_factory` for ``None``, devolve o próximo conjunto de "
"resultados da consulta como um :class:`tuple`. Caso contrário, passa-o para "
"a fábrica de linhas e devolve o seu resultado. Devolve ``None`` se não "
"houver mais dados disponíveis."

#: ../../library/sqlite3.rst:1579
msgid ""
"Return the next set of rows of a query result as a :class:`list`. Return an "
"empty list if no more rows are available."
msgstr ""
"Devolve o próximo conjunto de linhas de um resultado de consulta como uma :"
"class:`list`. Devolve uma lista vazia se não houver mais linhas disponíveis."

#: ../../library/sqlite3.rst:1582
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If *size* is not given, :attr:`arraysize` determines the number of rows to "
"be fetched. If fewer than *size* rows are available, as many rows as are "
"available are returned."
msgstr ""
"O número de linhas a buscar por chamada é especificado pelo parâmetro "
"*size*. Se *size* não for fornecido, :attr:`arraysize` determina o número de "
"linhas a buscar. Se houver menos linhas do que *size*, são devolvidas todas "
"as linhas disponíveis."

#: ../../library/sqlite3.rst:1588
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Note que existem considerações de desempenho envolvidas com o parâmetro "
"*size*. Para um desempenho ideal, é geralmente melhor usar o atributo "
"arraysize. Se o parâmetro *size* for usado, é melhor que mantenha o mesmo "
"valor de uma chamada :meth:`fetchmany` para a seguinte."

#: ../../library/sqlite3.rst:1595
msgid ""
"Return all (remaining) rows of a query result as a :class:`list`. Return an "
"empty list if no rows are available. Note that the :attr:`arraysize` "
"attribute can affect the performance of this operation."
msgstr ""
"Devolve todas as (restantes) linhas de um resultado de consulta como uma :"
"class:`list`. Devolve uma lista vazia se não houver linhas disponíveis. Note "
"que o atributo :attr:`arraysize` pode afetar o desempenho desta operação."

#: ../../library/sqlite3.rst:1602
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Fecha o cursor agora (em vez de quando ``__del__`` for chamado)."

#: ../../library/sqlite3.rst:1604
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"O cursor não poderá ser usado a partir deste ponto; uma exceção :exc:"
"`ProgrammingError` será lançada se alguma operação for tentada com o cursor."

#: ../../library/sqlite3.rst:1609 ../../library/sqlite3.rst:1613
msgid "Required by the DB-API. Does nothing in :mod:`!sqlite3`."
msgstr "Requerido pela DB-API. Não faz nada em :mod:`!sqlite3`."

#: ../../library/sqlite3.rst:1617
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Atributo de leitura/escrita que controla o número de linhas devolvidas por :"
"meth:`fetchmany`. O valor predefinido é 1, o que significa que uma única "
"linha seria buscada por chamada."

#: ../../library/sqlite3.rst:1622
msgid ""
"Read-only attribute that provides the SQLite database :class:`Connection` "
"belonging to the cursor.  A :class:`Cursor` object created by calling :meth:"
"`con.cursor() <Connection.cursor>` will have a :attr:`connection` attribute "
"that refers to *con*:"
msgstr ""
"Atributo de apenas leitura que fornece a ligação :class:`Connection` à base "
"de dados SQLite pertencente ao cursor. Um objeto :class:`Cursor` criado "
"chamando :meth:`con.cursor() <Connection.cursor>` terá um atributo :attr:"
"`connection` que se refere a *con*:"

#: ../../library/sqlite3.rst:1627
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> cur = con.cursor()\n"
">>> cur.connection == con\n"
"True\n"
">>> con.close()"

#: ../../library/sqlite3.rst:1637
msgid ""
"Read-only attribute that provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are ``None``."
msgstr ""
"Atributo de apenas leitura que fornece os nomes das colunas da última "
"consulta. Para permanecer compatível com a API de Base de Dados do Python, "
"devolve um 7-tuplo para cada coluna, onde os últimos seis itens de cada "
"tuplo são ``None``."

#: ../../library/sqlite3.rst:1641
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Também é definido para declarações ``SELECT`` sem quaisquer linhas "
"correspondentes."

#: ../../library/sqlite3.rst:1645
msgid ""
"Read-only attribute that provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is "
"``None``."
msgstr ""
"Atributo de apenas leitura que fornece o ID da última linha inserida. Só é "
"atualizado após declarações ``INSERT`` ou ``REPLACE`` bem-sucedidas usando o "
"método :meth:`execute`. Para outras declarações, após :meth:`executemany` "
"ou :meth:`executescript`, ou se a inserção falhou, o valor de ``lastrowid`` "
"permanece inalterado. O valor inicial de ``lastrowid`` é ``None``."

#: ../../library/sqlite3.rst:1653
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Inserções em tabelas ``WITHOUT ROWID`` não são registadas."

#: ../../library/sqlite3.rst:1655
msgid "Added support for the ``REPLACE`` statement."
msgstr "Adicionado suporte para a declaração ``REPLACE``."

#: ../../library/sqlite3.rst:1660
msgid ""
"Read-only attribute that provides the number of modified rows for "
"``INSERT``, ``UPDATE``, ``DELETE``, and ``REPLACE`` statements; is ``-1`` "
"for other statements, including :abbr:`CTE (Common Table Expression)` "
"queries. It is only updated by the :meth:`execute` and :meth:`executemany` "
"methods, after the statement has run to completion. This means that any "
"resulting rows must be fetched in order for :attr:`!rowcount` to be updated."
msgstr ""
"Atributo de apenas leitura que fornece o número de linhas modificadas para "
"declarações ``INSERT``, ``UPDATE``, ``DELETE`` e ``REPLACE``; é ``-1`` para "
"outras declarações, incluindo consultas :abbr:`CTE (Common Table "
"Expression)`. Só é atualizado pelos métodos :meth:`execute` e :meth:"
"`executemany`, após a declaração ter sido executada até ao fim. Isto "
"significa que quaisquer linhas resultantes devem ser buscadas para que :attr:"
"`!rowcount` seja atualizado."

#: ../../library/sqlite3.rst:1671
msgid ""
"Control how a row fetched from this :class:`!Cursor` is represented. If "
"``None``, a row is represented as a :class:`tuple`. Can be set to the "
"included :class:`sqlite3.Row`; or a :term:`callable` that accepts two "
"arguments, a :class:`Cursor` object and the :class:`!tuple` of row values, "
"and returns a custom object representing an SQLite row."
msgstr ""
"Controla como uma linha buscada a partir deste :class:`!Cursor` é "
"representada. Se ``None``, uma linha é representada como um :class:`tuple`. "
"Pode ser definido para o :class:`sqlite3.Row` incluído; ou um :term:"
"`chamável` que aceita dois argumentos, um objeto :class:`Cursor` e o :class:"
"`!tuple` de valores da linha, e devolve um objeto personalizado que "
"representa uma linha SQLite."

#: ../../library/sqlite3.rst:1678
msgid ""
"Defaults to what :attr:`Connection.row_factory` was set to when the :class:`!"
"Cursor` was created. Assigning to this attribute does not affect :attr:"
"`Connection.row_factory` of the parent connection."
msgstr ""
"Por predefinição, é o que :attr:`Connection.row_factory` estava definido "
"quando o :class:`!Cursor` foi criado. Atribuir a este atributo não afeta :"
"attr:`Connection.row_factory` da ligação pai."

#: ../../library/sqlite3.rst:1694
msgid "Row objects"
msgstr "Objetos Row"

#: ../../library/sqlite3.rst:1698
msgid ""
"A :class:`!Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It supports iteration, "
"equality testing, :func:`len`, and :term:`mapping` access by column name and "
"index."
msgstr ""
"Uma instância :class:`!Row` serve como uma fábrica de linhas :attr:"
"`~Connection.row_factory` altamente otimizada para objetos :class:"
"`Connection`. Suporta iteração, teste de igualdade, :func:`len` e acesso de :"
"term:`mapeamento` por nome de coluna e índice."

#: ../../library/sqlite3.rst:1703
msgid ""
"Two :class:`!Row` objects compare equal if they have identical column names "
"and values."
msgstr ""
"Dois objetos :class:`!Row` são considerados iguais se tiverem nomes de "
"colunas e valores idênticos."

#: ../../library/sqlite3.rst:1710
msgid ""
"Return a :class:`list` of column names as :class:`strings <str>`. "
"Immediately after a query, it is the first member of each tuple in :attr:"
"`Cursor.description`."
msgstr ""
"Devolve uma :class:`list` de nomes de colunas como :class:`strings <str>`. "
"Imediatamente após uma consulta, é o primeiro membro de cada tuplo em :attr:"
"`Cursor.description`."

#: ../../library/sqlite3.rst:1714
msgid "Added support of slicing."
msgstr "Adicionado suporte para fatiamento."

#: ../../library/sqlite3.rst:1721
msgid "Blob objects"
msgstr "Objetos Blob"

#: ../../library/sqlite3.rst:1727
msgid ""
"A :class:`Blob` instance is a :term:`file-like object` that can read and "
"write data in an SQLite :abbr:`BLOB (Binary Large OBject)`. Call :func:"
"`len(blob) <len>` to get the size (number of bytes) of the blob. Use indices "
"and :term:`slices <slice>` for direct access to the blob data."
msgstr ""
"Uma instância :class:`Blob` é um :term:`objeto tipo ficheiro` que pode ler e "
"escrever dados num :abbr:`BLOB (Binary Large OBject)` do SQLite. Chame :func:"
"`len(blob) <len>` para obter o tamanho (número de bytes) do blob. Use "
"índices e :term:`fatias <slice>` para acesso direto aos dados do blob."

#: ../../library/sqlite3.rst:1732
msgid ""
"Use the :class:`Blob` as a :term:`context manager` to ensure that the blob "
"handle is closed after use."
msgstr ""
"Use o :class:`Blob` como um :term:`gestor de contexto` para garantir que o "
"identificador do blob é fechado após o uso."

#: ../../library/sqlite3.rst:1735
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Write to our blob, using two write operations:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"hello, \")\n"
"    blob.write(b\"world.\")\n"
"    # Modify the first and last bytes of our blob\n"
"    blob[0] = ord(\"H\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Read the contents of our blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    greeting = blob.read()\n"
"\n"
"print(greeting)  # outputs \"b'Hello, world!'\"\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE test(blob_col blob)\")\n"
"con.execute(\"INSERT INTO test(blob_col) VALUES(zeroblob(13))\")\n"
"\n"
"# Escrever no nosso blob, usando duas operações de escrita:\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    blob.write(b\"olá, \")\n"
"    blob.write(b\"mundo.\")\n"
"    # Modificar o primeiro e o último byte do nosso blob\n"
"    blob[0] = ord(\"O\")\n"
"    blob[-1] = ord(\"!\")\n"
"\n"
"# Ler o conteúdo do nosso blob\n"
"with con.blobopen(\"test\", \"blob_col\", 1) as blob:\n"
"    saudacao = blob.read()\n"
"\n"
"print(saudacao)  # produz \"b'Olá, mundo!'\"\n"
"con.close()"

#: ../../library/sqlite3.rst:1763
msgid "Close the blob."
msgstr "Fecha o blob."

#: ../../library/sqlite3.rst:1765
msgid ""
"The blob will be unusable from this point onward.  An :class:`~sqlite3."
"Error` (or subclass) exception will be raised if any further operation is "
"attempted with the blob."
msgstr ""
"O blob não poderá ser usado a partir deste ponto. Uma exceção :class:"
"`~sqlite3.Error` (ou uma subclasse) será lançada se alguma operação "
"adicional for tentada com o blob."

#: ../../library/sqlite3.rst:1771
msgid ""
"Read *length* bytes of data from the blob at the current offset position. If "
"the end of the blob is reached, the data up to :abbr:`EOF (End of File)` "
"will be returned.  When *length* is not specified, or is negative, :meth:"
"`~Blob.read` will read until the end of the blob."
msgstr ""
"Lê *length* bytes de dados do blob na posição atual de deslocamento. Se o "
"final do blob for atingido, os dados até :abbr:`EOF (End of File)` serão "
"devolvidos. Quando *length* não for especificado, ou for negativo, :meth:"
"`~Blob.read` lerá até ao final do blob."

#: ../../library/sqlite3.rst:1779
msgid ""
"Write *data* to the blob at the current offset.  This function cannot change "
"the blob length.  Writing beyond the end of the blob will raise :exc:"
"`ValueError`."
msgstr ""
"Escreve *data* no blob na posição atual de deslocamento. Esta função não "
"pode alterar o comprimento do blob. Escrever além do final do blob lançará :"
"exc:`ValueError`."

#: ../../library/sqlite3.rst:1785
msgid "Return the current access position of the blob."
msgstr "Devolve a posição atual de acesso do blob."

#: ../../library/sqlite3.rst:1789
msgid ""
"Set the current access position of the blob to *offset*.  The *origin* "
"argument defaults to :const:`os.SEEK_SET` (absolute blob positioning). Other "
"values for *origin* are :const:`os.SEEK_CUR` (seek relative to the current "
"position) and :const:`os.SEEK_END` (seek relative to the blob’s end)."
msgstr ""
"Define a posição atual de acesso do blob para *offset*. O argumento *origin* "
"tem como predefinição :const:`os.SEEK_SET` (posicionamento absoluto do "
"blob). Outros valores para *origin* são :const:`os.SEEK_CUR` (deslocamento "
"relativo à posição atual) e :const:`os.SEEK_END` (deslocamento relativo ao "
"final do blob)."

#: ../../library/sqlite3.rst:1797
msgid "PrepareProtocol objects"
msgstr "Objetos PrepareProtocol"

#: ../../library/sqlite3.rst:1801
msgid ""
"The PrepareProtocol type's single purpose is to act as a :pep:`246` style "
"adaption protocol for objects that can :ref:`adapt themselves <sqlite3-"
"conform>` to :ref:`native SQLite types <sqlite3-types>`."
msgstr ""
"O único propósito do tipo PrepareProtocol é atuar como um protocolo de "
"adaptação no estilo :pep:`246` para objetos que podem :ref:`adaptar-se a si "
"mesmos <sqlite3-conform>` para :ref:`tipos nativos do SQLite <sqlite3-"
"types>`."

#: ../../library/sqlite3.rst:1809
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/sqlite3.rst:1811
msgid "The exception hierarchy is defined by the DB-API 2.0 (:pep:`249`)."
msgstr "A hierarquia de exceções é definida pela DB-API 2.0 (:pep:`249`)."

#: ../../library/sqlite3.rst:1815
msgid ""
"This exception is not currently raised by the :mod:`!sqlite3` module, but "
"may be raised by applications using :mod:`!sqlite3`, for example if a user-"
"defined function truncates data while inserting. ``Warning`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"Esta exceção não é atualmente lançada pelo módulo :mod:`!sqlite3`, mas pode "
"ser lançada por aplicações que usam :mod:`!sqlite3`, por exemplo, se uma "
"função definida pelo utilizador truncar dados durante a inserção. "
"``Warning`` é uma subclasse de :exc:`Exception`."

#: ../../library/sqlite3.rst:1822
msgid ""
"The base class of the other exceptions in this module. Use this to catch all "
"errors with one single :keyword:`except` statement. ``Error`` is a subclass "
"of :exc:`Exception`."
msgstr ""
"A classe base das outras exceções neste módulo. Use isto para capturar todos "
"os erros com uma única declaração :keyword:`except`. ``Error`` é uma "
"subclasse de :exc:`Exception`."

#: ../../library/sqlite3.rst:1826
msgid ""
"If the exception originated from within the SQLite library, the following "
"two attributes are added to the exception:"
msgstr ""
"Se a exceção teve origem dentro da biblioteca SQLite, os seguintes dois "
"atributos são adicionados à exceção:"

#: ../../library/sqlite3.rst:1831
msgid ""
"The numeric error code from the `SQLite API <https://sqlite.org/rescode."
"html>`_"
msgstr ""
"O código de erro numérico da `API SQLite <https://sqlite.org/rescode.html>`_"

#: ../../library/sqlite3.rst:1838
msgid ""
"The symbolic name of the numeric error code from the `SQLite API <https://"
"sqlite.org/rescode.html>`_"
msgstr ""
"O nome simbólico do código de erro numérico da `API SQLite <https://sqlite."
"org/rescode.html>`_"

#: ../../library/sqlite3.rst:1845
msgid ""
"Exception raised for misuse of the low-level SQLite C API. In other words, "
"if this exception is raised, it probably indicates a bug in the :mod:`!"
"sqlite3` module. ``InterfaceError`` is a subclass of :exc:`Error`."
msgstr ""
"Exceção lançada por uso incorreto da API C de baixo nível do SQLite. Em "
"outras palavras, se esta exceção for lançada, provavelmente indica um bug no "
"módulo :mod:`!sqlite3`. ``InterfaceError`` é uma subclasse de :exc:`Error`."

#: ../../library/sqlite3.rst:1852
msgid ""
"Exception raised for errors that are related to the database. This serves as "
"the base exception for several types of database errors. It is only raised "
"implicitly through the specialised subclasses. ``DatabaseError`` is a "
"subclass of :exc:`Error`."
msgstr ""
"Exceção lançada para erros relacionados com a base de dados. Isto serve como "
"a exceção base para vários tipos de erros de base de dados. É lançada "
"implicitamente através das subclasses especializadas. ``DatabaseError`` é "
"uma subclasse de :exc:`Error`."

#: ../../library/sqlite3.rst:1859
msgid ""
"Exception raised for errors caused by problems with the processed data, like "
"numeric values out of range, and strings which are too long. ``DataError`` "
"is a subclass of :exc:`DatabaseError`."
msgstr ""
"Exceção lançada para erros causados por problemas com os dados processados, "
"como valores numéricos fora do intervalo e strings demasiado longas. "
"``DataError`` é uma subclasse de :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1865
msgid ""
"Exception raised for errors that are related to the database's operation, "
"and not necessarily under the control of the programmer. For example, the "
"database path is not found, or a transaction could not be processed. "
"``OperationalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Exceção lançada para erros relacionados com a operação da base de dados, e "
"não necessariamente sob o controlo do programador. Por exemplo, o caminho da "
"base de dados não é encontrado, ou uma transação não pode ser processada. "
"``OperationalError`` é uma subclasse de :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1873
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Exceção lançada quando a integridade relacional da base de dados é afetada, "
"por exemplo, uma verificação de chave estrangeira falha. É uma subclasse de :"
"exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1878
msgid ""
"Exception raised when SQLite encounters an internal error. If this is "
"raised, it may indicate that there is a problem with the runtime SQLite "
"library. ``InternalError`` is a subclass of :exc:`DatabaseError`."
msgstr ""
"Exceção lançada quando o SQLite encontra um erro interno. Se isto for "
"lançado, pode indicar que há um problema com a biblioteca SQLite em tempo de "
"execução. ``InternalError`` é uma subclasse de :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1885
msgid ""
"Exception raised for :mod:`!sqlite3` API programming errors, for example "
"supplying the wrong number of bindings to a query, or trying to operate on a "
"closed :class:`Connection`. ``ProgrammingError`` is a subclass of :exc:"
"`DatabaseError`."
msgstr ""
"Exceção lançada para erros de programação da API :mod:`!sqlite3`, por "
"exemplo, fornecer o número errado de ligações a uma consulta, ou tentar "
"operar numa :class:`Connection` fechada. ``ProgrammingError`` é uma "
"subclasse de :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1892
msgid ""
"Exception raised in case a method or database API is not supported by the "
"underlying SQLite library. For example, setting *deterministic* to ``True`` "
"in :meth:`~Connection.create_function`, if the underlying SQLite library "
"does not support deterministic functions. ``NotSupportedError`` is a "
"subclass of :exc:`DatabaseError`."
msgstr ""
"Exceção lançada caso um método ou API de base de dados não seja suportado "
"pela biblioteca SQLite subjacente. Por exemplo, definir *deterministic* como "
"``True`` em :meth:`~Connection.create_function`, se a biblioteca SQLite "
"subjacente não suportar funções determinísticas. ``NotSupportedError`` é uma "
"subclasse de :exc:`DatabaseError`."

#: ../../library/sqlite3.rst:1902
msgid "SQLite and Python types"
msgstr "Tipos SQLite e Python"

#: ../../library/sqlite3.rst:1904
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"O SQLite suporta nativamente os seguintes tipos: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."

#: ../../library/sqlite3.rst:1907
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""
"Os seguintes tipos Python podem, portanto, ser enviados para o SQLite sem "
"qualquer problema:"

#: ../../library/sqlite3.rst:1910 ../../library/sqlite3.rst:1927
msgid "Python type"
msgstr "tipo Python"

#: ../../library/sqlite3.rst:1910 ../../library/sqlite3.rst:1927
msgid "SQLite type"
msgstr "Tipo SQLite"

#: ../../library/sqlite3.rst:1912 ../../library/sqlite3.rst:1929
msgid "``None``"
msgstr "``None``"

#: ../../library/sqlite3.rst:1912 ../../library/sqlite3.rst:1929
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:1914 ../../library/sqlite3.rst:1931
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:1914 ../../library/sqlite3.rst:1931
msgid "``INTEGER``"
msgstr "``INTEGER``"

#: ../../library/sqlite3.rst:1916 ../../library/sqlite3.rst:1933
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:1916 ../../library/sqlite3.rst:1933
msgid "``REAL``"
msgstr "``REAL``"

#: ../../library/sqlite3.rst:1918
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:1918 ../../library/sqlite3.rst:1935
msgid "``TEXT``"
msgstr "``TEXT``"

#: ../../library/sqlite3.rst:1920 ../../library/sqlite3.rst:1938
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:1920 ../../library/sqlite3.rst:1938
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:1924
msgid "This is how SQLite types are converted to Python types by default:"
msgstr ""
"Esta é a forma como os tipos SQLite são convertidos para tipos Python por "
"predefinição:"

#: ../../library/sqlite3.rst:1935
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
"depende de :attr:`~Connection.text_factory`, :class:`str` por predefinição"

#: ../../library/sqlite3.rst:1941
msgid ""
"The type system of the :mod:`!sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via :ref:`object "
"adapters <sqlite3-adapters>`, and you can let the :mod:`!sqlite3` module "
"convert SQLite types to Python types via :ref:`converters <sqlite3-"
"converters>`."
msgstr ""
"O sistema de tipos do módulo :mod:`!sqlite3` é extensível de duas formas: "
"pode armazenar tipos Python adicionais numa base de dados SQLite através de :"
"ref:`adaptadores de objetos <sqlite3-adapters>`, e pode deixar que o módulo :"
"mod:`!sqlite3` converta tipos SQLite para tipos Python através de :ref:"
"`conversores <sqlite3-converters>`."

#: ../../library/sqlite3.rst:1951
msgid "Default adapters and converters (deprecated)"
msgstr "Adaptadores e conversores predefinidos (obsoletos)"

#: ../../library/sqlite3.rst:1955
msgid ""
"The default adapters and converters are deprecated as of Python 3.12. "
"Instead, use the :ref:`sqlite3-adapter-converter-recipes` and tailor them to "
"your needs."
msgstr ""
"Os adaptadores e conversores predefinidos estão obsoletos a partir do Python "
"3.12. Em vez disso, use as :ref:`sqlite3-adapter-converter-recipes` e adapte-"
"as às suas necessidades."

#: ../../library/sqlite3.rst:1959
msgid "The deprecated default adapters and converters consist of:"
msgstr "Os adaptadores e conversores predefinidos obsoletos consistem em:"

#: ../../library/sqlite3.rst:1961
msgid ""
"An adapter for :class:`datetime.date` objects to :class:`strings <str>` in "
"`ISO 8601`_ format."
msgstr ""
"Um adaptador para objetos :class:`datetime.date` para :class:`strings <str>` "
"no formato `ISO 8601`_."

#: ../../library/sqlite3.rst:1963
msgid ""
"An adapter for :class:`datetime.datetime` objects to strings in ISO 8601 "
"format."
msgstr ""
"Um adaptador para objetos :class:`datetime.datetime` para strings no formato "
"ISO 8601."

#: ../../library/sqlite3.rst:1965
msgid ""
"A converter for :ref:`declared <sqlite3-converters>` \"date\" types to :"
"class:`datetime.date` objects."
msgstr ""
"Um conversor para tipos \"date\" :ref:`declarados <sqlite3-converters>` para "
"objetos :class:`datetime.date`."

#: ../../library/sqlite3.rst:1967
msgid ""
"A converter for declared \"timestamp\" types to :class:`datetime.datetime` "
"objects. Fractional parts will be truncated to 6 digits (microsecond "
"precision)."
msgstr ""
"Um conversor para tipos \"timestamp\" declarados para objetos :class:"
"`datetime.datetime`. As partes fracionárias serão truncadas para 6 dígitos "
"(precisão de microsegundos)."

#: ../../library/sqlite3.rst:1973
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"O conversor \"timestamp\" predefinido ignora os deslocamentos UTC na base de "
"dados e sempre devolve um objeto :class:`datetime.datetime` ingénuo. Para "
"preservar os deslocamentos UTC nos timestamps, ou deixe os conversores "
"desativados, ou registe um conversor consciente de deslocamento com :func:"
"`register_converter`."

#: ../../library/sqlite3.rst:1986
msgid "Command-line interface"
msgstr "Interface de linha de comandos"

#: ../../library/sqlite3.rst:1988
msgid ""
"The :mod:`!sqlite3` module can be invoked as a script, using the "
"interpreter's :option:`-m` switch, in order to provide a simple SQLite "
"shell. The argument signature is as follows::"
msgstr ""
"O módulo :mod:`!sqlite3` pode ser invocado como um script, usando a opção :"
"option:`-m` do interpretador, para fornecer uma shell SQLite simples. A "
"assinatura do argumento é a seguinte::"

#: ../../library/sqlite3.rst:1993
msgid "python -m sqlite3 [-h] [-v] [filename] [sql]"
msgstr "python -m sqlite3 [-h] [-v] [nome_do_ficheiro] [sql]"

#: ../../library/sqlite3.rst:1995
msgid "Type ``.quit`` or CTRL-D to exit the shell."
msgstr "Escreva ``.quit`` ou CTRL-D para sair da shell."

#: ../../library/sqlite3.rst:2001
msgid "Print CLI help."
msgstr "Mostra ajuda da CLI."

#: ../../library/sqlite3.rst:2005
msgid "Print underlying SQLite library version."
msgstr "Mostra a versão da biblioteca SQLite subjacente."

#: ../../library/sqlite3.rst:2013
msgid "How-to guides"
msgstr "Guias práticos"

#: ../../library/sqlite3.rst:2018
msgid "How to use placeholders to bind values in SQL queries"
msgstr "Como usar placeholders para ligar valores em consultas SQL"

#: ../../library/sqlite3.rst:2020
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to `SQL injection attacks`_. For example, an attacker can simply "
"close the single quote and inject ``OR TRUE`` to select all rows::"
msgstr ""
"As operações SQL geralmente precisam de usar valores de variáveis Python. No "
"entanto, tenha cuidado ao usar operações de strings do Python para montar "
"consultas, pois são vulneráveis a `ataques de injeção SQL`_. Por exemplo, um "
"atacante pode simplesmente fechar a aspa simples e injetar ``OR TRUE`` para "
"selecionar todas as linhas::"

#: ../../library/sqlite3.rst:2025
msgid ""
">>> # Never do this -- insecure!\n"
">>> symbol = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM stocks WHERE symbol = '%s'\" % symbol\n"
">>> print(sql)\n"
"SELECT * FROM stocks WHERE symbol = '' OR TRUE; --'\n"
">>> cur.execute(sql)"
msgstr ""
">>> # Nunca faça isto -- inseguro!\n"
">>> simbolo = input()\n"
"' OR TRUE; --\n"
">>> sql = \"SELECT * FROM acoes WHERE simbolo = '%s'\" % simbolo\n"
">>> print(sql)\n"
"SELECT * FROM acoes WHERE simbolo = '' OR TRUE; --'\n"
">>> cur.execute(sql)"

#: ../../library/sqlite3.rst:2033
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method."
msgstr ""
"Em vez disso, use a substituição de parâmetros da DB-API. Para inserir uma "
"variável numa string de consulta, use um placeholder na string e substitua "
"os valores reais na consulta fornecendo-os como um :class:`tuple` de valores "
"para o segundo argumento do método :meth:`~Cursor.execute` do cursor."

#: ../../library/sqlite3.rst:2038
msgid ""
"An SQL statement may use one of two kinds of placeholders: question marks "
"(qmark style) or named placeholders (named style). For the qmark style, "
"*parameters* must be a :term:`sequence` whose length must match the number "
"of placeholders, or a :exc:`ProgrammingError` is raised. For the named "
"style, *parameters* must be an instance of a :class:`dict` (or a subclass), "
"which must contain keys for all named parameters; any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"Uma declaração SQL pode usar um de dois tipos de placeholders: pontos de "
"interrogação (estilo qmark) ou placeholders nomeados (estilo nomeado). Para "
"o estilo qmark, *parameters* deve ser uma :term:`sequência` cujo comprimento "
"deve corresponder ao número de placeholders, ou um :exc:`ProgrammingError` é "
"lançado. Para o estilo nomeado, *parameters* deve ser uma instância de um :"
"class:`dict` (ou uma subclasse), que deve conter chaves para todos os "
"parâmetros nomeados; quaisquer itens extra são ignorados. Aqui está um "
"exemplo de ambos os estilos:"

#: ../../library/sqlite3.rst:2049
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"\n"
"# This is the named style used with executemany():\n"
"data = (\n"
"    {\"name\": \"C\", \"year\": 1972},\n"
"    {\"name\": \"Fortran\", \"year\": 1957},\n"
"    {\"name\": \"Python\", \"year\": 1991},\n"
"    {\"name\": \"Go\", \"year\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lang VALUES(:name, :year)\", data)\n"
"\n"
"# This is the qmark style used in a SELECT query:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lang WHERE first_appeared = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.execute(\"CREATE TABLE lingua(nome, primeira_aparicao)\")\n"
"\n"
"# Este é o estilo nomeado usado com executemany():\n"
"data = (\n"
"    {\"nome\": \"C\", \"ano\": 1972},\n"
"    {\"nome\": \"Fortran\", \"ano\": 1957},\n"
"    {\"nome\": \"Python\", \"ano\": 1991},\n"
"    {\"nome\": \"Go\", \"ano\": 2009},\n"
")\n"
"cur.executemany(\"INSERT INTO lingua VALUES(:nome, :ano)\", data)\n"
"\n"
"# Este é o estilo qmark usado numa consulta SELECT:\n"
"params = (1972,)\n"
"cur.execute(\"SELECT * FROM lingua WHERE primeira_aparicao = ?\", params)\n"
"print(cur.fetchall())\n"
"con.close()"

#: ../../library/sqlite3.rst:2076
msgid ""
":pep:`249` numeric placeholders are *not* supported. If used, they will be "
"interpreted as named placeholders."
msgstr ""
"Os placeholders numéricos :pep:`249` *não* são suportados. Se usados, serão "
"interpretados como placeholders nomeados."

#: ../../library/sqlite3.rst:2083
msgid "How to adapt custom Python types to SQLite values"
msgstr "Como adaptar tipos Python personalizados para valores SQLite"

#: ../../library/sqlite3.rst:2085
msgid ""
"SQLite supports only a limited set of data types natively. To store custom "
"Python types in SQLite databases, *adapt* them to one of the :ref:`Python "
"types SQLite natively understands <sqlite3-types>`."
msgstr ""
"O SQLite suporta apenas um conjunto limitado de tipos de dados nativamente. "
"Para armazenar tipos Python personalizados em bases de dados SQLite, "
"*adapte*-os para um dos :ref:`tipos Python que o SQLite entende nativamente "
"<sqlite3-types>`."

#: ../../library/sqlite3.rst:2089
msgid ""
"There are two ways to adapt Python objects to SQLite types: letting your "
"object adapt itself, or using an *adapter callable*. The latter will take "
"precedence above the former. For a library that exports a custom type, it "
"may make sense to enable that type to adapt itself. As an application "
"developer, it may make more sense to take direct control by registering "
"custom adapter functions."
msgstr ""
"Existem duas formas de adaptar objetos Python para tipos SQLite: deixar que "
"o seu objeto se adapte a si mesmo ou usar um *adaptador chamável*. Este "
"último terá precedência sobre o primeiro. Para uma biblioteca que exporta um "
"tipo personalizado, pode fazer sentido permitir que esse tipo se adapte a si "
"mesmo. Como desenvolvedor de aplicações, pode fazer mais sentido tomar o "
"controlo direto registando funções de adaptador personalizadas."

#: ../../library/sqlite3.rst:2101
msgid "How to write adaptable objects"
msgstr "Como escrever objetos adaptáveis"

#: ../../library/sqlite3.rst:2103
msgid ""
"Suppose we have a :class:`!Point` class that represents a pair of "
"coordinates, ``x`` and ``y``, in a Cartesian coordinate system. The "
"coordinate pair will be stored as a text string in the database, using a "
"semicolon to separate the coordinates. This can be implemented by adding a "
"``__conform__(self, protocol)`` method which returns the adapted value. The "
"object passed to *protocol* will be of type :class:`PrepareProtocol`."
msgstr ""
"Suponhamos que temos uma classe :class:`!Point` que representa um par de "
"coordenadas, ``x`` e ``y``, num sistema de coordenadas cartesianas. O par de "
"coordenadas será armazenado como uma string de texto na base de dados, "
"usando um ponto e vírgula para separar as coordenadas. Isto pode ser "
"implementado adicionando um método ``__conform__(self, protocol)`` que "
"devolve o valor adaptado. O objeto passado para *protocol* será do tipo :"
"class:`PrepareProtocol`."

#: ../../library/sqlite3.rst:2111
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"class Ponto:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return f\"{self.x};{self.y}\"\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Ponto(4.0, -3.2),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"

#: ../../library/sqlite3.rst:2135
msgid "How to register adapter callables"
msgstr "Como registar adaptadores chamáveis"

#: ../../library/sqlite3.rst:2137
msgid ""
"The other possibility is to create a function that converts the Python "
"object to an SQLite-compatible type. This function can then be registered "
"using :func:`register_adapter`."
msgstr ""
"A outra possibilidade é criar uma função que converte o objeto Python para "
"um tipo compatível com SQLite. Esta função pode então ser registada usando :"
"func:`register_adapter`."

#: ../../library/sqlite3.rst:2141
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Point(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"
msgstr ""
"class Ponto:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adaptar_ponto(ponto):\n"
"    return f\"{ponto.x};{ponto.y}\"\n"
"\n"
"sqlite3.register_adapter(Ponto, adaptar_ponto)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"cur.execute(\"SELECT ?\", (Ponto(1.0, 2.5),))\n"
"print(cur.fetchone()[0])\n"
"con.close()"

#: ../../library/sqlite3.rst:2168
msgid "How to convert SQLite values to custom Python types"
msgstr "Como converter valores SQLite para tipos Python personalizados"

#: ../../library/sqlite3.rst:2170
msgid ""
"Writing an adapter lets you convert *from* custom Python types *to* SQLite "
"values. To be able to convert *from* SQLite values *to* custom Python types, "
"we use *converters*."
msgstr ""
"Escrever um adaptador permite-lhe converter *de* tipos Python personalizados "
"*para* valores SQLite. Para poder converter *de* valores SQLite *para* tipos "
"Python personalizados, usamos *conversores*."

#: ../../library/sqlite3.rst:2175
msgid ""
"Let's go back to the :class:`!Point` class. We stored the x and y "
"coordinates separated via semicolons as strings in SQLite."
msgstr ""
"Vamos voltar à classe :class:`!Point`. Armazenámos as coordenadas x e y "
"separadas por ponto e vírgula como strings no SQLite."

#: ../../library/sqlite3.rst:2178
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`!Point` object from it."
msgstr ""
"Primeiro, vamos definir uma função conversora que aceita a string como "
"parâmetro e constrói um objeto :class:`!Point` a partir dela."

#: ../../library/sqlite3.rst:2183
msgid ""
"Converter functions are **always** passed a :class:`bytes` object, no matter "
"the underlying SQLite data type."
msgstr ""
"As funções conversoras recebem **sempre** um objeto :class:`bytes`, "
"independentemente do tipo de dados SQLite subjacente."

#: ../../library/sqlite3.rst:2186
msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""
"def converter_ponto(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Ponto(x, y)"

#: ../../library/sqlite3.rst:2192
msgid ""
"We now need to tell :mod:`!sqlite3` when it should convert a given SQLite "
"value. This is done when connecting to a database, using the *detect_types* "
"parameter of :func:`connect`. There are three options:"
msgstr ""
"Agora precisamos de dizer ao :mod:`!sqlite3` quando deve converter um dado "
"valor SQLite. Isto é feito ao ligar a uma base de dados, usando o parâmetro "
"*detect_types* de :func:`connect`. Existem três opções:"

#: ../../library/sqlite3.rst:2196
msgid "Implicit: set *detect_types* to :const:`PARSE_DECLTYPES`"
msgstr "Implícito: defina *detect_types* para :const:`PARSE_DECLTYPES`"

#: ../../library/sqlite3.rst:2197
msgid "Explicit: set *detect_types* to :const:`PARSE_COLNAMES`"
msgstr "Explícito: defina *detect_types* para :const:`PARSE_COLNAMES`"

#: ../../library/sqlite3.rst:2198
msgid ""
"Both: set *detect_types* to ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Column names take precedence over declared types."
msgstr ""
"Ambos: defina *detect_types* para ``sqlite3.PARSE_DECLTYPES | sqlite3."
"PARSE_COLNAMES``. Os nomes das colunas têm precedência sobre os tipos "
"declarados."

#: ../../library/sqlite3.rst:2202
msgid "The following example illustrates the implicit and explicit approaches:"
msgstr "O exemplo seguinte ilustra as abordagens implícita e explícita:"

#: ../../library/sqlite3.rst:2204
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Point({self.x}, {self.y})\"\n"
"\n"
"def adapt_point(point):\n"
"    return f\"{point.x};{point.y}\"\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter and converter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"# 1) Parse using declared types\n"
"p = Point(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p point)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Parse using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [point]\" FROM test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"
msgstr ""
"class Ponto:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return f\"Ponto({self.x}, {self.y})\"\n"
"\n"
"def adaptar_ponto(ponto):\n"
"    return f\"{ponto.x};{ponto.y}\"\n"
"\n"
"def converter_ponto(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Ponto(x, y)\n"
"\n"
"# Registar o adaptador e o conversor\n"
"sqlite3.register_adapter(Ponto, adaptar_ponto)\n"
"sqlite3.register_converter(\"ponto\", converter_ponto)\n"
"\n"
"# 1) Analisar usando tipos declarados\n"
"p = Ponto(4.0, -3.2)\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.execute(\"CREATE TABLE test(p ponto)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute(\"SELECT p FROM test\")\n"
"print(\"com tipos declarados:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"# 2) Analisar usando nomes de colunas\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.execute(\"CREATE TABLE test(p)\")\n"
"\n"
"cur.execute(\"INSERT INTO test(p) VALUES(?)\", (p,))\n"
"cur.execute('SELECT p AS \"p [ponto]\" FROM test')\n"
"print(\"com nomes de colunas:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()"

#: ../../library/sqlite3.rst:2255
msgid "Adapter and converter recipes"
msgstr "Receitas de adaptadores e conversores"

#: ../../library/sqlite3.rst:2257
msgid "This section shows recipes for common adapters and converters."
msgstr "Esta secção mostra receitas para adaptadores e conversores comuns."

#: ../../library/sqlite3.rst:2259
msgid ""
"import datetime\n"
"import sqlite3\n"
"\n"
"def adapt_date_iso(val):\n"
"    \"\"\"Adapt datetime.date to ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_iso(val):\n"
"    \"\"\"Adapt datetime.datetime to timezone-naive ISO 8601 date.\"\"\"\n"
"    return val.isoformat()\n"
"\n"
"def adapt_datetime_epoch(val):\n"
"    \"\"\"Adapt datetime.datetime to Unix timestamp.\"\"\"\n"
"    return int(val.timestamp())\n"
"\n"
"sqlite3.register_adapter(datetime.date, adapt_date_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_iso)\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime_epoch)\n"
"\n"
"def convert_date(val):\n"
"    \"\"\"Convert ISO 8601 date to datetime.date object.\"\"\"\n"
"    return datetime.date.fromisoformat(val.decode())\n"
"\n"
"def convert_datetime(val):\n"
"    \"\"\"Convert ISO 8601 datetime to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromisoformat(val.decode())\n"
"\n"
"def convert_timestamp(val):\n"
"    \"\"\"Convert Unix epoch timestamp to datetime.datetime object.\"\"\"\n"
"    return datetime.datetime.fromtimestamp(int(val))\n"
"\n"
"sqlite3.register_converter(\"date\", convert_date)\n"
"sqlite3.register_converter(\"datetime\", convert_datetime)\n"
"sqlite3.register_converter(\"timestamp\", convert_timestamp)"
msgstr ""

#: ../../library/sqlite3.rst:2319
msgid "How to use connection shortcut methods"
msgstr "Como usar métodos de atalho de ligação"

#: ../../library/sqlite3.rst:2321
msgid ""
"Using the :meth:`~Connection.execute`, :meth:`~Connection.executemany`, and :"
"meth:`~Connection.executescript` methods of the :class:`Connection` class, "
"your code can be written more concisely because you don't have to create the "
"(often superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Usando os métodos :meth:`~Connection.execute`, :meth:`~Connection."
"executemany` e :meth:`~Connection.executescript` da classe :class:"
"`Connection`, o seu código pode ser escrito de forma mais concisa porque não "
"precisa de criar explicitamente os objetos :class:`Cursor` (muitas vezes "
"supérfluos). Em vez disso, os objetos :class:`Cursor` são criados "
"implicitamente e estes métodos de atalho devolvem os objetos cursor. Desta "
"forma, pode executar uma declaração ``SELECT`` e iterar sobre ela "
"diretamente usando apenas uma única chamada no objeto :class:`Connection`."

#: ../../library/sqlite3.rst:2330
msgid ""
"# Create and fill the table.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(name, first_appeared)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lang(name, first_appeared) VALUES(?, ?)\", "
"data)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"SELECT name, first_appeared FROM lang\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"DELETE FROM lang\").rowcount, "
"\"rows\")\n"
"\n"
"# close() is not a shortcut method and it's not called automatically;\n"
"# the connection object should be closed manually\n"
"con.close()"
msgstr ""
"# Criar e preencher a tabela.\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lingua(nome, primeira_aparicao)\")\n"
"data = [\n"
"    (\"C++\", 1985),\n"
"    (\"Objective-C\", 1984),\n"
"]\n"
"con.executemany(\"INSERT INTO lingua(nome, primeira_aparicao) "
"VALUES(?, ?)\", data)\n"
"\n"
"# Imprimir o conteúdo da tabela\n"
"for row in con.execute(\"SELECT nome, primeira_aparicao FROM lingua\"):\n"
"    print(row)\n"
"\n"
"print(\"Acabei de apagar\", con.execute(\"DELETE FROM lingua\").rowcount, "
"\"linhas\")\n"
"\n"
"# close() não é um método de atalho e não é chamado automaticamente;\n"
"# o objeto de ligação deve ser fechado manualmente\n"
"con.close()"

#: ../../library/sqlite3.rst:2362
msgid "How to use the connection context manager"
msgstr "Como usar o gestor de contexto de ligação"

#: ../../library/sqlite3.rst:2364
msgid ""
"A :class:`Connection` object can be used as a context manager that "
"automatically commits or rolls back open transactions when leaving the body "
"of the context manager. If the body of the :keyword:`with` statement "
"finishes without exceptions, the transaction is committed. If this commit "
"fails, or if the body of the ``with`` statement raises an uncaught "
"exception, the transaction is rolled back. If :attr:`~Connection.autocommit` "
"is ``False``, a new transaction is implicitly opened after committing or "
"rolling back."
msgstr ""
"Um objeto :class:`Connection` pode ser usado como um gestor de contexto que "
"confirma ou reverte automaticamente transações abertas ao sair do corpo do "
"gestor de contexto. Se o corpo da declaração :keyword:`with` terminar sem "
"exceções, a transação é confirmada. Se esta confirmação falhar, ou se o "
"corpo da declaração ``with`` lançar uma exceção não capturada, a transação é "
"revertida. Se :attr:`~Connection.autocommit` for ``False``, uma nova "
"transação é implicitamente aberta após confirmar ou reverter."

#: ../../library/sqlite3.rst:2375
msgid ""
"If there is no open transaction upon leaving the body of the ``with`` "
"statement, or if :attr:`~Connection.autocommit` is ``True``, the context "
"manager does nothing."
msgstr ""
"Se não houver nenhuma transação aberta ao sair do corpo da declaração "
"``with``, ou se :attr:`~Connection.autocommit` for ``True``, o gestor de "
"contexto não faz nada."

#: ../../library/sqlite3.rst:2380
msgid ""
"The context manager neither implicitly opens a new transaction nor closes "
"the connection. If you need a closing context manager, consider using :meth:"
"`contextlib.closing`."
msgstr ""
"O gestor de contexto não abre implicitamente uma nova transação nem fecha a "
"ligação. Se precisar de um gestor de contexto que feche, considere usar :"
"meth:`contextlib.closing`."

#: ../../library/sqlite3.rst:2384
msgid ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lang(id INTEGER PRIMARY KEY, name VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception,\n"
"# the exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lang(name) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Python twice\")\n"
"\n"
"# Connection object used as context manager only commits or rollbacks "
"transactions,\n"
"# so the connection object should be closed manually\n"
"con.close()"
msgstr ""
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"CREATE TABLE lingua(id INTEGER PRIMARY KEY, nome VARCHAR "
"UNIQUE)\")\n"
"\n"
"# Bem-sucedido, con.commit() é chamado automaticamente depois\n"
"with con:\n"
"    con.execute(\"INSERT INTO lingua(nome) VALUES(?)\", (\"Python\",))\n"
"\n"
"# con.rollback() é chamado depois do bloco with terminar com uma exceção,\n"
"# a exceção ainda é lançada e deve ser capturada\n"
"try:\n"
"    with con:\n"
"        con.execute(\"INSERT INTO lingua(nome) VALUES(?)\", (\"Python\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"não foi possível adicionar Python duas vezes\")\n"
"\n"
"# O objeto de ligação usado como gestor de contexto apenas confirma ou "
"reverte transações,\n"
"# por isso o objeto de ligação deve ser fechado manualmente\n"
"con.close()"

#: ../../library/sqlite3.rst:2414
msgid "How to work with SQLite URIs"
msgstr "Como trabalhar com URIs do SQLite"

#: ../../library/sqlite3.rst:2416
msgid "Some useful URI tricks include:"
msgstr "Alguns truques úteis de URI incluem:"

#: ../../library/sqlite3.rst:2418
msgid "Open a database in read-only mode:"
msgstr "Abrir uma base de dados em modo de apenas leitura:"

#: ../../library/sqlite3.rst:2420
msgid ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE readonly(data)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: attempt to write a readonly database\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\"file:tutorial.db?mode=ro\", uri=True)\n"
">>> con.execute(\"CREATE TABLE so_leitura(dados)\")\n"
"Traceback (most recent call last):\n"
"OperationalError: tentativa de escrever numa base de dados de apenas "
"leitura\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2428
msgid ""
"Do not implicitly create a new database file if it does not already exist; "
"will raise :exc:`~sqlite3.OperationalError` if unable to create a new file:"
msgstr ""
"Não criar implicitamente um novo ficheiro de base de dados se este não "
"existir; lançará :exc:`~sqlite3.OperationalError` se não for possível criar "
"um novo ficheiro:"

#: ../../library/sqlite3.rst:2431
msgid ""
">>> con = sqlite3.connect(\"file:nosuchdb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: unable to open database file"
msgstr ""
">>> con = sqlite3.connect(\"file:naoexistedb.db?mode=rw\", uri=True)\n"
"Traceback (most recent call last):\n"
"OperationalError: não foi possível abrir o ficheiro da base de dados"

#: ../../library/sqlite3.rst:2438
msgid "Create a shared named in-memory database:"
msgstr "Criar uma base de dados em memória partilhada com nome:"

#: ../../library/sqlite3.rst:2440
msgid ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE shared(data)\")\n"
"    con1.execute(\"INSERT INTO shared VALUES(28)\")\n"
"res = con2.execute(\"SELECT data FROM shared\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"
msgstr ""
"db = \"file:mem1?mode=memory&cache=shared\"\n"
"con1 = sqlite3.connect(db, uri=True)\n"
"con2 = sqlite3.connect(db, uri=True)\n"
"with con1:\n"
"    con1.execute(\"CREATE TABLE partilhado(dados)\")\n"
"    con1.execute(\"INSERT INTO partilhado VALUES(28)\")\n"
"res = con2.execute(\"SELECT dados FROM partilhado\")\n"
"assert res.fetchone() == (28,)\n"
"\n"
"con1.close()\n"
"con2.close()"

#: ../../library/sqlite3.rst:2454
msgid ""
"More information about this feature, including a list of parameters, can be "
"found in the `SQLite URI documentation`_."
msgstr ""
"Mais informações sobre esta funcionalidade, incluindo uma lista de "
"parâmetros, podem ser encontradas na `documentação de URI do SQLite`_."

#: ../../library/sqlite3.rst:2463
msgid "How to create and use row factories"
msgstr "Como criar e usar fábricas de linhas"

#: ../../library/sqlite3.rst:2465
msgid ""
"By default, :mod:`!sqlite3` represents each row as a :class:`tuple`. If a :"
"class:`!tuple` does not suit your needs, you can use the :class:`sqlite3."
"Row` class or a custom :attr:`~Cursor.row_factory`."
msgstr ""
"Por predefinição, :mod:`!sqlite3` representa cada linha como um :class:"
"`tuple`. Se um :class:`!tuple` não se adequar às suas necessidades, pode "
"usar a classe :class:`sqlite3.Row` ou uma :attr:`~Cursor.row_factory` "
"personalizada."

#: ../../library/sqlite3.rst:2470
msgid ""
"While :attr:`!row_factory` exists as an attribute both on the :class:"
"`Cursor` and the :class:`Connection`, it is recommended to set :class:"
"`Connection.row_factory`, so all cursors created from the connection will "
"use the same row factory."
msgstr ""
"Embora :attr:`!row_factory` exista como atributo tanto no :class:`Cursor` "
"como na :class:`Connection`, recomenda-se definir :class:`Connection."
"row_factory`, para que todos os cursores criados a partir da ligação usem a "
"mesma fábrica de linhas."

#: ../../library/sqlite3.rst:2475
msgid ""
":class:`!Row` provides indexed and case-insensitive named access to columns, "
"with minimal memory overhead and performance impact over a :class:`!tuple`. "
"To use :class:`!Row` as a row factory, assign it to the :attr:`!row_factory` "
"attribute:"
msgstr ""
":class:`!Row` fornece acesso indexado e nomeado (sem distinção de maiúsculas/"
"minúsculas) às colunas, com sobrecarga mínima de memória e impacto de "
"desempenho sobre um :class:`!tuple`. Para usar :class:`!Row` como fábrica de "
"linhas, atribua-o ao atributo :attr:`!row_factory`:"

#: ../../library/sqlite3.rst:2480
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = sqlite3.Row"

#: ../../library/sqlite3.rst:2485
msgid "Queries now return :class:`!Row` objects:"
msgstr "As consultas agora devolvem objetos :class:`!Row`:"

#: ../../library/sqlite3.rst:2487
msgid ""
">>> res = con.execute(\"SELECT 'Earth' AS name, 6378 AS radius\")\n"
">>> row = res.fetchone()\n"
">>> row.keys()\n"
"['name', 'radius']\n"
">>> row[0]         # Access by index.\n"
"'Earth'\n"
">>> row[\"name\"]    # Access by name.\n"
"'Earth'\n"
">>> row[\"RADIUS\"]  # Column names are case-insensitive.\n"
"6378\n"
">>> con.close()"
msgstr ""
">>> res = con.execute(\"SELECT 'Terra' AS nome, 6378 AS raio\")\n"
">>> linha = res.fetchone()\n"
">>> linha.keys()\n"
"['nome', 'raio']\n"
">>> linha[0]         # Acesso por índice.\n"
"'Terra'\n"
">>> linha[\"nome\"]    # Acesso por nome.\n"
"'Terra'\n"
">>> linha[\"RAIO\"]  # Os nomes das colunas não distinguem maiúsculas de "
"minúsculas.\n"
"6378\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2503
msgid ""
"The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the "
"above example. In such cases, SQLite returns a single row with columns "
"defined by expressions, e.g. literals, with the given aliases ``expr AS "
"alias``."
msgstr ""
"A cláusula ``FROM`` pode ser omitida na declaração ``SELECT``, como no "
"exemplo acima. Nesses casos, o SQLite devolve uma única linha com colunas "
"definidas por expressões, por exemplo, literais, com os alias dados ``expr "
"AS alias``."

#: ../../library/sqlite3.rst:2508
msgid ""
"You can create a custom :attr:`~Cursor.row_factory` that returns each row as "
"a :class:`dict`, with column names mapped to values:"
msgstr ""
"Pode criar uma :attr:`~Cursor.row_factory` personalizada que devolve cada "
"linha como um :class:`dict`, com os nomes das colunas mapeados para os "
"valores:"

#: ../../library/sqlite3.rst:2511
msgid ""
"def dict_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    return {key: value for key, value in zip(fields, row)}"
msgstr ""
"def fabrica_dict(cursor, linha):\n"
"    campos = [coluna[0] for coluna in cursor.description]\n"
"    return {chave: valor for chave, valor in zip(campos, linha)}"

#: ../../library/sqlite3.rst:2517
msgid ""
"Using it, queries now return a :class:`!dict` instead of a :class:`!tuple`:"
msgstr ""
"Usando-a, as consultas agora devolvem um :class:`!dict` em vez de um :class:"
"`!tuple`:"

#: ../../library/sqlite3.rst:2519
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = dict_factory\n"
">>> for row in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(row)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = fabrica_dict\n"
">>> for linha in con.execute(\"SELECT 1 AS a, 2 AS b\"):\n"
"...     print(linha)\n"
"{'a': 1, 'b': 2}\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2528
msgid "The following row factory returns a :term:`named tuple`:"
msgstr "A seguinte fábrica de linhas devolve um :term:`tuplo nomeado`:"

#: ../../library/sqlite3.rst:2530
msgid ""
"from collections import namedtuple\n"
"\n"
"def namedtuple_factory(cursor, row):\n"
"    fields = [column[0] for column in cursor.description]\n"
"    cls = namedtuple(\"Row\", fields)\n"
"    return cls._make(row)"
msgstr ""
"from collections import namedtuple\n"
"\n"
"def fabrica_namedtuple(cursor, linha):\n"
"    campos = [coluna[0] for coluna in cursor.description]\n"
"    cls = namedtuple(\"Linha\", campos)\n"
"    return cls._make(linha)"

#: ../../library/sqlite3.rst:2539
msgid ":func:`!namedtuple_factory` can be used as follows:"
msgstr ":func:`!namedtuple_factory` pode ser usada da seguinte forma:"

#: ../../library/sqlite3.rst:2541
msgid ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = namedtuple_factory\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> row = cur.fetchone()\n"
">>> row\n"
"Row(a=1, b=2)\n"
">>> row[0]  # Indexed access.\n"
"1\n"
">>> row.b   # Attribute access.\n"
"2\n"
">>> con.close()"
msgstr ""
">>> con = sqlite3.connect(\":memory:\")\n"
">>> con.row_factory = fabrica_namedtuple\n"
">>> cur = con.execute(\"SELECT 1 AS a, 2 AS b\")\n"
">>> linha = cur.fetchone()\n"
">>> linha\n"
"Linha(a=1, b=2)\n"
">>> linha[0]  # Acesso por índice.\n"
"1\n"
">>> linha.b   # Acesso por atributo.\n"
"2\n"
">>> con.close()"

#: ../../library/sqlite3.rst:2555
msgid ""
"With some adjustments, the above recipe can be adapted to use a :class:"
"`~dataclasses.dataclass`, or any other custom class, instead of a :class:"
"`~collections.namedtuple`."
msgstr ""
"Com alguns ajustes, a receita acima pode ser adaptada para usar uma :class:"
"`~dataclasses.dataclass`, ou qualquer outra classe personalizada, em vez de "
"um :class:`~collections.namedtuple`."

#: ../../library/sqlite3.rst:2563
msgid "How to handle non-UTF-8 text encodings"
msgstr "Como lidar com codificações de texto não UTF-8"

#: ../../library/sqlite3.rst:2565
msgid ""
"By default, :mod:`!sqlite3` uses :class:`str` to adapt SQLite values with "
"the ``TEXT`` data type. This works well for UTF-8 encoded text, but it might "
"fail for other encodings and invalid UTF-8. You can use a custom :attr:"
"`~Connection.text_factory` to handle such cases."
msgstr ""
"Por predefinição, :mod:`!sqlite3` usa :class:`str` para adaptar valores "
"SQLite com o tipo de dados ``TEXT``. Isto funciona bem para texto codificado "
"em UTF-8, mas pode falhar para outras codificações e UTF-8 inválido. Pode "
"usar uma :attr:`~Connection.text_factory` personalizada para lidar com tais "
"casos."

#: ../../library/sqlite3.rst:2571
msgid ""
"Because of SQLite's `flexible typing`_, it is not uncommon to encounter "
"table columns with the ``TEXT`` data type containing non-UTF-8 encodings, or "
"even arbitrary data. To demonstrate, let's assume we have a database with "
"ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English "
"dictionary entries. Assuming we now have a :class:`Connection` instance :py:"
"data:`!con` connected to this database, we can decode the Latin-2 encoded "
"text using this :attr:`~Connection.text_factory`:"
msgstr ""
"Devido à `tipagem flexível`_ do SQLite, não é incomum encontrar colunas de "
"tabelas com o tipo de dados ``TEXT`` contendo codificações não UTF-8, ou "
"mesmo dados arbitrários. Para demonstrar, vamos assumir que temos uma base "
"de dados com texto codificado em ISO-8859-2 (Latin-2), por exemplo, uma "
"tabela de entradas de dicionário Checo-Inglês. Assumindo que agora temos uma "
"instância :class:`Connection` :py:data:`!con` ligada a esta base de dados, "
"podemos decodificar o texto codificado em Latin-2 usando esta :attr:"
"`~Connection.text_factory`:"

#: ../../library/sqlite3.rst:2580
msgid "con.text_factory = lambda data: str(data, encoding=\"latin2\")"
msgstr "con.text_factory = lambda data: str(data, encoding=\"latin2\")"

#: ../../library/sqlite3.rst:2584
msgid ""
"For invalid UTF-8 or arbitrary data in stored in ``TEXT`` table columns, you "
"can use the following technique, borrowed from the :ref:`unicode-howto`:"
msgstr ""
"Para dados UTF-8 inválidos ou arbitrários armazenados em colunas de tabelas "
"``TEXT``, pode usar a seguinte técnica, retirada do :ref:`unicode-howto`:"

#: ../../library/sqlite3.rst:2587
msgid "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"
msgstr "con.text_factory = lambda data: str(data, errors=\"surrogateescape\")"

#: ../../library/sqlite3.rst:2593
msgid ""
"The :mod:`!sqlite3` module API does not support strings containing "
"surrogates."
msgstr ""
"A API do módulo :mod:`!sqlite3` não suporta strings contendo substitutos."

#: ../../library/sqlite3.rst:2598
msgid ":ref:`unicode-howto`"
msgstr ":ref:`unicode-howto`"

#: ../../library/sqlite3.rst:2604
msgid "Explanation"
msgstr "Explicação"

#: ../../library/sqlite3.rst:2610
msgid "Transaction control"
msgstr "Controlo de transações"

#: ../../library/sqlite3.rst:2612
msgid ""
":mod:`!sqlite3` offers multiple methods of controlling whether, when and how "
"database transactions are opened and closed. :ref:`sqlite3-transaction-"
"control-autocommit` is recommended, while :ref:`sqlite3-transaction-control-"
"isolation-level` retains the pre-Python 3.12 behaviour."
msgstr ""
":mod:`!sqlite3` oferece vários métodos de controlar quando e como as "
"transações de base de dados são abertas e fechadas. :ref:`sqlite3-"
"transaction-control-autocommit` é recomendado, enquanto :ref:`sqlite3-"
"transaction-control-isolation-level` mantém o comportamento pré-Python 3.12."

#: ../../library/sqlite3.rst:2621
msgid "Transaction control via the ``autocommit`` attribute"
msgstr "Controlo de transações através do atributo ``autocommit``"

#: ../../library/sqlite3.rst:2623
msgid ""
"The recommended way of controlling transaction behaviour is through the :"
"attr:`Connection.autocommit` attribute, which should preferably be set using "
"the *autocommit* parameter of :func:`connect`."
msgstr ""
"A forma recomendada de controlar o comportamento de transações é através do "
"atributo :attr:`Connection.autocommit`, que deve ser definido "
"preferencialmente usando o parâmetro *autocommit* de :func:`connect`."

#: ../../library/sqlite3.rst:2628
msgid ""
"It is suggested to set *autocommit* to ``False``, which implies :pep:`249`-"
"compliant transaction control. This means:"
msgstr ""
"É sugerido definir *autocommit* como ``False``, o que implica controlo de "
"transações compatível com :pep:`249`. Isto significa:"

#: ../../library/sqlite3.rst:2632
msgid ""
":mod:`!sqlite3` ensures that a transaction is always open, so :func:"
"`connect`, :meth:`Connection.commit`, and :meth:`Connection.rollback` will "
"implicitly open a new transaction (immediately after closing the pending "
"one, for the latter two). :mod:`!sqlite3` uses ``BEGIN DEFERRED`` statements "
"when opening transactions."
msgstr ""
":mod:`!sqlite3` garante que uma transação está sempre aberta, por isso :func:"
"`connect`, :meth:`Connection.commit` e :meth:`Connection.rollback` abrirão "
"implicitamente uma nova transação (imediatamente após fechar a pendente, "
"para as duas últimas). :mod:`!sqlite3` usa declarações ``BEGIN DEFERRED`` ao "
"abrir transações."

#: ../../library/sqlite3.rst:2637
msgid "Transactions should be committed explicitly using :meth:`!commit`."
msgstr ""
"As transações devem ser confirmadas explicitamente usando :meth:`!commit`."

#: ../../library/sqlite3.rst:2638
msgid "Transactions should be rolled back explicitly using :meth:`!rollback`."
msgstr ""
"As transações devem ser revertidas explicitamente usando :meth:`!rollback`."

#: ../../library/sqlite3.rst:2639
msgid ""
"An implicit rollback is performed if the database is :meth:`~Connection."
"close`-ed with pending changes."
msgstr ""
"Uma reversão implícita é realizada se a base de dados for :meth:`~Connection."
"close` com alterações pendentes."

#: ../../library/sqlite3.rst:2642
msgid ""
"Set *autocommit* to ``True`` to enable SQLite's `autocommit mode`_. In this "
"mode, :meth:`Connection.commit` and :meth:`Connection.rollback` have no "
"effect. Note that SQLite's autocommit mode is distinct from the :pep:`249`-"
"compliant :attr:`Connection.autocommit` attribute; use :attr:`Connection."
"in_transaction` to query the low-level SQLite autocommit mode."
msgstr ""
"Defina *autocommit* como ``True`` para ativar o `modo autocommit`_ do "
"SQLite. Neste modo, :meth:`Connection.commit` e :meth:`Connection.rollback` "
"não têm efeito. Note que o modo autocommit do SQLite é distinto do atributo :"
"pep:`249`-compatível :attr:`Connection.autocommit`; use :attr:`Connection."
"in_transaction` para consultar o modo autocommit de baixo nível do SQLite."

#: ../../library/sqlite3.rst:2650
msgid ""
"Set *autocommit* to :data:`LEGACY_TRANSACTION_CONTROL` to leave transaction "
"control behaviour to the :attr:`Connection.isolation_level` attribute. See :"
"ref:`sqlite3-transaction-control-isolation-level` for more information."
msgstr ""
"Defina *autocommit* para :data:`LEGACY_TRANSACTION_CONTROL` para deixar o "
"comportamento de controlo de transações ao atributo :attr:`Connection."
"isolation_level`. Veja :ref:`sqlite3-transaction-control-isolation-level` "
"para mais informações."

#: ../../library/sqlite3.rst:2659
msgid "Transaction control via the ``isolation_level`` attribute"
msgstr "Controlo de transações através do atributo ``isolation_level``"

#: ../../library/sqlite3.rst:2663
msgid ""
"The recommended way of controlling transactions is via the :attr:"
"`~Connection.autocommit` attribute. See :ref:`sqlite3-transaction-control-"
"autocommit`."
msgstr ""
"A forma recomendada de controlar transações é através do atributo :attr:"
"`~Connection.autocommit`. Veja :ref:`sqlite3-transaction-control-autocommit`."

#: ../../library/sqlite3.rst:2667
msgid ""
"If :attr:`Connection.autocommit` is set to :data:"
"`LEGACY_TRANSACTION_CONTROL` (the default), transaction behaviour is "
"controlled using the :attr:`Connection.isolation_level` attribute. "
"Otherwise, :attr:`!isolation_level` has no effect."
msgstr ""
"Se :attr:`Connection.autocommit` estiver definido para :data:"
"`LEGACY_TRANSACTION_CONTROL` (predefinição), o comportamento da transação é "
"controlado usando o atributo :attr:`Connection.isolation_level`. Caso "
"contrário, :attr:`!isolation_level` não tem efeito."

#: ../../library/sqlite3.rst:2673
msgid ""
"If the connection attribute :attr:`~Connection.isolation_level` is not "
"``None``, new transactions are implicitly opened before :meth:`~Cursor."
"execute` and :meth:`~Cursor.executemany` executes ``INSERT``, ``UPDATE``, "
"``DELETE``, or ``REPLACE`` statements; for other statements, no implicit "
"transaction handling is performed. Use the :meth:`~Connection.commit` and :"
"meth:`~Connection.rollback` methods to respectively commit and roll back "
"pending transactions. You can choose the underlying `SQLite transaction "
"behaviour`_ — that is, whether and what type of ``BEGIN`` statements :mod:`!"
"sqlite3` implicitly executes – via the :attr:`~Connection.isolation_level` "
"attribute."
msgstr ""
"Se o atributo de ligação :attr:`~Connection.isolation_level` não for "
"``None``, novas transações são implicitamente abertas antes de :meth:"
"`~Cursor.execute` e :meth:`~Cursor.executemany` executarem declarações "
"``INSERT``, ``UPDATE``, ``DELETE`` ou ``REPLACE``; para outras declarações, "
"nenhum manuseamento implícito de transações é realizado. Use os métodos :"
"meth:`~Connection.commit` e :meth:`~Connection.rollback` para confirmar e "
"reverter, respetivamente, transações pendentes. Pode escolher o "
"comportamento de transação subjacente `SQLite transaction behaviour`_ — ou "
"seja, se e que tipo de declarações ``BEGIN`` o :mod:`!sqlite3` executa "
"implicitamente — através do atributo :attr:`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2686
msgid ""
"If :attr:`~Connection.isolation_level` is set to ``None``, no transactions "
"are implicitly opened at all. This leaves the underlying SQLite library in "
"`autocommit mode`_, but also allows the user to perform their own "
"transaction handling using explicit SQL statements. The underlying SQLite "
"library autocommit mode can be queried using the :attr:`~Connection."
"in_transaction` attribute."
msgstr ""
"Se :attr:`~Connection.isolation_level` estiver definido como ``None``, "
"nenhuma transação é implicitamente aberta. Isto deixa a biblioteca SQLite "
"subjacente em `modo autocommit`_, mas também permite ao utilizador realizar "
"o seu próprio manuseamento de transações usando declarações SQL explícitas. "
"O modo autocommit da biblioteca SQLite subjacente pode ser consultado usando "
"o atributo :attr:`~Connection.in_transaction`."

#: ../../library/sqlite3.rst:2694
msgid ""
"The :meth:`~Cursor.executescript` method implicitly commits any pending "
"transaction before execution of the given SQL script, regardless of the "
"value of :attr:`~Connection.isolation_level`."
msgstr ""
"O método :meth:`~Cursor.executescript` confirma implicitamente qualquer "
"transação pendente antes da execução do script SQL dado, independentemente "
"do valor de :attr:`~Connection.isolation_level`."

#: ../../library/sqlite3.rst:2698
msgid ""
":mod:`!sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`!sqlite3` costumava confirmar implicitamente uma transação aberta "
"antes de declarações DDL. Isto já não acontece."

#: ../../library/sqlite3.rst:2702
msgid ""
"The recommended way of controlling transactions is now via the :attr:"
"`~Connection.autocommit` attribute."
msgstr ""
"A forma recomendada de controlar transações é agora através do atributo :"
"attr:`~Connection.autocommit`."

#: ../../library/sqlite3.rst:1453
msgid "? (question mark)"
msgstr "? (ponto de interrogação)"

#: ../../library/sqlite3.rst:1453 ../../library/sqlite3.rst:1454
msgid "in SQL statements"
msgstr "em declarações SQL"

#: ../../library/sqlite3.rst:1454
msgid ": (colon)"
msgstr ": (dois pontos)"
