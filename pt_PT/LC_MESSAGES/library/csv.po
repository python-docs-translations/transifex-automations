# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-07 14:58+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/csv.rst:2
msgid ":mod:`!csv` --- CSV File Reading and Writing"
msgstr ":mod:`!csv` — Leitura e escrita de ficheiros CSV"

#: ../../library/csv.rst:9
msgid "**Source code:** :source:`Lib/csv.py`"
msgstr "**Código-fonte:** :source:`Lib/csv.py`"

#: ../../library/csv.rst:17
msgid ""
"The so-called CSV (Comma Separated Values) format is the most common import "
"and export format for spreadsheets and databases.  CSV format was used for "
"many years prior to attempts to describe the format in a standardized way "
"in :rfc:`4180`.  The lack of a well-defined standard means that subtle "
"differences often exist in the data produced and consumed by different "
"applications.  These differences can make it annoying to process CSV files "
"from multiple sources. Still, while the delimiters and quoting characters "
"vary, the overall format is similar enough that it is possible to write a "
"single module which can efficiently manipulate such data, hiding the details "
"of reading and writing the data from the programmer."
msgstr ""
"O chamado formato CSV (Valores Separados por Vírgulas) é o formato de "
"importação e exportação mais comum para folhas de cálculo e bases de dados. "
"O formato CSV foi usado durante muitos anos antes das tentativas de "
"descrever o formato de uma forma padronizada em :rfc:`4180`. A falta de um "
"padrão bem definido significa que frequentemente existem diferenças subtis "
"nos dados produzidos e consumidos por diferentes aplicações. Estas "
"diferenças podem tornar irritante o processamento de ficheiros CSV de várias "
"fontes. Ainda assim, embora os delimitadores e caracteres de aspas variem, o "
"formato geral é suficientemente semelhante para que seja possível escrever "
"um único módulo que possa manipular eficientemente tais dados, escondendo os "
"detalhes de leitura e escrita dos dados do programador."

#: ../../library/csv.rst:28
msgid ""
"The :mod:`csv` module implements classes to read and write tabular data in "
"CSV format.  It allows programmers to say, \"write this data in the format "
"preferred by Excel,\" or \"read data from this file which was generated by "
"Excel,\" without knowing the precise details of the CSV format used by "
"Excel.  Programmers can also describe the CSV formats understood by other "
"applications or define their own special-purpose CSV formats."
msgstr ""
"O módulo :mod:`csv` implementa classes para ler e escrever dados tabulares "
"em formato CSV. Permite aos programadores dizer: \"escreve estes dados no "
"formato preferido pelo Excel\" ou \"lê dados deste ficheiro que foi gerado "
"pelo Excel\", sem conhecer os detalhes precisos do formato CSV usado pelo "
"Excel. Os programadores também podem descrever os formatos CSV compreendidos "
"por outras aplicações ou definir os seus próprios formatos CSV para fins "
"especiais."

#: ../../library/csv.rst:35
msgid ""
"The :mod:`csv` module's :class:`reader` and :class:`writer` objects read and "
"write sequences.  Programmers can also read and write data in dictionary "
"form using the :class:`DictReader` and :class:`DictWriter` classes."
msgstr ""
"Os objetos :class:`reader` e :class:`writer` do módulo :mod:`csv` leem e "
"escrevem sequências. Os programadores também podem ler e escrever dados em "
"formato de dicionário usando as classes :class:`DictReader` e :class:"
"`DictWriter`."

#: ../../library/csv.rst:41
msgid ":pep:`305` - CSV File API"
msgstr ":pep:`305` - API de Ficheiros CSV"

#: ../../library/csv.rst:42
msgid "The Python Enhancement Proposal which proposed this addition to Python."
msgstr "A Proposta de Melhoria do Python que propôs esta adição ao Python."

#: ../../library/csv.rst:48
msgid "Module Contents"
msgstr "Conteúdo do módulo"

#: ../../library/csv.rst:50
msgid "The :mod:`csv` module defines the following functions:"
msgstr "O módulo :mod:`csv` define as seguintes funções:"

#: ../../library/csv.rst:58
msgid ""
"Return a :ref:`reader object <reader-objects>` that will process lines from "
"the given *csvfile*.  A csvfile must be an iterable of strings, each in the "
"reader's defined csv format. A csvfile is most commonly a file-like object "
"or list. If *csvfile* is a file object, it should be opened with "
"``newline=''``. [1]_  An optional *dialect* parameter can be given which is "
"used to define a set of parameters specific to a particular CSV dialect.  It "
"may be an instance of a subclass of the :class:`Dialect` class or one of the "
"strings returned by the :func:`list_dialects` function.  The other optional "
"*fmtparams* keyword arguments can be given to override individual formatting "
"parameters in the current dialect.  For full details about the dialect and "
"formatting parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Retorna um :ref:`objeto leitor <reader-objects>` que processará linhas do "
"*csvfile* dado. Um csvfile deve ser um iterável de strings, cada uma no "
"formato csv definido pelo leitor. Um csvfile é mais comumente um objeto tipo "
"ficheiro ou uma lista. Se *csvfile* for um objeto ficheiro, deve ser aberto "
"com ``newline=''``. [1]_ Um parâmetro opcional *dialect* pode ser dado, que "
"é usado para definir um conjunto de parâmetros específicos para um dialeto "
"CSV particular. Pode ser uma instância de uma subclasse da classe :class:"
"`Dialect` ou uma das strings retornadas pela função :func:`list_dialects`. "
"Os outros argumentos opcionais *fmtparams* podem ser dados para substituir "
"parâmetros de formatação individuais no dialeto atual. Para detalhes "
"completos sobre o dialeto e parâmetros de formatação, veja a secção :ref:"
"`csv-fmt-params`."

#: ../../library/csv.rst:72
msgid ""
"Each row read from the csv file is returned as a list of strings.  No "
"automatic data type conversion is performed unless the :data:"
"`QUOTE_NONNUMERIC` format option is specified (in which case unquoted fields "
"are transformed into floats)."
msgstr ""
"Cada linha lida do ficheiro csv é retornada como uma lista de strings. "
"Nenhuma conversão automática de tipo de dados é realizada a menos que a "
"opção de formato :data:`QUOTE_NONNUMERIC` seja especificada (caso em que "
"campos não aspas são transformados em floats)."

#: ../../library/csv.rst:76 ../../library/csv.rst:106 ../../library/csv.rst:182
#: ../../library/csv.rst:220
msgid "A short usage example::"
msgstr "Um exemplo de utilização breve::"

#: ../../library/csv.rst:78
msgid ""
">>> import csv\n"
">>> with open('eggs.csv', newline='') as csvfile:\n"
"...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for row in spamreader:\n"
"...         print(', '.join(row))\n"
"Spam, Spam, Spam, Spam, Spam, Baked Beans\n"
"Spam, Lovely Spam, Wonderful Spam"
msgstr ""
">>> import csv\n"
">>> with open('ovos.csv', newline='') as csvfile:\n"
"...     leitor_presunto = csv.reader(csvfile, delimiter=' ', quotechar='|')\n"
"...     for linha in leitor_presunto:\n"
"...         print(', '.join(linha))\n"
"Presunto, Presunto, Presunto, Presunto, Presunto, Feijão Cozido\n"
"Presunto, Presunto Delicioso, Presunto Maravilhoso"

#: ../../library/csv.rst:89
msgid ""
"Return a writer object responsible for converting the user's data into "
"delimited strings on the given file-like object.  *csvfile* can be any "
"object with a :meth:`~io.TextIOBase.write` method.  If *csvfile* is a file "
"object, it should be opened with ``newline=''`` [1]_.  An optional *dialect* "
"parameter can be given which is used to define a set of parameters specific "
"to a particular CSV dialect.  It may be an instance of a subclass of the :"
"class:`Dialect` class or one of the strings returned by the :func:"
"`list_dialects` function.  The other optional *fmtparams* keyword arguments "
"can be given to override individual formatting parameters in the current "
"dialect.  For full details about dialects and formatting parameters, see "
"the :ref:`csv-fmt-params` section. To make it as easy as possible to "
"interface with modules which implement the DB API, the value :const:`None` "
"is written as the empty string.  While this isn't a reversible "
"transformation, it makes it easier to dump SQL NULL data values to CSV files "
"without preprocessing the data returned from a ``cursor.fetch*`` call. All "
"other non-string data are stringified with :func:`str` before being written."
msgstr ""
"Retorna um objeto escritor responsável por converter os dados do utilizador "
"em strings delimitadas no objeto tipo ficheiro dado. *csvfile* pode ser "
"qualquer objeto com um método :meth:`~io.TextIOBase.write`. Se *csvfile* for "
"um objeto ficheiro, deve ser aberto com ``newline=''`` [1]_. Um parâmetro "
"opcional *dialect* pode ser dado, que é usado para definir um conjunto de "
"parâmetros específicos para um dialeto CSV particular. Pode ser uma "
"instância de uma subclasse da classe :class:`Dialect` ou uma das strings "
"retornadas pela função :func:`list_dialects`. Os outros argumentos opcionais "
"*fmtparams* podem ser dados para substituir parâmetros de formatação "
"individuais no dialeto atual. Para detalhes completos sobre dialetos e "
"parâmetros de formatação, veja a secção :ref:`csv-fmt-params`. Para tornar o "
"mais fácil possível a interface com módulos que implementam a API DB, o "
"valor :const:`None` é escrito como uma string vazia. Embora isto não seja "
"uma transformação reversível, torna mais fácil descarregar valores de dados "
"SQL NULL para ficheiros CSV sem pré-processar os dados retornados de uma "
"chamada ``cursor.fetch*``. Todos os outros dados não-string são convertidos "
"em strings com :func:`str` antes de serem escritos."

#: ../../library/csv.rst:108
msgid ""
"import csv\n"
"with open('eggs.csv', 'w', newline='') as csvfile:\n"
"    spamwriter = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])\n"
"    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])"
msgstr ""
"import csv\n"
"with open('ovos.csv', 'w', newline='') as csvfile:\n"
"    escritor_presunto = csv.writer(csvfile, delimiter=' ',\n"
"                            quotechar='|', quoting=csv.QUOTE_MINIMAL)\n"
"    escritor_presunto.writerow(['Presunto'] * 5 + ['Feijão Cozido'])\n"
"    escritor_presunto.writerow(['Presunto', 'Presunto Delicioso', 'Presunto "
"Maravilhoso'])"

#: ../../library/csv.rst:118
msgid ""
"Associate *dialect* with *name*.  *name* must be a string. The dialect can "
"be specified either by passing a sub-class of :class:`Dialect`, or by "
"*fmtparams* keyword arguments, or both, with keyword arguments overriding "
"parameters of the dialect. For full details about dialects and formatting "
"parameters, see section :ref:`csv-fmt-params`."
msgstr ""
"Associa *dialect* a *name*. *name* deve ser uma string. O dialeto pode ser "
"especificado passando uma subclasse de :class:`Dialect`, ou por argumentos "
"de palavra-chave *fmtparams*, ou ambos, com argumentos de palavra-chave a "
"substituírem parâmetros do dialeto. Para detalhes completos sobre dialetos e "
"parâmetros de formatação, veja a secção :ref:`csv-fmt-params`."

#: ../../library/csv.rst:127
msgid ""
"Delete the dialect associated with *name* from the dialect registry.  An :"
"exc:`Error` is raised if *name* is not a registered dialect name."
msgstr ""
"Apaga o dialeto associado a *name* do registo de dialetos. Uma exceção :exc:"
"`Error` é levantada se *name* não for um nome de dialeto registado."

#: ../../library/csv.rst:133
msgid ""
"Return the dialect associated with *name*.  An :exc:`Error` is raised if "
"*name* is not a registered dialect name.  This function returns an "
"immutable :class:`Dialect`."
msgstr ""
"Retorna o dialeto associado a *name*. Uma exceção :exc:`Error` é levantada "
"se *name* não for um nome de dialeto registado. Esta função retorna um :"
"class:`Dialect` imutável."

#: ../../library/csv.rst:139
msgid "Return the names of all registered dialects."
msgstr "Retorna os nomes de todos os dialetos registados."

#: ../../library/csv.rst:145
msgid ""
"Returns the current maximum field size allowed by the parser. If *new_limit* "
"is given, this becomes the new limit."
msgstr ""
"Retorna o tamanho máximo atual de campo permitido pelo analisador. Se "
"*new_limit* for dado, este torna-se o novo limite."

#: ../../library/csv.rst:149
msgid "The :mod:`csv` module defines the following classes:"
msgstr "O módulo :mod:`csv` define as seguintes classes:"

#: ../../library/csv.rst:154
msgid ""
"Create an object that operates like a regular reader but maps the "
"information in each row to a :class:`dict` whose keys are given by the "
"optional *fieldnames* parameter."
msgstr ""
"Cria um objeto que opera como um leitor normal, mas mapeia as informações em "
"cada linha para um :class:`dict` cujas chaves são dadas pelo parâmetro "
"opcional *fieldnames*."

#: ../../library/csv.rst:158
msgid ""
"The *fieldnames* parameter is a :term:`sequence`.  If *fieldnames* is "
"omitted, the values in the first row of file *f* will be used as the "
"fieldnames and will be omitted from the results. If *fieldnames* is "
"provided, they will be used and the first row will be included in the "
"results.  Regardless of how the fieldnames are determined, the dictionary "
"preserves their original ordering."
msgstr ""
"O parâmetro *fieldnames* é uma :term:`sequência`. Se *fieldnames* for "
"omitido, os valores na primeira linha do ficheiro *f* serão usados como os "
"nomes dos campos e serão omitidos dos resultados. Se *fieldnames* for "
"fornecido, serão usados e a primeira linha será incluída nos resultados. "
"Independentemente de como os nomes dos campos são determinados, o dicionário "
"preserva a sua ordem original."

#: ../../library/csv.rst:165
msgid ""
"If a row has more fields than fieldnames, the remaining data is put in a "
"list and stored with the fieldname specified by *restkey* (which defaults to "
"``None``).  If a non-blank row has fewer fields than fieldnames, the missing "
"values are filled-in with the value of *restval* (which defaults to "
"``None``)."
msgstr ""
"Se uma linha tiver mais campos do que fieldnames, os dados restantes são "
"colocados numa lista e armazenados com o nome do campo especificado por "
"*restkey* (que por defeito é ``None``). Se uma linha não vazia tiver menos "
"campos do que fieldnames, os valores em falta são preenchidos com o valor de "
"*restval* (que por defeito é ``None``)."

#: ../../library/csv.rst:171
msgid ""
"All other optional or keyword arguments are passed to the underlying :class:"
"`reader` instance."
msgstr ""
"Todos os outros argumentos opcionais ou de palavra-chave são passados para a "
"instância subjacente :class:`reader`."

#: ../../library/csv.rst:174 ../../library/csv.rst:218
msgid ""
"If the argument passed to *fieldnames* is an iterator, it will be coerced to "
"a :class:`list`."
msgstr ""
"Se o argumento passado a *fieldnames* for um iterador, será convertido para "
"uma :class:`list`."

#: ../../library/csv.rst:176
msgid "Returned rows are now of type :class:`OrderedDict`."
msgstr "As linhas retornadas são agora do tipo :class:`OrderedDict`."

#: ../../library/csv.rst:179
msgid "Returned rows are now of type :class:`dict`."
msgstr "As linhas retornadas são agora do tipo :class:`dict`."

#: ../../library/csv.rst:184
msgid ""
">>> import csv\n"
">>> with open('names.csv', newline='') as csvfile:\n"
"...     reader = csv.DictReader(csvfile)\n"
"...     for row in reader:\n"
"...         print(row['first_name'], row['last_name'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(row)\n"
"{'first_name': 'John', 'last_name': 'Cleese'}"
msgstr ""
">>> import csv\n"
">>> with open('nomes.csv', newline='') as csvfile:\n"
"...     leitor = csv.DictReader(csvfile)\n"
"...     for linha in leitor:\n"
"...         print(linha['primeiro_nome'], linha['último_nome'])\n"
"...\n"
"Eric Idle\n"
"John Cleese\n"
"\n"
">>> print(linha)\n"
"{'primeiro_nome': 'John', 'último_nome': 'Cleese'}"

#: ../../library/csv.rst:200
msgid ""
"Create an object which operates like a regular writer but maps dictionaries "
"onto output rows.  The *fieldnames* parameter is a :mod:`sequence "
"<collections.abc>` of keys that identify the order in which values in the "
"dictionary passed to the :meth:`~csvwriter.writerow` method are written to "
"file *f*.  The optional *restval* parameter specifies the value to be "
"written if the dictionary is missing a key in *fieldnames*.  If the "
"dictionary passed to the :meth:`~csvwriter.writerow` method contains a key "
"not found in *fieldnames*, the optional *extrasaction* parameter indicates "
"what action to take. If it is set to ``'raise'``, the default value, a :exc:"
"`ValueError` is raised. If it is set to ``'ignore'``, extra values in the "
"dictionary are ignored. Any other optional or keyword arguments are passed "
"to the underlying :class:`writer` instance."
msgstr ""
"Cria um objeto que opera como um escritor normal, mas mapeia dicionários "
"para linhas de saída. O parâmetro *fieldnames* é uma :mod:`sequência "
"<collections.abc>` de chaves que identificam a ordem pela qual os valores no "
"dicionário passado ao método :meth:`~csvwriter.writerow` são escritos no "
"ficheiro *f*. O parâmetro opcional *restval* especifica o valor a ser "
"escrito se o dicionário estiver em falta de uma chave em *fieldnames*. Se o "
"dicionário passado ao método :meth:`~csvwriter.writerow` contiver uma chave "
"não encontrada em *fieldnames*, o parâmetro opcional *extrasaction* indica "
"que ação tomar. Se for definido como ``'raise'``, o valor padrão, uma "
"exceção :exc:`ValueError` é levantada. Se for definido como ``'ignore'``, "
"valores extra no dicionário são ignorados. Quaisquer outros argumentos "
"opcionais ou de palavra-chave são passados para a instância subjacente :"
"class:`writer`."

#: ../../library/csv.rst:215
msgid ""
"Note that unlike the :class:`DictReader` class, the *fieldnames* parameter "
"of the :class:`DictWriter` class is not optional."
msgstr ""
"Note que, ao contrário da classe :class:`DictReader`, o parâmetro "
"*fieldnames* da classe :class:`DictWriter` não é opcional."

#: ../../library/csv.rst:222
msgid ""
"import csv\n"
"\n"
"with open('names.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['first_name', 'last_name']\n"
"    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    writer.writeheader()\n"
"    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})\n"
"    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})\n"
"    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})"
msgstr ""
"import csv\n"
"\n"
"with open('nomes.csv', 'w', newline='') as csvfile:\n"
"    fieldnames = ['primeiro_nome', 'último_nome']\n"
"    escritor = csv.DictWriter(csvfile, fieldnames=fieldnames)\n"
"\n"
"    escritor.writeheader()\n"
"    escritor.writerow({'primeiro_nome': 'Feijão', 'último_nome': 'Cozido'})\n"
"    escritor.writerow({'primeiro_nome': 'Presunto', 'último_nome': "
"'Delicioso'})\n"
"    escritor.writerow({'primeiro_nome': 'Presunto', 'último_nome': "
"'Maravilhoso'})"

#: ../../library/csv.rst:236
msgid ""
"The :class:`Dialect` class is a container class whose attributes contain "
"information for how to handle doublequotes, whitespace, delimiters, etc. Due "
"to the lack of a strict CSV specification, different applications produce "
"subtly different CSV data.  :class:`Dialect` instances define how :class:"
"`reader` and :class:`writer` instances behave."
msgstr ""
"A classe :class:`Dialect` é uma classe contentora cujos atributos contêm "
"informações sobre como lidar com aspas duplas, espaços em branco, "
"delimitadores, etc. Devido à falta de uma especificação CSV rigorosa, "
"diferentes aplicações produzem dados CSV subtamente diferentes. As "
"instâncias :class:`Dialect` definem como as instâncias :class:`reader` e :"
"class:`writer` se comportam."

#: ../../library/csv.rst:242
msgid ""
"All available :class:`Dialect` names are returned by :func:`list_dialects`, "
"and they can be registered with specific :class:`reader` and :class:`writer` "
"classes through their initializer (``__init__``) functions like this::"
msgstr ""
"Todos os nomes de :class:`Dialect` disponíveis são retornados por :func:"
"`list_dialects`, e podem ser registados com classes específicas :class:"
"`reader` e :class:`writer` através das suas funções de inicialização "
"(``__init__``) assim::"

#: ../../library/csv.rst:246
msgid ""
"import csv\n"
"\n"
"with open('students.csv', 'w', newline='') as csvfile:\n"
"    writer = csv.writer(csvfile, dialect='unix')"
msgstr ""
"import csv\n"
"\n"
"with open('alunos.csv', 'w', newline='') as csvfile:\n"
"    escritor = csv.writer(csvfile, dialect='unix')"

#: ../../library/csv.rst:254
msgid ""
"The :class:`excel` class defines the usual properties of an Excel-generated "
"CSV file.  It is registered with the dialect name ``'excel'``."
msgstr ""
"A classe :class:`excel` define as propriedades habituais de um ficheiro CSV "
"gerado pelo Excel. Está registada com o nome de dialeto ``'excel'``."

#: ../../library/csv.rst:260
msgid ""
"The :class:`excel_tab` class defines the usual properties of an Excel-"
"generated TAB-delimited file.  It is registered with the dialect name "
"``'excel-tab'``."
msgstr ""
"A classe :class:`excel_tab` define as propriedades habituais de um ficheiro "
"delimitado por TAB gerado pelo Excel. Está registada com o nome de dialeto "
"``'excel-tab'``."

#: ../../library/csv.rst:266
msgid ""
"The :class:`unix_dialect` class defines the usual properties of a CSV file "
"generated on UNIX systems, i.e. using ``'\\n'`` as line terminator and "
"quoting all fields.  It is registered with the dialect name ``'unix'``."
msgstr ""
"A classe :class:`unix_dialect` define as propriedades habituais de um "
"ficheiro CSV gerado em sistemas UNIX, ou seja, usando ``'\\n'`` como "
"terminador de linha e colocando aspas em todos os campos. Está registada com "
"o nome de dialeto ``'unix'``."

#: ../../library/csv.rst:275
msgid "The :class:`Sniffer` class is used to deduce the format of a CSV file."
msgstr ""
"A classe :class:`Sniffer` é usada para deduzir o formato de um ficheiro CSV."

#: ../../library/csv.rst:277
msgid "The :class:`Sniffer` class provides two methods:"
msgstr "A classe :class:`Sniffer` fornece dois métodos:"

#: ../../library/csv.rst:281
msgid ""
"Analyze the given *sample* and return a :class:`Dialect` subclass reflecting "
"the parameters found.  If the optional *delimiters* parameter is given, it "
"is interpreted as a string containing possible valid delimiter characters."
msgstr ""
"Analisa a *sample* dada e retorna uma subclasse :class:`Dialect` que reflete "
"os parâmetros encontrados. Se o parâmetro opcional *delimiters* for dado, é "
"interpretado como uma string contendo caracteres delimitadores válidos "
"possíveis."

#: ../../library/csv.rst:289
msgid ""
"Analyze the sample text (presumed to be in CSV format) and return :const:"
"`True` if the first row appears to be a series of column headers. Inspecting "
"each column, one of two key criteria will be considered to estimate if the "
"sample contains a header:"
msgstr ""
"Analisa o texto de exemplo (presumivelmente em formato CSV) e retorna :const:"
"`True` se a primeira linha parecer ser uma série de cabeçalhos de coluna. "
"Inspecionando cada coluna, um de dois critérios chave será considerado para "
"estimar se o exemplo contém um cabeçalho:"

#: ../../library/csv.rst:294
msgid "the second through n-th rows contain numeric values"
msgstr "as linhas da segunda à n-ésima contêm valores numéricos"

#: ../../library/csv.rst:295
msgid ""
"the second through n-th rows contain strings where at least one value's "
"length differs from that of the putative header of that column."
msgstr ""
"as linhas da segunda à n-ésima contêm strings onde pelo menos um valor tem "
"um comprimento diferente do cabeçalho putativo dessa coluna."

#: ../../library/csv.rst:298
msgid ""
"Twenty-one rows after the header are sampled; if more than half of the "
"columns + rows meet the criteria, :const:`True` is returned."
msgstr ""
"Vinte e uma linhas após o cabeçalho são amostradas; se mais de metade das "
"colunas + linhas cumprirem os critérios, :const:`True` é retornado."

#: ../../library/csv.rst:303
msgid ""
"This method is a rough heuristic and may produce both false positives and "
"negatives."
msgstr ""
"Este método é uma heurística aproximada e pode produzir falsos positivos e "
"negativos."

#: ../../library/csv.rst:306
msgid "An example for :class:`Sniffer` use::"
msgstr "Um exemplo de utilização de :class:`Sniffer`::"

#: ../../library/csv.rst:308
msgid ""
"with open('example.csv', newline='') as csvfile:\n"
"    dialect = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    reader = csv.reader(csvfile, dialect)\n"
"    # ... process CSV file contents here ..."
msgstr ""
"with open('exemplo.csv', newline='') as csvfile:\n"
"    dialeto = csv.Sniffer().sniff(csvfile.read(1024))\n"
"    csvfile.seek(0)\n"
"    leitor = csv.reader(csvfile, dialeto)\n"
"    # ... processar conteúdo do ficheiro CSV aqui ..."

#: ../../library/csv.rst:317
msgid "The :mod:`csv` module defines the following constants:"
msgstr "O módulo :mod:`csv` define as seguintes constantes:"

#: ../../library/csv.rst:321
msgid "Instructs :class:`writer` objects to quote all fields."
msgstr "Instrui os objetos :class:`writer` a colocar aspas em todos os campos."

#: ../../library/csv.rst:326
msgid ""
"Instructs :class:`writer` objects to only quote those fields which contain "
"special characters such as *delimiter*, *quotechar*, ``'\\r'``, ``'\\n'`` or "
"any of the characters in *lineterminator*."
msgstr ""
"Instrui os objetos :class:`writer` a colocar aspas apenas nos campos que "
"contêm caracteres especiais como *delimiter*, *quotechar*, ``'\\r'``, "
"``'\\n'`` ou quaisquer dos caracteres em *lineterminator*."

#: ../../library/csv.rst:333
msgid "Instructs :class:`writer` objects to quote all non-numeric fields."
msgstr ""
"Instrui os objetos :class:`writer` a colocar aspas em todos os campos não "
"numéricos."

#: ../../library/csv.rst:335
msgid ""
"Instructs :class:`reader` objects to convert all non-quoted fields to type :"
"class:`float`."
msgstr ""
"Instrui os objetos :class:`reader` a converter todos os campos não aspas "
"para o tipo :class:`float`."

#: ../../library/csv.rst:338
msgid ""
"Some numeric types, such as :class:`bool`, :class:`~fractions.Fraction`, or :"
"class:`~enum.IntEnum`, have a string representation that cannot be converted "
"to :class:`float`. They cannot be read in the :data:`QUOTE_NONNUMERIC` and :"
"data:`QUOTE_STRINGS` modes."
msgstr ""
"Alguns tipos numéricos, como :class:`bool`, :class:`~fractions.Fraction` ou :"
"class:`~enum.IntEnum`, têm uma representação de string que não pode ser "
"convertida para :class:`float`. Não podem ser lidos nos modos :data:"
"`QUOTE_NONNUMERIC` e :data:`QUOTE_STRINGS`."

#: ../../library/csv.rst:346
msgid ""
"Instructs :class:`writer` objects to never quote fields. When the current "
"*delimiter*, *quotechar*, *escapechar*, ``'\\r'``, ``'\\n'`` or any of the "
"characters in *lineterminator* occurs in output data it is preceded by the "
"current *escapechar* character. If *escapechar* is not set, the writer will "
"raise :exc:`Error` if any characters that require escaping are encountered. "
"Set *quotechar* to ``None`` to prevent its escaping."
msgstr ""
"Instrui os objetos :class:`writer` a nunca colocarem aspas nos campos. "
"Quando o *delimiter*, *quotechar*, *escapechar*, ``'\\r'``, ``'\\n'`` ou "
"quaisquer dos caracteres em *lineterminator* ocorrerem nos dados de saída, "
"são precedidos pelo carácter *escapechar* atual. Se *escapechar* não estiver "
"definido, o escritor levantará :exc:`Error` se forem encontrados caracteres "
"que requeiram escape. Defina *quotechar* para ``None`` para evitar o seu "
"escape."

#: ../../library/csv.rst:354
msgid ""
"Instructs :class:`reader` objects to perform no special processing of quote "
"characters."
msgstr ""
"Instrui os objetos :class:`reader` a não realizarem processamento especial "
"de caracteres de aspas."

#: ../../library/csv.rst:358
msgid ""
"Instructs :class:`writer` objects to quote all fields which are not "
"``None``.  This is similar to :data:`QUOTE_ALL`, except that if a field "
"value is ``None`` an empty (unquoted) string is written."
msgstr ""
"Instrui os objetos :class:`writer` a colocarem aspas em todos os campos que "
"não são ``None``. Isto é semelhante a :data:`QUOTE_ALL`, exceto que se o "
"valor do campo for ``None`` uma string vazia (sem aspas) é escrita."

#: ../../library/csv.rst:362
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) field as "
"``None`` and to otherwise behave as :data:`QUOTE_ALL`."
msgstr ""
"Instrui os objetos :class:`reader` a interpretarem um campo vazio (sem "
"aspas) como ``None`` e a comportarem-se de outra forma como :data:"
"`QUOTE_ALL`."

#: ../../library/csv.rst:369
msgid ""
"Instructs :class:`writer` objects to always place quotes around fields which "
"are strings.  This is similar to :data:`QUOTE_NONNUMERIC`, except that if a "
"field value is ``None`` an empty (unquoted) string is written."
msgstr ""
"Instrui os objetos :class:`writer` a colocarem sempre aspas em campos que "
"são strings. Isto é semelhante a :data:`QUOTE_NONNUMERIC`, exceto que se o "
"valor do campo for ``None`` uma string vazia (sem aspas) é escrita."

#: ../../library/csv.rst:373
msgid ""
"Instructs :class:`reader` objects to interpret an empty (unquoted) string as "
"``None`` and to otherwise behave as :data:`QUOTE_NONNUMERIC`."
msgstr ""
"Instrui os objetos :class:`reader` a interpretarem uma string vazia (sem "
"aspas) como ``None`` e a comportarem-se de outra forma como :data:"
"`QUOTE_NONNUMERIC`."

#: ../../library/csv.rst:378
msgid "The :mod:`csv` module defines the following exception:"
msgstr "O módulo :mod:`csv` define a seguinte exceção:"

#: ../../library/csv.rst:383
msgid "Raised by any of the functions when an error is detected."
msgstr "Levantada por qualquer uma das funções quando um erro é detetado."

#: ../../library/csv.rst:388
msgid "Dialects and Formatting Parameters"
msgstr "Dialetos e parâmetros de formatação"

#: ../../library/csv.rst:390
msgid ""
"To make it easier to specify the format of input and output records, "
"specific formatting parameters are grouped together into dialects.  A "
"dialect is a subclass of the :class:`Dialect` class containing various "
"attributes describing the format of the CSV file.  When creating :class:"
"`reader` or :class:`writer` objects, the programmer can specify a string or "
"a subclass of the :class:`Dialect` class as the dialect parameter.  In "
"addition to, or instead of, the *dialect* parameter, the programmer can also "
"specify individual formatting parameters, which have the same names as the "
"attributes defined below for the :class:`Dialect` class."
msgstr ""
"Para facilitar a especificação do formato dos registos de entrada e saída, "
"parâmetros de formatação específicos são agrupados em dialetos. Um dialeto é "
"uma subclasse da classe :class:`Dialect` que contém vários atributos que "
"descrevem o formato do ficheiro CSV. Ao criar objetos :class:`reader` ou :"
"class:`writer`, o programador pode especificar uma string ou uma subclasse "
"da classe :class:`Dialect` como o parâmetro de dialeto. Além disso, ou em "
"vez do parâmetro *dialect*, o programador também pode especificar parâmetros "
"de formatação individuais, que têm os mesmos nomes que os atributos "
"definidos abaixo para a classe :class:`Dialect`."

#: ../../library/csv.rst:400
msgid "Dialects support the following attributes:"
msgstr "Os dialetos suportam os seguintes atributos:"

#: ../../library/csv.rst:405
msgid ""
"A one-character string used to separate fields.  It defaults to ``','``."
msgstr ""
"Uma string de um carácter usada para separar campos. O valor predefinido é "
"``','``."

#: ../../library/csv.rst:410
msgid ""
"Controls how instances of *quotechar* appearing inside a field should "
"themselves be quoted.  When :const:`True`, the character is doubled. When :"
"const:`False`, the *escapechar* is used as a prefix to the *quotechar*.  It "
"defaults to :const:`True`."
msgstr ""
"Controla como as instâncias de *quotechar* que aparecem dentro de um campo "
"devem ser elas próprias colocadas entre aspas. Quando :const:`True`, o "
"carácter é duplicado. Quando :const:`False`, o *escapechar* é usado como "
"prefixo para o *quotechar*. O valor predefinido é :const:`True`."

#: ../../library/csv.rst:415
msgid ""
"On output, if *doublequote* is :const:`False` and no *escapechar* is set, :"
"exc:`Error` is raised if a *quotechar* is found in a field."
msgstr ""
"Na saída, se *doublequote* for :const:`False` e nenhum *escapechar* estiver "
"definido, :exc:`Error` é levantado se um *quotechar* for encontrado num "
"campo."

#: ../../library/csv.rst:421
msgid ""
"A one-character string used by the writer to escape characters that require "
"escaping:"
msgstr ""
"Uma string de um carácter usada pelo escritor para escapar caracteres que "
"requerem escape:"

#: ../../library/csv.rst:424
msgid ""
"the *delimiter*, the *quotechar*, ``'\\r'``, ``'\\n'`` and any of the "
"characters in *lineterminator* are escaped if *quoting* is set to :const:"
"`QUOTE_NONE`;"
msgstr ""
"o *delimiter*, o *quotechar*, ``'\\r'``, ``'\\n'`` e quaisquer dos "
"caracteres em *lineterminator* são escapados se *quoting* estiver definido "
"para :const:`QUOTE_NONE`;"

#: ../../library/csv.rst:427
msgid "the *quotechar* is escaped if *doublequote* is :const:`False`;"
msgstr "o *quotechar* é escapado se *doublequote* for :const:`False`;"

#: ../../library/csv.rst:428
msgid "the *escapechar* itself."
msgstr "o próprio *escapechar*."

#: ../../library/csv.rst:430
msgid ""
"On reading, the *escapechar* removes any special meaning from the following "
"character. It defaults to :const:`None`, which disables escaping."
msgstr ""
"Na leitura, o *escapechar* remove qualquer significado especial do carácter "
"seguinte. O valor predefinido é :const:`None`, que desativa o escape."

#: ../../library/csv.rst:433
msgid "An empty *escapechar* is not allowed."
msgstr "Um *escapechar* vazio não é permitido."

#: ../../library/csv.rst:438
msgid ""
"The string used to terminate lines produced by the :class:`writer`. It "
"defaults to ``'\\r\\n'``."
msgstr ""
"A string usada para terminar linhas produzidas pelo :class:`writer`. O valor "
"predefinido é ``'\\r\\n'``."

#: ../../library/csv.rst:443
msgid ""
"The :class:`reader` is hard-coded to recognise either ``'\\r'`` or ``'\\n'`` "
"as end-of-line, and ignores *lineterminator*. This behavior may change in "
"the future."
msgstr ""
"O :class:`reader` está codificado para reconhecer ``'\\r'`` ou ``'\\n'`` "
"como fim de linha e ignora *lineterminator*. Este comportamento pode mudar "
"no futuro."

#: ../../library/csv.rst:450
msgid ""
"A one-character string used to quote fields containing special characters, "
"such as the *delimiter* or the *quotechar*, or which contain new-line "
"characters (``'\\r'``, ``'\\n'`` or any of the characters in "
"*lineterminator*). It defaults to ``'\"'``. Can be set to ``None`` to "
"prevent escaping ``'\"'`` if *quoting* is set to :const:`QUOTE_NONE`."
msgstr ""
"Uma string de um carácter usada para colocar aspas em campos que contêm "
"caracteres especiais, como o *delimiter* ou o *quotechar*, ou que contêm "
"caracteres de nova linha (``'\\r'``, ``'\\n'`` ou quaisquer dos caracteres "
"em *lineterminator*). O valor predefinido é ``'\"'``. Pode ser definido como "
"``None`` para evitar o escape de ``'\"'`` se *quoting* estiver definido "
"como :const:`QUOTE_NONE`."

#: ../../library/csv.rst:457
msgid "An empty *quotechar* is not allowed."
msgstr "Um *quotechar* vazio não é permitido."

#: ../../library/csv.rst:462
msgid ""
"Controls when quotes should be generated by the writer and recognised by the "
"reader.  It can take on any of the :ref:`QUOTE_\\* constants <csv-"
"constants>` and defaults to :const:`QUOTE_MINIMAL` if *quotechar* is not "
"``None``, and :const:`QUOTE_NONE` otherwise."
msgstr ""
"Controla quando as aspas devem ser geradas pelo escritor e reconhecidas pelo "
"leitor. Pode assumir qualquer um dos :ref:`constantes QUOTE_\\* <csv-"
"constants>` e o valor predefinido é :const:`QUOTE_MINIMAL` se *quotechar* "
"não for ``None``, e :const:`QUOTE_NONE` caso contrário."

#: ../../library/csv.rst:470
msgid ""
"When :const:`True`, spaces immediately following the *delimiter* are "
"ignored. The default is :const:`False`.  When combining ``delimiter=' '`` "
"with ``skipinitialspace=True``, unquoted empty fields are not allowed."
msgstr ""
"Quando :const:`True`, os espaços imediatamente a seguir ao *delimiter* são "
"ignorados. O valor predefinido é :const:`False`. Quando se combina "
"``delimiter=' '`` com ``skipinitialspace=True``, campos vazios não aspas não "
"são permitidos."

#: ../../library/csv.rst:477
msgid ""
"When ``True``, raise exception :exc:`Error` on bad CSV input. The default is "
"``False``."
msgstr ""
"Quando ``True``, levanta a exceção :exc:`Error` em caso de entrada CSV "
"inválida. O valor predefinido é ``False``."

#: ../../library/csv.rst:483
msgid "Reader Objects"
msgstr "Objetos Leitor"

#: ../../library/csv.rst:485
msgid ""
"Reader objects (:class:`DictReader` instances and objects returned by the :"
"func:`reader` function) have the following public methods:"
msgstr ""
"Objetos Leitor (:class:`DictReader` instâncias e objetos retornados pela "
"função :func:`reader`) têm os seguintes métodos públicos:"

#: ../../library/csv.rst:490
msgid ""
"Return the next row of the reader's iterable object as a list (if the object "
"was returned from :func:`reader`) or a dict (if it is a :class:`DictReader` "
"instance), parsed according to the current :class:`Dialect`.  Usually you "
"should call this as ``next(reader)``."
msgstr ""
"Retorna a próxima linha do objeto iterável do leitor como uma lista (se o "
"objeto foi retornado de :func:`reader`) ou um dicionário (se for uma "
"instância :class:`DictReader`), analisado de acordo com o :class:`Dialect` "
"atual. Normalmente deve chamar isto como ``next(reader)``."

#: ../../library/csv.rst:496
msgid "Reader objects have the following public attributes:"
msgstr "Objetos Leitor têm os seguintes atributos públicos:"

#: ../../library/csv.rst:500
msgid "A read-only description of the dialect in use by the parser."
msgstr "Uma descrição de apenas leitura do dialeto em uso pelo analisador."

#: ../../library/csv.rst:505
msgid ""
"The number of lines read from the source iterator. This is not the same as "
"the number of records returned, as records can span multiple lines."
msgstr ""
"O número de linhas lidas do iterador de origem. Isto não é o mesmo que o "
"número de registos retornados, uma vez que os registos podem abranger várias "
"linhas."

#: ../../library/csv.rst:509
msgid "DictReader objects have the following public attribute:"
msgstr "Objetos DictReader têm o seguinte atributo público:"

#: ../../library/csv.rst:513
msgid ""
"If not passed as a parameter when creating the object, this attribute is "
"initialized upon first access or when the first record is read from the file."
msgstr ""
"Se não for passado como parâmetro ao criar o objeto, este atributo é "
"inicializado no primeiro acesso ou quando o primeiro registo é lido do "
"ficheiro."

#: ../../library/csv.rst:520
msgid "Writer Objects"
msgstr "Objetos Escritor"

#: ../../library/csv.rst:522
msgid ""
":class:`writer` objects (:class:`DictWriter` instances and objects returned "
"by the :func:`writer` function) have the following public methods.  A *row* "
"must be an iterable of strings or numbers for :class:`writer` objects and a "
"dictionary mapping fieldnames to strings or numbers (by passing them "
"through :func:`str` first) for :class:`DictWriter` objects.  Note that "
"complex numbers are written out surrounded by parens. This may cause some "
"problems for other programs which read CSV files (assuming they support "
"complex numbers at all)."
msgstr ""
"Objetos :class:`writer` (instâncias :class:`DictWriter` e objetos retornados "
"pela função :func:`writer`) têm os seguintes métodos públicos. Uma *row* "
"deve ser um iterável de strings ou números para objetos :class:`writer` e um "
"dicionário que mapeia nomes de campos para strings ou números (passando-os "
"primeiro por :func:`str`) para objetos :class:`DictWriter`. Note que números "
"complexos são escritos cercados por parênteses. Isto pode causar alguns "
"problemas para outros programas que leem ficheiros CSV (assumindo que "
"suportam números complexos)."

#: ../../library/csv.rst:533
msgid ""
"Write the *row* parameter to the writer's file object, formatted according "
"to the current :class:`Dialect`. Return the return value of the call to the "
"*write* method of the underlying file object."
msgstr ""
"Escreve o parâmetro *row* no objeto ficheiro do escritor, formatado de "
"acordo com o :class:`Dialect` atual. Retorna o valor de retorno da chamada "
"ao método *write* do objeto ficheiro subjacente."

#: ../../library/csv.rst:537
msgid "Added support of arbitrary iterables."
msgstr "Adicionado suporte para iteráveis arbitrários."

#: ../../library/csv.rst:542
msgid ""
"Write all elements in *rows* (an iterable of *row* objects as described "
"above) to the writer's file object, formatted according to the current "
"dialect."
msgstr ""
"Escreve todos os elementos em *rows* (um iterável de objetos *row* como "
"descrito acima) no objeto ficheiro do escritor, formatado de acordo com o "
"dialeto atual."

#: ../../library/csv.rst:546
msgid "Writer objects have the following public attribute:"
msgstr "Objetos Escritor têm o seguinte atributo público:"

#: ../../library/csv.rst:551
msgid "A read-only description of the dialect in use by the writer."
msgstr "Uma descrição de apenas leitura do dialeto em uso pelo escritor."

#: ../../library/csv.rst:554
msgid "DictWriter objects have the following public method:"
msgstr "Objetos DictWriter têm o seguinte método público:"

#: ../../library/csv.rst:559
msgid ""
"Write a row with the field names (as specified in the constructor) to the "
"writer's file object, formatted according to the current dialect. Return the "
"return value of the :meth:`csvwriter.writerow` call used internally."
msgstr ""
"Escreve uma linha com os nomes dos campos (como especificado no construtor) "
"no objeto ficheiro do escritor, formatado de acordo com o dialeto atual. "
"Retorna o valor de retorno da chamada :meth:`csvwriter.writerow` usada "
"internamente."

#: ../../library/csv.rst:564
msgid ""
":meth:`writeheader` now also returns the value returned by the :meth:"
"`csvwriter.writerow` method it uses internally."
msgstr ""
":meth:`writeheader` agora também retorna o valor retornado pelo método :meth:"
"`csvwriter.writerow` que usa internamente."

#: ../../library/csv.rst:572
msgid "Examples"
msgstr "Exemplos"

#: ../../library/csv.rst:574
msgid "The simplest example of reading a CSV file::"
msgstr "O exemplo mais simples de leitura de um ficheiro CSV::"

#: ../../library/csv.rst:576
msgid ""
"import csv\n"
"with open('some.csv', newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('algum.csv', newline='') as f:\n"
"    leitor = csv.reader(f)\n"
"    for linha in leitor:\n"
"        print(linha)"

#: ../../library/csv.rst:582
msgid "Reading a file with an alternate format::"
msgstr "Ler um ficheiro com um formato alternativo::"

#: ../../library/csv.rst:584
msgid ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('passwd', newline='') as f:\n"
"    leitor = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)\n"
"    for linha in leitor:\n"
"        print(linha)"

#: ../../library/csv.rst:590
msgid "The corresponding simplest possible writing example is::"
msgstr "O exemplo de escrita mais simples possível correspondente é::"

#: ../../library/csv.rst:592
msgid ""
"import csv\n"
"with open('some.csv', 'w', newline='') as f:\n"
"    writer = csv.writer(f)\n"
"    writer.writerows(someiterable)"
msgstr ""
"import csv\n"
"with open('algum.csv', 'w', newline='') as f:\n"
"    escritor = csv.writer(f)\n"
"    escritor.writerows(algum_iterável)"

#: ../../library/csv.rst:597
msgid ""
"Since :func:`open` is used to open a CSV file for reading, the file will by "
"default be decoded into unicode using the system default encoding (see :func:"
"`locale.getencoding`).  To decode a file using a different encoding, use the "
"``encoding`` argument of open::"
msgstr ""
"Como :func:`open` é usado para abrir um ficheiro CSV para leitura, o "
"ficheiro será, por defeito, decodificado para unicode usando a codificação "
"padrão do sistema (veja :func:`locale.getencoding`). Para decodificar um "
"ficheiro usando uma codificação diferente, use o argumento ``encoding`` de "
"open::"

#: ../../library/csv.rst:602
msgid ""
"import csv\n"
"with open('some.csv', newline='', encoding='utf-8') as f:\n"
"    reader = csv.reader(f)\n"
"    for row in reader:\n"
"        print(row)"
msgstr ""
"import csv\n"
"with open('algum.csv', newline='', encoding='utf-8') as f:\n"
"    leitor = csv.reader(f)\n"
"    for linha in leitor:\n"
"        print(linha)"

#: ../../library/csv.rst:608
msgid ""
"The same applies to writing in something other than the system default "
"encoding: specify the encoding argument when opening the output file."
msgstr ""
"O mesmo se aplica à escrita em algo diferente da codificação padrão do "
"sistema: especifique o argumento de codificação ao abrir o ficheiro de saída."

#: ../../library/csv.rst:611
msgid "Registering a new dialect::"
msgstr "Registar um novo dialeto::"

#: ../../library/csv.rst:613
msgid ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    reader = csv.reader(f, 'unixpwd')"
msgstr ""
"import csv\n"
"csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n"
"with open('passwd', newline='') as f:\n"
"    leitor = csv.reader(f, 'unixpwd')"

#: ../../library/csv.rst:618
msgid ""
"A slightly more advanced use of the reader --- catching and reporting "
"errors::"
msgstr ""
"Uma utilização um pouco mais avançada do leitor — capturar e reportar erros::"

#: ../../library/csv.rst:620
msgid ""
"import csv, sys\n"
"filename = 'some.csv'\n"
"with open(filename, newline='') as f:\n"
"    reader = csv.reader(f)\n"
"    try:\n"
"        for row in reader:\n"
"            print(row)\n"
"    except csv.Error as e:\n"
"        sys.exit(f'file {filename}, line {reader.line_num}: {e}')"
msgstr ""
"import csv, sys\n"
"filename = 'algum.csv'\n"
"with open(filename, newline='') as f:\n"
"    leitor = csv.reader(f)\n"
"    try:\n"
"        for linha in leitor:\n"
"            print(linha)\n"
"    except csv.Error as e:\n"
"        sys.exit(f'ficheiro {filename}, linha {leitor.line_num}: {e}')"

#: ../../library/csv.rst:630
msgid ""
"And while the module doesn't directly support parsing strings, it can easily "
"be done::"
msgstr ""
"E embora o módulo não suporte diretamente a análise de strings, pode ser "
"facilmente feito::"

#: ../../library/csv.rst:633
msgid ""
"import csv\n"
"for row in csv.reader(['one,two,three']):\n"
"    print(row)"
msgstr ""
"import csv\n"
"for linha in csv.reader(['um,dois,três']):\n"
"    print(linha)"

#: ../../library/csv.rst:639
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/csv.rst:640
msgid ""
"If ``newline=''`` is not specified, newlines embedded inside quoted fields "
"will not be interpreted correctly, and on platforms that use ``\\r\\n`` line "
"endings on write an extra ``\\r`` will be added.  It should always be safe "
"to specify ``newline=''``, since the csv module does its own (:term:"
"`universal <universal newlines>`) newline handling."
msgstr ""
"Se ``newline=''`` não for especificado, as novas linhas incorporadas dentro "
"de campos com aspas não serão interpretadas corretamente, e em plataformas "
"que usam terminações de linha ``\\r\\n`` na escrita, um ``\\r`` extra será "
"adicionado. Deve ser sempre seguro especificar ``newline=''``, uma vez que o "
"módulo csv faz o seu próprio tratamento de novas linhas (:term:`universal "
"<universal newlines>`)."

#: ../../library/csv.rst:11
msgid "csv"
msgstr "csv"

#: ../../library/csv.rst:11
msgid "data"
msgstr "dados"

#: ../../library/csv.rst:11
msgid "tabular"
msgstr "tabular"

#: ../../library/csv.rst:53
msgid "universal newlines"
msgstr "novas linhas universais"

#: ../../library/csv.rst:53
msgid "csv.reader function"
msgstr "função csv.reader"
