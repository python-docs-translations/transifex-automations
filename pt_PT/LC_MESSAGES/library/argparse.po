# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-11 14:18+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/argparse.rst:2
msgid ""
":mod:`!argparse` --- Parser for command-line options, arguments and "
"subcommands"
msgstr ""
":mod:`!argparse` — Analisador para opções, argumentos e subcomandos da linha "
"de comandos"

#: ../../library/argparse.rst:12
msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**Código-fonte:** :source:`Lib/argparse.py`"

#: ../../library/argparse.rst:16
msgid ""
"While :mod:`argparse` is the default recommended standard library module for "
"implementing basic command line applications, authors with more exacting "
"requirements for exactly how their command line applications behave may find "
"it doesn't provide the necessary level of control. Refer to :ref:`choosing-"
"an-argument-parser` for alternatives to consider when ``argparse`` doesn't "
"support behaviors that the application requires (such as entirely disabling "
"support for interspersed options and positional arguments, or accepting "
"option parameter values that start with ``-`` even when they correspond to "
"another defined option)."
msgstr ""
"Embora :mod:`argparse` seja o módulo da biblioteca padrão recomendado por "
"defeito para implementar aplicações básicas de linha de comandos, autores "
"com requisitos mais exigentes sobre o comportamento exato das suas "
"aplicações de linha de comandos podem descobrir que este não fornece o nível "
"de controlo necessário. Consulte :ref:`choosing-an-argument-parser` para "
"alternativas a considerar quando ``argparse`` não suporta comportamentos que "
"a aplicação requer (como desativar completamente o suporte para opções e "
"argumentos posicionais intercalados, ou aceitar valores de parâmetros de "
"opções que começam com ``-`` mesmo quando correspondem a outra opção "
"definida)."

#: ../../library/argparse.rst:28
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/argparse.rst:30
msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the :ref:"
"`argparse tutorial <argparse-tutorial>`."
msgstr ""
"Esta página contém informações de referência da API. Para uma introdução "
"mais suave à análise de linha de comandos em Python, consulte o :ref:"
"`tutorial do argparse <argparse-tutorial>`. "

#: ../../library/argparse.rst:34
msgid ""
"The :mod:`!argparse` module makes it easy to write user-friendly command-"
"line interfaces. The program defines what arguments it requires, and :mod:`!"
"argparse` will figure out how to parse those out of :data:`sys.argv`.  The :"
"mod:`!argparse` module also automatically generates help and usage "
"messages.  The module will also issue errors when users give the program "
"invalid arguments."
msgstr ""
"O módulo :mod:`!argparse` facilita a escrita de interfaces de linha de "
"comandos amigáveis. O programa define os argumentos que necessita e o :mod:`!"
"argparse` descobre como analisá-los a partir de :data:`sys.argv`. O módulo :"
"mod:`!argparse` também gera automaticamente mensagens de ajuda e uso. O "
"módulo também emite erros quando os utilizadores fornecem argumentos "
"inválidos ao programa."

#: ../../library/argparse.rst:40
msgid ""
"The :mod:`!argparse` module's support for command-line interfaces is built "
"around an instance of :class:`argparse.ArgumentParser`.  It is a container "
"for argument specifications and has options that apply to the parser as "
"whole::"
msgstr ""
"O suporte do módulo :mod:`!argparse` para interfaces de linha de comandos é "
"construído em torno de uma instância de :class:`argparse.ArgumentParser`. É "
"um contentor para especificações de argumentos e tem opções que se aplicam "
"ao analisador como um todo::"

#: ../../library/argparse.rst:44
msgid ""
"parser = argparse.ArgumentParser(\n"
"                    prog='ProgramName',\n"
"                    description='What the program does',\n"
"                    epilog='Text at the bottom of help')"
msgstr ""
"parser = argparse.ArgumentParser(\n"
"                    prog='NomeDoPrograma',\n"
"                    description='O que o programa faz',\n"
"                    epilog='Texto no final da ajuda')"

#: ../../library/argparse.rst:49
msgid ""
"The :meth:`ArgumentParser.add_argument` method attaches individual argument "
"specifications to the parser.  It supports positional arguments, options "
"that accept values, and on/off flags::"
msgstr ""
"O método :meth:`ArgumentParser.add_argument` anexa especificações "
"individuais de argumentos ao analisador. Suporta argumentos posicionais, "
"opções que aceitam valores e flags ligar/desligar::"

#: ../../library/argparse.rst:53
msgid ""
"parser.add_argument('filename')           # positional argument\n"
"parser.add_argument('-c', '--count')      # option that takes a value\n"
"parser.add_argument('-v', '--verbose',\n"
"                    action='store_true')  # on/off flag"
msgstr ""
"parser.add_argument('nome_ficheiro')           # argumento posicional\n"
"parser.add_argument('-c', '--contagem')      # opção que aceita um valor\n"
"parser.add_argument('-v', '--verboso',\n"
"                    action='store_true')  # flag ligar/desligar"

#: ../../library/argparse.rst:58
msgid ""
"The :meth:`ArgumentParser.parse_args` method runs the parser and places the "
"extracted data in a :class:`argparse.Namespace` object::"
msgstr ""
"O método :meth:`ArgumentParser.parse_args` executa o analisador e coloca os "
"dados extraídos num objeto :class:`argparse.Namespace`::"

#: ../../library/argparse.rst:61
msgid ""
"args = parser.parse_args()\n"
"print(args.filename, args.count, args.verbose)"
msgstr ""
"args = parser.parse_args()\n"
"print(args.nome_ficheiro, args.contagem, args.verboso)"

#: ../../library/argparse.rst:65
msgid ""
"If you're looking for a guide about how to upgrade :mod:`optparse` code to :"
"mod:`!argparse`, see :ref:`Upgrading Optparse Code <upgrading-optparse-"
"code>`."
msgstr ""
"Se está à procura de um guia sobre como atualizar o código :mod:`optparse` "
"para :mod:`!argparse`, consulte :ref:`Atualizar Código Optparse <upgrading-"
"optparse-code>`. "

#: ../../library/argparse.rst:69
msgid "ArgumentParser objects"
msgstr "Objetos ArgumentParser"

#: ../../library/argparse.rst:79
msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed "
"as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"Cria um novo objeto :class:`ArgumentParser`. Todos os parâmetros devem ser "
"passados como argumentos de palavra-chave. Cada parâmetro tem a sua própria "
"descrição mais detalhada abaixo, mas em resumo são:"

#: ../../library/argparse.rst:83
msgid ""
"prog_ - The name of the program (default: generated from the ``__main__`` "
"module attributes and ``sys.argv[0]``)"
msgstr ""
"prog_ — O nome do programa (predefinição: gerado a partir dos atributos do "
"módulo ``__main__`` e ``sys.argv[0]``)"

#: ../../library/argparse.rst:86
msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr ""
"usage_ — A string que descreve o uso do programa (predefinição: gerada a "
"partir dos argumentos adicionados ao analisador)"

#: ../../library/argparse.rst:89
msgid ""
"description_ - Text to display before the argument help (by default, no text)"
msgstr ""
"description_ — Texto a mostrar antes da ajuda do argumento (por "
"predefinição, sem texto)"

#: ../../library/argparse.rst:92
msgid "epilog_ - Text to display after the argument help (by default, no text)"
msgstr ""
"epilog_ — Texto a mostrar após a ajuda do argumento (por predefinição, sem "
"texto)"

#: ../../library/argparse.rst:94
msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr ""
"parents_ — Uma lista de objetos :class:`ArgumentParser` cujos argumentos "
"também devem ser incluídos"

#: ../../library/argparse.rst:97
msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ — Uma classe para personalizar a saída de ajuda"

#: ../../library/argparse.rst:99
msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""
"prefix_chars_ — O conjunto de caracteres que prefixam argumentos opcionais "
"(predefinição: '-')"

#: ../../library/argparse.rst:102
msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr ""
"fromfile_prefix_chars_ — O conjunto de caracteres que prefixam ficheiros a "
"partir dos quais devem ser lidos argumentos adicionais (predefinição: "
"``None``)"

#: ../../library/argparse.rst:105
msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""
"argument_default_ — O valor predefinido global para argumentos "
"(predefinição: ``None``)"

#: ../../library/argparse.rst:108
msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""
"conflict_handler_ — A estratégia para resolver opcionais conflitantes "
"(geralmente desnecessário)"

#: ../../library/argparse.rst:111
msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""
"add_help_ — Adicionar uma opção ``-h/--help`` ao analisador (predefinição: "
"``True``)"

#: ../../library/argparse.rst:113
msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is "
"unambiguous (default: ``True``)"
msgstr ""
"allow_abbrev_ — Permite que opções longas sejam abreviadas se a abreviatura "
"for inequívoca (predefinição: ``True``)"

#: ../../library/argparse.rst:116
msgid ""
"exit_on_error_ - Determines whether or not :class:`!ArgumentParser` exits "
"with error info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ — Determina se :class:`!ArgumentParser` sai com informações "
"de erro quando ocorre um erro. (predefinição: ``True``)"

#: ../../library/argparse.rst:119
msgid ""
"suggest_on_error_ - Enables suggestions for mistyped argument choices and "
"subparser names (default: ``False``)"
msgstr ""
"suggest_on_error_ — Ativa sugestões para escolhas de argumentos mal escritas "
"e nomes de subanalisadores (predefinição: ``False``)"

#: ../../library/argparse.rst:122
msgid "color_ - Allow color output (default: ``True``)"
msgstr "color_ — Permitir saída a cores (predefinição: ``True``)"

#: ../../library/argparse.rst:124
msgid "*allow_abbrev* parameter was added."
msgstr "O parâmetro *allow_abbrev* foi adicionado."

#: ../../library/argparse.rst:127
msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr ""
"Em versões anteriores, *allow_abbrev* também desativava o agrupamento de "
"flags curtas como ``-vv`` para significar ``-v -v``."

#: ../../library/argparse.rst:131
msgid "*exit_on_error* parameter was added."
msgstr "O parâmetro *exit_on_error* foi adicionado."

#: ../../library/argparse.rst:134
msgid "*suggest_on_error* and *color* parameters were added."
msgstr "Os parâmetros *suggest_on_error* e *color* foram adicionados."

#: ../../library/argparse.rst:137 ../../library/argparse.rst:696
msgid "The following sections describe how each of these are used."
msgstr "As secções seguintes descrevem como cada um destes é utilizado."

#: ../../library/argparse.rst:143
msgid "prog"
msgstr "prog"

#: ../../library/argparse.rst:146
msgid ""
"By default, :class:`ArgumentParser` calculates the name of the program to "
"display in help messages depending on the way the Python interpreter was run:"
msgstr ""
"Por predefinição, :class:`ArgumentParser` calcula o nome do programa a "
"mostrar nas mensagens de ajuda dependendo da forma como o interpretador "
"Python foi executado:"

#: ../../library/argparse.rst:149
msgid ""
"The :func:`base name <os.path.basename>` of ``sys.argv[0]`` if a file was "
"passed as argument."
msgstr ""
"O :func:`nome base <os.path.basename>` de ``sys.argv[0]`` se um ficheiro foi "
"passado como argumento."

#: ../../library/argparse.rst:151
msgid ""
"The Python interpreter name followed by ``sys.argv[0]`` if a directory or a "
"zipfile was passed as argument."
msgstr ""
"O nome do interpretador Python seguido de ``sys.argv[0]`` se um diretório ou "
"um ficheiro zip foi passado como argumento."

#: ../../library/argparse.rst:153
msgid ""
"The Python interpreter name followed by ``-m`` followed by the module or "
"package name if the :option:`-m` option was used."
msgstr ""
"O nome do interpretador Python seguido de ``-m`` seguido pelo nome do módulo "
"ou pacote se a opção :option:`-m` foi usada."

#: ../../library/argparse.rst:156
msgid ""
"This default is almost always desirable because it will make the help "
"messages match the string that was used to invoke the program on the command "
"line. However, to change this default behavior, another value can be "
"supplied using the ``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Esta predefinição é quase sempre desejável porque fará com que as mensagens "
"de ajuda correspondam à string que foi usada para invocar o programa na "
"linha de comandos. No entanto, para alterar este comportamento predefinido, "
"outro valor pode ser fornecido usando o argumento ``prog=`` para :class:"
"`ArgumentParser`::"

#: ../../library/argparse.rst:161
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='meuprograma')\n"
">>> parser.print_help()\n"
"uso: meuprograma [-h]\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair"

#: ../../library/argparse.rst:168
msgid ""
"Note that the program name, whether determined from ``sys.argv[0]``, from "
"the ``__main__`` module attributes or from the ``prog=`` argument, is "
"available to help messages using the ``%(prog)s`` format specifier."
msgstr ""
"Note que o nome do programa, seja determinado a partir de ``sys.argv[0]``, "
"dos atributos do módulo ``__main__`` ou do argumento ``prog=``, está "
"disponível para mensagens de ajuda usando o especificador de formato "
"``%(prog)s``."

#: ../../library/argparse.rst:175
msgid ""
">>> parser = argparse.ArgumentParser(prog='myprogram')\n"
">>> parser.add_argument('--foo', help='foo of the %(prog)s program')\n"
">>> parser.print_help()\n"
"usage: myprogram [-h] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   foo of the myprogram program"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='meuprograma')\n"
">>> parser.add_argument('--foo', help='foo do programa %(prog)s')\n"
">>> parser.print_help()\n"
"uso: meuprograma [-h] [--foo FOO]\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
" --foo FOO   foo do programa meuprograma"

#: ../../library/argparse.rst:184
msgid ""
"The default ``prog`` value now reflects how ``__main__`` was actually "
"executed, rather than always being ``os.path.basename(sys.argv[0])``."
msgstr ""
"O valor predefinido de ``prog`` agora reflete como ``__main__`` foi "
"realmente executado, em vez de ser sempre ``os.path.basename(sys.argv[0])``."

#: ../../library/argparse.rst:189
msgid "usage"
msgstr "uso"

#: ../../library/argparse.rst:191
msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains. The default message can be overridden with the "
"``usage=`` keyword argument::"
msgstr ""
"Por predefinição, :class:`ArgumentParser` calcula a mensagem de uso a partir "
"dos argumentos que contém. A mensagem predefinida pode ser substituída com o "
"argumento nomeado ``usage=``::"

#: ../../library/argparse.rst:195
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[options]')\n"
">>> parser.add_argument('--foo', nargs='?', help='foo help')\n"
">>> parser.add_argument('bar', nargs='+', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [options]\n"
"\n"
"positional arguments:\n"
" bar          bar help\n"
"\n"
"options:\n"
" -h, --help   show this help message and exit\n"
" --foo [FOO]  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s "
"[opções]')\n"
">>> parser.add_argument('--foo', nargs='?', help='ajuda foo')\n"
">>> parser.add_argument('bar', nargs='+', help='ajuda bar')\n"
">>> parser.print_help()\n"
"uso: PROG [opções]\n"
"\n"
"argumentos posicionais:\n"
" bar          ajuda bar\n"
"\n"
"opções:\n"
" -h, --help   mostrar esta mensagem de ajuda e sair\n"
" --foo [FOO]  ajuda foo"

#: ../../library/argparse.rst:208
msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr ""
"O especificador de formato ``%(prog)s`` está disponível para preencher o "
"nome do programa nas suas mensagens de uso."

#: ../../library/argparse.rst:211
msgid ""
"When a custom usage message is specified for the main parser, you may also "
"want to consider passing  the ``prog`` argument to :meth:`~ArgumentParser."
"add_subparsers` or the ``prog`` and the ``usage`` arguments to :meth:"
"`~_SubParsersAction.add_parser`, to ensure consistent command prefixes and "
"usage information across subparsers."
msgstr ""
"Quando uma mensagem de uso personalizada é especificada para o analisador "
"principal, também pode querer considerar passar o argumento ``prog`` para :"
"meth:`~ArgumentParser.add_subparsers` ou os argumentos ``prog`` e ``usage`` "
"para :meth:`~_SubParsersAction.add_parser`, para garantir prefixos de "
"comando consistentes e informações de uso em todos os subanalisadores."

#: ../../library/argparse.rst:221
msgid "description"
msgstr "descrição"

#: ../../library/argparse.rst:223
msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments."
msgstr ""
"A maioria das chamadas para o construtor :class:`ArgumentParser` usará o "
"argumento nomeado ``description=``. Este argumento fornece uma breve "
"descrição do que o programa faz e como funciona. Nas mensagens de ajuda, a "
"descrição é exibida entre a string de uso da linha de comandos e as "
"mensagens de ajuda para os vários argumentos."

#: ../../library/argparse.rst:229
msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr ""
"Por predefinição, a descrição será ajustada à linha para que se encaixe no "
"espaço dado. Para alterar este comportamento, consulte o argumento "
"formatter_class_."

#: ../../library/argparse.rst:234
msgid "epilog"
msgstr "epílogo"

#: ../../library/argparse.rst:236
msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Alguns programas gostam de exibir uma descrição adicional do programa após a "
"descrição dos argumentos. Tal texto pode ser especificado usando o argumento "
"``epilog=`` para :class:`ArgumentParser`::"

#: ../../library/argparse.rst:240
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='A foo that bars',\n"
"...     epilog=\"And that's how you'd foo a bar\")\n"
">>> parser.print_help()\n"
"usage: argparse.py [-h]\n"
"\n"
"A foo that bars\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"And that's how you'd foo a bar"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     description='Um foo que faz bars',\n"
"...     epilog=\"E é assim que se faz foo a um bar\")\n"
">>> parser.print_help()\n"
"uso: argparse.py [-h]\n"
"\n"
"Um foo que faz bars\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
"\n"
"E é assim que se faz foo a um bar"

#: ../../library/argparse.rst:253
msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"Tal como com o argumento description_, o texto ``epilog=`` é ajustado à "
"linha por predefinição, mas este comportamento pode ser ajustado com o "
"argumento formatter_class_ para :class:`ArgumentParser`."

#: ../../library/argparse.rst:259
msgid "parents"
msgstr "pais"

#: ../../library/argparse.rst:261
msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to :class:"
"`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :"
"class:`ArgumentParser` objects, collects all the positional and optional "
"actions from them, and adds these actions to the :class:`ArgumentParser` "
"object being constructed::"
msgstr ""
"Às vezes, vários analisadores partilham um conjunto comum de argumentos. Em "
"vez de repetir as definições destes argumentos, um único analisador com "
"todos os argumentos partilhados pode ser passado para o argumento "
"``parents=`` do :class:`ArgumentParser`. O argumento ``parents=`` recebe uma "
"lista de objetos :class:`ArgumentParser`, recolhe todas as ações posicionais "
"e opcionais deles e adiciona estas ações ao objeto :class:`ArgumentParser` "
"que está a ser construído::"

#: ../../library/argparse.rst:268
msgid ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"
msgstr ""
">>> parent_parser = argparse.ArgumentParser(add_help=False)\n"
">>> parent_parser.add_argument('--parent', type=int)\n"
"\n"
">>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> foo_parser.add_argument('foo')\n"
">>> foo_parser.parse_args(['--parent', '2', 'XXX'])\n"
"Namespace(foo='XXX', parent=2)\n"
"\n"
">>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])\n"
">>> bar_parser.add_argument('--bar')\n"
">>> bar_parser.parse_args(['--bar', 'YYY'])\n"
"Namespace(bar='YYY', parent=None)"

#: ../../library/argparse.rst:281
msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"Note que a maioria dos analisadores pais especificará ``add_help=False``. "
"Caso contrário, o :class:`ArgumentParser` verá duas opções ``-h/--help`` "
"(uma no pai e outra no filho) e levantará um erro."

#: ../../library/argparse.rst:286
msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr ""
"Deve inicializar completamente os analisadores antes de os passar via "
"``parents=``. Se alterar os analisadores pais após o analisador filho, essas "
"alterações não serão refletidas no filho."

#: ../../library/argparse.rst:294
msgid "formatter_class"
msgstr "formatter_class"

#: ../../library/argparse.rst:296
msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such "
"classes:"
msgstr ""
"Os objetos :class:`ArgumentParser` permitem que a formatação da ajuda seja "
"personalizada especificando uma classe de formatação alternativa. "
"Atualmente, existem quatro dessas classes:"

#: ../../library/argparse.rst:305
msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, :class:"
"`ArgumentParser` objects line-wrap the description_ and epilog_ texts in "
"command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` e :class:`RawTextHelpFormatter` dão "
"mais controlo sobre como as descrições textuais são exibidas. Por "
"predefinição, os objetos :class:`ArgumentParser` ajustam as linhas dos "
"textos de descrição_ e epílogo_ nas mensagens de ajuda da linha de comandos::"

#: ../../library/argparse.rst:310
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''this description\n"
"...         was indented weird\n"
"...             but that is okay''',\n"
"...     epilog='''\n"
"...             likewise for this epilog whose whitespace will\n"
"...         be cleaned up and whose words will be wrapped\n"
"...         across a couple lines''')\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"this description was indented weird but that is okay\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
"\n"
"likewise for this epilog whose whitespace will be cleaned up and whose "
"words\n"
"will be wrapped across a couple lines"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     description='''esta descrição\n"
"...         estava indentada de forma estranha\n"
"...             mas isso não é problema''',\n"
"...     epilog='''\n"
"...             o mesmo para este epílogo cujo espaço em branco será\n"
"...         limpo e cujas palavras serão ajustadas\n"
"...         em algumas linhas''')\n"
">>> parser.print_help()\n"
"uso: PROG [-h]\n"
"\n"
"esta descrição estava indentada de forma estranha mas isso não é problema\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
"\n"
"o mesmo para este epílogo cujo espaço em branco será limpo e cujas palavras "
"serão ajustadas em algumas linhas"

#: ../../library/argparse.rst:330
msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"Passar :class:`RawDescriptionHelpFormatter` como ``formatter_class=`` indica "
"que description_ e epilog_ já estão corretamente formatados e não devem ser "
"ajustados à linha::"

#: ../../library/argparse.rst:334
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Please do not mess up this text!\n"
"...         --------------------------------\n"
"...             I have indented it\n"
"...             exactly the way\n"
"...             I want it\n"
"...         '''))\n"
">>> parser.print_help()\n"
"usage: PROG [-h]\n"
"\n"
"Please do not mess up this text!\n"
"--------------------------------\n"
"   I have indented it\n"
"   exactly the way\n"
"   I want it\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.RawDescriptionHelpFormatter,\n"
"...     description=textwrap.dedent('''\\\n"
"...         Por favor não estrague este texto!\n"
"...         --------------------------------\n"
"...             Eu indentámo-lo\n"
"...             exatamente da forma\n"
"...             que eu quero\n"
"...         '''))\n"
">>> parser.print_help()\n"
"uso: PROG [-h]\n"
"\n"
"Por favor não estrague este texto!\n"
"--------------------------------\n"
"   Eu indentámo-lo\n"
"   exatamente da forma\n"
"   que eu quero\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair"

#: ../../library/argparse.rst:356
msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple newlines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` mantém o espaço em branco para todo o tipo de "
"texto de ajuda, incluindo descrições de argumentos. No entanto, várias novas "
"linhas são substituídas por uma. Se desejar preservar várias linhas em "
"branco, adicione espaços entre as novas linhas."

#: ../../library/argparse.rst:361
msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` adiciona automaticamente informações "
"sobre valores predefinidos a cada uma das mensagens de ajuda dos argumentos::"

#: ../../library/argparse.rst:364
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"positional arguments:\n"
" bar         BAR! (default: [1, 2, 3])\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO   FOO! (default: 42)"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int, default=42, help='FOO!')\n"
">>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')\n"
">>> parser.print_help()\n"
"uso: PROG [-h] [--foo FOO] [bar ...]\n"
"\n"
"argumentos posicionais:\n"
" bar         BAR! (predefinição: [1, 2, 3])\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
" --foo FOO   FOO! (predefinição: 42)"

#: ../../library/argparse.rst:379
msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` usa o nome do argumento type_ para cada "
"argumento como o nome de exibição para os seus valores (em vez de usar o "
"dest_ como o formatador regular faz)::"

#: ../../library/argparse.rst:383
msgid ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [--foo int] float\n"
"\n"
"positional arguments:\n"
"  float\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo int"
msgstr ""
">>> parser = argparse.ArgumentParser(\n"
"...     prog='PROG',\n"
"...     formatter_class=argparse.MetavarTypeHelpFormatter)\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', type=float)\n"
">>> parser.print_help()\n"
"uso: PROG [-h] [--foo int] float\n"
"\n"
"argumentos posicionais:\n"
"  float\n"
"\n"
"opções:\n"
"  -h, --help  mostrar esta mensagem de ajuda e sair\n"
"  --foo int"

#: ../../library/argparse.rst:400
msgid "prefix_chars"
msgstr "prefix_chars"

#: ../../library/argparse.rst:402
msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g. "
"for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the :class:`ArgumentParser` constructor::"
msgstr ""
"A maioria das opções de linha de comandos usará ``-`` como prefixo, por "
"exemplo, ``-f/--foo``. Analisadores que precisam suportar caracteres de "
"prefixo diferentes ou adicionais, por exemplo, para opções como ``+f`` ou ``/"
"foo``, podem especificá-los usando o argumento ``prefix_chars=`` no "
"construtor :class:`ArgumentParser`::"

#: ../../library/argparse.rst:408
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')\n"
">>> parser.add_argument('+f')\n"
">>> parser.add_argument('++bar')\n"
">>> parser.parse_args('+f X ++bar Y'.split())\n"
"Namespace(bar='Y', f='X')"

#: ../../library/argparse.rst:414
msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be "
"disallowed."
msgstr ""
"O argumento ``prefix_chars=`` tem como predefinição ``'-'``. Fornecer um "
"conjunto de caracteres que não inclui ``-`` fará com que as opções ``-f/--"
"foo`` não sejam permitidas."

#: ../../library/argparse.rst:420
msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

#: ../../library/argparse.rst:422
msgid ""
"Sometimes, when dealing with a particularly long argument list, it may make "
"sense to keep the list of arguments in a file rather than typing it out at "
"the command line.  If the ``fromfile_prefix_chars=`` argument is given to "
"the :class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be replaced "
"by the arguments they contain.  For example::"
msgstr ""
"Às vezes, ao lidar com uma lista de argumentos particularmente longa, pode "
"fazer sentido manter a lista de argumentos num ficheiro em vez de a digitar "
"na linha de comandos. Se o argumento ``fromfile_prefix_chars=`` for "
"fornecido ao construtor :class:`ArgumentParser`, então argumentos que "
"comecem com qualquer um dos caracteres especificados serão tratados como "
"ficheiros e serão substituídos pelos argumentos que contêm. Por exemplo::"

#: ../../library/argparse.rst:429
msgid ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"
msgstr ""
">>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:\n"
"...     fp.write('-f\\nbar')\n"
"...\n"
">>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')\n"
">>> parser.add_argument('-f')\n"
">>> parser.parse_args(['-f', 'foo', '@args.txt'])\n"
"Namespace(f='bar')"

#: ../../library/argparse.rst:437
msgid ""
"Arguments read from a file must be one per line by default (but see also :"
"meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they "
"were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-"
"f', 'bar']``."
msgstr ""
"Por predefinição, os argumentos lidos de um ficheiro devem ser um por linha "
"(mas veja também :meth:`~ArgumentParser.convert_arg_line_to_args`) e são "
"tratados como se estivessem no mesmo local que o argumento de referência do "
"ficheiro original na linha de comandos. Assim, no exemplo acima, a expressão "
"``['-f', 'foo', '@args.txt']`` é considerada equivalente à expressão ``['-"
"f', 'foo', '-f', 'bar']``."

#: ../../library/argparse.rst:445
msgid ""
"Empty lines are treated as empty strings (``''``), which are allowed as "
"values but not as arguments. Empty lines that are read as arguments will "
"result in an \"unrecognized arguments\" error."
msgstr ""
"Linhas vazias são tratadas como strings vazias (``''``), que são permitidas "
"como valores mas não como argumentos. Linhas vazias que são lidas como "
"argumentos resultarão num erro de \"argumentos não reconhecidos\"."

#: ../../library/argparse.rst:449
msgid ""
":class:`ArgumentParser` uses :term:`filesystem encoding and error handler` "
"to read the file containing arguments."
msgstr ""
":class:`ArgumentParser` usa a :term:`codificação do sistema de ficheiros e "
"manipulador de erros` para ler o ficheiro contendo os argumentos."

#: ../../library/argparse.rst:452
msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr ""
"O argumento ``fromfile_prefix_chars=`` tem como predefinição ``None``, o que "
"significa que os argumentos nunca serão tratados como referências de "
"ficheiros."

#: ../../library/argparse.rst:455
msgid ""
":class:`ArgumentParser` changed encoding and errors to read arguments files "
"from default (e.g. :func:`locale.getpreferredencoding(False) <locale."
"getpreferredencoding>` and ``\"strict\"``) to the :term:`filesystem encoding "
"and error handler`. Arguments file should be encoded in UTF-8 instead of "
"ANSI Codepage on Windows."
msgstr ""
":class:`ArgumentParser` alterou a codificação e erros para ler ficheiros de "
"argumentos da predefinição (por exemplo, :func:`locale."
"getpreferredencoding(False) <locale.getpreferredencoding>` e ``\"strict\"``) "
"para a :term:`codificação do sistema de ficheiros e manipulador de erros`. O "
"ficheiro de argumentos deve ser codificado em UTF-8 em vez de ANSI Codepage "
"no Windows."

#: ../../library/argparse.rst:463
msgid "argument_default"
msgstr "argument_default"

#: ../../library/argparse.rst:465
msgid ""
"Generally, argument defaults are specified either by passing a default to :"
"meth:`~ArgumentParser.add_argument` or by calling the :meth:`~ArgumentParser."
"set_defaults` methods with a specific set of name-value pairs.  Sometimes "
"however, it may be useful to specify a single parser-wide default for "
"arguments.  This can be accomplished by passing the ``argument_default=`` "
"keyword argument to :class:`ArgumentParser`.  For example, to globally "
"suppress attribute creation on :meth:`~ArgumentParser.parse_args` calls, we "
"supply ``argument_default=SUPPRESS``::"
msgstr ""
"Geralmente, os valores predefinidos dos argumentos são especificados "
"passando um valor predefinido para :meth:`~ArgumentParser.add_argument` ou "
"chamando os métodos :meth:`~ArgumentParser.set_defaults` com um conjunto "
"específico de pares nome-valor. No entanto, às vezes pode ser útil "
"especificar um valor predefinido global para argumentos. Isto pode ser "
"realizado passando o argumento de palavra-chave ``argument_default=`` para :"
"class:`ArgumentParser`. Por exemplo, para suprimir globalmente a criação de "
"atributos em chamadas :meth:`~ArgumentParser.parse_args`, fornecemos "
"``argument_default=SUPPRESS``::"

#: ../../library/argparse.rst:474
msgid ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"
msgstr ""
">>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar', nargs='?')\n"
">>> parser.parse_args(['--foo', '1', 'BAR'])\n"
"Namespace(bar='BAR', foo='1')\n"
">>> parser.parse_args([])\n"
"Namespace()"

#: ../../library/argparse.rst:485
msgid "allow_abbrev"
msgstr "allow_abbrev"

#: ../../library/argparse.rst:487
msgid ""
"Normally, when you pass an argument list to the :meth:`~ArgumentParser."
"parse_args` method of an :class:`ArgumentParser`, it :ref:`recognizes "
"abbreviations <prefix-matching>` of long options."
msgstr ""
"Normalmente, quando passa uma lista de argumentos para o método :meth:"
"`~ArgumentParser.parse_args` de um :class:`ArgumentParser`, este :ref:"
"`reconhece abreviaturas <prefix-matching>` de opções longas."

#: ../../library/argparse.rst:491
msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""
"Esta funcionalidade pode ser desativada definindo ``allow_abbrev`` como "
"``False``::"

#: ../../library/argparse.rst:493
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"usage: PROG [-h] [--foobar] [--foonley]\n"
"PROG: error: unrecognized arguments: --foon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)\n"
">>> parser.add_argument('--foobar', action='store_true')\n"
">>> parser.add_argument('--foonley', action='store_false')\n"
">>> parser.parse_args(['--foon'])\n"
"uso: PROG [-h] [--foobar] [--foonley]\n"
"PROG: erro: argumentos não reconhecidos: --foon"

#: ../../library/argparse.rst:504
msgid "conflict_handler"
msgstr "conflict_handler"

#: ../../library/argparse.rst:506
msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
"Os objetos :class:`ArgumentParser` não permitem duas ações com a mesma "
"string de opção. Por predefinição, os objetos :class:`ArgumentParser` "
"levantam uma exceção se for feita uma tentativa de criar um argumento com "
"uma string de opção que já está em uso::"

#: ../../library/argparse.rst:511
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argument --foo: conflicting option string(s): --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo', help='ajuda antiga foo')\n"
">>> parser.add_argument('--foo', help='ajuda nova foo')\n"
"Traceback (most recent call last):\n"
" ..\n"
"ArgumentError: argumento --foo: string(s) de opção conflitante(s): --foo"

#: ../../library/argparse.rst:518
msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any "
"older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument "
"of :class:`ArgumentParser`::"
msgstr ""
"Às vezes (por exemplo, ao usar parents_) pode ser útil simplesmente "
"substituir quaisquer argumentos mais antigos com a mesma string de opção. "
"Para obter este comportamento, o valor ``'resolve'`` pode ser fornecido ao "
"argumento ``conflict_handler=`` de :class:`ArgumentParser`::"

#: ../../library/argparse.rst:523
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='old foo help')\n"
">>> parser.add_argument('--foo', help='new foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" -f FOO      old foo help\n"
" --foo FOO   new foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', "
"conflict_handler='resolve')\n"
">>> parser.add_argument('-f', '--foo', help='ajuda antiga foo')\n"
">>> parser.add_argument('--foo', help='ajuda nova foo')\n"
">>> parser.print_help()\n"
"uso: PROG [-h] [-f FOO] [--foo FOO]\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
" -f FOO      ajuda antiga foo\n"
" --foo FOO   ajuda nova foo"

#: ../../library/argparse.rst:534
msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old ``-f/--"
"foo`` action is retained as the ``-f`` action, because only the ``--foo`` "
"option string was overridden."
msgstr ""
"Note que os objetos :class:`ArgumentParser` removem uma ação apenas se todas "
"as suas strings de opção forem substituídas. Assim, no exemplo acima, a "
"antiga ação ``-f/--foo`` é mantida como a ação ``-f``, porque apenas a "
"string de opção ``--foo`` foi substituída."

#: ../../library/argparse.rst:541
msgid "add_help"
msgstr "add_help"

#: ../../library/argparse.rst:543
msgid ""
"By default, :class:`ArgumentParser` objects add an option which simply "
"displays the parser's help message. If ``-h`` or ``--help`` is supplied at "
"the command line, the :class:`!ArgumentParser` help will be printed."
msgstr ""
"Por predefinição, os objetos :class:`ArgumentParser` adicionam uma opção que "
"simplesmente mostra a mensagem de ajuda do analisador. Se ``-h`` ou ``--"
"help`` for fornecido na linha de comandos, a ajuda do :class:`!"
"ArgumentParser` será impressa."

#: ../../library/argparse.rst:547
msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to :"
"class:`ArgumentParser`::"
msgstr ""
"Ocasionalmente, pode ser útil desativar a adição desta opção de ajuda. Isto "
"pode ser alcançado passando ``False`` como o argumento ``add_help=`` para :"
"class:`ArgumentParser`::"

#: ../../library/argparse.rst:551
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='foo help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO]\n"
"\n"
"options:\n"
" --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> parser.add_argument('--foo', help='ajuda foo')\n"
">>> parser.print_help()\n"
"uso: PROG [--foo FOO]\n"
"\n"
"opções:\n"
" --foo FOO  ajuda foo"

#: ../../library/argparse.rst:559
msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case ``-"
"h`` and ``--help`` are not valid options.  In this case, the first character "
"in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"A opção de ajuda é tipicamente ``-h/--help``. A exceção a isto é se "
"``prefix_chars=`` for especificado e não incluir ``-``, caso em que ``-h`` e "
"``--help`` não são opções válidas. Neste caso, o primeiro caractere em "
"``prefix_chars`` é usado para prefixar as opções de ajuda::"

#: ../../library/argparse.rst:565
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')\n"
">>> parser.print_help()\n"
"usage: PROG [+h]\n"
"\n"
"options:\n"
"  +h, ++help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:574
msgid "exit_on_error"
msgstr "exit_on_error"

#: ../../library/argparse.rst:576
msgid ""
"Normally, when you pass an invalid argument list to the :meth:"
"`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it will "
"print a *message* to :data:`sys.stderr` and exit with a status code of 2."
msgstr ""
"Normalmente, quando passa uma lista de argumentos inválida para o método :"
"meth:`~ArgumentParser.parse_args` de um :class:`ArgumentParser`, este "
"imprimirá uma *mensagem* para :data:`sys.stderr` e sairá com um código de "
"estado 2."

#: ../../library/argparse.rst:580
msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"Se o utilizador quiser capturar erros manualmente, a funcionalidade pode ser "
"ativada definindo ``exit_on_error`` como ``False``::"

#: ../../library/argparse.rst:583
msgid ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--integers', type=int)\n"
"_StoreAction(option_strings=['--integers'], dest='integers', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--integers a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Catching an argumentError')\n"
"...\n"
"Catching an argumentError"
msgstr ""
">>> parser = argparse.ArgumentParser(exit_on_error=False)\n"
">>> parser.add_argument('--inteiros', type=int)\n"
"_StoreAction(option_strings=['--inteiros'], dest='inteiros', nargs=None, "
"const=None, default=None, type=<class 'int'>, choices=None, help=None, "
"metavar=None)\n"
">>> try:\n"
"...     parser.parse_args('--inteiros a'.split())\n"
"... except argparse.ArgumentError:\n"
"...     print('Apanhar um argumentError')\n"
"...\n"
"Apanhar um argumentError"

#: ../../library/argparse.rst:596
msgid "suggest_on_error"
msgstr "suggest_on_error"

#: ../../library/argparse.rst:598
msgid ""
"By default, when a user passes an invalid argument choice or subparser "
"name, :class:`ArgumentParser` will exit with error info and list the "
"permissible argument choices (if specified) or subparser names as part of "
"the error message."
msgstr ""
"Por predefinição, quando um utilizador passa uma escolha de argumento "
"inválida ou um nome de subanalisador, o :class:`ArgumentParser` sairá com "
"informações de erro e listará as escolhas de argumentos permitidas (se "
"especificadas) ou nomes de subanalisadores como parte da mensagem de erro."

#: ../../library/argparse.rst:602
msgid ""
"If the user would like to enable suggestions for mistyped argument choices "
"and subparser names, the feature can be enabled by setting "
"``suggest_on_error`` to ``True``. Note that this only applies for arguments "
"when the choices specified are strings::"
msgstr ""
"Se o utilizador quiser ativar sugestões para escolhas de argumentos mal "
"escritas e nomes de subanalisadores, a funcionalidade pode ser ativada "
"definindo ``suggest_on_error`` como ``True``. Note que isto aplica-se apenas "
"a argumentos quando as escolhas especificadas são strings::"

#: ../../library/argparse.rst:607
msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.',\n"
"                                     suggest_on_error=True)\n"
">>> parser.add_argument('--action', choices=['sum', 'max'])\n"
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"...                     help='an integer for the accumulator')\n"
">>> parser.parse_args(['--action', 'sumn', 1, 2, 3])\n"
"tester.py: error: argument --action: invalid choice: 'sumn', maybe you meant "
"'sum'? (choose from 'sum', 'max')"
msgstr ""
">>> parser = argparse.ArgumentParser(description='Processar alguns "
"inteiros.',\n"
"                                     suggest_on_error=True)\n"
">>> parser.add_argument('--acao', choices=['soma', 'máx'])\n"
">>> parser.add_argument('inteiros', metavar='N', type=int, nargs='+',\n"
"...                     help='um inteiro para o acumulador')\n"
">>> parser.parse_args(['--acao', 'somn', 1, 2, 3])\n"
"tester.py: erro: argumento --acao: escolha inválida: 'somn', talvez tenha "
"querido dizer 'soma'? (escolha entre 'soma', 'máx')"

#: ../../library/argparse.rst:615
msgid ""
"If you're writing code that needs to be compatible with older Python "
"versions and want to opportunistically use ``suggest_on_error`` when it's "
"available, you can set it as an attribute after initializing the parser "
"instead of using the keyword argument::"
msgstr ""
"Se estiver a escrever código que precisa ser compatível com versões mais "
"antigas do Python e quiser usar ``suggest_on_error`` de forma oportunista "
"quando estiver disponível, pode defini-lo como um atributo após inicializar "
"o analisador em vez de usar o argumento de palavra-chave::"

#: ../../library/argparse.rst:620
msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.')\n"
">>> parser.suggest_on_error = True"
msgstr ""
">>> parser = argparse.ArgumentParser(description='Processar alguns "
"inteiros.')\n"
">>> parser.suggest_on_error = True"

#: ../../library/argparse.rst:627
msgid "color"
msgstr "cor"

#: ../../library/argparse.rst:629
msgid ""
"By default, the help message is printed in color using `ANSI escape "
"sequences <https://en.wikipedia.org/wiki/ANSI_escape_code>`__. If you want "
"plain text help messages, you can disable this :ref:`in your local "
"environment <using-on-controlling-color>`, or in the argument parser itself "
"by setting ``color`` to ``False``::"
msgstr ""
"Por predefinição, a mensagem de ajuda é impressa a cores usando `sequências "
"de escape ANSI <https://en.wikipedia.org/wiki/ANSI_escape_code>`__. Se "
"quiser mensagens de ajuda em texto simples, pode desativar isto :ref:`no seu "
"ambiente local <using-on-controlling-color>`, ou no próprio analisador de "
"argumentos definindo ``color`` como ``False``::"

#: ../../library/argparse.rst:635
msgid ""
">>> parser = argparse.ArgumentParser(description='Process some integers.',\n"
"...                                  color=False)\n"
">>> parser.add_argument('--action', choices=['sum', 'max'])\n"
">>> parser.add_argument('integers', metavar='N', type=int, nargs='+',\n"
"...                     help='an integer for the accumulator')\n"
">>> parser.parse_args(['--help'])"
msgstr ""
">>> parser = argparse.ArgumentParser(description='Processar alguns "
"inteiros.',\n"
"...                                  color=False)\n"
">>> parser.add_argument('--acao', choices=['soma', 'máx'])\n"
">>> parser.add_argument('inteiros', metavar='N', type=int, nargs='+',\n"
"...                     help='um inteiro para o acumulador')\n"
">>> parser.parse_args(['--help'])"

#: ../../library/argparse.rst:642
msgid ""
"Note that when ``color=True``, colored output depends on both environment "
"variables and terminal capabilities.  However, if ``color=False``, colored "
"output is always disabled, even if environment variables like "
"``FORCE_COLOR`` are set."
msgstr ""
"Note que quando ``color=True``, a saída colorida depende tanto de variáveis "
"de ambiente como das capacidades do terminal. No entanto, se "
"``color=False``, a saída colorida está sempre desativada, mesmo que "
"variáveis de ambiente como ``FORCE_COLOR`` estejam definidas."

#: ../../library/argparse.rst:649
msgid ""
"Error messages will include color codes when redirecting stderr to a file. "
"To avoid this, set the |NO_COLOR|_ or :envvar:`PYTHON_COLORS` environment "
"variable (for example, ``NO_COLOR=1 python script.py 2> errors.txt``)."
msgstr ""

#: ../../library/argparse.rst:658
msgid "The add_argument() method"
msgstr "O método add_argument()"

#: ../../library/argparse.rst:664
msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr ""
"Define como um único argumento de linha de comandos deve ser analisado. Cada "
"parâmetro tem a sua própria descrição mais detalhada abaixo, mas em resumo "
"são:"

#: ../../library/argparse.rst:667
msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``'foo'`` "
"or ``'-f', '--foo'``."
msgstr ""
"`nome ou flags`_ — Ou um nome ou uma lista de strings de opção, por exemplo, "
"``'foo'`` ou ``'-f', '--foo'``."

#: ../../library/argparse.rst:670
msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""
"action_ — O tipo básico de ação a ser tomada quando este argumento é "
"encontrado na linha de comandos."

#: ../../library/argparse.rst:673
msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr ""
"nargs_ — O número de argumentos de linha de comandos que devem ser "
"consumidos."

#: ../../library/argparse.rst:675
msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""
"const_ — Um valor constante necessário para algumas seleções de action_ e "
"nargs_."

#: ../../library/argparse.rst:677
msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr ""
"default_ — O valor produzido se o argumento estiver ausente da linha de "
"comandos e se estiver ausente do objeto namespace."

#: ../../library/argparse.rst:680
msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr ""
"type_ — O tipo para o qual o argumento de linha de comandos deve ser "
"convertido."

#: ../../library/argparse.rst:682
msgid "choices_ - A sequence of the allowable values for the argument."
msgstr "choices_ — Uma sequência dos valores permitidos para o argumento."

#: ../../library/argparse.rst:684
msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals "
"only)."
msgstr ""
"required_ — Se a opção de linha de comandos pode ser omitida (apenas "
"opcionais)."

#: ../../library/argparse.rst:687
msgid "help_ - A brief description of what the argument does."
msgstr "help_ — Uma breve descrição do que o argumento faz."

#: ../../library/argparse.rst:689
msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ — Um nome para o argumento em mensagens de uso."

#: ../../library/argparse.rst:691
msgid ""
"dest_ - The name of the attribute to be added to the object returned by :"
"meth:`parse_args`."
msgstr ""
"dest_ — O nome do atributo a ser adicionado ao objeto retornado por :meth:"
"`parse_args`."

#: ../../library/argparse.rst:694
msgid "deprecated_ - Whether or not use of the argument is deprecated."
msgstr "deprecated_ — Se o uso do argumento está obsoleto ou não."

#: ../../library/argparse.rst:702
msgid "name or flags"
msgstr "nome ou flags"

#: ../../library/argparse.rst:704
msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to :meth:"
"`~ArgumentParser.add_argument` must therefore be either a series of flags, "
"or a simple argument name."
msgstr ""
"O método :meth:`~ArgumentParser.add_argument` deve saber se é esperado um "
"argumento opcional, como ``-f`` ou ``--foo``, ou um argumento posicional, "
"como uma lista de nomes de ficheiros. Os primeiros argumentos passados para :"
"meth:`~ArgumentParser.add_argument` devem, portanto, ser uma série de flags "
"ou um nome de argumento simples."

#: ../../library/argparse.rst:710
msgid "For example, an optional argument could be created like::"
msgstr "Por exemplo, um argumento opcional pode ser criado assim::"

#: ../../library/argparse.rst:712
msgid ">>> parser.add_argument('-f', '--foo')"
msgstr ">>> parser.add_argument('-f', '--foo')"

#: ../../library/argparse.rst:714
msgid "while a positional argument could be created like::"
msgstr "enquanto um argumento posicional pode ser criado assim::"

#: ../../library/argparse.rst:716
msgid ">>> parser.add_argument('bar')"
msgstr ">>> parser.add_argument('bar')"

#: ../../library/argparse.rst:718
msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"Quando :meth:`~ArgumentParser.parse_args` é chamado, os argumentos opcionais "
"serão identificados pelo prefixo ``-``, e os argumentos restantes serão "
"assumidos como posicionais::"

#: ../../library/argparse.rst:722
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"usage: PROG [-h] [-f FOO] bar\n"
"PROG: error: the following arguments are required: bar"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-f', '--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['BAR'])\n"
"Namespace(bar='BAR', foo=None)\n"
">>> parser.parse_args(['BAR', '--foo', 'FOO'])\n"
"Namespace(bar='BAR', foo='FOO')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"uso: PROG [-h] [-f FOO] bar\n"
"PROG: erro: os seguintes argumentos são obrigatórios: bar"

#: ../../library/argparse.rst:733
msgid ""
"By default, :mod:`!argparse` automatically handles the internal naming and "
"display names of arguments, simplifying the process without requiring "
"additional configuration. As such, you do not need to specify the dest_ and "
"metavar_ parameters. The dest_ parameter defaults to the argument name with "
"underscores ``_`` replacing hyphens ``-`` . The metavar_ parameter defaults "
"to the upper-cased name. For example::"
msgstr ""
"Por predefinição, :mod:`!argparse` trata automaticamente da nomeação interna "
"e dos nomes de exibição dos argumentos, simplificando o processo sem exigir "
"configuração adicional. Assim, não precisa de especificar os parâmetros "
"dest_ e metavar_. O parâmetro dest_ tem como predefinição o nome do "
"argumento com sublinhados ``_`` a substituir hífenes ``-``. O parâmetro "
"metavar_ tem como predefinição o nome em maiúsculas. Por exemplo::"

#: ../../library/argparse.rst:741
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo-bar')\n"
">>> parser.parse_args(['--foo-bar', 'FOO-BAR']\n"
"Namespace(foo_bar='FOO-BAR')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo-bar FOO-BAR]\n"
"\n"
"optional arguments:\n"
" -h, --help  show this help message and exit\n"
" --foo-bar FOO-BAR"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo-bar')\n"
">>> parser.parse_args(['--foo-bar', 'FOO-BAR'])\n"
"Namespace(foo_bar='FOO-BAR')\n"
">>> parser.print_help()\n"
"uso:  [-h] [--foo-bar FOO-BAR]\n"
"\n"
"argumentos opcionais:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
" --foo-bar FOO-BAR"

#: ../../library/argparse.rst:756
msgid "action"
msgstr "ação"

#: ../../library/argparse.rst:758
msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
"Os objetos :class:`ArgumentParser` associam argumentos de linha de comandos "
"a ações. Estas ações podem fazer praticamente qualquer coisa com os "
"argumentos de linha de comandos associados a elas, embora a maioria das "
"ações simplesmente adicione um atributo ao objeto retornado por :meth:"
"`~ArgumentParser.parse_args`. O argumento de palavra-chave ``action`` "
"especifica como os argumentos de linha de comandos devem ser tratados. As "
"ações fornecidas são:"

#: ../../library/argparse.rst:764
msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action."
msgstr ""
"``'store'`` — Isto simplesmente armazena o valor do argumento. Esta é a ação "
"predefinida."

#: ../../library/argparse.rst:767
msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument; note that the const_ keyword argument defaults to ``None``.  The "
"``'store_const'`` action is most commonly used with optional arguments that "
"specify some sort of flag.  For example::"
msgstr ""
"``'store_const'`` — Isto armazena o valor especificado pelo argumento de "
"palavra-chave const_; note que o argumento de palavra-chave const_ tem como "
"predefinição ``None``. A ação ``'store_const'`` é mais comumente usada com "
"argumentos opcionais que especificam algum tipo de flag. Por exemplo::"

#: ../../library/argparse.rst:772
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_const', const=42)\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:777
msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` that respectively store the values ``True`` and ``False`` "
"with default values of ``False`` and ``True``::"
msgstr ""

#: ../../library/argparse.rst:782
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('--bar', action='store_false')\n"
">>> parser.add_argument('--baz', action='store_false')\n"
">>> parser.parse_args('--foo --bar'.split())\n"
"Namespace(foo=True, bar=False, baz=True)"

#: ../../library/argparse.rst:789
msgid ""
"``'append'`` - This appends each argument value to a list. It is useful for "
"allowing an option to be specified multiple times. If the default value is a "
"non-empty list, the parsed value will start with the default list's elements "
"and any values from the command line will be appended after those default "
"values. Example usage::"
msgstr ""
"``'append'`` — Isto anexa cada valor do argumento a uma lista. É útil para "
"permitir que uma opção seja especificada várias vezes. Se o valor "
"predefinido for uma lista não vazia, o valor analisado começará com os "
"elementos da lista predefinida e quaisquer valores da linha de comandos "
"serão anexados após esses valores predefinidos. Exemplo de uso::"

#: ../../library/argparse.rst:795
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append', default=['0'])\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['0', '1', '2'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='append', default=['0'])\n"
">>> parser.parse_args('--foo 1 --foo 2'.split())\n"
"Namespace(foo=['0', '1', '2'])"

#: ../../library/argparse.rst:800
msgid ""
"``'append_const'`` - This appends the value specified by the const_ keyword "
"argument to a list; note that the const_ keyword argument defaults to "
"``None``. The ``'append_const'`` action is typically useful when multiple "
"arguments need to store constants to the same list. For example::"
msgstr ""

#: ../../library/argparse.rst:806
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--str', dest='types', action='append_const', "
"const=str)\n"
">>> parser.add_argument('--int', dest='types', action='append_const', "
"const=int)\n"
">>> parser.parse_args('--str --int'.split())\n"
"Namespace(types=[<class 'str'>, <class 'int'>])"

#: ../../library/argparse.rst:812
msgid ""
"``'extend'`` - This appends each item from a multi-value argument to a list. "
"The ``'extend'`` action is typically used with the nargs_ keyword argument "
"value ``'+'`` or ``'*'``. Note that when nargs_ is ``None`` (the default) or "
"``'?'``, each character of the argument string will be appended to the list. "
"Example usage::"
msgstr ""

#: ../../library/argparse.rst:820
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\"--foo\", action=\"extend\", nargs=\"+\", "
"type=str)\n"
">>> parser.parse_args([\"--foo\", \"f1\", \"--foo\", \"f2\", \"f3\", "
"\"f4\"])\n"
"Namespace(foo=['f1', 'f2', 'f3', 'f4'])"

#: ../../library/argparse.rst:827
msgid ""
"``'count'`` - This counts the number of times an argument occurs. For "
"example, this is useful for increasing verbosity levels::"
msgstr ""

#: ../../library/argparse.rst:830
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--verbose', '-v', action='count', default=0)\n"
">>> parser.parse_args(['-vvv'])\n"
"Namespace(verbose=3)"

#: ../../library/argparse.rst:835
msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr ""
"Note que o *predefinido* será ``None`` a menos que seja explicitamente "
"definido como *0*."

#: ../../library/argparse.rst:837
msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` — Isto imprime uma mensagem de ajuda completa para todas as "
"opções no analisador atual e depois sai. Por predefinição, uma ação de ajuda "
"é automaticamente adicionada ao analisador. Consulte :class:`ArgumentParser` "
"para detalhes sobre como a saída é criada."

#: ../../library/argparse.rst:842
msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the :meth:"
"`~ArgumentParser.add_argument` call, and prints version information and "
"exits when invoked::"
msgstr ""
"``'version'`` — Isto espera um argumento de palavra-chave ``version=`` na "
"chamada :meth:`~ArgumentParser.add_argument` e imprime informações de versão "
"e sai quando invocado::"

#: ../../library/argparse.rst:846
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--version', action='version', version='%(prog)s "
"2.0')\n"
">>> parser.parse_args(['--version'])\n"
"PROG 2.0"

#: ../../library/argparse.rst:852
msgid ""
"You may also specify an arbitrary action by passing an :class:`Action` "
"subclass (e.g. :class:`BooleanOptionalAction`) or other object that "
"implements the same interface. Only actions that consume command-line "
"arguments (e.g. ``'store'``, ``'append'``, ``'extend'``, or custom actions "
"with non-zero ``nargs``) can be used with positional arguments."
msgstr ""
"Também pode especificar uma ação arbitrária passando uma subclasse :class:"
"`Action` (por exemplo, :class:`BooleanOptionalAction`) ou outro objeto que "
"implemente a mesma interface. Apenas ações que consomem argumentos de linha "
"de comandos (por exemplo, ``'store'``, ``'append'``, ``'extend'``, ou ações "
"personalizadas com ``nargs`` não zero) podem ser usadas com argumentos "
"posicionais."

#: ../../library/argparse.rst:858
msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the :meth:`!__call__` method and optionally the :meth:`!__init__` "
"and :meth:`!format_usage` methods. You can also register custom actions "
"using the :meth:`~ArgumentParser.register` method and reference them by "
"their registered name."
msgstr ""
"A forma recomendada de criar uma ação personalizada é estender :class:"
"`Action`, substituindo o método :meth:`!__call__` e opcionalmente os "
"métodos :meth:`!__init__` e :meth:`!format_usage`. Também pode registar "
"ações personalizadas usando o método :meth:`~ArgumentParser.register` e "
"referenciá-las pelo seu nome registado."

#: ../../library/argparse.rst:863
msgid "An example of a custom action::"
msgstr "Um exemplo de uma ação personalizada::"

#: ../../library/argparse.rst:865
msgid ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs not allowed\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"
msgstr ""
">>> class FooAction(argparse.Action):\n"
"...     def __init__(self, option_strings, dest, nargs=None, **kwargs):\n"
"...         if nargs is not None:\n"
"...             raise ValueError(\"nargs não permitido\")\n"
"...         super().__init__(option_strings, dest, **kwargs)\n"
"...     def __call__(self, parser, namespace, values, option_string=None):\n"
"...         print('%r %r %r' % (namespace, values, option_string))\n"
"...         setattr(namespace, self.dest, values)\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=FooAction)\n"
">>> parser.add_argument('bar', action=FooAction)\n"
">>> args = parser.parse_args('1 --foo 2'.split())\n"
"Namespace(bar=None, foo=None) '1' None\n"
"Namespace(bar='1', foo=None) '2' '--foo'\n"
">>> args\n"
"Namespace(bar='1', foo='2')"

#: ../../library/argparse.rst:883
msgid "For more details, see :class:`Action`."
msgstr "Para mais detalhes, consulte :class:`Action`."

#: ../../library/argparse.rst:889
msgid "nargs"
msgstr "nargs"

#: ../../library/argparse.rst:891
msgid ""
":class:`ArgumentParser` objects usually associate a single command-line "
"argument with a single action to be taken.  The ``nargs`` keyword argument "
"associates a different number of command-line arguments with a single "
"action. See also :ref:`specifying-ambiguous-arguments`. The supported values "
"are:"
msgstr ""
"Os objetos :class:`ArgumentParser` geralmente associam um único argumento de "
"linha de comandos a uma única ação a ser tomada. O argumento nomeado "
"``nargs`` associa um número diferente de argumentos de linha de comandos a "
"uma única ação. Veja também :ref:`specifying-ambiguous-arguments`. Os "
"valores suportados são:"

#: ../../library/argparse.rst:896
msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr ""
"``N`` (um inteiro). ``N`` argumentos da linha de comandos serão reunidos "
"numa lista. Por exemplo::"

#: ../../library/argparse.rst:899
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs=2)\n"
">>> parser.add_argument('bar', nargs=1)\n"
">>> parser.parse_args('c --foo a b'.split())\n"
"Namespace(bar=['c'], foo=['a', 'b'])"

#: ../../library/argparse.rst:905
msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr ""
"Note que ``nargs=1`` produz uma lista com um item. Isto é diferente da "
"predefinição, em que o item é produzido por si só."

#: ../../library/argparse.rst:910
msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. Um argumento será consumido da linha de comandos, se possível, e "
"produzido como um único item. Se nenhum argumento de linha de comandos "
"estiver presente, o valor de default_ será produzido. Note que para "
"argumentos opcionais, existe um caso adicional — a string de opção está "
"presente mas não é seguida por um argumento de linha de comandos. Neste "
"caso, o valor de const_ será produzido. Alguns exemplos para ilustrar isto::"

#: ../../library/argparse.rst:917
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='?', const='c', default='d')\n"
">>> parser.add_argument('bar', nargs='?', default='d')\n"
">>> parser.parse_args(['XX', '--foo', 'YY'])\n"
"Namespace(bar='XX', foo='YY')\n"
">>> parser.parse_args(['XX', '--foo'])\n"
"Namespace(bar='XX', foo='c')\n"
">>> parser.parse_args([])\n"
"Namespace(bar='d', foo='d')"

#: ../../library/argparse.rst:927
msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr ""
"Um dos usos mais comuns de ``nargs='?'`` é permitir ficheiros de entrada e "
"saída opcionais::"

#: ../../library/argparse.rst:930
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', nargs='?')\n"
">>> parser.add_argument('outfile', nargs='?')\n"
">>> parser.parse_args(['input.txt', 'output.txt'])\n"
"Namespace(infile='input.txt', outfile='output.txt')\n"
">>> parser.parse_args(['input.txt'])\n"
"Namespace(infile='input.txt', outfile=None)\n"
">>> parser.parse_args([])\n"
"Namespace(infile=None, outfile=None)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('ficheiro_entrada', nargs='?')\n"
">>> parser.add_argument('ficheiro_saida', nargs='?')\n"
">>> parser.parse_args(['entrada.txt', 'saida.txt'])\n"
"Namespace(ficheiro_entrada='entrada.txt', ficheiro_saida='saida.txt')\n"
">>> parser.parse_args(['entrada.txt'])\n"
"Namespace(ficheiro_entrada='entrada.txt', ficheiro_saida=None)\n"
">>> parser.parse_args([])\n"
"Namespace(ficheiro_entrada=None, ficheiro_saida=None)"

#: ../../library/argparse.rst:942
msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note "
"that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``. Todos os argumentos de linha de comandos presentes são reunidos "
"numa lista. Note que geralmente não faz muito sentido ter mais do que um "
"argumento posicional com ``nargs='*'``, mas vários argumentos opcionais com "
"``nargs='*'`` é possível. Por exemplo::"

#: ../../library/argparse.rst:947
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', nargs='*')\n"
">>> parser.add_argument('--bar', nargs='*')\n"
">>> parser.add_argument('baz', nargs='*')\n"
">>> parser.parse_args('a b --foo x y --bar 1 2'.split())\n"
"Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])"

#: ../../library/argparse.rst:956
msgid ""
"``'+'``. Just like ``'*'``, all command-line arguments present are gathered "
"into a list.  Additionally, an error message will be generated if there "
"wasn't at least one command-line argument present.  For example::"
msgstr ""
"``'+'``. Tal como ``'*'``, todos os argumentos de linha de comandos "
"presentes são reunidos numa lista. Além disso, uma mensagem de erro será "
"gerada se não houver pelo menos um argumento de linha de comandos presente. "
"Por exemplo::"

#: ../../library/argparse.rst:960
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] foo [foo ...]\n"
"PROG: error: the following arguments are required: foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('foo', nargs='+')\n"
">>> parser.parse_args(['a', 'b'])\n"
"Namespace(foo=['a', 'b'])\n"
">>> parser.parse_args([])\n"
"uso: PROG [-h] foo [foo ...]\n"
"PROG: erro: os seguintes argumentos são obrigatórios: foo"

#: ../../library/argparse.rst:968
msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced. Actions that do not consume command-line arguments (e.g. "
"``'store_const'``) set ``nargs=0``."
msgstr ""
"Se o argumento de palavra-chave ``nargs`` não for fornecido, o número de "
"argumentos consumidos é determinado pela action_. Geralmente, isto significa "
"que um único argumento de linha de comandos será consumido e um único item "
"(não uma lista) será produzido. Ações que não consomem argumentos de linha "
"de comandos (por exemplo, ``'store_const'``) definem ``nargs=0``."

#: ../../library/argparse.rst:978
msgid "const"
msgstr "const"

#: ../../library/argparse.rst:980
msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
"O argumento ``const`` de :meth:`~ArgumentParser.add_argument` é usado para "
"armazenar valores constantes que não são lidos da linha de comandos, mas são "
"necessários para as várias ações :class:`ArgumentParser`. Os dois usos mais "
"comuns são:"

#: ../../library/argparse.rst:984
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by :meth:"
"`~ArgumentParser.parse_args`. See the action_ description for examples. If "
"``const`` is not provided to :meth:`~ArgumentParser.add_argument`, it will "
"receive a default value of ``None``."
msgstr ""
"Quando :meth:`~ArgumentParser.add_argument` é chamado com "
"``action='store_const'`` ou ``action='append_const'``. Estas ações adicionam "
"o valor ``const`` a um dos atributos do objeto retornado por :meth:"
"`~ArgumentParser.parse_args`. Consulte a descrição de action_ para exemplos. "
"Se ``const`` não for fornecido a :meth:`~ArgumentParser.add_argument`, "
"receberá um valor predefinido de ``None``."

#: ../../library/argparse.rst:992
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value from ``const`` will be used. "
"See the nargs_ description for examples."
msgstr ""
"Quando :meth:`~ArgumentParser.add_argument` é chamado com strings de opção "
"(como ``-f`` ou ``--foo``) e ``nargs='?'``. Isto cria um argumento opcional "
"que pode ser seguido por zero ou um argumento de linha de comandos. Ao "
"analisar a linha de comandos, se a string de opção for encontrada sem um "
"argumento de linha de comandos a segui-la, o valor de ``const`` será usado. "
"Consulte a descrição de nargs_ para exemplos."

#: ../../library/argparse.rst:999
msgid ""
"``const=None`` by default, including when ``action='append_const'`` or "
"``action='store_const'``."
msgstr ""
"``const=None`` por predefinição, incluindo quando ``action='append_const'`` "
"ou ``action='store_const'``."

#: ../../library/argparse.rst:1006
msgid "default"
msgstr "predefinição"

#: ../../library/argparse.rst:1008
msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of :meth:`~ArgumentParser."
"add_argument`, whose value defaults to ``None``, specifies what value should "
"be used if the command-line argument is not present. For optional arguments, "
"the ``default`` value is used when the option string was not present at the "
"command line::"
msgstr ""
"Todos os argumentos opcionais e alguns argumentos posicionais podem ser "
"omitidos na linha de comandos. O argumento de palavra-chave ``default`` de :"
"meth:`~ArgumentParser.add_argument`, cujo valor tem como predefinição "
"``None``, especifica qual o valor que deve ser usado se o argumento de linha "
"de comandos não estiver presente. Para argumentos opcionais, o valor "
"``default`` é usado quando a string de opção não estava presente na linha de "
"comandos::"

#: ../../library/argparse.rst:1015
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args(['--foo', '2'])\n"
"Namespace(foo='2')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:1022
msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not overwrite it::"
msgstr ""
"Se o namespace alvo já tiver um atributo definido, a ação *predefinição* não "
"o substituirá::"

#: ../../library/argparse.rst:1025
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=42)\n"
">>> parser.parse_args([], namespace=argparse.Namespace(foo=101))\n"
"Namespace(foo=101)"

#: ../../library/argparse.rst:1030
msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the :class:"
"`Namespace` return value.  Otherwise, the parser uses the value as is::"
msgstr ""
"Se o valor ``default`` for uma string, o analisador analisa o valor como se "
"fosse um argumento de linha de comandos. Em particular, o analisador aplica "
"qualquer argumento de conversão de tipo_, se fornecido, antes de definir o "
"atributo no valor de retorno :class:`Namespace`. Caso contrário, o "
"analisador usa o valor como está::"

#: ../../library/argparse.rst:1035
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--length', default='10', type=int)\n"
">>> parser.add_argument('--width', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(length=10, width=10.5)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--comprimento', default='10', type=int)\n"
">>> parser.add_argument('--largura', default=10.5, type=int)\n"
">>> parser.parse_args()\n"
"Namespace(comprimento=10, largura=10.5)"

#: ../../library/argparse.rst:1041
msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""
"Para argumentos posicionais com nargs_ igual a ``?`` ou ``*``, o valor "
"``default`` é usado quando nenhum argumento de linha de comandos estiver "
"presente::"

#: ../../library/argparse.rst:1044
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', nargs='?', default=42)\n"
">>> parser.parse_args(['a'])\n"
"Namespace(foo='a')\n"
">>> parser.parse_args([])\n"
"Namespace(foo=42)"

#: ../../library/argparse.rst:1051
msgid ""
"For required_ arguments, the ``default`` value is ignored. For example, this "
"applies to positional arguments with nargs_ values other than ``?`` or "
"``*``, or optional arguments marked as ``required=True``."
msgstr ""
"Para argumentos required_, o valor ``default`` é ignorado. Por exemplo, isto "
"aplica-se a argumentos posicionais com valores nargs_ diferentes de ``?`` ou "
"``*``, ou argumentos opcionais marcados como ``required=True``."

#: ../../library/argparse.rst:1055
msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr ""
"Fornecer ``default=argparse.SUPPRESS`` faz com que nenhum atributo seja "
"adicionado se o argumento de linha de comandos não estiver presente::"

#: ../../library/argparse.rst:1058
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default=argparse.SUPPRESS)\n"
">>> parser.parse_args([])\n"
"Namespace()\n"
">>> parser.parse_args(['--foo', '1'])\n"
"Namespace(foo='1')"

#: ../../library/argparse.rst:1069
msgid "type"
msgstr "tipo"

#: ../../library/argparse.rst:1071
msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"Por predefinição, o analisador lê os argumentos de linha de comandos como "
"strings simples. No entanto, muitas vezes a string da linha de comandos deve "
"ser interpretada como outro tipo, como um :class:`float` ou :class:`int`. A "
"palavra-chave ``type`` para :meth:`~ArgumentParser.add_argument` permite que "
"sejam realizadas quaisquer verificações de tipo e conversões de tipo "
"necessárias."

#: ../../library/argparse.rst:1077
msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr ""
"Se a palavra-chave type_ for usada com a palavra-chave default_, o conversor "
"de tipo é aplicado apenas se a predefinição for uma string."

#: ../../library/argparse.rst:1080
msgid ""
"The argument to ``type`` can be a callable that accepts a single string or "
"the name of a registered type (see :meth:`~ArgumentParser.register`) If the "
"function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or :exc:"
"`ValueError`, the exception is caught and a nicely formatted error message "
"is displayed. Other exception types are not handled."
msgstr ""
"O argumento para ``type`` pode ser um objeto chamável que aceite uma única "
"string ou o nome de um tipo registado (consulte :meth:`~ArgumentParser."
"register`). Se a função levantar :exc:`ArgumentTypeError`, :exc:`TypeError`, "
"ou :exc:`ValueError`, a exceção é capturada e uma mensagem de erro bem "
"formatada é exibida. Outros tipos de exceção não são tratados."

#: ../../library/argparse.rst:1086
msgid "Common built-in types and functions can be used as type converters:"
msgstr ""
"Tipos e funções integradas comuns podem ser usados como conversores de tipo:"

#: ../../library/argparse.rst:1088
msgid ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('count', type=int)\n"
"parser.add_argument('distance', type=float)\n"
"parser.add_argument('street', type=ascii)\n"
"parser.add_argument('code_point', type=ord)\n"
"parser.add_argument('datapath', type=pathlib.Path)"
msgstr ""
"import argparse\n"
"import pathlib\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('contagem', type=int)\n"
"parser.add_argument('distância', type=float)\n"
"parser.add_argument('rua', type=ascii)\n"
"parser.add_argument('ponto_código', type=ord)\n"
"parser.add_argument('caminho_dados', type=pathlib.Path)"

#: ../../library/argparse.rst:1100
msgid "User defined functions can be used as well:"
msgstr "Funções definidas pelo utilizador também podem ser usadas:"

#: ../../library/argparse.rst:1102
msgid ""
">>> def hyphenated(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('short_title', type=hyphenated)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(short_title='\"the-tale-of-two-citi')"
msgstr ""
">>> def com_hífens(string):\n"
"...     return '-'.join([word[:4] for word in string.casefold().split()])\n"
"...\n"
">>> parser = argparse.ArgumentParser()\n"
">>> _ = parser.add_argument('título_curto', type=com_hífens)\n"
">>> parser.parse_args(['\"The Tale of Two Cities\"'])\n"
"Namespace(título_curto='\"the-tale-of-two-citi')"

#: ../../library/argparse.rst:1112
msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"A função :func:`bool` não é recomendada como conversor de tipo. Tudo o que "
"faz é converter strings vazias para ``False`` e strings não vazias para "
"``True``. Isto geralmente não é o que é desejado."

#: ../../library/argparse.rst:1116
msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"Em geral, a palavra-chave ``type`` é uma conveniência que deve ser usada "
"apenas para conversões simples que só podem levantar uma das três exceções "
"suportadas. Qualquer coisa com tratamento de erros ou gestão de recursos "
"mais interessante deve ser feita a jusante após os argumentos serem "
"analisados."

#: ../../library/argparse.rst:1121
msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A :exc:`~json."
"JSONDecodeError` would not be well formatted and a :exc:`FileNotFoundError` "
"exception would not be handled at all."
msgstr ""
"Por exemplo, conversões JSON ou YAML têm casos de erro complexos que "
"requerem relatórios melhores do que os que podem ser fornecidos pela palavra-"
"chave ``type``. Um :exc:`~json.JSONDecodeError` não seria bem formatado e "
"uma exceção :exc:`FileNotFoundError` não seria tratada de todo."

#: ../../library/argparse.rst:1126
msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses :class:`~argparse.FileType` and then "
"a subsequent argument fails, an error is reported but the file is not "
"automatically closed.  In this case, it would be better to wait until after "
"the parser has run and then use the :keyword:`with`-statement to manage the "
"files."
msgstr ""
"Até :class:`~argparse.FileType` tem as suas limitações para uso com a "
"palavra-chave ``type``. Se um argumento usar :class:`~argparse.FileType` e "
"depois um argumento subsequente falhar, um erro é reportado, mas o ficheiro "
"não é fechado automaticamente. Neste caso, seria melhor esperar até que o "
"analisador tenha terminado e depois usar a instrução :keyword:`with` para "
"gerir os ficheiros."

#: ../../library/argparse.rst:1133
msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr ""
"Para verificadores de tipo que simplesmente verificam contra um conjunto "
"fixo de valores, considere usar a palavra-chave choices_ em vez disso."

#: ../../library/argparse.rst:1140
msgid "choices"
msgstr "escolhas"

#: ../../library/argparse.rst:1142
msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a sequence object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"Alguns argumentos de linha de comandos devem ser selecionados de um conjunto "
"restrito de valores. Estes podem ser tratados passando um objeto de "
"sequência como argumento de palavra-chave *choices* para :meth:"
"`~ArgumentParser.add_argument`. Quando a linha de comandos é analisada, os "
"valores dos argumentos serão verificados e uma mensagem de erro será exibida "
"se o argumento não for um dos valores aceitáveis::"

#: ../../library/argparse.rst:1148
msgid ""
">>> parser = argparse.ArgumentParser(prog='game.py')\n"
">>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])\n"
">>> parser.parse_args(['rock'])\n"
"Namespace(move='rock')\n"
">>> parser.parse_args(['fire'])\n"
"usage: game.py [-h] {rock,paper,scissors}\n"
"game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',\n"
"'paper', 'scissors')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='jogo.py')\n"
">>> parser.add_argument('movimento', choices=['pedra', 'papel', 'tesoura'])\n"
">>> parser.parse_args(['pedra'])\n"
"Namespace(movimento='pedra')\n"
">>> parser.parse_args(['fogo'])\n"
"uso: jogo.py [-h] {pedra,papel,tesoura}\n"
"jogo.py: erro: argumento movimento: escolha inválida: 'fogo' (escolha entre "
"'pedra',\n"
"'papel', 'tesoura')"

#: ../../library/argparse.rst:1157
msgid ""
"Any sequence can be passed as the *choices* value, so :class:`list` "
"objects, :class:`tuple` objects, and custom sequences are all supported."
msgstr ""
"Qualquer sequência pode ser passada como valor *choices*, então objetos :"
"class:`list`, objetos :class:`tuple` e sequências personalizadas são todos "
"suportados."

#: ../../library/argparse.rst:1160
msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""
"O uso de :class:`enum.Enum` não é recomendado porque é difícil controlar a "
"sua aparência em mensagens de uso, ajuda e erro."

#: ../../library/argparse.rst:1163
msgid ""
"Note that *choices* are checked after any type_ conversions have been "
"performed, so objects in *choices* should match the type_ specified. This "
"can make *choices* appear unfamiliar in usage, help, or error messages."
msgstr ""
"Note que *choices* são verificadas após quaisquer conversões de tipo_ terem "
"sido realizadas, por isso os objetos em *choices* devem corresponder ao "
"tipo_ especificado. Isto pode fazer com que *choices* pareçam desconhecidas "
"em mensagens de uso, ajuda ou erro."

#: ../../library/argparse.rst:1168
msgid ""
"To keep *choices* user-friendly, consider a custom type wrapper that "
"converts and formats values, or omit type_ and handle conversion in your "
"application code."
msgstr ""
"Para manter *choices* amigáveis ao utilizador, considere um wrapper de tipo "
"personalizado que converta e formate valores, ou omita type_ e trate a "
"conversão no código da sua aplicação."

#: ../../library/argparse.rst:1172
msgid ""
"Formatted choices override the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""
"Escolhas formatadas substituem o *metavar* predefinido, que é normalmente "
"derivado de *dest*. Isto é geralmente o que deseja, porque o utilizador "
"nunca vê o parâmetro *dest*. Se esta exibição não for desejável (talvez "
"porque há muitas escolhas), basta especificar um metavar_ explícito."

#: ../../library/argparse.rst:1181
msgid "required"
msgstr "obrigatório"

#: ../../library/argparse.rst:1183
msgid ""
"In general, the :mod:`!argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"Em geral, o módulo :mod:`!argparse` assume que flags como ``-f`` e ``--bar`` "
"indicam argumentos *opcionais*, que podem sempre ser omitidos na linha de "
"comandos. Para tornar uma opção *obrigatória*, ``True`` pode ser "
"especificado para o argumento de palavra-chave ``required=`` em :meth:"
"`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1188
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"usage: [-h] --foo FOO\n"
": error: the following arguments are required: --foo"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', required=True)\n"
">>> parser.parse_args(['--foo', 'BAR'])\n"
"Namespace(foo='BAR')\n"
">>> parser.parse_args([])\n"
"uso: [-h] --foo FOO\n"
": erro: os seguintes argumentos são obrigatórios: --foo"

#: ../../library/argparse.rst:1196
msgid ""
"As the example shows, if an option is marked as ``required``, :meth:"
"`~ArgumentParser.parse_args` will report an error if that option is not "
"present at the command line."
msgstr ""
"Como o exemplo mostra, se uma opção for marcada como ``required``, :meth:"
"`~ArgumentParser.parse_args` reportará um erro se essa opção não estiver "
"presente na linha de comandos."

#: ../../library/argparse.rst:1202
msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr ""
"Opções obrigatórias são geralmente consideradas má prática porque os "
"utilizadores esperam que as *opções* sejam *opcionais*, e, portanto, devem "
"ser evitadas sempre que possível."

#: ../../library/argparse.rst:1209
msgid "help"
msgstr "ajuda"

#: ../../library/argparse.rst:1211
msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument."
msgstr ""
"O valor ``help`` é uma string que contém uma breve descrição do argumento. "
"Quando um utilizador solicita ajuda (geralmente usando ``-h`` ou ``--help`` "
"na linha de comandos), estas descrições ``help`` serão exibidas com cada "
"argumento."

#: ../../library/argparse.rst:1216
msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword "
"arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"As strings ``help`` podem incluir vários especificadores de formato para "
"evitar a repetição de coisas como o nome do programa ou o valor predefinido "
"do argumento. Os especificadores disponíveis incluem o nome do programa, "
"``%(prog)s`` e a maioria dos argumentos de palavra-chave para :meth:"
"`~ArgumentParser.add_argument`, por exemplo, ``%(default)s``, ``%(type)s``, "
"etc.::"

#: ../../library/argparse.rst:1221
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='the bar to %(prog)s (default: %(default)s)')\n"
">>> parser.print_help()\n"
"usage: frobble [-h] [bar]\n"
"\n"
"positional arguments:\n"
" bar     the bar to frobble (default: 42)\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('bar', nargs='?', type=int, default=42,\n"
"...                     help='a barra para %(prog)s (predefinição: "
"%(default)s)')\n"
">>> parser.print_help()\n"
"uso: frobble [-h] [bar]\n"
"\n"
"argumentos posicionais:\n"
" bar     a barra para frobble (predefinição: 42)\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair"

#: ../../library/argparse.rst:1233
msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"Como a string de ajuda suporta formatação %-formatting, se quiser que um "
"``%`` literal apareça na string de ajuda, deve escapá-lo como ``%%``."

#: ../../library/argparse.rst:1236
msgid ""
":mod:`!argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`!argparse` suporta silenciar a entrada de ajuda para certas opções, "
"definindo o valor ``help`` para ``argparse.SUPPRESS``::"

#: ../../library/argparse.rst:1239
msgid ""
">>> parser = argparse.ArgumentParser(prog='frobble')\n"
">>> parser.add_argument('--foo', help=argparse.SUPPRESS)\n"
">>> parser.print_help()\n"
"usage: frobble [-h]\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit"
msgstr ""

#: ../../library/argparse.rst:1251
msgid "metavar"
msgstr "metavar"

#: ../../library/argparse.rst:1253
msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, :class:`!ArgumentParser` "
"objects use the dest_ value as the \"name\" of each object.  By default, for "
"positional argument actions, the dest_ value is used directly, and for "
"optional argument actions, the dest_ value is uppercased.  So, a single "
"positional argument with ``dest='bar'`` will be referred to as ``bar``. A "
"single optional argument ``--foo`` that should be followed by a single "
"command-line argument will be referred to as ``FOO``.  An example::"
msgstr ""
"Quando :class:`ArgumentParser` gera mensagens de ajuda, precisa de alguma "
"forma de se referir a cada argumento esperado. Por predefinição, os objetos :"
"class:`!ArgumentParser` usam o valor dest_ como o \"nome\" de cada objeto. "
"Por predefinição, para ações de argumentos posicionais, o valor dest_ é "
"usado diretamente, e para ações de argumentos opcionais, o valor dest_ é "
"convertido para maiúsculas. Assim, um único argumento posicional com "
"``dest='bar'`` será referido como ``bar``. Um único argumento opcional ``--"
"foo`` que deve ser seguido por um único argumento de linha de comandos será "
"referido como ``FOO``. Um exemplo::"

#: ../../library/argparse.rst:1262
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo FOO] bar\n"
"\n"
"positional arguments:\n"
" bar\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo FOO"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"uso:  [-h] [--foo FOO] bar\n"
"\n"
"argumentos posicionais:\n"
" bar\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
" --foo FOO"

#: ../../library/argparse.rst:1277
msgid "An alternative name can be specified with ``metavar``::"
msgstr "Um nome alternativo pode ser especificado com ``metavar``::"

#: ../../library/argparse.rst:1279
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"usage:  [-h] [--foo YYY] XXX\n"
"\n"
"positional arguments:\n"
" XXX\n"
"\n"
"options:\n"
" -h, --help  show this help message and exit\n"
" --foo YYY"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', metavar='YYY')\n"
">>> parser.add_argument('bar', metavar='XXX')\n"
">>> parser.parse_args('X --foo Y'.split())\n"
"Namespace(bar='X', foo='Y')\n"
">>> parser.print_help()\n"
"uso:  [-h] [--foo YYY] XXX\n"
"\n"
"argumentos posicionais:\n"
" XXX\n"
"\n"
"opções:\n"
" -h, --help  mostrar esta mensagem de ajuda e sair\n"
" --foo YYY"

#: ../../library/argparse.rst:1294
msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"Note que ``metavar`` apenas altera o nome *exibido* — o nome do atributo no "
"objeto :meth:`~ArgumentParser.parse_args` ainda é determinado pelo valor "
"dest_."

#: ../../library/argparse.rst:1298
msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"Diferentes valores de ``nargs`` podem fazer com que o metavar seja usado "
"várias vezes. Fornecer um tuplo para ``metavar`` especifica uma exibição "
"diferente para cada um dos argumentos::"

#: ../../library/argparse.rst:1302
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"usage: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"options:\n"
" -h, --help     show this help message and exit\n"
" -x X X\n"
" --foo bar baz"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', nargs=2)\n"
">>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))\n"
">>> parser.print_help()\n"
"uso: PROG [-h] [-x X X] [--foo bar baz]\n"
"\n"
"opções:\n"
" -h, --help     mostrar esta mensagem de ajuda e sair\n"
" -x X X\n"
" --foo bar baz"

#: ../../library/argparse.rst:1317
msgid "dest"
msgstr "dest"

#: ../../library/argparse.rst:1319
msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of :meth:"
"`~ArgumentParser.add_argument`.  For positional argument actions, ``dest`` "
"is normally supplied as the first argument to :meth:`~ArgumentParser."
"add_argument`::"
msgstr ""
"A maioria das ações :class:`ArgumentParser` adiciona algum valor como "
"atributo do objeto retornado por :meth:`~ArgumentParser.parse_args`. O nome "
"deste atributo é determinado pelo argumento de palavra-chave ``dest`` de :"
"meth:`~ArgumentParser.add_argument`. Para ações de argumentos posicionais, "
"``dest`` é normalmente fornecido como o primeiro argumento para :meth:"
"`~ArgumentParser.add_argument`::"

#: ../../library/argparse.rst:1326
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_args(['XXX'])\n"
"Namespace(bar='XXX')"

#: ../../library/argparse.rst:1331
msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"Para ações de argumentos opcionais, o valor de ``dest`` é normalmente "
"inferido das strings de opção. :class:`ArgumentParser` gera o valor de "
"``dest`` tomando a primeira string de opção longa e removendo a string "
"inicial ``--``. Se nenhuma string de opção longa for fornecida, ``dest`` "
"será derivado da primeira string de opção curta removendo o caractere "
"inicial ``-``. Quaisquer caracteres ``-`` internos serão convertidos em "
"caracteres ``_`` para garantir que a string seja um nome de atributo válido. "
"Os exemplos abaixo ilustram este comportamento::"

#: ../../library/argparse.rst:1340
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('-f', '--foo-bar', '--foo')\n"
">>> parser.add_argument('-x', '-y')\n"
">>> parser.parse_args('-f 1 -x 2'.split())\n"
"Namespace(foo_bar='1', x='2')\n"
">>> parser.parse_args('--foo 1 -y 2'.split())\n"
"Namespace(foo_bar='1', x='2')"

#: ../../library/argparse.rst:1348
msgid "``dest`` allows a custom attribute name to be provided::"
msgstr ""
"``dest`` permite que um nome de atributo personalizado seja fornecido::"

#: ../../library/argparse.rst:1350
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', dest='bar')\n"
">>> parser.parse_args('--foo XXX'.split())\n"
"Namespace(bar='XXX')"

#: ../../library/argparse.rst:1359
msgid "deprecated"
msgstr "obsoleto"

#: ../../library/argparse.rst:1361
msgid ""
"During a project's lifetime, some arguments may need to be removed from the "
"command line. Before removing them, you should inform your users that the "
"arguments are deprecated and will be removed. The ``deprecated`` keyword "
"argument of :meth:`~ArgumentParser.add_argument`, which defaults to "
"``False``, specifies if the argument is deprecated and will be removed in "
"the future. For arguments, if ``deprecated`` is ``True``, then a warning "
"will be printed to :data:`sys.stderr` when the argument is used::"
msgstr ""
"Durante o ciclo de vida de um projeto, alguns argumentos podem precisar de "
"ser removidos da linha de comandos. Antes de os remover, deve informar os "
"seus utilizadores de que os argumentos estão obsoletos e serão removidos. O "
"argumento de palavra-chave ``deprecated`` de :meth:`~ArgumentParser."
"add_argument`, que tem como predefinição ``False``, especifica se o "
"argumento está obsoleto e será removido no futuro. Para argumentos, se "
"``deprecated`` for ``True``, então um aviso será impresso em :data:`sys."
"stderr` quando o argumento for usado::"

#: ../../library/argparse.rst:1371
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser(prog='snake.py')\n"
">>> parser.add_argument('--legs', default=0, type=int, deprecated=True)\n"
">>> parser.parse_args([])\n"
"Namespace(legs=0)\n"
">>> parser.parse_args(['--legs', '4'])\n"
"snake.py: warning: option '--legs' is deprecated\n"
"Namespace(legs=4)"
msgstr ""

#: ../../library/argparse.rst:1384
msgid "Action classes"
msgstr "Classes de ação"

#: ../../library/argparse.rst:1386
msgid ""
":class:`!Action` classes implement the Action API, a callable which returns "
"a callable which processes arguments from the command-line. Any object which "
"follows this API may be passed as the ``action`` parameter to :meth:"
"`~ArgumentParser.add_argument`."
msgstr ""
"As classes :class:`!Action` implementam a API de Ação, um objeto chamável "
"que retorna um objeto chamável que processa argumentos da linha de comandos. "
"Qualquer objeto que siga esta API pode ser passado como o parâmetro "
"``action`` para :meth:`~ArgumentParser.add_argument`."

#: ../../library/argparse.rst:1395
msgid ""
":class:`!Action` objects are used by an :class:`ArgumentParser` to represent "
"the information needed to parse a single argument from one or more strings "
"from the command line. The :class:`!Action` class must accept the two "
"positional arguments plus any keyword arguments passed to :meth:"
"`ArgumentParser.add_argument` except for the ``action`` itself."
msgstr ""
"Os objetos :class:`!Action` são usados por um :class:`ArgumentParser` para "
"representar a informação necessária para analisar um único argumento a "
"partir de uma ou mais strings da linha de comandos. A classe :class:`!"
"Action` deve aceitar os dois argumentos posicionais mais quaisquer "
"argumentos de palavra-chave passados para :meth:`ArgumentParser."
"add_argument`, exceto o próprio ``action``."

#: ../../library/argparse.rst:1401
msgid ""
"Instances of :class:`!Action` (or return value of any callable to the "
"``action`` parameter) should have attributes :attr:`!dest`, :attr:`!"
"option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`, :attr:`!"
"help`, etc. defined. The easiest way to ensure these attributes are defined "
"is to call :meth:`!Action.__init__`."
msgstr ""
"As instâncias de :class:`!Action` (ou o valor de retorno de qualquer objeto "
"chamável para o parâmetro ``action``) devem ter os atributos :attr:`!dest`, :"
"attr:`!option_strings`, :attr:`!default`, :attr:`!type`, :attr:`!required`, :"
"attr:`!help`, etc. definidos. A forma mais fácil de garantir que estes "
"atributos estão definidos é chamar :meth:`!Action.__init__`."

#: ../../library/argparse.rst:1409
msgid ""
":class:`!Action` instances should be callable, so subclasses must override "
"the :meth:`!__call__` method, which should accept four parameters:"
msgstr ""
"As instâncias de :class:`!Action` devem ser chamáveis, por isso as "
"subclasses devem substituir o método :meth:`!__call__`, que deve aceitar "
"quatro parâmetros:"

#: ../../library/argparse.rst:1412
msgid ""
"*parser* - The :class:`ArgumentParser` object which contains this action."
msgstr "*parser* — O objeto :class:`ArgumentParser` que contém esta ação."

#: ../../library/argparse.rst:1414
msgid ""
"*namespace* - The :class:`Namespace` object that will be returned by :meth:"
"`~ArgumentParser.parse_args`.  Most actions add an attribute to this object "
"using :func:`setattr`."
msgstr ""
"*namespace* — O objeto :class:`Namespace` que será retornado por :meth:"
"`~ArgumentParser.parse_args`. A maioria das ações adiciona um atributo a "
"este objeto usando :func:`setattr`."

#: ../../library/argparse.rst:1418
msgid ""
"*values* - The associated command-line arguments, with any type conversions "
"applied.  Type conversions are specified with the type_ keyword argument to :"
"meth:`~ArgumentParser.add_argument`."
msgstr ""
"*values* — Os argumentos de linha de comandos associados, com quaisquer "
"conversões de tipo aplicadas. As conversões de tipo são especificadas com o "
"argumento de palavra-chave type_ para :meth:`~ArgumentParser.add_argument`."

#: ../../library/argparse.rst:1422
msgid ""
"*option_string* - The option string that was used to invoke this action. The "
"``option_string`` argument is optional, and will be absent if the action is "
"associated with a positional argument."
msgstr ""
"*option_string* — A string de opção que foi usada para invocar esta ação. O "
"argumento ``option_string`` é opcional e estará ausente se a ação estiver "
"associada a um argumento posicional."

#: ../../library/argparse.rst:1426
msgid ""
"The :meth:`!__call__` method may perform arbitrary actions, but will "
"typically set attributes on the ``namespace`` based on ``dest`` and "
"``values``."
msgstr ""
"O método :meth:`!__call__` pode realizar ações arbitrárias, mas normalmente "
"definirá atributos no ``namespace`` com base em ``dest`` e ``values``."

#: ../../library/argparse.rst:1431
msgid ""
":class:`!Action` subclasses can define a :meth:`!format_usage` method that "
"takes no argument and return a string which will be used when printing the "
"usage of the program. If such method is not provided, a sensible default "
"will be used."
msgstr ""
"As subclasses de :class:`!Action` podem definir um método :meth:`!"
"format_usage` que não recebe argumentos e retorna uma string que será usada "
"ao imprimir o uso do programa. Se tal método não for fornecido, será usado "
"um valor predefinido sensato."

#: ../../library/argparse.rst:1437
msgid ""
"A subclass of :class:`Action` for handling boolean flags with positive and "
"negative options. Adding a single argument such as ``--foo`` automatically "
"creates both ``--foo`` and ``--no-foo`` options, storing ``True`` and "
"``False`` respectively::"
msgstr ""
"Uma subclasse de :class:`Action` para tratar flags booleanas com opções "
"positivas e negativas. Adicionar um único argumento como ``--foo`` cria "
"automaticamente as opções ``--foo`` e ``--no-foo``, armazenando ``True`` e "
"``False`` respetivamente::"

#: ../../library/argparse.rst:1442
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)\n"
">>> parser.parse_args(['--no-foo'])\n"
"Namespace(foo=False)"

#: ../../library/argparse.rst:1452
msgid "The parse_args() method"
msgstr "O método parse_args()"

#: ../../library/argparse.rst:1456
msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""
"Converte strings de argumentos em objetos e atribui-os como atributos do "
"namespace. Retorna o namespace preenchido."

#: ../../library/argparse.rst:1459
msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for :meth:`!"
"add_argument` for details."
msgstr ""
"Chamadas anteriores a :meth:`add_argument` determinam exatamente que objetos "
"são criados e como são atribuídos. Consulte a documentação de :meth:`!"
"add_argument` para detalhes."

#: ../../library/argparse.rst:1463
msgid ""
"args_ - List of strings to parse.  The default is taken from :data:`sys."
"argv`."
msgstr ""
"args_ — Lista de strings a analisar. O valor predefinido é obtido de :data:"
"`sys.argv`."

#: ../../library/argparse.rst:1466
msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty :"
"class:`Namespace` object."
msgstr ""
"namespace_ — Um objeto para receber os atributos. O valor predefinido é um "
"novo objeto :class:`Namespace` vazio."

#: ../../library/argparse.rst:1471
msgid "Option value syntax"
msgstr "Sintaxe do valor da opção"

#: ../../library/argparse.rst:1473
msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""
"O método :meth:`~ArgumentParser.parse_args` suporta várias formas de "
"especificar o valor de uma opção (se esta aceitar um). No caso mais simples, "
"a opção e o seu valor são passados como dois argumentos separados::"

#: ../../library/argparse.rst:1477
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(['-x', 'X'])\n"
"Namespace(foo=None, x='X')\n"
">>> parser.parse_args(['--foo', 'FOO'])\n"
"Namespace(foo='FOO', x=None)"

#: ../../library/argparse.rst:1485
msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using "
"``=`` to separate them::"
msgstr ""
"Para opções longas (opções com nomes mais longos do que um único caractere), "
"a opção e o valor também podem ser passados como um único argumento de linha "
"de comandos, usando ``=`` para os separar::"

#: ../../library/argparse.rst:1489
msgid ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"
msgstr ""
">>> parser.parse_args(['--foo=FOO'])\n"
"Namespace(foo='FOO', x=None)"

#: ../../library/argparse.rst:1492
msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""
"Para opções curtas (opções com apenas um caractere), a opção e o seu valor "
"podem ser concatenados::"

#: ../../library/argparse.rst:1495
msgid ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"
msgstr ""
">>> parser.parse_args(['-xX'])\n"
"Namespace(foo=None, x='X')"

#: ../../library/argparse.rst:1498
msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr ""
"Várias opções curtas podem ser unidas, usando apenas um único prefixo ``-``, "
"desde que apenas a última opção (ou nenhuma delas) requeira um valor::"

#: ../../library/argparse.rst:1501
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x', action='store_true')\n"
">>> parser.add_argument('-y', action='store_true')\n"
">>> parser.add_argument('-z')\n"
">>> parser.parse_args(['-xyzZ'])\n"
"Namespace(x=True, y=True, z='Z')"

#: ../../library/argparse.rst:1510
msgid "Invalid arguments"
msgstr "Argumentos inválidos"

#: ../../library/argparse.rst:1512
msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid "
"options, wrong number of positional arguments, etc.  When it encounters such "
"an error, it exits and prints the error along with a usage message::"
msgstr ""
"Ao analisar a linha de comandos, :meth:`~ArgumentParser.parse_args` verifica "
"vários tipos de erros, incluindo opções ambíguas, tipos inválidos, opções "
"inválidas, número errado de argumentos posicionais, etc. Quando encontra um "
"erro, sai e imprime o erro juntamente com uma mensagem de uso::"

#: ../../library/argparse.rst:1517
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # invalid type\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: argument --foo: invalid int value: 'spam'\n"
"\n"
">>> # invalid option\n"
">>> parser.parse_args(['--bar'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: no such option: --bar\n"
"\n"
">>> # wrong number of arguments\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"usage: PROG [-h] [--foo FOO] [bar]\n"
"PROG: error: extra arguments found: badger"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', type=int)\n"
">>> parser.add_argument('bar', nargs='?')\n"
"\n"
">>> # tipo inválido\n"
">>> parser.parse_args(['--foo', 'spam'])\n"
"uso: PROG [-h] [--foo FOO] [bar]\n"
"PROG: erro: argumento --foo: valor int inválido: 'spam'\n"
"\n"
">>> # opção inválida\n"
">>> parser.parse_args(['--bar'])\n"
"uso: PROG [-h] [--foo FOO] [bar]\n"
"PROG: erro: não existe a opção: --bar\n"
"\n"
">>> # número errado de argumentos\n"
">>> parser.parse_args(['spam', 'badger'])\n"
"uso: PROG [-h] [--foo FOO] [bar]\n"
"PROG: erro: argumentos extra encontrados: badger"

#: ../../library/argparse.rst:1538
msgid "Arguments containing ``-``"
msgstr "Argumentos contendo ``-``"

#: ../../library/argparse.rst:1540
msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""
"O método :meth:`~ArgumentParser.parse_args` tenta dar erros sempre que o "
"utilizador comete claramente um erro, mas algumas situações são "
"inerentemente ambíguas. Por exemplo, o argumento de linha de comandos ``-1`` "
"pode ser uma tentativa de especificar uma opção ou de fornecer um argumento "
"posicional. O método :meth:`~ArgumentParser.parse_args` é cauteloso aqui: "
"argumentos posicionais só podem começar com ``-`` se parecerem números "
"negativos e não houver opções no analisador que pareçam números negativos::"

#: ../../library/argparse.rst:1548
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # no negative number options, so -1 is a positional argument\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # no negative number options, so -1 and -5 are positional arguments\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # negative number options present, so -1 is an option\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # negative number options present, so -2 is an option\n"
">>> parser.parse_args(['-2'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: no such option: -2\n"
"\n"
">>> # negative number options present, so both -1s are options\n"
">>> parser.parse_args(['-1', '-1'])\n"
"usage: PROG [-h] [-1 ONE] [foo]\n"
"PROG: error: argument -1: expected one argument"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-x')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # sem opções de número negativo, então -1 é um argumento posicional\n"
">>> parser.parse_args(['-x', '-1'])\n"
"Namespace(foo=None, x='-1')\n"
"\n"
">>> # sem opções de número negativo, então -1 e -5 são argumentos "
"posicionais\n"
">>> parser.parse_args(['-x', '-1', '-5'])\n"
"Namespace(foo='-5', x='-1')\n"
"\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-1', dest='one')\n"
">>> parser.add_argument('foo', nargs='?')\n"
"\n"
">>> # opções de número negativo presentes, então -1 é uma opção\n"
">>> parser.parse_args(['-1', 'X'])\n"
"Namespace(foo=None, one='X')\n"
"\n"
">>> # opções de número negativo presentes, então -2 é uma opção\n"
">>> parser.parse_args(['-2'])\n"
"uso: PROG [-h] [-1 ONE] [foo]\n"
"PROG: erro: não existe a opção: -2\n"
"\n"
">>> # opções de número negativo presentes, então ambos os -1 são opções\n"
">>> parser.parse_args(['-1', '-1'])\n"
"uso: PROG [-h] [-1 ONE] [foo]\n"
"PROG: erro: argumento -1: esperado um argumento"

#: ../../library/argparse.rst:1578
msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""
"Se tiver argumentos posicionais que devem começar com ``-`` e não parecerem "
"números negativos, pode inserir o pseudo-argumento ``'--'`` que diz a :meth:"
"`~ArgumentParser.parse_args` que tudo depois disso é um argumento "
"posicional::"

#: ../../library/argparse.rst:1583
msgid ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"
msgstr ""
">>> parser.parse_args(['--', '-f'])\n"
"Namespace(foo='-f', one=None)"

#: ../../library/argparse.rst:1586
msgid ""
"See also :ref:`the argparse howto on ambiguous arguments <specifying-"
"ambiguous-arguments>` for more details."
msgstr ""
"Veja também :ref:`o guia argparse sobre argumentos ambíguos <specifying-"
"ambiguous-arguments>` para mais detalhes."

#: ../../library/argparse.rst:1592
msgid "Argument abbreviations (prefix matching)"
msgstr "Abreviaturas de argumentos (correspondência de prefixos)"

#: ../../library/argparse.rst:1594
msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
"O método :meth:`~ArgumentParser.parse_args` :ref:`por predefinição "
"<allow_abbrev>` permite que opções longas sejam abreviadas para um prefixo, "
"se a abreviatura for inequívoca (o prefixo corresponde a uma opção única)::"

#: ../../library/argparse.rst:1598
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"usage: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: error: ambiguous option: -ba could match -badger, -bacon"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('-bacon')\n"
">>> parser.add_argument('-badger')\n"
">>> parser.parse_args('-bac MMM'.split())\n"
"Namespace(bacon='MMM', badger=None)\n"
">>> parser.parse_args('-bad WOOD'.split())\n"
"Namespace(bacon=None, badger='WOOD')\n"
">>> parser.parse_args('-ba BA'.split())\n"
"uso: PROG [-h] [-bacon BACON] [-badger BADGER]\n"
"PROG: erro: opção ambígua: -ba pode corresponder a -badger, -bacon"

#: ../../library/argparse.rst:1609
msgid ""
"An error is produced for arguments that could produce more than one options. "
"This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr ""
"É produzido um erro para argumentos que podem produzir mais do que uma "
"opção. Esta funcionalidade pode ser desativada definindo :ref:`allow_abbrev` "
"como ``False``."

#: ../../library/argparse.rst:1615
msgid "Beyond ``sys.argv``"
msgstr "Para além de ``sys.argv``"

#: ../../library/argparse.rst:1617
msgid ""
"Sometimes it may be useful to have an :class:`ArgumentParser` parse "
"arguments other than those of :data:`sys.argv`.  This can be accomplished by "
"passing a list of strings to :meth:`~ArgumentParser.parse_args`.  This is "
"useful for testing at the interactive prompt::"
msgstr ""
"Às vezes pode ser útil ter um :class:`ArgumentParser` que analise argumentos "
"diferentes dos de :data:`sys.argv`. Isto pode ser conseguido passando uma "
"lista de strings para :meth:`~ArgumentParser.parse_args`. Isto é útil para "
"testar no prompt interativo::"

#: ../../library/argparse.rst:1622
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'integers', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='an integer in the range 0..9')\n"
">>> parser.add_argument(\n"
"...     '--sum', dest='accumulate', action='store_const', const=sum,\n"
"...     default=max, help='sum the integers (default: find the max)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--sum'])\n"
"Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument(\n"
"...     'inteiros', metavar='int', type=int, choices=range(10),\n"
"...     nargs='+', help='um inteiro no intervalo 0..9')\n"
">>> parser.add_argument(\n"
"...     '--soma', dest='acumulado', action='store_const', const=sum,\n"
"...     default=max, help='soma os inteiros (predefinição: encontrar o "
"máximo)')\n"
">>> parser.parse_args(['1', '2', '3', '4'])\n"
"Namespace(acumulado=<função integrada max>, inteiros=[1, 2, 3, 4])\n"
">>> parser.parse_args(['1', '2', '3', '4', '--soma'])\n"
"Namespace(acumulado=<função integrada sum>, inteiros=[1, 2, 3, 4])"

#: ../../library/argparse.rst:1637
msgid "The Namespace object"
msgstr "O objeto Namespace"

#: ../../library/argparse.rst:1641
msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create "
"an object holding attributes and return it."
msgstr ""
"Classe simples usada por predefinição por :meth:`~ArgumentParser.parse_args` "
"para criar um objeto que contém atributos e retorná-lo."

#: ../../library/argparse.rst:1644
msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"Esta classe é deliberadamente simples, apenas uma subclasse de :class:"
"`object` com uma representação de string legível. Se preferir ter uma visão "
"tipo dicionário dos atributos, pode usar o idioma Python padrão, :func:"
"`vars`::"

#: ../../library/argparse.rst:1648
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> args = parser.parse_args(['--foo', 'BAR'])\n"
">>> vars(args)\n"
"{'foo': 'BAR'}"

#: ../../library/argparse.rst:1654
msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object.  "
"This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""
"Também pode ser útil ter um :class:`ArgumentParser` que atribua atributos a "
"um objeto já existente, em vez de um novo objeto :class:`Namespace`. Isto "
"pode ser conseguido especificando o argumento de palavra-chave "
"``namespace=``::"

#: ../../library/argparse.rst:1658
msgid ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"
msgstr ""
">>> class C:\n"
"...     pass\n"
"...\n"
">>> c = C()\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)\n"
">>> c.foo\n"
"'BAR'"

#: ../../library/argparse.rst:1670
msgid "Other utilities"
msgstr "Outras utilidades"

#: ../../library/argparse.rst:1673
msgid "Sub-commands"
msgstr "Subcomandos"

#: ../../library/argparse.rst:1680
msgid ""
"Many programs split up their functionality into a number of subcommands, for "
"example, the ``svn`` program can invoke subcommands like ``svn checkout``, "
"``svn update``, and ``svn commit``.  Splitting up functionality this way can "
"be a particularly good idea when a program performs several different "
"functions which require different kinds of command-line arguments. :class:"
"`ArgumentParser` supports the creation of such subcommands with the :meth:`!"
"add_subparsers` method.  The :meth:`!add_subparsers` method is normally "
"called with no arguments and returns a special action object.  This object "
"has a single method, :meth:`~_SubParsersAction.add_parser`, which takes a "
"command name and any :class:`!ArgumentParser` constructor arguments, and "
"returns an :class:`!ArgumentParser` object that can be modified as usual."
msgstr ""
"Muitos programas dividem a sua funcionalidade em vários subcomandos, por "
"exemplo, o programa ``svn`` pode invocar subcomandos como ``svn checkout``, "
"``svn update`` e ``svn commit``. Dividir a funcionalidade desta forma pode "
"ser uma ideia particularmente boa quando um programa realiza várias funções "
"diferentes que requerem diferentes tipos de argumentos de linha de "
"comandos. :class:`ArgumentParser` suporta a criação de tais subcomandos com "
"o método :meth:`!add_subparsers`. O método :meth:`!add_subparsers` é "
"normalmente chamado sem argumentos e retorna um objeto de ação especial. "
"Este objeto tem um único método, :meth:`~_SubParsersAction.add_parser`, que "
"recebe um nome de comando e quaisquer argumentos do construtor :class:`!"
"ArgumentParser`, e retorna um objeto :class:`!ArgumentParser` que pode ser "
"modificado como de costume."

#: ../../library/argparse.rst:1692
msgid "Description of parameters:"
msgstr "Descrição dos parâmetros:"

#: ../../library/argparse.rst:1694
msgid ""
"*title* - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""
"*title* — título para o grupo de subanalisadores na saída de ajuda; por "
"predefinição, \"subcomandos\" se a descrição for fornecida, caso contrário "
"usa o título para argumentos posicionais"

#: ../../library/argparse.rst:1698
msgid ""
"*description* - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""
"*description* — descrição para o grupo de subanalisadores na saída de ajuda, "
"por predefinição ``None``"

#: ../../library/argparse.rst:1701
msgid ""
"*prog* - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""
"*prog* — informação de uso que será exibida com a ajuda do subcomando, por "
"predefinição o nome do programa e quaisquer argumentos posicionais antes do "
"argumento do subanalisador"

#: ../../library/argparse.rst:1705
msgid ""
"*parser_class* - class which will be used to create sub-parser instances, by "
"default the class of the current parser (e.g. :class:`ArgumentParser`)"
msgstr ""
"*parser_class* — classe que será usada para criar instâncias de "
"subanalisadores, por predefinição a classe do analisador atual (por "
"exemplo, :class:`ArgumentParser`)"

#: ../../library/argparse.rst:1708
msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""
"action_ — o tipo básico de ação a ser tomada quando este argumento é "
"encontrado na linha de comandos"

#: ../../library/argparse.rst:1711
msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr ""
"dest_ — nome do atributo sob o qual o nome do subcomando será armazenado; "
"por predefinição ``None`` e nenhum valor é armazenado"

#: ../../library/argparse.rst:1714
msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr ""
"required_ — Se um subcomando deve ser fornecido ou não, por predefinição "
"``False`` (adicionado em 3.7)"

#: ../../library/argparse.rst:1717
msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""
"help_ — ajuda para o grupo de subanalisadores na saída de ajuda, por "
"predefinição ``None``"

#: ../../library/argparse.rst:1719
msgid ""
"metavar_ - string presenting available subcommands in help; by default it is "
"``None`` and presents subcommands in form {cmd1, cmd2, ..}"
msgstr ""
"metavar_ — string que apresenta os subcomandos disponíveis na ajuda; por "
"predefinição é ``None`` e apresenta os subcomandos na forma {cmd1, cmd2, ..}"

#: ../../library/argparse.rst:1722
msgid "Some example usage::"
msgstr "Alguns exemplos de uso::"

#: ../../library/argparse.rst:1724
msgid ""
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='foo help')\n"
">>> subparsers = parser.add_subparsers(help='subcommand help')\n"
">>>\n"
">>> # create the parser for the \"a\" command\n"
">>> parser_a = subparsers.add_parser('a', help='a help')\n"
">>> parser_a.add_argument('bar', type=int, help='bar help')\n"
">>>\n"
">>> # create the parser for the \"b\" command\n"
">>> parser_b = subparsers.add_parser('b', help='b help')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz "
"help')\n"
">>>\n"
">>> # parse some argument lists\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"
msgstr ""
">>> # criar o analisador de nível superior\n"
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> parser.add_argument('--foo', action='store_true', help='ajuda foo')\n"
">>> subparsers = parser.add_subparsers(help='ajuda subcomando')\n"
">>>\n"
">>> # criar o analisador para o comando \"a\"\n"
">>> parser_a = subparsers.add_parser('a', help='ajuda a')\n"
">>> parser_a.add_argument('bar', type=int, help='ajuda bar')\n"
">>>\n"
">>> # criar o analisador para o comando \"b\"\n"
">>> parser_b = subparsers.add_parser('b', help='ajuda b')\n"
">>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='ajuda "
"baz')\n"
">>>\n"
">>> # analisar algumas listas de argumentos\n"
">>> parser.parse_args(['a', '12'])\n"
"Namespace(bar=12, foo=False)\n"
">>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])\n"
"Namespace(baz='Z', foo=True)"

#: ../../library/argparse.rst:1743
msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""
"Note que o objeto retornado por :meth:`parse_args` conterá apenas atributos "
"para o analisador principal e o subanalisador que foi selecionado pela linha "
"de comandos (e não quaisquer outros subanalisadores). Assim, no exemplo "
"acima, quando o comando ``a`` é especificado, apenas os atributos ``foo`` e "
"``bar`` estão presentes, e quando o comando ``b`` é especificado, apenas os "
"atributos ``foo`` e ``baz`` estão presentes."

#: ../../library/argparse.rst:1750
msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument "
"to :meth:`~_SubParsersAction.add_parser` as above.)"
msgstr ""
"Da mesma forma, quando uma mensagem de ajuda é solicitada a partir de um "
"subanalisador, apenas a ajuda para esse analisador específico será impressa. "
"A mensagem de ajuda não incluirá mensagens do analisador principal ou de "
"analisadores irmãos. (Uma mensagem de ajuda para cada comando de "
"subanalisador, no entanto, pode ser fornecida ao fornecer o argumento "
"``help=`` para :meth:`~_SubParsersAction.add_parser` como acima.)"

#: ../../library/argparse.rst:1758
msgid ""
">>> parser.parse_args(['--help'])\n"
"usage: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"positional arguments:\n"
"  {a,b}   subcommand help\n"
"    a     a help\n"
"    b     b help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"  --foo   foo help\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"usage: PROG a [-h] bar\n"
"\n"
"positional arguments:\n"
"  bar     bar help\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"usage: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"options:\n"
"  -h, --help     show this help message and exit\n"
"  --baz {X,Y,Z}  baz help"
msgstr ""
">>> parser.parse_args(['--help'])\n"
"uso: PROG [-h] [--foo] {a,b} ...\n"
"\n"
"argumentos posicionais:\n"
"  {a,b}   ajuda subcomando\n"
"    a     ajuda a\n"
"    b     ajuda b\n"
"\n"
"opções:\n"
"  -h, --help  mostrar esta mensagem de ajuda e sair\n"
"  --foo   ajuda foo\n"
"\n"
">>> parser.parse_args(['a', '--help'])\n"
"uso: PROG a [-h] bar\n"
"\n"
"argumentos posicionais:\n"
"  bar     ajuda bar\n"
"\n"
"opções:\n"
"  -h, --help  mostrar esta mensagem de ajuda e sair\n"
"\n"
">>> parser.parse_args(['b', '--help'])\n"
"uso: PROG b [-h] [--baz {X,Y,Z}]\n"
"\n"
"opções:\n"
"  -h, --help     mostrar esta mensagem de ajuda e sair\n"
"  --baz {X,Y,Z}  ajuda baz"

#: ../../library/argparse.rst:1786
msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""
"O método :meth:`add_subparsers` também suporta os argumentos de palavra-"
"chave ``title`` e ``description``. Quando algum deles está presente, os "
"comandos do subanalisador aparecerão no seu próprio grupo na saída de ajuda. "
"Por exemplo::"

#: ../../library/argparse.rst:1790
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcommands',\n"
"...                                    description='valid subcommands',\n"
"...                                    help='additional help')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"usage:  [-h] {foo,bar} ...\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"subcommands:\n"
"  valid subcommands\n"
"\n"
"  {foo,bar}   additional help"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(title='subcomandos',\n"
"...                                    description='subcomandos válidos',\n"
"...                                    help='ajuda adicional')\n"
">>> subparsers.add_parser('foo')\n"
">>> subparsers.add_parser('bar')\n"
">>> parser.parse_args(['-h'])\n"
"uso:  [-h] {foo,bar} ...\n"
"\n"
"opções:\n"
"  -h, --help  mostrar esta mensagem de ajuda e sair\n"
"\n"
"subcomandos:\n"
"  subcomandos válidos\n"
"\n"
"  {foo,bar}   ajuda adicional"

#: ../../library/argparse.rst:1807
msgid ""
"Furthermore, :meth:`~_SubParsersAction.add_parser` supports an additional "
"*aliases* argument, which allows multiple strings to refer to the same "
"subparser. This example, like ``svn``, aliases ``co`` as a shorthand for "
"``checkout``::"
msgstr ""
"Além disso, :meth:`~_SubParsersAction.add_parser` suporta um argumento "
"adicional *aliases*, que permite que várias strings se refiram ao mesmo "
"subanalisador. Este exemplo, como ``svn``, cria um alias ``co`` como atalho "
"para ``checkout``::"

#: ../../library/argparse.rst:1812
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers()\n"
">>> checkout = subparsers.add_parser('checkout', aliases=['co'])\n"
">>> checkout.add_argument('foo')\n"
">>> parser.parse_args(['co', 'bar'])\n"
"Namespace(foo='bar')"

#: ../../library/argparse.rst:1819
msgid ""
":meth:`~_SubParsersAction.add_parser` supports also an additional "
"*deprecated* argument, which allows to deprecate the subparser."
msgstr ""
":meth:`~_SubParsersAction.add_parser` também suporta um argumento adicional "
"*deprecated*, que permite tornar obsoleto o subanalisador."

#: ../../library/argparse.rst:1833
msgid ""
"One particularly effective way of handling subcommands is to combine the use "
"of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` so "
"that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""
"Uma forma particularmente eficaz de lidar com subcomandos é combinar o uso "
"do método :meth:`add_subparsers` com chamadas a :meth:`set_defaults` para "
"que cada subanalisador saiba qual a função Python que deve executar. Por "
"exemplo::"

#: ../../library/argparse.rst:1838
msgid ""
">>> # subcommand functions\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # create the top-level parser\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # create the parser for the \"foo\" command\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # create the parser for the \"bar\" command\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # parse the args and call whatever function was selected\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"
msgstr ""
">>> # funções de subcomando\n"
">>> def foo(args):\n"
"...     print(args.x * args.y)\n"
"...\n"
">>> def bar(args):\n"
"...     print('((%s))' % args.z)\n"
"...\n"
">>> # criar o analisador de nível superior\n"
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(required=True)\n"
">>>\n"
">>> # criar o analisador para o comando \"foo\"\n"
">>> parser_foo = subparsers.add_parser('foo')\n"
">>> parser_foo.add_argument('-x', type=int, default=1)\n"
">>> parser_foo.add_argument('y', type=float)\n"
">>> parser_foo.set_defaults(func=foo)\n"
">>>\n"
">>> # criar o analisador para o comando \"bar\"\n"
">>> parser_bar = subparsers.add_parser('bar')\n"
">>> parser_bar.add_argument('z')\n"
">>> parser_bar.set_defaults(func=bar)\n"
">>>\n"
">>> # analisar os argumentos e chamar a função selecionada\n"
">>> args = parser.parse_args('foo 1 -x 2'.split())\n"
">>> args.func(args)\n"
"2.0\n"
">>>\n"
">>> # analisar os argumentos e chamar a função selecionada\n"
">>> args = parser.parse_args('bar XYZYX'.split())\n"
">>> args.func(args)\n"
"((XYZYX))"

#: ../../library/argparse.rst:1870
msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"Desta forma, pode deixar que :meth:`parse_args` faça o trabalho de chamar a "
"função apropriada após a análise dos argumentos estar completa. Associar "
"funções a ações desta forma é tipicamente a maneira mais fácil de lidar com "
"as diferentes ações para cada um dos seus subanalisadores. No entanto, se "
"for necessário verificar o nome do subanalisador que foi invocado, o "
"argumento de palavra-chave ``dest`` na chamada :meth:`add_subparsers` "
"funcionará::"

#: ../../library/argparse.rst:1877
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> subparsers = parser.add_subparsers(dest='subparser_name')\n"
">>> subparser1 = subparsers.add_parser('1')\n"
">>> subparser1.add_argument('-x')\n"
">>> subparser2 = subparsers.add_parser('2')\n"
">>> subparser2.add_argument('y')\n"
">>> parser.parse_args(['2', 'frobble'])\n"
"Namespace(subparser_name='2', y='frobble')"

#: ../../library/argparse.rst:1886
msgid "New *required* keyword-only parameter."
msgstr "Novo parâmetro *required* apenas de palavra-chave."

#: ../../library/argparse.rst:1889
msgid ""
"Subparser's *prog* is no longer affected by a custom usage message in the "
"main parser."
msgstr ""
"O *prog* do subanalisador já não é afetado por uma mensagem de uso "
"personalizada no analisador principal."

#: ../../library/argparse.rst:1895
msgid "FileType objects"
msgstr "Objetos FileType"

#: ../../library/argparse.rst:1899
msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type "
"argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:"
"`FileType` objects as their type will open command-line arguments as files "
"with the requested modes, buffer sizes, encodings and error handling (see "
"the :func:`open` function for more details)::"
msgstr ""
"A fábrica :class:`FileType` cria objetos que podem ser passados para o "
"argumento type de :meth:`ArgumentParser.add_argument`. Argumentos que têm "
"objetos :class:`FileType` como seu tipo abrirão argumentos de linha de "
"comandos como ficheiros com os modos, tamanhos de buffer, codificações e "
"tratamento de erros solicitados (consulte a função :func:`open` para mais "
"detalhes)::"

#: ../../library/argparse.rst:1905
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))\n"
">>> parser.add_argument('out', type=argparse.FileType('w', "
"encoding='UTF-8'))\n"
">>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])\n"
"Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, "
"raw=<_io.FileIO name='raw.dat' mode='wb'>)"

#: ../../library/argparse.rst:1911
msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into :data:`sys.stdin` for readable :class:`FileType` objects "
"and :data:`sys.stdout` for writable :class:`FileType` objects::"
msgstr ""
"Os objetos FileType entendem o pseudo-argumento ``'-'`` e convertem-no "
"automaticamente em :data:`sys.stdin` para objetos :class:`FileType` legíveis "
"e em :data:`sys.stdout` para objetos :class:`FileType` graváveis::"

#: ../../library/argparse.rst:1915
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('infile', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('ficheiro_entrada', type=argparse.FileType('r'))\n"
">>> parser.parse_args(['-'])\n"
"Namespace(ficheiro_entrada=<_io.TextIOWrapper name='<stdin>' "
"encoding='UTF-8'>)"

#: ../../library/argparse.rst:1922
msgid ""
"If one argument uses *FileType* and then a subsequent argument fails, an "
"error is reported but the file is not automatically closed. This can also "
"clobber the output files. In this case, it would be better to wait until "
"after the parser has run and then use the :keyword:`with`-statement to "
"manage the files."
msgstr ""
"Se um argumento usar *FileType* e depois um argumento subsequente falhar, um "
"erro é reportado, mas o ficheiro não é fechado automaticamente. Isto também "
"pode corromper os ficheiros de saída. Neste caso, seria melhor esperar até "
"que o analisador tenha terminado e depois usar a instrução :keyword:`with` "
"para gerir os ficheiros."

#: ../../library/argparse.rst:1928
msgid "Added the *encodings* and *errors* parameters."
msgstr "Adicionados os parâmetros *encodings* e *errors*."

#: ../../library/argparse.rst:1935
msgid "Argument groups"
msgstr "Grupos de argumentos"

#: ../../library/argparse.rst:1940
msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"options\" when displaying help messages. When "
"there is a better conceptual grouping of arguments than this default one, "
"appropriate groups can be created using the :meth:`!add_argument_group` "
"method::"
msgstr ""
"Por predefinição, :class:`ArgumentParser` agrupa argumentos de linha de "
"comandos em \"argumentos posicionais\" e \"opções\" ao exibir mensagens de "
"ajuda. Quando existe um agrupamento conceitual melhor dos argumentos do que "
"este predefinido, grupos apropriados podem ser criados usando o método :meth:"
"`!add_argument_group`::"

#: ../../library/argparse.rst:1946
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('group')\n"
">>> group.add_argument('--foo', help='foo help')\n"
">>> group.add_argument('bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--foo FOO] bar\n"
"\n"
"group:\n"
"  bar    bar help\n"
"  --foo FOO  foo help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group = parser.add_argument_group('grupo')\n"
">>> group.add_argument('--foo', help='ajuda foo')\n"
">>> group.add_argument('bar', help='ajuda bar')\n"
">>> parser.print_help()\n"
"uso: PROG [--foo FOO] bar\n"
"\n"
"grupo:\n"
"  bar    ajuda bar\n"
"  --foo FOO  ajuda foo"

#: ../../library/argparse.rst:1957
msgid ""
"The :meth:`add_argument_group` method returns an argument group object which "
"has an :meth:`~ArgumentParser.add_argument` method just like a regular :"
"class:`ArgumentParser`.  When an argument is added to the group, the parser "
"treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`!add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""
"O método :meth:`add_argument_group` retorna um objeto de grupo de argumentos "
"que tem um método :meth:`~ArgumentParser.add_argument` tal como um :class:"
"`ArgumentParser` normal. Quando um argumento é adicionado ao grupo, o "
"analisador trata-o como um argumento normal, mas exibe o argumento num grupo "
"separado para mensagens de ajuda. O método :meth:`!add_argument_group` "
"aceita argumentos *title* e *description* que podem ser usados para "
"personalizar esta exibição::"

#: ../../library/argparse.rst:1965
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('group1', 'group1 description')\n"
">>> group1.add_argument('foo', help='foo help')\n"
">>> group2 = parser.add_argument_group('group2', 'group2 description')\n"
">>> group2.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [--bar BAR] foo\n"
"\n"
"group1:\n"
"  group1 description\n"
"\n"
"  foo    foo help\n"
"\n"
"group2:\n"
"  group2 description\n"
"\n"
"  --bar BAR  bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)\n"
">>> group1 = parser.add_argument_group('grupo1', 'descrição grupo1')\n"
">>> group1.add_argument('foo', help='ajuda foo')\n"
">>> group2 = parser.add_argument_group('grupo2', 'descrição grupo2')\n"
">>> group2.add_argument('--bar', help='ajuda bar')\n"
">>> parser.print_help()\n"
"uso: PROG [--bar BAR] foo\n"
"\n"
"grupo1:\n"
"  descrição grupo1\n"
"\n"
"  foo    ajuda foo\n"
"\n"
"grupo2:\n"
"  descrição grupo2\n"
"\n"
"  --bar BAR  ajuda bar"

#: ../../library/argparse.rst:1983
msgid ""
"The optional, keyword-only parameters argument_default_ and "
"conflict_handler_ allow for finer-grained control of the behavior of the "
"argument group. These parameters have the same meaning as in the :class:"
"`ArgumentParser` constructor, but apply specifically to the argument group "
"rather than the entire parser."
msgstr ""
"Os parâmetros opcionais, apenas de palavra-chave, argument_default_ e "
"conflict_handler_ permitem um controlo mais fino do comportamento do grupo "
"de argumentos. Estes parâmetros têm o mesmo significado que no construtor :"
"class:`ArgumentParser`, mas aplicam-se especificamente ao grupo de "
"argumentos em vez de ao analisador completo."

#: ../../library/argparse.rst:1988
msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr ""
"Note que quaisquer argumentos que não estejam nos seus grupos definidos pelo "
"utilizador acabarão de volta nas secções habituais de \"argumentos "
"posicionais\" e \"argumentos opcionais\"."

#: ../../library/argparse.rst:1991
msgid ""
"Calling :meth:`add_argument_group` on an argument group now raises an "
"exception. This nesting was never supported, often failed to work correctly, "
"and was unintentionally exposed through inheritance."
msgstr ""
"Chamar :meth:`add_argument_group` num grupo de argumentos agora levanta uma "
"exceção. Este aninhamento nunca foi suportado, frequentemente falhava em "
"funcionar corretamente e foi exposto acidentalmente através de herança."

#: ../../library/argparse.rst:1996
msgid "Passing prefix_chars_ to :meth:`add_argument_group` is now deprecated."
msgstr ""
"Passar prefix_chars_ para :meth:`add_argument_group` está agora obsoleto."

#: ../../library/argparse.rst:2002
msgid "Mutual exclusion"
msgstr "Exclusão mútua"

#: ../../library/argparse.rst:2006
msgid ""
"Create a mutually exclusive group. :mod:`!argparse` will make sure that only "
"one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr ""
"Criar um grupo de exclusão mútua. :mod:`!argparse` garantirá que apenas um "
"dos argumentos no grupo de exclusão mútua esteja presente na linha de "
"comandos::"

#: ../../library/argparse.rst:2010
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"usage: PROG [-h] [--foo | --bar]\n"
"PROG: error: argument --bar: not allowed with argument --foo"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group()\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args(['--foo'])\n"
"Namespace(bar=True, foo=True)\n"
">>> parser.parse_args(['--bar'])\n"
"Namespace(bar=False, foo=False)\n"
">>> parser.parse_args(['--foo', '--bar'])\n"
"uso: PROG [-h] [--foo | --bar]\n"
"PROG: erro: argumento --bar: não permitido com o argumento --foo"

#: ../../library/argparse.rst:2022
msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""
"O método :meth:`add_mutually_exclusive_group` também aceita um argumento "
"*required*, para indicar que pelo menos um dos argumentos de exclusão mútua "
"é obrigatório::"

#: ../../library/argparse.rst:2026
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"usage: PROG [-h] (--foo | --bar)\n"
"PROG: error: one of the arguments --foo --bar is required"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_mutually_exclusive_group(required=True)\n"
">>> group.add_argument('--foo', action='store_true')\n"
">>> group.add_argument('--bar', action='store_false')\n"
">>> parser.parse_args([])\n"
"uso: PROG [-h] (--foo | --bar)\n"
"PROG: erro: um dos argumentos --foo --bar é obrigatório"

#: ../../library/argparse.rst:2034
msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of :meth:`~ArgumentParser."
"add_argument_group`. However, a mutually exclusive group can be added to an "
"argument group that has a title and description. For example::"
msgstr ""
"Note que atualmente os grupos de argumentos de exclusão mútua não suportam "
"os argumentos *title* e *description* de :meth:`~ArgumentParser."
"add_argument_group`. No entanto, um grupo de exclusão mútua pode ser "
"adicionado a um grupo de argumentos que tenha um título e descrição. Por "
"exemplo::"

#: ../../library/argparse.rst:2040
msgid ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Group title', 'Group description')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='foo help')\n"
">>> exclusive_group.add_argument('--bar', help='bar help')\n"
">>> parser.print_help()\n"
"usage: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"options:\n"
"  -h, --help  show this help message and exit\n"
"\n"
"Group title:\n"
"  Group description\n"
"\n"
"  --foo FOO   foo help\n"
"  --bar BAR   bar help"
msgstr ""
">>> parser = argparse.ArgumentParser(prog='PROG')\n"
">>> group = parser.add_argument_group('Título do Grupo', 'Descrição do "
"Grupo')\n"
">>> exclusive_group = group.add_mutually_exclusive_group(required=True)\n"
">>> exclusive_group.add_argument('--foo', help='ajuda foo')\n"
">>> exclusive_group.add_argument('--bar', help='ajuda bar')\n"
">>> parser.print_help()\n"
"uso: PROG [-h] (--foo FOO | --bar BAR)\n"
"\n"
"opções:\n"
"  -h, --help  mostrar esta mensagem de ajuda e sair\n"
"\n"
"Título do Grupo:\n"
"  Descrição do Grupo\n"
"\n"
"  --foo FOO   ajuda foo\n"
"  --bar BAR   ajuda bar"

#: ../../library/argparse.rst:2057
msgid ""
"Calling :meth:`add_argument_group` or :meth:`add_mutually_exclusive_group` "
"on a mutually exclusive group now raises an exception. This nesting was "
"never supported, often failed to work correctly, and was unintentionally "
"exposed through inheritance."
msgstr ""
"Chamar :meth:`add_argument_group` ou :meth:`add_mutually_exclusive_group` "
"num grupo de exclusão mútua agora levanta uma exceção. Este aninhamento "
"nunca foi suportado, frequentemente falhava em funcionar corretamente e foi "
"exposto acidentalmente através de herança."

#: ../../library/argparse.rst:2065
msgid "Parser defaults"
msgstr "Predefinições do analisador"

#: ../../library/argparse.rst:2069
msgid ""
"Most of the time, the attributes of the object returned by :meth:"
"`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""
"A maior parte das vezes, os atributos do objeto retornado por :meth:"
"`parse_args` serão totalmente determinados pela inspeção dos argumentos de "
"linha de comandos e das ações dos argumentos. :meth:`set_defaults` permite "
"que alguns atributos adicionais, determinados sem qualquer inspeção da linha "
"de comandos, sejam adicionados::"

#: ../../library/argparse.rst:2075
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='badger')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='badger', foo=736)"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('foo', type=int)\n"
">>> parser.set_defaults(bar=42, baz='texugo')\n"
">>> parser.parse_args(['736'])\n"
"Namespace(bar=42, baz='texugo', foo=736)"

#: ../../library/argparse.rst:2081
msgid ""
"Note that defaults can be set at both the parser level using :meth:"
"`set_defaults` and at the argument level using :meth:`add_argument`. If both "
"are called for the same argument, the last default set for an argument is "
"used::"
msgstr ""
"Note que as predefinições podem ser definidas tanto ao nível do analisador "
"usando :meth:`set_defaults` como ao nível do argumento usando :meth:"
"`add_argument`. Se ambos forem chamados para o mesmo argumento, a última "
"predefinição definida para um argumento é usada::"

#: ../../library/argparse.rst:2085
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='bar')\n"
">>> parser.set_defaults(foo='spam')\n"
">>> parser.parse_args([])\n"
"Namespace(foo='spam')"

#: ../../library/argparse.rst:2091
msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""
"As predefinições ao nível do analisador podem ser particularmente úteis ao "
"trabalhar com vários analisadores. Consulte o método :meth:`~ArgumentParser."
"add_subparsers` para um exemplo deste tipo."

#: ../../library/argparse.rst:2097
msgid ""
"Get the default value for a namespace attribute, as set by either :meth:"
"`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::"
msgstr ""
"Obter o valor predefinido para um atributo de namespace, conforme definido "
"por :meth:`~ArgumentParser.add_argument` ou por :meth:`~ArgumentParser."
"set_defaults`::"

#: ../../library/argparse.rst:2101
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='badger')\n"
">>> parser.get_default('foo')\n"
"'badger'"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', default='texugo')\n"
">>> parser.get_default('foo')\n"
"'texugo'"

#: ../../library/argparse.rst:2108
msgid "Printing help"
msgstr "Impressão de ajuda"

#: ../../library/argparse.rst:2110
msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""
"Na maioria das aplicações típicas, :meth:`~ArgumentParser.parse_args` "
"tratará da formatação e impressão de quaisquer mensagens de uso ou erro. No "
"entanto, estão disponíveis vários métodos de formatação:"

#: ../../library/argparse.rst:2116
msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""
"Imprime uma breve descrição de como o :class:`ArgumentParser` deve ser "
"invocado na linha de comandos. Se *file* for ``None``, assume-se :data:`sys."
"stdout`."

#: ../../library/argparse.rst:2122
msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"Imprime uma mensagem de ajuda, incluindo o uso do programa e informações "
"sobre os argumentos registados com o :class:`ArgumentParser`. Se *file* for "
"``None``, assume-se :data:`sys.stdout`."

#: ../../library/argparse.rst:2126
msgid ""
"There are also variants of these methods that simply return a string instead "
"of printing it:"
msgstr ""
"Existem também variantes destes métodos que simplesmente retornam uma string "
"em vez de a imprimir:"

#: ../../library/argparse.rst:2131
msgid ""
"Return a string containing a brief description of how the :class:"
"`ArgumentParser` should be invoked on the command line."
msgstr ""
"Retorna uma string contendo uma breve descrição de como o :class:"
"`ArgumentParser` deve ser invocado na linha de comandos."

#: ../../library/argparse.rst:2136
msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr ""
"Retorna uma string contendo uma mensagem de ajuda, incluindo o uso do "
"programa e informações sobre os argumentos registados com o :class:"
"`ArgumentParser`."

#: ../../library/argparse.rst:2141
msgid "Partial parsing"
msgstr "Análise parcial"

#: ../../library/argparse.rst:2145
msgid ""
"Sometimes a script only needs to handle a specific set of command-line "
"arguments, leaving any unrecognized arguments for another script or program. "
"In these cases, the :meth:`~ArgumentParser.parse_known_args` method can be "
"useful."
msgstr ""
"Às vezes, um script só precisa lidar com um conjunto específico de "
"argumentos de linha de comandos, deixando quaisquer argumentos não "
"reconhecidos para outro script ou programa. Nestes casos, o método :meth:"
"`~ArgumentParser.parse_known_args` pode ser útil."

#: ../../library/argparse.rst:2150
msgid ""
"This method works similarly to :meth:`~ArgumentParser.parse_args`, but it "
"does not raise an error for extra, unrecognized arguments. Instead, it "
"parses the known arguments and returns a two item tuple that contains the "
"populated namespace and the list of any unrecognized arguments."
msgstr ""
"Este método funciona de forma semelhante a :meth:`~ArgumentParser."
"parse_args`, mas não levanta um erro para argumentos extra não reconhecidos. "
"Em vez disso, analisa os argumentos conhecidos e retorna um tuplo de dois "
"itens que contém o namespace preenchido e a lista de quaisquer argumentos "
"não reconhecidos."

#: ../../library/argparse.rst:2157
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo', action='store_true')\n"
">>> parser.add_argument('bar')\n"
">>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])\n"
"(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])"

#: ../../library/argparse.rst:2164
msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to :meth:"
"`~ArgumentParser.parse_known_args`. The parser may consume an option even if "
"it's just a prefix of one of its known options, instead of leaving it in the "
"remaining arguments list."
msgstr ""
"As regras de :ref:`correspondência de prefixos <prefix-matching>` aplicam-se "
"a :meth:`~ArgumentParser.parse_known_args`. O analisador pode consumir uma "
"opção mesmo que seja apenas um prefixo de uma das suas opções conhecidas, em "
"vez de a deixar na lista de argumentos restantes."

#: ../../library/argparse.rst:2171
msgid "Customizing file parsing"
msgstr "Personalização da análise de ficheiros"

#: ../../library/argparse.rst:2175
msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword "
"argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""
"Os argumentos que são lidos de um ficheiro (consulte o argumento de palavra-"
"chave *fromfile_prefix_chars* no construtor :class:`ArgumentParser`) são "
"lidos um argumento por linha. :meth:`convert_arg_line_to_args` pode ser "
"substituído para leituras mais elaboradas."

#: ../../library/argparse.rst:2180
msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""
"Este método recebe um único argumento *arg_line*, que é uma string lida do "
"ficheiro de argumentos. Retorna uma lista de argumentos analisados a partir "
"desta string. O método é chamado uma vez por linha lida do ficheiro de "
"argumentos, por ordem."

#: ../../library/argparse.rst:2184
msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""
"Uma substituição útil deste método é uma que trata cada palavra separada por "
"espaços como um argumento. O exemplo seguinte demonstra como fazer isto::"

#: ../../library/argparse.rst:2187
msgid ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"
msgstr ""
"class MyArgumentParser(argparse.ArgumentParser):\n"
"    def convert_arg_line_to_args(self, arg_line):\n"
"        return arg_line.split()"

#: ../../library/argparse.rst:2193
msgid "Exiting methods"
msgstr "Métodos de saída"

#: ../../library/argparse.rst:2197
msgid ""
"This method terminates the program, exiting with the specified *status* and, "
"if given, it prints a *message* to :data:`sys.stderr` before that. The user "
"can override this method to handle these steps differently::"
msgstr ""
"Este método termina o programa, saindo com o *status* especificado e, se "
"fornecido, imprime uma *message* para :data:`sys.stderr` antes disso. O "
"utilizador pode substituir este método para lidar com estes passos de forma "
"diferente::"

#: ../../library/argparse.rst:2201
msgid ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'Exiting because of an error: {message}')\n"
"        exit(status)"
msgstr ""
"class ErrorCatchingArgumentParser(argparse.ArgumentParser):\n"
"    def exit(self, status=0, message=None):\n"
"        if status:\n"
"            raise Exception(f'A sair devido a um erro: {message}')\n"
"        exit(status)"

#: ../../library/argparse.rst:2209
msgid ""
"This method prints a usage message, including the *message*, to :data:`sys."
"stderr` and terminates the program with a status code of 2."
msgstr ""
"Este método imprime uma mensagem de uso, incluindo a *message*, para :data:"
"`sys.stderr` e termina o programa com um código de estado 2."

#: ../../library/argparse.rst:2214
msgid "Intermixed parsing"
msgstr "Análise intercalada"

#: ../../library/argparse.rst:2219
msgid ""
"A number of Unix commands allow the user to intermix optional arguments with "
"positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""
"Vários comandos Unix permitem ao utilizador intercalar argumentos opcionais "
"com argumentos posicionais. Os métodos :meth:`~ArgumentParser."
"parse_intermixed_args` e :meth:`~ArgumentParser.parse_known_intermixed_args` "
"suportam este estilo de análise."

#: ../../library/argparse.rst:2224
msgid ""
"These parsers do not support all the :mod:`!argparse` features, and will "
"raise exceptions if unsupported features are used.  In particular, "
"subparsers, and mutually exclusive groups that include both optionals and "
"positionals are not supported."
msgstr ""
"Estes analisadores não suportam todas as funcionalidades do módulo :mod:`!"
"argparse` e levantarão exceções se forem usadas funcionalidades não "
"suportadas. Em particular, subanalisadores e grupos de exclusão mútua que "
"incluam tanto opcionais como posicionais não são suportados."

#: ../../library/argparse.rst:2229
msgid ""
"The following example shows the difference between :meth:`~ArgumentParser."
"parse_known_args` and :meth:`~ArgumentParser.parse_intermixed_args`: the "
"former returns ``['2', '3']`` as unparsed arguments, while the latter "
"collects all the positionals into ``rest``.  ::"
msgstr ""
"O exemplo seguinte mostra a diferença entre :meth:`~ArgumentParser."
"parse_known_args` e :meth:`~ArgumentParser.parse_intermixed_args`: o "
"primeiro retorna ``['2', '3']`` como argumentos não analisados, enquanto o "
"último recolhe todos os posicionais em ``rest``. ::"

#: ../../library/argparse.rst:2235
msgid ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('cmd')\n"
">>> parser.add_argument('rest', nargs='*', type=int)\n"
">>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())\n"
"(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())\n"
"Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])"
msgstr ""
">>> parser = argparse.ArgumentParser()\n"
">>> parser.add_argument('--foo')\n"
">>> parser.add_argument('comando')\n"
">>> parser.add_argument('resto', nargs='*', type=int)\n"
">>> parser.parse_known_args('fazer 1 --foo bar 2 3'.split())\n"
"(Namespace(comando='fazer', foo='bar', resto=[1]), ['2', '3'])\n"
">>> parser.parse_intermixed_args('fazer 1 --foo bar 2 3'.split())\n"
"Namespace(comando='fazer', foo='bar', resto=[1, 2, 3])"

#: ../../library/argparse.rst:2244
msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple "
"containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` retorna um tuplo de dois "
"itens contendo o namespace preenchido e a lista de strings de argumentos "
"restantes. :meth:`~ArgumentParser.parse_intermixed_args` levanta um erro se "
"houver quaisquer strings de argumentos não analisados restantes."

#: ../../library/argparse.rst:2253
msgid "Registering custom types or actions"
msgstr "Registo de tipos ou ações personalizados"

#: ../../library/argparse.rst:2257
msgid ""
"Sometimes it's desirable to use a custom string in error messages to provide "
"more user-friendly output. In these cases, :meth:`!register` can be used to "
"register custom actions or types with a parser and allow you to reference "
"the type by their registered name instead of their callable name."
msgstr ""
"Às vezes, é desejável usar uma string personalizada em mensagens de erro "
"para fornecer uma saída mais amigável ao utilizador. Nestes casos, :meth:`!"
"register` pode ser usado para registar ações ou tipos personalizados com um "
"analisador e permitir-lhe referenciar o tipo pelo seu nome registado em vez "
"do seu nome chamável."

#: ../../library/argparse.rst:2262
msgid ""
"The :meth:`!register` method accepts three arguments - a *registry_name*, "
"specifying the internal registry where the object will be stored (e.g., "
"``action``, ``type``), *value*, which is the key under which the object will "
"be registered, and object, the callable to be registered."
msgstr ""
"O método :meth:`!register` aceita três argumentos — um *registry_name*, que "
"especifica o registo interno onde o objeto será armazenado (por exemplo, "
"``action``, ``type``), *value*, que é a chave sob a qual o objeto será "
"registado, e *object*, o objeto chamável a ser registado."

#: ../../library/argparse.rst:2267
msgid ""
"The following example shows how to register a custom type with a parser::"
msgstr ""
"O exemplo seguinte mostra como registar um tipo personalizado com um "
"analisador::"

#: ../../library/argparse.rst:2269
msgid ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='hexadecimal integer')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, "
"default=None, type='hexadecimal integer', choices=None, required=False, "
"help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"usage: PROG [-h] [--foo FOO]\n"
"PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'"
msgstr ""
">>> import argparse\n"
">>> parser = argparse.ArgumentParser()\n"
">>> parser.register('type', 'inteiro hexadecimal', lambda s: int(s, 16))\n"
">>> parser.add_argument('--foo', type='inteiro hexadecimal')\n"
"_StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, "
"default=None, type='inteiro hexadecimal', choices=None, required=False, "
"help=None, metavar=None, deprecated=False)\n"
">>> parser.parse_args(['--foo', '0xFA'])\n"
"Namespace(foo=250)\n"
">>> parser.parse_args(['--foo', '1.2'])\n"
"uso: PROG [-h] [--foo FOO]\n"
"PROG: erro: argumento --foo: valor 'inteiro hexadecimal' inválido: '1.2'"

#: ../../library/argparse.rst:2281
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/argparse.rst:2285
msgid "An error from creating or using an argument (optional or positional)."
msgstr "Um erro ao criar ou usar um argumento (opcional ou posicional)."

#: ../../library/argparse.rst:2287
msgid ""
"The string value of this exception is the message, augmented with "
"information about the argument that caused it."
msgstr ""
"O valor string desta exceção é a mensagem, aumentada com informações sobre o "
"argumento que a causou."

#: ../../library/argparse.rst:2292
msgid ""
"Raised when something goes wrong converting a command line string to a type."
msgstr ""
"Levantada quando algo corre mal ao converter uma string de linha de comandos "
"para um tipo."

#: ../../library/argparse.rst:2296
msgid "Guides and Tutorials"
msgstr "Guias e Tutoriais"

#: ../../library/argparse.rst:908
msgid "? (question mark)"
msgstr "? (ponto de interrogação)"

#: ../../library/argparse.rst:908 ../../library/argparse.rst:940
#: ../../library/argparse.rst:954
msgid "in argparse module"
msgstr "no módulo argparse"

#: ../../library/argparse.rst:940
msgid "* (asterisk)"
msgstr "* (asterisco)"

#: ../../library/argparse.rst:954
msgid "+ (plus)"
msgstr "+ (mais)"
