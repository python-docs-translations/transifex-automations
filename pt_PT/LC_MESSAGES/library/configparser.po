# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 15:16+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/configparser.rst:2
msgid ":mod:`!configparser` --- Configuration file parser"
msgstr ":mod:`!configparser` --- Analisador de ficheiros de configuração"

#: ../../library/configparser.rst:14
msgid "**Source code:** :source:`Lib/configparser.py`"
msgstr "**Código-fonte:** :source:`Lib/configparser.py`"

#: ../../library/configparser.rst:24
msgid ""
"This module provides the :class:`ConfigParser` class which implements a "
"basic configuration language which provides a structure similar to what's "
"found in Microsoft Windows INI files.  You can use this to write Python "
"programs which can be customized by end users easily."
msgstr ""
"Este módulo fornece a classe :class:`ConfigParser`, que implementa uma "
"linguagem básica de configuração que fornece uma estrutura semelhante à "
"encontrada nos ficheiros INI do Microsoft Windows. Pode usar isto para "
"escrever programas Python que podem ser facilmente personalizados pelos "
"utilizadores finais."

#: ../../library/configparser.rst:31
msgid ""
"This library does *not* interpret or write the value-type prefixes used in "
"the Windows Registry extended version of INI syntax."
msgstr ""
"Esta biblioteca *não* interpreta nem escreve os prefixos de tipo de valor "
"usados na versão estendida da sintaxe INI do Registo do Windows."

#: ../../library/configparser.rst:36
msgid "Module :mod:`tomllib`"
msgstr "Módulo :mod:`tomllib`"

#: ../../library/configparser.rst:37
msgid ""
"TOML is a well-specified format for application configuration files. It is "
"specifically designed to be an improved version of INI."
msgstr ""
"TOML é um formato bem especificado para ficheiros de configuração de "
"aplicações. Foi especificamente concebido para ser uma versão melhorada do "
"INI."

#: ../../library/configparser.rst:40
msgid "Module :mod:`shlex`"
msgstr "Módulo :mod:`shlex`"

#: ../../library/configparser.rst:41
msgid ""
"Support for creating Unix shell-like mini-languages which can also be used "
"for application configuration files."
msgstr ""
"Suporte para criar mini-linguagens semelhantes a shell Unix, que também "
"podem ser usadas para ficheiros de configuração de aplicações."

#: ../../library/configparser.rst:44
msgid "Module :mod:`json`"
msgstr "Módulo :mod:`json`"

#: ../../library/configparser.rst:45
msgid ""
"The ``json`` module implements a subset of JavaScript syntax which is "
"sometimes used for configuration, but does not support comments."
msgstr ""
"O módulo ``json`` implementa um subconjunto da sintaxe JavaScript que é, por "
"vezes, usado para configuração, mas não suporta comentários."

#: ../../library/configparser.rst:61
msgid "Quick Start"
msgstr "Início Rápido"

#: ../../library/configparser.rst:63
msgid "Let's take a very basic configuration file that looks like this:"
msgstr ""
"Vamos considerar um ficheiro de configuração muito básico que se parece com "
"isto:"

#: ../../library/configparser.rst:65
msgid ""
"[DEFAULT]\n"
"ServerAliveInterval = 45\n"
"Compression = yes\n"
"CompressionLevel = 9\n"
"ForwardX11 = yes\n"
"\n"
"[forge.example]\n"
"User = hg\n"
"\n"
"[topsecret.server.example]\n"
"Port = 50022\n"
"ForwardX11 = no"
msgstr ""
"[DEFAULT]\n"
"ServerAliveInterval = 45\n"
"Compression = yes\n"
"CompressionLevel = 9\n"
"ForwardX11 = yes\n"
"\n"
"[forge.example]\n"
"User = hg\n"
"\n"
"[topsecret.server.example]\n"
"Port = 50022\n"
"ForwardX11 = no"

#: ../../library/configparser.rst:80
msgid ""
"The structure of INI files is described `in the following section "
"<#supported-ini-file-structure>`_.  Essentially, the file consists of "
"sections, each of which contains keys with values. :mod:`configparser` "
"classes can read and write such files.  Let's start by creating the above "
"configuration file programmatically."
msgstr ""
"A estrutura dos ficheiros INI é descrita `na secção seguinte <#supported-ini-"
"file-structure>`_. Basicamente, o ficheiro consiste em secções, cada uma das "
"quais contém chaves com valores. As classes :mod:`configparser` podem ler e "
"escrever tais ficheiros. Vamos começar por criar o ficheiro de configuração "
"acima programaticamente."

#: ../../library/configparser.rst:86
msgid ""
">>> import configparser\n"
">>> config = configparser.ConfigParser()\n"
">>> config['DEFAULT'] = {'ServerAliveInterval': '45',\n"
"...                      'Compression': 'yes',\n"
"...                      'CompressionLevel': '9'}\n"
">>> config['forge.example'] = {}\n"
">>> config['forge.example']['User'] = 'hg'\n"
">>> config['topsecret.server.example'] = {}\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['Port'] = '50022'     # mutates the parser\n"
">>> topsecret['ForwardX11'] = 'no'  # same here\n"
">>> config['DEFAULT']['ForwardX11'] = 'yes'\n"
">>> with open('example.ini', 'w') as configfile:\n"
"...   config.write(configfile)\n"
"..."
msgstr ""
">>> import configparser\n"
">>> config = configparser.ConfigParser()\n"
">>> config['DEFAULT'] = {'ServerAliveInterval': '45',\n"
"...                      'Compression': 'yes',\n"
"...                      'CompressionLevel': '9'}\n"
">>> config['forge.example'] = {}\n"
">>> config['forge.example']['User'] = 'hg'\n"
">>> config['topsecret.server.example'] = {}\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['Port'] = '50022'     # modifica o analisador\n"
">>> topsecret['ForwardX11'] = 'no'  # o mesmo aqui\n"
">>> config['DEFAULT']['ForwardX11'] = 'yes'\n"
">>> with open('example.ini', 'w') as configfile:\n"
"...   config.write(configfile)\n"
"..."

#: ../../library/configparser.rst:104
msgid ""
"As you can see, we can treat a config parser much like a dictionary. There "
"are differences, `outlined later <#mapping-protocol-access>`_, but the "
"behavior is very close to what you would expect from a dictionary."
msgstr ""
"Como pode ver, podemos tratar um analisador de configuração muito como um "
"dicionário. Existem diferenças, `descritas mais tarde <#mapping-protocol-"
"access>`_, mas o comportamento é muito próximo do que esperaria de um "
"dicionário."

#: ../../library/configparser.rst:108
msgid ""
"Now that we have created and saved a configuration file, let's read it back "
"and explore the data it holds."
msgstr ""
"Ahora que criámos e guardámos um ficheiro de configuração, vamos lê-lo de "
"volta e explorar os dados que contém."

#: ../../library/configparser.rst:111
msgid ""
">>> config = configparser.ConfigParser()\n"
">>> config.sections()\n"
"[]\n"
">>> config.read('example.ini')\n"
"['example.ini']\n"
">>> config.sections()\n"
"['forge.example', 'topsecret.server.example']\n"
">>> 'forge.example' in config\n"
"True\n"
">>> 'python.org' in config\n"
"False\n"
">>> config['forge.example']['User']\n"
"'hg'\n"
">>> config['DEFAULT']['Compression']\n"
"'yes'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['ForwardX11']\n"
"'no'\n"
">>> topsecret['Port']\n"
"'50022'\n"
">>> for key in config['forge.example']:\n"
"...     print(key)\n"
"user\n"
"compressionlevel\n"
"serveraliveinterval\n"
"compression\n"
"forwardx11\n"
">>> config['forge.example']['ForwardX11']\n"
"'yes'"
msgstr ""
">>> config = configparser.ConfigParser()\n"
">>> config.sections()\n"
"[]\n"
">>> config.read('example.ini')\n"
"['example.ini']\n"
">>> config.sections()\n"
"['forge.example', 'topsecret.server.example']\n"
">>> 'forge.example' in config\n"
"True\n"
">>> 'python.org' in config\n"
"False\n"
">>> config['forge.example']['User']\n"
"'hg'\n"
">>> config['DEFAULT']['Compression']\n"
"'yes'\n"
">>> topsecret = config['topsecret.server.example']\n"
">>> topsecret['ForwardX11']\n"
"'no'\n"
">>> topsecret['Port']\n"
"'50022'\n"
">>> for key in config['forge.example']:\n"
"...     print(key)\n"
"user\n"
"compressionlevel\n"
"serveraliveinterval\n"
"compression\n"
"forwardx11\n"
">>> config['forge.example']['ForwardX11']\n"
"'yes'"

#: ../../library/configparser.rst:143
msgid ""
"As we can see above, the API is pretty straightforward.  The only bit of "
"magic involves the ``DEFAULT`` section which provides default values for all "
"other sections [1]_.  Note also that keys in sections are case-insensitive "
"and stored in lowercase [1]_."
msgstr ""
"Como podemos ver acima, a API é bastante simples. A única parte mágica "
"envolve a secção ``DEFAULT``, que fornece valores predefinidos para todas as "
"outras secções [1]_. Note também que as chaves nas secções não são sensíveis "
"a maiúsculas e minúsculas e são armazenadas em minúsculas [1]_."

#: ../../library/configparser.rst:148 ../../library/configparser.rst:967
msgid ""
"It is possible to read several configurations into a single :class:"
"`ConfigParser`, where the most recently added configuration has the highest "
"priority. Any conflicting keys are taken from the more recent configuration "
"while the previously existing keys are retained. The example below reads in "
"an ``override.ini`` file, which will override any conflicting keys from the "
"``example.ini`` file."
msgstr ""
"É possível ler várias configurações num único :class:`ConfigParser`, onde a "
"configuração mais recentemente adicionada tem a maior prioridade. Quaisquer "
"chaves conflitantes são obtidas da configuração mais recente, enquanto as "
"chaves previamente existentes são mantidas. O exemplo abaixo lê um ficheiro "
"``override.ini``, que substituirá quaisquer chaves conflitantes do ficheiro "
"``example.ini``."

#: ../../library/configparser.rst:155 ../../library/configparser.rst:974
msgid ""
"[DEFAULT]\n"
"ServerAliveInterval = -1"
msgstr ""
"[DEFAULT]\n"
"ServerAliveInterval = -1"

#: ../../library/configparser.rst:160 ../../library/configparser.rst:979
msgid ""
">>> config_override = configparser.ConfigParser()\n"
">>> config_override['DEFAULT'] = {'ServerAliveInterval': '-1'}\n"
">>> with open('override.ini', 'w') as configfile:\n"
"...     config_override.write(configfile)\n"
"...\n"
">>> config_override = configparser.ConfigParser()\n"
">>> config_override.read(['example.ini', 'override.ini'])\n"
"['example.ini', 'override.ini']\n"
">>> print(config_override.get('DEFAULT', 'ServerAliveInterval'))\n"
"-1"
msgstr ""
">>> config_override = configparser.ConfigParser()\n"
">>> config_override['DEFAULT'] = {'ServerAliveInterval': '-1'}\n"
">>> with open('override.ini', 'w') as configfile:\n"
"...     config_override.write(configfile)\n"
"...\n"
">>> config_override = configparser.ConfigParser()\n"
">>> config_override.read(['example.ini', 'override.ini'])\n"
"['example.ini', 'override.ini']\n"
">>> print(config_override.get('DEFAULT', 'ServerAliveInterval'))\n"
"-1"

#: ../../library/configparser.rst:174
msgid ""
"This behaviour is equivalent to a :meth:`ConfigParser.read` call with "
"several files passed to the *filenames* parameter."
msgstr ""
"Este comportamento é equivalente a uma chamada :meth:`ConfigParser.read` com "
"vários ficheiros passados ao parâmetro *filenames*."

#: ../../library/configparser.rst:179
msgid "Supported Datatypes"
msgstr "Tipos de Dados Suportados"

#: ../../library/configparser.rst:181
msgid ""
"Config parsers do not guess datatypes of values in configuration files, "
"always storing them internally as strings.  This means that if you need "
"other datatypes, you should convert on your own:"
msgstr ""
"Os analisadores de configuração não adivinham os tipos de dados dos valores "
"nos ficheiros de configuração, armazenando-os sempre internamente como "
"strings. Isto significa que, se precisar de outros tipos de dados, deve "
"convertê-los por si próprio:"

#: ../../library/configparser.rst:185
msgid ""
">>> int(topsecret['Port'])\n"
"50022\n"
">>> float(topsecret['CompressionLevel'])\n"
"9.0"
msgstr ""
">>> int(topsecret['Port'])\n"
"50022\n"
">>> float(topsecret['CompressionLevel'])\n"
"9.0"

#: ../../library/configparser.rst:192
msgid ""
"Since this task is so common, config parsers provide a range of handy getter "
"methods to handle integers, floats and booleans.  The last one is the most "
"interesting because simply passing the value to ``bool()`` would do no good "
"since ``bool('False')`` is still ``True``.  This is why config parsers also "
"provide :meth:`~ConfigParser.getboolean`.  This method is case-insensitive "
"and recognizes Boolean values from ``'yes'``/``'no'``, ``'on'``/``'off'``, "
"``'true'``/``'false'`` and ``'1'``/``'0'`` [1]_.  For example:"
msgstr ""
"Como esta tarefa é tão comum, os analisadores de configuração fornecem uma "
"série de métodos de obtenção úteis para lidar com inteiros, floats e "
"booleanos. O último é o mais interessante porque simplesmente passar o valor "
"para ``bool()`` não seria útil, uma vez que ``bool('False')`` ainda é "
"``True``. É por isso que os analisadores de configuração também fornecem :"
"meth:`~ConfigParser.getboolean`. Este método não é sensível a maiúsculas e "
"minúsculas e reconhece valores booleanos de ``'yes'``/``'no'``, ``'on'``/"
"``'off'``, ``'true'``/``'false'`` e ``'1'``/``'0'`` [1]_. Por exemplo:"

#: ../../library/configparser.rst:200
msgid ""
">>> topsecret.getboolean('ForwardX11')\n"
"False\n"
">>> config['forge.example'].getboolean('ForwardX11')\n"
"True\n"
">>> config.getboolean('forge.example', 'Compression')\n"
"True"
msgstr ""
">>> topsecret.getboolean('ForwardX11')\n"
"False\n"
">>> config['forge.example'].getboolean('ForwardX11')\n"
"True\n"
">>> config.getboolean('forge.example', 'Compression')\n"
"True"

#: ../../library/configparser.rst:209
msgid ""
"Apart from :meth:`~ConfigParser.getboolean`, config parsers also provide "
"equivalent :meth:`~ConfigParser.getint` and :meth:`~ConfigParser.getfloat` "
"methods.  You can register your own converters and customize the provided "
"ones. [1]_"
msgstr ""
"Além de :meth:`~ConfigParser.getboolean`, os analisadores de configuração "
"também fornecem métodos equivalentes :meth:`~ConfigParser.getint` e :meth:"
"`~ConfigParser.getfloat`. Pode registar os seus próprios conversores e "
"personalizar os fornecidos. [1]_"

#: ../../library/configparser.rst:215
msgid "Fallback Values"
msgstr "Valores de Recurso"

#: ../../library/configparser.rst:217
msgid ""
"As with a dictionary, you can use a section's :meth:`~ConfigParser.get` "
"method to provide fallback values:"
msgstr ""
"Como com um dicionário, pode usar o método :meth:`~ConfigParser.get` de uma "
"secção para fornecer valores de recurso:"

#: ../../library/configparser.rst:220
msgid ""
">>> topsecret.get('Port')\n"
"'50022'\n"
">>> topsecret.get('CompressionLevel')\n"
"'9'\n"
">>> topsecret.get('Cipher')\n"
">>> topsecret.get('Cipher', '3des-cbc')\n"
"'3des-cbc'"
msgstr ""
">>> topsecret.get('Port')\n"
"'50022'\n"
">>> topsecret.get('CompressionLevel')\n"
"'9'\n"
">>> topsecret.get('Cipher')\n"
">>> topsecret.get('Cipher', '3des-cbc')\n"
"'3des-cbc'"

#: ../../library/configparser.rst:230
msgid ""
"Please note that default values have precedence over fallback values. For "
"instance, in our example the ``'CompressionLevel'`` key was specified only "
"in the ``'DEFAULT'`` section.  If we try to get it from the section "
"``'topsecret.server.example'``, we will always get the default, even if we "
"specify a fallback:"
msgstr ""
"Note que os valores predefinidos têm precedência sobre os valores de "
"recurso. Por exemplo, no nosso exemplo, a chave ``'CompressionLevel'`` foi "
"especificada apenas na secção ``'DEFAULT'``. Se tentarmos obtê-la da secção "
"``'topsecret.server.example'``, sempre obteremos o valor predefinido, mesmo "
"que especifiquemos um valor de recurso:"

#: ../../library/configparser.rst:236
msgid ""
">>> topsecret.get('CompressionLevel', '3')\n"
"'9'"
msgstr ""
">>> topsecret.get('CompressionLevel', '3')\n"
"'9'"

#: ../../library/configparser.rst:241
msgid ""
"One more thing to be aware of is that the parser-level :meth:`~ConfigParser."
"get` method provides a custom, more complex interface, maintained for "
"backwards compatibility.  When using this method, a fallback value can be "
"provided via the ``fallback`` keyword-only argument:"
msgstr ""
"Mais uma coisa a ter em conta é que o método :meth:`~ConfigParser.get` ao "
"nível do analisador fornece uma interface personalizada e mais complexa, "
"mantida para compatibilidade retroativa. Ao usar este método, um valor de "
"recurso pode ser fornecido através do argumento ``fallback`` apenas por "
"palavra-chave:"

#: ../../library/configparser.rst:246
msgid ""
">>> config.get('forge.example', 'monster',\n"
"...            fallback='No such things as monsters')\n"
"'No such things as monsters'"
msgstr ""
">>> config.get('forge.example', 'monster',\n"
"...            fallback='Não existem coisas como monstros')\n"
"'Não existem coisas como monstros'"

#: ../../library/configparser.rst:252
msgid ""
"The same ``fallback`` argument can be used with the :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` and :meth:`~ConfigParser.getboolean` "
"methods, for example:"
msgstr ""
"O mesmo argumento ``fallback`` pode ser usado com os métodos :meth:"
"`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat` e :meth:"
"`~ConfigParser.getboolean`, por exemplo:"

#: ../../library/configparser.rst:256
msgid ""
">>> 'BatchMode' in topsecret\n"
"False\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"True\n"
">>> config['DEFAULT']['BatchMode'] = 'no'\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"False"
msgstr ""
">>> 'BatchMode' in topsecret\n"
"False\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"True\n"
">>> config['DEFAULT']['BatchMode'] = 'no'\n"
">>> topsecret.getboolean('BatchMode', fallback=True)\n"
"False"

#: ../../library/configparser.rst:268
msgid "Supported INI File Structure"
msgstr "Estrutura de Ficheiro INI Suportada"

#: ../../library/configparser.rst:270
msgid ""
"A configuration file consists of sections, each led by a ``[section]`` "
"header, followed by key/value entries separated by a specific string (``=`` "
"or ``:`` by default [1]_).  By default, section names are case sensitive but "
"keys are not [1]_.  Leading and trailing whitespace is removed from keys and "
"values. Values can be omitted if the parser is configured to allow it [1]_, "
"in which case the key/value delimiter may also be left out.  Values can also "
"span multiple lines, as long as they are indented deeper than the first line "
"of the value.  Depending on the parser's mode, blank lines may be treated as "
"parts of multiline values or ignored."
msgstr ""
"Um ficheiro de configuração consiste em secções, cada uma liderada por um "
"cabeçalho ``[section]``, seguido de entradas chave/valor separadas por uma "
"string específica (``=`` ou ``:`` por predefinição [1]_). Por predefinição, "
"os nomes das secções são sensíveis a maiúsculas e minúsculas, mas as chaves "
"não são [1]_. Os espaços em branco no início e no fim são removidos das "
"chaves e valores. Os valores podem ser omitidos se o analisador estiver "
"configurado para permitir [1]_, caso em que o delimitador chave/valor também "
"pode ser omitido. Os valores também podem abranger várias linhas, desde que "
"estejam indentados mais profundamente do que a primeira linha do valor. "
"Dependendo do modo do analisador, linhas em branco podem ser tratadas como "
"partes de valores multilinhas ou ignoradas."

#: ../../library/configparser.rst:280
msgid ""
"By default, a valid section name can be any string that does not contain '\\"
"\\n'. To change this, see :attr:`ConfigParser.SECTCRE`."
msgstr ""
"Por predefinição, um nome de secção válido pode ser qualquer string que não "
"contenha '\\\\n'. Para alterar isto, consulte :attr:`ConfigParser.SECTCRE`."

#: ../../library/configparser.rst:283
msgid ""
"Configuration files may include comments, prefixed by specific characters "
"(``#`` and ``;`` by default [1]_).  Comments may appear on their own on an "
"otherwise empty line, possibly indented. [1]_"
msgstr ""
"Os ficheiros de configuração podem incluir comentários, prefixados por "
"caracteres específicos (``#`` e ``;`` por predefinição [1]_). Os comentários "
"podem aparecer sozinhos numa linha, possivelmente indentados. [1]_"

#: ../../library/configparser.rst:287 ../../library/configparser.rst:350
msgid "For example:"
msgstr "Por exemplo:"

#: ../../library/configparser.rst:289
msgid ""
"[Simple Values]\n"
"key=value\n"
"spaces in keys=allowed\n"
"spaces in values=allowed as well\n"
"spaces around the delimiter = obviously\n"
"you can also use : to delimit keys from values\n"
"\n"
"[All Values Are Strings]\n"
"values like this: 1000000\n"
"or this: 3.14159265359\n"
"are they treated as numbers? : no\n"
"integers, floats and booleans are held as: strings\n"
"can use the API to get converted values directly: true\n"
"\n"
"[Multiline Values]\n"
"chorus: I'm a lumberjack, and I'm okay\n"
"    I sleep all night and I work all day\n"
"\n"
"[No Values]\n"
"key_without_value\n"
"empty string value here =\n"
"\n"
"[You can use comments]\n"
"# like this\n"
"; or this\n"
"\n"
"# By default only in an empty line.\n"
"# Inline comments can be harmful because they prevent users\n"
"# from using the delimiting characters as parts of values.\n"
"# That being said, this can be customized.\n"
"\n"
"    [Sections Can Be Indented]\n"
"        can_values_be_as_well = True\n"
"        does_that_mean_anything_special = False\n"
"        purpose = formatting for readability\n"
"        multiline_values = are\n"
"            handled just fine as\n"
"            long as they are indented\n"
"            deeper than the first line\n"
"            of a value\n"
"        # Did I mention we can indent comments, too?"
msgstr ""
"[Valores Simples]\n"
"chave=valor\n"
"espaços em chaves=permitidos\n"
"espaços em valores=também permitidos\n"
"espaços em redor do delimitador = óbvio\n"
"também pode usar : para delimitar chaves de valores\n"
"\n"
"[Todos os Valores São Strings]\n"
"valores como este: 1000000\n"
"ou este: 3.14159265359\n"
"são tratados como números? : não\n"
"inteiros, floats e booleanos são mantidos como: strings\n"
"pode usar a API para obter valores convertidos diretamente: true\n"
"\n"
"[Valores Multilinha]\n"
"refrão: Sou um lenhador, e estou bem\n"
"    Durmo toda a noite e trabalho todo o dia\n"
"\n"
"[Sem Valores]\n"
"chave_sem_valor\n"
"valor de string vazio aqui =\n"
"\n"
"[Pode Usar Comentários]\n"
"# como este\n"
"; ou este\n"
"\n"
"# Por predefinição apenas numa linha vazia.\n"
"# Comentários em linha podem ser prejudiciais porque impedem os "
"utilizadores\n"
"# de usar os caracteres delimitadores como partes de valores.\n"
"# Dito isto, isto pode ser personalizado.\n"
"\n"
"    [As Secções Podem Ser Indentadas]\n"
"        os_valores_também_podem_ser = True\n"
"        isso_significa_algo_especial = False\n"
"        propósito = formatação para legibilidade\n"
"        valores_multilinha = são\n"
"            tratados muito bem desde que\n"
"            estejam indentados\n"
"            mais profundamente do que a primeira linha\n"
"            de um valor\n"
"        # Já mencionei que também podemos indentar comentários?"

#: ../../library/configparser.rst:335
msgid "Interpolation of values"
msgstr "Interpolation de Valores"

#: ../../library/configparser.rst:337
msgid ""
"On top of the core functionality, :class:`ConfigParser` supports "
"interpolation.  This means values can be preprocessed before returning them "
"from ``get()`` calls."
msgstr ""
"Além da funcionalidade principal, :class:`ConfigParser` suporta "
"interpolação. Isto significa que os valores podem ser pré-processados antes "
"de serem retornados de chamadas ``get()``."

#: ../../library/configparser.rst:345
msgid ""
"The default implementation used by :class:`ConfigParser`.  It enables values "
"to contain format strings which refer to other values in the same section, "
"or values in the special default section [1]_.  Additional default values "
"can be provided on initialization."
msgstr ""
"A implementação predefinida usada por :class:`ConfigParser`. Permite que os "
"valores contenham strings de formato que se referem a outros valores na "
"mesma secção, ou valores na secção especial predefinida [1]_. Valores "
"predefinidos adicionais podem ser fornecidos na inicialização."

#: ../../library/configparser.rst:352
msgid ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: %(home_dir)s/lumberjack\n"
"my_pictures: %(my_dir)s/Pictures\n"
"\n"
"[Escape]\n"
"# use a %% to escape the % sign (% is the only character that needs to be "
"escaped):\n"
"gain: 80%%"
msgstr ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: %(home_dir)s/lumberjack\n"
"my_pictures: %(my_dir)s/Pictures\n"
"\n"
"[Escape]\n"
"# use %% para escapar o sinal % (% é o único caráter que precisa de ser "
"escapado):\n"
"gain: 80%%"

#: ../../library/configparser.rst:363
msgid ""
"In the example above, :class:`ConfigParser` with *interpolation* set to "
"``BasicInterpolation()`` would resolve ``%(home_dir)s`` to the value of "
"``home_dir`` (``/Users`` in this case).  ``%(my_dir)s`` in effect would "
"resolve to ``/Users/lumberjack``.  All interpolations are done on demand so "
"keys used in the chain of references do not have to be specified in any "
"specific order in the configuration file."
msgstr ""
"No exemplo acima, :class:`ConfigParser` com *interpolação* definida para "
"``BasicInterpolation()`` resolveria ``%(home_dir)s`` para o valor de "
"``home_dir`` (``/Users`` neste caso). ``%(my_dir)s``, na prática, resolveria "
"para ``/Users/lumberjack``. Todas as interpolações são feitas sob demanda, "
"por isso as chaves usadas na cadeia de referências não precisam de ser "
"especificadas em nenhuma ordem específica no ficheiro de configuração."

#: ../../library/configparser.rst:370
msgid ""
"With ``interpolation`` set to ``None``, the parser would simply return "
"``%(my_dir)s/Pictures`` as the value of ``my_pictures`` and ``%(home_dir)s/"
"lumberjack`` as the value of ``my_dir``."
msgstr ""
"Com ``interpolation`` definido como ``None``, o analisador simplesmente "
"retornaria ``%(my_dir)s/Pictures`` como o valor de ``my_pictures`` e "
"``%(home_dir)s/lumberjack`` como o valor de ``my_dir``."

#: ../../library/configparser.rst:378
msgid ""
"An alternative handler for interpolation which implements a more advanced "
"syntax, used for instance in ``zc.buildout``.  Extended interpolation is "
"using ``${section:option}`` to denote a value from a foreign section. "
"Interpolation can span multiple levels.  For convenience, if the ``section:"
"`` part is omitted, interpolation defaults to the current section (and "
"possibly the default values from the special section)."
msgstr ""
"Um manipulador alternativo para interpolação que implementa uma sintaxe mais "
"avançada, usada, por exemplo, em ``zc.buildout``. A interpolação estendida "
"usa ``${section:option}`` para denotar um valor de uma secção externa. A "
"interpolação pode abranger vários níveis. Por conveniência, se a parte "
"``section:`` for omitida, a interpolação predefine para a secção atual (e "
"possivelmente os valores predefinidos da secção especial)."

#: ../../library/configparser.rst:385
msgid ""
"For example, the configuration specified above with basic interpolation, "
"would look like this with extended interpolation:"
msgstr ""
"Por exemplo, a configuração especificada acima com interpolação básica "
"ficaria assim com interpolação estendida:"

#: ../../library/configparser.rst:388
msgid ""
"[Paths]\n"
"home_dir: /Users\n"
"my_dir: ${home_dir}/lumberjack\n"
"my_pictures: ${my_dir}/Pictures\n"
"\n"
"[Escape]\n"
"# use a $$ to escape the $ sign ($ is the only character that needs to be "
"escaped):\n"
"cost: $$80"
msgstr ""

#: ../../library/configparser.rst:399
msgid "Values from other sections can be fetched as well:"
msgstr "Valores de outras secções também podem ser obtidos:"

#: ../../library/configparser.rst:401
msgid ""
"[Common]\n"
"home_dir: /Users\n"
"library_dir: /Library\n"
"system_dir: /System\n"
"macports_dir: /opt/local\n"
"\n"
"[Frameworks]\n"
"Python: 3.2\n"
"path: ${Common:system_dir}/Library/Frameworks/\n"
"\n"
"[Arthur]\n"
"nickname: Two Sheds\n"
"last_name: Jackson\n"
"my_dir: ${Common:home_dir}/twosheds\n"
"my_pictures: ${my_dir}/Pictures\n"
"python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}"
msgstr ""

#: ../../library/configparser.rst:421
msgid "Mapping Protocol Access"
msgstr "Acesso ao Protocolo de Mapeamento"

#: ../../library/configparser.rst:425
msgid ""
"Mapping protocol access is a generic name for functionality that enables "
"using custom objects as if they were dictionaries.  In case of :mod:"
"`configparser`, the mapping interface implementation is using the "
"``parser['section']['option']`` notation."
msgstr ""
"O acesso ao protocolo de mapeamento é um nome genérico para a funcionalidade "
"que permite usar objetos personalizados como se fossem dicionários. No caso "
"de :mod:`configparser`, a implementação da interface de mapeamento usa a "
"notação ``parser['section']['option']``."

#: ../../library/configparser.rst:430
msgid ""
"``parser['section']`` in particular returns a proxy for the section's data "
"in the parser.  This means that the values are not copied but they are taken "
"from the original parser on demand.  What's even more important is that when "
"values are changed on a section proxy, they are actually mutated in the "
"original parser."
msgstr ""
"``parser['section']``, em particular, retorna um proxy para os dados da "
"secção no analisador. Isto significa que os valores não são copiados, mas "
"são obtidos do analisador original sob demanda. O que é ainda mais "
"importante é que, quando os valores são alterados num proxy de secção, eles "
"são realmente modificados no analisador original."

#: ../../library/configparser.rst:436
msgid ""
":mod:`configparser` objects behave as close to actual dictionaries as "
"possible. The mapping interface is complete and adheres to the :class:"
"`~collections.abc.MutableMapping` ABC. However, there are a few differences "
"that should be taken into account:"
msgstr ""
"Os objetos :mod:`configparser` comportam-se o mais próximo possível de "
"dicionários reais. A interface de mapeamento é completa e aderente à :class:"
"`~collections.abc.MutableMapping` ABC. No entanto, existem algumas "
"diferenças que devem ser tidas em conta:"

#: ../../library/configparser.rst:441
msgid ""
"By default, all keys in sections are accessible in a case-insensitive manner "
"[1]_.  E.g. ``for option in parser[\"section\"]`` yields only "
"``optionxform``'ed option key names.  This means lowercased keys by "
"default.  At the same time, for a section that holds the key ``'a'``, both "
"expressions return ``True``::"
msgstr ""
"Por predefinição, todas as chaves nas secções são acessíveis de forma não "
"sensível a maiúsculas e minúsculas [1]_. Por exemplo, ``for option in "
"parser[\"section\"]`` produz apenas nomes de chaves de opção transformados "
"por ``optionxform``. Isto significa chaves em minúsculas por predefinição. "
"Ao mesmo tempo, para uma secção que contém a chave ``'a'``, ambas as "
"expressões retornam ``True``::"

#: ../../library/configparser.rst:446
msgid ""
"\"a\" in parser[\"section\"]\n"
"\"A\" in parser[\"section\"]"
msgstr ""
"\"a\" in parser[\"section\"]\n"
"\"A\" in parser[\"section\"]"

#: ../../library/configparser.rst:449
msgid ""
"All sections include ``DEFAULTSECT`` values as well which means that ``."
"clear()`` on a section may not leave the section visibly empty.  This is "
"because default values cannot be deleted from the section (because "
"technically they are not there).  If they are overridden in the section, "
"deleting causes the default value to be visible again.  Trying to delete a "
"default value causes a :exc:`KeyError`."
msgstr ""
"Todas as secções incluem também valores ``DEFAULTSECT``, o que significa que "
"``.clear()`` numa secção pode não deixar a secção visivelmente vazia. Isto "
"porque os valores predefinidos não podem ser eliminados da secção (porque, "
"tecnicamente, não estão lá). Se forem substituídos na secção, a eliminação "
"faz com que o valor predefinido volte a estar visível. Tentar eliminar um "
"valor predefinido causa um :exc:`KeyError`."

#: ../../library/configparser.rst:456
msgid "``DEFAULTSECT`` cannot be removed from the parser:"
msgstr "``DEFAULTSECT`` não pode ser removido do analisador:"

#: ../../library/configparser.rst:458
msgid "trying to delete it raises :exc:`ValueError`,"
msgstr "tentar eliminá-lo levanta :exc:`ValueError`,"

#: ../../library/configparser.rst:460
msgid "``parser.clear()`` leaves it intact,"
msgstr "``parser.clear()`` deixa-o intacto,"

#: ../../library/configparser.rst:462
msgid "``parser.popitem()`` never returns it."
msgstr "``parser.popitem()`` nunca o retorna."

#: ../../library/configparser.rst:464
msgid ""
"``parser.get(section, option, **kwargs)`` - the second argument is **not** a "
"fallback value.  Note however that the section-level ``get()`` methods are "
"compatible both with the mapping protocol and the classic configparser API."
msgstr ""
"``parser.get(section, option, **kwargs)`` - o segundo argumento **não** é um "
"valor de recurso. Note, no entanto, que os métodos ``get()`` ao nível da "
"secção são compatíveis tanto com o protocolo de mapeamento como com a API "
"clássica do configparser."

#: ../../library/configparser.rst:468
msgid ""
"``parser.items()`` is compatible with the mapping protocol (returns a list "
"of *section_name*, *section_proxy* pairs including the DEFAULTSECT).  "
"However, this method can also be invoked with arguments: ``parser."
"items(section, raw, vars)``.  The latter call returns a list of *option*, "
"*value* pairs for a specified ``section``, with all interpolations expanded "
"(unless ``raw=True`` is provided)."
msgstr ""
"``parser.items()`` é compatível com o protocolo de mapeamento (retorna uma "
"lista de pares *section_name*, *section_proxy*, incluindo DEFAULTSECT). No "
"entanto, este método também pode ser invocado com argumentos: ``parser."
"items(section, raw, vars)``. A última chamada retorna uma lista de pares "
"*option*, *value* para uma ``section`` especificada, com todas as "
"interpolações expandidas (a menos que ``raw=True`` seja fornecido)."

#: ../../library/configparser.rst:475
msgid ""
"The mapping protocol is implemented on top of the existing legacy API so "
"that subclasses overriding the original interface still should have mappings "
"working as expected."
msgstr ""
"O protocolo de mapeamento é implementado sobre a API legada existente, de "
"modo que subclasses que substituem a interface original ainda devem ter "
"mapeamentos a funcionar como esperado."

#: ../../library/configparser.rst:481
msgid "Customizing Parser Behaviour"
msgstr "Personalizar o Comportamento do Analisador"

#: ../../library/configparser.rst:483
msgid ""
"There are nearly as many INI format variants as there are applications using "
"it. :mod:`configparser` goes a long way to provide support for the largest "
"sensible set of INI styles available.  The default functionality is mainly "
"dictated by historical background and it's very likely that you will want to "
"customize some of the features."
msgstr ""
"Existem quase tantos variantes do formato INI quanto aplicações que o usam. :"
"mod:`configparser` faz um grande esforço para fornecer suporte para o maior "
"conjunto sensato de estilos INI disponíveis. A funcionalidade predefinida é "
"principalmente ditada pelo histórico e é muito provável que queira "
"personalizar algumas das funcionalidades."

#: ../../library/configparser.rst:489
msgid ""
"The most common way to change the way a specific config parser works is to "
"use the :meth:`!__init__` options:"
msgstr ""
"A forma mais comum de alterar a forma como um analisador de configuração "
"específico funciona é usar as opções :meth:`!__init__`:"

#: ../../library/configparser.rst:492
msgid "*defaults*, default value: ``None``"
msgstr "*defaults*, valor predefinido: ``None``"

#: ../../library/configparser.rst:494
msgid ""
"This option accepts a dictionary of key-value pairs which will be initially "
"put in the ``DEFAULT`` section.  This makes for an elegant way to support "
"concise configuration files that don't specify values which are the same as "
"the documented default."
msgstr ""
"Esta opção aceita um dicionário de pares chave-valor que serão inicialmente "
"colocados na secção ``DEFAULT``. Isto torna-se uma forma elegante de "
"suportar ficheiros de configuração concisos que não especificam valores que "
"são iguais ao predefinido documentado."

#: ../../library/configparser.rst:499
msgid ""
"Hint: if you want to specify default values for a specific section, use :"
"meth:`~ConfigParser.read_dict` before you read the actual file."
msgstr ""
"Dica: se quiser especificar valores predefinidos para uma secção específica, "
"use :meth:`~ConfigParser.read_dict` antes de ler o ficheiro real."

#: ../../library/configparser.rst:502
msgid "*dict_type*, default value: :class:`dict`"
msgstr "*dict_type*, valor predefinido: :class:`dict`"

#: ../../library/configparser.rst:504
msgid ""
"This option has a major impact on how the mapping protocol will behave and "
"how the written configuration files look.  With the standard dictionary, "
"every section is stored in the order they were added to the parser.  Same "
"goes for options within sections."
msgstr ""
"Esta opção tem um grande impacto em como o protocolo de mapeamento se "
"comportará e como os ficheiros de configuração escritos parecerão. Com o "
"dicionário padrão, cada secção é armazenada na ordem em que foram "
"adicionadas ao analisador. O mesmo acontece com as opções dentro das secções."

#: ../../library/configparser.rst:509
msgid ""
"An alternative dictionary type can be used for example to sort sections and "
"options on write-back."
msgstr ""
"Um tipo de dicionário alternativo pode ser usado, por exemplo, para ordenar "
"secções e opções na escrita de volta."

#: ../../library/configparser.rst:512
msgid ""
"Please note: there are ways to add a set of key-value pairs in a single "
"operation.  When you use a regular dictionary in those operations, the order "
"of the keys will be ordered.  For example:"
msgstr ""
"Note que: existem formas de adicionar um conjunto de pares chave-valor numa "
"única operação. Quando usa um dicionário regular nessas operações, a ordem "
"das chaves será ordenada. Por exemplo:"

#: ../../library/configparser.rst:516
msgid ""
">>> parser = configparser.ConfigParser()\n"
">>> parser.read_dict({'section1': {'key1': 'value1',\n"
"...                                'key2': 'value2',\n"
"...                                'key3': 'value3'},\n"
"...                   'section2': {'keyA': 'valueA',\n"
"...                                'keyB': 'valueB',\n"
"...                                'keyC': 'valueC'},\n"
"...                   'section3': {'foo': 'x',\n"
"...                                'bar': 'y',\n"
"...                                'baz': 'z'}\n"
"... })\n"
">>> parser.sections()\n"
"['section1', 'section2', 'section3']\n"
">>> [option for option in parser['section3']]\n"
"['foo', 'bar', 'baz']"
msgstr ""
">>> parser = configparser.ConfigParser()\n"
">>> parser.read_dict({'section1': {'key1': 'value1',\n"
"...                                'key2': 'value2',\n"
"...                                'key3': 'value3'},\n"
"...                   'section2': {'keyA': 'valueA',\n"
"...                                'keyB': 'valueB',\n"
"...                                'keyC': 'valueC'},\n"
"...                   'section3': {'foo': 'x',\n"
"...                                'bar': 'y',\n"
"...                                'baz': 'z'}\n"
"... })\n"
">>> parser.sections()\n"
"['section1', 'section2', 'section3']\n"
">>> [option for option in parser['section3']]\n"
"['foo', 'bar', 'baz']"

#: ../../library/configparser.rst:534
msgid "*allow_no_value*, default value: ``False``"
msgstr "*allow_no_value*, valor predefinido: ``False``"

#: ../../library/configparser.rst:536
msgid ""
"Some configuration files are known to include settings without values, but "
"which otherwise conform to the syntax supported by :mod:`configparser`.  The "
"*allow_no_value* parameter to the constructor can be used to indicate that "
"such values should be accepted:"
msgstr ""
"Alguns ficheiros de configuração incluem definições sem valores, mas que, de "
"outra forma, estão em conformidade com a sintaxe suportada por :mod:"
"`configparser`. O parâmetro *allow_no_value* para o construtor pode ser "
"usado para indicar que tais valores devem ser aceites:"

#: ../../library/configparser.rst:541
msgid ""
">>> import configparser\n"
"\n"
">>> sample_config = \"\"\"\n"
"... [mysqld]\n"
"...   user = mysql\n"
"...   pid-file = /var/run/mysqld/mysqld.pid\n"
"...   skip-external-locking\n"
"...   old_passwords = 1\n"
"...   skip-bdb\n"
"...   # we don't need ACID today\n"
"...   skip-innodb\n"
"... \"\"\"\n"
">>> config = configparser.ConfigParser(allow_no_value=True)\n"
">>> config.read_string(sample_config)\n"
"\n"
">>> # Settings with values are treated as before:\n"
">>> config[\"mysqld\"][\"user\"]\n"
"'mysql'\n"
"\n"
">>> # Settings without values provide None:\n"
">>> config[\"mysqld\"][\"skip-bdb\"]\n"
"\n"
">>> # Settings which aren't specified still raise an error:\n"
">>> config[\"mysqld\"][\"does-not-exist\"]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'does-not-exist'"
msgstr ""
">>> import configparser\n"
"\n"
">>> sample_config = \"\"\"\n"
"... [mysqld]\n"
"...   user = mysql\n"
"...   pid-file = /var/run/mysqld/mysqld.pid\n"
"...   skip-external-locking\n"
"...   old_passwords = 1\n"
"...   skip-bdb\n"
"...   # não precisamos de ACID hoje\n"
"...   skip-innodb\n"
"... \"\"\"\n"
">>> config = configparser.ConfigParser(allow_no_value=True)\n"
">>> config.read_string(sample_config)\n"
"\n"
">>> # Definições com valores são tratadas como antes:\n"
">>> config[\"mysqld\"][\"user\"]\n"
"'mysql'\n"
"\n"
">>> # Definições sem valores fornecem None:\n"
">>> config[\"mysqld\"][\"skip-bdb\"]\n"
"\n"
">>> # Definições que não estão especificadas ainda levantam um erro:\n"
">>> config[\"mysqld\"][\"does-not-exist\"]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'does-not-exist'"

#: ../../library/configparser.rst:571
msgid "*delimiters*, default value: ``('=', ':')``"
msgstr "*delimiters*, valor predefinido: ``('=', ':')``"

#: ../../library/configparser.rst:573
msgid ""
"Delimiters are substrings that delimit keys from values within a section. "
"The first occurrence of a delimiting substring on a line is considered a "
"delimiter.  This means values (but not keys) can contain the delimiters."
msgstr ""
"Os delimitadores são substrings que delimitam chaves de valores dentro de "
"uma secção. A primeira ocorrência de uma substring delimitadora numa linha é "
"considerada um delimitador. Isto significa que os valores (mas não as "
"chaves) podem conter os delimitadores."

#: ../../library/configparser.rst:577
msgid ""
"See also the *space_around_delimiters* argument to :meth:`ConfigParser."
"write`."
msgstr ""
"Veja também o argumento *space_around_delimiters* para :meth:`ConfigParser."
"write`."

#: ../../library/configparser.rst:580
msgid "*comment_prefixes*, default value: ``('#', ';')``"
msgstr "*comment_prefixes*, valor predefinido: ``('#', ';')``"

#: ../../library/configparser.rst:582
msgid "*inline_comment_prefixes*, default value: ``None``"
msgstr "*inline_comment_prefixes*, valor predefinido: ``None``"

#: ../../library/configparser.rst:584
msgid ""
"Comment prefixes are strings that indicate the start of a valid comment "
"within a config file. *comment_prefixes* are used only on otherwise empty "
"lines (optionally indented) whereas *inline_comment_prefixes* can be used "
"after every valid value (e.g. section names, options and empty lines as "
"well).  By default inline comments are disabled and ``'#'`` and ``';'`` are "
"used as prefixes for whole line comments."
msgstr ""
"Os prefixos de comentário são strings que indicam o início de um comentário "
"válido dentro de um ficheiro de configuração. *comment_prefixes* são usados "
"apenas em linhas vazias (opcionalmente indentadas), enquanto "
"*inline_comment_prefixes* podem ser usados após cada valor válido (por "
"exemplo, nomes de secções, opções e linhas vazias também). Por predefinição, "
"os comentários em linha estão desativados e ``'#'`` e ``';'`` são usados "
"como prefixos para comentários de linha inteira."

#: ../../library/configparser.rst:591
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``comment_prefixes=('#',';')`` and ``inline_comment_prefixes=(';',)``."
msgstr ""
"Em versões anteriores de :mod:`configparser`, o comportamento correspondia a "
"``comment_prefixes=('#',';')`` e ``inline_comment_prefixes=(';',)``."

#: ../../library/configparser.rst:595
msgid ""
"Please note that config parsers don't support escaping of comment prefixes "
"so using *inline_comment_prefixes* may prevent users from specifying option "
"values with characters used as comment prefixes.  When in doubt, avoid "
"setting *inline_comment_prefixes*.  In any circumstances, the only way of "
"storing comment prefix characters at the beginning of a line in multiline "
"values is to interpolate the prefix, for example::"
msgstr ""
"Note que os analisadores de configuração não suportam o escape de prefixos "
"de comentário, por isso usar *inline_comment_prefixes* pode impedir os "
"utilizadores de especificar valores de opção com caracteres usados como "
"prefixos de comentário. Em caso de dúvida, evite definir "
"*inline_comment_prefixes*. Em qualquer circunstância, a única forma de "
"armazenar caracteres de prefixo de comentário no início de uma linha em "
"valores multilinhas é interpolá-los, por exemplo::"

#: ../../library/configparser.rst:602
msgid ""
">>> from configparser import ConfigParser, ExtendedInterpolation\n"
">>> parser = ConfigParser(interpolation=ExtendedInterpolation())\n"
">>> # the default BasicInterpolation could be used as well\n"
">>> parser.read_string(\"\"\"\n"
"... [DEFAULT]\n"
"... hash = #\n"
"...\n"
"... [hashes]\n"
"... shebang =\n"
"...   ${hash}!/usr/bin/env python\n"
"...   ${hash} -*- coding: utf-8 -*-\n"
"...\n"
"... extensions =\n"
"...   enabled_extension\n"
"...   another_extension\n"
"...   #disabled_by_comment\n"
"...   yet_another_extension\n"
"...\n"
"... interpolation not necessary = if # is not at line start\n"
"... even in multiline values = line #1\n"
"...   line #2\n"
"...   line #3\n"
"... \"\"\")\n"
">>> print(parser['hashes']['shebang'])\n"
"\n"
"#!/usr/bin/env python\n"
"# -*- coding: utf-8 -*-\n"
">>> print(parser['hashes']['extensions'])\n"
"\n"
"enabled_extension\n"
"another_extension\n"
"yet_another_extension\n"
">>> print(parser['hashes']['interpolation not necessary'])\n"
"if # is not at line start\n"
">>> print(parser['hashes']['even in multiline values'])\n"
"line #1\n"
"line #2\n"
"line #3"
msgstr ""

#: ../../library/configparser.rst:641
msgid "*strict*, default value: ``True``"
msgstr "*strict*, valor predefinido: ``True``"

#: ../../library/configparser.rst:643
msgid ""
"When set to ``True``, the parser will not allow for any section or option "
"duplicates while reading from a single source (using :meth:`~ConfigParser."
"read_file`, :meth:`~ConfigParser.read_string` or :meth:`~ConfigParser."
"read_dict`).  It is recommended to use strict parsers in new applications."
msgstr ""
"Quando definido como ``True``, o analisador não permitirá quaisquer "
"duplicados de secções ou opções ao ler de uma única fonte (usando :meth:"
"`~ConfigParser.read_file`, :meth:`~ConfigParser.read_string` ou :meth:"
"`~ConfigParser.read_dict`). É recomendado usar analisadores estritos em "
"novas aplicações."

#: ../../library/configparser.rst:648
msgid ""
"In previous versions of :mod:`configparser` behaviour matched "
"``strict=False``."
msgstr ""
"Em versões anteriores de :mod:`configparser`, o comportamento correspondia a "
"``strict=False``."

#: ../../library/configparser.rst:652
msgid "*empty_lines_in_values*, default value: ``True``"
msgstr "*empty_lines_in_values*, valor predefinido: ``True``"

#: ../../library/configparser.rst:654
msgid ""
"In config parsers, values can span multiple lines as long as they are "
"indented more than the key that holds them.  By default parsers also let "
"empty lines to be parts of values.  At the same time, keys can be "
"arbitrarily indented themselves to improve readability.  In consequence, "
"when configuration files get big and complex, it is easy for the user to "
"lose track of the file structure.  Take for instance:"
msgstr ""
"Nos analisadores de configuração, os valores podem abranger várias linhas, "
"desde que estejam indentados mais do que a chave que os contém. Por "
"predefinição, os analisadores também permitem que linhas vazias façam parte "
"dos valores. Ao mesmo tempo, as chaves podem ser indentadas arbitrariamente "
"para melhorar a legibilidade. Em consequência, quando os ficheiros de "
"configuração se tornam grandes e complexos, é fácil para o utilizador perder "
"a noção da estrutura do ficheiro. Tome como exemplo:"

#: ../../library/configparser.rst:661
msgid ""
"[Section]\n"
"key = multiline\n"
"  value with a gotcha\n"
"\n"
" this = is still a part of the multiline value of 'key'"
msgstr ""
"[Section]\n"
"key = multiline\n"
"  valor com uma armadilha\n"
"\n"
" this = ainda faz parte do valor multilinhas de 'key'"

#: ../../library/configparser.rst:669
msgid ""
"This can be especially problematic for the user to see if she's using a "
"proportional font to edit the file.  That is why when your application does "
"not need values with empty lines, you should consider disallowing them.  "
"This will make empty lines split keys every time.  In the example above, it "
"would produce two keys, ``key`` and ``this``."
msgstr ""
"Isto pode ser especialmente problemático para o utilizador ver se estiver a "
"usar uma fonte proporcional para editar o ficheiro. É por isso que, quando a "
"sua aplicação não precisa de valores com linhas vazias, deve considerar não "
"os permitir. Isto fará com que as linhas vazias separem as chaves todas as "
"vezes. No exemplo acima, produziria duas chaves, ``key`` e ``this``."

#: ../../library/configparser.rst:675
msgid ""
"*default_section*, default value: ``configparser.DEFAULTSECT`` (that is: "
"``\"DEFAULT\"``)"
msgstr ""
"*default_section*, valor predefinido: ``configparser.DEFAULTSECT`` (ou seja: "
"``\"DEFAULT\"``)"

#: ../../library/configparser.rst:678
msgid ""
"The convention of allowing a special section of default values for other "
"sections or interpolation purposes is a powerful concept of this library, "
"letting users create complex declarative configurations.  This section is "
"normally called ``\"DEFAULT\"`` but this can be customized to point to any "
"other valid section name.  Some typical values include: ``\"general\"`` or "
"``\"common\"``.  The name provided is used for recognizing default sections "
"when reading from any source and is used when writing configuration back to "
"a file.  Its current value can be retrieved using the ``parser_instance."
"default_section`` attribute and may be modified at runtime (i.e. to convert "
"files from one format to another)."
msgstr ""
"A convenção de permitir uma secção especial de valores predefinidos para "
"outras secções ou para fins de interpolação é um conceito poderoso desta "
"biblioteca, permitindo que os utilizadores criem configurações declarativas "
"complexas. Esta secção é normalmente chamada ``\"DEFAULT\"``, mas isto pode "
"ser personalizado para apontar para qualquer outro nome de secção válido. "
"Alguns valores típicos incluem: ``\"general\"`` ou ``\"common\"``. O nome "
"fornecido é usado para reconhecer secções predefinidas ao ler de qualquer "
"fonte e é usado ao escrever a configuração de volta para um ficheiro. O seu "
"valor atual pode ser recuperado usando o atributo ``parser_instance."
"default_section`` e pode ser modificado em tempo de execução (por exemplo, "
"para converter ficheiros de um formato para outro)."

#: ../../library/configparser.rst:689
msgid "*interpolation*, default value: ``configparser.BasicInterpolation``"
msgstr ""
"*interpolation*, valor predefinido: ``configparser.BasicInterpolation``"

#: ../../library/configparser.rst:691
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_. :class:"
"`RawConfigParser` has a default value of ``None``."
msgstr ""
"O comportamento de interpolação pode ser personalizado fornecendo um "
"manipulador personalizado através do argumento *interpolation*. ``None`` "
"pode ser usado para desligar completamente a interpolação, "
"``ExtendedInterpolation()`` fornece uma variante mais avançada inspirada em "
"``zc.buildout``. Mais sobre o assunto na `secção de documentação dedicada "
"<#interpolation-of-values>`_. :class:`RawConfigParser` tem um valor "
"predefinido de ``None``."

#: ../../library/configparser.rst:698
msgid "*converters*, default value: not set"
msgstr "*converters*, valor predefinido: não definido"

#: ../../library/configparser.rst:700
msgid ""
"Config parsers provide option value getters that perform type conversion.  "
"By default :meth:`~ConfigParser.getint`, :meth:`~ConfigParser.getfloat`, "
"and :meth:`~ConfigParser.getboolean` are implemented.  Should other getters "
"be desirable, users may define them in a subclass or pass a dictionary where "
"each key is a name of the converter and each value is a callable "
"implementing said conversion.  For instance, passing ``{'decimal': decimal."
"Decimal}`` would add :meth:`!getdecimal` on both the parser object and all "
"section proxies.  In other words, it will be possible to write both "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` and "
"``parser_instance['section'].getdecimal('key', 0)``."
msgstr ""
"Os analisadores de configuração fornecem métodos de obtenção de valores de "
"opção que realizam conversão de tipo. Por predefinição, :meth:`~ConfigParser."
"getint`, :meth:`~ConfigParser.getfloat` e :meth:`~ConfigParser.getboolean` "
"são implementados. Se outros métodos de obtenção forem desejáveis, os "
"utilizadores podem defini-los numa subclasse ou passar um dicionário onde "
"cada chave é um nome do conversor e cada valor é um objeto invocável que "
"implementa a conversão. Por exemplo, passar ``{'decimal': decimal.Decimal}`` "
"adicionaria :meth:`!getdecimal` tanto no objeto analisador como em todos os "
"proxies de secção. Em outras palavras, será possível escrever tanto "
"``parser_instance.getdecimal('section', 'key', fallback=0)`` como "
"``parser_instance['section'].getdecimal('key', 0)``."

#: ../../library/configparser.rst:711
msgid ""
"If the converter needs to access the state of the parser, it can be "
"implemented as a method on a config parser subclass.  If the name of this "
"method starts with ``get``, it will be available on all section proxies, in "
"the dict-compatible form (see the ``getdecimal()`` example above)."
msgstr ""
"Se o conversor precisar de aceder ao estado do analisador, pode ser "
"implementado como um método numa subclasse do analisador de configuração. Se "
"o nome deste método começar com ``get``, estará disponível em todos os "
"proxies de secção, na forma compatível com dicionário (consulte o exemplo "
"``getdecimal()`` acima)."

#: ../../library/configparser.rst:716
msgid ""
"More advanced customization may be achieved by overriding default values of "
"these parser attributes.  The defaults are defined on the classes, so they "
"may be overridden by subclasses or by attribute assignment."
msgstr ""
"Uma personalização mais avançada pode ser alcançada substituindo os valores "
"predefinidos destes atributos do analisador. Os valores predefinidos são "
"definidos nas classes, por isso podem ser substituídos por subclasses ou por "
"atribuição de atributos."

#: ../../library/configparser.rst:722
msgid ""
"By default when using :meth:`~ConfigParser.getboolean`, config parsers "
"consider the following values ``True``: ``'1'``, ``'yes'``, ``'true'``, "
"``'on'`` and the following values ``False``: ``'0'``, ``'no'``, ``'false'``, "
"``'off'``.  You can override this by specifying a custom dictionary of "
"strings and their Boolean outcomes. For example:"
msgstr ""

#: ../../library/configparser.rst:728
msgid ""
">>> custom = configparser.ConfigParser()\n"
">>> custom['section1'] = {'funky': 'nope'}\n"
">>> custom['section1'].getboolean('funky')\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Not a boolean: nope\n"
">>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}\n"
">>> custom['section1'].getboolean('funky')\n"
"False"
msgstr ""

#: ../../library/configparser.rst:740
msgid ""
"Other typical Boolean pairs include ``accept``/``reject`` or ``enabled``/"
"``disabled``."
msgstr ""

#: ../../library/configparser.rst:746
msgid ""
"This method transforms option names on every read, get, or set operation.  "
"The default converts the name to lowercase.  This also means that when a "
"configuration file gets written, all keys will be lowercase.  Override this "
"method if that's unsuitable. For example:"
msgstr ""

#: ../../library/configparser.rst:752
msgid ""
">>> config = \"\"\"\n"
"... [Section1]\n"
"... Key = Value\n"
"...\n"
"... [Section2]\n"
"... AnotherKey = Value\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> list(typical['Section1'].keys())\n"
"['key']\n"
">>> list(typical['Section2'].keys())\n"
"['anotherkey']\n"
">>> custom = configparser.RawConfigParser()\n"
">>> custom.optionxform = lambda option: option\n"
">>> custom.read_string(config)\n"
">>> list(custom['Section1'].keys())\n"
"['Key']\n"
">>> list(custom['Section2'].keys())\n"
"['AnotherKey']"
msgstr ""
">>> config = \"\"\"\n"
"... [Section1]\n"
"... Key = Value\n"
"...\n"
"... [Section2]\n"
"... AnotherKey = Value\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> list(typical['Section1'].keys())\n"
"['key']\n"
">>> list(typical['Section2'].keys())\n"
"['anotherkey']\n"
">>> custom = configparser.RawConfigParser()\n"
">>> custom.optionxform = lambda option: option\n"
">>> custom.read_string(config)\n"
">>> list(custom['Section1'].keys())\n"
"['Key']\n"
">>> list(custom['Section2'].keys())\n"
"['AnotherKey']"

#: ../../library/configparser.rst:776
msgid ""
"The optionxform function transforms option names to a canonical form. This "
"should be an idempotent function: if the name is already in canonical form, "
"it should be returned unchanged."
msgstr ""
"A função optionxform transforma os nomes das opções para uma forma canónica. "
"Isto deve ser uma função idempotente: se o nome já estiver na forma "
"canónica, deve ser retornado inalterado."

#: ../../library/configparser.rst:783
msgid ""
"A compiled regular expression used to parse section headers.  The default "
"matches ``[section]`` to the name ``\"section\"``.  Whitespace is considered "
"part of the section name, thus ``[  larch  ]`` will be read as a section of "
"name ``\"  larch  \"``.  Override this attribute if that's unsuitable.  For "
"example:"
msgstr ""

#: ../../library/configparser.rst:789
msgid ""
">>> import re\n"
">>> config = \"\"\"\n"
"... [Section 1]\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> typical.sections()\n"
"['Section 1', '  Section 2  ']\n"
">>> custom = configparser.ConfigParser()\n"
">>> custom.SECTCRE = re.compile(r\"\\[ *(?P<header>[^]]+?) *\\]\")\n"
">>> custom.read_string(config)\n"
">>> custom.sections()\n"
"['Section 1', 'Section 2']"
msgstr ""
">>> import re\n"
">>> config = \"\"\"\n"
"... [Section 1]\n"
"... option = value\n"
"...\n"
"... [  Section 2  ]\n"
"... another = val\n"
"... \"\"\"\n"
">>> typical = configparser.ConfigParser()\n"
">>> typical.read_string(config)\n"
">>> typical.sections()\n"
"['Section 1', '  Section 2  ']\n"
">>> custom = configparser.ConfigParser()\n"
">>> custom.SECTCRE = re.compile(r\"\\[ *(?P<header>[^]]+?) *\\]\")\n"
">>> custom.read_string(config)\n"
">>> custom.sections()\n"
"['Section 1', 'Section 2']"

#: ../../library/configparser.rst:811
msgid ""
"While ConfigParser objects also use an ``OPTCRE`` attribute for recognizing "
"option lines, it's not recommended to override it because that would "
"interfere with constructor options *allow_no_value* and *delimiters*."
msgstr ""

#: ../../library/configparser.rst:817
msgid "Legacy API Examples"
msgstr "Exemplos de API Legada"

#: ../../library/configparser.rst:819
msgid ""
"Mainly because of backwards compatibility concerns, :mod:`configparser` "
"provides also a legacy API with explicit ``get``/``set`` methods.  While "
"there are valid use cases for the methods outlined below, mapping protocol "
"access is preferred for new projects.  The legacy API is at times more "
"advanced, low-level and downright counterintuitive."
msgstr ""

#: ../../library/configparser.rst:825
msgid "An example of writing to a configuration file::"
msgstr "Um exemplo de escrita num ficheiro de configuração::"

#: ../../library/configparser.rst:827
msgid ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"\n"
"# Please note that using RawConfigParser's set functions, you can assign\n"
"# non-string values to keys internally, but will receive an error when\n"
"# attempting to write to a file or when you get it in non-raw mode. Setting\n"
"# values using the mapping protocol or ConfigParser's set() does not allow\n"
"# such assignments to take place.\n"
"config.add_section('Section1')\n"
"config.set('Section1', 'an_int', '15')\n"
"config.set('Section1', 'a_bool', 'true')\n"
"config.set('Section1', 'a_float', '3.1415')\n"
"config.set('Section1', 'baz', 'fun')\n"
"config.set('Section1', 'bar', 'Python')\n"
"config.set('Section1', 'foo', '%(bar)s is %(baz)s!')\n"
"\n"
"# Writing our configuration file to 'example.cfg'\n"
"with open('example.cfg', 'w') as configfile:\n"
"    config.write(configfile)"
msgstr ""

#: ../../library/configparser.rst:848
msgid "An example of reading the configuration file again::"
msgstr "Um exemplo de leitura do ficheiro de configuração novamente::"

#: ../../library/configparser.rst:850
msgid ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"config.read('example.cfg')\n"
"\n"
"# getfloat() raises an exception if the value is not a float\n"
"# getint() and getboolean() also do this for their respective types\n"
"a_float = config.getfloat('Section1', 'a_float')\n"
"an_int = config.getint('Section1', 'an_int')\n"
"print(a_float + an_int)\n"
"\n"
"# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.\n"
"# This is because we are using a RawConfigParser().\n"
"if config.getboolean('Section1', 'a_bool'):\n"
"    print(config.get('Section1', 'foo'))"
msgstr ""
"import configparser\n"
"\n"
"config = configparser.RawConfigParser()\n"
"config.read('example.cfg')\n"
"\n"
"# getfloat() levanta uma exceção se o valor não for um float\n"
"# getint() e getboolean() também o fazem para os seus respetivos tipos\n"
"a_float = config.getfloat('Section1', 'a_float')\n"
"an_int = config.getint('Section1', 'an_int')\n"
"print(a_float + an_int)\n"
"\n"
"# Note que a próxima saída não interpola '%(bar)s' ou '%(baz)s'.\n"
"# Isto é porque estamos a usar um RawConfigParser().\n"
"if config.getboolean('Section1', 'a_bool'):\n"
"    print(config.get('Section1', 'foo'))"

#: ../../library/configparser.rst:866
msgid "To get interpolation, use :class:`ConfigParser`::"
msgstr "Para obter interpolação, use :class:`ConfigParser`::"

#: ../../library/configparser.rst:868
msgid ""
"import configparser\n"
"\n"
"cfg = configparser.ConfigParser()\n"
"cfg.read('example.cfg')\n"
"\n"
"# Set the optional *raw* argument of get() to True if you wish to disable\n"
"# interpolation in a single get operation.\n"
"print(cfg.get('Section1', 'foo', raw=False))  # -> \"Python is fun!\"\n"
"print(cfg.get('Section1', 'foo', raw=True))   # -> \"%(bar)s is %(baz)s!\"\n"
"\n"
"# The optional *vars* argument is a dict with members that will take\n"
"# precedence in interpolation.\n"
"print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',\n"
"                                       'baz': 'evil'}))\n"
"\n"
"# The optional *fallback* argument can be used to provide a fallback value\n"
"print(cfg.get('Section1', 'foo'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'foo', fallback='Monty is not.'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback='No such things as "
"monsters.'))\n"
"      # -> \"No such things as monsters.\"\n"
"\n"
"# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError\n"
"# but we can also use:\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback=None))\n"
"      # -> None"
msgstr ""
"import configparser\n"
"\n"
"cfg = configparser.ConfigParser()\n"
"cfg.read('example.cfg')\n"
"\n"
"# Defina o argumento opcional *raw* de get() como True se desejar desativar\n"
"# a interpolação numa única operação get.\n"
"print(cfg.get('Section1', 'foo', raw=False))  # -> \"Python is fun!\"\n"
"print(cfg.get('Section1', 'foo', raw=True))   # -> \"%(bar)s is %(baz)s!\"\n"
"\n"
"# O argumento opcional *vars* é um dicionário com membros que terão "
"precedência na interpolação.\n"
"print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',\n"
"                                       'baz': 'evil'}))\n"
"\n"
"# O argumento opcional *fallback* pode ser usado para fornecer um valor de "
"recurso\n"
"print(cfg.get('Section1', 'foo'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'foo', fallback='Monty is not.'))\n"
"      # -> \"Python is fun!\"\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback='No such things as "
"monsters.'))\n"
"      # -> \"No such things as monsters.\"\n"
"\n"
"# Um simples print(cfg.get('Section1', 'monster')) levantaria NoOptionError\n"
"# mas também podemos usar:\n"
"\n"
"print(cfg.get('Section1', 'monster', fallback=None))\n"
"      # -> None"

#: ../../library/configparser.rst:899
msgid ""
"Default values are available in both types of ConfigParsers.  They are used "
"in interpolation if an option used is not defined elsewhere. ::"
msgstr ""
"Os valores predefinidos estão disponíveis em ambos os tipos de "
"ConfigParsers. São usados na interpolação se uma opção usada não estiver "
"definida noutro lugar. ::"

#: ../../library/configparser.rst:902
msgid ""
"import configparser\n"
"\n"
"# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each\n"
"config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})\n"
"config.read('example.cfg')\n"
"\n"
"print(config.get('Section1', 'foo'))     # -> \"Python is fun!\"\n"
"config.remove_option('Section1', 'bar')\n"
"config.remove_option('Section1', 'baz')\n"
"print(config.get('Section1', 'foo'))     # -> \"Life is hard!\""
msgstr ""
"import configparser\n"
"\n"
"# Nova instância com 'bar' e 'baz' predefinidos para 'Life' e 'hard', "
"respetivamente\n"
"config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})\n"
"config.read('example.cfg')\n"
"\n"
"print(config.get('Section1', 'foo'))     # -> \"Python is fun!\"\n"
"config.remove_option('Section1', 'bar')\n"
"config.remove_option('Section1', 'baz')\n"
"print(config.get('Section1', 'foo'))     # -> \"Life is hard!\""

#: ../../library/configparser.rst:917
msgid "ConfigParser Objects"
msgstr "Objetos ConfigParser"

#: ../../library/configparser.rst:921
msgid ""
"The main configuration parser.  When *defaults* is given, it is initialized "
"into the dictionary of intrinsic defaults.  When *dict_type* is given, it "
"will be used to create the dictionary objects for the list of sections, for "
"the options within a section, and for the default values."
msgstr ""
"O principal analisador de configuração. Quando *defaults* é fornecido, é "
"inicializado no dicionário de valores predefinidos intrínsecos. Quando "
"*dict_type* é fornecido, será usado para criar os objetos de dicionário para "
"a lista de secções, para as opções dentro de uma secção e para os valores "
"predefinidos."

#: ../../library/configparser.rst:926
msgid ""
"When *delimiters* is given, it is used as the set of substrings that divide "
"keys from values.  When *comment_prefixes* is given, it will be used as the "
"set of substrings that prefix comments in otherwise empty lines. Comments "
"can be indented.  When *inline_comment_prefixes* is given, it will be used "
"as the set of substrings that prefix comments in non-empty lines."
msgstr ""
"Quando *delimiters* é fornecido, é usado como o conjunto de substrings que "
"dividem as chaves dos valores. Quando *comment_prefixes* é fornecido, será "
"usado como o conjunto de substrings que prefixam comentários em linhas "
"vazias. Os comentários podem ser indentados. Quando "
"*inline_comment_prefixes* é fornecido, será usado como o conjunto de "
"substrings que prefixam comentários em linhas não vazias."

#: ../../library/configparser.rst:932
msgid ""
"When *strict* is ``True`` (the default), the parser won't allow for any "
"section or option duplicates while reading from a single source (file, "
"string or dictionary), raising :exc:`DuplicateSectionError` or :exc:"
"`DuplicateOptionError`.  When *empty_lines_in_values* is ``False`` (default: "
"``True``), each empty line marks the end of an option.  Otherwise, internal "
"empty lines of a multiline option are kept as part of the value. When "
"*allow_no_value* is ``True`` (default: ``False``), options without values "
"are accepted; the value held for these is ``None`` and they are serialized "
"without the trailing delimiter."
msgstr ""
"Quando *strict* é ``True`` (o predefinido), o analisador não permitirá "
"quaisquer duplicados de secções ou opções ao ler de uma única fonte "
"(ficheiro, string ou dicionário), levantando :exc:`DuplicateSectionError` "
"ou :exc:`DuplicateOptionError`. Quando *empty_lines_in_values* é ``False`` "
"(predefinido: ``True``), cada linha vazia marca o fim de uma opção. Caso "
"contrário, as linhas vazias internas de uma opção multilinha são mantidas "
"como parte do valor. Quando *allow_no_value* é ``True`` (predefinido: "
"``False``), as opções sem valores são aceites; o valor mantido para estas é "
"``None`` e são serializadas sem o delimitador final."

#: ../../library/configparser.rst:942
msgid ""
"When *default_section* is given, it specifies the name for the special "
"section holding default values for other sections and interpolation purposes "
"(normally named ``\"DEFAULT\"``).  This value can be retrieved and changed "
"at runtime using the ``default_section`` instance attribute. This won't re-"
"evaluate an already parsed config file, but will be used when writing parsed "
"settings to a new config file."
msgstr ""
"Quando *default_section* é fornecido, especifica o nome para a secção "
"especial que contém valores predefinidos para outras secções e fins de "
"interpolação (normalmente chamada ``\"DEFAULT\"``). Este valor pode ser "
"recuperado e alterado em tempo de execução usando o atributo de instância "
"``default_section``. Isto não reavaliará um ficheiro de configuração já "
"analisado, mas será usado ao escrever as definições analisadas num novo "
"ficheiro de configuração."

#: ../../library/configparser.rst:949
msgid ""
"Interpolation behaviour may be customized by providing a custom handler "
"through the *interpolation* argument. ``None`` can be used to turn off "
"interpolation completely, ``ExtendedInterpolation()`` provides a more "
"advanced variant inspired by ``zc.buildout``.  More on the subject in the "
"`dedicated documentation section <#interpolation-of-values>`_."
msgstr ""

#: ../../library/configparser.rst:955
msgid ""
"All option names used in interpolation will be passed through the :meth:"
"`optionxform` method just like any other option name reference.  For "
"example, using the default implementation of :meth:`optionxform` (which "
"converts option names to lower case), the values ``foo %(bar)s`` and ``foo "
"%(BAR)s`` are equivalent."
msgstr ""
"Todos os nomes de opções usados na interpolação serão passados pelo método :"
"meth:`optionxform`, tal como qualquer outra referência de nome de opção. Por "
"exemplo, usando a implementação predefinida de :meth:`optionxform` (que "
"converte nomes de opções para minúsculas), os valores ``foo %(bar)s`` e "
"``foo %(BAR)s`` são equivalentes."

#: ../../library/configparser.rst:961
msgid ""
"When *converters* is given, it should be a dictionary where each key "
"represents the name of a type converter and each value is a callable "
"implementing the conversion from string to the desired datatype.  Every "
"converter gets its own corresponding :meth:`!get*` method on the parser "
"object and section proxies."
msgstr ""
"Quando *converters* é fornecido, deve ser um dicionário onde cada chave "
"representa o nome de um conversor de tipo e cada valor é um objeto invocável "
"que implementa a conversão de string para o tipo de dados desejado. Cada "
"conversor obtém o seu próprio método :meth:`!get*` correspondente no objeto "
"analisador e nos proxies de secção."

#: ../../library/configparser.rst:992
msgid "The default *dict_type* is :class:`collections.OrderedDict`."
msgstr "O tipo *dict_type* predefinido é :class:`collections.OrderedDict`."

#: ../../library/configparser.rst:995
msgid ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* and *interpolation* were added."
msgstr ""
"*allow_no_value*, *delimiters*, *comment_prefixes*, *strict*, "
"*empty_lines_in_values*, *default_section* e *interpolation* foram "
"adicionados."

#: ../../library/configparser.rst:1000
msgid "The *converters* argument was added."
msgstr "O argumento *converters* foi adicionado."

#: ../../library/configparser.rst:1003
msgid ""
"The *defaults* argument is read with :meth:`read_dict`, providing consistent "
"behavior across the parser: non-string keys and values are implicitly "
"converted to strings."
msgstr ""
"O argumento *defaults* é lido com :meth:`read_dict`, fornecendo "
"comportamento consistente em todo o analisador: chaves e valores não-string "
"são implicitamente convertidos para strings."

#: ../../library/configparser.rst:1008 ../../library/configparser.rst:1271
msgid ""
"The default *dict_type* is :class:`dict`, since it now preserves insertion "
"order."
msgstr ""
"O tipo *dict_type* predefinido é :class:`dict`, uma vez que agora preserva a "
"ordem de inserção."

#: ../../library/configparser.rst:1014
msgid "Return a dictionary containing the instance-wide defaults."
msgstr ""
"Retorna um dicionário contendo os valores predefinidos em toda a instância."

#: ../../library/configparser.rst:1019
msgid ""
"Return a list of the sections available; the *default section* is not "
"included in the list."
msgstr ""
"Retorna uma lista das secções disponíveis; a *secção predefinida* não está "
"incluída na lista."

#: ../../library/configparser.rst:1025
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised.  The name of "
"the section must be a string; if not, :exc:`TypeError` is raised."
msgstr ""
"Adiciona uma secção com o nome *section* à instância. Se uma secção com o "
"nome dado já existir, é levantada uma :exc:`DuplicateSectionError`. Se o "
"nome da *secção predefinida* for passado, é levantada uma :exc:`ValueError`. "
"O nome da secção deve ser uma string; se não for, é levantada uma :exc:"
"`TypeError`."

#: ../../library/configparser.rst:1030
msgid "Non-string section names raise :exc:`TypeError`."
msgstr "Nomes de secção não-string levantam :exc:`TypeError`."

#: ../../library/configparser.rst:1036
msgid ""
"Indicates whether the named *section* is present in the configuration. The "
"*default section* is not acknowledged."
msgstr ""
"Indica se a *secção* nomeada está presente na configuração. A *secção "
"predefinida* não é reconhecida."

#: ../../library/configparser.rst:1042
msgid "Return a list of options available in the specified *section*."
msgstr "Retorna uma lista de opções disponíveis na *secção* especificada."

#: ../../library/configparser.rst:1047
msgid ""
"If the given *section* exists, and contains the given *option*, return :"
"const:`True`; otherwise return :const:`False`.  If the specified *section* "
"is :const:`None` or an empty string, DEFAULT is assumed."
msgstr ""
"Se a *secção* dada existir e contiver a *opção* dada, retorna :const:`True`; "
"caso contrário, retorna :const:`False`. Se a *secção* especificada for :"
"const:`None` ou uma string vazia, assume-se DEFAULT."

#: ../../library/configparser.rst:1054
msgid ""
"Attempt to read and parse an iterable of filenames, returning a list of "
"filenames which were successfully parsed."
msgstr ""
"Tenta ler e analisar um iterável de nomes de ficheiros, retornando uma lista "
"de nomes de ficheiros que foram analisados com sucesso."

#: ../../library/configparser.rst:1057
msgid ""
"If *filenames* is a string, a :class:`bytes` object or a :term:`path-like "
"object`, it is treated as a single filename.  If a file named in *filenames* "
"cannot be opened, that file will be ignored.  This is designed so that you "
"can specify an iterable of potential configuration file locations (for "
"example, the current directory, the user's home directory, and some system-"
"wide directory), and all existing configuration files in the iterable will "
"be read."
msgstr ""
"Se *filenames* for uma string, um objeto :class:`bytes` ou um objeto :term:"
"`path-like`, é tratado como um único nome de ficheiro. Se um ficheiro "
"nomeado em *filenames* não puder ser aberto, esse ficheiro será ignorado. "
"Isto é concebido para que possa especificar um iterável de locais potenciais "
"de ficheiros de configuração (por exemplo, o diretório atual, o diretório "
"inicial do utilizador e algum diretório do sistema), e todos os ficheiros de "
"configuração existentes no iterável serão lidos."

#: ../../library/configparser.rst:1066
msgid ""
"If none of the named files exist, the :class:`ConfigParser` instance will "
"contain an empty dataset.  An application which requires initial values to "
"be loaded from a file should load the required file or files using :meth:"
"`read_file` before calling :meth:`read` for any optional files::"
msgstr ""
"Se nenhum dos ficheiros nomeados existir, a instância :class:`ConfigParser` "
"conterá um conjunto de dados vazio. Uma aplicação que requer valores "
"iniciais a serem carregados de um ficheiro deve carregar o ficheiro ou "
"ficheiros necessários usando :meth:`read_file` antes de chamar :meth:`read` "
"para quaisquer ficheiros opcionais::"

#: ../../library/configparser.rst:1072
msgid ""
"import configparser, os\n"
"\n"
"config = configparser.ConfigParser()\n"
"config.read_file(open('defaults.cfg'))\n"
"config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n"
"            encoding='cp1250')"
msgstr ""
"import configparser, os\n"
"\n"
"config = configparser.ConfigParser()\n"
"config.read_file(open('defaults.cfg'))\n"
"config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],\n"
"            encoding='cp1250')"

#: ../../library/configparser.rst:1079
msgid ""
"Added the *encoding* parameter. Previously, all files were read using the "
"default encoding for :func:`open`."
msgstr ""
"Adicionado o parâmetro *encoding*. Anteriormente, todos os ficheiros eram "
"lidos usando a codificação predefinida para :func:`open`."

#: ../../library/configparser.rst:1083
msgid "The *filenames* parameter accepts a :term:`path-like object`."
msgstr "O parâmetro *filenames* aceita um objeto :term:`path-like`."

#: ../../library/configparser.rst:1086
msgid "The *filenames* parameter accepts a :class:`bytes` object."
msgstr "O parâmetro *filenames* aceita um objeto :class:`bytes`."

#: ../../library/configparser.rst:1092
msgid ""
"Read and parse configuration data from *f* which must be an iterable "
"yielding Unicode strings (for example files opened in text mode)."
msgstr ""
"Lê e analisa dados de configuração de *f*, que deve ser um iterável que "
"produz strings Unicode (por exemplo, ficheiros abertos em modo de texto)."

#: ../../library/configparser.rst:1095
msgid ""
"Optional argument *source* specifies the name of the file being read.  If "
"not given and *f* has a :attr:`!name` attribute, that is used for *source*; "
"the default is ``'<???>'``."
msgstr ""
"O argumento opcional *source* especifica o nome do ficheiro a ser lido. Se "
"não for fornecido e *f* tiver um atributo :attr:`!name`, esse é usado para "
"*source*; o predefinido é ``'<???>'``."

#: ../../library/configparser.rst:1099
msgid "Replaces :meth:`!readfp`."
msgstr "Substitui :meth:`!readfp`."

#: ../../library/configparser.rst:1104
msgid "Parse configuration data from a string."
msgstr "Analisa dados de configuração a partir de uma string."

#: ../../library/configparser.rst:1106
msgid ""
"Optional argument *source* specifies a context-specific name of the string "
"passed.  If not given, ``'<string>'`` is used.  This should commonly be a "
"filesystem path or a URL."
msgstr ""
"O argumento opcional *source* especifica um nome específico do contexto da "
"string passada. Se não for fornecido, ``'<string>'`` é usado. Isto deve ser "
"comumente um caminho do sistema de ficheiros ou um URL."

#: ../../library/configparser.rst:1115
msgid ""
"Load configuration from any object that provides a dict-like ``items()`` "
"method.  Keys are section names, values are dictionaries with keys and "
"values that should be present in the section.  If the used dictionary type "
"preserves order, sections and their keys will be added in order. Values are "
"automatically converted to strings."
msgstr ""
"Carrega a configuração de qualquer objeto que forneça um método ``items()`` "
"semelhante a um dicionário. As chaves são nomes de secções, os valores são "
"dicionários com chaves e valores que devem estar presentes na secção. Se o "
"tipo de dicionário usado preservar a ordem, as secções e as suas chaves "
"serão adicionadas por ordem. Os valores são automaticamente convertidos para "
"strings."

#: ../../library/configparser.rst:1121
msgid ""
"Optional argument *source* specifies a context-specific name of the "
"dictionary passed.  If not given, ``<dict>`` is used."
msgstr ""
"O argumento opcional *source* especifica um nome específico do contexto do "
"dicionário passado. Se não for fornecido, ``<dict>`` é usado."

#: ../../library/configparser.rst:1124
msgid "This method can be used to copy state between parsers."
msgstr "Este método pode ser usado para copiar o estado entre analisadores."

#: ../../library/configparser.rst:1131
msgid ""
"Get an *option* value for the named *section*.  If *vars* is provided, it "
"must be a dictionary.  The *option* is looked up in *vars* (if provided), "
"*section*, and in *DEFAULTSECT* in that order.  If the key is not found and "
"*fallback* is provided, it is used as a fallback value.  ``None`` can be "
"provided as a *fallback* value."
msgstr ""
"Obtém um valor de *opção* para a *secção* nomeada. Se *vars* for fornecido, "
"deve ser um dicionário. A *opção* é procurada em *vars* (se fornecido), "
"*secção* e em *DEFAULTSECT* por essa ordem. Se a chave não for encontrada e "
"*fallback* for fornecido, é usado como um valor de recurso. ``None`` pode "
"ser fornecido como um valor de *fallback*."

#: ../../library/configparser.rst:1137
msgid ""
"All the ``'%'`` interpolations are expanded in the return values, unless the "
"*raw* argument is true.  Values for interpolation keys are looked up in the "
"same manner as the option."
msgstr ""
"Todas as interpolações ``'%'`` são expandidas nos valores de retorno, a "
"menos que o argumento *raw* seja verdadeiro. Os valores para as chaves de "
"interpolação são procurados da mesma forma que a opção."

#: ../../library/configparser.rst:1141
msgid ""
"Arguments *raw*, *vars* and *fallback* are keyword only to protect users "
"from trying to use the third argument as the *fallback* fallback (especially "
"when using the mapping protocol)."
msgstr ""
"Os argumentos *raw*, *vars* e *fallback* são apenas por palavra-chave para "
"proteger os utilizadores de tentarem usar o terceiro argumento como o "
"*fallback* de recurso (especialmente ao usar o protocolo de mapeamento)."

#: ../../library/configparser.rst:1149
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to an integer.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Um método de conveniência que converte a *opção* na *secção* especificada "
"para um inteiro. Consulte :meth:`get` para a explicação de *raw*, *vars* e "
"*fallback*."

#: ../../library/configparser.rst:1156
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a floating-point number.  See :meth:`get` for explanation of *raw*, "
"*vars* and *fallback*."
msgstr ""
"Um método de conveniência que converte a *opção* na *secção* especificada "
"para um número de ponto flutuante. Consulte :meth:`get` para a explicação de "
"*raw*, *vars* e *fallback*."

#: ../../library/configparser.rst:1163
msgid ""
"A convenience method which coerces the *option* in the specified *section* "
"to a Boolean value.  Note that the accepted values for the option are "
"``'1'``, ``'yes'``, ``'true'``, and ``'on'``, which cause this method to "
"return ``True``, and ``'0'``, ``'no'``, ``'false'``, and ``'off'``, which "
"cause it to return ``False``.  These string values are checked in a case-"
"insensitive manner.  Any other value will cause it to raise :exc:"
"`ValueError`.  See :meth:`get` for explanation of *raw*, *vars* and "
"*fallback*."
msgstr ""
"Um método de conveniência que converte a *opção* na *secção* especificada "
"para um valor booleano. Note que os valores aceites para a opção são "
"``'1'``, ``'yes'``, ``'true'`` e ``'on'``, que fazem com que este método "
"retorne ``True``, e ``'0'``, ``'no'``, ``'false'`` e ``'off'``, que fazem "
"com que retorne ``False``. Estes valores de string são verificados de forma "
"não sensível a maiúsculas e minúsculas. Qualquer outro valor fará com que "
"levante :exc:`ValueError`. Consulte :meth:`get` para a explicação de *raw*, "
"*vars* e *fallback*."

#: ../../library/configparser.rst:1176
msgid ""
"When *section* is not given, return a list of *section_name*, "
"*section_proxy* pairs, including DEFAULTSECT."
msgstr ""
"Quando *section* não é fornecido, retorna uma lista de pares *section_name*, "
"*section_proxy*, incluindo DEFAULTSECT."

#: ../../library/configparser.rst:1179
msgid ""
"Otherwise, return a list of *name*, *value* pairs for the options in the "
"given *section*.  Optional arguments have the same meaning as for the :meth:"
"`get` method."
msgstr ""
"Caso contrário, retorna uma lista de pares *name*, *value* para as opções na "
"*secção* dada. Os argumentos opcionais têm o mesmo significado que para o "
"método :meth:`get`."

#: ../../library/configparser.rst:1183
msgid ""
"Items present in *vars* no longer appear in the result.  The previous "
"behaviour mixed actual parser options with variables provided for "
"interpolation."
msgstr ""
"Itens presentes em *vars* já não aparecem no resultado. O comportamento "
"anterior misturava opções reais do analisador com variáveis fornecidas para "
"interpolação."

#: ../../library/configparser.rst:1191
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  *option* and *value* must be "
"strings; if not, :exc:`TypeError` is raised."
msgstr ""
"Se a secção dada existir, define a opção dada para o valor especificado; "
"caso contrário, levanta :exc:`NoSectionError`. *option* e *value* devem ser "
"strings; se não forem, é levantada uma :exc:`TypeError`."

#: ../../library/configparser.rst:1198
msgid ""
"Write a representation of the configuration to the specified :term:`file "
"object`, which must be opened in text mode (accepting strings).  This "
"representation can be parsed by a future :meth:`read` call.  If "
"*space_around_delimiters* is true, delimiters between keys and values are "
"surrounded by spaces."
msgstr ""
"Escreve uma representação da configuração no objeto :term:`file` "
"especificado, que deve ser aberto em modo de texto (aceitando strings). Esta "
"representação pode ser analisada por uma chamada futura :meth:`read`. Se "
"*space_around_delimiters* for verdadeiro, os delimitadores entre chaves e "
"valores são rodeados por espaços."

#: ../../library/configparser.rst:1206
msgid ""
"Comments in the original configuration file are not preserved when writing "
"the configuration back. What is considered a comment, depends on the given "
"values for *comment_prefix* and *inline_comment_prefix*."
msgstr ""
"Os comentários no ficheiro de configuração original não são preservados ao "
"escrever a configuração de volta. O que é considerado um comentário depende "
"dos valores dados para *comment_prefix* e *inline_comment_prefix*."

#: ../../library/configparser.rst:1214
msgid ""
"Remove the specified *option* from the specified *section*.  If the section "
"does not exist, raise :exc:`NoSectionError`.  If the option existed to be "
"removed, return :const:`True`; otherwise return :const:`False`."
msgstr ""
"Remove a *opção* especificada da *secção* especificada. Se a secção não "
"existir, levanta :exc:`NoSectionError`. Se a opção existir para ser "
"removida, retorna :const:`True`; caso contrário, retorna :const:`False`."

#: ../../library/configparser.rst:1222
msgid ""
"Remove the specified *section* from the configuration.  If the section in "
"fact existed, return ``True``.  Otherwise return ``False``."
msgstr ""
"Remove a *secção* especificada da configuração. Se a secção de facto "
"existir, retorna ``True``. Caso contrário, retorna ``False``."

#: ../../library/configparser.rst:1228
msgid ""
"Transforms the option name *option* as found in an input file or as passed "
"in by client code to the form that should be used in the internal "
"structures.  The default implementation returns a lower-case version of "
"*option*; subclasses may override this or client code can set an attribute "
"of this name on instances to affect this behavior."
msgstr ""
"Transforma o nome da opção *option*, conforme encontrado num ficheiro de "
"entrada ou conforme passado pelo código do cliente, para a forma que deve "
"ser usada nas estruturas internas. A implementação predefinida retorna uma "
"versão em minúsculas de *option*; subclasses podem substituir isto ou o "
"código do cliente pode definir um atributo com este nome nas instâncias para "
"afetar este comportamento."

#: ../../library/configparser.rst:1234
msgid ""
"You don't need to subclass the parser to use this method, you can also set "
"it on an instance, to a function that takes a string argument and returns a "
"string.  Setting it to ``str``, for example, would make option names case "
"sensitive::"
msgstr ""
"Não precisa de criar uma subclasse do analisador para usar este método, "
"também pode defini-lo numa instância, para uma função que recebe um "
"argumento string e retorna uma string. Defini-lo para ``str``, por exemplo, "
"tornaria os nomes das opções sensíveis a maiúsculas e minúsculas::"

#: ../../library/configparser.rst:1239
msgid ""
"cfgparser = ConfigParser()\n"
"cfgparser.optionxform = str"
msgstr ""
"cfgparser = ConfigParser()\n"
"cfgparser.optionxform = str"

#: ../../library/configparser.rst:1242
msgid ""
"Note that when reading configuration files, whitespace around the option "
"names is stripped before :meth:`optionxform` is called."
msgstr ""
"Note que, ao ler ficheiros de configuração, os espaços em branco em redor "
"dos nomes das opções são removidos antes de :meth:`optionxform` ser chamado."

#: ../../library/configparser.rst:1248
msgid ""
"The maximum depth for recursive interpolation for :meth:`~configparser."
"ConfigParser.get` when the *raw* parameter is false.  This is relevant only "
"when the default *interpolation* is used."
msgstr ""
"A profundidade máxima para interpolação recursiva para :meth:`~configparser."
"ConfigParser.get` quando o parâmetro *raw* é falso. Isto é relevante apenas "
"quando a *interpolação* predefinida é usada."

#: ../../library/configparser.rst:1256
msgid "RawConfigParser Objects"
msgstr "Objetos RawConfigParser"

#: ../../library/configparser.rst:1266
msgid ""
"Legacy variant of the :class:`ConfigParser`.  It has interpolation disabled "
"by default and allows for non-string section names, option names, and values "
"via its unsafe ``add_section`` and ``set`` methods, as well as the legacy "
"``defaults=`` keyword argument handling."
msgstr ""

#: ../../library/configparser.rst:1276
msgid ""
"Consider using :class:`ConfigParser` instead which checks types of the "
"values to be stored internally.  If you don't want interpolation, you can "
"use ``ConfigParser(interpolation=None)``."
msgstr ""
"Considere usar :class:`ConfigParser` em vez disso, que verifica os tipos dos "
"valores a serem armazenados internamente. Se não quiser interpolação, pode "
"usar ``ConfigParser(interpolation=None)``."

#: ../../library/configparser.rst:1283
msgid ""
"Add a section named *section* to the instance.  If a section by the given "
"name already exists, :exc:`DuplicateSectionError` is raised.  If the "
"*default section* name is passed, :exc:`ValueError` is raised."
msgstr ""

#: ../../library/configparser.rst:1287
msgid ""
"Type of *section* is not checked which lets users create non-string named "
"sections.  This behaviour is unsupported and may cause internal errors."
msgstr ""
"O tipo de *section* não é verificado, o que permite aos utilizadores criar "
"secções com nomes não-string. Este comportamento não é suportado e pode "
"causar erros internos."

#: ../../library/configparser.rst:1293
msgid ""
"If the given section exists, set the given option to the specified value; "
"otherwise raise :exc:`NoSectionError`.  While it is possible to use :class:"
"`RawConfigParser` (or :class:`ConfigParser` with *raw* parameters set to "
"true) for *internal* storage of non-string values, full functionality "
"(including interpolation and output to files) can only be achieved using "
"string values."
msgstr ""
"Se a secção dada existir, define a opção dada para o valor especificado; "
"caso contrário, levanta :exc:`NoSectionError`. Embora seja possível usar :"
"class:`RawConfigParser` (ou :class:`ConfigParser` com parâmetros *raw* "
"definidos como verdadeiros) para armazenamento *interno* de valores não-"
"string, a funcionalidade completa (incluindo interpolação e saída para "
"ficheiros) só pode ser alcançada usando valores string."

#: ../../library/configparser.rst:1300
msgid ""
"This method lets users assign non-string values to keys internally.  This "
"behaviour is unsupported and will cause errors when attempting to write to a "
"file or get it in non-raw mode.  **Use the mapping protocol API** which does "
"not allow such assignments to take place."
msgstr ""
"Este método permite que os utilizadores atribuam valores não-string a chaves "
"internamente. Este comportamento não é suportado e causará erros ao tentar "
"escrever num ficheiro ou obtê-lo em modo não-raw. **Use a API do protocolo "
"de mapeamento**, que não permite que tais atribuições ocorram."

#: ../../library/configparser.rst:1307
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/configparser.rst:1311
msgid "Base class for all other :mod:`configparser` exceptions."
msgstr "Classe base para todas as outras exceções :mod:`configparser`."

#: ../../library/configparser.rst:1316
msgid "Exception raised when a specified section is not found."
msgstr "Exceção levantada quando uma secção especificada não é encontrada."

#: ../../library/configparser.rst:1321
msgid ""
"Exception raised if :meth:`~ConfigParser.add_section` is called with the "
"name of a section that is already present or in strict parsers when a "
"section if found more than once in a single input file, string or dictionary."
msgstr ""
"Exceção levantada se :meth:`~ConfigParser.add_section` for chamado com o "
"nome de uma secção que já está presente ou em analisadores estritos quando "
"uma secção é encontrada mais do que uma vez num único ficheiro de entrada, "
"string ou dicionário."

#: ../../library/configparser.rst:1325
msgid ""
"Added the optional *source* and *lineno* attributes and parameters to :meth:"
"`!__init__`."
msgstr ""
"Adicionados os atributos e parâmetros opcionais *source* e *lineno* a :meth:"
"`!__init__`."

#: ../../library/configparser.rst:1332
msgid ""
"Exception raised by strict parsers if a single option appears twice during "
"reading from a single file, string or dictionary. This catches misspellings "
"and case sensitivity-related errors, e.g. a dictionary may have two keys "
"representing the same case-insensitive configuration key."
msgstr ""
"Exceção levantada por analisadores estritos se uma única opção aparecer duas "
"vezes durante a leitura de um único ficheiro, string ou dicionário. Isto "
"deteta erros ortográficos e erros relacionados com a sensibilidade a "
"maiúsculas e minúsculas, por exemplo, um dicionário pode ter duas chaves que "
"representam a mesma chave de configuração não sensível a maiúsculas e "
"minúsculas."

#: ../../library/configparser.rst:1340
msgid ""
"Exception raised when a specified option is not found in the specified "
"section."
msgstr ""
"Exceção levantada quando uma opção especificada não é encontrada na secção "
"especificada."

#: ../../library/configparser.rst:1346
msgid ""
"Base class for exceptions raised when problems occur performing string "
"interpolation."
msgstr ""
"Classe base para exceções levantadas quando ocorrem problemas ao realizar "
"interpolação de strings."

#: ../../library/configparser.rst:1352
msgid ""
"Exception raised when string interpolation cannot be completed because the "
"number of iterations exceeds :const:`MAX_INTERPOLATION_DEPTH`.  Subclass of :"
"exc:`InterpolationError`."
msgstr ""
"Exceção levantada quando a interpolação de strings não pode ser concluída "
"porque o número de iterações excede :const:`MAX_INTERPOLATION_DEPTH`. "
"Subclasse de :exc:`InterpolationError`."

#: ../../library/configparser.rst:1359
msgid ""
"Exception raised when an option referenced from a value does not exist. "
"Subclass of :exc:`InterpolationError`."
msgstr ""
"Exceção levantada quando uma opção referenciada a partir de um valor não "
"existe. Subclasse de :exc:`InterpolationError`."

#: ../../library/configparser.rst:1365
msgid ""
"Exception raised when the source text into which substitutions are made does "
"not conform to the required syntax.  Subclass of :exc:`InterpolationError`."
msgstr ""
"Exceção levantada quando o texto de origem no qual as substituições são "
"feitas não está em conformidade com a sintaxe necessária. Subclasse de :exc:"
"`InterpolationError`."

#: ../../library/configparser.rst:1371
msgid ""
"Exception raised when attempting to parse a file which has no section "
"headers."
msgstr ""
"Exceção levantada ao tentar analisar um ficheiro que não tem cabeçalhos de "
"secção."

#: ../../library/configparser.rst:1377
msgid "Exception raised when errors occur attempting to parse a file."
msgstr "Exceção levantada quando ocorrem erros ao tentar analisar um ficheiro."

#: ../../library/configparser.rst:1379
msgid ""
"The ``filename`` attribute and :meth:`!__init__` constructor argument were "
"removed.  They have been available using the name ``source`` since 3.2."
msgstr ""
"O atributo ``filename`` e o argumento do construtor :meth:`!__init__` foram "
"removidos. Estão disponíveis usando o nome ``source`` desde a versão 3.2."

#: ../../library/configparser.rst:1384
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/configparser.rst:1385
msgid ""
"Config parsers allow for heavy customization.  If you are interested in "
"changing the behaviour outlined by the footnote reference, consult the "
"`Customizing Parser Behaviour`_ section."
msgstr ""

#: ../../library/configparser.rst:16
msgid ".ini"
msgstr ".ini"

#: ../../library/configparser.rst:16
msgid "file"
msgstr "ficheiro"

#: ../../library/configparser.rst:16
msgid "configuration"
msgstr "configuração"

#: ../../library/configparser.rst:16
msgid "ini file"
msgstr "ficheiro ini"

#: ../../library/configparser.rst:16
msgid "Windows ini file"
msgstr ""

#: ../../library/configparser.rst:341
msgid "% (percent)"
msgstr "% (percentagem)"

#: ../../library/configparser.rst:341 ../../library/configparser.rst:374
msgid "interpolation in configuration files"
msgstr ""

#: ../../library/configparser.rst:374
msgid "$ (dollar)"
msgstr "$ (dólar)"
