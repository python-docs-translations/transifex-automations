# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-11 14:18+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/types.rst:2
msgid ":mod:`!types` --- Dynamic type creation and names for built-in types"
msgstr ""
":mod:`!types` --- Criação dinâmica de tipos e nomes para tipos incorporados"

#: ../../library/types.rst:7
msgid "**Source code:** :source:`Lib/types.py`"
msgstr "**Código-fonte:** :source:`Lib/types.py`"

#: ../../library/types.rst:11
msgid ""
"This module defines utility functions to assist in dynamic creation of new "
"types."
msgstr ""
"Este módulo define funções utilitárias para assistir na criação dinâmica de "
"novos tipos."

#: ../../library/types.rst:14
msgid ""
"It also defines names for some object types that are used by the standard "
"Python interpreter, but not exposed as builtins like :class:`int` or :class:"
"`str` are."
msgstr ""
"Também define nomes para alguns tipos de objetos que são usados pelo "
"interpretador Python padrão, mas não expostos como incorporados como :class:"
"`int` ou :class:`str`."

#: ../../library/types.rst:18
msgid ""
"Finally, it provides some additional type-related utility classes and "
"functions that are not fundamental enough to be builtins."
msgstr ""
"Finalmente, fornece algumas classes e funções utilitárias adicionais "
"relacionadas com tipos que não são fundamentais o suficiente para serem "
"incorporadas."

#: ../../library/types.rst:23
msgid "Dynamic Type Creation"
msgstr "Criação Dinâmica de Tipos"

#: ../../library/types.rst:27
msgid "Creates a class object dynamically using the appropriate metaclass."
msgstr "Cria um objeto de classe dinamicamente usando a metaclasse apropriada."

#: ../../library/types.rst:29
msgid ""
"The first three arguments are the components that make up a class definition "
"header: the class name, the base classes (in order), the keyword arguments "
"(such as ``metaclass``)."
msgstr ""
"Os três primeiros argumentos são os componentes que constituem um cabeçalho "
"de definição de classe: o nome da classe, as classes base (por ordem), os "
"argumentos nomeados (como ``metaclass``)."

#: ../../library/types.rst:33
msgid ""
"The *exec_body* argument is a callback that is used to populate the freshly "
"created class namespace. It should accept the class namespace as its sole "
"argument and update the namespace directly with the class contents. If no "
"callback is provided, it has the same effect as passing in ``lambda ns: "
"None``."
msgstr ""
"O argumento *exec_body* é um *callback* que é usado para preencher o espaço "
"de nomes da classe recém-criada. Deve aceitar o espaço de nomes da classe "
"como seu único argumento e atualizar o espaço de nomes diretamente com o "
"conteúdo da classe. Se nenhum *callback* for fornecido, tem o mesmo efeito "
"que passar ``lambda ns: None``."

#: ../../library/types.rst:43
msgid "Calculates the appropriate metaclass and creates the class namespace."
msgstr "Calcula a metaclasse apropriada e cria o espaço de nomes da classe."

#: ../../library/types.rst:45
msgid ""
"The arguments are the components that make up a class definition header: the "
"class name, the base classes (in order) and the keyword arguments (such as "
"``metaclass``)."
msgstr ""
"Os argumentos são os componentes que constituem um cabeçalho de definição de "
"classe: o nome da classe, as classes base (por ordem) e os argumentos "
"nomeados (como ``metaclass``)."

#: ../../library/types.rst:49
msgid "The return value is a 3-tuple: ``metaclass, namespace, kwds``"
msgstr ""
"O valor de retorno é um tuplo de 3 elementos: ``metaclass, namespace, kwds``"

#: ../../library/types.rst:51
msgid ""
"*metaclass* is the appropriate metaclass, *namespace* is the prepared class "
"namespace and *kwds* is an updated copy of the passed in *kwds* argument "
"with any ``'metaclass'`` entry removed. If no *kwds* argument is passed in, "
"this will be an empty dict."
msgstr ""
"*metaclass* é a metaclasse apropriada, *namespace* é o espaço de nomes da "
"classe preparado e *kwds* é uma cópia atualizada do argumento *kwds* passado "
"com qualquer entrada ``'metaclass'`` removida. Se nenhum argumento *kwds* "
"for passado, isto será um dicionário vazio."

#: ../../library/types.rst:60
msgid ""
"The default value for the ``namespace`` element of the returned tuple has "
"changed.  Now an insertion-order-preserving mapping is used when the "
"metaclass does not have a ``__prepare__`` method."
msgstr ""
"O valor predefinido para o elemento ``namespace`` do tuplo devolvido mudou. "
"Agoras é usado um mapeamento que preserva a ordem de inserção quando a "
"metaclasse não tem um método ``__prepare__``."

#: ../../library/types.rst:66
msgid ":ref:`metaclasses`"
msgstr ":ref:`metaclasses`"

#: ../../library/types.rst:67
msgid "Full details of the class creation process supported by these functions"
msgstr ""
"Detalhes completos do processo de criação de classe suportado por estas "
"funções"

#: ../../library/types.rst:69
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` — Metaclasses em Python 3000"

#: ../../library/types.rst:70
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "Introduziu o gancho de espaço de nomes ``__prepare__``"

#: ../../library/types.rst:74
msgid "Resolve MRO entries dynamically as specified by :pep:`560`."
msgstr "Resolve entradas MRO dinamicamente como especificado pela :pep:`560`."

#: ../../library/types.rst:76
msgid ""
"This function looks for items in *bases* that are not instances of :class:"
"`type`, and returns a tuple where each such object that has an :meth:"
"`~object.__mro_entries__` method is replaced with an unpacked result of "
"calling this method.  If a *bases* item is an instance of :class:`type`, or "
"it doesn't have an :meth:`!__mro_entries__` method, then it is included in "
"the return tuple unchanged."
msgstr ""
"Esta função procura itens em *bases* que não são instâncias de :class:"
"`type`, e devolve um tuplo onde cada objeto que tem um método :meth:`~object."
"__mro_entries__` é substituído pelo resultado desempacotado da chamada deste "
"método. Se um item *bases* for uma instância de :class:`type`, ou não tiver "
"um método :meth:`!__mro_entries__`, então é incluído no tuplo devolvido sem "
"alterações."

#: ../../library/types.rst:87
msgid ""
"Return the tuple of objects originally given as the bases of *cls* before "
"the :meth:`~object.__mro_entries__` method has been called on any bases "
"(following the mechanisms laid out in :pep:`560`). This is useful for "
"introspecting :ref:`Generics <user-defined-generics>`."
msgstr ""
"Devolve o tuplo de objetos originalmente dados como as bases de *cls* antes "
"que o método :meth:`~object.__mro_entries__` tenha sido chamado em quaisquer "
"bases (seguindo os mecanismos descritos na :pep:`560`). Isto é útil para "
"introspeção de :ref:`Genéricos <user-defined-generics>`."

#: ../../library/types.rst:92
msgid ""
"For classes that have an ``__orig_bases__`` attribute, this function returns "
"the value of ``cls.__orig_bases__``. For classes without the "
"``__orig_bases__`` attribute, :attr:`cls.__bases__ <type.__bases__>` is "
"returned."
msgstr ""
"Para classes que têm um atributo ``__orig_bases__``, esta função devolve o "
"valor de ``cls.__orig_bases__``. Para classes sem o atributo "
"``__orig_bases__``, :attr:`cls.__bases__ <type.__bases__>` é devolvido."

#: ../../library/types.rst:97
msgid "Examples::"
msgstr "Exemplos:"

#: ../../library/types.rst:99
msgid ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"
msgstr ""
"from typing import TypeVar, Generic, NamedTuple, TypedDict\n"
"\n"
"T = TypeVar(\"T\")\n"
"class Foo(Generic[T]): ...\n"
"class Bar(Foo[int], float): ...\n"
"class Baz(list[str]): ...\n"
"Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n"
"Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n"
"\n"
"assert Bar.__bases__ == (Foo, float)\n"
"assert get_original_bases(Bar) == (Foo[int], float)\n"
"\n"
"assert Baz.__bases__ == (list,)\n"
"assert get_original_bases(Baz) == (list[str],)\n"
"\n"
"assert Eggs.__bases__ == (tuple,)\n"
"assert get_original_bases(Eggs) == (NamedTuple,)\n"
"\n"
"assert Spam.__bases__ == (dict,)\n"
"assert get_original_bases(Spam) == (TypedDict,)\n"
"\n"
"assert int.__bases__ == (object,)\n"
"assert get_original_bases(int) == (object,)"

#: ../../library/types.rst:127
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` — Suporte central para o módulo typing e tipos genéricos"

#: ../../library/types.rst:131
msgid "Standard Interpreter Types"
msgstr "Tipos do Interpretador Padrão"

#: ../../library/types.rst:133
msgid ""
"This module provides names for many of the types that are required to "
"implement a Python interpreter. It deliberately avoids including some of the "
"types that arise only incidentally during processing such as the "
"``listiterator`` type."
msgstr ""
"Este módulo fornece nomes para muitos dos tipos que são necessários para "
"implementar um interpretador Python. Evita deliberadamente incluir alguns "
"dos tipos que surgem apenas incidentalmente durante o processamento, como o "
"tipo ``listiterator``."

#: ../../library/types.rst:138
msgid ""
"Typical use of these names is for :func:`isinstance` or :func:`issubclass` "
"checks."
msgstr ""
"O uso típico destes nomes é para verificações :func:`isinstance` ou :func:"
"`issubclass`."

#: ../../library/types.rst:142
msgid ""
"If you instantiate any of these types, note that signatures may vary between "
"Python versions."
msgstr ""
"Se instanciar algum destes tipos, note que as assinaturas podem variar entre "
"versões do Python."

#: ../../library/types.rst:144
msgid "Standard names are defined for the following types:"
msgstr "Nomes padrão são definidos para os seguintes tipos:"

#: ../../library/types.rst:148
msgid "The type of :data:`None`."
msgstr "O tipo de :data:`None`."

#: ../../library/types.rst:156
msgid ""
"The type of user-defined functions and functions created by :keyword:"
"`lambda`  expressions."
msgstr ""
"O tipo de funções definidas pelo utilizador e funções criadas por "
"expressões :keyword:`lambda`."

#: ../../library/types.rst:159
msgid ""
"Raises an :ref:`auditing event <auditing>` ``function.__new__`` with "
"argument ``code``."
msgstr ""
"Lança um :ref:`evento de auditoria <auditing>` ``function.__new__`` com o "
"argumento ``code``."

#: ../../library/types.rst:161
msgid ""
"The audit event only occurs for direct instantiation of function objects, "
"and is not raised for normal compilation."
msgstr ""
"O evento de auditoria só ocorre para a instanciação direta de objetos de "
"função e não é lançado para compilação normal."

#: ../../library/types.rst:167
msgid ""
"The type of :term:`generator`-iterator objects, created by generator "
"functions."
msgstr ""
"O tipo de objetos :term:`gerador`-iterador, criados por funções geradoras."

#: ../../library/types.rst:173
msgid ""
"The type of :term:`coroutine` objects, created by :keyword:`async def` "
"functions."
msgstr ""
"O tipo de objetos :term:`corrotina`, criados por funções :keyword:`async "
"def`."

#: ../../library/types.rst:181
msgid ""
"The type of :term:`asynchronous generator`-iterator objects, created by "
"asynchronous generator functions."
msgstr ""
"O tipo de objetos :term:`gerador assíncrono`-iterador, criados por funções "
"geradoras assíncronas."

#: ../../library/types.rst:191
msgid ""
"The type of :ref:`code objects <code-objects>` such as returned by :func:"
"`compile`."
msgstr ""
"O tipo de :ref:`objetos de código <code-objects>`, como os devolvidos por :"
"func:`compile`."

#: ../../library/types.rst:193
msgid ""
"Raises an :ref:`auditing event <auditing>` ``code.__new__`` with arguments "
"``code``, ``filename``, ``name``, ``argcount``, ``posonlyargcount``, "
"``kwonlyargcount``, ``nlocals``, ``stacksize``, ``flags``."
msgstr ""
"Lança um :ref:`evento de auditoria <auditing>` ``code.__new__`` com os "
"argumentos ``code``, ``filename``, ``name``, ``argcount``, "
"``posonlyargcount``, ``kwonlyargcount``, ``nlocals``, ``stacksize``, "
"``flags``."

#: ../../library/types.rst:195
msgid ""
"Note that the audited arguments may not match the names or positions "
"required by the initializer.  The audit event only occurs for direct "
"instantiation of code objects, and is not raised for normal compilation."
msgstr ""
"Note que os argumentos auditados podem não corresponder aos nomes ou "
"posições exigidos pelo inicializador. O evento de auditoria só ocorre para a "
"instanciação direta de objetos de código e não é lançado para compilação "
"normal."

#: ../../library/types.rst:201
msgid ""
"The type for cell objects: such objects are used as containers for a "
"function's :term:`closure variables <closure variable>`."
msgstr ""
"O tipo de objetos de célula: tais objetos são usados como contentores para "
"variáveis de :term:`fecho <closure variable>` de uma função."

#: ../../library/types.rst:209
msgid "The type of methods of user-defined class instances."
msgstr "O tipo de métodos de instâncias de classes definidas pelo utilizador."

#: ../../library/types.rst:215
msgid ""
"The type of built-in functions like :func:`len` or :func:`sys.exit`, and "
"methods of built-in classes.  (Here, the term \"built-in\" means \"written "
"in C\".)"
msgstr ""
"O tipo de funções incorporadas como :func:`len` ou :func:`sys.exit`, e "
"métodos de classes incorporadas. (Aqui, o termo \"incorporado\" significa "
"\"escrito em C\".)"

#: ../../library/types.rst:222
msgid ""
"The type of methods of some built-in data types and base classes such as :"
"meth:`object.__init__` or :meth:`object.__lt__`."
msgstr ""
"O tipo de métodos de alguns tipos de dados incorporados e classes base como :"
"meth:`object.__init__` ou :meth:`object.__lt__`."

#: ../../library/types.rst:230
msgid ""
"The type of *bound* methods of some built-in data types and base classes. "
"For example it is the type of :code:`object().__str__`."
msgstr ""
"O tipo de métodos *ligados* de alguns tipos de dados incorporados e classes "
"base. Por exemplo, é o tipo de :code:`object().__str__`."

#: ../../library/types.rst:238
msgid "The type of :data:`NotImplemented`."
msgstr "O tipo de :data:`NotImplemented`."

#: ../../library/types.rst:245
msgid ""
"The type of methods of some built-in data types such as :meth:`str.join`."
msgstr ""
"O tipo de métodos de alguns tipos de dados incorporados como :meth:`str."
"join`."

#: ../../library/types.rst:252
msgid ""
"The type of *unbound* class methods of some built-in data types such as "
"``dict.__dict__['fromkeys']``."
msgstr ""
"O tipo de métodos de classe *não ligados* de alguns tipos de dados "
"incorporados como ``dict.__dict__['fromkeys']``."

#: ../../library/types.rst:260
msgid ""
"The type of :term:`modules <module>`. The constructor takes the name of the "
"module to be created and optionally its :term:`docstring`."
msgstr ""
"O tipo de :term:`módulos <module>`. O construtor recebe o nome do módulo a "
"ser criado e, opcionalmente, a sua :term:`docstring`."

#: ../../library/types.rst:265
msgid ":ref:`Documentation on module objects <module-objects>`"
msgstr ":ref:`Documentação sobre objetos de módulo <module-objects>`"

#: ../../library/types.rst:266
msgid ""
"Provides details on the special attributes that can be found on instances "
"of :class:`!ModuleType`."
msgstr ""
"Fornece detalhes sobre os atributos especiais que podem ser encontrados em "
"instâncias de :class:`!ModuleType`."

#: ../../library/types.rst:269
msgid ":func:`importlib.util.module_from_spec`"
msgstr ":func:`importlib.util.module_from_spec`"

#: ../../library/types.rst:270
msgid ""
"Modules created using the :class:`!ModuleType` constructor are created with "
"many of their special attributes unset or set to default values. :func:`!"
"module_from_spec` provides a more robust way of creating :class:`!"
"ModuleType` instances which ensures the various attributes are set "
"appropriately."
msgstr ""
"Os módulos criados usando o construtor :class:`!ModuleType` são criados com "
"muitos dos seus atributos especiais não definidos ou definidos para valores "
"predefinidos. :func:`!module_from_spec` fornece uma forma mais robusta de "
"criar instâncias :class:`!ModuleType` que garante que os vários atributos "
"são definidos apropriadamente."

#: ../../library/types.rst:278
msgid "The type of :data:`Ellipsis`."
msgstr "O tipo de :data:`Ellipsis`."

#: ../../library/types.rst:284
msgid ""
"The type of :ref:`parameterized generics <types-genericalias>` such as "
"``list[int]``."
msgstr ""
"O tipo de :ref:`genéricos parametrizados <types-genericalias>` como "
"``list[int]``."

#: ../../library/types.rst:287
msgid ""
"``t_origin`` should be a non-parameterized generic class, such as ``list``, "
"``tuple`` or ``dict``.  ``t_args`` should be a :class:`tuple` (possibly of "
"length 1) of types which parameterize ``t_origin``::"
msgstr ""
"``t_origin`` deve ser uma classe genérica não parametrizada, como ``list``, "
"``tuple`` ou ``dict``. ``t_args`` deve ser um :class:`tuple` (possivelmente "
"de comprimento 1) de tipos que parametrizam ``t_origin``:"

#: ../../library/types.rst:291
msgid ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"
msgstr ""
">>> from types import GenericAlias\n"
"\n"
">>> list[int] == GenericAlias(list, (int,))\n"
"True\n"
">>> dict[str, int] == GenericAlias(dict, (str, int))\n"
"True"

#: ../../library/types.rst:300
msgid "This type can now be subclassed."
msgstr "Este tipo pode agora ser subclassificado."

#: ../../library/types.rst:305
msgid ":ref:`Generic Alias Types<types-genericalias>`"
msgstr ":ref:`Tipos de Alias Genéricos<types-genericalias>`"

#: ../../library/types.rst:306
msgid "In-depth documentation on instances of :class:`!types.GenericAlias`"
msgstr ""
"Documentação aprofundada sobre instâncias de :class:`!types.GenericAlias`"

#: ../../library/types.rst:308
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` — Dicas de Tipo para Genéricos em Coleções Padrão"

#: ../../library/types.rst:309
msgid "Introducing the :class:`!types.GenericAlias` class"
msgstr "Introdução da classe :class:`!types.GenericAlias`"

#: ../../library/types.rst:313
msgid "The type of :ref:`union type expressions<types-union>`."
msgstr "O tipo de :ref:`expressões de tipo união<types-union>`."

#: ../../library/types.rst:319
msgid "This is now an alias for :class:`typing.Union`."
msgstr "Isto é agora um alias para :class:`typing.Union`."

#: ../../library/types.rst:323
msgid ""
"The type of traceback objects such as found in ``sys.exception()."
"__traceback__``."
msgstr ""
"O tipo de objetos de traceback como os encontrados em ``sys.exception()."
"__traceback__``."

#: ../../library/types.rst:325
msgid ""
"See :ref:`the language reference <traceback-objects>` for details of the "
"available attributes and operations, and guidance on creating tracebacks "
"dynamically."
msgstr ""
"Veja :ref:`a referência da linguagem <traceback-objects>` para detalhes dos "
"atributos e operações disponíveis, e orientação sobre a criação de "
"tracebacks dinamicamente."

#: ../../library/types.rst:332
msgid ""
"The type of :ref:`frame objects <frame-objects>` such as found in :attr:`tb."
"tb_frame <traceback.tb_frame>` if ``tb`` is a traceback object."
msgstr ""
"O tipo de :ref:`objetos de quadro <frame-objects>` como os encontrados em :"
"attr:`tb.tb_frame <traceback.tb_frame>` se ``tb`` for um objeto de traceback."

#: ../../library/types.rst:338
msgid ""
"The type of objects defined in extension modules with ``PyGetSetDef``, such "
"as :attr:`FrameType.f_locals <frame.f_locals>` or ``array.array.typecode``. "
"This type is used as descriptor for object attributes; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"O tipo de objetos definidos em módulos de extensão com ``PyGetSetDef``, "
"como :attr:`FrameType.f_locals <frame.f_locals>` ou ``array.array."
"typecode``. Este tipo é usado como descritor para atributos de objetos; tem "
"o mesmo propósito que o tipo :class:`property`, mas para classes definidas "
"em módulos de extensão."

#: ../../library/types.rst:347
msgid ""
"The type of objects defined in extension modules with ``PyMemberDef``, such "
"as ``datetime.timedelta.days``.  This type is used as descriptor for simple "
"C data members which use standard conversion functions; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""
"O tipo de objetos definidos em módulos de extensão com ``PyMemberDef``, como "
"``datetime.timedelta.days``. Este tipo é usado como descritor para membros "
"de dados C simples que usam funções de conversão padrão; tem o mesmo "
"propósito que o tipo :class:`property`, mas para classes definidas em "
"módulos de extensão."

#: ../../library/types.rst:352
msgid ""
"In addition, when a class is defined with a :attr:`~object.__slots__` "
"attribute, then for each slot, an instance of :class:`!MemberDescriptorType` "
"will be added as an attribute on the class. This allows the slot to appear "
"in the class's :attr:`~type.__dict__`."
msgstr ""
"Além disso, quando uma classe é definida com um atributo :attr:`~object."
"__slots__`, então para cada slot, uma instância de :class:`!"
"MemberDescriptorType` será adicionada como um atributo na classe. Isto "
"permite que o slot apareça no :attr:`~type.__dict__` da classe."

#: ../../library/types.rst:358
msgid ""
"In other implementations of Python, this type may be identical to "
"``GetSetDescriptorType``."
msgstr ""
"Em outras implementações do Python, este tipo pode ser idêntico a "
"``GetSetDescriptorType``."

#: ../../library/types.rst:363
msgid ""
"Read-only proxy of a mapping. It provides a dynamic view on the mapping's "
"entries, which means that when the mapping changes, the view reflects these "
"changes."
msgstr ""
"Proxy de leitura de um mapeamento. Fornece uma vista dinâmica nas entradas "
"do mapeamento, o que significa que quando o mapeamento muda, a vista reflete "
"essas mudanças."

#: ../../library/types.rst:371
msgid ""
"Updated to support the new union (``|``) operator from :pep:`584`, which "
"simply delegates to the underlying mapping."
msgstr ""
"Atualizado para suportar o novo operador de união (``|``) da :pep:`584`, que "
"simplesmente delega para o mapeamento subjacente."

#: ../../library/types.rst:376
msgid ""
"Return ``True`` if the underlying mapping has a key *key*, else ``False``."
msgstr ""
"Devolve ``True`` se o mapeamento subjacente tiver uma chave *key*, caso "
"contrário ``False``."

#: ../../library/types.rst:381
msgid ""
"Return the item of the underlying mapping with key *key*.  Raises a :exc:"
"`KeyError` if *key* is not in the underlying mapping."
msgstr ""
"Devolve o item do mapeamento subjacente com a chave *key*. Lança uma :exc:"
"`KeyError` se *key* não estiver no mapeamento subjacente."

#: ../../library/types.rst:386
msgid ""
"Return an iterator over the keys of the underlying mapping.  This is a "
"shortcut for ``iter(proxy.keys())``."
msgstr ""
"Devolve um iterador sobre as chaves do mapeamento subjacente. Isto é um "
"atalho para ``iter(proxy.keys())``."

#: ../../library/types.rst:391
msgid "Return the number of items in the underlying mapping."
msgstr "Devolve o número de itens no mapeamento subjacente."

#: ../../library/types.rst:395
msgid "Return a shallow copy of the underlying mapping."
msgstr "Devolve uma cópia superficial do mapeamento subjacente."

#: ../../library/types.rst:399
msgid ""
"Return the value for *key* if *key* is in the underlying mapping, else "
"*default*.  If *default* is not given, it defaults to ``None``, so that this "
"method never raises a :exc:`KeyError`."
msgstr ""
"Devolve o valor para *key* se *key* estiver no mapeamento subjacente, caso "
"contrário *default*. Se *default* não for dado, o valor predefinido é "
"``None``, de modo que este método nunca lança uma :exc:`KeyError`."

#: ../../library/types.rst:405
msgid ""
"Return a new view of the underlying mapping's items (``(key, value)`` pairs)."
msgstr ""
"Devolve uma nova vista dos itens do mapeamento subjacente (pares ``(key, "
"value)``)."

#: ../../library/types.rst:410
msgid "Return a new view of the underlying mapping's keys."
msgstr "Devolve uma nova vista das chaves do mapeamento subjacente."

#: ../../library/types.rst:414
msgid "Return a new view of the underlying mapping's values."
msgstr "Devolve uma nova vista dos valores do mapeamento subjacente."

#: ../../library/types.rst:418
msgid "Return a reverse iterator over the keys of the underlying mapping."
msgstr "Devolve um iterador reverso sobre as chaves do mapeamento subjacente."

#: ../../library/types.rst:424
msgid "Return a hash of the underlying mapping."
msgstr "Devolve um hash do mapeamento subjacente."

#: ../../library/types.rst:430
msgid "The type of :ref:`capsule objects <capsules>`."
msgstr "O tipo de :ref:`objetos cápsula <capsules>`."

#: ../../library/types.rst:436
msgid "Additional Utility Classes and Functions"
msgstr "Classes e Funções Utilitárias Adicionais"

#: ../../library/types.rst:440
msgid ""
"A simple :class:`object` subclass that provides attribute access to its "
"namespace, as well as a meaningful repr."
msgstr ""
"Uma subclasse simples de :class:`object` que fornece acesso a atributos ao "
"seu espaço de nomes, bem como uma representação significativa."

#: ../../library/types.rst:443
msgid ""
"Unlike :class:`object`, with :class:`!SimpleNamespace` you can add and "
"remove attributes."
msgstr ""
"Ao contrário de :class:`object`, com :class:`!SimpleNamespace` pode "
"adicionar e remover atributos."

#: ../../library/types.rst:446
msgid ""
":py:class:`SimpleNamespace` objects may be initialized in the same way as :"
"class:`dict`: either with keyword arguments, with a single positional "
"argument, or with both. When initialized with keyword arguments, those are "
"directly added to the underlying namespace. Alternatively, when initialized "
"with a positional argument, the underlying namespace will be updated with "
"key-value pairs from that argument (either a mapping object or an :term:"
"`iterable` object producing key-value pairs). All such keys must be strings."
msgstr ""
"Os objetos :py:class:`SimpleNamespace` podem ser inicializados da mesma "
"forma que :class:`dict`: com argumentos nomeados, com um único argumento "
"posicional, ou com ambos. Quando inicializados com argumentos nomeados, "
"estes são adicionados diretamente ao espaço de nomes subjacente. "
"Alternativamente, quando inicializados com um argumento posicional, o espaço "
"de nomes subjacente será atualizado com pares chave-valor desse argumento "
"(seja um objeto de mapeamento ou um objeto :term:`iterável` que produza "
"pares chave-valor). Todas essas chaves devem ser strings."

#: ../../library/types.rst:457
msgid "The type is roughly equivalent to the following code::"
msgstr "O tipo é aproximadamente equivalente ao seguinte código:"

#: ../../library/types.rst:459
msgid ""
"class SimpleNamespace:\n"
"    def __init__(self, mapping_or_iterable=(), /, **kwargs):\n"
"        self.__dict__.update(mapping_or_iterable)\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, "
"SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"
msgstr ""
"class SimpleNamespace:\n"
"    def __init__(self, mapping_or_iterable=(), /, **kwargs):\n"
"        self.__dict__.update(mapping_or_iterable)\n"
"        self.__dict__.update(kwargs)\n"
"\n"
"    def __repr__(self):\n"
"        items = (f\"{k}={v!r}\" for k, v in self.__dict__.items())\n"
"        return \"{}({})\".format(type(self).__name__, \", \".join(items))\n"
"\n"
"    def __eq__(self, other):\n"
"        if isinstance(self, SimpleNamespace) and isinstance(other, "
"SimpleNamespace):\n"
"           return self.__dict__ == other.__dict__\n"
"        return NotImplemented"

#: ../../library/types.rst:473
msgid ""
"``SimpleNamespace`` may be useful as a replacement for ``class NS: pass``. "
"However, for a structured record type use :func:`~collections.namedtuple` "
"instead."
msgstr ""
"``SimpleNamespace`` pode ser útil como substituto para ``class NS: pass``. "
"No entanto, para um tipo de registo estruturado, use :func:`~collections."
"namedtuple` em vez disso."

#: ../../library/types.rst:477
msgid ""
":class:`!SimpleNamespace` objects are supported by :func:`copy.replace`."
msgstr ""
"Os objetos :class:`!SimpleNamespace` são suportados por :func:`copy.replace`."

#: ../../library/types.rst:481
msgid ""
"Attribute order in the repr changed from alphabetical to insertion (like "
"``dict``)."
msgstr ""
"A ordem dos atributos na representação mudou de alfabética para ordem de "
"inserção (como em ``dict``)."

#: ../../library/types.rst:485
msgid "Added support for an optional positional argument."
msgstr "Adicionado suporte para um argumento posicional opcional."

#: ../../library/types.rst:490
msgid "Route attribute access on a class to __getattr__."
msgstr "Encaminha o acesso a atributos numa classe para __getattr__."

#: ../../library/types.rst:492
msgid ""
"This is a descriptor, used to define attributes that act differently when "
"accessed through an instance and through a class.  Instance access remains "
"normal, but access to an attribute through a class will be routed to the "
"class's __getattr__ method; this is done by raising AttributeError."
msgstr ""
"Isto é um descritor, usado para definir atributos que atuam de forma "
"diferente quando acedidos através de uma instância e através de uma classe. "
"O acesso à instância permanece normal, mas o acesso a um atributo através de "
"uma classe será encaminhado para o método __getattr__ da classe; isto é "
"feito lançando AttributeError."

#: ../../library/types.rst:497
msgid ""
"This allows one to have properties active on an instance, and have virtual "
"attributes on the class with the same name (see :class:`enum.Enum` for an "
"example)."
msgstr ""
"Isto permite ter propriedades ativas numa instância e ter atributos virtuais "
"na classe com o mesmo nome (veja :class:`enum.Enum` para um exemplo)."

#: ../../library/types.rst:504
msgid "Coroutine Utility Functions"
msgstr "Funções Utilitárias de Corrotina"

#: ../../library/types.rst:508
msgid ""
"This function transforms a :term:`generator` function into a :term:"
"`coroutine function` which returns a generator-based coroutine. The "
"generator-based coroutine is still a :term:`generator iterator`, but is also "
"considered to be a :term:`coroutine` object and is :term:`awaitable`.  "
"However, it may not necessarily implement the :meth:`~object.__await__` "
"method."
msgstr ""
"Esta função transforma uma função :term:`geradora` numa função :term:"
"`corrotina` que devolve uma corrotina baseada em gerador. A corrotina "
"baseada em gerador ainda é um :term:`iterador gerador`, mas também é "
"considerada um objeto :term:`corrotina` e é :term:`aguardável`. No entanto, "
"pode não implementar necessariamente o método :meth:`~object.__await__`."

#: ../../library/types.rst:515
msgid "If *gen_func* is a generator function, it will be modified in-place."
msgstr "Se *gen_func* for uma função geradora, será modificada no local."

#: ../../library/types.rst:517
msgid ""
"If *gen_func* is not a generator function, it will be wrapped. If it returns "
"an instance of :class:`collections.abc.Generator`, the instance will be "
"wrapped in an *awaitable* proxy object.  All other types of objects will be "
"returned as is."
msgstr ""
"Se *gen_func* não for uma função geradora, será envolvida. Se devolver uma "
"instância de :class:`collections.abc.Generator`, a instância será envolvida "
"num objeto proxy *aguardável*. Todos os outros tipos de objetos serão "
"devolvidos como estão."

#: ../../library/types.rst:189
msgid "built-in function"
msgstr "função incorporada"

#: ../../library/types.rst:189
msgid "compile"
msgstr "compile"
