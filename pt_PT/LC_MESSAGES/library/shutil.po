# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-19 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/shutil.rst:2
msgid ":mod:`!shutil` --- High-level file operations"
msgstr ":mod:`!shutil` — Operações de alto nível com ficheiros"

#: ../../library/shutil.rst:10
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr "**Código-fonte:** :source:`Lib/shutil.py`"

#: ../../library/shutil.rst:18
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""
"O módulo :mod:`shutil` oferece um número de operações de alto nível em "
"ficheiros e coleções de ficheiros. Em particular, são fornecidas funções que "
"suportam a cópia e remoção de ficheiros. Para operações em ficheiros "
"individuais, veja também o módulo :mod:`os`."

#: ../../library/shutil.rst:25
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""
"Mesmo as funções de cópia de ficheiros de nível superior (:func:`shutil."
"copy`, :func:`shutil.copy2`) não conseguem copiar todos os metadados do "
"ficheiro."

#: ../../library/shutil.rst:28
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""
"Nas plataformas POSIX, isto significa que o proprietário e o grupo do "
"ficheiro são perdidos, bem como as ACLs. No Mac OS, o fork de recursos e "
"outros metadados não são usados. Isto significa que os recursos serão "
"perdidos e os códigos de tipo e criador do ficheiro não estarão corretos. No "
"Windows, os proprietários de ficheiros, ACLs e fluxos de dados alternativos "
"não são copiados."

#: ../../library/shutil.rst:38
msgid "Directory and files operations"
msgstr "Operações de diretórios e ficheiros"

#: ../../library/shutil.rst:42
msgid ""
"Copy the contents of the :term:`file-like object <file object>` *fsrc* to "
"the file-like object *fdst*. The integer *length*, if given, is the buffer "
"size. In particular, a negative *length* value means to copy the data "
"without looping over the source data in chunks; by default the data is read "
"in chunks to avoid uncontrolled memory consumption. Note that if the current "
"file position of the *fsrc* object is not 0, only the contents from the "
"current file position to the end of the file will be copied."
msgstr ""
"Copiar o conteúdo do objeto :term:`semelhante a ficheiro <file object>` "
"*fsrc* para o objeto semelhante a ficheiro *fdst*. O inteiro *length*, se "
"fornecido, é o tamanho do buffer. Em particular, um valor *length* negativo "
"significa copiar os dados sem percorrer os dados de origem em blocos; por "
"predefinição, os dados são lidos em blocos para evitar consumo descontrolado "
"de memória. Note que, se a posição atual do ficheiro do objeto *fsrc* não "
"for 0, apenas o conteúdo desde a posição atual do ficheiro até ao fim do "
"ficheiro será copiado."

#: ../../library/shutil.rst:50
msgid ""
":func:`copyfileobj` will *not* guarantee that the destination stream has "
"been flushed on completion of the copy. If you want to read from the "
"destination at the completion of the copy operation (for example, reading "
"the contents of a temporary file that has been copied from a HTTP stream), "
"you must ensure that you have called :func:`~io.IOBase.flush` or :func:`~io."
"IOBase.close` on the file-like object before attempting to read the "
"destination file."
msgstr ""
"A função :func:`copyfileobj` *não* garante que o fluxo de destino tenha sido "
"descarregado após a conclusão da cópia. Se pretender ler a partir do destino "
"após a conclusão da operação de cópia (por exemplo, ler o conteúdo de um "
"ficheiro temporário que foi copiado a partir de um fluxo HTTP), deve "
"garantir que chamou :func:`~io.IOBase.flush` ou :func:`~io.IOBase.close` no "
"objeto semelhante a ficheiro antes de tentar ler o ficheiro de destino."

#: ../../library/shutil.rst:60
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst* and return *dst* in the most efficient way possible. *src* and *dst* "
"are :term:`path-like objects <path-like object>` or path names given as "
"strings."
msgstr ""
"Copiar o conteúdo (sem metadados) do ficheiro nomeado *src* para um ficheiro "
"nomeado *dst* e retornar *dst* da forma mais eficiente possível. *src* e "
"*dst* são :term:`objetos semelhantes a caminhos <path-like object>` ou nomes "
"de caminhos fornecidos como strings."

#: ../../library/shutil.rst:64
msgid ""
"*dst* must be the complete target file name; look at :func:`~shutil.copy` "
"for a copy that accepts a target directory path.  If *src* and *dst* specify "
"the same file, :exc:`SameFileError` is raised."
msgstr ""
"*dst* deve ser o nome completo do ficheiro de destino; veja :func:`~shutil."
"copy` para uma cópia que aceita um caminho de diretório de destino. Se *src* "
"e *dst* especificarem o mesmo ficheiro, é levantada uma exceção :exc:"
"`SameFileError`."

#: ../../library/shutil.rst:68
msgid ""
"The destination location must be writable; otherwise, an :exc:`OSError` "
"exception will be raised. If *dst* already exists, it will be replaced. "
"Special files such as character or block devices and pipes cannot be copied "
"with this function."
msgstr ""
"O local de destino deve ser gravável; caso contrário, será levantada uma "
"exceção :exc:`OSError`. Se *dst* já existir, será substituído. Ficheiros "
"especiais, como dispositivos de caracteres ou blocos e pipes, não podem ser "
"copiados com esta função."

#: ../../library/shutil.rst:73
msgid ""
"If *follow_symlinks* is false and *src* is a symbolic link, a new symbolic "
"link will be created instead of copying the file *src* points to."
msgstr ""
"Se *follow_symlinks* for falso e *src* for uma ligação simbólica, será "
"criada uma nova ligação simbólica em vez de copiar o ficheiro para o qual "
"*src* aponta."

#: ../../library/shutil.rst:77 ../../library/shutil.rst:191
#: ../../library/shutil.rst:222
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copyfile`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.copyfile`` com os "
"argumentos ``src``, ``dst``."

#: ../../library/shutil.rst:79
msgid ""
":exc:`IOError` used to be raised instead of :exc:`OSError`. Added "
"*follow_symlinks* argument. Now returns *dst*."
msgstr ""
"Anteriormente, era levantada uma :exc:`IOError` em vez de :exc:`OSError`. "
"Adicionado o argumento *follow_symlinks*. Agora retorna *dst*."

#: ../../library/shutil.rst:84
msgid ""
"Raise :exc:`SameFileError` instead of :exc:`Error`.  Since the former is a "
"subclass of the latter, this change is backward compatible."
msgstr ""
"Levanta :exc:`SameFileError` em vez de :exc:`Error`. Uma vez que a primeira "
"é uma subclasse da última, esta alteração é retrocompatível."

#: ../../library/shutil.rst:88 ../../library/shutil.rst:199
#: ../../library/shutil.rst:231 ../../library/shutil.rst:301
#: ../../library/shutil.rst:414
msgid ""
"Platform-specific fast-copy syscalls may be used internally in order to copy "
"the file more efficiently. See :ref:`shutil-platform-dependent-efficient-"
"copy-operations` section."
msgstr ""
"Chamadas de sistema de cópia rápida específicas da plataforma podem ser "
"usadas internamente para copiar o ficheiro de forma mais eficiente. Veja a "
"secção :ref:`shutil-platform-dependent-efficient-copy-operations`."

#: ../../library/shutil.rst:95
msgid ""
"This exception is raised when :func:`copyfile` or :func:`copytree` attempt "
"to copy a named pipe."
msgstr ""
"Esta exceção é levantada quando :func:`copyfile` ou :func:`copytree` tentam "
"copiar um pipe nomeado."

#: ../../library/shutil.rst:102
msgid ""
"This exception is raised if source and destination in :func:`copyfile` are "
"the same file."
msgstr ""
"Esta exceção é levantada se a origem e o destino em :func:`copyfile` forem o "
"mesmo ficheiro."

#: ../../library/shutil.rst:110
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are :term:`path-like objects <path-"
"like object>` or path names given as strings. If *follow_symlinks* is false, "
"and both *src* and *dst* are symbolic links, :func:`copymode` will attempt "
"to modify the mode of *dst* itself (rather than the file it points to).  "
"This functionality is not available on every platform; please see :func:"
"`copystat` for more information.  If :func:`copymode` cannot modify symbolic "
"links on the local platform, and it is asked to do so, it will do nothing "
"and return."
msgstr ""
"Copiar os bits de permissão de *src* para *dst*. O conteúdo do ficheiro, o "
"proprietário e o grupo não são afetados. *src* e *dst* são :term:`objetos "
"semelhantes a caminhos <path-like object>` ou nomes de caminhos fornecidos "
"como strings. Se *follow_symlinks* for falso e tanto *src* como *dst* forem "
"ligações simbólicas, :func:`copymode` tentará modificar o modo de *dst* em "
"si (em vez do ficheiro para o qual aponta). Esta funcionalidade não está "
"disponível em todas as plataformas; consulte :func:`copystat` para mais "
"informações. Se :func:`copymode` não puder modificar ligações simbólicas na "
"plataforma local e for solicitado a fazê-lo, não fará nada e retornará."

#: ../../library/shutil.rst:120 ../../library/shutil.rst:193
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copymode`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.copymode`` com os "
"argumentos ``src``, ``dst``."

#: ../../library/shutil.rst:122
msgid "Added *follow_symlinks* argument."
msgstr "Adicionado o argumento *follow_symlinks*."

#: ../../library/shutil.rst:127
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  On Linux, :func:`copystat` also copies the "
"\"extended attributes\" where possible.  The file contents, owner, and group "
"are unaffected.  *src* and *dst* are :term:`path-like objects <path-like "
"object>` or path names given as strings."
msgstr ""
"Copiar os bits de permissão, a hora do último acesso, a hora da última "
"modificação e as flags de *src* para *dst*. No Linux, :func:`copystat` "
"também copia os \"atributos estendidos\" onde possível. O conteúdo do "
"ficheiro, o proprietário e o grupo não são afetados. *src* e *dst* são :term:"
"`objetos semelhantes a caminhos <path-like object>` ou nomes de caminhos "
"fornecidos como strings."

#: ../../library/shutil.rst:133
msgid ""
"If *follow_symlinks* is false, and *src* and *dst* both refer to symbolic "
"links, :func:`copystat` will operate on the symbolic links themselves rather "
"than the files the symbolic links refer to—reading the information from the "
"*src* symbolic link, and writing the information to the *dst* symbolic link."
msgstr ""
"Se *follow_symlinks* for falso e *src* e *dst* se referirem ambos a ligações "
"simbólicas, :func:`copystat` operará nas próprias ligações simbólicas em vez "
"dos ficheiros para os quais as ligações simbólicas apontam — lendo as "
"informações da ligação simbólica *src* e escrevendo as informações na "
"ligação simbólica *dst*."

#: ../../library/shutil.rst:142
msgid ""
"Not all platforms provide the ability to examine and modify symbolic links.  "
"Python itself can tell you what functionality is locally available."
msgstr ""
"Nem todas as plataformas fornecem a capacidade de examinar e modificar "
"ligações simbólicas. O próprio Python pode informá-lo sobre que "
"funcionalidades estão disponíveis localmente."

#: ../../library/shutil.rst:146
msgid ""
"If ``os.chmod in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the permission bits of a symbolic link."
msgstr ""
"Se ``os.chmod in os.supports_follow_symlinks`` for ``True``, :func:"
"`copystat` pode modificar os bits de permissão de uma ligação simbólica."

#: ../../library/shutil.rst:150
msgid ""
"If ``os.utime in os.supports_follow_symlinks`` is ``True``, :func:`copystat` "
"can modify the last access and modification times of a symbolic link."
msgstr ""
"Se ``os.utime in os.supports_follow_symlinks`` for ``True``, :func:"
"`copystat` pode modificar as horas do último acesso e modificação de uma "
"ligação simbólica."

#: ../../library/shutil.rst:154
msgid ""
"If ``os.chflags in os.supports_follow_symlinks`` is ``True``, :func:"
"`copystat` can modify the flags of a symbolic link.  (``os.chflags`` is not "
"available on all platforms.)"
msgstr ""
"Se ``os.chflags in os.supports_follow_symlinks`` for ``True``, :func:"
"`copystat` pode modificar as flags de uma ligação simbólica. (``os.chflags`` "
"não está disponível em todas as plataformas.)"

#: ../../library/shutil.rst:159
msgid ""
"On platforms where some or all of this functionality is unavailable, when "
"asked to modify a symbolic link, :func:`copystat` will copy everything it "
"can. :func:`copystat` never returns failure."
msgstr ""
"Em plataformas onde alguma ou toda esta funcionalidade não está disponível, "
"quando solicitado para modificar uma ligação simbólica, :func:`copystat` "
"copiará tudo o que puder. :func:`copystat` nunca retorna falha."

#: ../../library/shutil.rst:164
msgid "Please see :data:`os.supports_follow_symlinks` for more information."
msgstr "Consulte :data:`os.supports_follow_symlinks` para mais informações."

#: ../../library/shutil.rst:167 ../../library/shutil.rst:224
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copystat`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.copystat`` com os "
"argumentos ``src``, ``dst``."

#: ../../library/shutil.rst:169
msgid ""
"Added *follow_symlinks* argument and support for Linux extended attributes."
msgstr ""
"Adicionado o argumento *follow_symlinks* e suporte para atributos estendidos "
"do Linux."

#: ../../library/shutil.rst:174
msgid ""
"Copies the file *src* to the file or directory *dst*.  *src* and *dst* "
"should be :term:`path-like objects <path-like object>` or strings.  If *dst* "
"specifies a directory, the file will be copied into *dst* using the base "
"filename from *src*. If *dst* specifies a file that already exists, it will "
"be replaced. Returns the path to the newly created file."
msgstr ""
"Copiar o ficheiro *src* para o ficheiro ou diretório *dst*. *src* e *dst* "
"devem ser :term:`objetos semelhantes a caminhos <path-like object>` ou "
"strings. Se *dst* especificar um diretório, o ficheiro será copiado para "
"*dst* usando o nome base de *src*. Se *dst* especificar um ficheiro que já "
"existe, será substituído. Retorna o caminho para o ficheiro recém-criado."

#: ../../library/shutil.rst:180
msgid ""
"If *follow_symlinks* is false, and *src* is a symbolic link, *dst* will be "
"created as a symbolic link.  If *follow_symlinks* is true and *src* is a "
"symbolic link, *dst* will be a copy of the file *src* refers to."
msgstr ""
"Se *follow_symlinks* for falso e *src* for uma ligação simbólica, *dst* será "
"criado como uma ligação simbólica. Se *follow_symlinks* for verdadeiro e "
"*src* for uma ligação simbólica, *dst* será uma cópia do ficheiro para o "
"qual *src* aponta."

#: ../../library/shutil.rst:185
msgid ""
":func:`~shutil.copy` copies the file data and the file's permission mode "
"(see :func:`os.chmod`).  Other metadata, like the file's creation and "
"modification times, is not preserved. To preserve all file metadata from the "
"original, use :func:`~shutil.copy2` instead."
msgstr ""
":func:`~shutil.copy` copia os dados do ficheiro e o modo de permissão do "
"ficheiro (veja :func:`os.chmod`). Outros metadados, como as horas de criação "
"e modificação do ficheiro, não são preservados. Para preservar todos os "
"metadados do ficheiro original, use :func:`~shutil.copy2` em vez disso."

#: ../../library/shutil.rst:195
msgid ""
"Added *follow_symlinks* argument. Now returns path to the newly created file."
msgstr ""
"Adicionado o argumento *follow_symlinks*. Agora retorna o caminho para o "
"ficheiro recém-criado."

#: ../../library/shutil.rst:206
msgid ""
"Identical to :func:`~shutil.copy` except that :func:`copy2` also attempts to "
"preserve file metadata."
msgstr ""
"Idêntico a :func:`~shutil.copy`, exceto que :func:`copy2` também tenta "
"preservar os metadados do ficheiro."

#: ../../library/shutil.rst:209
msgid ""
"When *follow_symlinks* is false, and *src* is a symbolic link, :func:`copy2` "
"attempts to copy all metadata from the *src* symbolic link to the newly "
"created *dst* symbolic link. However, this functionality is not available on "
"all platforms. On platforms where some or all of this functionality is "
"unavailable, :func:`copy2` will preserve all the metadata it can; :func:"
"`copy2` never raises an exception because it cannot preserve file metadata."
msgstr ""
"Quando *follow_symlinks* é falso e *src* é uma ligação simbólica, :func:"
"`copy2` tenta copiar todos os metadados da ligação simbólica *src* para a "
"ligação simbólica *dst* recém-criada. No entanto, esta funcionalidade não "
"está disponível em todas as plataformas. Em plataformas onde alguma ou toda "
"esta funcionalidade não está disponível, :func:`copy2` preservará todos os "
"metadados que puder; :func:`copy2` nunca levanta uma exceção porque não pode "
"preservar os metadados do ficheiro."

#: ../../library/shutil.rst:218
msgid ""
":func:`copy2` uses :func:`copystat` to copy the file metadata. Please see :"
"func:`copystat` for more information about platform support for modifying "
"symbolic link metadata."
msgstr ""
":func:`copy2` usa :func:`copystat` para copiar os metadados do ficheiro. "
"Consulte :func:`copystat` para mais informações sobre o suporte da "
"plataforma para modificar metadados de ligações simbólicas."

#: ../../library/shutil.rst:226
msgid ""
"Added *follow_symlinks* argument, try to copy extended file system "
"attributes too (currently Linux only). Now returns path to the newly created "
"file."
msgstr ""
"Adicionado o argumento *follow_symlinks*, tenta também copiar atributos "
"estendidos do sistema de ficheiros (atualmente apenas Linux). Agora retorna "
"o caminho para o ficheiro recém-criado."

#: ../../library/shutil.rst:238
msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""
"Esta função de fábrica cria uma função que pode ser usada como um objeto "
"chamável para o argumento *ignore* de :func:`copytree`, ignorando ficheiros "
"e diretórios que correspondam a um dos *patterns* fornecidos no estilo glob. "
"Veja o exemplo abaixo."

#: ../../library/shutil.rst:247
msgid ""
"Recursively copy an entire directory tree rooted at *src* to a directory "
"named *dst* and return the destination directory.  All intermediate "
"directories needed to contain *dst* will also be created by default."
msgstr ""
"Copiar recursivamente uma árvore de diretórios inteira enraizada em *src* "
"para um diretório nomeado *dst* e retornar o diretório de destino. Todos os "
"diretórios intermédios necessários para conter *dst* também serão criados "
"por predefinição."

#: ../../library/shutil.rst:251
msgid ""
"Permissions and times of directories are copied with :func:`copystat`, "
"individual files are copied using :func:`~shutil.copy2`."
msgstr ""
"As permissões e horas dos diretórios são copiadas com :func:`copystat`, os "
"ficheiros individuais são copiados usando :func:`~shutil.copy2`."

#: ../../library/shutil.rst:254
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree and the metadata of the original links will "
"be copied as far as the platform allows; if false or omitted, the contents "
"and metadata of the linked files are copied to the new tree."
msgstr ""
"Se *symlinks* for verdadeiro, as ligações simbólicas na árvore de origem são "
"representadas como ligações simbólicas na nova árvore e os metadados das "
"ligações originais serão copiados tanto quanto a plataforma permitir; se for "
"falso ou omitido, o conteúdo e os metadados dos ficheiros ligados são "
"copiados para a nova árvore."

#: ../../library/shutil.rst:259
msgid ""
"When *symlinks* is false, if the file pointed to by the symlink doesn't "
"exist, an exception will be added in the list of errors raised in an :exc:"
"`Error` exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""
"Quando *symlinks* é falso, se o ficheiro apontado pela ligação simbólica não "
"existir, uma exceção será adicionada à lista de erros levantados numa "
"exceção :exc:`Error` no final do processo de cópia. Pode definir a flag "
"opcional *ignore_dangling_symlinks* como verdadeira se pretender silenciar "
"esta exceção. Note que esta opção não tem efeito em plataformas que não "
"suportam :func:`os.symlink`."

#: ../../library/shutil.rst:266
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""
"Se *ignore* for fornecido, deve ser um objeto chamável que receberá como "
"seus argumentos o diretório que está a ser visitado por :func:`copytree` e "
"uma lista do seu conteúdo, conforme retornado por :func:`os.listdir`. Uma "
"vez que :func:`copytree` é chamado recursivamente, o objeto chamável "
"*ignore* será chamado uma vez para cada diretório que é copiado. O objeto "
"chamável deve retornar uma sequência de nomes de diretórios e ficheiros "
"relativos ao diretório atual (ou seja, um subconjunto dos itens no seu "
"segundo argumento); estes nomes serão então ignorados no processo de cópia. :"
"func:`ignore_patterns` pode ser usado para criar um objeto chamável que "
"ignore nomes com base em padrões no estilo glob."

#: ../../library/shutil.rst:276
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""
"Se ocorrerem exceção(ões), uma :exc:`Error` é levantada com uma lista de "
"razões."

#: ../../library/shutil.rst:278
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`~shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`~shutil.copy`) can be used."
msgstr ""
"Se *copy_function* for fornecido, deve ser um objeto chamável que será usado "
"para copiar cada ficheiro. Será chamado com o caminho de origem e o caminho "
"de destino como argumentos. Por predefinição, :func:`~shutil.copy2` é usado, "
"mas qualquer função que suporte a mesma assinatura (como :func:`~shutil."
"copy`) pode ser usada."

#: ../../library/shutil.rst:283
msgid ""
"If *dirs_exist_ok* is false (the default) and *dst* already exists, a :exc:"
"`FileExistsError` is raised. If *dirs_exist_ok* is true, the copying "
"operation will continue if it encounters existing directories, and files "
"within the *dst* tree will be overwritten by corresponding files from the "
"*src* tree."
msgstr ""
"Se *dirs_exist_ok* for falso (predefinição) e *dst* já existir, é levantado "
"um :exc:`FileExistsError`. Se *dirs_exist_ok* for verdadeiro, a operação de "
"cópia continuará se encontrar diretórios existentes, e os ficheiros dentro "
"da árvore *dst* serão substituídos pelos ficheiros correspondentes da árvore "
"*src*."

#: ../../library/shutil.rst:289
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.copytree`` with "
"arguments ``src``, ``dst``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.copytree`` com os "
"argumentos ``src``, ``dst``."

#: ../../library/shutil.rst:291
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function. Added the *ignore_dangling_symlinks* argument to silence dangling "
"symlinks errors when *symlinks* is false."
msgstr ""
"Adicionado o argumento *copy_function* para permitir fornecer uma função de "
"cópia personalizada. Adicionado o argumento *ignore_dangling_symlinks* para "
"silenciar erros de ligações simbólicas pendentes quando *symlinks* é falso."

#: ../../library/shutil.rst:297
msgid "Copy metadata when *symlinks* is false. Now returns *dst*."
msgstr "Copiar metadados quando *symlinks* é falso. Agora retorna *dst*."

#: ../../library/shutil.rst:306
msgid "Added the *dirs_exist_ok* parameter."
msgstr "Adicionado o parâmetro *dirs_exist_ok*."

#: ../../library/shutil.rst:313
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onexc* or *onerror* or, if both "
"are omitted, exceptions are propagated to the caller."
msgstr ""
"Apagar uma árvore de diretórios inteira; *path* deve apontar para um "
"diretório (mas não para uma ligação simbólica para um diretório). Se "
"*ignore_errors* for verdadeiro, os erros resultantes de remoções falhadas "
"serão ignorados; se for falso ou omitido, esses erros são tratados chamando "
"um manipulador especificado por *onexc* ou *onerror* ou, se ambos forem "
"omitidos, as exceções são propagadas para o chamador."

#: ../../library/shutil.rst:319
msgid ""
"This function can support :ref:`paths relative to directory descriptors "
"<dir_fd>`."
msgstr ""
"Esta função pode suportar :ref:`caminhos relativos a descritores de "
"diretório <dir_fd>`."

#: ../../library/shutil.rst:324
msgid ""
"On platforms that support the necessary fd-based functions a symlink attack "
"resistant version of :func:`rmtree` is used by default.  On other platforms, "
"the :func:`rmtree` implementation is susceptible to a symlink attack: given "
"proper timing and circumstances, attackers can manipulate symlinks on the "
"filesystem to delete files they wouldn't be able to access otherwise.  "
"Applications can use the :data:`rmtree.avoids_symlink_attacks` function "
"attribute to determine which case applies."
msgstr ""
"Em plataformas que suportam as funções necessárias baseadas em fd, uma "
"versão de :func:`rmtree` resistente a ataques de ligação simbólica é usada "
"por predefinição. Noutras plataformas, a implementação de :func:`rmtree` é "
"susceptível a um ataque de ligação simbólica: dado o timing e as "
"circunstâncias adequadas, os atacantes podem manipular ligações simbólicas "
"no sistema de ficheiros para apagar ficheiros aos quais não teriam acesso de "
"outra forma. As aplicações podem usar o atributo de função :data:`rmtree."
"avoids_symlink_attacks` para determinar qual caso se aplica."

#: ../../library/shutil.rst:332
msgid ""
"If *onexc* is provided, it must be a callable that accepts three parameters: "
"*function*, *path*, and *excinfo*."
msgstr ""
"Se *onexc* for fornecido, deve ser um objeto chamável que aceite três "
"parâmetros: *function*, *path* e *excinfo*."

#: ../../library/shutil.rst:335
msgid ""
"The first parameter, *function*, is the function which raised the exception; "
"it depends on the platform and implementation.  The second parameter, "
"*path*, will be the path name passed to *function*.  The third parameter, "
"*excinfo*, is the exception that was raised. Exceptions raised by *onexc* "
"will not be caught."
msgstr ""
"O primeiro parâmetro, *function*, é a função que levantou a exceção; depende "
"da plataforma e da implementação. O segundo parâmetro, *path*, será o nome "
"do caminho passado para *function*. O terceiro parâmetro, *excinfo*, é a "
"exceção que foi levantada. Exceções levantadas por *onexc* não serão "
"capturadas."

#: ../../library/shutil.rst:341
msgid ""
"The deprecated *onerror* is similar to *onexc*, except that the third "
"parameter it receives is the tuple returned from :func:`sys.exc_info`."
msgstr ""
"O *onerror* obsoleto é semelhante a *onexc*, exceto que o terceiro parâmetro "
"que recebe é o tuplo retornado de :func:`sys.exc_info`."

#: ../../library/shutil.rst:345
msgid ""
":ref:`shutil-rmtree-example` for an example of handling the removal of a "
"directory tree that contains read-only files."
msgstr ""
":ref:`shutil-rmtree-example` para um exemplo de como lidar com a remoção de "
"uma árvore de diretórios que contém ficheiros de apenas leitura."

#: ../../library/shutil.rst:348
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.rmtree`` with arguments "
"``path``, ``dir_fd``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.rmtree`` com os "
"argumentos ``path``, ``dir_fd``."

#: ../../library/shutil.rst:350
msgid ""
"Added a symlink attack resistant version that is used automatically if "
"platform supports fd-based functions."
msgstr ""
"Adicionada uma versão resistente a ataques de ligação simbólica que é usada "
"automaticamente se a plataforma suportar funções baseadas em fd."

#: ../../library/shutil.rst:354
msgid ""
"On Windows, will no longer delete the contents of a directory junction "
"before removing the junction."
msgstr ""
"No Windows, já não apagará o conteúdo de uma junção de diretório antes de "
"remover a junção."

#: ../../library/shutil.rst:358
msgid "Added the *dir_fd* parameter."
msgstr "Adicionado o parâmetro *dir_fd*."

#: ../../library/shutil.rst:361
msgid "Added the *onexc* parameter, deprecated *onerror*."
msgstr "Adicionado o parâmetro *onexc*, *onerror* obsoleto."

#: ../../library/shutil.rst:364
msgid ""
":func:`!rmtree` now ignores :exc:`FileNotFoundError` exceptions for all but "
"the top-level path. Exceptions other than :exc:`OSError` and subclasses of :"
"exc:`!OSError` are now always propagated to the caller."
msgstr ""
":func:`!rmtree` agora ignora exceções :exc:`FileNotFoundError` para todos os "
"caminhos exceto o de nível superior. Exceções que não sejam :exc:`OSError` e "
"subclasses de :exc:`!OSError` são agora sempre propagadas para o chamador."

#: ../../library/shutil.rst:372
msgid ""
"Indicates whether the current platform and implementation provides a symlink "
"attack resistant version of :func:`rmtree`.  Currently this is only true for "
"platforms supporting fd-based directory access functions."
msgstr ""
"Indica se a plataforma e implementação atuais fornecem uma versão de :func:"
"`rmtree` resistente a ataques de ligação simbólica. Atualmente, isto só é "
"verdadeiro para plataformas que suportam funções de acesso a diretórios "
"baseadas em fd."

#: ../../library/shutil.rst:381
msgid ""
"Recursively move a file or directory (*src*) to another location and return "
"the destination."
msgstr ""
"Mover recursivamente um ficheiro ou diretório (*src*) para outro local e "
"retornar o destino."

#: ../../library/shutil.rst:384
msgid ""
"If *dst* is an existing directory or a symlink to a directory, then *src* is "
"moved inside that directory. The destination path in that directory must not "
"already exist."
msgstr ""
"Se *dst* for um diretório existente ou uma ligação simbólica para um "
"diretório, então *src* é movido para dentro desse diretório. O caminho de "
"destino nesse diretório não deve já existir."

#: ../../library/shutil.rst:388
msgid ""
"If *dst* already exists but is not a directory, it may be overwritten "
"depending on :func:`os.rename` semantics."
msgstr ""
"Se *dst* já existir, mas não for um diretório, pode ser substituído, "
"dependendo da semântica de :func:`os.rename`."

#: ../../library/shutil.rst:391
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used. Otherwise, *src* is copied to the destination using *copy_function* "
"and then removed.  In case of symlinks, a new symlink pointing to the target "
"of *src* will be created as the destination and *src* will be removed."
msgstr ""
"Se o destino estiver no sistema de ficheiros atual, então :func:`os.rename` "
"é usado. Caso contrário, *src* é copiado para o destino usando "
"*copy_function* e depois removido. No caso de ligações simbólicas, uma nova "
"ligação simbólica apontando para o alvo de *src* será criada como destino e "
"*src* será removido."

#: ../../library/shutil.rst:396
msgid ""
"If *copy_function* is given, it must be a callable that takes two arguments, "
"*src* and the destination, and will be used to copy *src* to the destination "
"if :func:`os.rename` cannot be used.  If the source is a directory, :func:"
"`copytree` is called, passing it the *copy_function*. The default "
"*copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the "
"*copy_function* allows the move to succeed when it is not possible to also "
"copy the metadata, at the expense of not copying any of the metadata."
msgstr ""
"Se *copy_function* for fornecido, deve ser um objeto chamável que aceite "
"dois argumentos, *src* e o destino, e será usado para copiar *src* para o "
"destino se :func:`os.rename` não puder ser usado. Se a origem for um "
"diretório, :func:`copytree` é chamado, passando-lhe a *copy_function*. A "
"*copy_function* predefinida é :func:`copy2`. Usar :func:`~shutil.copy` como "
"*copy_function* permite que a movimentação tenha sucesso quando não for "
"possível copiar também os metadados, à custa de não copiar quaisquer "
"metadados."

#: ../../library/shutil.rst:404
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.move`` with arguments "
"``src``, ``dst``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.move`` com os "
"argumentos ``src``, ``dst``."

#: ../../library/shutil.rst:406
msgid ""
"Added explicit symlink handling for foreign filesystems, thus adapting it to "
"the behavior of GNU's :program:`mv`. Now returns *dst*."
msgstr ""
"Adicionado tratamento explícito de ligações simbólicas para sistemas de "
"ficheiros estrangeiros, adaptando-o assim ao comportamento do :program:`mv` "
"do GNU. Agora retorna *dst*."

#: ../../library/shutil.rst:411
msgid "Added the *copy_function* keyword argument."
msgstr "Adicionado o argumento de palavra-chave *copy_function*."

#: ../../library/shutil.rst:419
msgid "Accepts a :term:`path-like object` for both *src* and *dst*."
msgstr "Aceita um :term:`objeto semelhante a caminho` para *src* e *dst*."

#: ../../library/shutil.rst:424
msgid ""
"Return disk usage statistics about the given path as a :term:`named tuple` "
"with the attributes *total*, *used* and *free*, which are the amount of "
"total, used and free space, in bytes. *path* may be a file or a directory."
msgstr ""
"Retornar estatísticas de utilização do disco sobre o caminho dado como um :"
"term:`tuplo nomeado` com os atributos *total*, *used* e *free*, que são a "
"quantidade de espaço total, usado e livre, em bytes. *path* pode ser um "
"ficheiro ou um diretório."

#: ../../library/shutil.rst:431
msgid ""
"On Unix filesystems, *path* must point to a path within a **mounted** "
"filesystem partition. On those platforms, CPython doesn't attempt to "
"retrieve disk usage information from non-mounted filesystems."
msgstr ""
"Nos sistemas de ficheiros Unix, *path* deve apontar para um caminho dentro "
"de uma partição de sistema de ficheiros **montada**. Nessas plataformas, o "
"CPython não tenta recuperar informações de utilização do disco de sistemas "
"de ficheiros não montados."

#: ../../library/shutil.rst:437
msgid "On Windows, *path* can now be a file or directory."
msgstr "No Windows, *path* pode agora ser um ficheiro ou diretório."

#: ../../library/shutil.rst:440 ../../library/shutil.rst:454
msgid "Availability"
msgstr "Disponibilidade"

#: ../../library/shutil.rst:445
msgid "Change owner *user* and/or *group* of the given *path*."
msgstr "Alterar o proprietário *user* e/ou *group* do *path* dado."

#: ../../library/shutil.rst:447
msgid ""
"*user* can be a system user name or a uid; the same applies to *group*. At "
"least one argument is required."
msgstr ""
"*user* pode ser um nome de utilizador do sistema ou um uid; o mesmo se "
"aplica a *group*. Pelo menos um argumento é necessário."

#: ../../library/shutil.rst:450
msgid "See also :func:`os.chown`, the underlying function."
msgstr "Veja também :func:`os.chown`, a função subjacente."

#: ../../library/shutil.rst:452
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.chown`` with arguments "
"``path``, ``user``, ``group``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.chown`` com os "
"argumentos ``path``, ``user``, ``group``."

#: ../../library/shutil.rst:458
msgid "Added *dir_fd* and *follow_symlinks* parameters."
msgstr "Adicionados os parâmetros *dir_fd* e *follow_symlinks*."

#: ../../library/shutil.rst:464
msgid ""
"Return the path to an executable which would be run if the given *cmd* was "
"called.  If no *cmd* would be called, return ``None``."
msgstr ""
"Retornar o caminho para um executável que seria executado se o *cmd* dado "
"fosse chamado. Se nenhum *cmd* fosse chamado, retornar ``None``."

#: ../../library/shutil.rst:467
msgid ""
"*mode* is a permission mask passed to :func:`os.access`, by default "
"determining if the file exists and is executable."
msgstr ""
"*mode* é uma máscara de permissão passada a :func:`os.access`, por "
"predefinição, determinando se o ficheiro existe e é executável."

#: ../../library/shutil.rst:470
msgid ""
"*path* is a \"``PATH`` string\" specifying the directories to look in, "
"delimited by :data:`os.pathsep`. When no *path* is specified, the :envvar:"
"`PATH` environment variable is read from :data:`os.environ`, falling back "
"to :data:`os.defpath` if it is not set."
msgstr ""
"*path* é uma string \"``PATH``\" que especifica os diretórios a procurar, "
"delimitados por :data:`os.pathsep`. Quando nenhum *path* é especificado, a "
"variável de ambiente :envvar:`PATH` é lida de :data:`os.environ`, recuando "
"para :data:`os.defpath` se não estiver definida."

#: ../../library/shutil.rst:475
msgid ""
"If *cmd* contains a directory component, :func:`!which` only checks the "
"specified path directly and does not search the directories listed in *path* "
"or in the system's :envvar:`PATH` environment variable."
msgstr ""
"Se *cmd* contiver um componente de diretório, :func:`!which` verifica apenas "
"o caminho especificado diretamente e não procura nos diretórios listados em "
"*path* ou na variável de ambiente :envvar:`PATH` do sistema."

#: ../../library/shutil.rst:479
msgid ""
"On Windows, the current directory is prepended to the *path* if *mode* does "
"not include ``os.X_OK``. When the *mode* does include ``os.X_OK``, the "
"Windows API ``NeedCurrentDirectoryForExePathW`` will be consulted to "
"determine if the current directory should be prepended to *path*. To avoid "
"consulting the current working directory for executables: set the "
"environment variable ``NoDefaultCurrentDirectoryInExePath``."
msgstr ""
"No Windows, o diretório atual é adicionado ao início de *path* se *mode* não "
"incluir ``os.X_OK``. Quando o *mode* incluir ``os.X_OK``, a API do Windows "
"``NeedCurrentDirectoryForExePathW`` será consultada para determinar se o "
"diretório atual deve ser adicionado ao início de *path*. Para evitar "
"consultar o diretório de trabalho atual para executáveis: defina a variável "
"de ambiente ``NoDefaultCurrentDirectoryInExePath``."

#: ../../library/shutil.rst:486
msgid ""
"Also on Windows, the :envvar:`PATHEXT` environment variable is used to "
"resolve commands that may not already include an extension. For example, if "
"you call ``shutil.which(\"python\")``, :func:`which` will search ``PATHEXT`` "
"to know that it should look for ``python.exe`` within the *path* "
"directories. For example, on Windows::"
msgstr ""
"Também no Windows, a variável de ambiente :envvar:`PATHEXT` é usada para "
"resolver comandos que podem não incluir já uma extensão. Por exemplo, se "
"chamar ``shutil.which(\"python\")``, :func:`which` procurará em ``PATHEXT`` "
"para saber que deve procurar ``python.exe`` dentro dos diretórios *path*. "
"Por exemplo, no Windows::"

#: ../../library/shutil.rst:492
msgid ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

#: ../../library/shutil.rst:495
msgid ""
"This is also applied when *cmd* is a path that contains a directory "
"component::"
msgstr ""
"Isto também é aplicado quando *cmd* é um caminho que contém um componente de "
"diretório::"

#: ../../library/shutil.rst:498
msgid ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"
msgstr ""
">>> shutil.which(\"C:\\\\Python33\\\\python\")\n"
"'C:\\\\Python33\\\\python.EXE'"

#: ../../library/shutil.rst:503
msgid ""
"The :class:`bytes` type is now accepted.  If *cmd* type is :class:`bytes`, "
"the result type is also :class:`bytes`."
msgstr ""
"O tipo :class:`bytes` é agora aceite. Se o tipo de *cmd* for :class:`bytes`, "
"o tipo do resultado também é :class:`bytes`."

#: ../../library/shutil.rst:507
msgid ""
"On Windows, the current directory is no longer prepended to the search path "
"if *mode* includes ``os.X_OK`` and WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` is false, else the current "
"directory is prepended even if it is already in the search path; ``PATHEXT`` "
"is used now even when *cmd* includes a directory component or ends with an "
"extension that is in ``PATHEXT``; and filenames that have no extension can "
"now be found."
msgstr ""
"No Windows, o diretório atual já não é adicionado ao início do caminho de "
"procura se *mode* incluir ``os.X_OK`` e WinAPI "
"``NeedCurrentDirectoryForExePathW(cmd)`` for falso; caso contrário, o "
"diretório atual é adicionado ao início, mesmo que já esteja no caminho de "
"procura; ``PATHEXT`` é agora usado mesmo quando *cmd* inclui um componente "
"de diretório ou termina com uma extensão que está em ``PATHEXT``; e nomes de "
"ficheiros que não têm extensão podem agora ser encontrados."

#: ../../library/shutil.rst:518
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""
"Esta exceção coleciona exceções que são levantadas durante uma operação de "
"múltiplos ficheiros. Para :func:`copytree`, o argumento da exceção é uma "
"lista de 3-tuplos (*srcname*, *dstname*, *exception*)."

#: ../../library/shutil.rst:525
msgid "Platform-dependent efficient copy operations"
msgstr "Operações de cópia eficientes dependentes da plataforma"

#: ../../library/shutil.rst:527
msgid ""
"Starting from Python 3.8, all functions involving a file copy (:func:"
"`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree`, and :func:"
"`move`) may use platform-specific \"fast-copy\" syscalls in order to copy "
"the file more efficiently (see :issue:`33671`). \"fast-copy\" means that the "
"copying operation occurs within the kernel, avoiding the use of userspace "
"buffers in Python as in \"``outfd.write(infd.read())``\"."
msgstr ""
"A partir do Python 3.8, todas as funções que envolvem uma cópia de ficheiro "
"(:func:`copyfile`, :func:`~shutil.copy`, :func:`copy2`, :func:`copytree` e :"
"func:`move`) podem usar chamadas de sistema \"fast-copy\" específicas da "
"plataforma para copiar o ficheiro de forma mais eficiente (veja :issue:"
"`33671`). \"fast-copy\" significa que a operação de cópia ocorre dentro do "
"núcleo, evitando o uso de buffers no espaço do utilizador em Python, como em "
"\"``outfd.write(infd.read())``\"."

#: ../../library/shutil.rst:535
msgid "On macOS `fcopyfile`_ is used to copy the file content (not metadata)."
msgstr ""
"No macOS, `fcopyfile`_ é usado para copiar o conteúdo do ficheiro (não os "
"metadados)."

#: ../../library/shutil.rst:537
msgid "On Linux :func:`os.copy_file_range` or :func:`os.sendfile` is used."
msgstr "No Linux, :func:`os.copy_file_range` ou :func:`os.sendfile` é usado."

#: ../../library/shutil.rst:539
msgid "On Solaris :func:`os.sendfile` is used."
msgstr "No Solaris, :func:`os.sendfile` é usado."

#: ../../library/shutil.rst:541
msgid ""
"On Windows :func:`shutil.copyfile` uses a bigger default buffer size (1 MiB "
"instead of 64 KiB) and a :func:`memoryview`-based variant of :func:`shutil."
"copyfileobj` is used."
msgstr ""
"No Windows, :func:`shutil.copyfile` usa um tamanho de buffer predefinido "
"maior (1 MiB em vez de 64 KiB) e uma variante de :func:`shutil.copyfileobj` "
"baseada em :func:`memoryview` é usada."

#: ../../library/shutil.rst:545
msgid ""
"If the fast-copy operation fails and no data was written in the destination "
"file then shutil will silently fallback on using less efficient :func:"
"`copyfileobj` function internally."
msgstr ""
"Se a operação de cópia rápida falhar e nenhum dado tiver sido escrito no "
"ficheiro de destino, então shutil recuará silenciosamente para usar a "
"função :func:`copyfileobj` menos eficiente internamente."

#: ../../library/shutil.rst:551
msgid "Solaris now uses :func:`os.sendfile`."
msgstr "O Solaris agora usa :func:`os.sendfile`."

#: ../../library/shutil.rst:554
msgid ""
"Copy-on-write or server-side copy may be used internally via :func:`os."
"copy_file_range` on supported Linux filesystems."
msgstr ""
"A cópia na escrita ou a cópia do lado do servidor pode ser usada "
"internamente através de :func:`os.copy_file_range` em sistemas de ficheiros "
"Linux suportados."

#: ../../library/shutil.rst:561
msgid "copytree example"
msgstr "Exemplo de copytree"

#: ../../library/shutil.rst:563
msgid "An example that uses the :func:`ignore_patterns` helper::"
msgstr "Um exemplo que usa o auxiliar :func:`ignore_patterns`::"

#: ../../library/shutil.rst:565
msgid ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"
msgstr ""
"from shutil import copytree, ignore_patterns\n"
"\n"
"copytree(source, destination, ignore=ignore_patterns('*.pyc', 'tmp*'))"

#: ../../library/shutil.rst:569
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""
"Isto copiará tudo exceto ficheiros ``.pyc`` e ficheiros ou diretórios cujo "
"nome começa com ``tmp``."

#: ../../library/shutil.rst:572
msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr ""
"Outro exemplo que usa o argumento *ignore* para adicionar uma chamada de "
"registo::"

#: ../../library/shutil.rst:574
msgid ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('Working in %s', path)\n"
"    return []   # nothing will be ignored\n"
"\n"
"copytree(source, destination, ignore=_logpath)"
msgstr ""
"from shutil import copytree\n"
"import logging\n"
"\n"
"def _logpath(path, names):\n"
"    logging.info('A trabalhar em %s', path)\n"
"    return []   # nada será ignorado\n"
"\n"
"copytree(source, destination, ignore=_logpath)"

#: ../../library/shutil.rst:587
msgid "rmtree example"
msgstr "Exemplo de rmtree"

#: ../../library/shutil.rst:589
msgid ""
"This example shows how to remove a directory tree on Windows where some of "
"the files have their read-only bit set. It uses the onexc callback to clear "
"the readonly bit and reattempt the remove. Any subsequent failure will "
"propagate. ::"
msgstr ""
"Este exemplo mostra como remover uma árvore de diretórios no Windows onde "
"alguns dos ficheiros têm o bit de apenas leitura definido. Usa o callback "
"onexc para limpar o bit de apenas leitura e tentar novamente a remoção. "
"Qualquer falha subsequente será propagada. ::"

#: ../../library/shutil.rst:594
msgid ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Clear the readonly bit and reattempt the removal\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"
msgstr ""
"import os, stat\n"
"import shutil\n"
"\n"
"def remove_readonly(func, path, _):\n"
"    \"Limpar o bit de apenas leitura e tentar novamente a remoção\"\n"
"    os.chmod(path, stat.S_IWRITE)\n"
"    func(path)\n"
"\n"
"shutil.rmtree(directory, onexc=remove_readonly)"

#: ../../library/shutil.rst:607
msgid "Archiving operations"
msgstr "Operações de arquivamento"

#: ../../library/shutil.rst:611
msgid "Added support for the *xztar* format."
msgstr "Adicionado suporte para o formato *xztar*."

#: ../../library/shutil.rst:615
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""
"Utilitários de alto nível para criar e ler ficheiros comprimidos e "
"arquivados também são fornecidos. Eles dependem dos módulos :mod:`zipfile` "
"e :mod:`tarfile`."

#: ../../library/shutil.rst:620
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr "Criar um ficheiro de arquivo (como zip ou tar) e retornar o seu nome."

#: ../../library/shutil.rst:622
msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension."
msgstr ""
"*base_name* é o nome do ficheiro a criar, incluindo o caminho, menos "
"qualquer extensão específica do formato."

#: ../../library/shutil.rst:625
msgid ""
"*format* is the archive format: one of \"zip\" (if the :mod:`zlib` module is "
"available), \"tar\", \"gztar\" (if the :mod:`zlib` module is available), "
"\"bztar\" (if the :mod:`bz2` module is available), \"xztar\" (if the :mod:"
"`lzma` module is available), or \"zstdtar\" (if the :mod:`compression.zstd` "
"module is available)."
msgstr ""
"*format* é o formato do arquivo: um de \"zip\" (se o módulo :mod:`zlib` "
"estiver disponível), \"tar\", \"gztar\" (se o módulo :mod:`zlib` estiver "
"disponível), \"bztar\" (se o módulo :mod:`bz2` estiver disponível), "
"\"xztar\" (se o módulo :mod:`lzma` estiver disponível), ou \"zstdtar\" (se o "
"módulo :mod:`compression.zstd` estiver disponível)."

#: ../../library/shutil.rst:631
msgid ""
"*root_dir* is a directory that will be the root directory of the archive, "
"all paths in the archive will be relative to it; for example, we typically "
"chdir into *root_dir* before creating the archive."
msgstr ""
"*root_dir* é um diretório que será o diretório raiz do arquivo; todos os "
"caminhos no arquivo serão relativos a ele; por exemplo, normalmente fazemos "
"chdir para *root_dir* antes de criar o arquivo."

#: ../../library/shutil.rst:635
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive.  "
"*base_dir* must be given relative to *root_dir*.  See :ref:`shutil-archiving-"
"example-with-basedir` for how to use *base_dir* and *root_dir* together."
msgstr ""
"*base_dir* é o diretório a partir do qual começamos a arquivar; ou seja, "
"*base_dir* será o prefixo comum de todos os ficheiros e diretórios no "
"arquivo. *base_dir* deve ser fornecido em relação a *root_dir*. Veja :ref:"
"`shutil-archiving-example-with-basedir` para saber como usar *base_dir* e "
"*root_dir* em conjunto."

#: ../../library/shutil.rst:641
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr "*root_dir* e *base_dir* têm ambos como predefinição o diretório atual."

#: ../../library/shutil.rst:643
msgid ""
"If *dry_run* is true, no archive is created, but the operations that would "
"be executed are logged to *logger*."
msgstr ""
"Se *dry_run* for verdadeiro, nenhum arquivo é criado, mas as operações que "
"seriam executadas são registadas em *logger*."

#: ../../library/shutil.rst:646
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""
"*owner* e *group* são usados ao criar um arquivo tar. Por predefinição, usa "
"o proprietário e grupo atuais."

#: ../../library/shutil.rst:649
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""
"*logger* deve ser um objeto compatível com :pep:`282`, normalmente uma "
"instância de :class:`logging.Logger`."

#: ../../library/shutil.rst:652
msgid "The *verbose* argument is unused and deprecated."
msgstr "O argumento *verbose* não é usado e está obsoleto."

#: ../../library/shutil.rst:654
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.make_archive`` with "
"arguments ``base_name``, ``format``, ``root_dir``, ``base_dir``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.make_archive`` com "
"os argumentos ``base_name``, ``format``, ``root_dir``, ``base_dir``."

#: ../../library/shutil.rst:658
msgid ""
"This function is not thread-safe when custom archivers registered with :func:"
"`register_archive_format` do not support the *root_dir* argument.  In this "
"case it temporarily changes the current working directory of the process to "
"*root_dir* to perform archiving."
msgstr ""

#: ../../library/shutil.rst:664
msgid ""
"The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU "
"format for archives created with ``format=\"tar\"``."
msgstr ""
"O formato moderno pax (POSIX.1-2001) é agora usado em vez do formato legado "
"GNU para arquivos criados com ``format=\"tar\"``."

#: ../../library/shutil.rst:668
msgid ""
"This function is now made thread-safe during creation of standard ``.zip`` "
"and tar archives."
msgstr ""
"Esta função é agora segura para threads durante a criação de arquivos ``."
"zip`` e tar padrão."

#: ../../library/shutil.rst:674
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``."
msgstr ""
"Retorna uma lista de formatos suportados para arquivamento. Cada elemento da "
"sequência retornada é um tuplo ``(name, description)``."

#: ../../library/shutil.rst:677 ../../library/shutil.rst:794
msgid "By default :mod:`shutil` provides these formats:"
msgstr "Por predefinição, o :mod:`shutil` fornece estes formatos:"

#: ../../library/shutil.rst:679
msgid "*zip*: ZIP file (if the :mod:`zlib` module is available)."
msgstr "*zip*: Ficheiro ZIP (se o módulo :mod:`zlib` estiver disponível)."

#: ../../library/shutil.rst:680
msgid ""
"*tar*: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives."
msgstr ""
"*tar*: Ficheiro tar não comprimido. Usa o formato pax POSIX.1-2001 para "
"novos arquivos."

#: ../../library/shutil.rst:681 ../../library/shutil.rst:799
msgid "*gztar*: gzip'ed tar-file (if the :mod:`zlib` module is available)."
msgstr ""
"*gztar*: Ficheiro tar comprimido com gzip (se o módulo :mod:`zlib` estiver "
"disponível)."

#: ../../library/shutil.rst:682 ../../library/shutil.rst:800
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available)."
msgstr ""
"*bztar*: Ficheiro tar comprimido com bzip2 (se o módulo :mod:`bz2` estiver "
"disponível)."

#: ../../library/shutil.rst:683 ../../library/shutil.rst:801
msgid "*xztar*: xz'ed tar-file (if the :mod:`lzma` module is available)."
msgstr ""
"*xztar*: Ficheiro tar comprimido com xz (se o módulo :mod:`lzma` estiver "
"disponível)."

#: ../../library/shutil.rst:684 ../../library/shutil.rst:802
msgid ""
"*zstdtar*: Zstandard compressed tar-file (if the :mod:`compression.zstd` "
"module is available)."
msgstr ""
"*zstdtar*: Ficheiro tar comprimido com Zstandard (se o módulo :mod:"
"`compression.zstd` estiver disponível)."

#: ../../library/shutil.rst:687
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""
"Pode registar novos formatos ou fornecer o seu próprio arquivador para "
"quaisquer formatos existentes, usando :func:`register_archive_format`."

#: ../../library/shutil.rst:693
msgid "Register an archiver for the format *name*."
msgstr "Registar um arquivador para o formato *name*."

#: ../../library/shutil.rst:695
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the *base_name* of the file to create, followed by the "
"*base_dir* (which defaults to :data:`os.curdir`) to start archiving from. "
"Further arguments are passed as keyword arguments: *owner*, *group*, "
"*dry_run* and *logger* (as passed in :func:`make_archive`)."
msgstr ""
"*function* é o objeto chamável que será usado para descompactar arquivos. O "
"objeto chamável receberá o *base_name* do ficheiro a criar, seguido do "
"*base_dir* (que por predefinição é :data:`os.curdir`) para iniciar o "
"arquivamento. Outros argumentos são passados como argumentos de palavra-"
"chave: *owner*, *group*, *dry_run* e *logger* (como passados em :func:"
"`make_archive`)."

#: ../../library/shutil.rst:701
msgid ""
"If *function* has the custom attribute ``function.supports_root_dir`` set to "
"``True``, the *root_dir* argument is passed as a keyword argument. Otherwise "
"the current working directory of the process is temporarily changed to "
"*root_dir* before calling *function*. In this case :func:`make_archive` is "
"not thread-safe."
msgstr ""
"Se *function* tiver o atributo personalizado ``function.supports_root_dir`` "
"definido como ``True``, o argumento *root_dir* é passado como um argumento "
"de palavra-chave. Caso contrário, o diretório de trabalho atual do processo "
"é temporariamente alterado para *root_dir* antes de chamar *function*. Neste "
"caso, :func:`make_archive` não é seguro para threads."

#: ../../library/shutil.rst:707
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""
"Se fornecido, *extra_args* é uma sequência de pares ``(name, value)`` que "
"serão usados como argumentos nomeados adicionais quando o objeto chamável do "
"arquivador for usado."

#: ../../library/shutil.rst:710
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers.  Defaults to an empty string."
msgstr ""
"*description* é usado por :func:`get_archive_formats`, que retorna a lista "
"de arquivadores. Por predefinição, é uma string vazia."

#: ../../library/shutil.rst:713
msgid "Added support for functions supporting the *root_dir* argument."
msgstr "Adicionado suporte para funções que suportam o argumento *root_dir*."

#: ../../library/shutil.rst:719
msgid "Remove the archive format *name* from the list of supported formats."
msgstr "Remover o formato de arquivo *name* da lista de formatos suportados."

#: ../../library/shutil.rst:724
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr "Descompactar um arquivo. *filename* é o caminho completo do arquivo."

#: ../../library/shutil.rst:726
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""
"*extract_dir* é o nome do diretório de destino onde o arquivo é "
"descompactado. Se não for fornecido, é usado o diretório de trabalho atual."

#: ../../library/shutil.rst:729
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", \"gztar\", "
"\"bztar\", \"xztar\", or \"zstdtar\".  Or any other format registered with :"
"func:`register_unpack_format`.  If not provided, :func:`unpack_archive` will "
"use the archive file name extension and see if an unpacker was registered "
"for that extension.  In case none is found, a :exc:`ValueError` is raised."
msgstr ""
"*format* é o formato do arquivo: um de \"zip\", \"tar\", \"gztar\", "
"\"bztar\", \"xztar\", ou \"zstdtar\". Ou qualquer outro formato registado "
"com :func:`register_unpack_format`. Se não for fornecido, :func:"
"`unpack_archive` usará a extensão do nome do ficheiro do arquivo e "
"verificará se um descompactador foi registado para essa extensão. Caso "
"nenhum seja encontrado, é levantada uma :exc:`ValueError`."

#: ../../library/shutil.rst:736
msgid ""
"The keyword-only *filter* argument is passed to the underlying unpacking "
"function. For zip files, *filter* is not accepted. For tar files, it is "
"recommended to use ``'data'`` (default since Python 3.14), unless using "
"features specific to tar and UNIX-like filesystems. (See :ref:`tarfile-"
"extraction-filter` for details.)"
msgstr ""
"O argumento *filter*, apenas de palavra-chave, é passado para a função de "
"descompactação subjacente. Para ficheiros zip, *filter* não é aceite. Para "
"ficheiros tar, é recomendado usar ``'data'`` (predefinição desde o Python "
"3.14), a menos que esteja a usar funcionalidades específicas do tar e de "
"sistemas de ficheiros tipo UNIX. (Veja :ref:`tarfile-extraction-filter` para "
"mais detalhes.)"

#: ../../library/shutil.rst:742
msgid ""
"Raises an :ref:`auditing event <auditing>` ``shutil.unpack_archive`` with "
"arguments ``filename``, ``extract_dir``, ``format``."
msgstr ""
"Levanta um :ref:`evento de auditoria <auditing>` ``shutil.unpack_archive`` "
"com os argumentos ``filename``, ``extract_dir``, ``format``."

#: ../../library/shutil.rst:746
msgid ""
"Never extract archives from untrusted sources without prior inspection. It "
"is possible that files are created outside of the path specified in the "
"*extract_dir* argument, e.g. members that have absolute filenames starting "
"with \"/\" or filenames with two dots \"..\"."
msgstr ""
"Nunca extraia arquivos de fontes não confiáveis sem inspeção prévia. É "
"possível que ficheiros sejam criados fora do caminho especificado no "
"argumento *extract_dir*, por exemplo, membros que tenham nomes de ficheiros "
"absolutos começando com \"/\" ou nomes de ficheiros com dois pontos \"..\"."

#: ../../library/shutil.rst:751
msgid ""
"Since Python 3.14, the defaults for both built-in formats (zip and tar "
"files) will prevent the most dangerous of such security issues, but will not "
"prevent *all* unintended behavior. Read the :ref:`tarfile-further-"
"verification` section for tar-specific details."
msgstr ""
"Desde o Python 3.14, as predefinições para ambos os formatos incorporados "
"(ficheiros zip e tar) prevenirão os problemas de segurança mais perigosos, "
"mas não prevenirão *todo* o comportamento não intencional. Leia a secção :"
"ref:`tarfile-further-verification` para detalhes específicos do tar."

#: ../../library/shutil.rst:757
msgid "Accepts a :term:`path-like object` for *filename* and *extract_dir*."
msgstr ""
"Aceita um :term:`objeto semelhante a caminho` para *filename* e "
"*extract_dir*."

#: ../../library/shutil.rst:760
msgid "Added the *filter* argument."
msgstr "Adicionado o argumento *filter*."

#: ../../library/shutil.rst:765
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""
"Regista um formato de descompactação. *name* é o nome do formato e "
"*extensions* é uma lista de extensões correspondentes ao formato, como ``."
"zip`` para ficheiros Zip."

#: ../../library/shutil.rst:769
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive:"
msgstr ""
"*function* é o objeto chamável que será usado para descompactar arquivos. O "
"objeto chamável receberá:"

#: ../../library/shutil.rst:772
msgid "the path of the archive, as a positional argument;"
msgstr "o caminho do arquivo, como um argumento posicional;"

#: ../../library/shutil.rst:773
msgid ""
"the directory the archive must be extracted to, as a positional argument;"
msgstr ""
"o diretório para o qual o arquivo deve ser extraído, como um argumento "
"posicional;"

#: ../../library/shutil.rst:774
msgid ""
"possibly a *filter* keyword argument, if it was given to :func:"
"`unpack_archive`;"
msgstr ""
"possivelmente um argumento de palavra-chave *filter*, se foi fornecido a :"
"func:`unpack_archive`;"

#: ../../library/shutil.rst:776
msgid ""
"additional keyword arguments, specified by *extra_args* as a sequence of "
"``(name, value)`` tuples."
msgstr ""
"argumentos nomeados adicionais, especificados por *extra_args* como uma "
"sequência de tuplos ``(name, value)``."

#: ../../library/shutil.rst:779
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""
"*description* pode ser fornecido para descrever o formato e será retornado "
"pela função :func:`get_unpack_formats`."

#: ../../library/shutil.rst:785
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr ""
"Remover o registo de um formato de descompactação. *name* é o nome do "
"formato."

#: ../../library/shutil.rst:790
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""
"Retorna uma lista de todos os formatos registados para descompactação. Cada "
"elemento da sequência retornada é um tuplo ``(name, extensions, "
"description)``."

#: ../../library/shutil.rst:796
msgid ""
"*zip*: ZIP file (unpacking compressed files works only if the corresponding "
"module is available)."
msgstr ""
"*zip*: Ficheiro ZIP (a descompactação de ficheiros comprimidos funciona "
"apenas se o módulo correspondente estiver disponível)."

#: ../../library/shutil.rst:798
msgid "*tar*: uncompressed tar file."
msgstr "*tar*: ficheiro tar não comprimido."

#: ../../library/shutil.rst:805
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""
"Pode registar novos formatos ou fornecer o seu próprio descompactador para "
"quaisquer formatos existentes, usando :func:`register_unpack_format`."

#: ../../library/shutil.rst:812
msgid "Archiving example"
msgstr "Exemplo de arquivamento"

#: ../../library/shutil.rst:814
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""
"Neste exemplo, criamos um arquivo tar comprimido com gzip contendo todos os "
"ficheiros encontrados no diretório :file:`.ssh` do utilizador::"

#: ../../library/shutil.rst:817
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> root_dir = os.path.expanduser(os.path.join('~', '.ssh'))\n"
">>> make_archive(archive_name, 'gztar', root_dir)\n"
"'/Users/tarek/myarchive.tar.gz'"

#: ../../library/shutil.rst:824
msgid "The resulting archive contains:"
msgstr "O arquivo resultante contém:"

#: ../../library/shutil.rst:826
msgid ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"
msgstr ""
"$ tar -tzvf /Users/tarek/myarchive.tar.gz\n"
"drwx------ tarek/staff       0 2010-02-01 16:23:40 ./\n"
"-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys\n"
"-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config\n"
"-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa\n"
"-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub\n"
"-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa\n"
"-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub\n"
"-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts"

#: ../../library/shutil.rst:842
msgid "Archiving example with *base_dir*"
msgstr "Exemplo de arquivamento com *base_dir*"

#: ../../library/shutil.rst:844
msgid ""
"In this example, similar to the `one above <shutil-archiving-example_>`_, we "
"show how to use :func:`make_archive`, but this time with the usage of "
"*base_dir*.  We now have the following directory structure:"
msgstr ""
"Neste exemplo, semelhante ao `acima <shutil-archiving-example_>`_, mostramos "
"como usar :func:`make_archive`, mas desta vez com o uso de *base_dir*. Temos "
"agora a seguinte estrutura de diretórios:"

#: ../../library/shutil.rst:848
msgid ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"
msgstr ""
"$ tree tmp\n"
"tmp\n"
"└── root\n"
"    └── structure\n"
"        ├── content\n"
"            └── please_add.txt\n"
"        └── do_not_add.txt"

#: ../../library/shutil.rst:858
msgid ""
"In the final archive, :file:`please_add.txt` should be included, but :file:"
"`do_not_add.txt` should not.  Therefore we use the following::"
msgstr ""
"No arquivo final, :file:`please_add.txt` deve ser incluído, mas :file:"
"`do_not_add.txt` não deve. Portanto, usamos o seguinte::"

#: ../../library/shutil.rst:861
msgid ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/myarchive.tar'"
msgstr ""
">>> from shutil import make_archive\n"
">>> import os\n"
">>> archive_name = os.path.expanduser(os.path.join('~', 'myarchive'))\n"
">>> make_archive(\n"
"...     archive_name,\n"
"...     'tar',\n"
"...     root_dir='tmp/root',\n"
"...     base_dir='structure/content',\n"
"... )\n"
"'/Users/tarek/myarchive.tar'"

#: ../../library/shutil.rst:872
msgid "Listing the files in the resulting archive gives us:"
msgstr "Listar os ficheiros no arquivo resultante dá-nos:"

#: ../../library/shutil.rst:874
msgid ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"
msgstr ""
"$ python -m tarfile -l /Users/tarek/myarchive.tar\n"
"structure/content/\n"
"structure/content/please_add.txt"

#: ../../library/shutil.rst:882
msgid "Querying the size of the output terminal"
msgstr "Consultar o tamanho do terminal de saída"

#: ../../library/shutil.rst:886
msgid "Get the size of the terminal window."
msgstr "Obter o tamanho da janela do terminal."

#: ../../library/shutil.rst:888
msgid ""
"For each of the two dimensions, the environment variable, ``COLUMNS`` and "
"``LINES`` respectively, is checked. If the variable is defined and the value "
"is a positive integer, it is used."
msgstr ""
"Para cada uma das duas dimensões, a variável de ambiente, ``COLUMNS`` e "
"``LINES`` respetivamente, é verificada. Se a variável estiver definida e o "
"valor for um inteiro positivo, é usado."

#: ../../library/shutil.rst:892
msgid ""
"When ``COLUMNS`` or ``LINES`` is not defined, which is the common case, the "
"terminal connected to :data:`sys.__stdout__` is queried by invoking :func:"
"`os.get_terminal_size`."
msgstr ""
"Quando ``COLUMNS`` ou ``LINES`` não estiverem definidas, o que é o caso "
"comum, o terminal ligado a :data:`sys.__stdout__` é consultado invocando :"
"func:`os.get_terminal_size`."

#: ../../library/shutil.rst:896
msgid ""
"If the terminal size cannot be successfully queried, either because the "
"system doesn't support querying, or because we are not connected to a "
"terminal, the value given in ``fallback`` parameter is used. ``fallback`` "
"defaults to ``(80, 24)`` which is the default size used by many terminal "
"emulators."
msgstr ""
"Se o tamanho do terminal não puder ser consultado com sucesso, seja porque o "
"sistema não suporta a consulta, ou porque não estamos ligados a um terminal, "
"é usado o valor fornecido no parâmetro ``fallback``. ``fallback`` tem como "
"predefinição ``(80, 24)``, que é o tamanho predefinido usado por muitos "
"emuladores de terminal."

#: ../../library/shutil.rst:902
msgid "The value returned is a named tuple of type :class:`os.terminal_size`."
msgstr ""
"O valor retornado é um tuplo nomeado do tipo :class:`os.terminal_size`."

#: ../../library/shutil.rst:904
msgid ""
"See also: The Single UNIX Specification, Version 2, `Other Environment "
"Variables`_."
msgstr ""
"Veja também: The Single UNIX Specification, Versão 2, `Outras Variáveis de "
"Ambiente`_."

#: ../../library/shutil.rst:909
msgid ""
"The ``fallback`` values are also used if :func:`os.get_terminal_size` "
"returns zeroes."
msgstr ""
"Os valores ``fallback`` também são usados se :func:`os.get_terminal_size` "
"retornar zeros."

#: ../../library/shutil.rst:12
msgid "file"
msgstr "ficheiro"

#: ../../library/shutil.rst:12
msgid "copying"
msgstr "cópia"

#: ../../library/shutil.rst:12
msgid "copying files"
msgstr "copiar ficheiros"

#: ../../library/shutil.rst:311
msgid "directory"
msgstr "diretório"

#: ../../library/shutil.rst:311
msgid "deleting"
msgstr "apagar"
