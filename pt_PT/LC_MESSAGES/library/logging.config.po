# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-29 16:28+0000\n"
"PO-Revision-Date: 2025-09-22 16:50+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/logging.config.rst:2
msgid ":mod:`logging.config` --- Logging configuration"
msgstr ""

#: ../../library/logging.config.rst:10
msgid "**Source code:** :source:`Lib/logging/config.py`"
msgstr "**Código-fonte:** :source:`Lib/logging/config.py`"

#: ../../library/logging.config.rst:14
msgid ""
"This page contains only reference information. For tutorials, please see"
msgstr ""
"Esta página contém apenas informações de referência. Para tutoriais, consulte"

#: ../../library/logging.config.rst:17
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial Básico <logging-basic-tutorial>`"

#: ../../library/logging.config.rst:18
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial Avançado <logging-advanced-tutorial>`"

#: ../../library/logging.config.rst:19
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`Livro de Receitas de Registo <logging-cookbook>`"

#: ../../library/logging.config.rst:23
msgid "This section describes the API for configuring the logging module."
msgstr "Esta secção descreve a API para configurar o módulo de registo."

#: ../../library/logging.config.rst:28
msgid "Configuration functions"
msgstr "Funções de configuração"

#: ../../library/logging.config.rst:30
msgid ""
"The following functions configure the logging module. They are located in "
"the :mod:`logging.config` module.  Their use is optional --- you can "
"configure the logging module using these functions or by making calls to the "
"main API (defined in :mod:`logging` itself) and defining handlers which are "
"declared either in :mod:`logging` or :mod:`logging.handlers`."
msgstr ""
"As funções seguintes configuram o módulo de registo. Estão localizadas no "
"módulo :mod:`logging.config`. O seu uso é opcional — pode configurar o "
"módulo de registo usando estas funções ou fazendo chamadas à API principal "
"(definida em :mod:`logging` em si) e definindo manipuladores que são "
"declarados em :mod:`logging` ou :mod:`logging.handlers`."

#: ../../library/logging.config.rst:38
msgid ""
"Takes the logging configuration from a dictionary.  The contents of this "
"dictionary are described in :ref:`logging-config-dictschema` below."
msgstr ""
"Obtém a configuração de registo a partir de um dicionário. O conteúdo deste "
"dicionário é descrito em :ref:`logging-config-dictschema` abaixo."

#: ../../library/logging.config.rst:42
msgid ""
"If an error is encountered during configuration, this function will raise a :"
"exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` or :exc:"
"`ImportError` with a suitably descriptive message.  The following is a "
"(possibly incomplete) list of conditions which will raise an error:"
msgstr ""
"Se for encontrado um erro durante a configuração, esta função levantará uma "
"exceção :exc:`ValueError`, :exc:`TypeError`, :exc:`AttributeError` ou :exc:"
"`ImportError` com uma mensagem descritiva adequada. A seguinte é uma lista "
"(possivelmente incompleta) de condições que levantarão um erro:"

#: ../../library/logging.config.rst:48
msgid ""
"A ``level`` which is not a string or which is a string not corresponding to "
"an actual logging level."
msgstr ""
"Um ``level`` que não é uma string ou que é uma string que não corresponde a "
"um nível de registo real."

#: ../../library/logging.config.rst:50
msgid "A ``propagate`` value which is not a boolean."
msgstr "Um valor ``propagate`` que não é booleano."

#: ../../library/logging.config.rst:51
msgid "An id which does not have a corresponding destination."
msgstr "Um id que não tem um destino correspondente."

#: ../../library/logging.config.rst:52
msgid "A non-existent handler id found during an incremental call."
msgstr ""
"Um id de manipulador inexistente encontrado durante uma chamada incremental."

#: ../../library/logging.config.rst:53
msgid "An invalid logger name."
msgstr "Um nome de registador inválido."

#: ../../library/logging.config.rst:54
msgid "Inability to resolve to an internal or external object."
msgstr "Incapacidade de resolver para um objeto interno ou externo."

#: ../../library/logging.config.rst:56
msgid ""
"Parsing is performed by the :class:`DictConfigurator` class, whose "
"constructor is passed the dictionary used for configuration, and has a :meth:"
"`configure` method.  The :mod:`logging.config` module has a callable "
"attribute :attr:`dictConfigClass` which is initially set to :class:"
"`DictConfigurator`. You can replace the value of :attr:`dictConfigClass` "
"with a suitable implementation of your own."
msgstr ""
"A análise é realizada pela classe :class:`DictConfigurator`, cujo construtor "
"recebe o dicionário usado para configuração e tem um método :meth:"
"`configure`. O módulo :mod:`logging.config` tem um atributo chamável :attr:"
"`dictConfigClass` que é inicialmente definido para :class:"
"`DictConfigurator`. Pode substituir o valor de :attr:`dictConfigClass` com "
"uma implementação adequada sua."

#: ../../library/logging.config.rst:64
msgid ""
":func:`dictConfig` calls :attr:`dictConfigClass` passing the specified "
"dictionary, and then calls the :meth:`configure` method on the returned "
"object to put the configuration into effect::"
msgstr ""
":func:`dictConfig` chama :attr:`dictConfigClass` passando o dicionário "
"especificado e, em seguida, chama o método :meth:`configure` no objeto "
"devolvido para colocar a configuração em vigor::"

#: ../../library/logging.config.rst:71
msgid ""
"For example, a subclass of :class:`DictConfigurator` could call "
"``DictConfigurator.__init__()`` in its own :meth:`__init__()`, then set up "
"custom prefixes which would be usable in the subsequent :meth:`configure` "
"call. :attr:`dictConfigClass` would be bound to this new subclass, and then :"
"func:`dictConfig` could be called exactly as in the default, uncustomized "
"state."
msgstr ""

#: ../../library/logging.config.rst:82
msgid ""
"Reads the logging configuration from a :mod:`configparser`\\-format file. "
"The format of the file should be as described in :ref:`logging-config-"
"fileformat`. This function can be called several times from an application, "
"allowing an end user to select from various pre-canned configurations (if "
"the developer provides a mechanism to present the choices and load the "
"chosen configuration)."
msgstr ""
"Lê a configuração de registo a partir de um ficheiro no formato :mod:"
"`configparser`. O formato do ficheiro deve ser como descrito em :ref:"
"`logging-config-fileformat`. Esta função pode ser chamada várias vezes a "
"partir de uma aplicação, permitindo que um utilizador final selecione entre "
"várias configurações pré-definidas (se o desenvolvedor fornecer um mecanismo "
"para apresentar as escolhas e carregar a configuração escolhida)."

#: ../../library/logging.config.rst:90
msgid ""
"It will raise :exc:`FileNotFoundError` if the file doesn't exist and :exc:"
"`RuntimeError` if the file is invalid or empty."
msgstr ""
"Levantará :exc:`FileNotFoundError` se o ficheiro não existir e :exc:"
"`RuntimeError` se o ficheiro for inválido ou vazio."

#: ../../library/logging.config.rst:0
msgid "Parameters"
msgstr "Parâmetros"

#: ../../library/logging.config.rst:94
msgid ""
"A filename, or a file-like object, or an instance derived from :class:"
"`~configparser.RawConfigParser`. If a :class:`!RawConfigParser`-derived "
"instance is passed, it is used as is. Otherwise, a :class:`~configparser."
"ConfigParser` is instantiated, and the configuration read by it from the "
"object passed in ``fname``. If that has a :meth:`readline` method, it is "
"assumed to be a file-like object and read using :meth:`~configparser."
"ConfigParser.read_file`; otherwise, it is assumed to be a filename and "
"passed to :meth:`~configparser.ConfigParser.read`."
msgstr ""
"Um nome de ficheiro, ou um objeto semelhante a um ficheiro, ou uma instância "
"derivada de :class:`~configparser.RawConfigParser`. Se uma instância "
"derivada de :class:`!RawConfigParser` for passada, é usada como está. Caso "
"contrário, uma instância de :class:`~configparser.ConfigParser` é "
"instanciada, e a configuração é lida a partir do objeto passado em "
"``fname``. Se este tiver um método :meth:`readline`, assume-se que é um "
"objeto semelhante a um ficheiro e é lido usando :meth:`~configparser."
"ConfigParser.read_file`; caso contrário, assume-se que é um nome de ficheiro "
"e é passado para :meth:`~configparser.ConfigParser.read`."

#: ../../library/logging.config.rst:106
msgid ""
"Defaults to be passed to the :class:`!ConfigParser` can be specified in this "
"argument."
msgstr ""
"Os valores predefinidos a serem passados para o :class:`!ConfigParser` podem "
"ser especificados neste argumento."

#: ../../library/logging.config.rst:109
msgid ""
"If specified as ``False``, loggers which exist when this call is made are "
"left enabled. The default is ``True`` because this enables old behaviour in "
"a backward-compatible way. This behaviour is to disable any existing non-"
"root loggers unless they or their ancestors are explicitly named in the "
"logging configuration."
msgstr ""
"Se especificado como ``False``, os registadores que existem quando esta "
"chamada é feita são deixados ativados. O valor predefinido é ``True`` porque "
"isto permite o comportamento antigo de uma forma compatível com versões "
"anteriores. Este comportamento é desativar quaisquer registadores não-raiz "
"existentes, a menos que eles ou os seus antecessores sejam explicitamente "
"nomeados na configuração de registo."

#: ../../library/logging.config.rst:118
msgid "The encoding used to open file when *fname* is filename."
msgstr ""
"A codificação usada para abrir o ficheiro quando *fname* é um nome de "
"ficheiro."

#: ../../library/logging.config.rst:120
msgid ""
"An instance of a subclass of :class:`~configparser.RawConfigParser` is   now "
"accepted as a value for ``fname``. This facilitates:"
msgstr ""
"Uma instância de uma subclasse de :class:`~configparser.RawConfigParser` é "
"agora aceite como um valor para ``fname``. Isto facilita:"

#: ../../library/logging.config.rst:124
msgid ""
"Use of a configuration file where logging configuration is just part of the "
"overall application configuration."
msgstr ""
"O uso de um ficheiro de configuração onde a configuração de registo é apenas "
"parte da configuração geral da aplicação."

#: ../../library/logging.config.rst:126
msgid ""
"Use of a configuration read from a file, and then modified by the using "
"application (e.g. based on command-line parameters or other aspects of the "
"runtime environment) before being passed to ``fileConfig``."
msgstr ""
"O uso de uma configuração lida a partir de um ficheiro e, em seguida, "
"modificada pela aplicação (por exemplo, com base em parâmetros de linha de "
"comandos ou outros aspetos do ambiente de execução) antes de ser passada "
"para ``fileConfig``."

#: ../../library/logging.config.rst:130
msgid "Added the *encoding* parameter."
msgstr "Adicionado o parâmetro *encoding*."

#: ../../library/logging.config.rst:133
msgid ""
"An exception will be thrown if the provided file doesn't exist or is invalid "
"or empty."
msgstr ""
"Uma exceção será lançada se o ficheiro fornecido não existir ou for inválido "
"ou vazio."

#: ../../library/logging.config.rst:139
msgid ""
"Starts up a socket server on the specified port, and listens for new "
"configurations. If no port is specified, the module's default :const:"
"`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent "
"as a file suitable for processing by :func:`dictConfig` or :func:"
"`fileConfig`. Returns a :class:`~threading.Thread` instance on which you can "
"call :meth:`~threading.Thread.start` to start the server, and which you can :"
"meth:`~threading.Thread.join` when appropriate. To stop the server, call :"
"func:`stopListening`."
msgstr ""
"Inicia um servidor de socket na porta especificada e escuta por novas "
"configurações. Se nenhuma porta for especificada, é usada a porta "
"predefinida do módulo :const:`DEFAULT_LOGGING_CONFIG_PORT`. As configurações "
"de registo serão enviadas como um ficheiro adequado para processamento por :"
"func:`dictConfig` ou :func:`fileConfig`. Devolve uma instância de :class:"
"`~threading.Thread` na qual pode chamar :meth:`~threading.Thread.start` para "
"iniciar o servidor e que pode :meth:`~threading.Thread.join` quando "
"apropriado. Para parar o servidor, chame :func:`stopListening`."

#: ../../library/logging.config.rst:148
msgid ""
"The ``verify`` argument, if specified, should be a callable which should "
"verify whether bytes received across the socket are valid and should be "
"processed. This could be done by encrypting and/or signing what is sent "
"across the socket, such that the ``verify`` callable can perform signature "
"verification and/or decryption. The ``verify`` callable is called with a "
"single argument - the bytes received across the socket - and should return "
"the bytes to be processed, or ``None`` to indicate that the bytes should be "
"discarded. The returned bytes could be the same as the passed in bytes (e.g. "
"when only verification is done), or they could be completely different "
"(perhaps if decryption were performed)."
msgstr ""
"O argumento ``verify``, se especificado, deve ser um objeto chamável que "
"deve verificar se os bytes recebidos através do socket são válidos e devem "
"ser processados. Isto pode ser feito encriptando e/ou assinando o que é "
"enviado através do socket, de modo que o objeto chamável ``verify`` possa "
"realizar verificação de assinatura e/ou desencriptação. O objeto chamável "
"``verify`` é chamado com um único argumento — os bytes recebidos através do "
"socket — e deve devolver os bytes a serem processados, ou ``None`` para "
"indicar que os bytes devem ser descartados. Os bytes devolvidos podem ser os "
"mesmos que os bytes passados (por exemplo, quando apenas é feita "
"verificação), ou podem ser completamente diferentes (talvez se fosse "
"realizada desencriptação)."

#: ../../library/logging.config.rst:159
msgid ""
"To send a configuration to the socket, read in the configuration file and "
"send it to the socket as a sequence of bytes preceded by a four-byte length "
"string packed in binary using ``struct.pack('>L', n)``."
msgstr ""
"Para enviar uma configuração para o socket, leia o ficheiro de configuração "
"e envie-o para o socket como uma sequência de bytes precedida por uma string "
"de comprimento de quatro bytes compactada em binário usando ``struct."
"pack('>L', n)``."

#: ../../library/logging.config.rst:167
msgid ""
"Because portions of the configuration are passed through :func:`eval`, use "
"of this function may open its users to a security risk. While the function "
"only binds to a socket on ``localhost``, and so does not accept connections "
"from remote machines, there are scenarios where untrusted code could be run "
"under the account of the process which calls :func:`listen`. Specifically, "
"if the process calling :func:`listen` runs on a multi-user machine where "
"users cannot trust each other, then a malicious user could arrange to run "
"essentially arbitrary code in a victim user's process, simply by connecting "
"to the victim's :func:`listen` socket and sending a configuration which runs "
"whatever code the attacker wants to have executed in the victim's process. "
"This is especially easy to do if the default port is used, but not hard even "
"if a different port is used. To avoid the risk of this happening, use the "
"``verify`` argument to :func:`listen` to prevent unrecognised configurations "
"from being applied."
msgstr ""
"Como partes da configuração são passadas através de :func:`eval`, o uso "
"desta função pode expor os seus utilizadores a um risco de segurança. Embora "
"a função apenas se ligue a um socket em ``localhost``, e, portanto, não "
"aceite ligações de máquinas remotas, existem cenários em que código não "
"confiável pode ser executado sob a conta do processo que chama :func:"
"`listen`. Especificamente, se o processo que chama :func:`listen` é "
"executado numa máquina multi-utilizador onde os utilizadores não podem "
"confiar uns nos outros, então um utilizador malicioso poderia executar "
"essencialmente qualquer código no processo de um utilizador vítima, "
"simplesmente ligando-se ao socket :func:`listen` da vítima e enviando uma "
"configuração que executa qualquer código que o atacante queira que seja "
"executado no processo da vítima. Isto é especialmente fácil de fazer se a "
"porta predefinida for usada, mas não é difícil mesmo que uma porta diferente "
"seja usada. Para evitar o risco de isto acontecer, use o argumento "
"``verify`` para :func:`listen` para evitar que configurações não "
"reconhecidas sejam aplicadas."

#: ../../library/logging.config.rst:183
msgid "The ``verify`` argument was added."
msgstr "O argumento ``verify`` foi adicionado."

#: ../../library/logging.config.rst:188
msgid ""
"If you want to send configurations to the listener which don't disable "
"existing loggers, you will need to use a JSON format for the configuration, "
"which will use :func:`dictConfig` for configuration. This method allows you "
"to specify ``disable_existing_loggers`` as ``False`` in the configuration "
"you send."
msgstr ""
"Se pretender enviar configurações para o ouvinte que não desativam "
"registadores existentes, terá de usar um formato JSON para a configuração, "
"que usará :func:`dictConfig` para a configuração. Este método permite-lhe "
"especificar ``disable_existing_loggers`` como ``False`` na configuração que "
"envia."

#: ../../library/logging.config.rst:197
msgid ""
"Stops the listening server which was created with a call to :func:`listen`. "
"This is typically called before calling :meth:`join` on the return value "
"from :func:`listen`."
msgstr ""
"Para o servidor de escuta que foi criado com uma chamada para :func:"
"`listen`. Isto é tipicamente chamado antes de chamar :meth:`join` no valor "
"de retorno de :func:`listen`."

#: ../../library/logging.config.rst:203
msgid "Security considerations"
msgstr "Considerações de segurança"

#: ../../library/logging.config.rst:205
msgid ""
"The logging configuration functionality tries to offer convenience, and in "
"part this is done by offering the ability to convert text in configuration "
"files into Python objects used in logging configuration - for example, as "
"described in :ref:`logging-config-dict-userdef`. However, these same "
"mechanisms (importing callables from user-defined modules and calling them "
"with parameters from the configuration) could be used to invoke any code you "
"like, and for this reason you should treat configuration files from "
"untrusted sources with *extreme caution* and satisfy yourself that nothing "
"bad can happen if you load them, before actually loading them."
msgstr ""
"A funcionalidade de configuração de registo tenta oferecer conveniência, e "
"em parte isto é feito oferecendo a capacidade de converter texto em "
"ficheiros de configuração em objetos Python usados na configuração de "
"registo — por exemplo, como descrito em :ref:`logging-config-dict-userdef`. "
"No entanto, estes mesmos mecanismos (importar objetos chamáveis de módulos "
"definidos pelo utilizador e chamá-los com parâmetros da configuração) "
"poderiam ser usados para invocar qualquer código que desejar, e por esta "
"razão deve tratar ficheiros de configuração de fontes não confiáveis com "
"*extrema cautela* e certificar-se de que nada de mau pode acontecer se os "
"carregar, antes de os carregar efetivamente."

#: ../../library/logging.config.rst:219
msgid "Configuration dictionary schema"
msgstr "Esquema do dicionário de configuração"

#: ../../library/logging.config.rst:221
msgid ""
"Describing a logging configuration requires listing the various objects to "
"create and the connections between them; for example, you may create a "
"handler named 'console' and then say that the logger named 'startup' will "
"send its messages to the 'console' handler. These objects aren't limited to "
"those provided by the :mod:`logging` module because you might write your own "
"formatter or handler class. The parameters to these classes may also need to "
"include external objects such as ``sys.stderr``.  The syntax for describing "
"these objects and connections is defined in :ref:`logging-config-dict-"
"connections` below."
msgstr ""
"Descrever uma configuração de registo requer listar os vários objetos a "
"criar e as ligações entre eles; por exemplo, pode criar um manipulador "
"chamado 'consola' e depois dizer que o registador chamado 'inicialização' "
"enviará as suas mensagens para o manipulador 'consola'. Estes objetos não "
"estão limitados aos fornecidos pelo módulo :mod:`logging` porque pode "
"escrever a sua própria classe de formatador ou manipulador. Os parâmetros "
"para estas classes também podem precisar de incluir objetos externos como "
"``sys.stderr``. A sintaxe para descrever estes objetos e ligações é definida "
"em :ref:`logging-config-dict-connections` abaixo."

#: ../../library/logging.config.rst:233
msgid "Dictionary Schema Details"
msgstr "Detalhes do esquema do dicionário"

#: ../../library/logging.config.rst:235
msgid ""
"The dictionary passed to :func:`dictConfig` must contain the following keys:"
msgstr ""
"O dicionário passado para :func:`dictConfig` deve conter as seguintes chaves:"

#: ../../library/logging.config.rst:238
msgid ""
"*version* - to be set to an integer value representing the schema version.  "
"The only valid value at present is 1, but having this key allows the schema "
"to evolve while still preserving backwards compatibility."
msgstr ""
"*version* — deve ser definido para um valor inteiro que representa a versão "
"do esquema. O único valor válido atualmente é 1, mas ter esta chave permite "
"que o esquema evolua, preservando ainda a compatibilidade retroativa."

#: ../../library/logging.config.rst:243
msgid ""
"All other keys are optional, but if present they will be interpreted as "
"described below.  In all cases below where a 'configuring dict' is "
"mentioned, it will be checked for the special ``'()'`` key to see if a "
"custom instantiation is required.  If so, the mechanism described in :ref:"
"`logging-config-dict-userdef` below is used to create an instance; "
"otherwise, the context is used to determine what to instantiate."
msgstr ""
"Todas as outras chaves são opcionais, mas se presentes serão interpretadas "
"como descrito abaixo. Em todos os casos abaixo onde um 'dicionário de "
"configuração' é mencionado, será verificado quanto à chave especial ``'()'`` "
"para ver se é necessária uma instanciação personalizada. Se for, o mecanismo "
"descrito em :ref:`logging-config-dict-userdef` abaixo é usado para criar uma "
"instância; caso contrário, o contexto é usado para determinar o que "
"instanciar."

#: ../../library/logging.config.rst:252
msgid ""
"*formatters* - the corresponding value will be a dict in which each key is a "
"formatter id and each value is a dict describing how to configure the "
"corresponding :class:`~logging.Formatter` instance."
msgstr ""
"*formatters* — o valor correspondente será um dicionário em que cada chave é "
"um id de formatador e cada valor é um dicionário que descreve como "
"configurar a instância :class:`~logging.Formatter` correspondente."

#: ../../library/logging.config.rst:256
msgid ""
"The configuring dict is searched for the following optional keys which "
"correspond to the arguments passed to create a :class:`~logging.Formatter` "
"object:"
msgstr ""
"O dicionário de configuração é pesquisado pelas seguintes chaves opcionais "
"que correspondem aos argumentos passados para criar um objeto :class:"
"`~logging.Formatter`:"

#: ../../library/logging.config.rst:260
msgid "``format``"
msgstr "``format``"

#: ../../library/logging.config.rst:261
msgid "``datefmt``"
msgstr "``datefmt``"

#: ../../library/logging.config.rst:262
msgid "``style``"
msgstr "``style``"

#: ../../library/logging.config.rst:263
msgid "``validate`` (since version >=3.8)"
msgstr "``validate`` (desde a versão >=3.8)"

#: ../../library/logging.config.rst:265
msgid ""
"An optional ``class`` key indicates the name of the formatter's class (as a "
"dotted module and class name).  The instantiation arguments are as for :"
"class:`~logging.Formatter`, thus this key is most useful for instantiating a "
"customised subclass of :class:`~logging.Formatter`.  For example, the "
"alternative class might present exception tracebacks in an expanded or "
"condensed format.  If your formatter requires different or extra "
"configuration keys, you should use :ref:`logging-config-dict-userdef`."
msgstr ""
"Uma chave opcional ``class`` indica o nome da classe do formatador (como um "
"nome de módulo e classe separados por pontos). Os argumentos de instanciação "
"são como para :class:`~logging.Formatter`, pelo que esta chave é mais útil "
"para instanciar uma subclasse personalizada de :class:`~logging.Formatter`. "
"Por exemplo, a classe alternativa pode apresentar rastreios de exceção num "
"formato expandido ou condensado. Se o seu formatador necessitar de chaves de "
"configuração diferentes ou extra, deve usar :ref:`logging-config-dict-"
"userdef`."

#: ../../library/logging.config.rst:274
msgid ""
"*filters* - the corresponding value will be a dict in which each key is a "
"filter id and each value is a dict describing how to configure the "
"corresponding Filter instance."
msgstr ""
"*filters* — o valor correspondente será um dicionário em que cada chave é um "
"id de filtro e cada valor é um dicionário que descreve como configurar a "
"instância de Filtro correspondente."

#: ../../library/logging.config.rst:278
msgid ""
"The configuring dict is searched for the key ``name`` (defaulting to the "
"empty string) and this is used to construct a :class:`logging.Filter` "
"instance."
msgstr ""
"O dicionário de configuração é pesquisado pela chave ``name`` (predefinido "
"para a string vazia) e isto é usado para construir uma instância de :class:"
"`logging.Filter`."

#: ../../library/logging.config.rst:282
msgid ""
"*handlers* - the corresponding value will be a dict in which each key is a "
"handler id and each value is a dict describing how to configure the "
"corresponding Handler instance."
msgstr ""
"*handlers* — o valor correspondente será um dicionário em que cada chave é "
"um id de manipulador e cada valor é um dicionário que descreve como "
"configurar a instância de Manipulador correspondente."

#: ../../library/logging.config.rst:286 ../../library/logging.config.rst:331
msgid "The configuring dict is searched for the following keys:"
msgstr "O dicionário de configuração é pesquisado pelas seguintes chaves:"

#: ../../library/logging.config.rst:288
msgid ""
"``class`` (mandatory).  This is the fully qualified name of the handler "
"class."
msgstr ""
"``class`` (obrigatório). Este é o nome totalmente qualificado da classe do "
"manipulador."

#: ../../library/logging.config.rst:291
msgid "``level`` (optional).  The level of the handler."
msgstr "``level`` (opcional). O nível do manipulador."

#: ../../library/logging.config.rst:293
msgid "``formatter`` (optional).  The id of the formatter for this handler."
msgstr "``formatter`` (opcional). O id do formatador para este manipulador."

#: ../../library/logging.config.rst:296
msgid "``filters`` (optional).  A list of ids of the filters for this handler."
msgstr ""
"``filters`` (opcional). Uma lista de ids dos filtros para este manipulador."

#: ../../library/logging.config.rst:299 ../../library/logging.config.rst:340
msgid "``filters`` can take filter instances in addition to ids."
msgstr "``filters`` pode aceitar instâncias de filtro além de ids."

#: ../../library/logging.config.rst:302
msgid ""
"All *other* keys are passed through as keyword arguments to the handler's "
"constructor.  For example, given the snippet:"
msgstr ""
"Todas as *outras* chaves são passadas como argumentos de palavra-chave para "
"o construtor do manipulador. Por exemplo, dado o excerto:"

#: ../../library/logging.config.rst:321
msgid ""
"the handler with id ``console`` is instantiated as a :class:`logging."
"StreamHandler`, using ``sys.stdout`` as the underlying stream.  The handler "
"with id ``file`` is instantiated as a :class:`logging.handlers."
"RotatingFileHandler` with the keyword arguments ``filename='logconfig.log', "
"maxBytes=1024, backupCount=3``."
msgstr ""
"o manipulador com id ``console`` é instanciado como um :class:`logging."
"StreamHandler`, usando ``sys.stdout`` como o fluxo subjacente. O manipulador "
"com id ``file`` é instanciado como um :class:`logging.handlers."
"RotatingFileHandler` com os argumentos de palavra-chave "
"``filename='logconfig.log', maxBytes=1024, backupCount=3``."

#: ../../library/logging.config.rst:327
msgid ""
"*loggers* - the corresponding value will be a dict in which each key is a "
"logger name and each value is a dict describing how to configure the "
"corresponding Logger instance."
msgstr ""
"*loggers* — o valor correspondente será um dicionário em que cada chave é um "
"nome de registador e cada valor é um dicionário que descreve como configurar "
"a instância de Logger correspondente."

#: ../../library/logging.config.rst:333
msgid "``level`` (optional).  The level of the logger."
msgstr "``level`` (opcional). O nível do registador."

#: ../../library/logging.config.rst:335
msgid "``propagate`` (optional).  The propagation setting of the logger."
msgstr "``propagate`` (opcional). A configuração de propagação do registador."

#: ../../library/logging.config.rst:337
msgid "``filters`` (optional).  A list of ids of the filters for this logger."
msgstr ""
"``filters`` (opcional). Uma lista de ids dos filtros para este registador."

#: ../../library/logging.config.rst:343
msgid ""
"``handlers`` (optional).  A list of ids of the handlers for this logger."
msgstr ""
"``handlers`` (opcional). Uma lista de ids dos manipuladores para este "
"registador."

#: ../../library/logging.config.rst:346
msgid ""
"The specified loggers will be configured according to the level, "
"propagation, filters and handlers specified."
msgstr ""
"Os registadores especificados serão configurados de acordo com o nível, "
"propagação, filtros e manipuladores especificados."

#: ../../library/logging.config.rst:349
msgid ""
"*root* - this will be the configuration for the root logger. Processing of "
"the configuration will be as for any logger, except that the ``propagate`` "
"setting will not be applicable."
msgstr ""
"*root* — esta será a configuração para o registador raiz. O processamento da "
"configuração será como para qualquer registador, exceto que a configuração "
"``propagate`` não será aplicável."

#: ../../library/logging.config.rst:353
msgid ""
"*incremental* - whether the configuration is to be interpreted as "
"incremental to the existing configuration.  This value defaults to "
"``False``, which means that the specified configuration replaces the "
"existing configuration with the same semantics as used by the existing :func:"
"`fileConfig` API."
msgstr ""
"*incremental* — se a configuração deve ser interpretada como incremental em "
"relação à configuração existente. Este valor é predefinido como ``False``, o "
"que significa que a configuração especificada substitui a configuração "
"existente com a mesma semântica usada pela API :func:`fileConfig` existente."

#: ../../library/logging.config.rst:359
msgid ""
"If the specified value is ``True``, the configuration is processed as "
"described in the section on :ref:`logging-config-dict-incremental`."
msgstr ""
"Se o valor especificado for ``True``, a configuração é processada como "
"descrito na secção sobre :ref:`logging-config-dict-incremental`."

#: ../../library/logging.config.rst:362
msgid ""
"*disable_existing_loggers* - whether any existing non-root loggers are to be "
"disabled. This setting mirrors the parameter of the same name in :func:"
"`fileConfig`. If absent, this parameter defaults to ``True``. This value is "
"ignored if *incremental* is ``True``."
msgstr ""
"*disable_existing_loggers* — se quaisquer registadores não-raiz existentes "
"devem ser desativados. Esta configuração espelha o parâmetro com o mesmo "
"nome em :func:`fileConfig`. Se ausente, este parâmetro é predefinido como "
"``True``. Este valor é ignorado se *incremental* for ``True``."

#: ../../library/logging.config.rst:370
msgid "Incremental Configuration"
msgstr "Configuração Incremental"

#: ../../library/logging.config.rst:372
msgid ""
"It is difficult to provide complete flexibility for incremental "
"configuration.  For example, because objects such as filters and formatters "
"are anonymous, once a configuration is set up, it is not possible to refer "
"to such anonymous objects when augmenting a configuration."
msgstr ""
"É difícil fornecer flexibilidade completa para configuração incremental. Por "
"exemplo, porque objetos como filtros e formatadores são anónimos, uma vez "
"estabelecida uma configuração, não é possível referir-se a tais objetos "
"anónimos ao aumentar uma configuração."

#: ../../library/logging.config.rst:378
msgid ""
"Furthermore, there is not a compelling case for arbitrarily altering the "
"object graph of loggers, handlers, filters, formatters at run-time, once a "
"configuration is set up; the verbosity of loggers and handlers can be "
"controlled just by setting levels (and, in the case of loggers, propagation "
"flags).  Changing the object graph arbitrarily in a safe way is problematic "
"in a multi-threaded environment; while not impossible, the benefits are not "
"worth the complexity it adds to the implementation."
msgstr ""
"Além disso, não há um caso convincente para alterar arbitrariamente o grafo "
"de objetos de registadores, manipuladores, filtros, formatadores em tempo de "
"execução, uma vez estabelecida uma configuração; a verbosidade de "
"registadores e manipuladores pode ser controlada simplesmente definindo "
"níveis (e, no caso de registadores, flags de propagação). Alterar o grafo de "
"objetos arbitrariamente de uma forma segura é problemático num ambiente "
"multi-thread; embora não seja impossível, os benefícios não valem a "
"complexidade que adiciona à implementação."

#: ../../library/logging.config.rst:387
msgid ""
"Thus, when the ``incremental`` key of a configuration dict is present and is "
"``True``, the system will completely ignore any ``formatters`` and "
"``filters`` entries, and process only the ``level`` settings in the "
"``handlers`` entries, and the ``level`` and ``propagate`` settings in the "
"``loggers`` and ``root`` entries."
msgstr ""
"Assim, quando a chave ``incremental`` de um dicionário de configuração está "
"presente e é ``True``, o sistema ignorará completamente quaisquer entradas "
"``formatters`` e ``filters``, e processará apenas as configurações ``level`` "
"nas entradas ``handlers``, e as configurações ``level`` e ``propagate`` nas "
"entradas ``loggers`` e ``root``."

#: ../../library/logging.config.rst:393
msgid ""
"Using a value in the configuration dict lets configurations to be sent over "
"the wire as pickled dicts to a socket listener. Thus, the logging verbosity "
"of a long-running application can be altered over time with no need to stop "
"and restart the application."
msgstr ""
"Usar um valor no dicionário de configuração permite que configurações sejam "
"enviadas através da rede como dicionários serializados para um ouvinte de "
"socket. Assim, a verbosidade de registo de uma aplicação de longa duração "
"pode ser alterada ao longo do tempo sem necessidade de parar e reiniciar a "
"aplicação."

#: ../../library/logging.config.rst:401
msgid "Object connections"
msgstr "Ligações de objetos"

#: ../../library/logging.config.rst:403
msgid ""
"The schema describes a set of logging objects - loggers, handlers, "
"formatters, filters - which are connected to each other in an object graph.  "
"Thus, the schema needs to represent connections between the objects.  For "
"example, say that, once configured, a particular logger has attached to it a "
"particular handler.  For the purposes of this discussion, we can say that "
"the logger represents the source, and the handler the destination, of a "
"connection between the two.  Of course in the configured objects this is "
"represented by the logger holding a reference to the handler.  In the "
"configuration dict, this is done by giving each destination object an id "
"which identifies it unambiguously, and then using the id in the source "
"object's configuration to indicate that a connection exists between the "
"source and the destination object with that id."
msgstr ""
"O esquema descreve um conjunto de objetos de registo — registadores, "
"manipuladores, formatadores, filtros — que estão ligados entre si num grafo "
"de objetos. Assim, o esquema precisa de representar ligações entre os "
"objetos. Por exemplo, digamos que, uma vez configurado, um registador "
"específico tem anexado a si um manipulador específico. Para os fins desta "
"discussão, podemos dizer que o registador representa a origem e o "
"manipulador o destino de uma ligação entre os dois. Claro que nos objetos "
"configurados isto é representado pelo registador que mantém uma referência "
"ao manipulador. No dicionário de configuração, isto é feito dando a cada "
"objeto de destino um id que o identifica de forma unívoca e, em seguida, "
"usando o id na configuração do objeto de origem para indicar que existe uma "
"ligação entre a origem e o objeto de destino com esse id."

#: ../../library/logging.config.rst:417
msgid "So, for example, consider the following YAML snippet:"
msgstr "Assim, por exemplo, considere o seguinte excerto YAML:"

#: ../../library/logging.config.rst:438
msgid ""
"(Note: YAML used here because it's a little more readable than the "
"equivalent Python source form for the dictionary.)"
msgstr ""
"(Nota: YAML usado aqui porque é um pouco mais legível do que a forma de "
"origem Python equivalente para o dicionário.)"

#: ../../library/logging.config.rst:441
msgid ""
"The ids for loggers are the logger names which would be used "
"programmatically to obtain a reference to those loggers, e.g. ``foo.bar."
"baz``.  The ids for Formatters and Filters can be any string value (such as "
"``brief``, ``precise`` above) and they are transient, in that they are only "
"meaningful for processing the configuration dictionary and used to determine "
"connections between objects, and are not persisted anywhere when the "
"configuration call is complete."
msgstr ""
"Os ids para registadores são os nomes dos registadores que seriam usados "
"programaticamente para obter uma referência a esses registadores, por "
"exemplo, ``foo.bar.baz``. Os ids para Formatadores e Filtros podem ser "
"qualquer valor de string (como ``brief``, ``precise`` acima) e são "
"transitórios, no sentido de que são significativos apenas para processar o "
"dicionário de configuração e usados para determinar ligações entre objetos, "
"e não são persistidos em nenhum lugar quando a chamada de configuração é "
"concluída."

#: ../../library/logging.config.rst:449
msgid ""
"The above snippet indicates that logger named ``foo.bar.baz`` should have "
"two handlers attached to it, which are described by the handler ids ``h1`` "
"and ``h2``. The formatter for ``h1`` is that described by id ``brief``, and "
"the formatter for ``h2`` is that described by id ``precise``."
msgstr ""
"O excerto acima indica que o registador chamado ``foo.bar.baz`` deve ter "
"dois manipuladores anexados a ele, que são descritos pelos ids de "
"manipulador ``h1`` e ``h2``. O formatador para ``h1`` é aquele descrito pelo "
"id ``brief``, e o formatador para ``h2`` é aquele descrito pelo id "
"``precise``."

#: ../../library/logging.config.rst:459
msgid "User-defined objects"
msgstr "Objetos definidos pelo utilizador"

#: ../../library/logging.config.rst:461
msgid ""
"The schema supports user-defined objects for handlers, filters and "
"formatters.  (Loggers do not need to have different types for different "
"instances, so there is no support in this configuration schema for user-"
"defined logger classes.)"
msgstr ""
"O esquema suporta objetos definidos pelo utilizador para manipuladores, "
"filtros e formatadores. (Os registadores não precisam de ter tipos "
"diferentes para instâncias diferentes, por isso não há suporte neste esquema "
"de configuração para classes de registadores definidas pelo utilizador.)"

#: ../../library/logging.config.rst:466
msgid ""
"Objects to be configured are described by dictionaries which detail their "
"configuration.  In some places, the logging system will be able to infer "
"from the context how an object is to be instantiated, but when a user-"
"defined object is to be instantiated, the system will not know how to do "
"this.  In order to provide complete flexibility for user-defined object "
"instantiation, the user needs to provide a 'factory' - a callable which is "
"called with a configuration dictionary and which returns the instantiated "
"object. This is signalled by an absolute import path to the factory being "
"made available under the special key ``'()'``.  Here's a concrete example:"
msgstr ""
"Os objetos a serem configurados são descritos por dicionários que detalham a "
"sua configuração. Em alguns lugares, o sistema de registo será capaz de "
"inferir a partir do contexto como um objeto deve ser instanciado, mas quando "
"um objeto definido pelo utilizador deve ser instanciado, o sistema não "
"saberá como fazê-lo. Para fornecer flexibilidade completa para a "
"instanciação de objetos definidos pelo utilizador, o utilizador precisa "
"fornecer uma 'fábrica' — um objeto chamável que é chamado com um dicionário "
"de configuração e que devolve o objeto instanciado. Isto é sinalizado por um "
"caminho de importação absoluto para a fábrica que é disponibilizado sob a "
"chave especial ``'()'``. Aqui está um exemplo concreto:"

#: ../../library/logging.config.rst:492
msgid ""
"The above YAML snippet defines three formatters.  The first, with id "
"``brief``, is a standard :class:`logging.Formatter` instance with the "
"specified format string.  The second, with id ``default``, has a longer "
"format and also defines the time format explicitly, and will result in a :"
"class:`logging.Formatter` initialized with those two format strings.  Shown "
"in Python source form, the ``brief`` and ``default`` formatters have "
"configuration sub-dictionaries::"
msgstr ""
"O excerto YAML acima define três formatadores. O primeiro, com id ``brief``, "
"é uma instância padrão de :class:`logging.Formatter` com a string de formato "
"especificada. O segundo, com id ``default``, tem um formato mais longo e "
"também define explicitamente o formato de tempo, e resultará num :class:"
"`logging.Formatter` inicializado com essas duas strings de formato. "
"Mostrados na forma de origem Python, os formatadores ``brief`` e ``default`` "
"têm subdicionários de configuração::"

#: ../../library/logging.config.rst:504
msgid "and::"
msgstr "e:"

#: ../../library/logging.config.rst:511
msgid ""
"respectively, and as these dictionaries do not contain the special key "
"``'()'``, the instantiation is inferred from the context: as a result, "
"standard :class:`logging.Formatter` instances are created.  The "
"configuration sub-dictionary for the third formatter, with id ``custom``, "
"is::"
msgstr ""
"respetivamente, e como estes dicionários não contêm a chave especial "
"``'()'``, a instanciação é inferida a partir do contexto: como resultado, "
"são criadas instâncias padrão de :class:`logging.Formatter`. O subdicionário "
"de configuração para o terceiro formatador, com id ``custom``, é::"

#: ../../library/logging.config.rst:524
msgid ""
"and this contains the special key ``'()'``, which means that user-defined "
"instantiation is wanted.  In this case, the specified factory callable will "
"be used. If it is an actual callable it will be used directly - otherwise, "
"if you specify a string (as in the example) the actual callable will be "
"located using normal import mechanisms. The callable will be called with the "
"**remaining** items in the configuration sub-dictionary as keyword "
"arguments.  In the above example, the formatter with id ``custom`` will be "
"assumed to be returned by the call::"
msgstr ""
"e isto contém a chave especial ``'()'``, o que significa que é desejada uma "
"instanciação definida pelo utilizador. Neste caso, o objeto chamável de "
"fábrica especificado será usado. Se for um objeto chamável real, será usado "
"diretamente — caso contrário, se especificar uma string (como no exemplo), o "
"objeto chamável real será localizado usando mecanismos de importação "
"normais. O objeto chamável será chamado com os **itens restantes** no "
"subdicionário de configuração como argumentos de palavra-chave. No exemplo "
"acima, o formatador com id ``custom`` será assumido como devolvido pela "
"chamada::"

#: ../../library/logging.config.rst:536
msgid ""
"The values for keys such as ``bar``, ``spam`` and ``answer`` in the above "
"example should not be configuration dictionaries or references such as "
"``cfg://foo`` or ``ext://bar``, because they will not be processed by the "
"configuration machinery, but passed to the callable as-is."
msgstr ""
"Os valores para chaves como ``bar``, ``spam`` e ``answer`` no exemplo acima "
"não devem ser dicionários de configuração ou referências como ``cfg://foo`` "
"ou ``ext://bar``, porque não serão processados pela maquinaria de "
"configuração, mas passados para o objeto chamável como estão."

#: ../../library/logging.config.rst:541
msgid ""
"The key ``'()'`` has been used as the special key because it is not a valid "
"keyword parameter name, and so will not clash with the names of the keyword "
"arguments used in the call.  The ``'()'`` also serves as a mnemonic that the "
"corresponding value is a callable."
msgstr ""
"A chave ``'()'`` foi usada como a chave especial porque não é um nome de "
"parâmetro de palavra-chave válido, e assim não entrará em conflito com os "
"nomes dos argumentos de palavra-chave usados na chamada. O ``'()'`` também "
"serve como um mnemónico de que o valor correspondente é um objeto chamável."

#: ../../library/logging.config.rst:546
msgid ""
"The ``filters`` member of ``handlers`` and ``loggers`` can take filter "
"instances in addition to ids."
msgstr ""
"O membro ``filters`` de ``handlers`` e ``loggers`` pode aceitar instâncias "
"de filtro além de ids."

#: ../../library/logging.config.rst:550
msgid ""
"You can also specify a special key ``'.'`` whose value is a dictionary is a "
"mapping of attribute names to values. If found, the specified attributes "
"will be set on the user-defined object before it is returned. Thus, with the "
"following configuration::"
msgstr ""

#: ../../library/logging.config.rst:566
msgid ""
"the returned formatter will have attribute ``foo`` set to ``'bar'`` and "
"attribute ``baz`` set to ``'bozz'``."
msgstr ""
"o formatador devolvido terá o atributo ``foo`` definido para ``'bar'`` e o "
"atributo ``baz`` definido para ``'bozz'``."

#: ../../library/logging.config.rst:569
msgid ""
"The values for attributes such as ``foo`` and ``baz`` in the above example "
"should not be configuration dictionaries or references such as ``cfg://foo`` "
"or ``ext://bar``, because they will not be processed by the configuration "
"machinery, but set as attribute values as-is."
msgstr ""
"Os valores para atributos como ``foo`` e ``baz`` no exemplo acima não devem "
"ser dicionários de configuração ou referências como ``cfg://foo`` ou ``ext://"
"bar``, porque não serão processados pela maquinaria de configuração, mas "
"definidos como valores de atributo como estão."

#: ../../library/logging.config.rst:578
msgid "Handler configuration order"
msgstr "Ordem de configuração do manipulador"

#: ../../library/logging.config.rst:580
msgid ""
"Handlers are configured in alphabetical order of their keys, and a "
"configured handler replaces the configuration dictionary in (a working copy "
"of) the ``handlers`` dictionary in the schema. If you use a construct such "
"as ``cfg://handlers.foo``, then initially ``handlers['foo']`` points to the "
"configuration dictionary for the handler named ``foo``, and later (once that "
"handler has been configured) it points to the configured handler instance. "
"Thus, ``cfg://handlers.foo`` could resolve to either a dictionary or a "
"handler instance. In general, it is wise to name handlers in a way such that "
"dependent handlers are configured _after_ any handlers they depend on; that "
"allows something like ``cfg://handlers.foo`` to be used in configuring a "
"handler that depends on handler ``foo``. If that dependent handler were "
"named ``bar``, problems would result, because the configuration of ``bar`` "
"would be attempted before that of ``foo``, and ``foo`` would not yet have "
"been configured. However, if the dependent handler were named ``foobar``, it "
"would be configured after ``foo``, with the result that ``cfg://handlers."
"foo`` would resolve to configured handler ``foo``, and not its configuration "
"dictionary."
msgstr ""

#: ../../library/logging.config.rst:601
msgid "Access to external objects"
msgstr "Acesso a objetos externos"

#: ../../library/logging.config.rst:603
msgid ""
"There are times where a configuration needs to refer to objects external to "
"the configuration, for example ``sys.stderr``.  If the configuration dict is "
"constructed using Python code, this is straightforward, but a problem arises "
"when the configuration is provided via a text file (e.g. JSON, YAML).  In a "
"text file, there is no standard way to distinguish ``sys.stderr`` from the "
"literal string ``'sys.stderr'``.  To facilitate this distinction, the "
"configuration system looks for certain special prefixes in string values and "
"treat them specially.  For example, if the literal string ``'ext://sys."
"stderr'`` is provided as a value in the configuration, then the ``ext://`` "
"will be stripped off and the remainder of the value processed using normal "
"import mechanisms."
msgstr ""
"Há alturas em que uma configuração precisa de se referir a objetos externos "
"à configuração, por exemplo, ``sys.stderr``. Se o dicionário de configuração "
"for construído usando código Python, isto é simples, mas surge um problema "
"quando a configuração é fornecida através de um ficheiro de texto (por "
"exemplo, JSON, YAML). Num ficheiro de texto, não há uma forma padrão de "
"distinguir ``sys.stderr`` da string literal ``'sys.stderr'``. Para facilitar "
"esta distinção, o sistema de configuração procura certos prefixos especiais "
"em valores de string e trata-os de forma especial. Por exemplo, se a string "
"literal ``'ext://sys.stderr'`` for fornecida como um valor na configuração, "
"então o ``ext://`` será removido e o restante do valor processado usando "
"mecanismos de importação normais."

#: ../../library/logging.config.rst:616
msgid ""
"The handling of such prefixes is done in a way analogous to protocol "
"handling: there is a generic mechanism to look for prefixes which match the "
"regular expression ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$`` whereby, if the "
"``prefix`` is recognised, the ``suffix`` is processed in a prefix-dependent "
"manner and the result of the processing replaces the string value.  If the "
"prefix is not recognised, then the string value will be left as-is."
msgstr ""
"O tratamento de tais prefixos é feito de uma forma análoga ao tratamento de "
"protocolos: existe um mecanismo genérico para procurar prefixos que "
"correspondam à expressão regular ``^(?P<prefix>[a-z]+)://(?P<suffix>.*)$``, "
"pelo qual, se o ``prefix`` for reconhecido, o ``suffix`` é processado de uma "
"forma dependente do prefixo e o resultado do processamento substitui o valor "
"da string. Se o prefixo não for reconhecido, então o valor da string será "
"deixado como está."

#: ../../library/logging.config.rst:628
msgid "Access to internal objects"
msgstr "Acesso a objetos internos"

#: ../../library/logging.config.rst:630
msgid ""
"As well as external objects, there is sometimes also a need to refer to "
"objects in the configuration.  This will be done implicitly by the "
"configuration system for things that it knows about.  For example, the "
"string value ``'DEBUG'`` for a ``level`` in a logger or handler will "
"automatically be converted to the value ``logging.DEBUG``, and the "
"``handlers``, ``filters`` and ``formatter`` entries will take an object id "
"and resolve to the appropriate destination object."
msgstr ""
"Além de objetos externos, às vezes também há necessidade de se referir a "
"objetos na configuração. Isto será feito implicitamente pelo sistema de "
"configuração para coisas que ele conhece. Por exemplo, o valor da string "
"``'DEBUG'`` para um ``level`` num registador ou manipulador será "
"automaticamente convertido para o valor ``logging.DEBUG``, e as entradas "
"``handlers``, ``filters`` e ``formatter`` aceitarão um id de objeto e "
"resolverão para o objeto de destino apropriado."

#: ../../library/logging.config.rst:638
msgid ""
"However, a more generic mechanism is needed for user-defined objects which "
"are not known to the :mod:`logging` module.  For example, consider :class:"
"`logging.handlers.MemoryHandler`, which takes a ``target`` argument which is "
"another handler to delegate to. Since the system already knows about this "
"class, then in the configuration, the given ``target`` just needs to be the "
"object id of the relevant target handler, and the system will resolve to the "
"handler from the id.  If, however, a user defines a ``my.package.MyHandler`` "
"which has an ``alternate`` handler, the configuration system would not know "
"that the ``alternate`` referred to a handler.  To cater for this, a generic "
"resolution system allows the user to specify:"
msgstr ""
"No entanto, é necessário um mecanismo mais genérico para objetos definidos "
"pelo utilizador que não são conhecidos pelo módulo :mod:`logging`. Por "
"exemplo, considere :class:`logging.handlers.MemoryHandler`, que aceita um "
"argumento ``target`` que é outro manipulador para delegar. Como o sistema já "
"conhece esta classe, então na configuração, o ``target`` dado precisa apenas "
"de ser o id do objeto do manipulador de destino relevante, e o sistema "
"resolverá para o manipulador a partir do id. Se, no entanto, um utilizador "
"definir um ``my.package.MyHandler`` que tem um manipulador ``alternate``, o "
"sistema de configuração não saberia que o ``alternate`` se referia a um "
"manipulador. Para lidar com isto, um sistema de resolução genérico permite "
"ao utilizador especificar:"

#: ../../library/logging.config.rst:660
msgid ""
"The literal string ``'cfg://handlers.file'`` will be resolved in an "
"analogous way to strings with the ``ext://`` prefix, but looking in the "
"configuration itself rather than the import namespace.  The mechanism allows "
"access by dot or by index, in a similar way to that provided by ``str."
"format``.  Thus, given the following snippet:"
msgstr ""
"A string literal ``'cfg://handlers.file'`` será resolvida de uma forma "
"análoga a strings com o prefixo ``ext://``, mas procurando na própria "
"configuração em vez do espaço de nomes de importação. O mecanismo permite "
"acesso por ponto ou por índice, de uma forma semelhante à fornecida por "
"``str.format``. Assim, dado o seguinte excerto:"

#: ../../library/logging.config.rst:678
msgid ""
"in the configuration, the string ``'cfg://handlers'`` would resolve to the "
"dict with key ``handlers``, the string ``'cfg://handlers.email`` would "
"resolve to the dict with key ``email`` in the ``handlers`` dict, and so on.  "
"The string ``'cfg://handlers.email.toaddrs[1]`` would resolve to "
"``'dev_team@domain.tld'`` and the string ``'cfg://handlers.email."
"toaddrs[0]'`` would resolve to the value ``'support_team@domain.tld'``. The "
"``subject`` value could be accessed using either ``'cfg://handlers.email."
"subject'`` or, equivalently, ``'cfg://handlers.email[subject]'``.  The "
"latter form only needs to be used if the key contains spaces or non-"
"alphanumeric characters.  If an index value consists only of decimal digits, "
"access will be attempted using the corresponding integer value, falling back "
"to the string value if needed."
msgstr ""

#: ../../library/logging.config.rst:692
msgid ""
"Given a string ``cfg://handlers.myhandler.mykey.123``, this will resolve to "
"``config_dict['handlers']['myhandler']['mykey']['123']``. If the string is "
"specified as ``cfg://handlers.myhandler.mykey[123]``, the system will "
"attempt to retrieve the value from ``config_dict['handlers']['myhandler']"
"['mykey'][123]``, and fall back to ``config_dict['handlers']['myhandler']"
"['mykey']['123']`` if that fails."
msgstr ""
"Dada uma string ``cfg://handlers.myhandler.mykey.123``, esta resolverá para "
"``config_dict['handlers']['myhandler']['mykey']['123']``. Se a string for "
"especificada como ``cfg://handlers.myhandler.mykey[123]``, o sistema tentará "
"recuperar o valor de ``config_dict['handlers']['myhandler']['mykey'][123]``, "
"e recuará para ``config_dict['handlers']['myhandler']['mykey']['123']`` se "
"isso falhar."

#: ../../library/logging.config.rst:704
msgid "Import resolution and custom importers"
msgstr "Resolução de importação e importadores personalizados"

#: ../../library/logging.config.rst:706
msgid ""
"Import resolution, by default, uses the builtin :func:`__import__` function "
"to do its importing. You may want to replace this with your own importing "
"mechanism: if so, you can replace the :attr:`importer` attribute of the :"
"class:`DictConfigurator` or its superclass, the :class:`BaseConfigurator` "
"class. However, you need to be careful because of the way functions are "
"accessed from classes via descriptors. If you are using a Python callable to "
"do your imports, and you want to define it at class level rather than "
"instance level, you need to wrap it with :func:`staticmethod`. For example::"
msgstr ""
"A resolução de importação, por predefinição, usa a função integrada :func:"
"`__import__` para fazer as suas importações. Pode querer substituir isto "
"pelo seu próprio mecanismo de importação: se for o caso, pode substituir o "
"atributo :attr:`importer` do :class:`DictConfigurator` ou da sua "
"superclasse, a classe :class:`BaseConfigurator`. No entanto, precisa de ter "
"cuidado devido à forma como as funções são acedidas a partir de classes "
"através de descritores. Se estiver a usar um objeto chamável Python para "
"fazer as suas importações, e quiser defini-lo ao nível da classe em vez de "
"ao nível da instância, precisa de o envolver com :func:`staticmethod`. Por "
"exemplo::"

#: ../../library/logging.config.rst:721
msgid ""
"You don't need to wrap with :func:`staticmethod` if you're setting the "
"import callable on a configurator *instance*."
msgstr ""
"Não precisa de envolver com :func:`staticmethod` se estiver a definir o "
"objeto chamável de importação numa *instância* de configurador."

#: ../../library/logging.config.rst:728
msgid "Configuration file format"
msgstr "Formato do ficheiro de configuração"

#: ../../library/logging.config.rst:730
msgid ""
"The configuration file format understood by :func:`fileConfig` is based on :"
"mod:`configparser` functionality. The file must contain sections called "
"``[loggers]``, ``[handlers]`` and ``[formatters]`` which identify by name "
"the entities of each type which are defined in the file. For each such "
"entity, there is a separate section which identifies how that entity is "
"configured.  Thus, for a logger named ``log01`` in the ``[loggers]`` "
"section, the relevant configuration details are held in a section "
"``[logger_log01]``. Similarly, a handler called ``hand01`` in the "
"``[handlers]`` section will have its configuration held in a section called "
"``[handler_hand01]``, while a formatter called ``form01`` in the "
"``[formatters]`` section will have its configuration specified in a section "
"called ``[formatter_form01]``. The root logger configuration must be "
"specified in a section called ``[logger_root]``."
msgstr ""
"O formato do ficheiro de configuração compreendido por :func:`fileConfig` é "
"baseado na funcionalidade :mod:`configparser`. O ficheiro deve conter "
"secções chamadas ``[loggers]``, ``[handlers]`` e ``[formatters]`` que "
"identificam por nome as entidades de cada tipo que são definidas no "
"ficheiro. Para cada uma dessas entidades, há uma secção separada que "
"identifica como essa entidade é configurada. Assim, para um registador "
"chamado ``log01`` na secção ``[loggers]``, os detalhes de configuração "
"relevantes são mantidos numa secção ``[logger_log01]``. Da mesma forma, um "
"manipulador chamado ``hand01`` na secção ``[handlers]`` terá a sua "
"configuração mantida numa secção chamada ``[handler_hand01]``, enquanto um "
"formatador chamado ``form01`` na secção ``[formatters]`` terá a sua "
"configuração especificada numa secção chamada ``[formatter_form01]``. A "
"configuração do registador raiz deve ser especificada numa secção chamada "
"``[logger_root]``."

#: ../../library/logging.config.rst:745
msgid ""
"The :func:`fileConfig` API is older than the :func:`dictConfig` API and does "
"not provide functionality to cover certain aspects of logging. For example, "
"you cannot configure :class:`~logging.Filter` objects, which provide for "
"filtering of messages beyond simple integer levels, using :func:"
"`fileConfig`. If you need to have instances of :class:`~logging.Filter` in "
"your logging configuration, you will need to use :func:`dictConfig`. Note "
"that future enhancements to configuration functionality will be added to :"
"func:`dictConfig`, so it's worth considering transitioning to this newer API "
"when it's convenient to do so."
msgstr ""
"A API :func:`fileConfig` é mais antiga que a API :func:`dictConfig` e não "
"fornece funcionalidade para cobrir certos aspetos do registo. Por exemplo, "
"não pode configurar objetos :class:`~logging.Filter`, que fornecem filtragem "
"de mensagens além de níveis inteiros simples, usando :func:`fileConfig`. Se "
"precisar de ter instâncias de :class:`~logging.Filter` na sua configuração "
"de registo, terá de usar :func:`dictConfig`. Note que melhorias futuras à "
"funcionalidade de configuração serão adicionadas a :func:`dictConfig`, por "
"isso vale a pena considerar a transição para esta API mais recente quando "
"for conveniente fazê-lo."

#: ../../library/logging.config.rst:755
msgid "Examples of these sections in the file are given below."
msgstr "Exemplos destas secções no ficheiro são dados abaixo."

#: ../../library/logging.config.rst:768
msgid ""
"The root logger must specify a level and a list of handlers. An example of a "
"root logger section is given below."
msgstr ""
"O registador raiz deve especificar um nível e uma lista de manipuladores. Um "
"exemplo de uma secção de registador raiz é dado abaixo."

#: ../../library/logging.config.rst:777
msgid ""
"The ``level`` entry can be one of ``DEBUG, INFO, WARNING, ERROR, CRITICAL`` "
"or ``NOTSET``. For the root logger only, ``NOTSET`` means that all messages "
"will be logged. Level values are :ref:`evaluated <func-eval>` in the context "
"of the ``logging`` package's namespace."
msgstr ""
"A entrada ``level`` pode ser uma de ``DEBUG, INFO, WARNING, ERROR, "
"CRITICAL`` ou ``NOTSET``. Para o registador raiz apenas, ``NOTSET`` "
"significa que todas as mensagens serão registadas. Os valores de nível são :"
"ref:`avaliados <func-eval>` no contexto do espaço de nomes do pacote "
"``logging``."

#: ../../library/logging.config.rst:782
msgid ""
"The ``handlers`` entry is a comma-separated list of handler names, which "
"must appear in the ``[handlers]`` section. These names must appear in the "
"``[handlers]`` section and have corresponding sections in the configuration "
"file."
msgstr ""
"A entrada ``handlers`` é uma lista separada por vírgulas de nomes de "
"manipuladores, que devem aparecer na secção ``[handlers]``. Estes nomes "
"devem aparecer na secção ``[handlers]`` e ter secções correspondentes no "
"ficheiro de configuração."

#: ../../library/logging.config.rst:787
msgid ""
"For loggers other than the root logger, some additional information is "
"required. This is illustrated by the following example."
msgstr ""
"Para registadores que não o registador raiz, é necessária alguma informação "
"adicional. Isto é ilustrado pelo exemplo seguinte."

#: ../../library/logging.config.rst:798
msgid ""
"The ``level`` and ``handlers`` entries are interpreted as for the root "
"logger, except that if a non-root logger's level is specified as ``NOTSET``, "
"the system consults loggers higher up the hierarchy to determine the "
"effective level of the logger. The ``propagate`` entry is set to 1 to "
"indicate that messages must propagate to handlers higher up the logger "
"hierarchy from this logger, or 0 to indicate that messages are **not** "
"propagated to handlers up the hierarchy. The ``qualname`` entry is the "
"hierarchical channel name of the logger, that is to say the name used by the "
"application to get the logger."
msgstr ""
"As entradas ``level`` e ``handlers`` são interpretadas como para o "
"registador raiz, exceto que se o nível de um registador não-raiz for "
"especificado como ``NOTSET``, o sistema consulta registadores mais acima na "
"hierarquia para determinar o nível efetivo do registador. A entrada "
"``propagate`` é definida como 1 para indicar que as mensagens devem propagar "
"para manipuladores mais acima na hierarquia de registadores a partir deste "
"registador, ou 0 para indicar que as mensagens **não** são propagadas para "
"manipuladores acima na hierarquia. A entrada ``qualname`` é o nome de canal "
"hierárquico do registador, ou seja, o nome usado pela aplicação para obter o "
"registador."

#: ../../library/logging.config.rst:807
msgid ""
"Sections which specify handler configuration are exemplified by the "
"following."
msgstr ""
"Secções que especificam a configuração do manipulador são exemplificadas "
"pelo seguinte."

#: ../../library/logging.config.rst:817
msgid ""
"The ``class`` entry indicates the handler's class (as determined by :func:"
"`eval` in the ``logging`` package's namespace). The ``level`` is interpreted "
"as for loggers, and ``NOTSET`` is taken to mean 'log everything'."
msgstr ""
"A entrada ``class`` indica a classe do manipulador (como determinado por :"
"func:`eval` no espaço de nomes do pacote ``logging``). O ``level`` é "
"interpretado como para registadores, e ``NOTSET`` é interpretado como "
"'registar tudo'."

#: ../../library/logging.config.rst:821
msgid ""
"The ``formatter`` entry indicates the key name of the formatter for this "
"handler. If blank, a default formatter (``logging._defaultFormatter``) is "
"used. If a name is specified, it must appear in the ``[formatters]`` section "
"and have a corresponding section in the configuration file."
msgstr ""
"A entrada ``formatter`` indica o nome da chave do formatador para este "
"manipulador. Se em branco, é usado um formatador predefinido (``logging."
"_defaultFormatter``). Se um nome for especificado, deve aparecer na secção "
"``[formatters]`` e ter uma secção correspondente no ficheiro de configuração."

#: ../../library/logging.config.rst:826
msgid ""
"The ``args`` entry, when :ref:`evaluated <func-eval>` in the context of the "
"``logging`` package's namespace, is the list of arguments to the constructor "
"for the handler class. Refer to the constructors for the relevant handlers, "
"or to the examples below, to see how typical entries are constructed. If not "
"provided, it defaults to ``()``."
msgstr ""
"A entrada ``args``, quando :ref:`avaliada <func-eval>` no contexto do espaço "
"de nomes do pacote ``logging``, é a lista de argumentos para o construtor da "
"classe do manipulador. Consulte os construtores para os manipuladores "
"relevantes, ou os exemplos abaixo, para ver como são construídas entradas "
"típicas. Se não for fornecida, o valor predefinido é ``()``."

#: ../../library/logging.config.rst:832
msgid ""
"The optional ``kwargs`` entry, when :ref:`evaluated <func-eval>` in the "
"context of the ``logging`` package's namespace, is the keyword argument dict "
"to the constructor for the handler class. If not provided, it defaults to "
"``{}``."
msgstr ""
"A entrada opcional ``kwargs``, quando :ref:`avaliada <func-eval>` no "
"contexto do espaço de nomes do pacote ``logging``, é o dicionário de "
"argumentos de palavra-chave para o construtor da classe do manipulador. Se "
"não for fornecida, o valor predefinido é ``{}``."

#: ../../library/logging.config.rst:889
msgid ""
"Sections which specify formatter configuration are typified by the following."
msgstr ""
"Secções que especificam a configuração do formatador são tipificadas pelo "
"seguinte."

#: ../../library/logging.config.rst:900
msgid ""
"The arguments for the formatter configuration are the same as the keys in "
"the dictionary schema :ref:`formatters section <logging-config-dictschema-"
"formatters>`."
msgstr ""
"Os argumentos para a configuração do formatador são os mesmos que as chaves "
"na secção do esquema do dicionário :ref:`formatters <logging-config-"
"dictschema-formatters>`."

#: ../../library/logging.config.rst:906
msgid ""
"Due to the use of :func:`eval` as described above, there are potential "
"security risks which result from using the :func:`listen` to send and "
"receive configurations via sockets. The risks are limited to where multiple "
"users with no mutual trust run code on the same machine; see the :func:"
"`listen` documentation for more information."
msgstr ""
"Devido ao uso de :func:`eval` como descrito acima, existem riscos de "
"segurança potenciais que resultam do uso de :func:`listen` para enviar e "
"receber configurações através de sockets. Os riscos são limitados a "
"situações onde vários utilizadores sem confiança mútua executam código na "
"mesma máquina; consulte a documentação de :func:`listen` para mais "
"informações."

#: ../../library/logging.config.rst:915
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../library/logging.config.rst:915
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de registo."

#: ../../library/logging.config.rst:917
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../../library/logging.config.rst:918
msgid "Useful handlers included with the logging module."
msgstr "Manipuladores úteis incluídos com o módulo de registo."
