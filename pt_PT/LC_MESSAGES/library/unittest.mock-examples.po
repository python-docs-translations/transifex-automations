# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-09 15:15+0000\n"
"PO-Revision-Date: 2025-09-15 01:05+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/unittest.mock-examples.rst:2
msgid ":mod:`!unittest.mock` --- getting started"
msgstr ":mod:`!unittest.mock` — introdução"

#: ../../library/unittest.mock-examples.rst:27
msgid "Using Mock"
msgstr "A utilizar Mock"

#: ../../library/unittest.mock-examples.rst:30
msgid "Mock Patching Methods"
msgstr "Substituição de métodos com Mock"

#: ../../library/unittest.mock-examples.rst:32
msgid "Common uses for :class:`Mock` objects include:"
msgstr "Usos comuns para objetos :class:`Mock` incluem:"

#: ../../library/unittest.mock-examples.rst:34
msgid "Patching methods"
msgstr "Substituir métodos"

#: ../../library/unittest.mock-examples.rst:35
msgid "Recording method calls on objects"
msgstr "Registar chamadas de métodos em objetos"

#: ../../library/unittest.mock-examples.rst:37
msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr ""
"Pode querer substituir um método num objeto para verificar se é chamado com "
"os argumentos corretos por outra parte do sistema:"

#: ../../library/unittest.mock-examples.rst:45
msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr ""
"Depois de o mock ser utilizado (``real.method`` neste exemplo), possui "
"métodos e atributos que permitem fazer afirmações sobre como foi utilizado."

#: ../../library/unittest.mock-examples.rst:50
msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"Na maioria destes exemplos, as classes :class:`Mock` e :class:`MagicMock` "
"são intercambiáveis. Como a ``MagicMock`` é a classe mais capaz, é a mais "
"sensata para utilizar por defeito."

#: ../../library/unittest.mock-examples.rst:54
msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"Depois de o mock ser chamado, o seu atributo :attr:`~Mock.called` é definido "
"para ``True``. Mais importante, podemos utilizar o método :meth:`~Mock."
"assert_called_with` ou :meth:`~Mock.assert_called_once_with` para verificar "
"se foi chamado com os argumentos corretos."

#: ../../library/unittest.mock-examples.rst:59
msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr ""
"Este exemplo testa que chamar ``ProductionClass().method`` resulta numa "
"chamada ao método ``something``:"

#: ../../library/unittest.mock-examples.rst:76
msgid "Mock for Method Calls on an Object"
msgstr "Mock para chamadas de métodos num objeto"

#: ../../library/unittest.mock-examples.rst:78
msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"No último exemplo, substituímos um método diretamente num objeto para "
"verificar se foi chamado corretamente. Outro caso de uso comum é passar um "
"objeto para um método (ou alguma parte do sistema em teste) e depois "
"verificar se é utilizado da forma correta."

#: ../../library/unittest.mock-examples.rst:83
msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"A classe ``ProductionClass`` simples abaixo tem um método ``closer``. Se for "
"chamado com um objeto, chama ``close`` nesse objeto."

#: ../../library/unittest.mock-examples.rst:91
msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr ""
"Para testá-lo, precisamos de passar um objeto com um método ``close`` e "
"verificar se foi chamado corretamente."

#: ../../library/unittest.mock-examples.rst:99
msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"Não precisamos de fazer nenhum trabalho para fornecer o método 'close' no "
"nosso mock. Aceder a 'close' cria-o. Portanto, se 'close' ainda não foi "
"chamado, aceder a ele no teste irá criá-lo, mas :meth:`~Mock."
"assert_called_with` irá lançar uma exceção de falha."

#: ../../library/unittest.mock-examples.rst:106
msgid "Mocking Classes"
msgstr "Mock de classes"

#: ../../library/unittest.mock-examples.rst:108
msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"Um caso de uso comum é criar mocks de classes instanciadas pelo seu código "
"em teste. Quando substitui uma classe, essa classe é substituída por um "
"mock. As instâncias são criadas ao *chamar a classe*. Isto significa que "
"acede à \"instância mock\" ao observar o valor de retorno da classe "
"substituída."

#: ../../library/unittest.mock-examples.rst:113
msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"No exemplo abaixo, temos uma função ``some_function`` que instancia ``Foo`` "
"e chama um método nela. A chamada a :func:`patch` substitui a classe ``Foo`` "
"por um mock. A instância ``Foo`` é o resultado de chamar o mock, pelo que é "
"configurada ao modificar o :attr:`~Mock.return_value`. ::"

#: ../../library/unittest.mock-examples.rst:118
msgid ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"
msgstr ""
">>> def some_function():\n"
"...     instance = module.Foo()\n"
"...     return instance.method()\n"
"...\n"
">>> with patch('module.Foo') as mock:\n"
"...     instance = mock.return_value\n"
"...     instance.method.return_value = 'the result'\n"
"...     result = some_function()\n"
"...     assert result == 'the result'"

#: ../../library/unittest.mock-examples.rst:130
msgid "Naming your mocks"
msgstr "Atribuir nomes aos seus mocks"

#: ../../library/unittest.mock-examples.rst:132
msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"Pode ser útil atribuir um nome aos seus mocks. O nome é apresentado na "
"representação do mock e pode ser útil quando o mock aparece em mensagens de "
"falha de teste. O nome também é propagado para atributos ou métodos do mock:"

#: ../../library/unittest.mock-examples.rst:144
msgid "Tracking all Calls"
msgstr "Registar todas as chamadas"

#: ../../library/unittest.mock-examples.rst:146
msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr ""
"Muitas vezes, quer registar mais do que uma única chamada a um método. O "
"atributo :attr:`~Mock.mock_calls` regista todas as chamadas a atributos "
"filhos do mock — e também aos seus descendentes."

#: ../../library/unittest.mock-examples.rst:158
msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"Se fizer uma afirmação sobre ``mock_calls`` e algum método inesperado tiver "
"sido chamado, a afirmação falhará. Isto é útil porque, além de afirmar que "
"as chamadas esperadas foram feitas, também está a verificar se foram feitas "
"pela ordem correta e sem chamadas adicionais:"

#: ../../library/unittest.mock-examples.rst:163
msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ""
"Utiliza o objeto :data:`call` para construir listas para comparar com "
"``mock_calls``:"

#: ../../library/unittest.mock-examples.rst:170
msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr ""
"No entanto, os parâmetros de chamadas que retornam mocks não são registados, "
"o que significa que não é possível rastrear chamadas aninhadas em que os "
"parâmetros usados para criar ancestrais são importantes:"

#: ../../library/unittest.mock-examples.rst:181
msgid "Setting Return Values and Attributes"
msgstr "Definir valores de retorno e atributos"

#: ../../library/unittest.mock-examples.rst:183
msgid "Setting the return values on a mock object is trivially easy:"
msgstr "Definir os valores de retorno num objeto mock é trivial:"

#: ../../library/unittest.mock-examples.rst:190
msgid "Of course you can do the same for methods on the mock:"
msgstr "Claro que pode fazer o mesmo para métodos no mock:"

#: ../../library/unittest.mock-examples.rst:197
msgid "The return value can also be set in the constructor:"
msgstr "O valor de retorno também pode ser definido no construtor:"

#: ../../library/unittest.mock-examples.rst:203
msgid "If you need an attribute setting on your mock, just do it:"
msgstr "Se precisar de definir um atributo no seu mock, basta fazê-lo:"

#: ../../library/unittest.mock-examples.rst:210
msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"Às vezes, quer simular uma situação mais complexa, como por exemplo ``mock."
"connection.cursor().execute(\"SELECT 1\")``. Se quiséssemos que esta chamada "
"retornasse uma lista, teríamos de configurar o resultado da chamada aninhada."

#: ../../library/unittest.mock-examples.rst:214
msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr ""
"Podemos utilizar :data:`call` para construir o conjunto de chamadas numa "
"\"chamada encadeada\" como esta, para afirmações fáceis posteriormente:"

#: ../../library/unittest.mock-examples.rst:228
msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr ""
"É a chamada a ``.call_list()`` que transforma o nosso objeto de chamada numa "
"lista de chamadas que representam as chamadas encadeadas."

#: ../../library/unittest.mock-examples.rst:233
msgid "Raising exceptions with mocks"
msgstr "Lançar exceções com mocks"

#: ../../library/unittest.mock-examples.rst:235
msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"Um atributo útil é :attr:`~Mock.side_effect`. Se o definir para uma classe "
"ou instância de exceção, a exceção será lançada quando o mock for chamado."

#: ../../library/unittest.mock-examples.rst:247
msgid "Side effect functions and iterables"
msgstr "Funções e iteráveis de efeito lateral"

#: ../../library/unittest.mock-examples.rst:249
msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` também pode ser definido como uma função ou um iterável. O "
"caso de uso de ``side_effect`` como iterável é quando o seu mock vai ser "
"chamado várias vezes, e quer que cada chamada retorne um valor diferente. "
"Quando define ``side_effect`` como um iterável, cada chamada ao mock retorna "
"o próximo valor do iterável:"

#: ../../library/unittest.mock-examples.rst:264
msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"Para casos de uso mais avançados, como variar dinamicamente os valores de "
"retorno dependendo dos argumentos com que o mock é chamado, ``side_effect`` "
"pode ser uma função. A função será chamada com os mesmos argumentos que o "
"mock. O que a função retornar é o que a chamada retorna:"

#: ../../library/unittest.mock-examples.rst:281
msgid "Mocking asynchronous iterators"
msgstr "Mock de iteradores assíncronos"

#: ../../library/unittest.mock-examples.rst:283
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"Desde o Python 3.8, ``AsyncMock`` e ``MagicMock`` suportam a simulação de :"
"ref:`async-iterators` através de ``__aiter__``. O atributo :attr:`~Mock."
"return_value` de ``__aiter__`` pode ser usado para definir os valores de "
"retorno a serem usados na iteração."

#: ../../library/unittest.mock-examples.rst:298
msgid "Mocking asynchronous context manager"
msgstr "Mock de gestores de contexto assíncronos"

#: ../../library/unittest.mock-examples.rst:300
msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"Desde o Python 3.8, ``AsyncMock`` e ``MagicMock`` suportam a simulação de :"
"ref:`async-context-managers` através de ``__aenter__`` e ``__aexit__``. Por "
"defeito, ``__aenter__`` e ``__aexit__`` são instâncias de ``AsyncMock`` que "
"retornam uma função assíncrona."

#: ../../library/unittest.mock-examples.rst:322
msgid "Creating a Mock from an Existing Object"
msgstr "Criar um Mock a partir de um objeto existente"

#: ../../library/unittest.mock-examples.rst:324
msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"Um problema do uso excessivo de mocks é que acopla os seus testes à "
"implementação dos seus mocks em vez do seu código real. Suponha que tem uma "
"classe que implementa ``some_method``. Num teste para outra classe, fornece "
"um mock deste objeto que também fornece ``some_method``. Se mais tarde "
"refatorar a primeira classe, de forma a que já não tenha ``some_method``, os "
"seus testes continuarão a passar, mesmo que o seu código esteja agora "
"quebrado!"

#: ../../library/unittest.mock-examples.rst:331
msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` permite-lhe fornecer um objeto como especificação para o mock, "
"usando o argumento nomeado *spec*. Aceder a métodos/atributos no mock que "
"não existam no objeto de especificação irá levantar imediatamente um erro de "
"atributo. Se alterar a implementação da sua especificação, os testes que "
"usam essa classe começarão a falhar imediatamente, sem precisar de "
"instanciar a classe nesses testes."

#: ../../library/unittest.mock-examples.rst:344
msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr ""
"Utilizar uma especificação também permite uma correspondência mais "
"inteligente das chamadas feitas ao mock, independentemente de alguns "
"parâmetros terem sido passados como argumentos posicionais ou nomeados:"

#: ../../library/unittest.mock-examples.rst:348
msgid ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"
msgstr ""
">>> def f(a, b, c): pass\n"
"...\n"
">>> mock = Mock(spec=f)\n"
">>> mock(1, 2, 3)\n"
"<Mock name='mock()' id='140161580456576'>\n"
">>> mock.assert_called_with(a=1, b=2, c=3)"

#: ../../library/unittest.mock-examples.rst:355
msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"Se quiser que esta correspondência mais inteligente também funcione com "
"chamadas de métodos no mock, pode usar :ref:`auto-speccing <auto-speccing>`."

#: ../../library/unittest.mock-examples.rst:358
msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"Se quiser uma forma mais forte de especificação que impeça a definição de "
"atributos arbitrários, bem como a obtenção dos mesmos, pode usar *spec_set* "
"em vez de *spec*."

#: ../../library/unittest.mock-examples.rst:364
msgid "Using side_effect to return per file content"
msgstr "Usar side_effect para retornar conteúdo por ficheiro"

#: ../../library/unittest.mock-examples.rst:366
msgid ""
":func:`mock_open` is used to patch :func:`open` method. :attr:`~Mock."
"side_effect` can be used to return a new Mock object per call. This can be "
"used to return different contents per file stored in a dictionary::"
msgstr ""
":func:`mock_open` é usado para substituir o método :func:`open`. :attr:"
"`~Mock.side_effect` pode ser usado para retornar um novo objeto Mock por "
"chamada. Isto pode ser usado para retornar conteúdos diferentes por ficheiro "
"armazenados num dicionário:"

#: ../../library/unittest.mock-examples.rst:370
msgid ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"data1\",\n"
"             \"file2\": \"data2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"data1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"data2\"\n"
"\n"
"    with open(\"file3\") as file2:\n"
"        assert file2.read() == \"default\""
msgstr ""
"DEFAULT = \"default\"\n"
"data_dict = {\"file1\": \"dados1\",\n"
"             \"file2\": \"dados2\"}\n"
"\n"
"def open_side_effect(name):\n"
"    return mock_open(read_data=data_dict.get(name, DEFAULT))()\n"
"\n"
"with patch(\"builtins.open\", side_effect=open_side_effect):\n"
"    with open(\"file1\") as file1:\n"
"        assert file1.read() == \"dados1\"\n"
"\n"
"    with open(\"file2\") as file2:\n"
"        assert file2.read() == \"dados2\"\n"
"\n"
"    with open(\"file3\") as file3:\n"
"        assert file3.read() == \"default\""

#: ../../library/unittest.mock-examples.rst:389
msgid "Patch Decorators"
msgstr "Decoradores de substituição"

#: ../../library/unittest.mock-examples.rst:393
msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"Com :func:`patch`, é importante substituir objetos no espaço de nomes onde "
"são procurados. Isto é normalmente simples, mas para um guia rápido leia :"
"ref:`onde substituir <where-to-patch>`."

#: ../../library/unittest.mock-examples.rst:398
msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"Uma necessidade comum em testes é substituir um atributo de classe ou um "
"atributo de módulo, por exemplo, substituir uma função integrada ou "
"substituir uma classe num módulo para testar se é instanciada. Módulos e "
"classes são efetivamente globais, por isso a substituição deve ser desfeita "
"após o teste, ou a substituição persistirá noutros testes e causará "
"problemas difíceis de diagnosticar."

#: ../../library/unittest.mock-examples.rst:404
msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"mock fornece três decoradores convenientes para isto: :func:`patch`, :func:"
"`patch.object` e :func:`patch.dict`. ``patch`` recebe uma string única, no "
"formato ``package.module.Class.attribute`` para especificar o atributo que "
"está a substituir. Também pode opcionalmente receber um valor que deseja que "
"o atributo (ou classe ou outro) seja substituído. 'patch.object' recebe um "
"objeto e o nome do atributo que deseja substituir, além do valor opcional "
"para a substituição."

#: ../../library/unittest.mock-examples.rst:412
msgid "``patch.object``::"
msgstr "``patch.object``:"

#: ../../library/unittest.mock-examples.rst:414
msgid ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> original = SomeClass.attribute\n"
">>> @patch.object(SomeClass, 'attribute', sentinel.attribute)\n"
"... def test():\n"
"...     assert SomeClass.attribute == sentinel.attribute\n"
"...\n"
">>> test()\n"
">>> assert SomeClass.attribute == original\n"
"\n"
">>> @patch('package.module.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import attribute\n"
"...     assert attribute is sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:429
msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"Se estiver a substituir um módulo (incluindo :mod:`builtins`), utilize :func:"
"`patch` em vez de :func:`patch.object`:"

#: ../../library/unittest.mock-examples.rst:439
msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr ""
"O nome do módulo pode ser 'pontuado', na forma ``package.module`` se "
"necessário:"

#: ../../library/unittest.mock-examples.rst:441
msgid ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"
msgstr ""
">>> @patch('package.module.ClassName.attribute', sentinel.attribute)\n"
"... def test():\n"
"...     from package.module import ClassName\n"
"...     assert ClassName.attribute == sentinel.attribute\n"
"...\n"
">>> test()"

#: ../../library/unittest.mock-examples.rst:448
msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "Um padrão útil é decorar os próprios métodos de teste:"

#: ../../library/unittest.mock-examples.rst:459
msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Se quiser substituir com um Mock, pode usar :func:`patch` com apenas um "
"argumento (ou :func:`patch.object` com dois argumentos). O mock será criado "
"para si e passado para a função/método de teste:"

#: ../../library/unittest.mock-examples.rst:471
msgid "You can stack up multiple patch decorators using this pattern::"
msgstr "Pode empilhar vários decoradores de substituição usando este padrão:"

#: ../../library/unittest.mock-examples.rst:473
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     @patch('package.module.ClassName1')\n"
"...     @patch('package.module.ClassName2')\n"
"...     def test_something(self, MockClass2, MockClass1):\n"
"...         self.assertIs(package.module.ClassName1, MockClass1)\n"
"...         self.assertIs(package.module.ClassName2, MockClass2)\n"
"...\n"
">>> MyTest('test_something').test_something()"

#: ../../library/unittest.mock-examples.rst:482
msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"Quando aninha decoradores de substituição, os mocks são passados para a "
"função decorada na mesma ordem em que foram aplicados (a ordem normal do "
"*Python* em que os decoradores são aplicados). Isto significa de baixo para "
"cima, por isso no exemplo acima, o mock para ``test_module.ClassName2`` é "
"passado primeiro."

#: ../../library/unittest.mock-examples.rst:487
msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Também existe :func:`patch.dict` para definir valores num dicionário apenas "
"durante um âmbito e restaurar o dicionário para o seu estado original quando "
"o teste termina:"

#: ../../library/unittest.mock-examples.rst:498
msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr ""
"``patch``, ``patch.object`` e ``patch.dict`` podem todos ser usados como "
"gestores de contexto."

#: ../../library/unittest.mock-examples.rst:500
msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"Quando usa :func:`patch` para criar um mock para si, pode obter uma "
"referência ao mock usando a forma \"as\" da instrução with:"

#: ../../library/unittest.mock-examples.rst:515
msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"Como alternativa, ``patch``, ``patch.object`` e ``patch.dict`` podem ser "
"usados como decoradores de classe. Quando usados desta forma, é o mesmo que "
"aplicar o decorador individualmente a cada método cujo nome começa com "
"\"test\"."

#: ../../library/unittest.mock-examples.rst:523
msgid "Further Examples"
msgstr "Mais exemplos"

#: ../../library/unittest.mock-examples.rst:526
msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "Aqui estão mais alguns exemplos para cenários um pouco mais avançados."

#: ../../library/unittest.mock-examples.rst:530
msgid "Mocking chained calls"
msgstr "Mock de chamadas encadeadas"

#: ../../library/unittest.mock-examples.rst:532
msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"Fazer mock de chamadas encadeadas é na verdade simples com mock depois de "
"entender o atributo :attr:`~Mock.return_value`. Quando um mock é chamado "
"pela primeira vez, ou quando obtém o seu ``return_value`` antes de ser "
"chamado, um novo :class:`Mock` é criado."

#: ../../library/unittest.mock-examples.rst:537
msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"Isto significa que pode ver como o objeto retornado de uma chamada a um "
"objeto mock foi utilizado, interrogando o mock ``return_value``:"

#: ../../library/unittest.mock-examples.rst:545
msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr ""
"A partir daqui, é um passo simples configurar e depois fazer afirmações "
"sobre chamadas encadeadas. Claro que outra alternativa é escrever o seu "
"código de uma forma mais testável desde o início..."

#: ../../library/unittest.mock-examples.rst:549
msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "Suponhamos que temos algum código que se parece um pouco com isto:"

#: ../../library/unittest.mock-examples.rst:558
msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"Assumindo que ``BackendProvider`` já está bem testado, como testamos "
"``method()``? Especificamente, queremos testar se a secção de código ``# "
"more code`` utiliza o objeto de resposta da forma correta."

#: ../../library/unittest.mock-examples.rst:562
msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"Como esta cadeia de chamadas é feita a partir de um atributo de instância, "
"podemos fazer monkey patch do atributo ``backend`` numa instância de "
"``Something``. Neste caso específico, estamos apenas interessados no valor "
"de retorno da chamada final para ``start_call``, por isso não temos muita "
"configuração a fazer. Vamos assumir que o objeto que retorna é 'file-like', "
"por isso vamos garantir que o nosso objeto de resposta usa a função "
"integrada :func:`open` como o seu ``spec``."

#: ../../library/unittest.mock-examples.rst:569
msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"Para fazer isto, criamos uma instância mock como nosso backend mock e "
"criamos um objeto de resposta mock para ele. Para definir a resposta como o "
"valor de retorno para aquele ``start_call`` final, podemos fazer isto:"

#: ../../library/unittest.mock-examples.rst:573
msgid ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"
msgstr ""
"mock_backend.get_endpoint.return_value.create_call.return_value.start_call."
"return_value = mock_response"

#: ../../library/unittest.mock-examples.rst:575
msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr ""
"Podemos fazer isso de uma forma um pouco mais elegante usando o método :meth:"
"`~Mock.configure_mock` para definir diretamente o valor de retorno para nós:"

#: ../../library/unittest.mock-examples.rst:578
msgid ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"
msgstr ""
">>> something = Something()\n"
">>> mock_response = Mock(spec=open)\n"
">>> mock_backend = Mock()\n"
">>> config = {'get_endpoint.return_value.create_call.return_value.start_call."
"return_value': mock_response}\n"
">>> mock_backend.configure_mock(**config)"

#: ../../library/unittest.mock-examples.rst:584
msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr ""
"Com estes, fazemos monkey patch do \"mock backend\" no local e podemos fazer "
"a chamada real:"

#: ../../library/unittest.mock-examples.rst:587
msgid ""
">>> something.backend = mock_backend\n"
">>> something.method()"
msgstr ""
">>> something.backend = mock_backend\n"
">>> something.method()"

#: ../../library/unittest.mock-examples.rst:590
msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"Usando :attr:`~Mock.mock_calls`, podemos verificar a chamada encadeada com "
"uma única afirmação. Uma chamada encadeada são várias chamadas numa linha de "
"código, por isso haverá várias entradas em ``mock_calls``. Podemos usar :"
"meth:`call.call_list` para criar esta lista de chamadas para nós:"

#: ../../library/unittest.mock-examples.rst:595
msgid ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"
msgstr ""
">>> chained = call.get_endpoint('foobar').create_call('spam', 'eggs')."
"start_call()\n"
">>> call_list = chained.call_list()\n"
">>> assert mock_backend.mock_calls == call_list"

#: ../../library/unittest.mock-examples.rst:601
msgid "Partial mocking"
msgstr "Mock parcial"

#: ../../library/unittest.mock-examples.rst:603
msgid ""
"For some tests, you may want to mock out a call to :meth:`datetime.date."
"today` to return a known date, but don't want to prevent the code under test "
"from creating new date objects. Unfortunately :class:`datetime.date` is "
"written in C, so you cannot just monkey-patch out the static :meth:`datetime."
"date.today` method."
msgstr ""
"Para alguns testes, pode querer fazer mock de uma chamada a :meth:`datetime."
"date.today` para retornar uma data conhecida, mas não quer impedir que o "
"código em teste crie novos objetos de data. Infelizmente, :class:`datetime."
"date` está escrito em C, por isso não pode simplesmente fazer monkey-patch "
"do método estático :meth:`datetime.date.today`."

#: ../../library/unittest.mock-examples.rst:608
msgid ""
"Instead, you can effectively wrap the date class with a mock, while passing "
"through calls to the constructor to the real class (and returning real "
"instances)."
msgstr ""
"Em vez disso, pode envolver efetivamente a classe de data com um mock, "
"enquanto passa as chamadas para o construtor para a classe real (e retorna "
"instâncias reais)."

#: ../../library/unittest.mock-examples.rst:612
msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`~Mock.side_effect` attribute on "
"the mock date class is then set to a lambda function that returns a real "
"date. When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
"O decorador :func:`patch <patch>` é usado aqui para fazer mock da classe "
"``date`` no módulo em teste. O atributo :attr:`~Mock.side_effect` na classe "
"de data mock é então definido para uma função lambda que retorna uma data "
"real. Quando a classe de data mock é chamada, uma data real será construída "
"e retornada por ``side_effect``:"

#: ../../library/unittest.mock-examples.rst:618
msgid ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"
msgstr ""
">>> from datetime import date\n"
">>> with patch('mymodule.date') as mock_date:\n"
"...     mock_date.today.return_value = date(2010, 10, 8)\n"
"...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)\n"
"...\n"
"...     assert mymodule.date.today() == date(2010, 10, 8)\n"
"...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)"

#: ../../library/unittest.mock-examples.rst:626
msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"Note que não fazemos patch de :class:`datetime.date` globalmente, fazemos "
"patch de ``date`` no módulo que o *usa*. Veja :ref:`onde fazer patch <where-"
"to-patch>`."

#: ../../library/unittest.mock-examples.rst:629
msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"Quando ``date.today()`` é chamado, uma data conhecida é retornada, mas as "
"chamadas para o construtor ``date(...)`` ainda retornam datas normais. Sem "
"isto, pode encontrar-se a ter de calcular um resultado esperado usando "
"exatamente o mesmo algoritmo que o código em teste, o que é um anti-padrão "
"clássico de teste."

#: ../../library/unittest.mock-examples.rst:634
msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"As chamadas ao construtor de data são registadas nos atributos ``mock_date`` "
"(``call_count`` e outros) que também podem ser úteis para os seus testes."

#: ../../library/unittest.mock-examples.rst:637
msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"Uma forma alternativa de lidar com mocks de datas, ou outras classes "
"integradas, é discutida nesta `entrada de blog <https://williambert."
"online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/>`_."

#: ../../library/unittest.mock-examples.rst:643
msgid "Mocking a Generator Method"
msgstr "Mock de um método gerador"

#: ../../library/unittest.mock-examples.rst:645
msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr ""
"Um gerador Python é uma função ou método que usa a instrução :keyword:"
"`yield` para retornar uma série de valores quando iterado sobre [#]_."

#: ../../library/unittest.mock-examples.rst:648
msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"Um método/função gerador é chamado para retornar o objeto gerador. É o "
"objeto gerador que é então iterado. O método de protocolo para iteração é :"
"meth:`~container.__iter__`, por isso podemos fazer mock disso usando um :"
"class:`MagicMock`."

#: ../../library/unittest.mock-examples.rst:653
msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr ""
"Aqui está um exemplo de uma classe com um método \"iter\" implementado como "
"um gerador:"

#: ../../library/unittest.mock-examples.rst:665
msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr ""
"Como faríamos mock desta classe, e em particular do seu método \"iter\"?"

#: ../../library/unittest.mock-examples.rst:667
msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"Para configurar os valores retornados da iteração (implícita na chamada a :"
"class:`list`), precisamos de configurar o objeto retornado pela chamada a "
"``foo.iter()``."

#: ../../library/unittest.mock-examples.rst:675
msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"Também existem expressões geradoras e usos mais `avançados <http://www."
"dabeaz.com/coroutines/index.html>`_ de geradores, mas não estamos "
"preocupados com eles aqui. Uma introdução muito boa a geradores e ao seu "
"poder é: `Generator Tricks for Systems Programmers <http://www.dabeaz.com/"
"generators/>`_."

#: ../../library/unittest.mock-examples.rst:683
msgid "Applying the same patch to every test method"
msgstr "Aplicar o mesmo patch a todos os métodos de teste"

#: ../../library/unittest.mock-examples.rst:685
msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"Se quiser vários patches em vigor para múltiplos métodos de teste, a forma "
"óbvia é aplicar os decoradores de patch a cada método. Isto pode parecer uma "
"repetição desnecessária. Em vez disso, pode usar :func:`patch` (em todas as "
"suas formas) como um decorador de classe. Isto aplica os patches a todos os "
"métodos de teste na classe. Um método de teste é identificado por métodos "
"cujos nomes começam com ``test``:"

#: ../../library/unittest.mock-examples.rst:692
msgid ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"
msgstr ""
">>> @patch('mymodule.SomeClass')\n"
"... class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_one(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def test_two(self, MockSomeClass):\n"
"...         self.assertIs(mymodule.SomeClass, MockSomeClass)\n"
"...\n"
"...     def not_a_test(self):\n"
"...         return 'something'\n"
"...\n"
">>> MyTest('test_one').test_one()\n"
">>> MyTest('test_two').test_two()\n"
">>> MyTest('test_two').not_a_test()\n"
"'something'"

#: ../../library/unittest.mock-examples.rst:709
msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"Uma forma alternativa de gerir patches é usar :ref:`start-and-stop`. Isto "
"permite mover a substituição para os seus métodos ``setUp`` e ``tearDown``:"

#: ../../library/unittest.mock-examples.rst:713
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         self.patcher = patch('mymodule.foo')\n"
"...         self.mock_foo = self.patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
"...     def tearDown(self):\n"
"...         self.patcher.stop()\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""

#: ../../library/unittest.mock-examples.rst:726
msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Se usar esta técnica, deve garantir que a substituição é \"desfeita\" "
"chamando ``stop``. Isto pode ser mais complicado do que parece, porque se "
"uma exceção for lançada no setUp, o tearDown não é chamado. :meth:`unittest."
"TestCase.addCleanup` facilita este processo:"

#: ../../library/unittest.mock-examples.rst:731
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...     def setUp(self):\n"
"...         patcher = patch('mymodule.foo')\n"
"...         self.addCleanup(patcher.stop)\n"
"...         self.mock_foo = patcher.start()\n"
"...\n"
"...     def test_foo(self):\n"
"...         self.assertIs(mymodule.foo, self.mock_foo)\n"
"...\n"
">>> MyTest('test_foo').run()"

#: ../../library/unittest.mock-examples.rst:744
msgid "Mocking Unbound Methods"
msgstr "Mock de métodos não ligados"

#: ../../library/unittest.mock-examples.rst:746
msgid ""
"Sometimes a test needs to patch an *unbound method*, which means patching "
"the method on the class rather than on the instance. In order to make "
"assertions about which objects were calling this particular method, you need "
"to pass ``self`` as the first argument. The issue is that you can't patch "
"with a mock for this, because if you replace an unbound method with a mock "
"it doesn't become a bound method when fetched from the instance, and so it "
"doesn't get ``self`` passed in. The workaround is to patch the unbound "
"method with a real function instead. The :func:`patch` decorator makes it so "
"simple to patch out methods with a mock that having to create a real "
"function becomes a nuisance."
msgstr ""
"Às vezes, um teste precisa de substituir um *método não ligado*, o que "
"significa substituir o método na classe em vez de na instância. Para fazer "
"afirmações sobre quais objetos chamaram este método específico, precisa de "
"passar ``self`` como o primeiro argumento. O problema é que não pode "
"substituir com um mock para isto, porque se substituir um método não ligado "
"por um mock, este não se torna um método ligado quando é obtido a partir da "
"instância, e assim não recebe ``self``. A solução é substituir o método não "
"ligado por uma função real. O decorador :func:`patch` torna tão simples "
"substituir métodos com um mock que criar uma função real se torna um "
"incómodo."

#: ../../library/unittest.mock-examples.rst:756
msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what was needed:"
msgstr ""
"Se passar ``autospec=True`` para patch, este faz a substituição com um "
"objeto de função *real*. Este objeto de função tem a mesma assinatura que o "
"que está a substituir, mas delega num mock internamente. Ainda assim, o seu "
"mock é criado automaticamente da mesma forma que antes. Isto significa que, "
"se o usar para substituir um método não ligado numa classe, a função "
"substituída será transformada num método ligado se for obtida a partir de "
"uma instância. Terá ``self`` passado como o primeiro argumento, que é "
"exatamente o que era necessário:"

#: ../../library/unittest.mock-examples.rst:777
msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"Se não usarmos ``autospec=True``, o método não ligado é substituído por uma "
"instância Mock, e não é chamado com ``self``."

#: ../../library/unittest.mock-examples.rst:782
msgid "Checking multiple calls with mock"
msgstr "Verificar múltiplas chamadas com mock"

#: ../../library/unittest.mock-examples.rst:784
msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr ""
"mock tem uma API conveniente para fazer afirmações sobre como os seus "
"objetos mock são utilizados."

#: ../../library/unittest.mock-examples.rst:791
msgid ""
"If your mock is only being called once you can use the :meth:`~Mock."
"assert_called_once_with` method that also asserts that the :attr:`~Mock."
"call_count` is one."
msgstr ""
"Se o seu mock for chamado apenas uma vez, pode usar o método :meth:`~Mock."
"assert_called_once_with`, que também afirma que o :attr:`~Mock.call_count` é "
"um."

#: ../../library/unittest.mock-examples.rst:803
msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"Tanto ``assert_called_with`` como ``assert_called_once_with`` fazem "
"afirmações sobre a *chamada mais recente*. Se o seu mock for chamado várias "
"vezes e quiser fazer afirmações sobre *todas* essas chamadas, pode usar :"
"attr:`~Mock.call_args_list`:"

#: ../../library/unittest.mock-examples.rst:815
msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
"O auxiliar :data:`call` facilita a criação de afirmações sobre estas "
"chamadas. Pode construir uma lista de chamadas esperadas e compará-la com "
"``call_args_list``. Isto parece-se muito com a representação de "
"``call_args_list``:"

#: ../../library/unittest.mock-examples.rst:825
msgid "Coping with mutable arguments"
msgstr "Lidar com argumentos mutáveis"

#: ../../library/unittest.mock-examples.rst:827
msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"Outra situação, embora rara, pode causar problemas: quando o seu mock é "
"chamado com argumentos mutáveis. ``call_args`` e ``call_args_list`` "
"armazenam *referências* para os argumentos. Se os argumentos forem alterados "
"pelo código em teste, já não pode fazer afirmações sobre quais eram os "
"valores quando o mock foi chamado."

#: ../../library/unittest.mock-examples.rst:832
msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr ""
"Aqui está algum código de exemplo que mostra o problema. Imagine as "
"seguintes funções definidas em 'mymodule':"

#: ../../library/unittest.mock-examples.rst:835
msgid ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"First frob and then clear val\"\n"
"    frob(val)\n"
"    val.clear()"
msgstr ""
"def frob(val):\n"
"    pass\n"
"\n"
"def grob(val):\n"
"    \"Primeiro frob e depois limpa val\"\n"
"    frob(val)\n"
"    val.clear()"

#: ../../library/unittest.mock-examples.rst:843
msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr ""
"Quando tentamos testar que ``grob`` chama ``frob`` com o argumento correto, "
"veja o que acontece:"

#: ../../library/unittest.mock-examples.rst:846
msgid ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Expected: (({6},), {})\n"
"Called with: ((set(),), {})"
msgstr ""
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> val\n"
"set()\n"
">>> mock_frob.assert_called_with({6})\n"
"Traceback (most recent call last):\n"
"    ...\n"
"AssertionError: Esperado: (({6},), {})\n"
"Chamado com: ((set(),), {})"

#: ../../library/unittest.mock-examples.rst:858
msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr ""
"Uma possibilidade seria o mock copiar os argumentos que passa. Isto poderia "
"causar problemas se fizer afirmações que dependem da identidade do objeto "
"para igualdade."

#: ../../library/unittest.mock-examples.rst:862
msgid ""
"Here's one solution that uses the :attr:`~Mock.side_effect` functionality. "
"If you provide a ``side_effect`` function for a mock then ``side_effect`` "
"will be called with the same args as the mock. This gives us an opportunity "
"to copy the arguments and store them for later assertions. In this example "
"I'm using *another* mock to store the arguments so that I can use the mock "
"methods for doing the assertion. Again a helper function sets this up for "
"me. ::"
msgstr ""
"Aqui está uma solução que usa a funcionalidade :attr:`~Mock.side_effect`. Se "
"fornecer uma função ``side_effect`` para um mock, então ``side_effect`` será "
"chamada com os mesmos argumentos que o mock. Isto dá-nos a oportunidade de "
"copiar os argumentos e armazená-los para afirmações posteriores. Neste "
"exemplo, estou a usar *outro* mock para armazenar os argumentos, para que "
"possa usar os métodos do mock para fazer a afirmação. Mais uma vez, uma "
"função auxiliar configura isto para mim:"

#: ../../library/unittest.mock-examples.rst:870
msgid ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"
msgstr ""
">>> from copy import deepcopy\n"
">>> from unittest.mock import Mock, patch, DEFAULT\n"
">>> def copy_call_args(mock):\n"
"...     new_mock = Mock()\n"
"...     def side_effect(*args, **kwargs):\n"
"...         args = deepcopy(args)\n"
"...         kwargs = deepcopy(kwargs)\n"
"...         new_mock(*args, **kwargs)\n"
"...         return DEFAULT\n"
"...     mock.side_effect = side_effect\n"
"...     return new_mock\n"
"...\n"
">>> with patch('mymodule.frob') as mock_frob:\n"
"...     new_mock = copy_call_args(mock_frob)\n"
"...     val = {6}\n"
"...     mymodule.grob(val)\n"
"...\n"
">>> new_mock.assert_called_with({6})\n"
">>> new_mock.call_args\n"
"call({6})"

#: ../../library/unittest.mock-examples.rst:891
msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` é chamada com o mock que será chamado. Retorna um novo "
"mock no qual fazemos a afirmação. A função ``side_effect`` faz uma cópia dos "
"argumentos e chama o nosso ``new_mock`` com a cópia."

#: ../../library/unittest.mock-examples.rst:897
msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"Se o seu mock só for usado uma vez, há uma forma mais fácil de verificar os "
"argumentos no momento em que são chamados. Pode simplesmente fazer a "
"verificação dentro de uma função ``side_effect``."

#: ../../library/unittest.mock-examples.rst:911
msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr ""
"Uma abordagem alternativa é criar uma subclasse de :class:`Mock` ou :class:"
"`MagicMock` que copie (usando :func:`copy.deepcopy`) os argumentos. Aqui "
"está um exemplo de implementação:"

#: ../../library/unittest.mock-examples.rst:936
msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"Quando cria uma subclasse de ``Mock`` ou ``MagicMock``, todos os atributos "
"criados dinamicamente e o ``return_value`` usarão automaticamente a sua "
"subclasse. Isto significa que todos os filhos de um ``CopyingMock`` também "
"terão o tipo ``CopyingMock``."

#: ../../library/unittest.mock-examples.rst:942
msgid "Nesting Patches"
msgstr "Aninhar substituições"

#: ../../library/unittest.mock-examples.rst:944
msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr ""
"Usar patch como um gestor de contexto é conveniente, mas se fizer várias "
"substituições, pode acabar com instruções with aninhadas, cada vez mais "
"indentadas para a direita:"

#: ../../library/unittest.mock-examples.rst:948
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"
msgstr ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def test_foo(self):\n"
"...         with patch('mymodule.Foo') as mock_foo:\n"
"...             with patch('mymodule.Bar') as mock_bar:\n"
"...                 with patch('mymodule.Spam') as mock_spam:\n"
"...                     assert mymodule.Foo is mock_foo\n"
"...                     assert mymodule.Bar is mock_bar\n"
"...                     assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').test_foo()\n"
">>> assert mymodule.Foo is original"

#: ../../library/unittest.mock-examples.rst:962
msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"Com as funções ``cleanup`` do unittest e o :ref:`start-and-stop`, podemos "
"alcançar o mesmo efeito sem a indentação aninhada. Um método auxiliar "
"simples, ``create_patch``, coloca a substituição no lugar e retorna o mock "
"criado para nós:"

#: ../../library/unittest.mock-examples.rst:967
msgid ""
">>> class MyTest(unittest.TestCase):\n"
"...\n"
"...     def create_patch(self, name):\n"
"...         patcher = patch(name)\n"
"...         thing = patcher.start()\n"
"...         self.addCleanup(patcher.stop)\n"
"...         return thing\n"
"...\n"
"...     def test_foo(self):\n"
"...         mock_foo = self.create_patch('mymodule.Foo')\n"
"...         mock_bar = self.create_patch('mymodule.Bar')\n"
"...         mock_spam = self.create_patch('mymodule.Spam')\n"
"...\n"
"...         assert mymodule.Foo is mock_foo\n"
"...         assert mymodule.Bar is mock_bar\n"
"...         assert mymodule.Spam is mock_spam\n"
"...\n"
">>> original = mymodule.Foo\n"
">>> MyTest('test_foo').run()\n"
">>> assert mymodule.Foo is original"
msgstr ""

#: ../../library/unittest.mock-examples.rst:990
msgid "Mocking a dictionary with MagicMock"
msgstr "Mock de um dicionário com MagicMock"

#: ../../library/unittest.mock-examples.rst:992
msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr ""
"Pode querer fazer mock de um dicionário, ou outro objeto contentor, "
"registando todo o acesso ao mesmo, enquanto ainda se comporta como um "
"dicionário."

#: ../../library/unittest.mock-examples.rst:995
msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"Podemos fazer isto com :class:`MagicMock`, que se comportará como um "
"dicionário, e usando :data:`~Mock.side_effect` para delegar o acesso ao "
"dicionário a um dicionário real que está sob o nosso controlo."

#: ../../library/unittest.mock-examples.rst:999
msgid ""
"When the :meth:`~object.__getitem__` and :meth:`~object.__setitem__` methods "
"of our ``MagicMock`` are called (normal dictionary access) then "
"``side_effect`` is called with the key (and in the case of ``__setitem__`` "
"the value too). We can also control what is returned."
msgstr ""
"Quando os métodos :meth:`~object.__getitem__` e :meth:`~object.__setitem__` "
"do nosso ``MagicMock`` são chamados (acesso normal ao dicionário), então "
"``side_effect`` é chamado com a chave (e, no caso de ``__setitem__``, também "
"o valor). Também podemos controlar o que é retornado."

#: ../../library/unittest.mock-examples.rst:1004
msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"Depois de o ``MagicMock`` ter sido usado, podemos usar atributos como :data:"
"`~Mock.call_args_list` para afirmar como o dicionário foi utilizado:"

#: ../../library/unittest.mock-examples.rst:1020
msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr ""
"Uma alternativa a usar ``MagicMock`` é usar ``Mock`` e fornecer *apenas* os "
"métodos mágicos que especificamente deseja:"

#: ../../library/unittest.mock-examples.rst:1027
msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"Uma *terceira* opção é usar ``MagicMock``, mas passar ``dict`` como "
"argumento *spec* (ou *spec_set*), para que o ``MagicMock`` criado tenha "
"apenas os métodos mágicos de dicionário disponíveis:"

#: ../../library/unittest.mock-examples.rst:1035
msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"Com estas funções de efeito lateral no lugar, o ``mock`` comportar-se-á como "
"um dicionário normal, mas registará o acesso. Até lança uma exceção :exc:"
"`KeyError` se tentar aceder a uma chave que não existe."

#: ../../library/unittest.mock-examples.rst:1054
msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr ""
"Depois de ter sido usado, pode fazer afirmações sobre o acesso usando os "
"métodos e atributos normais do mock:"

#: ../../library/unittest.mock-examples.rst:1066
msgid "Mock subclasses and their attributes"
msgstr "Subclasses de Mock e os seus atributos"

#: ../../library/unittest.mock-examples.rst:1068
msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr ""
"Existem várias razões pelas quais pode querer criar uma subclasse de :class:"
"`Mock`. Uma razão pode ser adicionar métodos auxiliares. Aqui está um "
"exemplo simples:"

#: ../../library/unittest.mock-examples.rst:1084
msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"O comportamento padrão para instâncias de ``Mock`` é que os atributos e os "
"mocks de valor de retorno são do mesmo tipo que o mock ao qual são acedidos. "
"Isto garante que os atributos de ``Mock`` são ``Mocks`` e os atributos de "
"``MagicMock`` são ``MagicMocks`` [#]_. Portanto, se estiver a criar uma "
"subclasse para adicionar métodos auxiliares, estes também estarão "
"disponíveis nos atributos e no mock de valor de retorno das instâncias da "
"sua subclasse."

#: ../../library/unittest.mock-examples.rst:1100
msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twisted.org/documents/11.0.0/api/twisted.python.components."
"html>`_. Having this applied to attributes too actually causes errors."
msgstr ""
"Às vezes, isto é inconveniente. Por exemplo, `um utilizador <https://code."
"google.com/archive/p/mock/issues/105>`_ está a criar uma subclasse de mock "
"para criar um `adaptador Twisted <https://twisted.org/documents/11.0.0/api/"
"twisted.python.components.html>`_. Aplicar isto também aos atributos causa "
"realmente erros."

#: ../../library/unittest.mock-examples.rst:1106
msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` (em todas as suas variantes) usa um método chamado "
"``_get_child_mock`` para criar estes \"sub-mocks\" para atributos e valores "
"de retorno. Pode evitar que a sua subclasse seja usada para atributos "
"substituindo este método. A assinatura é que aceita argumentos de palavra-"
"chave arbitrários (``**kwargs``), que são depois passados para o construtor "
"do mock:"

#: ../../library/unittest.mock-examples.rst:1123
msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr ""
"Uma exceção a esta regra são os mocks não chamáveis. Os atributos usam a "
"variante chamável, porque, caso contrário, os mocks não chamáveis não "
"poderiam ter métodos chamáveis."

#: ../../library/unittest.mock-examples.rst:1129
msgid "Mocking imports with patch.dict"
msgstr "Mock de importações com patch.dict"

#: ../../library/unittest.mock-examples.rst:1131
msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"Uma situação em que fazer mock pode ser difícil é quando tem uma importação "
"local dentro de uma função. Estas são mais difíceis de fazer mock porque não "
"estão a usar um objeto do espaço de nomes do módulo que possamos substituir."

#: ../../library/unittest.mock-examples.rst:1135
msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"Geralmente, as importações locais devem ser evitadas. Às vezes são feitas "
"para evitar dependências circulares, para as quais geralmente existe uma "
"forma muito melhor de resolver o problema (refatorar o código), ou para "
"evitar \"custos iniciais\" atrasando a importação. Isto também pode ser "
"resolvido de formas melhores do que uma importação local incondicional "
"(armazenar o módulo como um atributo de classe ou módulo e só fazer a "
"importação na primeira utilização)."

#: ../../library/unittest.mock-examples.rst:1142
msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in ``sys.modules``, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"Deixando isso de lado, há uma forma de usar ``mock`` para afetar os "
"resultados de uma importação. Importar busca um *objeto* do dicionário :data:"
"`sys.modules`. Note que busca um *objeto*, que não precisa de ser um módulo. "
"Importar um módulo pela primeira vez resulta num objeto de módulo a ser "
"colocado em ``sys.modules``, por isso normalmente, quando importa algo, "
"obtém um módulo de volta. No entanto, isto não precisa de ser o caso."

#: ../../library/unittest.mock-examples.rst:1149
msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"Isto significa que pode usar :func:`patch.dict` para *temporariamente* "
"colocar um mock em :data:`sys.modules`. Qualquer importação enquanto esta "
"substituição estiver ativa buscará o mock. Quando a substituição estiver "
"completa (a função decorada sai, o corpo da instrução with está completo ou "
"``patcher.stop()`` é chamado), o que estava lá anteriormente será restaurado "
"com segurança."

#: ../../library/unittest.mock-examples.rst:1155
msgid "Here's an example that mocks out the 'fooble' module."
msgstr "Aqui está um exemplo que faz mock do módulo 'fooble'."

#: ../../library/unittest.mock-examples.rst:1167
msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"Como pode ver, a ``import fooble`` tem sucesso, mas na saída não há 'fooble' "
"restante em :data:`sys.modules`."

#: ../../library/unittest.mock-examples.rst:1170
msgid "This also works for the ``from module import name`` form:"
msgstr "Isto também funciona para a forma ``from module import name``:"

#: ../../library/unittest.mock-examples.rst:1180
msgid "With slightly more work you can also mock package imports:"
msgstr ""
"Com um pouco mais de trabalho, também pode fazer mock de importações de "
"pacotes:"

#: ../../library/unittest.mock-examples.rst:1193
msgid "Tracking order of calls and less verbose call assertions"
msgstr "Registar a ordem das chamadas e afirmações de chamada menos verbosas"

#: ../../library/unittest.mock-examples.rst:1195
msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
"A classe :class:`Mock` permite-lhe registar a *ordem* das chamadas de "
"métodos nos seus objetos mock através do atributo :attr:`~Mock."
"method_calls`. Isto não permite registar a ordem das chamadas entre objetos "
"mock separados, mas podemos usar :attr:`~Mock.mock_calls` para alcançar o "
"mesmo efeito."

#: ../../library/unittest.mock-examples.rst:1200
msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"Como os mocks registam chamadas para mocks filhos em ``mock_calls``, e "
"aceder a um atributo arbitrário de um mock cria um mock filho, podemos criar "
"os nossos mocks separados a partir de um mock pai. As chamadas para esses "
"mocks filhos serão então todas registadas, por ordem, em ``mock_calls`` do "
"mock pai:"

#: ../../library/unittest.mock-examples.rst:1217
msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr ""
"Podemos então afirmar sobre as chamadas, incluindo a ordem, comparando com o "
"atributo ``mock_calls`` no mock gestor:"

#: ../../library/unittest.mock-examples.rst:1224
msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"Se ``patch`` estiver a criar e a colocar os seus mocks, pode anexá-los a um "
"mock gestor usando o método :meth:`~Mock.attach_mock`. Após anexar, as "
"chamadas serão registadas em ``mock_calls`` do gestor:"

#: ../../library/unittest.mock-examples.rst:1228
msgid ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"
msgstr ""
">>> manager = MagicMock()\n"
">>> with patch('mymodule.Class1') as MockClass1:\n"
"...     with patch('mymodule.Class2') as MockClass2:\n"
"...         manager.attach_mock(MockClass1, 'MockClass1')\n"
"...         manager.attach_mock(MockClass2, 'MockClass2')\n"
"...         MockClass1().foo()\n"
"...         MockClass2().bar()\n"
"<MagicMock name='mock.MockClass1().foo()' id='...'>\n"
"<MagicMock name='mock.MockClass2().bar()' id='...'>\n"
">>> manager.mock_calls\n"
"[call.MockClass1(),\n"
"call.MockClass1().foo(),\n"
"call.MockClass2(),\n"
"call.MockClass2().bar()]"

#: ../../library/unittest.mock-examples.rst:1243
msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"Se muitas chamadas tiverem sido feitas, mas só estiver interessado numa "
"sequência particular delas, uma alternativa é usar o método :meth:`~Mock."
"assert_has_calls`. Isto recebe uma lista de chamadas (construída com o "
"objeto :data:`call`). Se essa sequência de chamadas estiver em :attr:`~Mock."
"mock_calls`, então a afirmação tem sucesso."

#: ../../library/unittest.mock-examples.rst:1257
msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr ""
"Mesmo que a chamada encadeada ``m.one().two().three()`` não sejam as únicas "
"chamadas feitas ao mock, a afirmação ainda tem sucesso."

#: ../../library/unittest.mock-examples.rst:1260
msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"Às vezes, um mock pode ter várias chamadas feitas a ele, e só está "
"interessado em afirmar sobre *algumas* dessas chamadas. Pode nem sequer se "
"importar com a ordem. Neste caso, pode passar ``any_order=True`` para "
"``assert_has_calls``:"

#: ../../library/unittest.mock-examples.rst:1272
msgid "More complex argument matching"
msgstr "Correspondência de argumentos mais complexa"

#: ../../library/unittest.mock-examples.rst:1274
msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr ""
"Usando o mesmo conceito básico que :data:`ANY`, podemos implementar "
"correspondências para fazer afirmações mais complexas sobre objetos usados "
"como argumentos em mocks."

#: ../../library/unittest.mock-examples.rst:1277
msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"Suponha que esperamos que algum objeto seja passado para um mock que, por "
"defeito, compara igualdade com base na identidade do objeto (que é o padrão "
"do Python para classes definidas pelo utilizador). Para usar :meth:`~Mock."
"assert_called_with`, precisaríamos de passar o objeto exato. Se só "
"estivermos interessados em alguns dos atributos deste objeto, podemos criar "
"um correspondente que verificará esses atributos para nós."

#: ../../library/unittest.mock-examples.rst:1284
msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr ""
"Pode ver neste exemplo como uma chamada 'padrão' a ``assert_called_with`` "
"não é suficiente:"

#: ../../library/unittest.mock-examples.rst:1300
msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr ""
"Uma função de comparação para a nossa classe ``Foo`` pode parecer algo assim:"

#: ../../library/unittest.mock-examples.rst:1312
msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr ""
"E um objeto correspondente que pode usar funções de comparação como esta "
"para a sua operação de igualdade pode parecer algo assim:"

#: ../../library/unittest.mock-examples.rst:1323
msgid "Putting all this together:"
msgstr "Juntando tudo isto:"

#: ../../library/unittest.mock-examples.rst:1328
msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"O ``Matcher`` é instanciado com a nossa função de comparação e o objeto "
"``Foo`` com o qual queremos comparar. Em ``assert_called_with``, o método de "
"igualdade do ``Matcher`` será chamado, que compara o objeto com o qual o "
"mock foi chamado com aquele com que criámos o nosso correspondente. Se "
"corresponderem, então ``assert_called_with`` passa; se não corresponderem, é "
"lançada uma exceção :exc:`AssertionError`:"

#: ../../library/unittest.mock-examples.rst:1341
msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr ""
"Com alguns ajustes, pode fazer com que a função de comparação lance "
"diretamente a exceção :exc:`AssertionError` e forneça uma mensagem de falha "
"mais útil."

#: ../../library/unittest.mock-examples.rst:1344
msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"A partir da versão 1.5, a biblioteca de testes Python `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ fornece funcionalidade semelhante, que pode "
"ser útil aqui, na forma do seu correspondente de igualdade (`hamcrest."
"library.integration.match_equality <https://pyhamcrest.readthedocs.io/en/"
"release-1.8/integration/#module-hamcrest.library.integration."
"match_equality>`_)."
