# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-11 14:18+0000\n"
"PO-Revision-Date: 2025-09-16 00:01+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/concurrent.futures.rst:2
msgid ":mod:`!concurrent.futures` --- Launching parallel tasks"
msgstr ":mod:`!concurrent.futures` — Lançamento de tarefas paralelas"

#: ../../library/concurrent.futures.rst:9
msgid ""
"**Source code:** :source:`Lib/concurrent/futures/thread.py`, :source:`Lib/"
"concurrent/futures/process.py`, and :source:`Lib/concurrent/futures/"
"interpreter.py`"
msgstr ""
"**Código-fonte:** :source:`Lib/concurrent/futures/thread.py`, :source:`Lib/"
"concurrent/futures/process.py` e :source:`Lib/concurrent/futures/interpreter."
"py`"

#: ../../library/concurrent.futures.rst:15
msgid ""
"The :mod:`concurrent.futures` module provides a high-level interface for "
"asynchronously executing callables."
msgstr ""
"O módulo :mod:`concurrent.futures` fornece uma interface de alto nível para "
"executar objetos chamáveis de forma assíncrona."

#: ../../library/concurrent.futures.rst:18
msgid ""
"The asynchronous execution can be performed with threads, using :class:"
"`ThreadPoolExecutor` or :class:`InterpreterPoolExecutor`, or separate "
"processes, using :class:`ProcessPoolExecutor`. Each implements the same "
"interface, which is defined by the abstract :class:`Executor` class."
msgstr ""
"A execução assíncrona pode ser realizada com threads, usando :class:"
"`ThreadPoolExecutor` ou :class:`InterpreterPoolExecutor`, ou com processos "
"separados, usando :class:`ProcessPoolExecutor`. Cada um implementa a mesma "
"interface, que é definida pela classe abstrata :class:`Executor`."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Disponibilidade"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Este módulo não funciona ou não está disponível em WebAssembly. Consulte :"
"ref:`wasm-availability` para mais informações."

#: ../../library/concurrent.futures.rst:27
msgid "Executor Objects"
msgstr "Objetos Executor"

#: ../../library/concurrent.futures.rst:31
msgid ""
"An abstract class that provides methods to execute calls asynchronously.  It "
"should not be used directly, but through its concrete subclasses."
msgstr ""
"Uma classe abstrata que fornece métodos para executar chamadas de forma "
"assíncrona. Não deve ser usada diretamente, mas através das suas subclasses "
"concretas."

#: ../../library/concurrent.futures.rst:36
msgid ""
"Schedules the callable, *fn*, to be executed as ``fn(*args, **kwargs)`` and "
"returns a :class:`Future` object representing the execution of the "
"callable. ::"
msgstr ""
"Agenda a execução do objeto chamável, *fn*, como ``fn(*args, **kwargs)`` e "
"devolve um objeto :class:`Future` que representa a execução do objeto "
"chamável."

#: ../../library/concurrent.futures.rst:40
msgid ""
"with ThreadPoolExecutor(max_workers=1) as executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"
msgstr ""
"with ThreadPoolExecutor(max_workers=1) as executor:\n"
"    future = executor.submit(pow, 323, 1235)\n"
"    print(future.result())"

#: ../../library/concurrent.futures.rst:46
msgid "Similar to :func:`map(fn, *iterables) <map>` except:"
msgstr "Semelhante a :func:`map(fn, *iterables) <map>`, exceto:"

#: ../../library/concurrent.futures.rst:48
msgid ""
"The *iterables* are collected immediately rather than lazily, unless a "
"*buffersize* is specified to limit the number of submitted tasks whose "
"results have not yet been yielded. If the buffer is full, iteration over the "
"*iterables* pauses until a result is yielded from the buffer."
msgstr ""
"Os *iterables* são recolhidos imediatamente em vez de de forma preguiçosa, a "
"menos que um *buffersize* seja especificado para limitar o número de tarefas "
"submetidas cujos resultados ainda não foram produzidos. Se o buffer estiver "
"cheio, a iteração sobre os *iterables* pausará até que um resultado seja "
"produzido a partir do buffer."

#: ../../library/concurrent.futures.rst:53
msgid ""
"*fn* is executed asynchronously and several calls to *fn* may be made "
"concurrently."
msgstr ""
"*fn* é executado de forma assíncrona e várias chamadas a *fn* podem ser "
"feitas concorrentemente."

#: ../../library/concurrent.futures.rst:56
msgid ""
"The returned iterator raises a :exc:`TimeoutError` if :meth:`~iterator."
"__next__` is called and the result isn't available after *timeout* seconds "
"from the original call to :meth:`Executor.map`. *timeout* can be an int or a "
"float.  If *timeout* is not specified or ``None``, there is no limit to the "
"wait time."
msgstr ""
"O iterador devolvido levanta uma exceção :exc:`TimeoutError` se :meth:"
"`~iterator.__next__` for chamado e o resultado não estiver disponível após "
"*timeout* segundos desde a chamada original a :meth:`Executor.map`. "
"*timeout* pode ser um inteiro ou um float. Se *timeout* não for especificado "
"ou for ``None``, não há limite para o tempo de espera."

#: ../../library/concurrent.futures.rst:62
msgid ""
"If a *fn* call raises an exception, then that exception will be raised when "
"its value is retrieved from the iterator."
msgstr ""
"Se uma chamada a *fn* levantar uma exceção, essa exceção será levantada "
"quando o seu valor for recuperado do iterador."

#: ../../library/concurrent.futures.rst:65
msgid ""
"When using :class:`ProcessPoolExecutor`, this method chops *iterables* into "
"a number of chunks which it submits to the pool as separate tasks.  The "
"(approximate) size of these chunks can be specified by setting *chunksize* "
"to a positive integer.  For very long iterables, using a large value for "
"*chunksize* can significantly improve performance compared to the default "
"size of 1.  With :class:`ThreadPoolExecutor` and :class:"
"`InterpreterPoolExecutor`, *chunksize* has no effect."
msgstr ""
"Ao usar :class:`ProcessPoolExecutor`, este método divide os *iterables* em "
"vários pedaços que são submetidos ao pool como tarefas separadas. O tamanho "
"(aproximado) destes pedaços pode ser especificado definindo *chunksize* como "
"um inteiro positivo. Para iteráveis muito longos, usar um valor grande para "
"*chunksize* pode melhorar significativamente o desempenho em comparação com "
"o tamanho predefinido de 1. Com :class:`ThreadPoolExecutor` e :class:"
"`InterpreterPoolExecutor`, *chunksize* não tem efeito."

#: ../../library/concurrent.futures.rst:74
msgid "Added the *chunksize* parameter."
msgstr "Adicionado o parâmetro *chunksize*."

#: ../../library/concurrent.futures.rst:77
msgid "Added the *buffersize* parameter."
msgstr "Adicionado o parâmetro *buffersize*."

#: ../../library/concurrent.futures.rst:82
msgid ""
"Signal the executor that it should free any resources that it is using when "
"the currently pending futures are done executing.  Calls to :meth:`Executor."
"submit` and :meth:`Executor.map` made after shutdown will raise :exc:"
"`RuntimeError`."
msgstr ""
"Sinaliza ao executor que deve libertar quaisquer recursos que esteja a usar "
"quando os futuros atualmente pendentes terminarem a execução. Chamadas a :"
"meth:`Executor.submit` e :meth:`Executor.map` feitas após o shutdown "
"levantarão :exc:`RuntimeError`."

#: ../../library/concurrent.futures.rst:87
msgid ""
"If *wait* is ``True`` then this method will not return until all the pending "
"futures are done executing and the resources associated with the executor "
"have been freed.  If *wait* is ``False`` then this method will return "
"immediately and the resources associated with the executor will be freed "
"when all pending futures are done executing.  Regardless of the value of "
"*wait*, the entire Python program will not exit until all pending futures "
"are done executing."
msgstr ""
"Se *wait* for ``True``, este método não retornará até que todos os futuros "
"pendentes terminem a execução e os recursos associados ao executor tenham "
"sido libertados. Se *wait* for ``False``, este método retornará "
"imediatamente e os recursos associados ao executor serão libertados quando "
"todos os futuros pendentes terminarem a execução. Independentemente do valor "
"de *wait*, todo o programa Python não sairá até que todos os futuros "
"pendentes terminem a execução."

#: ../../library/concurrent.futures.rst:95
msgid ""
"If *cancel_futures* is ``True``, this method will cancel all pending futures "
"that the executor has not started running. Any futures that are completed or "
"running won't be cancelled, regardless of the value of *cancel_futures*."
msgstr ""
"Se *cancel_futures* for ``True``, este método cancelará todos os futuros "
"pendentes que o executor ainda não começou a executar. Quaisquer futuros que "
"já estejam concluídos ou em execução não serão cancelados, independentemente "
"do valor de *cancel_futures*."

#: ../../library/concurrent.futures.rst:100
msgid ""
"If both *cancel_futures* and *wait* are ``True``, all futures that the "
"executor has started running will be completed prior to this method "
"returning. The remaining futures are cancelled."
msgstr ""
"Se *cancel_futures* e *wait* forem ambos ``True``, todos os futuros que o "
"executor já começou a executar serão concluídos antes deste método retornar. "
"Os futuros restantes são cancelados."

#: ../../library/concurrent.futures.rst:104
msgid ""
"You can avoid having to call this method explicitly if you use the executor "
"as a :term:`context manager` via the  :keyword:`with` statement, which will "
"shutdown the :class:`Executor` (waiting as if :meth:`Executor.shutdown` were "
"called with *wait* set to ``True``)::"
msgstr ""
"Pode evitar ter de chamar este método explicitamente se usar o executor como "
"um :term:`gestor de contexto` através da instrução :keyword:`with`, que "
"encerrará o :class:`Executor` (aguardando como se :meth:`Executor.shutdown` "
"fosse chamado com *wait* definido como ``True``):"

#: ../../library/concurrent.futures.rst:109
msgid ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"
msgstr ""
"import shutil\n"
"with ThreadPoolExecutor(max_workers=4) as e:\n"
"    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')\n"
"    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')\n"
"    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')\n"
"    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')"

#: ../../library/concurrent.futures.rst:116
msgid "Added *cancel_futures*."
msgstr "Adicionado *cancel_futures*."

#: ../../library/concurrent.futures.rst:121
msgid "ThreadPoolExecutor"
msgstr "ThreadPoolExecutor"

#: ../../library/concurrent.futures.rst:123
msgid ""
":class:`ThreadPoolExecutor` is an :class:`Executor` subclass that uses a "
"pool of threads to execute calls asynchronously."
msgstr ""
":class:`ThreadPoolExecutor` é uma subclasse de :class:`Executor` que usa um "
"pool de threads para executar chamadas de forma assíncrona."

#: ../../library/concurrent.futures.rst:126
msgid ""
"Deadlocks can occur when the callable associated with a :class:`Future` "
"waits on the results of another :class:`Future`.  For example::"
msgstr ""
"Podem ocorrer deadlocks quando o objeto chamável associado a um :class:"
"`Future` aguarda pelos resultados de outro :class:`Future`. Por exemplo::"

#: ../../library/concurrent.futures.rst:129
msgid ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b will never complete because it is waiting on a.\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a will never complete because it is waiting on b.\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"
msgstr ""
"import time\n"
"def wait_on_b():\n"
"    time.sleep(5)\n"
"    print(b.result())  # b nunca será concluído porque está à espera de a.\n"
"    return 5\n"
"\n"
"def wait_on_a():\n"
"    time.sleep(5)\n"
"    print(a.result())  # a nunca será concluído porque está à espera de b.\n"
"    return 6\n"
"\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=2)\n"
"a = executor.submit(wait_on_b)\n"
"b = executor.submit(wait_on_a)"

#: ../../library/concurrent.futures.rst:145
msgid "And::"
msgstr "E::"

#: ../../library/concurrent.futures.rst:147
msgid ""
"def wait_on_future():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # This will never complete because there is only one worker thread and\n"
"    # it is executing this function.\n"
"    print(f.result())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(wait_on_future)"
msgstr ""
"def wait_on_future():\n"
"    f = executor.submit(pow, 5, 2)\n"
"    # Isto nunca será concluído porque só existe uma thread de trabalho e\n"
"    # está a executar esta função.\n"
"    print(f.result())\n"
"\n"
"executor = ThreadPoolExecutor(max_workers=1)\n"
"executor.submit(wait_on_future)"

#: ../../library/concurrent.futures.rst:159
msgid ""
"An :class:`Executor` subclass that uses a pool of at most *max_workers* "
"threads to execute calls asynchronously."
msgstr ""
"Uma subclasse de :class:`Executor` que usa um pool de no máximo "
"*max_workers* threads para executar chamadas de forma assíncrona."

#: ../../library/concurrent.futures.rst:162
msgid ""
"All threads enqueued to ``ThreadPoolExecutor`` will be joined before the "
"interpreter can exit. Note that the exit handler which does this is executed "
"*before* any exit handlers added using ``atexit``. This means exceptions in "
"the main thread must be caught and handled in order to signal threads to "
"exit gracefully. For this reason, it is recommended that "
"``ThreadPoolExecutor`` not be used for long-running tasks."
msgstr ""
"Todas as threads enfileiradas para ``ThreadPoolExecutor`` serão unidas antes "
"de o interpretador poder sair. Note que o manipulador de saída que faz isto "
"é executado *antes* de quaisquer manipuladores de saída adicionados usando "
"``atexit``. Isto significa que as exceções no thread principal devem ser "
"capturadas e tratadas para sinalizar às threads que saiam de forma elegante. "
"Por esta razão, recomenda-se que ``ThreadPoolExecutor`` não seja usado para "
"tarefas de longa duração."

#: ../../library/concurrent.futures.rst:169
msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker thread; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently pending "
"jobs will raise a :exc:`~concurrent.futures.thread.BrokenThreadPool`, as "
"well as any attempt to submit more jobs to the pool."
msgstr ""
"*initializer* é um objeto chamável opcional que é chamado no início de cada "
"thread de trabalho; *initargs* é um tuplo de argumentos passados ao "
"inicializador. Se *initializer* levantar uma exceção, todas as tarefas "
"atualmente pendentes levantarão uma :exc:`~concurrent.futures.thread."
"BrokenThreadPool`, bem como qualquer tentativa de submeter mais tarefas ao "
"pool."

#: ../../library/concurrent.futures.rst:175
msgid ""
"If *max_workers* is ``None`` or not given, it will default to the number of "
"processors on the machine, multiplied by ``5``, assuming that :class:"
"`ThreadPoolExecutor` is often used to overlap I/O instead of CPU work and "
"the number of workers should be higher than the number of workers for :class:"
"`ProcessPoolExecutor`."
msgstr ""
"Se *max_workers* for ``None`` ou não for especificado, o valor predefinido "
"será o número de processadores na máquina, multiplicado por ``5``, assumindo "
"que :class:`ThreadPoolExecutor` é frequentemente usado para sobrepor E/S em "
"vez de trabalho de CPU e que o número de trabalhadores deve ser maior do que "
"o número de trabalhadores para :class:`ProcessPoolExecutor`."

#: ../../library/concurrent.futures.rst:183
msgid ""
"Added the *thread_name_prefix* parameter to allow users to control the :"
"class:`threading.Thread` names for worker threads created by the pool for "
"easier debugging."
msgstr ""
"Adicionado o parâmetro *thread_name_prefix* para permitir que os "
"utilizadores controlem os nomes das :class:`threading.Thread` para threads "
"de trabalho criadas pelo pool, facilitando a depuração."

#: ../../library/concurrent.futures.rst:188
#: ../../library/concurrent.futures.rst:393
msgid "Added the *initializer* and *initargs* arguments."
msgstr "Adicionados os argumentos *initializer* e *initargs*."

#: ../../library/concurrent.futures.rst:191
msgid ""
"Default value of *max_workers* is changed to ``min(32, os.cpu_count() + "
"4)``. This default value preserves at least 5 workers for I/O bound tasks. "
"It utilizes at most 32 CPU cores for CPU bound tasks which release the GIL. "
"And it avoids using very large resources implicitly on many-core machines."
msgstr ""
"O valor predefinido de *max_workers* foi alterado para ``min(32, os."
"cpu_count() + 4)``. Este valor predefinido preserva pelo menos 5 "
"trabalhadores para tarefas limitadas por E/S. Utiliza no máximo 32 núcleos "
"de CPU para tarefas limitadas por CPU que libertam o GIL. E evita o uso "
"implícito de recursos muito grandes em máquinas com muitos núcleos."

#: ../../library/concurrent.futures.rst:197
msgid ""
"ThreadPoolExecutor now reuses idle worker threads before starting "
"*max_workers* worker threads too."
msgstr ""
"ThreadPoolExecutor agora reutiliza threads de trabalho ociosos antes de "
"iniciar demasiadas threads de trabalho *max_workers*."

#: ../../library/concurrent.futures.rst:200
msgid ""
"Default value of *max_workers* is changed to ``min(32, (os."
"process_cpu_count() or 1) + 4)``."
msgstr ""
"O valor predefinido de *max_workers* foi alterado para ``min(32, (os."
"process_cpu_count() or 1) + 4)``."

#: ../../library/concurrent.futures.rst:208
msgid "ThreadPoolExecutor Example"
msgstr "Exemplo de ThreadPoolExecutor"

#: ../../library/concurrent.futures.rst:211
msgid ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistent-subdomain.python.org/']\n"
"\n"
"# Retrieve a single page and report the URL and contents\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# We can use a with statement to ensure threads are cleaned up promptly\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # Start the load operations and mark each future with its URL\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in "
"URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r generated an exception: %s' % (url, exc))\n"
"        else:\n"
"            print('%r page is %d bytes' % (url, len(data)))"
msgstr ""
"import concurrent.futures\n"
"import urllib.request\n"
"\n"
"URLS = ['http://www.foxnews.com/',\n"
"        'http://www.cnn.com/',\n"
"        'http://europe.wsj.com/',\n"
"        'http://www.bbc.co.uk/',\n"
"        'http://nonexistent-subdomain.python.org/']\n"
"\n"
"# Obter uma única página e reportar a URL e o conteúdo\n"
"def load_url(url, timeout):\n"
"    with urllib.request.urlopen(url, timeout=timeout) as conn:\n"
"        return conn.read()\n"
"\n"
"# Podemos usar uma instrução with para garantir que as threads são limpas "
"prontamente\n"
"with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n"
"    # Iniciar as operações de carregamento e marcar cada futuro com a sua "
"URL\n"
"    future_to_url = {executor.submit(load_url, url, 60): url for url in "
"URLS}\n"
"    for future in concurrent.futures.as_completed(future_to_url):\n"
"        url = future_to_url[future]\n"
"        try:\n"
"            data = future.result()\n"
"        except Exception as exc:\n"
"            print('%r gerou uma exceção: %s' % (url, exc))\n"
"        else:\n"
"            print('%r a página tem %d bytes' % (url, len(data)))"

#: ../../library/concurrent.futures.rst:240
msgid "InterpreterPoolExecutor"
msgstr "InterpreterPoolExecutor"

#: ../../library/concurrent.futures.rst:244
msgid ""
"The :class:`InterpreterPoolExecutor` class uses a pool of interpreters to "
"execute calls asynchronously.  It is a :class:`ThreadPoolExecutor` subclass, "
"which means each worker is running in its own thread. The difference here is "
"that each worker has its own interpreter, and runs each task using that "
"interpreter."
msgstr ""
"A classe :class:`InterpreterPoolExecutor` usa um pool de interpretadores "
"para executar chamadas de forma assíncrona. É uma subclasse de :class:"
"`ThreadPoolExecutor`, o que significa que cada trabalhador está a executar "
"na sua própria thread. A diferença aqui é que cada trabalhador tem o seu "
"próprio interpretador e executa cada tarefa usando esse interpretador."

#: ../../library/concurrent.futures.rst:250
msgid ""
"The biggest benefit to using interpreters instead of only threads is true "
"multi-core parallelism.  Each interpreter has its own :term:`Global "
"Interpreter Lock <global interpreter lock>`, so code running in one "
"interpreter can run on one CPU core, while code in another interpreter runs "
"unblocked on a different core."
msgstr ""
"O maior benefício de usar interpretadores em vez de apenas threads é o "
"paralelismo verdadeiro multi-núcleo. Cada interpretador tem o seu próprio :"
"term:`Global Interpreter Lock <global interpreter lock>`, pelo que o código "
"a executar num interpretador pode executar num núcleo de CPU, enquanto o "
"código noutro interpretador executa sem bloqueio noutro núcleo."

#: ../../library/concurrent.futures.rst:256
msgid ""
"The tradeoff is that writing concurrent code for use with multiple "
"interpreters can take extra effort.  However, this is because it forces you "
"to be deliberate about how and when interpreters interact, and to be "
"explicit about what data is shared between interpreters. This results in "
"several benefits that help balance the extra effort, including true multi-"
"core parallelism,  For example, code written this way can make it easier to "
"reason about concurrency.  Another major benefit is that you don't have to "
"deal with several of the big pain points of using threads, like race "
"conditions."
msgstr ""
"A compensação é que escrever código concorrente para uso com vários "
"interpretadores pode exigir um esforço extra. No entanto, isto acontece "
"porque obriga a ser deliberado sobre como e quando os interpretadores "
"interagem e a ser explícito sobre quais dados são partilhados entre "
"interpretadores. Isto resulta em vários benefícios que ajudam a equilibrar o "
"esforço extra, incluindo paralelismo multi-núcleo verdadeiro. Por exemplo, o "
"código escrito desta forma pode facilitar o raciocínio sobre concorrência. "
"Outro grande benefício é que não é necessário lidar com vários dos grandes "
"pontos problemáticos do uso de threads, como condições de corrida."

#: ../../library/concurrent.futures.rst:266
msgid ""
"Each worker's interpreter is isolated from all the other interpreters. "
"\"Isolated\" means each interpreter has its own runtime state and operates "
"completely independently.  For example, if you redirect :data:`sys.stdout` "
"in one interpreter, it will not be automatically redirected to any other "
"interpreter.  If you import a module in one interpreter, it is not "
"automatically imported in any other.  You would need to import the module "
"separately in interpreter where you need it.  In fact, each module imported "
"in an interpreter is a completely separate object from the same module in a "
"different interpreter, including :mod:`sys`, :mod:`builtins`, and even "
"``__main__``."
msgstr ""
"O interpretador de cada trabalhador está isolado de todos os outros "
"interpretadores. \"Isolado\" significa que cada interpretador tem o seu "
"próprio estado de execução e opera completamente de forma independente. Por "
"exemplo, se redirecionar :data:`sys.stdout` num interpretador, não será "
"automaticamente redirecionado para qualquer outro interpretador. Se importar "
"um módulo num interpretador, não será automaticamente importado em nenhum "
"outro. Terá de importar o módulo separadamente no interpretador onde o "
"necessita. De facto, cada módulo importado num interpretador é um objeto "
"completamente separado do mesmo módulo noutro interpretador, incluindo :mod:"
"`sys`, :mod:`builtins` e até ``__main__``."

#: ../../library/concurrent.futures.rst:278
msgid ""
"Isolation means a mutable object, or other data, cannot be used by more than "
"one interpreter at the same time.  That effectively means interpreters "
"cannot actually share such objects or data.  Instead, each interpreter must "
"have its own copy, and you will have to synchronize any changes between the "
"copies manually.  Immutable objects and data, like the builtin singletons, "
"strings, and tuples of immutable objects, don't have these limitations."
msgstr ""
"O isolamento significa que um objeto mutável, ou outros dados, não pode ser "
"usado por mais do que um interpretador ao mesmo tempo. Isso significa "
"efetivamente que os interpretadores não podem partilhar tais objetos ou "
"dados. Em vez disso, cada interpretador deve ter a sua própria cópia, e terá "
"de sincronizar manualmente quaisquer alterações entre as cópias. Objetos e "
"dados imutáveis, como os singletons integrados, strings e tuplos de objetos "
"imutáveis, não têm estas limitações."

#: ../../library/concurrent.futures.rst:286
msgid ""
"Communicating and synchronizing between interpreters is most effectively "
"done using dedicated tools, like those proposed in :pep:`734`.  One less "
"efficient alternative is to serialize with :mod:`pickle` and then send the "
"bytes over a shared :mod:`socket <socket>` or :func:`pipe <os.pipe>`."
msgstr ""
"A comunicação e sincronização entre interpretadores é feita de forma mais "
"eficaz usando ferramentas dedicadas, como as propostas em :pep:`734`. Uma "
"alternativa menos eficiente é serializar com :mod:`pickle` e depois enviar "
"os bytes através de um :mod:`socket <socket>` partilhado ou :func:`pipe <os."
"pipe>`."

#: ../../library/concurrent.futures.rst:294
msgid ""
"A :class:`ThreadPoolExecutor` subclass that executes calls asynchronously "
"using a pool of at most *max_workers* threads.  Each thread runs tasks in "
"its own interpreter.  The worker interpreters are isolated from each other, "
"which means each has its own runtime state and that they can't share any "
"mutable objects or other data.  Each interpreter has its own :term:`Global "
"Interpreter Lock <global interpreter lock>`, which means code run with this "
"executor has true multi-core parallelism."
msgstr ""
"Uma subclasse de :class:`ThreadPoolExecutor` que executa chamadas de forma "
"assíncrona usando um pool de no máximo *max_workers* threads. Cada thread "
"executa tarefas no seu próprio interpretador. Os interpretadores dos "
"trabalhadores estão isolados uns dos outros, o que significa que cada um tem "
"o seu próprio estado de execução e não podem partilhar quaisquer objetos "
"mutáveis ou outros dados. Cada interpretador tem o seu próprio :term:`Global "
"Interpreter Lock <global interpreter lock>`, o que significa que o código "
"executado com este executor tem paralelismo multi-núcleo verdadeiro."

#: ../../library/concurrent.futures.rst:302
msgid ""
"The optional *initializer* and *initargs* arguments have the same meaning as "
"for :class:`!ThreadPoolExecutor`: the initializer is run when each worker is "
"created, though in this case it is run in the worker's interpreter.  The "
"executor serializes the *initializer* and *initargs* using :mod:`pickle` "
"when sending them to the worker's interpreter."
msgstr ""
"Os argumentos opcionais *initializer* e *initargs* têm o mesmo significado "
"que para :class:`!ThreadPoolExecutor`: o inicializador é executado quando "
"cada trabalhador é criado, embora neste caso seja executado no interpretador "
"do trabalhador. O executor serializa o *initializer* e *initargs* usando :"
"mod:`pickle` ao enviá-los para o interpretador do trabalhador."

#: ../../library/concurrent.futures.rst:310
msgid ""
"The executor may replace uncaught exceptions from *initializer* with :class:"
"`~concurrent.futures.interpreter.ExecutionFailed`."
msgstr ""
"O executor pode substituir exceções não capturadas de *initializer* por :"
"class:`~concurrent.futures.interpreter.ExecutionFailed`."

#: ../../library/concurrent.futures.rst:313
msgid "Other caveats from parent :class:`ThreadPoolExecutor` apply here."
msgstr ""
"Outras advertências da classe pai :class:`ThreadPoolExecutor` aplicam-se "
"aqui."

#: ../../library/concurrent.futures.rst:315
msgid ""
":meth:`~Executor.submit` and :meth:`~Executor.map` work like normal, except "
"the worker serializes the callable and arguments using :mod:`pickle` when "
"sending them to its interpreter.  The worker likewise serializes the return "
"value when sending it back."
msgstr ""
":meth:`~Executor.submit` e :meth:`~Executor.map` funcionam normalmente, "
"exceto que o trabalhador serializa o objeto chamável e os argumentos usando :"
"mod:`pickle` ao enviá-los para o seu interpretador. O trabalhador também "
"serializa o valor de retorno ao enviá-lo de volta."

#: ../../library/concurrent.futures.rst:320
msgid ""
"When a worker's current task raises an uncaught exception, the worker always "
"tries to preserve the exception as-is.  If that is successful then it also "
"sets the ``__cause__`` to a corresponding :class:`~concurrent.futures."
"interpreter.ExecutionFailed` instance, which contains a summary of the "
"original exception. In the uncommon case that the worker is not able to "
"preserve the original as-is then it directly preserves the corresponding :"
"class:`~concurrent.futures.interpreter.ExecutionFailed` instance instead."
msgstr ""
"Quando a tarefa atual de um trabalhador levanta uma exceção não capturada, o "
"trabalhador tenta sempre preservar a exceção como está. Se isso for bem-"
"sucedido, também define o ``__cause__`` para uma instância correspondente "
"de :class:`~concurrent.futures.interpreter.ExecutionFailed`, que contém um "
"resumo da exceção original. No caso incomum em que o trabalhador não "
"consegue preservar a original como está, preserva diretamente a instância "
"correspondente de :class:`~concurrent.futures.interpreter.ExecutionFailed`."

#: ../../library/concurrent.futures.rst:332
msgid "ProcessPoolExecutor"
msgstr "ProcessPoolExecutor"

#: ../../library/concurrent.futures.rst:334
msgid ""
"The :class:`ProcessPoolExecutor` class is an :class:`Executor` subclass that "
"uses a pool of processes to execute calls asynchronously. :class:"
"`ProcessPoolExecutor` uses the :mod:`multiprocessing` module, which allows "
"it to side-step the :term:`Global Interpreter Lock <global interpreter "
"lock>` but also means that only picklable objects can be executed and "
"returned."
msgstr ""
"A classe :class:`ProcessPoolExecutor` é uma subclasse de :class:`Executor` "
"que usa um pool de processos para executar chamadas de forma assíncrona. :"
"class:`ProcessPoolExecutor` usa o módulo :mod:`multiprocessing`, que permite "
"contornar o :term:`Global Interpreter Lock <global interpreter lock>`, mas "
"também significa que apenas objetos serializáveis podem ser executados e "
"devolvidos."

#: ../../library/concurrent.futures.rst:341
msgid ""
"The ``__main__`` module must be importable by worker subprocesses. This "
"means that :class:`ProcessPoolExecutor` will not work in the interactive "
"interpreter."
msgstr ""
"O módulo ``__main__`` deve ser importável pelos subprocessos dos "
"trabalhadores. Isto significa que :class:`ProcessPoolExecutor` não "
"funcionará no interpretador interativo."

#: ../../library/concurrent.futures.rst:344
msgid ""
"Calling :class:`Executor` or :class:`Future` methods from a callable "
"submitted to a :class:`ProcessPoolExecutor` will result in deadlock."
msgstr ""
"Chamar métodos :class:`Executor` ou :class:`Future` a partir de um objeto "
"chamável submetido a um :class:`ProcessPoolExecutor` resultará em deadlock."

#: ../../library/concurrent.futures.rst:347
msgid ""
"Note that the restrictions on functions and arguments needing to picklable "
"as per :class:`multiprocessing.Process` apply when using :meth:`~Executor."
"submit` and :meth:`~Executor.map` on a :class:`ProcessPoolExecutor`. A "
"function defined in a REPL or a lambda should not be expected to work."
msgstr ""
"Note que as restrições sobre funções e argumentos que precisam de ser "
"serializáveis, conforme :class:`multiprocessing.Process`, aplicam-se ao "
"usar :meth:`~Executor.submit` e :meth:`~Executor.map` num :class:"
"`ProcessPoolExecutor`. Uma função definida num REPL ou uma lambda não deve "
"ser esperada para funcionar."

#: ../../library/concurrent.futures.rst:354
msgid ""
"An :class:`Executor` subclass that executes calls asynchronously using a "
"pool of at most *max_workers* processes.  If *max_workers* is ``None`` or "
"not given, it will default to :func:`os.process_cpu_count`. If *max_workers* "
"is less than or equal to ``0``, then a :exc:`ValueError` will be raised. On "
"Windows, *max_workers* must be less than or equal to ``61``. If it is not "
"then :exc:`ValueError` will be raised. If *max_workers* is ``None``, then "
"the default chosen will be at most ``61``, even if more processors are "
"available. *mp_context* can be a :mod:`multiprocessing` context or ``None``. "
"It will be used to launch the workers. If *mp_context* is ``None`` or not "
"given, the default :mod:`multiprocessing` context is used. See :ref:"
"`multiprocessing-start-methods`."
msgstr ""
"Uma subclasse de :class:`Executor` que executa chamadas de forma assíncrona "
"usando um pool de no máximo *max_workers* processos. Se *max_workers* for "
"``None`` ou não for especificado, o valor predefinido será :func:`os."
"process_cpu_count`. Se *max_workers* for menor ou igual a ``0``, será "
"levantada uma exceção :exc:`ValueError`. No Windows, *max_workers* deve ser "
"menor ou igual a ``61``. Se não for, será levantada uma exceção :exc:"
"`ValueError`. Se *max_workers* for ``None``, o valor predefinido escolhido "
"será no máximo ``61``, mesmo que mais processadores estejam disponíveis. "
"*mp_context* pode ser um contexto :mod:`multiprocessing` ou ``None``. Será "
"usado para lançar os trabalhadores. Se *mp_context* for ``None`` ou não for "
"especificado, o contexto predefinido :mod:`multiprocessing` é usado. Veja :"
"ref:`multiprocessing-start-methods`."

#: ../../library/concurrent.futures.rst:368
msgid ""
"*initializer* is an optional callable that is called at the start of each "
"worker process; *initargs* is a tuple of arguments passed to the "
"initializer.  Should *initializer* raise an exception, all currently pending "
"jobs will raise a :exc:`~concurrent.futures.process.BrokenProcessPool`, as "
"well as any attempt to submit more jobs to the pool."
msgstr ""
"*initializer* é um objeto chamável opcional que é chamado no início de cada "
"processo de trabalho; *initargs* é um tuplo de argumentos passados ao "
"inicializador. Se *initializer* levantar uma exceção, todas as tarefas "
"atualmente pendentes levantarão uma :exc:`~concurrent.futures.process."
"BrokenProcessPool`, assim como qualquer tentativa de submeter mais tarefas "
"ao pool."

#: ../../library/concurrent.futures.rst:374
msgid ""
"*max_tasks_per_child* is an optional argument that specifies the maximum "
"number of tasks a single process can execute before it will exit and be "
"replaced with a fresh worker process. By default *max_tasks_per_child* is "
"``None`` which means worker processes will live as long as the pool. When a "
"max is specified, the \"spawn\" multiprocessing start method will be used by "
"default in absence of a *mp_context* parameter. This feature is incompatible "
"with the \"fork\" start method."
msgstr ""
"*max_tasks_per_child* é um argumento opcional que especifica o número máximo "
"de tarefas que um único processo pode executar antes de sair e ser "
"substituído por um novo processo de trabalho. Por predefinição, "
"*max_tasks_per_child* é ``None``, o que significa que os processos de "
"trabalho viverão enquanto o pool existir. Quando um máximo é especificado, o "
"método de início \"spawn\" de multiprocessamento será usado por predefinição "
"na ausência de um parâmetro *mp_context*. Esta funcionalidade é incompatível "
"com o método de início \"fork\"."

#: ../../library/concurrent.futures.rst:382
msgid ""
"When one of the worker processes terminates abruptly, a :exc:`~concurrent."
"futures.process.BrokenProcessPool` error is now raised. Previously, "
"behaviour was undefined but operations on the executor or its futures would "
"often freeze or deadlock."
msgstr ""
"Quando um dos processos de trabalho termina abruptamente, um erro :exc:"
"`~concurrent.futures.process.BrokenProcessPool` é agora levantado. "
"Anteriormente, o comportamento era indefinido, mas as operações no executor "
"ou nos seus futuros frequentemente congelavam ou entravam em deadlock."

#: ../../library/concurrent.futures.rst:389
msgid ""
"The *mp_context* argument was added to allow users to control the "
"start_method for worker processes created by the pool."
msgstr ""
"O argumento *mp_context* foi adicionado para permitir que os utilizadores "
"controlem o *start_method* para os processos de trabalho criados pelo pool."

#: ../../library/concurrent.futures.rst:395
msgid ""
"The *max_tasks_per_child* argument was added to allow users to control the "
"lifetime of workers in the pool."
msgstr ""
"O argumento *max_tasks_per_child* foi adicionado para permitir que os "
"utilizadores controlem o tempo de vida dos trabalhadores no pool."

#: ../../library/concurrent.futures.rst:399
msgid ""
"On POSIX systems, if your application has multiple threads and the :mod:"
"`multiprocessing` context uses the ``\"fork\"`` start method: The :func:`os."
"fork` function called internally to spawn workers may raise a :exc:"
"`DeprecationWarning`. Pass a *mp_context* configured to use a different "
"start method. See the :func:`os.fork` documentation for further explanation."
msgstr ""
"Em sistemas POSIX, se a sua aplicação tiver várias threads e o contexto :mod:"
"`multiprocessing` usar o método de início ``\"fork\"``: A função :func:`os."
"fork` chamada internamente para criar trabalhadores pode levantar um :exc:"
"`DeprecationWarning`. Passe um *mp_context* configurado para usar um método "
"de início diferente. Consulte a documentação de :func:`os.fork` para mais "
"explicações."

#: ../../library/concurrent.futures.rst:407
msgid ""
"*max_workers* uses :func:`os.process_cpu_count` by default, instead of :func:"
"`os.cpu_count`."
msgstr ""
"*max_workers* usa :func:`os.process_cpu_count` por predefinição, em vez de :"
"func:`os.cpu_count`."

#: ../../library/concurrent.futures.rst:411
msgid ""
"The default process start method (see :ref:`multiprocessing-start-methods`) "
"changed away from *fork*. If you require the *fork* start method for :class:"
"`ProcessPoolExecutor` you must explicitly pass ``mp_context=multiprocessing."
"get_context(\"fork\")``."
msgstr ""
"O método de início de processo predefinido (veja :ref:`multiprocessing-start-"
"methods`) mudou de *fork*. Se necessitar do método de início *fork* para :"
"class:`ProcessPoolExecutor`, deve passar explicitamente "
"``mp_context=multiprocessing.get_context(\"fork\")``."

#: ../../library/concurrent.futures.rst:419
msgid ""
"Attempt to terminate all living worker processes immediately by calling :"
"meth:`Process.terminate <multiprocessing.Process.terminate>` on each of "
"them. Internally, it will also call :meth:`Executor.shutdown` to ensure that "
"all other resources associated with the executor are freed."
msgstr ""
"Tenta terminar imediatamente todos os processos de trabalho ativos chamando :"
"meth:`Process.terminate <multiprocessing.Process.terminate>` em cada um "
"deles. Internamente, também chamará :meth:`Executor.shutdown` para garantir "
"que todos os outros recursos associados ao executor sejam libertados."

#: ../../library/concurrent.futures.rst:424
#: ../../library/concurrent.futures.rst:436
msgid ""
"After calling this method the caller should no longer submit tasks to the "
"executor."
msgstr ""
"Após chamar este método, o chamador não deve submeter mais tarefas ao "
"executor."

#: ../../library/concurrent.futures.rst:431
msgid ""
"Attempt to kill all living worker processes immediately by calling :meth:"
"`Process.kill <multiprocessing.Process.kill>` on each of them. Internally, "
"it will also call :meth:`Executor.shutdown` to ensure that all other "
"resources associated with the executor are freed."
msgstr ""
"Tenta matar imediatamente todos os processos de trabalho ativos chamando :"
"meth:`Process.kill <multiprocessing.Process.kill>` em cada um deles. "
"Internamente, também chamará :meth:`Executor.shutdown` para garantir que "
"todos os outros recursos associados ao executor sejam libertados."

#: ../../library/concurrent.futures.rst:444
msgid "ProcessPoolExecutor Example"
msgstr "Exemplo de ProcessPoolExecutor"

#: ../../library/concurrent.futures.rst:447
msgid ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n"
"            print('%d is prime: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import concurrent.futures\n"
"import math\n"
"\n"
"PRIMES = [\n"
"    112272535095293,\n"
"    112582705942171,\n"
"    112272535095293,\n"
"    115280095190773,\n"
"    115797848077099,\n"
"    1099726899285419]\n"
"\n"
"def is_prime(n):\n"
"    if n < 2:\n"
"        return False\n"
"    if n == 2:\n"
"        return True\n"
"    if n % 2 == 0:\n"
"        return False\n"
"\n"
"    sqrt_n = int(math.floor(math.sqrt(n)))\n"
"    for i in range(3, sqrt_n + 1, 2):\n"
"        if n % i == 0:\n"
"            return False\n"
"    return True\n"
"\n"
"def main():\n"
"    with concurrent.futures.ProcessPoolExecutor() as executor:\n"
"        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n"
"            print('%d é primo: %s' % (number, prime))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../library/concurrent.futures.rst:482
msgid "Future Objects"
msgstr "Objetos Future"

#: ../../library/concurrent.futures.rst:484
msgid ""
"The :class:`Future` class encapsulates the asynchronous execution of a "
"callable. :class:`Future` instances are created by :meth:`Executor.submit`."
msgstr ""
"A classe :class:`Future` encapsula a execução assíncrona de um objeto "
"chamável. Instâncias de :class:`Future` são criadas por :meth:`Executor."
"submit`."

#: ../../library/concurrent.futures.rst:489
msgid ""
"Encapsulates the asynchronous execution of a callable.  :class:`Future` "
"instances are created by :meth:`Executor.submit` and should not be created "
"directly except for testing."
msgstr ""
"Encapsula a execução assíncrona de um objeto chamável. Instâncias de :class:"
"`Future` são criadas por :meth:`Executor.submit` e não devem ser criadas "
"diretamente, exceto para testes."

#: ../../library/concurrent.futures.rst:495
msgid ""
"Attempt to cancel the call.  If the call is currently being executed or "
"finished running and cannot be cancelled then the method will return "
"``False``, otherwise the call will be cancelled and the method will return "
"``True``."
msgstr ""
"Tenta cancelar a chamada. Se a chamada estiver atualmente a ser executada ou "
"já tiver terminado e não puder ser cancelada, o método retornará ``False``; "
"caso contrário, a chamada será cancelada e o método retornará ``True``."

#: ../../library/concurrent.futures.rst:502
msgid "Return ``True`` if the call was successfully cancelled."
msgstr "Devolve ``True`` se a chamada foi cancelada com sucesso."

#: ../../library/concurrent.futures.rst:506
msgid ""
"Return ``True`` if the call is currently being executed and cannot be "
"cancelled."
msgstr ""
"Devolve ``True`` se a chamada estiver atualmente a ser executada e não puder "
"ser cancelada."

#: ../../library/concurrent.futures.rst:511
msgid ""
"Return ``True`` if the call was successfully cancelled or finished running."
msgstr ""
"Devolve ``True`` se a chamada foi cancelada com sucesso ou terminou a "
"execução."

#: ../../library/concurrent.futures.rst:516
msgid ""
"Return the value returned by the call. If the call hasn't yet completed then "
"this method will wait up to *timeout* seconds.  If the call hasn't completed "
"in *timeout* seconds, then a :exc:`TimeoutError` will be raised. *timeout* "
"can be an int or float.  If *timeout* is not specified or ``None``, there is "
"no limit to the wait time."
msgstr ""
"Devolve o valor retornado pela chamada. Se a chamada ainda não tiver sido "
"concluída, este método aguardará até *timeout* segundos. Se a chamada não "
"for concluída em *timeout* segundos, será levantada uma exceção :exc:"
"`TimeoutError`. *timeout* pode ser um inteiro ou um float. Se *timeout* não "
"for especificado ou for ``None``, não há limite para o tempo de espera."

#: ../../library/concurrent.futures.rst:523
#: ../../library/concurrent.futures.rst:537
msgid ""
"If the future is cancelled before completing then :exc:`.CancelledError` "
"will be raised."
msgstr ""
"Se o futuro for cancelado antes de ser concluído, será levantada uma "
"exceção :exc:`.CancelledError`."

#: ../../library/concurrent.futures.rst:526
msgid ""
"If the call raised an exception, this method will raise the same exception."
msgstr ""
"Se a chamada tiver levantado uma exceção, este método levantará a mesma "
"exceção."

#: ../../library/concurrent.futures.rst:530
msgid ""
"Return the exception raised by the call.  If the call hasn't yet completed "
"then this method will wait up to *timeout* seconds.  If the call hasn't "
"completed in *timeout* seconds, then a :exc:`TimeoutError` will be raised.  "
"*timeout* can be an int or float.  If *timeout* is not specified or "
"``None``, there is no limit to the wait time."
msgstr ""
"Devolve a exceção levantada pela chamada. Se a chamada ainda não tiver sido "
"concluída, este método aguardará até *timeout* segundos. Se a chamada não "
"for concluída em *timeout* segundos, será levantada uma exceção :exc:"
"`TimeoutError`. *timeout* pode ser um inteiro ou um float. Se *timeout* não "
"for especificado ou for ``None``, não há limite para o tempo de espera."

#: ../../library/concurrent.futures.rst:540
msgid "If the call completed without raising, ``None`` is returned."
msgstr ""
"Se a chamada for concluída sem levantar exceções, ``None`` é devolvido."

#: ../../library/concurrent.futures.rst:544
msgid ""
"Attaches the callable *fn* to the future.  *fn* will be called, with the "
"future as its only argument, when the future is cancelled or finishes "
"running."
msgstr ""
"Anexa o objeto chamável *fn* ao futuro. *fn* será chamado, com o futuro como "
"seu único argumento, quando o futuro for cancelado ou terminar a execução."

#: ../../library/concurrent.futures.rst:548
msgid ""
"Added callables are called in the order that they were added and are always "
"called in a thread belonging to the process that added them.  If the "
"callable raises an :exc:`Exception` subclass, it will be logged and "
"ignored.  If the callable raises a :exc:`BaseException` subclass, the "
"behavior is undefined."
msgstr ""
"Os objetos chamáveis adicionados são chamados pela ordem em que foram "
"adicionados e são sempre chamados numa thread pertencente ao processo que os "
"adicionou. Se o objeto chamável levantar uma subclasse de :exc:`Exception`, "
"será registado e ignorado. Se o objeto chamável levantar uma subclasse de :"
"exc:`BaseException`, o comportamento é indefinido."

#: ../../library/concurrent.futures.rst:554
msgid ""
"If the future has already completed or been cancelled, *fn* will be called "
"immediately."
msgstr ""
"Se o futuro já tiver sido concluído ou cancelado, *fn* será chamado "
"imediatamente."

#: ../../library/concurrent.futures.rst:557
msgid ""
"The following :class:`Future` methods are meant for use in unit tests and :"
"class:`Executor` implementations."
msgstr ""
"Os seguintes métodos de :class:`Future` são destinados a serem usados em "
"testes unitários e implementações de :class:`Executor`."

#: ../../library/concurrent.futures.rst:562
msgid ""
"This method should only be called by :class:`Executor` implementations "
"before executing the work associated with the :class:`Future` and by unit "
"tests."
msgstr ""
"Este método só deve ser chamado por implementações de :class:`Executor` "
"antes de executar o trabalho associado ao :class:`Future` e por testes "
"unitários."

#: ../../library/concurrent.futures.rst:566
msgid ""
"If the method returns ``False`` then the :class:`Future` was cancelled, i."
"e. :meth:`Future.cancel` was called and returned ``True``.  Any threads "
"waiting on the :class:`Future` completing (i.e. through :func:`as_completed` "
"or :func:`wait`) will be woken up."
msgstr ""
"Se o método devolver ``False``, então o :class:`Future` foi cancelado, ou "
"seja, :meth:`Future.cancel` foi chamado e devolveu ``True``. Quaisquer "
"threads à espera que o :class:`Future` seja concluído (por exemplo, através "
"de :func:`as_completed` ou :func:`wait`) serão acordadas."

#: ../../library/concurrent.futures.rst:571
msgid ""
"If the method returns ``True`` then the :class:`Future` was not cancelled "
"and has been put in the running state, i.e. calls to :meth:`Future.running` "
"will return ``True``."
msgstr ""
"Se o método devolver ``True``, então o :class:`Future` não foi cancelado e "
"foi colocado no estado de execução, ou seja, chamadas a :meth:`Future."
"running` devolverão ``True``."

#: ../../library/concurrent.futures.rst:575
msgid ""
"This method can only be called once and cannot be called after :meth:`Future."
"set_result` or :meth:`Future.set_exception` have been called."
msgstr ""
"Este método só pode ser chamado uma vez e não pode ser chamado após :meth:"
"`Future.set_result` ou :meth:`Future.set_exception` terem sido chamados."

#: ../../library/concurrent.futures.rst:581
msgid ""
"Sets the result of the work associated with the :class:`Future` to *result*."
msgstr ""
"Define o resultado do trabalho associado ao :class:`Future` como *result*."

#: ../../library/concurrent.futures.rst:584
#: ../../library/concurrent.futures.rst:597
msgid ""
"This method should only be used by :class:`Executor` implementations and "
"unit tests."
msgstr ""
"Este método só deve ser usado por implementações de :class:`Executor` e "
"testes unitários."

#: ../../library/concurrent.futures.rst:587
#: ../../library/concurrent.futures.rst:600
msgid ""
"This method raises :exc:`concurrent.futures.InvalidStateError` if the :class:"
"`Future` is already done."
msgstr ""
"Este método levanta :exc:`concurrent.futures.InvalidStateError` se o :class:"
"`Future` já estiver concluído."

#: ../../library/concurrent.futures.rst:594
msgid ""
"Sets the result of the work associated with the :class:`Future` to the :"
"class:`Exception` *exception*."
msgstr ""
"Define o resultado do trabalho associado ao :class:`Future` como a exceção :"
"class:`Exception` *exception*."

#: ../../library/concurrent.futures.rst:606
msgid "Module Functions"
msgstr "Funções do Módulo"

#: ../../library/concurrent.futures.rst:610
msgid ""
"Wait for the :class:`Future` instances (possibly created by different :class:"
"`Executor` instances) given by *fs* to complete. Duplicate futures given to "
"*fs* are removed and will be returned only once. Returns a named 2-tuple of "
"sets.  The first set, named ``done``, contains the futures that completed "
"(finished or cancelled futures) before the wait completed.  The second set, "
"named ``not_done``, contains the futures that did not complete (pending or "
"running futures)."
msgstr ""
"Aguarda que as instâncias de :class:`Future` (possivelmente criadas por "
"diferentes instâncias de :class:`Executor`) dadas por *fs* sejam concluídas. "
"Futuros duplicados fornecidos a *fs* são removidos e serão devolvidos apenas "
"uma vez. Devolve um tuplo nomeado de 2 conjuntos. O primeiro conjunto, "
"chamado ``done``, contém os futuros que foram concluídos (futuros terminados "
"ou cancelados) antes de a espera ser concluída. O segundo conjunto, chamado "
"``not_done``, contém os futuros que não foram concluídos (futuros pendentes "
"ou em execução)."

#: ../../library/concurrent.futures.rst:618
msgid ""
"*timeout* can be used to control the maximum number of seconds to wait "
"before returning.  *timeout* can be an int or float.  If *timeout* is not "
"specified or ``None``, there is no limit to the wait time."
msgstr ""
"*timeout* pode ser usado para controlar o número máximo de segundos a "
"aguardar antes de retornar. *timeout* pode ser um inteiro ou um float. Se "
"*timeout* não for especificado ou for ``None``, não há limite para o tempo "
"de espera."

#: ../../library/concurrent.futures.rst:622
msgid ""
"*return_when* indicates when this function should return.  It must be one of "
"the following constants:"
msgstr ""
"*return_when* indica quando esta função deve retornar. Deve ser uma das "
"seguintes constantes:"

#: ../../library/concurrent.futures.rst:628
msgid "Constant"
msgstr "Constante"

#: ../../library/concurrent.futures.rst:629
msgid "Description"
msgstr "Descrição"

#: ../../library/concurrent.futures.rst:632
msgid "The function will return when any future finishes or is cancelled."
msgstr "A função retornará quando qualquer futuro terminar ou for cancelado."

#: ../../library/concurrent.futures.rst:635
msgid ""
"The function will return when any future finishes by raising an exception. "
"If no future raises an exception then it is equivalent to :const:"
"`ALL_COMPLETED`."
msgstr ""
"A função retornará quando qualquer futuro terminar levantando uma exceção. "
"Se nenhum futuro levantar uma exceção, então é equivalente a :const:"
"`ALL_COMPLETED`."

#: ../../library/concurrent.futures.rst:640
msgid "The function will return when all futures finish or are cancelled."
msgstr ""
"A função retornará quando todos os futuros terminarem ou forem cancelados."

#: ../../library/concurrent.futures.rst:644
msgid ""
"Returns an iterator over the :class:`Future` instances (possibly created by "
"different :class:`Executor` instances) given by *fs* that yields futures as "
"they complete (finished or cancelled futures). Any futures given by *fs* "
"that are duplicated will be returned once. Any futures that completed "
"before :func:`as_completed` is called will be yielded first.  The returned "
"iterator raises a :exc:`TimeoutError` if :meth:`~iterator.__next__` is "
"called and the result isn't available after *timeout* seconds from the "
"original call to :func:`as_completed`.  *timeout* can be an int or float. If "
"*timeout* is not specified or ``None``, there is no limit to the wait time."
msgstr ""
"Devolve um iterador sobre as instâncias de :class:`Future` (possivelmente "
"criadas por diferentes instâncias de :class:`Executor`) dadas por *fs* que "
"produz futuros à medida que são concluídos (futuros terminados ou "
"cancelados). Quaisquer futuros dados por *fs* que sejam duplicados serão "
"devolvidos uma vez. Quaisquer futuros que tenham sido concluídos antes de :"
"func:`as_completed` ser chamado serão produzidos primeiro. O iterador "
"devolvido levanta uma exceção :exc:`TimeoutError` se :meth:`~iterator."
"__next__` for chamado e o resultado não estiver disponível após *timeout* "
"segundos desde a chamada original a :func:`as_completed`. *timeout* pode ser "
"um inteiro ou um float. Se *timeout* não for especificado ou for ``None``, "
"não há limite para o tempo de espera."

#: ../../library/concurrent.futures.rst:657
msgid ":pep:`3148` -- futures - execute computations asynchronously"
msgstr ":pep:`3148` — futuros — executar cálculos de forma assíncrona"

#: ../../library/concurrent.futures.rst:658
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr ""
"A proposta que descreveu esta funcionalidade para inclusão na biblioteca "
"padrão do Python."

#: ../../library/concurrent.futures.rst:663
msgid "Exception classes"
msgstr "Classes de Exceção"

#: ../../library/concurrent.futures.rst:669
msgid "Raised when a future is cancelled."
msgstr "Levantada quando um futuro é cancelado."

#: ../../library/concurrent.futures.rst:673
msgid ""
"A deprecated alias of :exc:`TimeoutError`, raised when a future operation "
"exceeds the given timeout."
msgstr ""
"Um alias obsoleto de :exc:`TimeoutError`, levantado quando uma operação "
"futura excede o tempo limite dado."

#: ../../library/concurrent.futures.rst:678
msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Esta classe tornou-se um alias de :exc:`TimeoutError`."

#: ../../library/concurrent.futures.rst:683
msgid ""
"Derived from :exc:`RuntimeError`, this exception class is raised when an "
"executor is broken for some reason, and cannot be used to submit or execute "
"new tasks."
msgstr ""
"Derivada de :exc:`RuntimeError`, esta classe de exceção é levantada quando "
"um executor está avariado por algum motivo e não pode ser usado para "
"submeter ou executar novas tarefas."

#: ../../library/concurrent.futures.rst:691
msgid ""
"Raised when an operation is performed on a future that is not allowed in the "
"current state."
msgstr ""
"Levantada quando uma operação é realizada num futuro que não é permitida no "
"estado atual."

#: ../../library/concurrent.futures.rst:700
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor`, this exception class "
"is raised when one of the workers of a :class:`~concurrent.futures."
"ThreadPoolExecutor` has failed initializing."
msgstr ""
"Derivada de :exc:`~concurrent.futures.BrokenExecutor`, esta classe de "
"exceção é levantada quando um dos trabalhadores de um :class:`~concurrent."
"futures.ThreadPoolExecutor` falha na inicialização."

#: ../../library/concurrent.futures.rst:711
msgid ""
"Derived from :exc:`~concurrent.futures.thread.BrokenThreadPool`, this "
"exception class is raised when one of the workers of a :class:`~concurrent."
"futures.InterpreterPoolExecutor` has failed initializing."
msgstr ""
"Derivada de :exc:`~concurrent.futures.thread.BrokenThreadPool`, esta classe "
"de exceção é levantada quando um dos trabalhadores de um :class:`~concurrent."
"futures.InterpreterPoolExecutor` falha na inicialização."

#: ../../library/concurrent.futures.rst:720
msgid ""
"Raised from :class:`~concurrent.futures.InterpreterPoolExecutor` when the "
"given initializer fails or from :meth:`~concurrent.futures.Executor.submit` "
"when there's an uncaught exception from the submitted task."
msgstr ""
"Levantada de :class:`~concurrent.futures.InterpreterPoolExecutor` quando o "
"inicializador dado falha ou de :meth:`~concurrent.futures.Executor.submit` "
"quando há uma exceção não capturada da tarefa submetida."

#: ../../library/concurrent.futures.rst:731
msgid ""
"Derived from :exc:`~concurrent.futures.BrokenExecutor` (formerly :exc:"
"`RuntimeError`), this exception class is raised when one of the workers of "
"a :class:`~concurrent.futures.ProcessPoolExecutor` has terminated in a non-"
"clean fashion (for example, if it was killed from the outside)."
msgstr ""
"Derivada de :exc:`~concurrent.futures.BrokenExecutor` (anteriormente :exc:"
"`RuntimeError`), esta classe de exceção é levantada quando um dos "
"trabalhadores de um :class:`~concurrent.futures.ProcessPoolExecutor` "
"terminou de forma não limpa (por exemplo, se foi morto externamente)."
