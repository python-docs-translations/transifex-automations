# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-19 17:28+0000\n"
"PO-Revision-Date: 2025-09-22 15:57+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-protocol.rst:9
msgid "Transports and Protocols"
msgstr "Transportes e Protocolos"

#: ../../library/asyncio-protocol.rst:12
msgid "Preface"
msgstr "Prefácio"

#: ../../library/asyncio-protocol.rst:13
msgid ""
"Transports and Protocols are used by the **low-level** event loop APIs such "
"as :meth:`loop.create_connection`.  They use callback-based programming "
"style and enable high-performance implementations of network or IPC "
"protocols (e.g. HTTP)."
msgstr ""
"Os Transportes e Protocolos são usados pelas APIs de **baixo nível** do "
"ciclo de eventos, como :meth:`loop.create_connection`. Utilizam um estilo de "
"programação baseado em *callbacks* e permitem implementações de alto "
"desempenho de protocolos de rede ou IPC (por exemplo, HTTP)."

#: ../../library/asyncio-protocol.rst:18
msgid ""
"Essentially, transports and protocols should only be used in libraries and "
"frameworks and never in high-level asyncio applications."
msgstr ""
"Essencialmente, os transportes e protocolos devem ser usados apenas em "
"bibliotecas e *frameworks*, e nunca em aplicações asyncio de alto nível."

#: ../../library/asyncio-protocol.rst:22
msgid "This documentation page covers both `Transports`_ and `Protocols`_."
msgstr ""
"Esta página de documentação abrange tanto `Transports`_ como `Protocols`_."

#: ../../library/asyncio-protocol.rst:25
msgid "Introduction"
msgstr "Introdução"

#: ../../library/asyncio-protocol.rst:26
msgid ""
"At the highest level, the transport is concerned with *how* bytes are "
"transmitted, while the protocol determines *which* bytes to transmit (and to "
"some extent when)."
msgstr ""
"Num nível mais elevado, o transporte está preocupado com *como* os bytes são "
"transmitidos, enquanto o protocolo determina *quais* bytes transmitir (e, "
"até certo ponto, quando)."

#: ../../library/asyncio-protocol.rst:30
msgid ""
"A different way of saying the same thing: a transport is an abstraction for "
"a socket (or similar I/O endpoint) while a protocol is an abstraction for an "
"application, from the transport's point of view."
msgstr ""
"Outra forma de dizer a mesma coisa: um transporte é uma abstração para um "
"*socket* (ou ponto final de I/O semelhante), enquanto um protocolo é uma "
"abstração para uma aplicação, do ponto de vista do transporte."

#: ../../library/asyncio-protocol.rst:35
msgid ""
"Yet another view is the transport and protocol interfaces together define an "
"abstract interface for using network I/O and interprocess I/O."
msgstr ""
"Outra visão é que as interfaces de transporte e protocolo, em conjunto, "
"definem uma interface abstrata para usar I/O de rede e I/O entre processos."

#: ../../library/asyncio-protocol.rst:39
msgid ""
"There is always a 1:1 relationship between transport and protocol objects: "
"the protocol calls transport methods to send data, while the transport calls "
"protocol methods to pass it data that has been received."
msgstr ""
"Existe sempre uma relação 1:1 entre objetos de transporte e protocolo: o "
"protocolo chama métodos de transporte para enviar dados, enquanto o "
"transporte chama métodos de protocolo para passar dados que foram recebidos."

#: ../../library/asyncio-protocol.rst:44
msgid ""
"Most of connection oriented event loop methods (such as :meth:`loop."
"create_connection`) usually accept a *protocol_factory* argument used to "
"create a *Protocol* object for an accepted connection, represented by a "
"*Transport* object. Such methods usually return a tuple of ``(transport, "
"protocol)``."
msgstr ""
"A maioria dos métodos de ciclo de eventos orientados à ligação (como :meth:"
"`loop.create_connection`) geralmente aceita um argumento *protocol_factory* "
"usado para criar um objeto *Protocol* para uma ligação aceite, representado "
"por um objeto *Transport*. Esses métodos geralmente retornam um tuplo de "
"``(transport, protocol)``."

#: ../../library/asyncio-protocol.rst:51
msgid "Contents"
msgstr "Conteúdos"

#: ../../library/asyncio-protocol.rst:52
msgid "This documentation page contains the following sections:"
msgstr "Esta página de documentação contém as seguintes secções:"

#: ../../library/asyncio-protocol.rst:54
msgid ""
"The `Transports`_ section documents asyncio :class:`BaseTransport`, :class:"
"`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, and :class:`SubprocessTransport` classes."
msgstr ""
"A secção `Transports`_ documenta as classes asyncio :class:`BaseTransport`, :"
"class:`ReadTransport`, :class:`WriteTransport`, :class:`Transport`, :class:"
"`DatagramTransport`, e :class:`SubprocessTransport`."

#: ../../library/asyncio-protocol.rst:59
msgid ""
"The `Protocols`_ section documents asyncio :class:`BaseProtocol`, :class:"
"`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, and :class:"
"`SubprocessProtocol` classes."
msgstr ""
"A secção `Protocols`_ documenta as classes asyncio :class:`BaseProtocol`, :"
"class:`Protocol`, :class:`BufferedProtocol`, :class:`DatagramProtocol`, e :"
"class:`SubprocessProtocol`."

#: ../../library/asyncio-protocol.rst:63
msgid ""
"The `Examples`_ section showcases how to work with transports, protocols, "
"and low-level event loop APIs."
msgstr ""
"A secção `Examples`_ mostra como trabalhar com transportes, protocolos e "
"APIs de baixo nível do ciclo de eventos."

#: ../../library/asyncio-protocol.rst:70
msgid "Transports"
msgstr "Transportes"

#: ../../library/asyncio-protocol.rst:72
msgid "**Source code:** :source:`Lib/asyncio/transports.py`"
msgstr "**Código fonte:** :source:`Lib/asyncio/transports.py`"

#: ../../library/asyncio-protocol.rst:76
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels."
msgstr ""
"Os Transportes são classes fornecidas por :mod:`asyncio` para abstrair "
"vários tipos de canais de comunicação."

#: ../../library/asyncio-protocol.rst:79
msgid ""
"Transport objects are always instantiated by an :ref:`asyncio event loop "
"<asyncio-event-loop>`."
msgstr ""
"Os objetos de Transporte são sempre instanciados por um :ref:`ciclo de "
"eventos asyncio <asyncio-event-loop>`."

#: ../../library/asyncio-protocol.rst:82
msgid ""
"asyncio implements transports for TCP, UDP, SSL, and subprocess pipes. The "
"methods available on a transport depend on the transport's kind."
msgstr ""
"O asyncio implementa transportes para TCP, UDP, SSL e *pipes* de "
"subprocessos. Os métodos disponíveis num transporte dependem do tipo de "
"transporte."

#: ../../library/asyncio-protocol.rst:85
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""
"As classes de transporte :ref:`não são seguras para *threads* <asyncio-"
"multithreading>`."

#: ../../library/asyncio-protocol.rst:89
msgid "Transports Hierarchy"
msgstr "Hierarquia de Transportes"

#: ../../library/asyncio-protocol.rst:93
msgid ""
"Base class for all transports.  Contains methods that all asyncio transports "
"share."
msgstr ""
"Classe base para todos os transportes. Contém métodos que todos os "
"transportes asyncio partilham."

#: ../../library/asyncio-protocol.rst:98
msgid "A base transport for write-only connections."
msgstr "Um transporte base para ligações apenas de escrita."

#: ../../library/asyncio-protocol.rst:100
msgid ""
"Instances of the *WriteTransport* class are returned from the :meth:`loop."
"connect_write_pipe` event loop method and are also used by subprocess-"
"related methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Instâncias da classe *WriteTransport* são retornadas pelo método de ciclo de "
"eventos :meth:`loop.connect_write_pipe` e também são usadas por métodos "
"relacionados com subprocessos, como :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:107
msgid "A base transport for read-only connections."
msgstr "Um transporte base para ligações apenas de leitura."

#: ../../library/asyncio-protocol.rst:109
msgid ""
"Instances of the *ReadTransport* class are returned from the :meth:`loop."
"connect_read_pipe` event loop method and are also used by subprocess-related "
"methods like :meth:`loop.subprocess_exec`."
msgstr ""
"Instâncias da classe *ReadTransport* são retornadas pelo método de ciclo de "
"eventos :meth:`loop.connect_read_pipe` e também são usadas por métodos "
"relacionados com subprocessos, como :meth:`loop.subprocess_exec`."

#: ../../library/asyncio-protocol.rst:116
msgid ""
"Interface representing a bidirectional transport, such as a TCP connection."
msgstr ""
"Interface que representa um transporte bidirecional, como uma ligação TCP."

#: ../../library/asyncio-protocol.rst:119
msgid ""
"The user does not instantiate a transport directly; they call a utility "
"function, passing it a protocol factory and other information necessary to "
"create the transport and protocol."
msgstr ""
"O utilizador não instancia um transporte diretamente; chama uma função "
"utilitária, passando-lhe uma fábrica de protocolos e outras informações "
"necessárias para criar o transporte e o protocolo."

#: ../../library/asyncio-protocol.rst:123
msgid ""
"Instances of the *Transport* class are returned from or used by event loop "
"methods like :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."
msgstr ""
"Instâncias da classe *Transport* são retornadas ou usadas por métodos de "
"ciclo de eventos como :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.create_server`, :meth:`loop.sendfile`, "
"etc."

#: ../../library/asyncio-protocol.rst:131
msgid "A transport for datagram (UDP) connections."
msgstr "Um transporte para ligações de datagrama (UDP)."

#: ../../library/asyncio-protocol.rst:133
msgid ""
"Instances of the *DatagramTransport* class are returned from the :meth:`loop."
"create_datagram_endpoint` event loop method."
msgstr ""
"Instâncias da classe *DatagramTransport* são retornadas pelo método de ciclo "
"de eventos :meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:139
msgid ""
"An abstraction to represent a connection between a parent and its child OS "
"process."
msgstr ""
"Uma abstração para representar uma ligação entre um processo pai e o seu "
"processo filho do sistema operativo."

#: ../../library/asyncio-protocol.rst:142
msgid ""
"Instances of the *SubprocessTransport* class are returned from event loop "
"methods :meth:`loop.subprocess_shell` and :meth:`loop.subprocess_exec`."
msgstr ""
"Instâncias da classe *SubprocessTransport* são retornadas pelos métodos de "
"ciclo de eventos :meth:`loop.subprocess_shell` e :meth:`loop."
"subprocess_exec`."

#: ../../library/asyncio-protocol.rst:148
msgid "Base Transport"
msgstr "Transporte Base"

#: ../../library/asyncio-protocol.rst:152
msgid "Close the transport."
msgstr "Fecha o transporte."

#: ../../library/asyncio-protocol.rst:154
msgid ""
"If the transport has a buffer for outgoing data, buffered data will be "
"flushed asynchronously.  No more data will be received.  After all buffered "
"data is flushed, the protocol's :meth:`protocol.connection_lost() "
"<BaseProtocol.connection_lost>` method will be called with :const:`None` as "
"its argument. The transport should not be used once it is closed."
msgstr ""
"Se o transporte tiver um *buffer* para dados de saída, os dados em *buffer* "
"serão descarregados de forma assíncrona. Não serão recebidos mais dados. "
"Depois de todos os dados em *buffer* serem descarregados, o método :meth:"
"`protocol.connection_lost() <BaseProtocol.connection_lost>` do protocolo "
"será chamado com :const:`None` como argumento. O transporte não deve ser "
"usado depois de fechado."

#: ../../library/asyncio-protocol.rst:164
msgid "Return ``True`` if the transport is closing or is closed."
msgstr "Devolve ``True`` se o transporte estiver a fechar ou estiver fechado."

#: ../../library/asyncio-protocol.rst:168
msgid "Return information about the transport or underlying resources it uses."
msgstr ""
"Devolve informações sobre o transporte ou os recursos subjacentes que "
"utiliza."

#: ../../library/asyncio-protocol.rst:171
msgid ""
"*name* is a string representing the piece of transport-specific information "
"to get."
msgstr ""
"*name* é uma string que representa a peça de informação específica do "
"transporte a obter."

#: ../../library/asyncio-protocol.rst:174
msgid ""
"*default* is the value to return if the information is not available, or if "
"the transport does not support querying it with the given third-party event "
"loop implementation or on the current platform."
msgstr ""
"*default* é o valor a devolver se a informação não estiver disponível, ou se "
"o transporte não suportar a sua consulta com a implementação dada de ciclo "
"de eventos de terceiros ou na plataforma atual."

#: ../../library/asyncio-protocol.rst:179
msgid ""
"For example, the following code attempts to get the underlying socket object "
"of the transport::"
msgstr ""
"Por exemplo, o seguinte código tenta obter o objeto *socket* subjacente do "
"transporte:"

#: ../../library/asyncio-protocol.rst:186
msgid "Categories of information that can be queried on some transports:"
msgstr ""
"Categorias de informação que podem ser consultadas em alguns transportes:"

#: ../../library/asyncio-protocol.rst:188
msgid "socket:"
msgstr "socket:"

#: ../../library/asyncio-protocol.rst:190
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""
"``'peername'``: o endereço remoto ao qual o *socket* está ligado, resultado "
"de :meth:`socket.socket.getpeername` (``None`` em caso de erro)"

#: ../../library/asyncio-protocol.rst:194
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr "``'socket'``: instância :class:`socket.socket`"

#: ../../library/asyncio-protocol.rst:196
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""
"``'sockname'``: o endereço próprio do *socket*, resultado de :meth:`socket."
"socket.getsockname`"

#: ../../library/asyncio-protocol.rst:199
msgid "SSL socket:"
msgstr "SSL socket:"

#: ../../library/asyncio-protocol.rst:201
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""
"``'compression'``: o algoritmo de compressão a ser usado como uma string, ou "
"``None`` se a ligação não estiver comprimida; resultado de :meth:`ssl."
"SSLSocket.compression`"

#: ../../library/asyncio-protocol.rst:205
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""
"``'cipher'``: um tuplo de três valores contendo o nome do *cipher* a ser "
"usado, a versão do protocolo SSL que define o seu uso, e o número de bits "
"secretos a serem usados; resultado de :meth:`ssl.SSLSocket.cipher`"

#: ../../library/asyncio-protocol.rst:210
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""
"``'peercert'``: certificado do par; resultado de :meth:`ssl.SSLSocket."
"getpeercert`"

#: ../../library/asyncio-protocol.rst:213
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr "``'sslcontext'``: instância :class:`ssl.SSLContext`"

#: ../../library/asyncio-protocol.rst:215
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""
"``'ssl_object'``: instância :class:`ssl.SSLObject` ou :class:`ssl.SSLSocket`"

#: ../../library/asyncio-protocol.rst:218
msgid "pipe:"
msgstr "pipe:"

#: ../../library/asyncio-protocol.rst:220
msgid "``'pipe'``: pipe object"
msgstr "``'pipe'``: objeto *pipe*"

#: ../../library/asyncio-protocol.rst:222
msgid "subprocess:"
msgstr "subprocesso:"

#: ../../library/asyncio-protocol.rst:224
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr "``'subprocess'``: instância :class:`subprocess.Popen`"

#: ../../library/asyncio-protocol.rst:228
msgid "Set a new protocol."
msgstr "Define um novo protocolo."

#: ../../library/asyncio-protocol.rst:230
msgid ""
"Switching protocol should only be done when both protocols are documented to "
"support the switch."
msgstr ""
"A mudança de protocolo só deve ser feita quando ambos os protocolos "
"estiverem documentados para suportar a mudança."

#: ../../library/asyncio-protocol.rst:235
msgid "Return the current protocol."
msgstr "Devolve o protocolo atual."

#: ../../library/asyncio-protocol.rst:239
msgid "Read-only Transports"
msgstr "Transportes apenas de leitura"

#: ../../library/asyncio-protocol.rst:243
msgid "Return ``True`` if the transport is receiving new data."
msgstr "Devolve ``True`` se o transporte estiver a receber novos dados."

#: ../../library/asyncio-protocol.rst:249
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`protocol.data_received() <Protocol.data_received>` method "
"until :meth:`resume_reading` is called."
msgstr ""
"Pausa a extremidade de receção do transporte. Nenhum dado será passado para "
"o método :meth:`protocol.data_received() <Protocol.data_received>` do "
"protocolo até que :meth:`resume_reading` seja chamado."

#: ../../library/asyncio-protocol.rst:253
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already paused or closed."
msgstr ""
"O método é idempotente, ou seja, pode ser chamado quando o transporte já "
"estiver pausado ou fechado."

#: ../../library/asyncio-protocol.rst:259
msgid ""
"Resume the receiving end.  The protocol's :meth:`protocol.data_received() "
"<Protocol.data_received>` method will be called once again if some data is "
"available for reading."
msgstr ""
"Retoma a extremidade de receção. O método :meth:`protocol.data_received() "
"<Protocol.data_received>` do protocolo será chamado novamente se alguns "
"dados estiverem disponíveis para leitura."

#: ../../library/asyncio-protocol.rst:263
msgid ""
"The method is idempotent, i.e. it can be called when the transport is "
"already reading."
msgstr ""
"O método é idempotente, ou seja, pode ser chamado quando o transporte já "
"estiver a ler."

#: ../../library/asyncio-protocol.rst:269
msgid "Write-only Transports"
msgstr "Transportes apenas de escrita"

#: ../../library/asyncio-protocol.rst:273
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Fecha o transporte imediatamente, sem esperar que as operações pendentes "
"sejam concluídas. Os dados em *buffer* serão perdidos. Não serão recebidos "
"mais dados. O método :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` do protocolo será eventualmente chamado com :const:`None` "
"como argumento."

#: ../../library/asyncio-protocol.rst:281
msgid ""
"Return :const:`True` if the transport supports :meth:`~WriteTransport."
"write_eof`, :const:`False` if not."
msgstr ""
"Devolve :const:`True` se o transporte suportar :meth:`~WriteTransport."
"write_eof`, :const:`False` caso contrário."

#: ../../library/asyncio-protocol.rst:286
msgid "Return the current size of the output buffer used by the transport."
msgstr "Devolve o tamanho atual do *buffer* de saída usado pelo transporte."

#: ../../library/asyncio-protocol.rst:290
msgid ""
"Get the *high* and *low* watermarks for write flow control. Return a tuple "
"``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""
"Obtém os limites *high* e *low* para o controlo de fluxo de escrita. Devolve "
"um tuplo ``(low, high)`` onde *low* e *high* são números positivos de bytes."

#: ../../library/asyncio-protocol.rst:294
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr "Use :meth:`set_write_buffer_limits` para definir os limites."

#: ../../library/asyncio-protocol.rst:300
msgid "Set the *high* and *low* watermarks for write flow control."
msgstr "Define os limites *high* e *low* para o controlo de fluxo de escrita."

#: ../../library/asyncio-protocol.rst:302
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` and :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` methods are "
"called. If specified, the low watermark must be less than or equal to the "
"high watermark.  Neither *high* nor *low* can be negative."
msgstr ""
"Estes dois valores (medidos em número de bytes) controlam quando os métodos :"
"meth:`protocol.pause_writing() <BaseProtocol.pause_writing>` e :meth:"
"`protocol.resume_writing() <BaseProtocol.resume_writing>` do protocolo são "
"chamados. Se especificado, o limite inferior deve ser menor ou igual ao "
"limite superior. Nem *high* nem *low* podem ser negativos."

#: ../../library/asyncio-protocol.rst:310
msgid ""
":meth:`~BaseProtocol.pause_writing` is called when the buffer size becomes "
"greater than or equal to the *high* value. If writing has been paused, :meth:"
"`~BaseProtocol.resume_writing` is called when the buffer size becomes less "
"than or equal to the *low* value."
msgstr ""
":meth:`~BaseProtocol.pause_writing` é chamado quando o tamanho do *buffer* "
"se torna maior ou igual ao valor *high*. Se a escrita tiver sido pausada, :"
"meth:`~BaseProtocol.resume_writing` é chamado quando o tamanho do *buffer* "
"se torna menor ou igual ao valor *low*."

#: ../../library/asyncio-protocol.rst:315
msgid ""
"The defaults are implementation-specific.  If only the high watermark is "
"given, the low watermark defaults to an implementation-specific value less "
"than or equal to the high watermark.  Setting *high* to zero forces *low* to "
"zero as well, and causes :meth:`~BaseProtocol.pause_writing` to be called "
"whenever the buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`~BaseProtocol.resume_writing` to be called only once the buffer is empty. "
"Use of zero for either limit is generally sub-optimal as it reduces "
"opportunities for doing I/O and computation concurrently."
msgstr ""
"Os valores predefinidos são específicos da implementação. Se apenas o limite "
"superior for dado, o limite inferior assume um valor específico da "
"implementação, menor ou igual ao limite superior. Definir *high* para zero "
"força *low* a zero também, e faz com que :meth:`~BaseProtocol.pause_writing` "
"seja chamado sempre que o *buffer* se tornar não vazio. Definir *low* para "
"zero faz com que :meth:`~BaseProtocol.resume_writing` seja chamado apenas "
"quando o *buffer* estiver vazio. O uso de zero para qualquer limite é "
"geralmente sub-ótimo, pois reduz as oportunidades de fazer I/O e computação "
"concorrentemente."

#: ../../library/asyncio-protocol.rst:326
msgid "Use :meth:`~WriteTransport.get_write_buffer_limits` to get the limits."
msgstr ""
"Use :meth:`~WriteTransport.get_write_buffer_limits` para obter os limites."

#: ../../library/asyncio-protocol.rst:331
msgid "Write some *data* bytes to the transport."
msgstr "Escreve alguns bytes de *data* para o transporte."

#: ../../library/asyncio-protocol.rst:333
#: ../../library/asyncio-protocol.rst:362
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""
"Este método não bloqueia; coloca os dados em *buffer* e organiza-os para "
"serem enviados de forma assíncrona."

#: ../../library/asyncio-protocol.rst:338
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""
"Escreve uma lista (ou qualquer iterável) de bytes de dados para o "
"transporte. Isto é funcionalmente equivalente a chamar :meth:`write` em cada "
"elemento produzido pelo iterável, mas pode ser implementado de forma mais "
"eficiente."

#: ../../library/asyncio-protocol.rst:345
msgid ""
"Close the write end of the transport after flushing all buffered data. Data "
"may still be received."
msgstr ""
"Fecha a extremidade de escrita do transporte após descarregar todos os dados "
"em *buffer*. Os dados ainda podem ser recebidos."

#: ../../library/asyncio-protocol.rst:348
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closed connections."
msgstr ""
"Este método pode gerar :exc:`NotImplementedError` se o transporte (por "
"exemplo, SSL) não suportar ligações semi-fechadas."

#: ../../library/asyncio-protocol.rst:353
msgid "Datagram Transports"
msgstr "Transportes de datagrama"

#: ../../library/asyncio-protocol.rst:357
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""
"Envie os bytes de *data* para o par remoto dado por *addr* (um endereço de "
"destino dependente do transporte). Se *addr* for :const:`None`, os dados são "
"enviados para o endereço de destino dado na criação do transporte."

#: ../../library/asyncio-protocol.rst:367
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost. No more data will be received.  The "
"protocol's :meth:`protocol.connection_lost() <BaseProtocol.connection_lost>` "
"method will eventually be called with :const:`None` as its argument."
msgstr ""
"Fecha o transporte imediatamente, sem esperar que as operações pendentes "
"sejam concluídas. Os dados em *buffer* serão perdidos. Não serão recebidos "
"mais dados. O método :meth:`protocol.connection_lost() <BaseProtocol."
"connection_lost>` do protocolo será eventualmente chamado com :const:`None` "
"como argumento."

#: ../../library/asyncio-protocol.rst:377
msgid "Subprocess Transports"
msgstr "Transportes de subprocesso"

#: ../../library/asyncio-protocol.rst:381
msgid "Return the subprocess process id as an integer."
msgstr "Devolve o ID do processo do subprocesso como um inteiro."

#: ../../library/asyncio-protocol.rst:385
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""
"Devolve o transporte para o *pipe* de comunicação correspondente ao "
"descritor de ficheiro inteiro *fd*:"

#: ../../library/asyncio-protocol.rst:388
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""

#: ../../library/asyncio-protocol.rst:390
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""

#: ../../library/asyncio-protocol.rst:392
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""

#: ../../library/asyncio-protocol.rst:394
msgid "other *fd*: :const:`None`"
msgstr "outro *fd*: :const:`None`"

#: ../../library/asyncio-protocol.rst:398
msgid ""
"Return the subprocess return code as an integer or :const:`None` if it "
"hasn't returned, which is similar to the :attr:`subprocess.Popen.returncode` "
"attribute."
msgstr ""
"Devolve o código de retorno do subprocesso como um inteiro ou :const:`None` "
"se ainda não retornou, o que é semelhante ao atributo :attr:`subprocess."
"Popen.returncode`."

#: ../../library/asyncio-protocol.rst:404
msgid "Kill the subprocess."
msgstr "Mata o subprocesso."

#: ../../library/asyncio-protocol.rst:406
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""
"Em sistemas POSIX, a função envia SIGKILL para o subprocesso. No Windows, "
"este método é um alias para :meth:`terminate`."

#: ../../library/asyncio-protocol.rst:409
msgid "See also :meth:`subprocess.Popen.kill`."
msgstr "Veja também :meth:`subprocess.Popen.kill`."

#: ../../library/asyncio-protocol.rst:413
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""
"Envie o número do *signal* para o subprocesso, como em :meth:`subprocess."
"Popen.send_signal`."

#: ../../library/asyncio-protocol.rst:418
msgid "Stop the subprocess."
msgstr "Para o subprocesso."

#: ../../library/asyncio-protocol.rst:420
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""

#: ../../library/asyncio-protocol.rst:424
msgid "See also :meth:`subprocess.Popen.terminate`."
msgstr "Veja também :meth:`subprocess.Popen.terminate`."

#: ../../library/asyncio-protocol.rst:428
msgid "Kill the subprocess by calling the :meth:`kill` method."
msgstr "Mata o subprocesso chamando o método :meth:`kill`."

#: ../../library/asyncio-protocol.rst:430
msgid ""
"If the subprocess hasn't returned yet, and close transports of *stdin*, "
"*stdout*, and *stderr* pipes."
msgstr ""
"Se o subprocesso ainda não tiver retornado, fecha os transportes dos *pipes* "
"de *stdin*, *stdout* e *stderr*."

#: ../../library/asyncio-protocol.rst:437
msgid "Protocols"
msgstr "Protocolos"

#: ../../library/asyncio-protocol.rst:439
msgid "**Source code:** :source:`Lib/asyncio/protocols.py`"
msgstr "**Código fonte:** :source:`Lib/asyncio/protocols.py`"

#: ../../library/asyncio-protocol.rst:443
msgid ""
"asyncio provides a set of abstract base classes that should be used to "
"implement network protocols.  Those classes are meant to be used together "
"with :ref:`transports <asyncio-transport>`."
msgstr ""
"O asyncio fornece um conjunto de classes base abstratas que devem ser usadas "
"para implementar protocolos de rede. Essas classes são destinadas a serem "
"usadas em conjunto com :ref:`transportes <asyncio-transport>`."

#: ../../library/asyncio-protocol.rst:447
msgid ""
"Subclasses of abstract base protocol classes may implement some or all "
"methods.  All these methods are callbacks: they are called by transports on "
"certain events, for example when some data is received. A base protocol "
"method should be called by the corresponding transport."
msgstr ""
"Subclasses de classes base de protocolo abstrato podem implementar alguns ou "
"todos os métodos. Todos estes métodos são *callbacks*: são chamados por "
"transportes em certos eventos, por exemplo, quando alguns dados são "
"recebidos. Um método de protocolo base deve ser chamado pelo transporte "
"correspondente."

#: ../../library/asyncio-protocol.rst:454
msgid "Base Protocols"
msgstr "Protocolos Base"

#: ../../library/asyncio-protocol.rst:458
msgid "Base protocol with methods that all protocols share."
msgstr "Protocolo base com métodos que todos os protocolos partilham."

#: ../../library/asyncio-protocol.rst:462
msgid ""
"The base class for implementing streaming protocols (TCP, Unix sockets, etc)."
msgstr ""
"A classe base para implementar protocolos de fluxo (TCP, *sockets* Unix, "
"etc.)."

#: ../../library/asyncio-protocol.rst:467
msgid ""
"A base class for implementing streaming protocols with manual control of the "
"receive buffer."
msgstr ""
"Uma classe base para implementar protocolos de fluxo com controlo manual do "
"*buffer* de receção."

#: ../../library/asyncio-protocol.rst:472
msgid "The base class for implementing datagram (UDP) protocols."
msgstr "A classe base para implementar protocolos de datagrama (UDP)."

#: ../../library/asyncio-protocol.rst:476
msgid ""
"The base class for implementing protocols communicating with child processes "
"(unidirectional pipes)."
msgstr ""
"A classe base para implementar protocolos que comunicam com processos filhos "
"(pipes unidirecionais)."

#: ../../library/asyncio-protocol.rst:481
msgid "Base Protocol"
msgstr "Protocolo Base"

#: ../../library/asyncio-protocol.rst:483
msgid "All asyncio protocols can implement Base Protocol callbacks."
msgstr ""
"Todos os protocolos asyncio podem implementar *callbacks* de Protocolo Base."

#: ../../library/asyncio-protocol.rst:486
msgid "Connection Callbacks"
msgstr "*Callbacks* de Ligação"

#: ../../library/asyncio-protocol.rst:487
msgid ""
"Connection callbacks are called on all protocols, exactly once per a "
"successful connection.  All other protocol callbacks can only be called "
"between those two methods."
msgstr ""
"Os *callbacks* de ligação são chamados em todos os protocolos, exatamente "
"uma vez por ligação bem-sucedida. Todos os outros *callbacks* de protocolo "
"só podem ser chamados entre esses dois métodos."

#: ../../library/asyncio-protocol.rst:493
msgid "Called when a connection is made."
msgstr "Chamado quando uma ligação é estabelecida."

#: ../../library/asyncio-protocol.rst:495
msgid ""
"The *transport* argument is the transport representing the connection.  The "
"protocol is responsible for storing the reference to its transport."
msgstr ""
"O argumento *transport* é o transporte que representa a ligação. O protocolo "
"é responsável por armazenar a referência ao seu transporte."

#: ../../library/asyncio-protocol.rst:501
msgid "Called when the connection is lost or closed."
msgstr "Chamado quando a ligação é perdida ou fechada."

#: ../../library/asyncio-protocol.rst:503
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""
"O argumento é um objeto de exceção ou :const:`None`. Este último significa "
"que um EOF regular foi recebido, ou que a ligação foi abortada ou fechada "
"por este lado da ligação."

#: ../../library/asyncio-protocol.rst:509
msgid "Flow Control Callbacks"
msgstr "*Callbacks* de Controlo de Fluxo"

#: ../../library/asyncio-protocol.rst:510
msgid ""
"Flow control callbacks can be called by transports to pause or resume "
"writing performed by the protocol."
msgstr ""
"Os *callbacks* de controlo de fluxo podem ser chamados por transportes para "
"pausar ou retomar a escrita realizada pelo protocolo."

#: ../../library/asyncio-protocol.rst:513
msgid ""
"See the documentation of the :meth:`~WriteTransport.set_write_buffer_limits` "
"method for more details."
msgstr ""
"Veja a documentação do método :meth:`~WriteTransport."
"set_write_buffer_limits` para mais detalhes."

#: ../../library/asyncio-protocol.rst:518
msgid "Called when the transport's buffer goes over the high watermark."
msgstr "Chamado quando o *buffer* do transporte ultrapassa o limite superior."

#: ../../library/asyncio-protocol.rst:522
msgid "Called when the transport's buffer drains below the low watermark."
msgstr ""
"Chamado quando o *buffer* do transporte desce abaixo do limite inferior."

#: ../../library/asyncio-protocol.rst:524
msgid ""
"If the buffer size equals the high watermark, :meth:`~BaseProtocol."
"pause_writing` is not called: the buffer size must go strictly over."
msgstr ""
"Se o tamanho do *buffer* for igual ao limite superior, :meth:`~BaseProtocol."
"pause_writing` não é chamado: o tamanho do *buffer* deve ultrapassar "
"estritamente."

#: ../../library/asyncio-protocol.rst:528
msgid ""
"Conversely, :meth:`~BaseProtocol.resume_writing` is called when the buffer "
"size is equal or lower than the low watermark.  These end conditions are "
"important to ensure that things go as expected when either mark is zero."
msgstr ""
"Por outro lado, :meth:`~BaseProtocol.resume_writing` é chamado quando o "
"tamanho do *buffer* é igual ou inferior ao limite inferior. Estas condições "
"finais são importantes para garantir que as coisas funcionem como esperado "
"quando qualquer um dos limites é zero."

#: ../../library/asyncio-protocol.rst:535
msgid "Streaming Protocols"
msgstr "Protocolos de Fluxo"

#: ../../library/asyncio-protocol.rst:537
msgid ""
"Event methods, such as :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, and :meth:`loop.connect_write_pipe` accept factories "
"that return streaming protocols."
msgstr ""
"Métodos de eventos, como :meth:`loop.create_server`, :meth:`loop."
"create_unix_server`, :meth:`loop.create_connection`, :meth:`loop."
"create_unix_connection`, :meth:`loop.connect_accepted_socket`, :meth:`loop."
"connect_read_pipe`, e :meth:`loop.connect_write_pipe` aceitam fábricas que "
"retornam protocolos de fluxo."

#: ../../library/asyncio-protocol.rst:545
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""
"Chamado quando alguns dados são recebidos. *data* é um objeto bytes não "
"vazio que contém os dados recebidos."

#: ../../library/asyncio-protocol.rst:548
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible. However, data is always received in "
"the correct order."
msgstr ""
"Se os dados são colocados em *buffer*, divididos em partes ou remontados "
"depende do transporte. Em geral, não deve confiar em semânticas específicas "
"e, em vez disso, tornar a sua análise genérica e flexível. No entanto, os "
"dados são sempre recebidos na ordem correta."

#: ../../library/asyncio-protocol.rst:553
msgid ""
"The method can be called an arbitrary number of times while a connection is "
"open."
msgstr ""
"O método pode ser chamado um número arbitrário de vezes enquanto uma ligação "
"estiver aberta."

#: ../../library/asyncio-protocol.rst:556
msgid ""
"However, :meth:`protocol.eof_received() <Protocol.eof_received>` is called "
"at most once.  Once ``eof_received()`` is called, ``data_received()`` is not "
"called anymore."
msgstr ""
"No entanto, :meth:`protocol.eof_received() <Protocol.eof_received>` é "
"chamado no máximo uma vez. Depois de ``eof_received()`` ser chamado, "
"``data_received()`` não é mais chamado."

#: ../../library/asyncio-protocol.rst:562
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`transport.write_eof() <WriteTransport.write_eof>`, if the "
"other end also uses asyncio)."
msgstr ""
"Chamado quando a outra extremidade sinaliza que não enviará mais dados (por "
"exemplo, chamando :meth:`transport.write_eof() <WriteTransport.write_eof>`, "
"se a outra extremidade também usar asyncio)."

#: ../../library/asyncio-protocol.rst:567
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, the protocol used determines whether to close the transport. Since "
"the default implementation returns ``None``, it implicitly closes the "
"connection."
msgstr ""
"Este método pode devolver um valor falso (incluindo ``None``), caso em que o "
"transporte se fechará. Por outro lado, se este método devolver um valor "
"verdadeiro, o protocolo usado determina se deve fechar o transporte. Como a "
"implementação predefinida devolve ``None``, fecha implicitamente a ligação."

#: ../../library/asyncio-protocol.rst:573
msgid ""
"Some transports, including SSL, don't support half-closed connections, in "
"which case returning true from this method will result in the connection "
"being closed."
msgstr ""
"Alguns transportes, incluindo SSL, não suportam ligações semi-fechadas, caso "
"em que devolver verdadeiro deste método resultará no fechamento da ligação."

#: ../../library/asyncio-protocol.rst:578
#: ../../library/asyncio-protocol.rst:636
msgid "State machine:"
msgstr "Máquina de estados:"

#: ../../library/asyncio-protocol.rst:589
msgid "Buffered Streaming Protocols"
msgstr "Protocolos de fluxo com *buffer*"

#: ../../library/asyncio-protocol.rst:593
msgid ""
"Buffered Protocols can be used with any event loop method that supports "
"`Streaming Protocols`_."
msgstr ""
"Protocolos com *Buffer* podem ser usados com qualquer método de ciclo de "
"eventos que suporte `Protocolos de Fluxo`_."

#: ../../library/asyncio-protocol.rst:596
msgid ""
"``BufferedProtocol`` implementations allow explicit manual allocation and "
"control of the receive buffer.  Event loops can then use the buffer provided "
"by the protocol to avoid unnecessary data copies.  This can result in "
"noticeable performance improvement for protocols that receive big amounts of "
"data.  Sophisticated protocol implementations can significantly reduce the "
"number of buffer allocations."
msgstr ""
"As implementações de ``BufferedProtocol`` permitem alocação manual explícita "
"e controlo do *buffer* de receção. Os ciclos de eventos podem então usar o "
"*buffer* fornecido pelo protocolo para evitar cópias de dados "
"desnecessárias. Isto pode resultar em melhorias de desempenho notáveis para "
"protocolos que recebem grandes quantidades de dados. Implementações "
"sofisticadas de protocolos podem reduzir significativamente o número de "
"alocações de *buffer*."

#: ../../library/asyncio-protocol.rst:603
msgid ""
"The following callbacks are called on :class:`BufferedProtocol` instances:"
msgstr ""
"Os seguintes *callbacks* são chamados em instâncias de :class:"
"`BufferedProtocol`:"

#: ../../library/asyncio-protocol.rst:608
msgid "Called to allocate a new receive buffer."
msgstr "Chamado para alocar um novo *buffer* de receção."

#: ../../library/asyncio-protocol.rst:610
msgid ""
"*sizehint* is the recommended minimum size for the returned buffer.  It is "
"acceptable to return smaller or larger buffers than what *sizehint* "
"suggests.  When set to -1, the buffer size can be arbitrary. It is an error "
"to return a buffer with a zero size."
msgstr ""
"*sizehint* é o tamanho mínimo recomendado para o *buffer* devolvido. É "
"aceitável devolver *buffers* menores ou maiores do que o sugerido por "
"*sizehint*. Quando definido como -1, o tamanho do *buffer* pode ser "
"arbitrário. É um erro devolver um *buffer* com tamanho zero."

#: ../../library/asyncio-protocol.rst:615
msgid ""
"``get_buffer()`` must return an object implementing the :ref:`buffer "
"protocol <bufferobjects>`."
msgstr ""
"``get_buffer()`` deve devolver um objeto que implemente o :ref:`protocolo de "
"buffer <bufferobjects>`."

#: ../../library/asyncio-protocol.rst:620
msgid "Called when the buffer was updated with the received data."
msgstr "Chamado quando o *buffer* foi atualizado com os dados recebidos."

#: ../../library/asyncio-protocol.rst:622
msgid "*nbytes* is the total number of bytes that were written to the buffer."
msgstr "*nbytes* é o número total de bytes que foram escritos no *buffer*."

#: ../../library/asyncio-protocol.rst:626
msgid ""
"See the documentation of the :meth:`protocol.eof_received() <Protocol."
"eof_received>` method."
msgstr ""
"Veja a documentação do método :meth:`protocol.eof_received() <Protocol."
"eof_received>`."

#: ../../library/asyncio-protocol.rst:630
msgid ""
":meth:`~BufferedProtocol.get_buffer` can be called an arbitrary number of "
"times during a connection.  However, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` is called at most once and, if called, :meth:"
"`~BufferedProtocol.get_buffer` and :meth:`~BufferedProtocol.buffer_updated` "
"won't be called after it."
msgstr ""
":meth:`~BufferedProtocol.get_buffer` pode ser chamado um número arbitrário "
"de vezes durante uma ligação. No entanto, :meth:`protocol.eof_received() "
"<Protocol.eof_received>` é chamado no máximo uma vez e, se chamado, :meth:"
"`~BufferedProtocol.get_buffer` e :meth:`~BufferedProtocol.buffer_updated` "
"não serão chamados depois disso."

#: ../../library/asyncio-protocol.rst:649
msgid "Datagram Protocols"
msgstr "Protocolos de datagrama"

#: ../../library/asyncio-protocol.rst:651
msgid ""
"Datagram Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.create_datagram_endpoint` method."
msgstr ""
"Instâncias de Protocolo de Datagrama devem ser construídas por fábricas de "
"protocolos passadas ao método :meth:`loop.create_datagram_endpoint`."

#: ../../library/asyncio-protocol.rst:656
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""
"Chamado quando um datagrama é recebido. *data* é um objeto bytes que contém "
"os dados recebidos. *addr* é o endereço do par que envia os dados; o formato "
"exato depende do transporte."

#: ../../library/asyncio-protocol.rst:662
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""
"Chamado quando uma operação de envio ou receção anterior gera um :class:"
"`OSError`. *exc* é a instância de :class:`OSError`."

#: ../../library/asyncio-protocol.rst:665
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram could not be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""
"Este método é chamado em condições raras, quando o transporte (por exemplo, "
"UDP) deteta que um datagrama não pôde ser entregue ao seu destinatário. No "
"entanto, em muitas condições, datagramas não entregáveis serão descartados "
"silenciosamente."

#: ../../library/asyncio-protocol.rst:672
msgid ""
"On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for "
"datagram protocols, because there is no reliable way to detect send failures "
"caused by writing too many packets."
msgstr ""
"Em sistemas BSD (macOS, FreeBSD, etc.), o controlo de fluxo não é suportado "
"para protocolos de datagrama, porque não há uma forma fiável de detetar "
"falhas de envio causadas pela escrita de demasiados pacotes."

#: ../../library/asyncio-protocol.rst:676
msgid ""
"The socket always appears 'ready' and excess packets are dropped. An :class:"
"`OSError` with ``errno`` set to :const:`errno.ENOBUFS` may or may not be "
"raised; if it is raised, it will be reported to :meth:`DatagramProtocol."
"error_received` but otherwise ignored."
msgstr ""
"O *socket* parece sempre 'pronto' e os pacotes em excesso são descartados. "
"Um :class:`OSError` com ``errno`` definido para :const:`errno.ENOBUFS` pode "
"ou não ser gerado; se for gerado, será reportado a :meth:`DatagramProtocol."
"error_received`, mas de outra forma será ignorado."

#: ../../library/asyncio-protocol.rst:685
msgid "Subprocess Protocols"
msgstr "Protocolos de subprocesso"

#: ../../library/asyncio-protocol.rst:687
msgid ""
"Subprocess Protocol instances should be constructed by protocol factories "
"passed to the :meth:`loop.subprocess_exec` and :meth:`loop.subprocess_shell` "
"methods."
msgstr ""
"Instâncias de Protocolo de Subprocesso devem ser construídas por fábricas de "
"protocolos passadas aos métodos :meth:`loop.subprocess_exec` e :meth:`loop."
"subprocess_shell`."

#: ../../library/asyncio-protocol.rst:693
msgid ""
"Called when the child process writes data into its stdout or stderr pipe."
msgstr ""
"Chamado quando o processo filho escreve dados no seu *pipe* de stdout ou "
"stderr."

#: ../../library/asyncio-protocol.rst:696
msgid "*fd* is the integer file descriptor of the pipe."
msgstr "*fd* é o descritor de ficheiro inteiro do *pipe*."

#: ../../library/asyncio-protocol.rst:698
msgid "*data* is a non-empty bytes object containing the received data."
msgstr "*data* é um objeto bytes não vazio que contém os dados recebidos."

#: ../../library/asyncio-protocol.rst:702
msgid ""
"Called when one of the pipes communicating with the child process is closed."
msgstr ""
"Chamado quando um dos *pipes* que comunicam com o processo filho é fechado."

#: ../../library/asyncio-protocol.rst:705
msgid "*fd* is the integer file descriptor that was closed."
msgstr "*fd* é o descritor de ficheiro inteiro que foi fechado."

#: ../../library/asyncio-protocol.rst:709
msgid "Called when the child process has exited."
msgstr "Chamado quando o processo filho terminou."

#: ../../library/asyncio-protocol.rst:713
msgid "Examples"
msgstr "Exemplos"

#: ../../library/asyncio-protocol.rst:718
msgid "TCP Echo Server"
msgstr "Servidor TCP Echo"

#: ../../library/asyncio-protocol.rst:720
msgid ""
"Create a TCP echo server using the :meth:`loop.create_server` method, send "
"back received data, and close the connection::"
msgstr ""
"Criar um servidor TCP echo usando o método :meth:`loop.create_server`, "
"enviar de volta os dados recebidos e fechar a ligação:"

#: ../../library/asyncio-protocol.rst:761
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the high-level :func:`asyncio.start_server` function."
msgstr ""
"O exemplo :ref:`servidor TCP echo usando fluxos <asyncio-tcp-echo-server-"
"streams>` usa a função de alto nível :func:`asyncio.start_server`."

#: ../../library/asyncio-protocol.rst:767
msgid "TCP Echo Client"
msgstr "Cliente TCP Echo"

#: ../../library/asyncio-protocol.rst:769
msgid ""
"A TCP echo client using the :meth:`loop.create_connection` method, sends "
"data, and waits until the connection is closed::"
msgstr ""
"Um cliente TCP echo usando o método :meth:`loop.create_connection`, envia "
"dados e espera até que a ligação seja fechada:"

#: ../../library/asyncio-protocol.rst:817
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the high-level :func:`asyncio.open_connection` function."
msgstr ""
"O exemplo :ref:`cliente TCP echo usando fluxos <asyncio-tcp-echo-client-"
"streams>` usa a função de alto nível :func:`asyncio.open_connection`."

#: ../../library/asyncio-protocol.rst:824
msgid "UDP Echo Server"
msgstr "Servidor UDP Echo"

#: ../../library/asyncio-protocol.rst:826
msgid ""
"A UDP echo server, using the :meth:`loop.create_datagram_endpoint` method, "
"sends back received data::"
msgstr ""
"Um servidor UDP echo, usando o método :meth:`loop.create_datagram_endpoint`, "
"envia de volta os dados recebidos:"

#: ../../library/asyncio-protocol.rst:868
msgid "UDP Echo Client"
msgstr "Cliente UDP Echo"

#: ../../library/asyncio-protocol.rst:870
msgid ""
"A UDP echo client, using the :meth:`loop.create_datagram_endpoint` method, "
"sends data and closes the transport when it receives the answer::"
msgstr ""

#: ../../library/asyncio-protocol.rst:925
msgid "Connecting Existing Sockets"
msgstr "Ligar *Sockets* Existentes"

#: ../../library/asyncio-protocol.rst:927
msgid ""
"Wait until a socket receives data using the :meth:`loop.create_connection` "
"method with a protocol::"
msgstr ""
"Esperar até que um *socket* receba dados usando o método :meth:`loop."
"create_connection` com um protocolo:"

#: ../../library/asyncio-protocol.rst:981
msgid ""
"The :ref:`watch a file descriptor for read events "
"<asyncio_example_watch_fd>` example uses the low-level :meth:`loop."
"add_reader` method to register an FD."
msgstr ""
"O exemplo :ref:`observar um descritor de ficheiro para eventos de leitura "
"<asyncio_example_watch_fd>` usa o método de baixo nível :meth:`loop."
"add_reader` para registar um FD."

#: ../../library/asyncio-protocol.rst:985
msgid ""
"The :ref:`register an open socket to wait for data using streams "
"<asyncio_example_create_connection-streams>` example uses high-level streams "
"created by the :func:`open_connection` function in a coroutine."
msgstr ""
"O exemplo :ref:`registar um socket aberto para esperar por dados usando "
"fluxos <asyncio_example_create_connection-streams>` usa fluxos de alto nível "
"criados pela função :func:`open_connection` numa corrotina."

#: ../../library/asyncio-protocol.rst:992
msgid "loop.subprocess_exec() and SubprocessProtocol"
msgstr "loop.subprocess_exec() e SubprocessProtocol"

#: ../../library/asyncio-protocol.rst:994
msgid ""
"An example of a subprocess protocol used to get the output of a subprocess "
"and to wait for the subprocess exit."
msgstr ""
"Um exemplo de um protocolo de subprocesso usado para obter a saída de um "
"subprocesso e para esperar pela saída do subprocesso."

#: ../../library/asyncio-protocol.rst:997
msgid "The subprocess is created by the :meth:`loop.subprocess_exec` method::"
msgstr "O subprocesso é criado pelo método :meth:`loop.subprocess_exec`:"

#: ../../library/asyncio-protocol.rst:1043
msgid ""
"See also the :ref:`same example <asyncio_example_create_subprocess_exec>` "
"written using high-level APIs."
msgstr ""
"Veja também o :ref:`mesmo exemplo <asyncio_example_create_subprocess_exec>` "
"escrito usando APIs de alto nível."
