# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-21 17:09+0000\n"
"PO-Revision-Date: 2025-09-22 16:50+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ""

#: ../../library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Código-fonte:** :source:`Lib/unittest/__init__.py`"

#: ../../library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Se já estiver familiarizado com os conceitos básicos de testes, pode querer "
"avançar para :ref:`a lista de métodos assert <assert-methods>`.)"

#: ../../library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"A estrutura de testes unitários :mod:`unittest` foi originalmente inspirada "
"pelo JUnit e tem um sabor semelhante às principais estruturas de testes "
"unitários em outras linguagens. Suporta automação de testes, partilha de "
"código de configuração e encerramento para testes, agregação de testes em "
"coleções e independência dos testes em relação à estrutura de relatório."

#: ../../library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Para alcançar isto, o :mod:`unittest` suporta alguns conceitos importantes "
"de forma orientada a objetos:"

#: ../../library/unittest.rst:32
msgid "test fixture"
msgstr "ambiente de teste"

#: ../../library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"Um :dfn:`ambiente de teste` representa a preparação necessária para realizar "
"um ou mais testes, e quaisquer ações de limpeza associadas. Isto pode "
"envolver, por exemplo, a criação de bases de dados temporárias ou proxy, "
"diretórios, ou o início de um processo de servidor."

#: ../../library/unittest.rst:37
msgid "test case"
msgstr "caso de teste"

#: ../../library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
"Um :dfn:`caso de teste` é a unidade individual de teste. Verifica uma "
"resposta específica para um conjunto particular de entradas. O :mod:"
"`unittest` fornece uma classe base, :class:`TestCase`, que pode ser usada "
"para criar novos casos de teste."

#: ../../library/unittest.rst:41
msgid "test suite"
msgstr "conjunto de testes"

#: ../../library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"Um :dfn:`conjunto de testes` é uma coleção de casos de teste, conjuntos de "
"testes, ou ambos. É usado para agregar testes que devem ser executados em "
"conjunto."

#: ../../library/unittest.rst:48
msgid "test runner"
msgstr "executor de testes"

#: ../../library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"Um :dfn:`executor de testes` é um componente que orquestra a execução de "
"testes e fornece o resultado ao utilizador. O executor pode usar uma "
"interface gráfica, uma interface textual, ou retornar um valor especial para "
"indicar os resultados da execução dos testes."

#: ../../library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr "Módulo :mod:`doctest`"

#: ../../library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "Outro módulo de suporte a testes com um estilo muito diferente."

#: ../../library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Teste simples de Smalltalk: Com Padrões <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../../library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"O artigo original de Kent Beck sobre estruturas de teste usando o padrão "
"partilhado pelo :mod:`unittest`."

#: ../../library/unittest.rst:61
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../../library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Estrutura de testes unitários de terceiros com uma sintaxe mais leve para "
"escrever testes. Por exemplo, ``assert func(10) == 42``."

#: ../../library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`A taxonomia das ferramentas de teste do Python <https://wiki.python.org/"
"moin/PythonTestingToolsTaxonomy>`_"

#: ../../library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Uma lista extensa de ferramentas de teste em Python, incluindo estruturas de "
"teste funcional e bibliotecas de objetos simulados."

#: ../../library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Lista de Correio Testing in Python <http://lists.idyll.org/listinfo/testing-"
"in-python>`_"

#: ../../library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"Um grupo de interesse especial para discussão de testes e ferramentas de "
"teste em Python."

#: ../../library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://www.jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"O script :file:`Tools/unittestgui/unittestgui.py` na distribuição de código-"
"fonte do Python é uma ferramenta gráfica para descoberta e execução de "
"testes. Isto é destinado principalmente à facilidade de uso para quem é novo "
"em testes unitários. Para ambientes de produção, recomenda-se que os testes "
"sejam conduzidos por um sistema de integração contínua, como `Buildbot "
"<https://buildbot.net/>`_, `Jenkins <https://www.jenkins.io/>`_, `GitHub "
"Actions <https://github.com/features/actions>`_, ou `AppVeyor <https://www."
"appveyor.com/>`_."

#: ../../library/unittest.rst:83
msgid "Basic example"
msgstr "Exemplo básico"

#: ../../library/unittest.rst:85
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"O módulo :mod:`unittest` fornece um conjunto rico de ferramentas para "
"construir e executar testes. Esta secção demonstra que um pequeno "
"subconjunto das ferramentas é suficiente para satisfazer as necessidades da "
"maioria dos utilizadores."

#: ../../library/unittest.rst:89
msgid "Here is a short script to test three string methods::"
msgstr "Aqui está um script curto para testar três métodos de strings::"

#: ../../library/unittest.rst:113
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""

#: ../../library/unittest.rst:118
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"O cerne de cada teste é uma chamada a :meth:`~TestCase.assertEqual` para "
"verificar um resultado esperado; :meth:`~TestCase.assertTrue` ou :meth:"
"`~TestCase.assertFalse` para verificar uma condição; ou :meth:`~TestCase."
"assertRaises` para verificar que uma exceção específica é levantada. Estes "
"métodos são usados em vez da instrução :keyword:`assert` para que o executor "
"de testes possa acumular todos os resultados dos testes e produzir um "
"relatório."

#: ../../library/unittest.rst:125
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Os métodos :meth:`~TestCase.setUp` e :meth:`~TestCase.tearDown` permitem-lhe "
"definir instruções que serão executadas antes e depois de cada método de "
"teste. São abordados com mais detalhe na secção :ref:`organizing-tests`."

#: ../../library/unittest.rst:129
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"O bloco final mostra uma forma simples de executar os testes. A função :func:"
"`unittest.main` fornece uma interface de linha de comandos para o script de "
"teste. Quando executado a partir da linha de comandos, o script acima produz "
"uma saída que se parece com isto::"

#: ../../library/unittest.rst:139
msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Passar a opção ``-v`` para o seu script de teste instruirá a função :func:"
"`unittest.main` a ativar um nível mais alto de verbosidade e produzir a "
"seguinte saída::"

#: ../../library/unittest.rst:151
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Os exemplos acima mostram as funcionalidades mais comumente usadas do :mod:"
"`unittest`, que são suficientes para satisfazer muitas necessidades diárias "
"de teste. O restante da documentação explora o conjunto completo de "
"funcionalidades a partir de primeiros princípios."

#: ../../library/unittest.rst:155
msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""
"O comportamento de retornar um valor de um método de teste (diferente do "
"valor predefinido ``None``) está agora obsoleto."

#: ../../library/unittest.rst:163
msgid "Command-Line Interface"
msgstr "Interface de Linha de Comandos"

#: ../../library/unittest.rst:165
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"O módulo unittest pode ser usado a partir da linha de comandos para executar "
"testes de módulos, classes ou até mesmo métodos de teste individuais::"

#: ../../library/unittest.rst:172
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Pode passar uma lista com qualquer combinação de nomes de módulos e nomes "
"totalmente qualificados de classes ou métodos."

#: ../../library/unittest.rst:175
msgid "Test modules can be specified by file path as well::"
msgstr ""
"Os módulos de teste também podem ser especificados pelo caminho do ficheiro::"

#: ../../library/unittest.rst:179
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Isto permite-lhe usar a conclusão de nomes de ficheiros da shell para "
"especificar o módulo de teste. O ficheiro especificado ainda deve ser "
"importável como um módulo. O caminho é convertido num nome de módulo "
"removendo o '.py' e convertendo os separadores de caminho em '.'. Se quiser "
"executar um ficheiro de teste que não é importável como um módulo, deve "
"executar o ficheiro diretamente."

#: ../../library/unittest.rst:185
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Pode executar testes com mais detalhes (maior verbosidade) passando a flag -"
"v::"

#: ../../library/unittest.rst:189
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"Quando executado sem argumentos, a :ref:`unittest-test-discovery` é "
"iniciada::"

#: ../../library/unittest.rst:193
msgid "For a list of all the command-line options::"
msgstr "Para uma lista de todas as opções de linha de comandos::"

#: ../../library/unittest.rst:197
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"Em versões anteriores, só era possível executar métodos de teste individuais "
"e não módulos ou classes."

#: ../../library/unittest.rst:203
msgid "Command-line options"
msgstr "Opções de linha de comandos"

#: ../../library/unittest.rst:205
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` suporta as seguintes opções de linha de comandos:"

#: ../../library/unittest.rst:211
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Os fluxos de saída padrão e erro padrão são colocados em buffer durante a "
"execução do teste. A saída durante um teste bem-sucedido é descartada. A "
"saída é ecoada normalmente em caso de falha ou erro no teste e é adicionada "
"às mensagens de falha."

#: ../../library/unittest.rst:217
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"Pressionar :kbd:`Control-C` durante a execução do teste aguarda que o teste "
"atual termine e, em seguida, relata todos os resultados até ao momento. Um "
"segundo :kbd:`Control-C` levanta a exceção normal :exc:`KeyboardInterrupt`."

#: ../../library/unittest.rst:221
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Consulte `Tratamento de Sinais`_ para ver as funções que fornecem esta "
"funcionalidade."

#: ../../library/unittest.rst:225
msgid "Stop the test run on the first error or failure."
msgstr "Parar a execução do teste no primeiro erro ou falha."

#: ../../library/unittest.rst:229
msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Executar apenas métodos e classes de teste que correspondam ao padrão ou "
"substring. Esta opção pode ser usada várias vezes, caso em que todos os "
"casos de teste que correspondam a qualquer um dos padrões dados são "
"incluídos."

#: ../../library/unittest.rst:233
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Padrões que contêm um carácter curinga (``*``) são comparados com o nome do "
"teste usando :meth:`fnmatch.fnmatchcase`; caso contrário, é usada uma "
"correspondência simples de substring sensível a maiúsculas."

#: ../../library/unittest.rst:237
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Os padrões são comparados com o nome totalmente qualificado do método de "
"teste, conforme importado pelo carregador de testes."

#: ../../library/unittest.rst:240
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Por exemplo, ``-k foo`` corresponde a ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, mas não a ``bar_tests.FooTest."
"test_something``."

#: ../../library/unittest.rst:245
msgid "Show local variables in tracebacks."
msgstr "Mostrar variáveis locais em tracebacks."

#: ../../library/unittest.rst:247
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr ""
"As opções de linha de comandos ``-b``, ``-c`` e ``-f`` foram adicionadas."

#: ../../library/unittest.rst:250
msgid "The command-line option ``--locals``."
msgstr "A opção de linha de comandos ``--locals``."

#: ../../library/unittest.rst:253
msgid "The command-line option ``-k``."
msgstr "A opção de linha de comandos ``-k``."

#: ../../library/unittest.rst:256
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"A linha de comandos também pode ser usada para descoberta de testes, para "
"executar todos os testes de um projeto ou apenas um subconjunto."

#: ../../library/unittest.rst:263
msgid "Test Discovery"
msgstr "Descoberta de Testes"

#: ../../library/unittest.rst:267
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""
"O Unittest suporta descoberta simples de testes. Para ser compatível com a "
"descoberta de testes, todos os ficheiros de teste devem ser :ref:`módulos "
"<tut-modules>` ou :ref:`pacotes <tut-packages>` importáveis a partir do "
"diretório de topo do projeto (isto significa que os seus nomes de ficheiro "
"devem ser :ref:`identificadores <identifiers>` válidos)."

#: ../../library/unittest.rst:273
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"A descoberta de testes é implementada em :meth:`TestLoader.discover`, mas "
"também pode ser usada a partir da linha de comandos. O uso básico da linha "
"de comandos é::"

#: ../../library/unittest.rst:281
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Como atalho, ``python -m unittest`` é equivalente a ``python -m unittest "
"discover``. Se quiser passar argumentos para a descoberta de testes, o "
"subcomando ``discover`` deve ser usado explicitamente."

#: ../../library/unittest.rst:285
msgid "The ``discover`` sub-command has the following options:"
msgstr "O subcomando ``discover`` tem as seguintes opções:"

#: ../../library/unittest.rst:291
msgid "Verbose output"
msgstr "Saída detalhada"

#: ../../library/unittest.rst:295
msgid "Directory to start discovery (``.`` default)"
msgstr "Diretório para iniciar a descoberta (``.`` predefinido)"

#: ../../library/unittest.rst:299
msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""
"Padrão para corresponder a ficheiros de teste (``test*.py`` predefinido)"

#: ../../library/unittest.rst:303
msgid "Top level directory of project (defaults to start directory)"
msgstr "Diretório de topo do projeto (predefinido para o diretório de início)"

#: ../../library/unittest.rst:305
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"As opções :option:`-s`, :option:`-p` e :option:`-t` podem ser passadas como "
"argumentos posicionais nessa ordem. As duas linhas de comando seguintes são "
"equivalentes::"

#: ../../library/unittest.rst:312
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Além de ser um caminho, é possível passar um nome de pacote, por exemplo "
"``myproject.subpackage.test``, como diretório de início. O nome do pacote "
"que fornecer será então importado e a sua localização no sistema de "
"ficheiros será usada como diretório de início."

#: ../../library/unittest.rst:319
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"A descoberta de testes carrega os testes importando-os. Depois de a "
"descoberta de testes encontrar todos os ficheiros de teste a partir do "
"diretório de início que especificar, converte os caminhos em nomes de "
"pacotes para importar. Por exemplo, :file:`foo/bar/baz.py` será importado "
"como ``foo.bar.baz``."

#: ../../library/unittest.rst:324
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Se tiver um pacote instalado globalmente e tentar a descoberta de testes "
"noutra cópia do pacote, a importação *pode* acontecer a partir do local "
"errado. Se isto acontecer, a descoberta de testes avisá-lo-á e sairá."

#: ../../library/unittest.rst:328
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Se fornecer o diretório de início como um nome de pacote em vez de um "
"caminho para um diretório, a descoberta assume que a localização de onde "
"importa é a localização que pretendia, pelo que não receberá o aviso."

#: ../../library/unittest.rst:333
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Os módulos e pacotes de teste podem personalizar o carregamento e descoberta "
"de testes através do `protocolo load_tests`_."

#: ../../library/unittest.rst:336
msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""

#: ../../library/unittest.rst:342
msgid ""
":mod:`unittest` dropped the :term:`namespace packages <namespace package>` "
"support in Python 3.11. It has been broken since Python 3.7. Start directory "
"and subdirectories containing tests must be regular package that have "
"``__init__.py`` file."
msgstr ""

#: ../../library/unittest.rst:348
msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr ""

#: ../../library/unittest.rst:364
msgid "Organizing test code"
msgstr "Organização do código de teste"

#: ../../library/unittest.rst:366
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Os blocos básicos de construção de testes unitários são :dfn:`casos de "
"teste` — cenários individuais que devem ser configurados e verificados "
"quanto à correção. Em :mod:`unittest`, os casos de teste são representados "
"por instâncias de :class:`unittest.TestCase`. Para criar os seus próprios "
"casos de teste, deve escrever subclasses de :class:`TestCase` ou usar :class:"
"`FunctionTestCase`."

#: ../../library/unittest.rst:372
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"O código de teste de uma instância de :class:`TestCase` deve ser totalmente "
"autónomo, de forma a que possa ser executado isoladamente ou em combinação "
"arbitrária com qualquer número de outros casos de teste."

#: ../../library/unittest.rst:376
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"A subclasse mais simples de :class:`TestCase` implementará simplesmente um "
"método de teste (ou seja, um método cujo nome começa com ``test``) para "
"executar código de teste específico::"

#: ../../library/unittest.rst:387
msgid ""
"Note that in order to test something, we use one of the :ref:`assert\\* "
"methods <assert-methods>` provided by the :class:`TestCase` base class.  If "
"the test fails, an exception will be raised with an explanatory message, "
"and :mod:`unittest` will identify the test case as a :dfn:`failure`.  Any "
"other exceptions will be treated as :dfn:`errors`."
msgstr ""
"Note que, para testar algo, usamos um dos :ref:`métodos assert <assert-"
"methods>` fornecidos pela classe base :class:`TestCase`. Se o teste falhar, "
"será levantada uma exceção com uma mensagem explicativa, e o :mod:`unittest` "
"identificará o caso de teste como uma :dfn:`falha`. Quaisquer outras "
"exceções serão tratadas como :dfn:`erros`."

#: ../../library/unittest.rst:393
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Os testes podem ser numerosos e a sua configuração pode ser repetitiva. "
"Felizmente, podemos fatorizar o código de configuração implementando um "
"método chamado :meth:`~TestCase.setUp`, que a estrutura de teste chamará "
"automaticamente para cada teste que executamos::"

#: ../../library/unittest.rst:414
msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"A ordem pela qual os vários testes serão executados é determinada pela "
"ordenação dos nomes dos métodos de teste de acordo com a ordenação "
"incorporada para strings."

#: ../../library/unittest.rst:418
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Se o método :meth:`~TestCase.setUp` levantar uma exceção enquanto o teste "
"está a ser executado, a estrutura considerará que o teste sofreu um erro, e "
"o método de teste não será executado."

#: ../../library/unittest.rst:422
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"Da mesma forma, podemos fornecer um método :meth:`~TestCase.tearDown` que "
"organiza tudo depois de o método de teste ter sido executado::"

#: ../../library/unittest.rst:434
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Se :meth:`~TestCase.setUp` tiver sucesso, :meth:`~TestCase.tearDown` será "
"executado independentemente de o método de teste ter tido sucesso ou não."

#: ../../library/unittest.rst:437
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"Um ambiente de trabalho para o código de teste é chamado de :dfn:`ambiente "
"de teste`. Uma nova instância de TestCase é criada como um ambiente de teste "
"único usado para executar cada método de teste individual. Assim, :meth:"
"`~TestCase.setUp`, :meth:`~TestCase.tearDown` e :meth:`~TestCase.__init__` "
"serão chamados uma vez por teste."

#: ../../library/unittest.rst:443
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Recomenda-se que utilize implementações de TestCase para agrupar testes de "
"acordo com as funcionalidades que testam. O :mod:`unittest` fornece um "
"mecanismo para isso: o :dfn:`conjunto de testes`, representado pela classe :"
"class:`TestSuite` do :mod:`unittest`. Na maioria dos casos, chamar :func:"
"`unittest.main` fará o correto e recolherá todos os casos de teste do módulo "
"para si e executá-los-á."

#: ../../library/unittest.rst:450
msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"No entanto, se quiser personalizar a construção do seu conjunto de testes, "
"pode fazê-lo você mesmo::"

#: ../../library/unittest.rst:463
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Pode colocar as definições de casos de teste e conjuntos de teste nos mesmos "
"módulos que o código que pretendem testar (como :file:`widget.py`), mas há "
"várias vantagens em colocar o código de teste num módulo separado, como :"
"file:`test_widget.py`:"

#: ../../library/unittest.rst:468
msgid "The test module can be run standalone from the command line."
msgstr ""
"O módulo de teste pode ser executado autonomamente a partir da linha de "
"comandos."

#: ../../library/unittest.rst:470
msgid "The test code can more easily be separated from shipped code."
msgstr ""
"O código de teste pode ser mais facilmente separado do código distribuído."

#: ../../library/unittest.rst:472
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Há menos tentação para alterar o código de teste para se ajustar ao código "
"que testa sem uma boa razão."

#: ../../library/unittest.rst:475
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""
"O código de teste deve ser modificado muito menos frequentemente do que o "
"código que testa."

#: ../../library/unittest.rst:477
msgid "Tested code can be refactored more easily."
msgstr "O código testado pode ser refatorado mais facilmente."

#: ../../library/unittest.rst:479
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Os testes para módulos escritos em C devem estar em módulos separados de "
"qualquer forma, então por que não ser consistente?"

#: ../../library/unittest.rst:482
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Se a estratégia de teste mudar, não há necessidade de alterar o código-fonte."

#: ../../library/unittest.rst:488
msgid "Re-using old test code"
msgstr "Reutilização de código de teste antigo"

#: ../../library/unittest.rst:490
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Alguns utilizadores descobrirão que têm código de teste existente que "
"gostariam de executar a partir do :mod:`unittest`, sem converter cada função "
"de teste antiga para uma subclasse de :class:`TestCase`."

#: ../../library/unittest.rst:494
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Por esta razão, o :mod:`unittest` fornece uma classe :class:"
"`FunctionTestCase`. Esta subclasse de :class:`TestCase` pode ser usada para "
"encapsular uma função de teste existente. Também podem ser fornecidas "
"funções de configuração e limpeza."

#: ../../library/unittest.rst:498
msgid "Given the following test function::"
msgstr "Dada a seguinte função de teste::"

#: ../../library/unittest.rst:505
msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"pode-se criar uma instância de caso de teste equivalente da seguinte forma, "
"com métodos opcionais de configuração e limpeza::"

#: ../../library/unittest.rst:514
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Embora a :class:`FunctionTestCase` possa ser usada para converter "
"rapidamente uma base de testes existente para um sistema baseado em :mod:"
"`unittest`, esta abordagem não é recomendada. Dedicar tempo a configurar "
"subclasses adequadas de :class:`TestCase` tornará as refatorações futuras de "
"testes infinitamente mais fáceis."

#: ../../library/unittest.rst:519
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"Em alguns casos, os testes existentes podem ter sido escritos usando o "
"módulo :mod:`doctest`. Se for o caso, o :mod:`doctest` fornece uma classe :"
"class:`DocTestSuite` que pode construir automaticamente instâncias de :class:"
"`unittest.TestSuite` a partir dos testes existentes baseados em :mod:"
"`doctest`."

#: ../../library/unittest.rst:528
msgid "Skipping tests and expected failures"
msgstr "Ignorar testes e falhas esperadas"

#: ../../library/unittest.rst:532
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"O Unittest suporta ignorar métodos de teste individuais e até classes "
"inteiras de testes. Além disso, suporta marcar um teste como uma \"falha "
"esperada\", um teste que está quebrado e falhará, mas não deve ser contado "
"como uma falha num :class:`TestResult`."

#: ../../library/unittest.rst:537
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Ignorar um teste é simplesmente uma questão de usar o decorador :func:`skip` "
"ou uma das suas variantes condicionais, chamando :meth:`TestCase.skipTest` "
"dentro de um método :meth:`~TestCase.setUp` ou de teste, ou levantando "
"diretamente :exc:`SkipTest`."

#: ../../library/unittest.rst:541
msgid "Basic skipping looks like this::"
msgstr "A ignorância básica parece-se com isto::"

#: ../../library/unittest.rst:566
msgid "This is the output of running the example above in verbose mode::"
msgstr "Esta é a saída da execução do exemplo acima em modo detalhado::"

#: ../../library/unittest.rst:578
msgid "Classes can be skipped just like methods::"
msgstr "As classes podem ser ignoradas da mesma forma que os métodos::"

#: ../../library/unittest.rst:585
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` também pode ignorar o teste. Isto é útil quando um "
"recurso que precisa de ser configurado não está disponível."

#: ../../library/unittest.rst:588
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "As falhas esperadas usam o decorador :func:`expectedFailure`. ::"

#: ../../library/unittest.rst:595
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"É fácil criar os seus próprios decoradores de ignorância, fazendo um "
"decorador que chama :func:`skip` no teste quando quiser que seja ignorado. "
"Este decorador ignora o teste a menos que o objeto passado tenha um certo "
"atributo::"

#: ../../library/unittest.rst:604
msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Os seguintes decoradores e exceções implementam a ignorância de testes e "
"falhas esperadas:"

#: ../../library/unittest.rst:608
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Ignorar incondicionalmente o teste decorado. *reason* deve descrever por que "
"o teste está a ser ignorado."

#: ../../library/unittest.rst:613
msgid "Skip the decorated test if *condition* is true."
msgstr "Ignorar o teste decorado se *condition* for verdadeiro."

#: ../../library/unittest.rst:617
msgid "Skip the decorated test unless *condition* is true."
msgstr "Ignorar o teste decorado a menos que *condition* seja verdadeiro."

#: ../../library/unittest.rst:621
msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Marcar o teste como uma falha ou erro esperado. Se o teste falhar ou gerar "
"erros na própria função de teste (em vez de nos métodos de :dfn:`ambiente de "
"teste`), então será considerado um sucesso. Se o teste passar, será "
"considerado uma falha."

#: ../../library/unittest.rst:628
msgid "This exception is raised to skip a test."
msgstr "Esta exceção é levantada para ignorar um teste."

#: ../../library/unittest.rst:630
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Normalmente, pode usar :meth:`TestCase.skipTest` ou um dos decoradores de "
"ignorância em vez de levantar isto diretamente."

#: ../../library/unittest.rst:633
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Os testes ignorados não terão :meth:`~TestCase.setUp` ou :meth:`~TestCase."
"tearDown` executados à sua volta. As classes ignoradas não terão :meth:"
"`~TestCase.setUpClass` ou :meth:`~TestCase.tearDownClass` executados. Os "
"módulos ignorados não terão :func:`setUpModule` ou :func:`tearDownModule` "
"executados."

#: ../../library/unittest.rst:641
msgid "Distinguishing test iterations using subtests"
msgstr "Diferenciar iterações de teste usando subtests"

#: ../../library/unittest.rst:645
msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Quando há diferenças muito pequenas entre os seus testes, por exemplo alguns "
"parâmetros, o unittest permite-lhe distingui-los dentro do corpo de um "
"método de teste usando o gestor de contexto :meth:`~TestCase.subTest`."

#: ../../library/unittest.rst:649
msgid "For example, the following test::"
msgstr ""

#: ../../library/unittest.rst:661
msgid "will produce the following output::"
msgstr "produzirá a seguinte saída::"

#: ../../library/unittest.rst:693
msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Sem usar um subteste, a execução pararia após a primeira falha, e o erro "
"seria mais difícil de diagnosticar porque o valor de ``i`` não seria "
"exibido::"

#: ../../library/unittest.rst:709
msgid "Classes and functions"
msgstr "Classes e funções"

#: ../../library/unittest.rst:711
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "Esta secção descreve em detalhe a API do :mod:`unittest`."

#: ../../library/unittest.rst:717
msgid "Test cases"
msgstr "Casos de teste"

#: ../../library/unittest.rst:721
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"As instâncias da classe :class:`TestCase` representam as unidades lógicas de "
"teste no universo :mod:`unittest`. Esta classe destina-se a ser usada como "
"uma classe base, com testes específicos implementados por subclasses "
"concretas. Esta classe implementa a interface necessária pelo executor de "
"testes para permitir que ele conduza os testes, e métodos que o código de "
"teste pode usar para verificar e reportar vários tipos de falhas."

#: ../../library/unittest.rst:728
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Cada instância de :class:`TestCase` executará um único método base: o método "
"chamado *methodName*. Na maioria dos usos de :class:`TestCase`, não alterará "
"o *methodName* nem reimplementará o método predefinido ``runTest()``."

#: ../../library/unittest.rst:733
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
"A classe :class:`TestCase` pode ser instanciada com sucesso sem fornecer um "
"*methodName*. Isto torna mais fácil experimentar com :class:`TestCase` a "
"partir do interpretador interativo."

#: ../../library/unittest.rst:738
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"As instâncias de :class:`TestCase` fornecem três grupos de métodos: um grupo "
"usado para executar o teste, outro usado pela implementação do teste para "
"verificar condições e reportar falhas, e alguns métodos de consulta que "
"permitem recolher informações sobre o próprio teste."

#: ../../library/unittest.rst:743
msgid "Methods in the first group (running the test) are:"
msgstr "Os métodos do primeiro grupo (execução do teste) são:"

#: ../../library/unittest.rst:747
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Método chamado para preparar o ambiente de teste. Isto é chamado "
"imediatamente antes de chamar o método de teste; qualquer exceção levantada "
"por este método, exceto :exc:`AssertionError` ou :exc:`SkipTest`, será "
"considerada um erro em vez de uma falha de teste. A implementação "
"predefinida não faz nada."

#: ../../library/unittest.rst:755
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Método chamado imediatamente após o método de teste ter sido chamado e o "
"resultado registado. Isto é chamado mesmo que o método de teste tenha "
"levantado uma exceção, pelo que a implementação em subclasses pode precisar "
"de ser particularmente cuidadosa ao verificar o estado interno. Qualquer "
"exceção, exceto :exc:`AssertionError` ou :exc:`SkipTest`, levantada por este "
"método será considerada um erro adicional em vez de uma falha de teste "
"(aumentando assim o número total de erros reportados). Este método só será "
"chamado se o :meth:`setUp` tiver sucesso, independentemente do resultado do "
"método de teste. A implementação predefinida não faz nada."

#: ../../library/unittest.rst:768
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"Um método de classe chamado antes dos testes numa classe individual serem "
"executados. ``setUpClass`` é chamado com a classe como único argumento e "
"deve ser decorado como um :func:`classmethod`::"

#: ../../library/unittest.rst:776 ../../library/unittest.rst:791
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Consulte `Fixtures de Classe e Módulo`_ para mais detalhes."

#: ../../library/unittest.rst:783
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Um método de classe chamado após os testes numa classe individual terem sido "
"executados. ``tearDownClass`` é chamado com a classe como único argumento e "
"deve ser decorado como um :meth:`classmethod`::"

#: ../../library/unittest.rst:798
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Executa o teste, recolhendo o resultado no objeto :class:`TestResult` "
"passado como *result*. Se *result* for omitido ou ``None``, um objeto de "
"resultado temporário é criado (chamando o método :meth:`defaultTestResult`) "
"e usado. O objeto de resultado é retornado ao chamador de :meth:`run`."

#: ../../library/unittest.rst:804
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"O mesmo efeito pode ser obtido simplesmente chamando a instância :class:"
"`TestCase`."

#: ../../library/unittest.rst:807
msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Versões anteriores de ``run`` não retornavam o resultado. Chamar uma "
"instância também não retornava."

#: ../../library/unittest.rst:813
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Chamar isto durante um método de teste ou :meth:`setUp` ignora o teste "
"atual. Consulte :ref:`unittest-skipping` para mais informações."

#: ../../library/unittest.rst:821
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Retorna um gestor de contexto que executa o bloco de código incluído como um "
"subteste. *msg* e *params* são valores opcionais e arbitrários que são "
"exibidos sempre que um subteste falha, permitindo-lhe identificá-los "
"claramente."

#: ../../library/unittest.rst:826
msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Um caso de teste pode conter qualquer número de declarações de subteste, e "
"estas podem ser arbitrariamente aninhadas."

#: ../../library/unittest.rst:829
msgid "See :ref:`subtests` for more information."
msgstr "Consulte :ref:`subtests` para mais informações."

#: ../../library/unittest.rst:836
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Executa o teste sem recolher o resultado. Isto permite que as exceções "
"levantadas pelo teste sejam propagadas para o chamador, e pode ser usado "
"para suportar a execução de testes sob um depurador."

#: ../../library/unittest.rst:842
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"A classe :class:`TestCase` fornece vários métodos assert para verificar e "
"reportar falhas. A tabela seguinte lista os métodos mais comumente usados "
"(consulte as tabelas abaixo para mais métodos assert):"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182 ../../library/unittest.rst:1309
msgid "Method"
msgstr "Método"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182
msgid "Checks that"
msgstr "Verifica que"

#: ../../library/unittest.rst:847 ../../library/unittest.rst:968
#: ../../library/unittest.rst:1182 ../../library/unittest.rst:1309
msgid "New in"
msgstr "Novo em"

#: ../../library/unittest.rst:849
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../../library/unittest.rst:849
msgid "``a == b``"
msgstr "``a == b``"

#: ../../library/unittest.rst:852
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../../library/unittest.rst:852
msgid "``a != b``"
msgstr "``a != b``"

#: ../../library/unittest.rst:855
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../../library/unittest.rst:855
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../../library/unittest.rst:858
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../../library/unittest.rst:858
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../../library/unittest.rst:861
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../../library/unittest.rst:861
msgid "``a is b``"
msgstr "``a is b``"

#: ../../library/unittest.rst:861 ../../library/unittest.rst:864
#: ../../library/unittest.rst:867 ../../library/unittest.rst:870
#: ../../library/unittest.rst:873 ../../library/unittest.rst:876
#: ../../library/unittest.rst:973 ../../library/unittest.rst:1190
#: ../../library/unittest.rst:1193 ../../library/unittest.rst:1196
#: ../../library/unittest.rst:1199 ../../library/unittest.rst:1202
#: ../../library/unittest.rst:1311 ../../library/unittest.rst:1314
#: ../../library/unittest.rst:1317 ../../library/unittest.rst:1320
#: ../../library/unittest.rst:1323 ../../library/unittest.rst:1326
msgid "3.1"
msgstr "3.1"

#: ../../library/unittest.rst:864
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../../library/unittest.rst:864
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../../library/unittest.rst:867
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../../library/unittest.rst:867
msgid "``x is None``"
msgstr "``x is None``"

#: ../../library/unittest.rst:870
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../../library/unittest.rst:870
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../../library/unittest.rst:873
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../../library/unittest.rst:873
msgid "``a in b``"
msgstr "``a in b``"

#: ../../library/unittest.rst:876
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../../library/unittest.rst:876
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../../library/unittest.rst:879
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../../library/unittest.rst:879
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../../library/unittest.rst:879 ../../library/unittest.rst:882
#: ../../library/unittest.rst:976 ../../library/unittest.rst:979
#: ../../library/unittest.rst:1205 ../../library/unittest.rst:1208
msgid "3.2"
msgstr "3.2"

#: ../../library/unittest.rst:882
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../../library/unittest.rst:882
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../../library/unittest.rst:886
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Todos os métodos assert aceitam um argumento *msg* que, se especificado, é "
"usado como mensagem de erro em caso de falha (consulte também :data:"
"`longMessage`). Note que o argumento de palavra-chave *msg* pode ser passado "
"para :meth:`assertRaises`, :meth:`assertRaisesRegex`, :meth:`assertWarns`, :"
"meth:`assertWarnsRegex` apenas quando são usados como um gestor de contexto."

#: ../../library/unittest.rst:894
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Testa se *first* e *second* são iguais. Se os valores não forem iguais, o "
"teste falhará."

#: ../../library/unittest.rst:897
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Além disso, se *first* e *second* forem exatamente do mesmo tipo e um de "
"list, tuple, dict, set, frozenset ou str ou qualquer tipo que uma subclasse "
"registe com :meth:`addTypeEqualityFunc`, a função de igualdade específica do "
"tipo será chamada para gerar uma mensagem de erro predefinida mais útil "
"(consulte também a :ref:`lista de métodos específicos do tipo <type-specific-"
"methods>`)."

#: ../../library/unittest.rst:904
msgid "Added the automatic calling of type-specific equality function."
msgstr ""
"Adicionada a chamada automática da função de igualdade específica do tipo."

#: ../../library/unittest.rst:907
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` adicionado como a função de igualdade de tipo "
"predefinida para comparar strings."

#: ../../library/unittest.rst:914
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Testa se *first* e *second* não são iguais. Se os valores forem iguais, o "
"teste falhará."

#: ../../library/unittest.rst:920
msgid "Test that *expr* is true (or false)."
msgstr "Testa se *expr* é verdadeiro (ou falso)."

#: ../../library/unittest.rst:922
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Note que isto é equivalente a ``bool(expr) is True`` e não a ``expr is "
"True`` (use ``assertIs(expr, True)`` para o último). Este método também deve "
"ser evitado quando métodos mais específicos estão disponíveis (por exemplo, "
"``assertEqual(a, b)`` em vez de ``assertTrue(a == b)``), porque fornecem uma "
"mensagem de erro melhor em caso de falha."

#: ../../library/unittest.rst:932
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "Testa se *first* e *second* são (ou não são) o mesmo objeto."

#: ../../library/unittest.rst:940
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Testa se *expr* é (ou não é) ``None``."

#: ../../library/unittest.rst:948
msgid "Test that *member* is (or is not) in *container*."
msgstr "Testa se *member* está (ou não está) em *container*."

#: ../../library/unittest.rst:956
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Testa se *obj* é (ou não é) uma instância de *cls* (que pode ser uma classe "
"ou um tuplo de classes, como suportado por :func:`isinstance`). Para "
"verificar o tipo exato, use :func:`assertIs(type(obj), cls) <assertIs>`."

#: ../../library/unittest.rst:964
msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Também é possível verificar a produção de exceções, avisos e mensagens de "
"registo usando os seguintes métodos:"

#: ../../library/unittest.rst:970
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../../library/unittest.rst:970
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` levanta *exc*"

#: ../../library/unittest.rst:973
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

#: ../../library/unittest.rst:973
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` levanta *exc* e a mensagem corresponde à regex *r*"

#: ../../library/unittest.rst:976
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../../library/unittest.rst:976
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` levanta *warn*"

#: ../../library/unittest.rst:979
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

#: ../../library/unittest.rst:979
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` levanta *warn* e a mensagem corresponde à regex *r*"

#: ../../library/unittest.rst:982
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../../library/unittest.rst:982
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "O bloco ``with`` regista em *logger* com nível mínimo *level*"

#: ../../library/unittest.rst:982
msgid "3.4"
msgstr "3.4"

#: ../../library/unittest.rst:985
msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"

#: ../../library/unittest.rst:985
msgid "The ``with`` block does not log on"
msgstr "O bloco ``with`` não regista em"

#: ../../library/unittest.rst:986
msgid "*logger* with minimum *level*"
msgstr "*logger* com nível mínimo *level*"

#: ../../library/unittest.rst:985
msgid "3.10"
msgstr "3.10"

#: ../../library/unittest.rst:992
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Testa se uma exceção é levantada quando *callable* é chamado com quaisquer "
"argumentos posicionais ou de palavra-chave que também são passados para :"
"meth:`assertRaises`. O teste passa se *exception* for levantada, é um erro "
"se outra exceção for levantada, ou falha se nenhuma exceção for levantada. "
"Para capturar qualquer exceção de um grupo, um tuplo contendo as classes de "
"exceção pode ser passado como *exception*."

#: ../../library/unittest.rst:999
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Se apenas os argumentos *exception* e possivelmente *msg* forem fornecidos, "
"retorna um gestor de contexto para que o código a ser testado possa ser "
"escrito em linha em vez de como uma função::"

#: ../../library/unittest.rst:1006
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"Quando usado como um gestor de contexto, :meth:`assertRaises` aceita o "
"argumento de palavra-chave adicional *msg*."

#: ../../library/unittest.rst:1009
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"O gestor de contexto armazenará o objeto de exceção capturado no seu "
"atributo :attr:`exception`. Isto pode ser útil se a intenção for realizar "
"verificações adicionais na exceção levantada::"

#: ../../library/unittest.rst:1019
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Adicionada a capacidade de usar :meth:`assertRaises` como um gestor de "
"contexto."

#: ../../library/unittest.rst:1022
msgid "Added the :attr:`exception` attribute."
msgstr "Adicionado o atributo :attr:`exception`."

#: ../../library/unittest.rst:1025 ../../library/unittest.rst:1051
#: ../../library/unittest.rst:1092 ../../library/unittest.rst:1115
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Adicionado o argumento de palavra-chave *msg* quando usado como um gestor de "
"contexto."

#: ../../library/unittest.rst:1032
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Semelhante a :meth:`assertRaises`, mas também testa se *regex* corresponde à "
"representação em string da exceção levantada. *regex* pode ser um objeto de "
"expressão regular ou uma string contendo uma expressão regular adequada para "
"uso por :func:`re.search`. Exemplos::"

#: ../../library/unittest.rst:1040 ../../library/unittest.rst:1108
msgid "or::"
msgstr "ou:"

#: ../../library/unittest.rst:1045
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Adicionado com o nome ``assertRaisesRegexp``."

#: ../../library/unittest.rst:1048
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Renomeado para :meth:`assertRaisesRegex`."

#: ../../library/unittest.rst:1058
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"Testa se um aviso é acionado quando *callable* é chamado com quaisquer "
"argumentos posicionais ou de palavra-chave que também são passados para :"
"meth:`assertWarns`. O teste passa se *warning* for acionado e falha se não "
"for. Qualquer exceção é um erro. Para capturar qualquer aviso de um grupo, "
"um tuplo contendo as classes de aviso pode ser passado como *warnings*."

#: ../../library/unittest.rst:1065
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Se apenas os argumentos *warning* e possivelmente *msg* forem fornecidos, "
"retorna um gestor de contexto para que o código a ser testado possa ser "
"escrito em linha em vez de como uma função::"

#: ../../library/unittest.rst:1072
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"Quando usado como um gestor de contexto, :meth:`assertWarns` aceita o "
"argumento de palavra-chave adicional *msg*."

#: ../../library/unittest.rst:1075
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"O gestor de contexto armazenará o objeto de aviso capturado no seu atributo :"
"attr:`warning`, e a linha de origem que acionou os avisos nos atributos :"
"attr:`filename` e :attr:`lineno`. Isto pode ser útil se a intenção for "
"realizar verificações adicionais no aviso capturado::"

#: ../../library/unittest.rst:1087
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Este método funciona independentemente dos filtros de aviso em vigor quando "
"é chamado."

#: ../../library/unittest.rst:1099
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"Semelhante a :meth:`assertWarns`, mas também testa se *regex* corresponde à "
"mensagem do aviso acionado. *regex* pode ser um objeto de expressão regular "
"ou uma string contendo uma expressão regular adequada para uso por :func:`re."
"search`. Exemplo::"

#: ../../library/unittest.rst:1120
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"Um gestor de contexto para testar que pelo menos uma mensagem é registada no "
"*logger* ou num dos seus filhos, com pelo menos o nível *level* dado."

#: ../../library/unittest.rst:1124
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Se fornecido, *logger* deve ser um objeto :class:`logging.Logger` ou uma :"
"class:`str` que dá o nome de um logger. O predefinido é o logger raiz, que "
"capturará todas as mensagens que não foram bloqueadas por um logger "
"descendente não propagante."

#: ../../library/unittest.rst:1129 ../../library/unittest.rst:1170
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :const:`logging.ERROR`).  "
"The default is :const:`logging.INFO`."
msgstr ""
"Se fornecido, *level* deve ser um nível de registo numérico ou o seu "
"equivalente em string (por exemplo, ``\"ERROR\"`` ou :const:`logging."
"ERROR`). O predefinido é :const:`logging.INFO`."

#: ../../library/unittest.rst:1133
msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"O teste passa se pelo menos uma mensagem emitida dentro do bloco ``with`` "
"corresponder às condições *logger* e *level*, caso contrário falha."

#: ../../library/unittest.rst:1136
msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"O objeto retornado pelo gestor de contexto é um auxiliar de gravação que "
"mantém o registo das mensagens de registo correspondentes. Tem dois "
"atributos:"

#: ../../library/unittest.rst:1142
msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"Uma lista de objetos :class:`logging.LogRecord` das mensagens de registo "
"correspondentes."

#: ../../library/unittest.rst:1147
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"Uma lista de objetos :class:`str` com a saída formatada das mensagens "
"correspondentes."

#: ../../library/unittest.rst:1150
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/unittest.rst:1162
msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""
"Um gestor de contexto para testar que nenhuma mensagem é registada no "
"*logger* ou num dos seus filhos, com pelo menos o nível *level* dado."

#: ../../library/unittest.rst:1166
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"Se fornecido, *logger* deve ser um objeto :class:`logging.Logger` ou uma :"
"class:`str` que dá o nome de um logger. O predefinido é o logger raiz, que "
"capturará todas as mensagens."

#: ../../library/unittest.rst:1174
msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"Ao contrário de :meth:`assertLogs`, nada será retornado pelo gestor de "
"contexto."

#: ../../library/unittest.rst:1179
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Existem também outros métodos usados para realizar verificações mais "
"específicas, tais como:"

#: ../../library/unittest.rst:1184
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../../library/unittest.rst:1184
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../../library/unittest.rst:1187
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../../library/unittest.rst:1187
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../../library/unittest.rst:1190
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../../library/unittest.rst:1190
msgid "``a > b``"
msgstr "``a > b``"

#: ../../library/unittest.rst:1193
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../../library/unittest.rst:1193
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../../library/unittest.rst:1196
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../../library/unittest.rst:1196
msgid "``a < b``"
msgstr "``a < b``"

#: ../../library/unittest.rst:1199
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../../library/unittest.rst:1199
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../../library/unittest.rst:1202
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../../library/unittest.rst:1202
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../../library/unittest.rst:1205
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../../library/unittest.rst:1205
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../../library/unittest.rst:1208
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../../library/unittest.rst:1208
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* e *b* têm os mesmos elementos no mesmo número, independentemente da sua "
"ordem."

#: ../../library/unittest.rst:1217
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Testa se *first* e *second* são aproximadamente (ou não aproximadamente) "
"iguais, calculando a diferença, arredondando para o número dado de casas "
"decimais *places* (predefinido 7), e comparando com zero. Note que estes "
"métodos arredondam os valores para o número dado de *casas decimais* (ou "
"seja, como a função :func:`round`) e não *dígitos significativos*."

#: ../../library/unittest.rst:1223
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Se *delta* for fornecido em vez de *places*, então a diferença entre *first* "
"e *second* deve ser menor ou igual a (ou maior que) *delta*."

#: ../../library/unittest.rst:1226
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "Fornecer ambos *delta* e *places* levanta um :exc:`TypeError`."

#: ../../library/unittest.rst:1228
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` considera automaticamente objetos quase iguais que "
"comparam igual. :meth:`assertNotAlmostEqual` falha automaticamente se os "
"objetos compararem igual. Adicionado o argumento de palavra-chave *delta*."

#: ../../library/unittest.rst:1239
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Testa se *first* é respetivamente >, >=, < ou <= que *second*, dependendo do "
"nome do método. Se não, o teste falhará::"

#: ../../library/unittest.rst:1251
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Testa se uma pesquisa *regex* corresponde (ou não corresponde) a *text*. Em "
"caso de falha, a mensagem de erro incluirá o padrão e o *text* (ou o padrão "
"e a parte do *text* que correspondia inesperadamente). *regex* pode ser um "
"objeto de expressão regular ou uma string contendo uma expressão regular "
"adequada para uso por :func:`re.search`."

#: ../../library/unittest.rst:1257
msgid "Added under the name ``assertRegexpMatches``."
msgstr "Adicionado com o nome ``assertRegexpMatches``."

#: ../../library/unittest.rst:1259
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"O método ``assertRegexpMatches()`` foi renomeado para :meth:`.assertRegex`."

#: ../../library/unittest.rst:1262
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../../library/unittest.rst:1264
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr ""

#: ../../library/unittest.rst:1271
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Testa se a sequência *first* contém os mesmos elementos que *second*, "
"independentemente da sua ordem. Quando não contiverem, será gerada uma "
"mensagem de erro listando as diferenças entre as sequências."

#: ../../library/unittest.rst:1275
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Elementos duplicados *não* são ignorados ao comparar *first* e *second*. "
"Verifica se cada elemento tem a mesma contagem em ambas as sequências. "
"Equivalente a: ``assertEqual(Counter(list(first)), Counter(list(second)))``, "
"mas também funciona com sequências de objetos não hashable."

#: ../../library/unittest.rst:1286
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"O método :meth:`assertEqual` despacha a verificação de igualdade para "
"objetos do mesmo tipo para diferentes métodos específicos do tipo. Estes "
"métodos já estão implementados para a maioria dos tipos integrados, mas "
"também é possível registar novos métodos usando :meth:`addTypeEqualityFunc`:"

#: ../../library/unittest.rst:1293
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Regista um método específico do tipo chamado por :meth:`assertEqual` para "
"verificar se dois objetos exatamente do mesmo *typeobj* (não subclasses) "
"comparam igual. *function* deve aceitar dois argumentos posicionais e um "
"terceiro argumento de palavra-chave msg=None, tal como :meth:`assertEqual`. "
"Deve levantar :data:`self.failureException(msg) <failureException>` quando "
"for detetada desigualdade entre os dois primeiros parâmetros — possivelmente "
"fornecendo informações úteis e explicando as desigualdades em detalhe na "
"mensagem de erro."

#: ../../library/unittest.rst:1304
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"A lista de métodos específicos do tipo usados automaticamente por :meth:"
"`~TestCase.assertEqual` está resumida na tabela seguinte. Note que "
"geralmente não é necessário invocar estes métodos diretamente."

#: ../../library/unittest.rst:1309
msgid "Used to compare"
msgstr "Usado para comparar"

#: ../../library/unittest.rst:1311
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../../library/unittest.rst:1311
msgid "strings"
msgstr "strings"

#: ../../library/unittest.rst:1314
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../../library/unittest.rst:1314
msgid "sequences"
msgstr "sequências"

#: ../../library/unittest.rst:1317
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../../library/unittest.rst:1317
msgid "lists"
msgstr "listas"

#: ../../library/unittest.rst:1320
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../../library/unittest.rst:1320
msgid "tuples"
msgstr "tuplos"

#: ../../library/unittest.rst:1323
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../../library/unittest.rst:1323
msgid "sets or frozensets"
msgstr "conjuntos ou frozensets"

#: ../../library/unittest.rst:1326
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../../library/unittest.rst:1326
msgid "dicts"
msgstr "dicionários"

#: ../../library/unittest.rst:1334
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Testa se a string multilinhas *first* é igual à string *second*. Quando não "
"forem iguais, um diff das duas strings, destacando as diferenças, será "
"incluído na mensagem de erro. Este método é usado por predefinição ao "
"comparar strings com :meth:`assertEqual`."

#: ../../library/unittest.rst:1344
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"Testa se duas sequências são iguais. Se um *seq_type* for fornecido, tanto "
"*first* como *second* devem ser instâncias de *seq_type* ou uma falha será "
"levantada. Se as sequências forem diferentes, uma mensagem de erro é "
"construída mostrando a diferença entre as duas."

#: ../../library/unittest.rst:1349
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Este método não é chamado diretamente por :meth:`assertEqual`, mas é usado "
"para implementar :meth:`assertListEqual` e :meth:`assertTupleEqual`."

#: ../../library/unittest.rst:1359
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Testa se duas listas ou tuplos são iguais. Se não forem, uma mensagem de "
"erro é construída mostrando apenas as diferenças entre as duas. Um erro "
"também é levantado se algum dos parâmetros for do tipo errado. Estes métodos "
"são usados por predefinição ao comparar listas ou tuplos com :meth:"
"`assertEqual`."

#: ../../library/unittest.rst:1370
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Testa se dois conjuntos são iguais. Se não forem, uma mensagem de erro é "
"construída listando as diferenças entre os conjuntos. Este método é usado "
"por predefinição ao comparar conjuntos ou frozensets com :meth:`assertEqual`."

#: ../../library/unittest.rst:1374
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"Falha se *first* ou *second* não tiverem um método :meth:`set.difference`."

#: ../../library/unittest.rst:1382
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Testa se dois dicionários são iguais. Se não forem, uma mensagem de erro é "
"construída mostrando as diferenças nos dicionários. Este método será usado "
"por predefinição para comparar dicionários em chamadas a :meth:`assertEqual`."

#: ../../library/unittest.rst:1393
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""
"Finalmente, a classe :class:`TestCase` fornece os seguintes métodos e "
"atributos:"

#: ../../library/unittest.rst:1398
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Sinaliza uma falha de teste incondicionalmente, com *msg* ou ``None`` para a "
"mensagem de erro."

#: ../../library/unittest.rst:1404
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Este atributo de classe indica a exceção levantada pelo método de teste. Se "
"uma estrutura de teste precisar de usar uma exceção especializada, "
"possivelmente para transportar informações adicionais, deve criar uma "
"subclasse desta exceção para \"jogar limpo\" com a estrutura. O valor "
"inicial deste atributo é :exc:`AssertionError`."

#: ../../library/unittest.rst:1413
msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Este atributo de classe determina o que acontece quando uma mensagem de "
"falha personalizada é passada como argumento msg para uma chamada assertXYY "
"que falha. ``True`` é o valor predefinido. Neste caso, a mensagem "
"personalizada é anexada ao final da mensagem de falha padrão. Quando "
"definido como ``False``, a mensagem personalizada substitui a mensagem "
"padrão."

#: ../../library/unittest.rst:1419
msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"A configuração da classe pode ser substituída em métodos de teste "
"individuais atribuindo um atributo de instância, self.longMessage, a "
"``True`` ou ``False`` antes de chamar os métodos assert."

#: ../../library/unittest.rst:1423
msgid "The class setting gets reset before each test call."
msgstr "A configuração da classe é redefinida antes de cada chamada de teste."

#: ../../library/unittest.rst:1430
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Este atributo controla o comprimento máximo dos diffs produzidos pelos "
"métodos assert que reportam diffs em caso de falha. O valor predefinido é "
"80*8 caracteres. Os métodos assert afetados por este atributo são :meth:"
"`assertSequenceEqual` (incluindo todos os métodos de comparação de "
"sequências que delegam nele), :meth:`assertDictEqual` e :meth:"
"`assertMultiLineEqual`."

#: ../../library/unittest.rst:1437
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Definir ``maxDiff`` para ``None`` significa que não há comprimento máximo "
"para os diffs."

#: ../../library/unittest.rst:1443
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"As estruturas de teste podem usar os seguintes métodos para recolher "
"informações sobre o teste:"

#: ../../library/unittest.rst:1449
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Retorna o número de testes representados por este objeto de teste. Para "
"instâncias de :class:`TestCase`, isto será sempre ``1``."

#: ../../library/unittest.rst:1455
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Retorna uma instância da classe de resultado de teste que deve ser usada "
"para esta classe de caso de teste (se nenhuma outra instância de resultado "
"for fornecida ao método :meth:`run`)."

#: ../../library/unittest.rst:1459
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"Para instâncias de :class:`TestCase`, isto será sempre uma instância de :"
"class:`TestResult`; subclasses de :class:`TestCase` devem substituir isto "
"conforme necessário."

#: ../../library/unittest.rst:1466
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Retorna uma string que identifica o caso de teste específico. Isto é "
"geralmente o nome completo do método de teste, incluindo o nome do módulo e "
"da classe."

#: ../../library/unittest.rst:1472
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Retorna uma descrição do teste, ou ``None`` se nenhuma descrição tiver sido "
"fornecida. A implementação predefinida deste método retorna a primeira linha "
"da docstring do método de teste, se disponível, ou ``None``."

#: ../../library/unittest.rst:1477
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"Na versão 3.1, isto foi alterado para adicionar o nome do teste à descrição "
"curta, mesmo na presença de uma docstring. Isto causou problemas de "
"compatibilidade com extensões do unittest e a adição do nome do teste foi "
"movida para :class:`TextTestResult` no Python 3.2."

#: ../../library/unittest.rst:1486
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"Adiciona uma função a ser chamada após :meth:`tearDown` para limpar recursos "
"usados durante o teste. As funções serão chamadas em ordem inversa à ordem "
"em que foram adicionadas (:abbr:`LIFO (último a entrar, primeiro a sair)`). "
"São chamadas com quaisquer argumentos e argumentos de palavra-chave passados "
"para :meth:`addCleanup` quando são adicionadas."

#: ../../library/unittest.rst:1492
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Se :meth:`setUp` falhar, significando que :meth:`tearDown` não é chamado, "
"então quaisquer funções de limpeza adicionadas ainda serão chamadas."

#: ../../library/unittest.rst:1500
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""
"Entrar no :term:`gestor de contexto` fornecido. Se for bem-sucedido, também "
"adiciona o seu método :meth:`~object.__exit__` como uma função de limpeza "
"através de :meth:`addCleanup` e retorna o resultado do método :meth:`~object."
"__enter__`."

#: ../../library/unittest.rst:1510
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Este método é chamado incondicionalmente após :meth:`tearDown`, ou após :"
"meth:`setUp` se :meth:`setUp` levantar uma exceção."

#: ../../library/unittest.rst:1513
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"É responsável por chamar todas as funções de limpeza adicionadas por :meth:"
"`addCleanup`. Se precisar que as funções de limpeza sejam chamadas *antes* "
"de :meth:`tearDown`, pode chamar :meth:`doCleanups` você mesmo."

#: ../../library/unittest.rst:1518
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` remove métodos da pilha de funções de limpeza um de cada "
"vez, pelo que pode ser chamado a qualquer momento."

#: ../../library/unittest.rst:1526
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"Adiciona uma função a ser chamada após :meth:`tearDownClass` para limpar "
"recursos usados durante a classe de teste. As funções serão chamadas em "
"ordem inversa à ordem em que foram adicionadas (:abbr:`LIFO (último a "
"entrar, primeiro a sair)`). São chamadas com quaisquer argumentos e "
"argumentos de palavra-chave passados para :meth:`addClassCleanup` quando são "
"adicionadas."

#: ../../library/unittest.rst:1532
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Se :meth:`setUpClass` falhar, significando que :meth:`tearDownClass` não é "
"chamado, então quaisquer funções de limpeza adicionadas ainda serão chamadas."

#: ../../library/unittest.rst:1540
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Entrar no :term:`gestor de contexto` fornecido. Se for bem-sucedido, também "
"adiciona o seu método :meth:`~object.__exit__` como uma função de limpeza "
"através de :meth:`addClassCleanup` e retorna o resultado do método :meth:"
"`~object.__enter__`."

#: ../../library/unittest.rst:1550
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Este método é chamado incondicionalmente após :meth:`tearDownClass`, ou "
"após :meth:`setUpClass` se :meth:`setUpClass` levantar uma exceção."

#: ../../library/unittest.rst:1553
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"É responsável por chamar todas as funções de limpeza adicionadas por :meth:"
"`addClassCleanup`. Se precisar que as funções de limpeza sejam chamadas "
"*antes* de :meth:`tearDownClass`, pode chamar :meth:`doClassCleanups` você "
"mesmo."

#: ../../library/unittest.rst:1558
msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` remove métodos da pilha de funções de limpeza um de "
"cada vez, pelo que pode ser chamado a qualquer momento."

#: ../../library/unittest.rst:1566
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Esta classe fornece uma API semelhante a :class:`TestCase` e também aceita "
"corrotinas como funções de teste."

#: ../../library/unittest.rst:1573
msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"Método chamado para preparar o ambiente de teste. Isto é chamado após :meth:"
"`setUp`. Isto é chamado imediatamente antes de chamar o método de teste; "
"qualquer exceção levantada por este método, exceto :exc:`AssertionError` ou :"
"exc:`SkipTest`, será considerada um erro em vez de uma falha de teste. A "
"implementação predefinida não faz nada."

#: ../../library/unittest.rst:1581
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"Método chamado imediatamente após o método de teste ter sido chamado e o "
"resultado registado. Isto é chamado antes de :meth:`tearDown`. Isto é "
"chamado mesmo que o método de teste tenha levantado uma exceção, pelo que a "
"implementação em subclasses pode precisar de ser particularmente cuidadosa "
"ao verificar o estado interno. Qualquer exceção, exceto :exc:"
"`AssertionError` ou :exc:`SkipTest`, levantada por este método será "
"considerada um erro adicional em vez de uma falha de teste (aumentando assim "
"o número total de erros reportados). Este método só será chamado se :meth:"
"`asyncSetUp` tiver sucesso, independentemente do resultado do método de "
"teste. A implementação predefinida não faz nada."

#: ../../library/unittest.rst:1593
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Este método aceita uma corrotina que pode ser usada como uma função de "
"limpeza."

#: ../../library/unittest.rst:1597
msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""
"Entrar no :term:`gestor de contexto assíncrono` fornecido. Se for bem-"
"sucedido, também adiciona o seu método :meth:`~object.__aexit__` como uma "
"função de limpeza através de :meth:`addAsyncCleanup` e retorna o resultado "
"do método :meth:`~object.__aenter__`."

#: ../../library/unittest.rst:1607
msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"Configura um novo ciclo de eventos para executar o teste, recolhendo o "
"resultado no objeto :class:`TestResult` passado como *result*. Se *result* "
"for omitido ou ``None``, um objeto de resultado temporário é criado "
"(chamando o método :meth:`defaultTestResult`) e usado. O objeto de resultado "
"é retornado ao chamador de :meth:`run`. No final do teste, todas as tarefas "
"no ciclo de eventos são canceladas."

#: ../../library/unittest.rst:1615
msgid "An example illustrating the order::"
msgstr "Um exemplo ilustrando a ordem::"

#: ../../library/unittest.rst:1651
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"Após executar o teste, ``events`` conterá ``[\"setUp\", \"asyncSetUp\", "
"\"test_response\", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``."

#: ../../library/unittest.rst:1656
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Esta classe implementa a parte da interface :class:`TestCase` que permite ao "
"executor de testes conduzir o teste, mas não fornece os métodos que o código "
"de teste pode usar para verificar e reportar erros. Isto é usado para criar "
"casos de teste usando código de teste legado, permitindo que seja integrado "
"numa estrutura de teste baseada em :mod:`unittest`."

#: ../../library/unittest.rst:1666
msgid "Deprecated aliases"
msgstr "Aliases obsoletos"

#: ../../library/unittest.rst:1668
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""

#: ../../library/unittest.rst:1673
msgid "Method Name"
msgstr "Nome do método"

#: ../../library/unittest.rst:1673
msgid "Deprecated alias"
msgstr "Alias obsoleto"

#: ../../library/unittest.rst:1675
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../../library/unittest.rst:1675
msgid "failUnlessEqual"
msgstr ""

#: ../../library/unittest.rst:1675
msgid "assertEquals"
msgstr ""

#: ../../library/unittest.rst:1676
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../../library/unittest.rst:1676
msgid "failIfEqual"
msgstr ""

#: ../../library/unittest.rst:1676
msgid "assertNotEquals"
msgstr ""

#: ../../library/unittest.rst:1677
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../../library/unittest.rst:1677
msgid "failUnless"
msgstr ""

#: ../../library/unittest.rst:1677
msgid "assert\\_"
msgstr ""

#: ../../library/unittest.rst:1678
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../../library/unittest.rst:1678
msgid "failIf"
msgstr ""

#: ../../library/unittest.rst:1679
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../../library/unittest.rst:1679
msgid "failUnlessRaises"
msgstr ""

#: ../../library/unittest.rst:1680
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../../library/unittest.rst:1680
msgid "failUnlessAlmostEqual"
msgstr ""

#: ../../library/unittest.rst:1680
msgid "assertAlmostEquals"
msgstr ""

#: ../../library/unittest.rst:1681
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../../library/unittest.rst:1681
msgid "failIfAlmostEqual"
msgstr ""

#: ../../library/unittest.rst:1681
msgid "assertNotAlmostEquals"
msgstr ""

#: ../../library/unittest.rst:1682
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../../library/unittest.rst:1682
msgid "assertRegexpMatches"
msgstr ""

#: ../../library/unittest.rst:1683
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../../library/unittest.rst:1683
msgid "assertNotRegexpMatches"
msgstr ""

#: ../../library/unittest.rst:1684
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../../library/unittest.rst:1684
msgid "assertRaisesRegexp"
msgstr ""

#: ../../library/unittest.rst:1687
msgid "The fail* aliases listed in the second column have been deprecated."
msgstr ""

#: ../../library/unittest.rst:1689
msgid "The assert* aliases listed in the third column have been deprecated."
msgstr ""

#: ../../library/unittest.rst:1691
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""

#: ../../library/unittest.rst:1694
msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of :meth:`."
"assertNotRegex`."
msgstr ""

#: ../../library/unittest.rst:1700
msgid "Grouping tests"
msgstr "Agrupamento de testes"

#: ../../library/unittest.rst:1704
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Esta classe representa uma agregação de casos de teste individuais e "
"conjuntos de teste. A classe apresenta a interface necessária pelo executor "
"de testes para permitir que seja executada como qualquer outro caso de "
"teste. Executar uma instância de :class:`TestSuite` é o mesmo que iterar "
"sobre o conjunto, executando cada teste individualmente."

#: ../../library/unittest.rst:1709
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Se *tests* for fornecido, deve ser um iterável de casos de teste individuais "
"ou outros conjuntos de teste que serão usados para construir o conjunto "
"inicialmente. Métodos adicionais são fornecidos para adicionar casos de "
"teste e conjuntos à coleção mais tarde."

#: ../../library/unittest.rst:1713
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
"Os objetos :class:`TestSuite` comportam-se de forma muito semelhante aos "
"objetos :class:`TestCase`, exceto que não implementam realmente um teste. Em "
"vez disso, são usados para agregar testes em grupos de testes que devem ser "
"executados em conjunto. Alguns métodos adicionais estão disponíveis para "
"adicionar testes a instâncias de :class:`TestSuite`:"

#: ../../library/unittest.rst:1721
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Adiciona um :class:`TestCase` ou :class:`TestSuite` ao conjunto."

#: ../../library/unittest.rst:1726
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Adiciona todos os testes de um iterável de instâncias :class:`TestCase` e :"
"class:`TestSuite` a este conjunto de testes."

#: ../../library/unittest.rst:1729
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Isto é equivalente a iterar sobre *tests*, chamando :meth:`addTest` para "
"cada elemento."

#: ../../library/unittest.rst:1732
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""
":class:`TestSuite` partilha os seguintes métodos com :class:`TestCase`:"

#: ../../library/unittest.rst:1737
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Executa os testes associados a este conjunto, recolhendo o resultado no "
"objeto de resultado de teste passado como *result*. Note que, ao contrário "
"de :meth:`TestCase.run`, :meth:`TestSuite.run` requer que o objeto de "
"resultado seja passado."

#: ../../library/unittest.rst:1745
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Executa os testes associados a este conjunto sem recolher o resultado. Isto "
"permite que exceções levantadas pelo teste sejam propagadas ao chamador e "
"pode ser usado para suportar a execução de testes sob um depurador."

#: ../../library/unittest.rst:1752
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Retorna o número de testes representados por este objeto de teste, incluindo "
"todos os testes individuais e subconjuntos."

#: ../../library/unittest.rst:1758
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`!__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"Os testes agrupados por um :class:`TestSuite` são sempre acedidos por "
"iteração. As subclasses podem fornecer testes de forma preguiçosa "
"substituindo :meth:`!__iter__`. Note que este método pode ser chamado várias "
"vezes num único conjunto (por exemplo, ao contar testes ou comparar para "
"igualdade), pelo que os testes retornados por iterações repetidas antes de :"
"meth:`TestSuite.run` devem ser os mesmos para cada iteração de chamada. "
"Após :meth:`TestSuite.run`, os chamadores não devem confiar nos testes "
"retornados por este método, a menos que o chamador use uma subclasse que "
"substitua :meth:`TestSuite._removeTestAtIndex` para preservar referências de "
"teste."

#: ../../library/unittest.rst:1768
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`!__iter__` wasn't sufficient "
"for providing tests."
msgstr ""
"Em versões anteriores, o :class:`TestSuite` acedia aos testes diretamente em "
"vez de através de iteração, pelo que substituir :meth:`!__iter__` não era "
"suficiente para fornecer testes."

#: ../../library/unittest.rst:1773
msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"Em versões anteriores, o :class:`TestSuite` mantinha referências a cada :"
"class:`TestCase` após :meth:`TestSuite.run`. As subclasses podem restaurar "
"esse comportamento substituindo :meth:`TestSuite._removeTestAtIndex`."

#: ../../library/unittest.rst:1778
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"Na utilização típica de um objeto :class:`TestSuite`, o método :meth:`run` é "
"invocado por um :class:`TestRunner` em vez de pelo arnês de teste do "
"utilizador final."

#: ../../library/unittest.rst:1783
msgid "Loading and running tests"
msgstr "Carregamento e execução de testes"

#: ../../library/unittest.rst:1787
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"A classe :class:`TestLoader` é usada para criar conjuntos de teste a partir "
"de classes e módulos. Normalmente, não é necessário criar uma instância "
"desta classe; o módulo :mod:`unittest` fornece uma instância que pode ser "
"partilhada como :data:`unittest.defaultTestLoader`. No entanto, usar uma "
"subclasse ou instância permite personalizar algumas propriedades "
"configuráveis."

#: ../../library/unittest.rst:1793
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr "Os objetos :class:`TestLoader` têm os seguintes atributos:"

#: ../../library/unittest.rst:1798
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""
"Uma lista dos erros não fatais encontrados ao carregar testes. Não é "
"redefinida pelo carregador em nenhum momento. Erros fatais são sinalizados "
"pelo método relevante ao levantar uma exceção para o chamador. Erros não "
"fatais também são indicados por um teste sintético que levantará o erro "
"original quando executado."

#: ../../library/unittest.rst:1807
msgid ":class:`TestLoader` objects have the following methods:"
msgstr "Os objetos :class:`TestLoader` têm os seguintes métodos:"

#: ../../library/unittest.rst:1812
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
"Retorna um conjunto de todos os casos de teste contidos na classe derivada "
"de :class:`TestCase`, :class:`testCaseClass`."

#: ../../library/unittest.rst:1815
msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"Uma instância de caso de teste é criada para cada método nomeado por :meth:"
"`getTestCaseNames`. Por predefinição, estes são os nomes de métodos que "
"começam com ``test``. Se :meth:`getTestCaseNames` não retornar métodos, mas "
"o método :meth:`runTest` estiver implementado, um único caso de teste é "
"criado para esse método em vez disso."

#: ../../library/unittest.rst:1824
msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Retorna um conjunto de todos os casos de teste contidos no módulo dado. Este "
"método pesquisa *module* por classes derivadas de :class:`TestCase` e cria "
"uma instância da classe para cada método de teste definido para a classe."

#: ../../library/unittest.rst:1831
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Embora usar uma hierarquia de classes derivadas de :class:`TestCase` possa "
"ser conveniente para partilhar fixtures e funções auxiliares, definir "
"métodos de teste em classes base que não são destinadas a serem instanciadas "
"diretamente não funciona bem com este método. No entanto, fazê-lo pode ser "
"útil quando as fixtures são diferentes e definidas em subclasses."

#: ../../library/unittest.rst:1837
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Se um módulo fornecer uma função ``load_tests``, ela será chamada para "
"carregar os testes. Isto permite que os módulos personalizem o carregamento "
"de testes. Este é o `protocolo load_tests`_. O argumento *pattern* é passado "
"como o terceiro argumento para ``load_tests``."

#: ../../library/unittest.rst:1842
msgid "Support for ``load_tests`` added."
msgstr "Suporte para ``load_tests`` adicionado."

#: ../../library/unittest.rst:1845
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""

#: ../../library/unittest.rst:1854
msgid "Return a suite of all test cases given a string specifier."
msgstr ""
"Retorna um conjunto de todos os casos de teste dados um especificador de "
"string."

#: ../../library/unittest.rst:1856
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"O especificador *name* é um \"nome pontuado\" que pode resolver para um "
"módulo, uma classe de caso de teste, um método de teste dentro de uma classe "
"de caso de teste, uma instância de :class:`TestSuite`, ou um objeto chamável "
"que retorna uma instância de :class:`TestCase` ou :class:`TestSuite`. Estas "
"verificações são aplicadas pela ordem listada aqui; ou seja, um método numa "
"possível classe de caso de teste será identificado como \"um método de teste "
"dentro de uma classe de caso de teste\", em vez de \"um objeto chamável\"."

#: ../../library/unittest.rst:1864
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Por exemplo, se tiver um módulo :mod:`SampleTests` contendo uma classe "
"derivada de :class:`TestCase`, :class:`SampleTestCase`, com três métodos de "
"teste (:meth:`test_one`, :meth:`test_two` e :meth:`test_three`), o "
"especificador ``'SampleTests.SampleTestCase'`` faria com que este método "
"retornasse um conjunto que executará os três métodos de teste. Usar o "
"especificador ``'SampleTests.SampleTestCase.test_two'`` faria com que "
"retornasse um conjunto de teste que executará apenas o método de teste :meth:"
"`test_two`. O especificador pode referir-se a módulos e pacotes que não "
"foram importados; eles serão importados como efeito colateral."

#: ../../library/unittest.rst:1874
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "O método resolve opcionalmente *name* em relação ao *module* dado."

#: ../../library/unittest.rst:1876
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"Se ocorrer um :exc:`ImportError` ou :exc:`AttributeError` ao percorrer "
"*name*, então um teste sintético que levanta esse erro quando executado será "
"retornado. Estes erros estão incluídos nos erros acumulados por self.errors."

#: ../../library/unittest.rst:1885
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Semelhante a :meth:`loadTestsFromName`, mas recebe uma sequência de nomes em "
"vez de um único nome. O valor de retorno é um conjunto de testes que suporta "
"todos os testes definidos para cada nome."

#: ../../library/unittest.rst:1892
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Retorna uma sequência ordenada de nomes de métodos encontrados dentro de "
"*testCaseClass*; isto deve ser uma subclasse de :class:`TestCase`."

#: ../../library/unittest.rst:1898
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Encontra todos os módulos de teste ao percorrer subdiretórios a partir do "
"diretório de início especificado, e retorna um objeto TestSuite contendo-os. "
"Apenas os ficheiros de teste que correspondem a *pattern* serão carregados. "
"(Usando correspondência de padrões estilo shell.) Apenas nomes de módulos "
"que são importáveis (ou seja, são identificadores Python válidos) serão "
"carregados."

#: ../../library/unittest.rst:1904
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""

#: ../../library/unittest.rst:1908
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Se a importação de um módulo falhar, por exemplo, devido a um erro de "
"sintaxe, isso será registrado como um único erro e a descoberta continuará. "
"Se a falha de importação for devido a :exc:`SkipTest` ser levantado, será "
"registrado como um salto em vez de um erro."

#: ../../library/unittest.rst:1913
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"Se um pacote (um diretório contendo um ficheiro chamado :file:`__init__.py`) "
"for encontrado, o pacote será verificado quanto a uma função ``load_tests``. "
"Se esta existir, será chamada ``package.load_tests(loader, tests, "
"pattern)``. A descoberta de testes garante que um pacote é verificado quanto "
"a testes apenas uma vez durante uma invocação, mesmo que a função load_tests "
"em si chame ``loader.discover``."

#: ../../library/unittest.rst:1921
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Se ``load_tests`` existir, então a descoberta *não* recorre ao pacote; "
"``load_tests`` é responsável por carregar todos os testes no pacote."

#: ../../library/unittest.rst:1925
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""

#: ../../library/unittest.rst:1930
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""
"*start_dir* pode ser um nome de módulo pontuado, bem como um diretório."

#: ../../library/unittest.rst:1934
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Módulos que levantam :exc:`SkipTest` na importação são registados como "
"saltos, não erros."

#: ../../library/unittest.rst:1938
msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir* pode ser um :term:`pacote de espaço de nomes <namespace "
"package>`."

#: ../../library/unittest.rst:1941
msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Os caminhos são ordenados antes de serem importados, para que a ordem de "
"execução seja a mesma, mesmo que a ordenação do sistema de ficheiros "
"subjacente não dependa do nome do ficheiro."

#: ../../library/unittest.rst:1946
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"Os pacotes encontrados são agora verificados quanto a ``load_tests`` "
"independentemente de o seu caminho corresponder a *pattern*, porque é "
"impossível um nome de pacote corresponder ao padrão predefinido."

#: ../../library/unittest.rst:1951
msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""

#: ../../library/unittest.rst:1956
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Os seguintes atributos de um :class:`TestLoader` podem ser configurados por "
"subclassing ou atribuição numa instância:"

#: ../../library/unittest.rst:1962
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"String que dá o prefixo dos nomes de métodos que serão interpretados como "
"métodos de teste. O valor predefinido é ``'test'``."

#: ../../library/unittest.rst:1965
msgid ""
"This affects :meth:`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Isto afeta :meth:`getTestCaseNames` e todos os métodos ``loadTestsFrom*``."

#: ../../library/unittest.rst:1971
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the ``loadTestsFrom*`` methods."
msgstr ""
"Função a ser usada para comparar nomes de métodos ao ordená-los em :meth:"
"`getTestCaseNames` e todos os métodos ``loadTestsFrom*``."

#: ../../library/unittest.rst:1977
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Objeto chamável que constrói um conjunto de testes a partir de uma lista de "
"testes. Não são necessários métodos no objeto resultante. O valor "
"predefinido é a classe :class:`TestSuite`."

#: ../../library/unittest.rst:1981 ../../library/unittest.rst:1994
msgid "This affects all the ``loadTestsFrom*`` methods."
msgstr "Isto afeta todos os métodos ``loadTestsFrom*``."

#: ../../library/unittest.rst:1985
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-k`` option)."
msgstr ""
"Lista de padrões de nomes de teste estilo shell Unix que os métodos de teste "
"devem corresponder para serem incluídos em conjuntos de teste (consulte a "
"opção ``-k``)."

#: ../../library/unittest.rst:1988
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-k`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"Se este atributo não for ``None`` (o predefinido), todos os métodos de teste "
"a serem incluídos em conjuntos de teste devem corresponder a um dos padrões "
"nesta lista. Note que as correspondências são sempre realizadas usando :meth:"
"`fnmatch.fnmatchcase`, pelo que, ao contrário dos padrões passados para a "
"opção ``-k``, os padrões de substring simples terão de ser convertidos "
"usando curingas ``*``."

#: ../../library/unittest.rst:2001
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Esta classe é usada para compilar informações sobre quais testes tiveram "
"sucesso e quais falharam."

#: ../../library/unittest.rst:2004
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Um objeto :class:`TestResult` armazena os resultados de um conjunto de "
"testes. As classes :class:`TestCase` e :class:`TestSuite` garantem que os "
"resultados são devidamente registados; os autores de testes não precisam de "
"se preocupar em registar o resultado dos testes."

#: ../../library/unittest.rst:2009
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Estruturas de teste construídas sobre :mod:`unittest` podem querer aceder ao "
"objeto :class:`TestResult` gerado pela execução de um conjunto de testes "
"para fins de relatório; uma instância de :class:`TestResult` é retornada "
"pelo método :meth:`TestRunner.run` para este propósito."

#: ../../library/unittest.rst:2014
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
"As instâncias de :class:`TestResult` têm os seguintes atributos que serão de "
"interesse ao inspecionar os resultados da execução de um conjunto de testes:"

#: ../../library/unittest.rst:2020
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"Uma lista contendo 2-tuplos de instâncias :class:`TestCase` e strings com "
"tracebacks formatados. Cada tuplo representa um teste que levantou uma "
"exceção inesperada."

#: ../../library/unittest.rst:2026
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :ref:`assert\\* methods <assert-methods>`."
msgstr ""
"Uma lista contendo 2-tuplos de instâncias :class:`TestCase` e strings com "
"tracebacks formatados. Cada tuplo representa um teste onde uma falha foi "
"explicitamente sinalizada usando os :ref:`métodos assert <assert-methods>`."

#: ../../library/unittest.rst:2032
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"Uma lista contendo 2-tuplos de instâncias :class:`TestCase` e strings com o "
"motivo para ignorar o teste."

#: ../../library/unittest.rst:2039
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"Uma lista contendo 2-tuplos de instâncias :class:`TestCase` e strings com "
"tracebacks formatados. Cada tuplo representa uma falha ou erro esperado do "
"caso de teste."

#: ../../library/unittest.rst:2045
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"Uma lista contendo instâncias :class:`TestCase` que foram marcadas como "
"falhas esperadas, mas tiveram sucesso."

#: ../../library/unittest.rst:2050
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""
"Definido para ``True`` quando a execução dos testes deve parar por :meth:"
"`stop`."

#: ../../library/unittest.rst:2054
msgid "The total number of tests run so far."
msgstr "O número total de testes executados até agora."

#: ../../library/unittest.rst:2058
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Se definido como verdadeiro, ``sys.stdout`` e ``sys.stderr`` serão colocados "
"em buffer entre as chamadas a :meth:`startTest` e :meth:`stopTest`. A saída "
"recolhida só será ecoada para o ``sys.stdout`` e ``sys.stderr`` reais se o "
"teste falhar ou gerar erros. Qualquer saída também é anexada à mensagem de "
"falha/erro."

#: ../../library/unittest.rst:2067
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Se definido como verdadeiro, :meth:`stop` será chamado na primeira falha ou "
"erro, interrompendo a execução do teste."

#: ../../library/unittest.rst:2074
msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""
"Se definido como verdadeiro, as variáveis locais serão mostradas nos "
"tracebacks."

#: ../../library/unittest.rst:2080
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Retorna ``True`` se todos os testes executados até agora tiverem passado, "
"caso contrário retorna ``False``."

#: ../../library/unittest.rst:2083
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Retorna ``False`` se houver algum :attr:`unexpectedSuccesses` de testes "
"marcados com o decorador :func:`expectedFailure`."

#: ../../library/unittest.rst:2089
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Este método pode ser chamado para sinalizar que o conjunto de testes em "
"execução deve ser abortado, definindo o atributo :attr:`shouldStop` para "
"``True``. Os objetos :class:`TestRunner` devem respeitar esta flag e "
"retornar sem executar quaisquer testes adicionais."

#: ../../library/unittest.rst:2094
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Por exemplo, esta funcionalidade é usada pela classe :class:`TextTestRunner` "
"para parar a estrutura de teste quando o utilizador sinaliza uma interrupção "
"a partir do teclado. Ferramentas interativas que fornecem implementações de :"
"class:`TestRunner` podem usar isto de forma semelhante."

#: ../../library/unittest.rst:2099
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Os seguintes métodos da classe :class:`TestResult` são usados para manter as "
"estruturas de dados internas e podem ser estendidos em subclasses para "
"suportar requisitos adicionais de relatório. Isto é particularmente útil na "
"construção de ferramentas que suportam relatórios interativos enquanto os "
"testes estão a ser executados."

#: ../../library/unittest.rst:2107
msgid "Called when the test case *test* is about to be run."
msgstr "Chamado quando o caso de teste *test* está prestes a ser executado."

#: ../../library/unittest.rst:2111
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""
"Chamado após o caso de teste *test* ter sido executado, independentemente do "
"resultado."

#: ../../library/unittest.rst:2116
msgid "Called once before any tests are executed."
msgstr "Chamado uma vez antes de quaisquer testes serem executados."

#: ../../library/unittest.rst:2123
msgid "Called once after all tests are executed."
msgstr "Chamado uma vez após todos os testes serem executados."

#: ../../library/unittest.rst:2130
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Chamado quando o caso de teste *test* levanta uma exceção inesperada. *err* "
"é um tuplo da forma retornada por :func:`sys.exc_info`: ``(type, value, "
"traceback)``."

#: ../../library/unittest.rst:2134
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"A implementação predefinida anexa um tuplo ``(test, formatted_err)`` ao "
"atributo :attr:`errors` da instância, onde *formatted_err* é um traceback "
"formatado derivado de *err*."

#: ../../library/unittest.rst:2141
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Chamado quando o caso de teste *test* sinaliza uma falha. *err* é um tuplo "
"da forma retornada por :func:`sys.exc_info`: ``(type, value, traceback)``."

#: ../../library/unittest.rst:2144
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"A implementação predefinida anexa um tuplo ``(test, formatted_err)`` ao "
"atributo :attr:`failures` da instância, onde *formatted_err* é um traceback "
"formatado derivado de *err*."

#: ../../library/unittest.rst:2151
msgid "Called when the test case *test* succeeds."
msgstr "Chamado quando o caso de teste *test* tem sucesso."

#: ../../library/unittest.rst:2153
msgid "The default implementation does nothing."
msgstr "A implementação predefinida não faz nada."

#: ../../library/unittest.rst:2158
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Chamado quando o caso de teste *test* é ignorado. *reason* é o motivo pelo "
"qual o teste foi ignorado."

#: ../../library/unittest.rst:2161
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"A implementação predefinida anexa um tuplo ``(test, reason)`` ao atributo :"
"attr:`skipped` da instância."

#: ../../library/unittest.rst:2167
msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
"Chamado quando o caso de teste *test* falha ou gera erros, mas foi marcado "
"com o decorador :func:`expectedFailure`."

#: ../../library/unittest.rst:2170
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"A implementação predefinida anexa um tuplo ``(test, formatted_err)`` ao "
"atributo :attr:`expectedFailures` da instância, onde *formatted_err* é um "
"traceback formatado derivado de *err*."

#: ../../library/unittest.rst:2177
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Chamado quando o caso de teste *test* foi marcado com o decorador :func:"
"`expectedFailure`, mas teve sucesso."

#: ../../library/unittest.rst:2180
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"A implementação predefinida anexa o teste ao atributo :attr:"
"`unexpectedSuccesses` da instância."

#: ../../library/unittest.rst:2186
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Chamado quando um subteste termina. *test* é o caso de teste correspondente "
"ao método de teste. *subtest* é uma instância personalizada de :class:"
"`TestCase` que descreve o subteste."

#: ../../library/unittest.rst:2190
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Se *outcome* for :const:`None`, o subteste teve sucesso. Caso contrário, "
"falhou com uma exceção onde *outcome* é um tuplo da forma retornada por :"
"func:`sys.exc_info`: ``(type, value, traceback)``."

#: ../../library/unittest.rst:2194
msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"A implementação predefinida não faz nada quando o resultado é um sucesso e "
"regista falhas de subteste como falhas normais."

#: ../../library/unittest.rst:2202
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""

#: ../../library/unittest.rst:2205
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""

#: ../../library/unittest.rst:2212
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Instância da classe :class:`TestLoader` destinada a ser partilhada. Se "
"nenhuma personalização da :class:`TestLoader` for necessária, esta instância "
"pode ser usada em vez de criar repetidamente novas instâncias."

#: ../../library/unittest.rst:2220
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"Uma implementação básica de executor de testes que envia resultados para um "
"fluxo. Se *stream* for ``None``, o predefinido, :data:`sys.stderr` é usado "
"como o fluxo de saída. Esta classe tem alguns parâmetros configuráveis, mas "
"é essencialmente muito simples. Aplicações gráficas que executam conjuntos "
"de testes devem fornecer implementações alternativas. Tais implementações "
"devem aceitar ``**kwargs`` à medida que a interface para construir "
"executores muda quando funcionalidades são adicionadas ao unittest."

#: ../../library/unittest.rst:2227
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""

#: ../../library/unittest.rst:2238
msgid "Added the ``warnings`` argument."
msgstr ""

#: ../../library/unittest.rst:2241
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"O fluxo predefinido é definido para :data:`sys.stderr` no momento da "
"instanciação em vez de no momento da importação."

#: ../../library/unittest.rst:2245
msgid "Added the tb_locals parameter."
msgstr ""

#: ../../library/unittest.rst:2250
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Este método retorna a instância de ``TestResult`` usada por :meth:`run`. Não "
"é destinado a ser chamado diretamente, mas pode ser substituído em "
"subclasses para fornecer um ``TestResult`` personalizado."

#: ../../library/unittest.rst:2254
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` instancia a classe ou objeto chamável passado no "
"construtor de ``TextTestRunner`` como argumento ``resultclass``. Por "
"predefinição, é :class:`TextTestResult` se nenhum ``resultclass`` for "
"fornecido. A classe de resultado é instanciada com os seguintes argumentos::"

#: ../../library/unittest.rst:2263
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"Este método é a interface pública principal para o ``TextTestRunner``. Este "
"método recebe uma instância de :class:`TestSuite` ou :class:`TestCase`. Um :"
"class:`TestResult` é criado chamando :func:`_makeResult` e os teste(s) são "
"executados e os resultados impressos no stdout."

#: ../../library/unittest.rst:2274
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Um programa de linha de comandos que carrega um conjunto de testes de "
"*module* e executa-os; isto é principalmente para tornar os módulos de teste "
"convenientemente executáveis. A utilização mais simples desta função é "
"incluir a seguinte linha no final de um script de teste::"

#: ../../library/unittest.rst:2282
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Pode executar testes com informações mais detalhadas passando o argumento "
"verbosity::"

#: ../../library/unittest.rst:2288
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"O argumento *defaultTest* é o nome de um único teste ou um iterável de nomes "
"de testes a executar se nenhum nome de teste for especificado via *argv*. Se "
"não for especificado ou for ``None`` e nenhum nome de teste for fornecido "
"via *argv*, todos os testes encontrados em *module* são executados."

#: ../../library/unittest.rst:2293
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"O argumento *argv* pode ser uma lista de opções passadas ao programa, com o "
"primeiro elemento a ser o nome do programa. Se não for especificado ou for "
"``None``, os valores de :data:`sys.argv` são usados."

#: ../../library/unittest.rst:2297
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""

#: ../../library/unittest.rst:2301
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"O argumento *testLoader* tem de ser uma instância de :class:`TestLoader`, e "
"por predefinição é :data:`defaultTestLoader`."

#: ../../library/unittest.rst:2304
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` suporta ser usado a partir do interpretador interativo passando o "
"argumento ``exit=False``. Isto exibe o resultado na saída padrão sem chamar :"
"func:`sys.exit`::"

#: ../../library/unittest.rst:2311
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Os parâmetros *failfast*, *catchbreak* e *buffer* têm o mesmo efeito que as "
"opções de linha de comandos com o mesmo nome."

#: ../../library/unittest.rst:2314
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"O argumento *warnings* especifica o :ref:`filtro de avisos <warning-filter>` "
"que deve ser usado ao executar os testes. Se não for especificado, "
"permanecerá ``None`` se uma opção :option:`!-W` for passada para :program:"
"`python` (consulte :ref:`Controlo de avisos <using-on-warnings>`), caso "
"contrário será definido para ``'default'``."

#: ../../library/unittest.rst:2320
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""

#: ../../library/unittest.rst:2323
msgid "The *exit* parameter was added."
msgstr "O parâmetro *exit* foi adicionado."

#: ../../library/unittest.rst:2326
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Os parâmetros *verbosity*, *failfast*, *catchbreak*, *buffer* e *warnings* "
"foram adicionados."

#: ../../library/unittest.rst:2330
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"O parâmetro *defaultTest* foi alterado para também aceitar um iterável de "
"nomes de testes."

#: ../../library/unittest.rst:2338
msgid "load_tests Protocol"
msgstr "Protocolo load_tests"

#: ../../library/unittest.rst:2342
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Módulos ou pacotes podem personalizar a forma como os testes são carregados "
"a partir deles durante execuções normais de testes ou descoberta de testes, "
"implementando uma função chamada ``load_tests``."

#: ../../library/unittest.rst:2345
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Se um módulo de teste definir ``load_tests``, ele será chamado por :meth:"
"`TestLoader.loadTestsFromModule` com os seguintes argumentos::"

#: ../../library/unittest.rst:2350
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"onde *pattern* é passado diretamente de ``loadTestsFromModule``. Por "
"predefinição é ``None``."

#: ../../library/unittest.rst:2353
msgid "It should return a :class:`TestSuite`."
msgstr "Deve retornar um :class:`TestSuite`."

#: ../../library/unittest.rst:2355
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* é a instância de :class:`TestLoader` que está a fazer o "
"carregamento. *standard_tests* são os testes que seriam carregados por "
"predefinição a partir do módulo. É comum que os módulos de teste queiram "
"apenas adicionar ou remover testes do conjunto padrão de testes. O terceiro "
"argumento é usado ao carregar pacotes como parte da descoberta de testes."

#: ../../library/unittest.rst:2361
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"Uma função típica ``load_tests`` que carrega testes a partir de um conjunto "
"específico de classes :class:`TestCase` pode parecer-se com isto::"

#: ../../library/unittest.rst:2373
msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Se a descoberta for iniciada num diretório contendo um pacote, seja a partir "
"da linha de comandos ou chamando :meth:`TestLoader.discover`, então o "
"ficheiro :file:`__init__.py` do pacote será verificado quanto à presença de "
"``load_tests``. Se essa função não existir, a descoberta irá percorrer o "
"pacote como se fosse apenas outro diretório. Caso contrário, a descoberta "
"dos testes do pacote será deixada a cargo de ``load_tests``, que é chamada "
"com os seguintes argumentos::"

#: ../../library/unittest.rst:2382
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Isto deve retornar um :class:`TestSuite` representando todos os testes do "
"pacote. (``standard_tests`` conterá apenas testes recolhidos de :file:"
"`__init__.py`.)"

#: ../../library/unittest.rst:2386
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Como o padrão é passado para ``load_tests``, o pacote pode continuar (e "
"potencialmente modificar) a descoberta de testes. Uma função ``load_tests`` "
"'não faz nada' para um pacote de teste pareceria::"

#: ../../library/unittest.rst:2397
msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"A descoberta já não verifica nomes de pacotes para correspondência com "
"*pattern* devido à impossibilidade de nomes de pacotes corresponderem ao "
"padrão predefinido."

#: ../../library/unittest.rst:2404
msgid "Class and Module Fixtures"
msgstr "Fixtures de Classe e Módulo"

#: ../../library/unittest.rst:2406
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Fixtures de nível de classe e módulo são implementadas em :class:"
"`TestSuite`. Quando o conjunto de testes encontra um teste de uma nova "
"classe, então :meth:`tearDownClass` da classe anterior (se existir) é "
"chamado, seguido de :meth:`setUpClass` da nova classe."

#: ../../library/unittest.rst:2411
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"Da mesma forma, se um teste for de um módulo diferente do teste anterior, "
"então ``tearDownModule`` do módulo anterior é executado, seguido de "
"``setUpModule`` do novo módulo."

#: ../../library/unittest.rst:2415
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Após todos os testes terem sido executados, o ``tearDownClass`` final e o "
"``tearDownModule`` são executados."

#: ../../library/unittest.rst:2418
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Note que as fixtures partilhadas não funcionam bem com funcionalidades "
"[potenciais] como a paralelização de testes e quebram o isolamento dos "
"testes. Devem ser usadas com cuidado."

#: ../../library/unittest.rst:2421
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"A ordenação predefinida dos testes criados pelos carregadores de testes do "
"unittest é agrupar todos os testes dos mesmos módulos e classes juntos. Isto "
"levará a que ``setUpClass`` / ``setUpModule`` (etc) sejam chamados "
"exatamente uma vez por classe e módulo. Se aleatorizar a ordem, de forma que "
"testes de diferentes módulos e classes fiquem adjacentes uns aos outros, "
"então estas funções de fixtures partilhadas podem ser chamadas várias vezes "
"numa única execução de teste."

#: ../../library/unittest.rst:2428
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"As fixtures partilhadas não são destinadas a funcionar com suites com "
"ordenação não padrão. Um ``BaseTestSuite`` ainda existe para frameworks que "
"não querem suportar fixtures partilhadas."

#: ../../library/unittest.rst:2432
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Se houver alguma exceção levantada durante uma das funções de fixtures "
"partilhadas, o teste é reportado como um erro. Como não há uma instância de "
"teste correspondente, um objeto ``_ErrorHolder`` (que tem a mesma interface "
"que um :class:`TestCase`) é criado para representar o erro. Se estiver "
"apenas a usar o executor de testes padrão do unittest, então este detalhe "
"não importa, mas se for um autor de framework pode ser relevante."

#: ../../library/unittest.rst:2441
msgid "setUpClass and tearDownClass"
msgstr "setUpClass e tearDownClass"

#: ../../library/unittest.rst:2443
msgid "These must be implemented as class methods::"
msgstr "Estes devem ser implementados como métodos de classe::"

#: ../../library/unittest.rst:2456
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Se quiser que ``setUpClass`` e ``tearDownClass`` das classes base sejam "
"chamados, então deve chamá-los você mesmo. As implementações em :class:"
"`TestCase` estão vazias."

#: ../../library/unittest.rst:2460
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Se uma exceção for levantada durante um ``setUpClass``, então os testes na "
"classe não são executados e o ``tearDownClass`` não é executado. Classes "
"ignoradas não terão ``setUpClass`` ou ``tearDownClass`` executados. Se a "
"exceção for uma exceção :exc:`SkipTest`, então a classe será reportada como "
"tendo sido ignorada em vez de como um erro."

#: ../../library/unittest.rst:2468
msgid "setUpModule and tearDownModule"
msgstr "setUpModule e tearDownModule"

#: ../../library/unittest.rst:2470
msgid "These should be implemented as functions::"
msgstr "Estes devem ser implementados como funções::"

#: ../../library/unittest.rst:2478
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Se uma exceção for levantada num ``setUpModule``, então nenhum dos testes no "
"módulo será executado e o ``tearDownModule`` não será executado. Se a "
"exceção for uma exceção :exc:`SkipTest`, então o módulo será reportado como "
"tendo sido ignorado em vez de como um erro."

#: ../../library/unittest.rst:2483
msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Para adicionar código de limpeza que deve ser executado mesmo em caso de "
"exceção, use ``addModuleCleanup``:"

#: ../../library/unittest.rst:2489
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"Adiciona uma função a ser chamada após :func:`tearDownModule` para limpar "
"recursos usados durante a classe de teste. As funções serão chamadas em "
"ordem inversa à ordem em que foram adicionadas (:abbr:`LIFO (último a "
"entrar, primeiro a sair)`). São chamadas com quaisquer argumentos e "
"argumentos de palavra-chave passados para :meth:`addModuleCleanup` quando "
"são adicionadas."

#: ../../library/unittest.rst:2495
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Se :meth:`setUpModule` falhar, significando que :func:`tearDownModule` não é "
"chamado, então quaisquer funções de limpeza adicionadas ainda serão chamadas."

#: ../../library/unittest.rst:2503
msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""
"Entrar no :term:`gestor de contexto` fornecido. Se for bem-sucedido, também "
"adiciona o seu método :meth:`~object.__exit__` como uma função de limpeza "
"através de :func:`addModuleCleanup` e retorna o resultado do método :meth:"
"`~object.__enter__`."

#: ../../library/unittest.rst:2513
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Esta função é chamada incondicionalmente após :func:`tearDownModule`, ou "
"após :func:`setUpModule` se :func:`setUpModule` levantar uma exceção."

#: ../../library/unittest.rst:2516
msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"É responsável por chamar todas as funções de limpeza adicionadas por :func:"
"`addModuleCleanup`. Se precisar que as funções de limpeza sejam chamadas "
"*antes* de :func:`tearDownModule`, pode chamar :func:`doModuleCleanups` você "
"mesmo."

#: ../../library/unittest.rst:2521
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` remove métodos da pilha de funções de limpeza um de "
"cada vez, pelo que pode ser chamado a qualquer momento."

#: ../../library/unittest.rst:2528
msgid "Signal Handling"
msgstr "Tratamento de sinal"

#: ../../library/unittest.rst:2532
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""

#: ../../library/unittest.rst:2539
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"O gestor de sinal de tratamento de control-C tenta permanecer compatível com "
"código ou testes que instalam o seu próprio gestor de :const:`signal."
"SIGINT`. Se o gestor ``unittest`` for chamado mas *não* for o gestor "
"instalado de :const:`signal.SIGINT` (ou seja, foi substituído pelo sistema "
"em teste e delegado), então chama o gestor predefinido. Isto será "
"normalmente o comportamento esperado por código que substitui um gestor "
"instalado e delega nele. Para testes individuais que precisam de desativar o "
"tratamento de control-C do ``unittest``, pode ser usado o decorador :func:"
"`removeHandler`."

#: ../../library/unittest.rst:2548
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Existem algumas funções utilitárias para autores de frameworks que permitem "
"ativar a funcionalidade de tratamento de control-C dentro de frameworks de "
"teste."

#: ../../library/unittest.rst:2553
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Instala o gestor de control-C. Quando um :const:`signal.SIGINT` é recebido "
"(normalmente em resposta ao utilizador premir control-C), todos os "
"resultados registados têm :meth:`~TestResult.stop` chamado."

#: ../../library/unittest.rst:2560
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Regista um objeto :class:`TestResult` para tratamento de control-C. O "
"registo de um resultado armazena uma referência fraca para ele, pelo que não "
"impede que o resultado seja recolhido pelo garbage collector."

#: ../../library/unittest.rst:2564
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"O registo de um objeto :class:`TestResult` não tem efeitos secundários se o "
"tratamento de control-C não estiver ativado, pelo que os frameworks de teste "
"podem registar incondicionalmente todos os resultados que criam, "
"independentemente de o tratamento estar ou não ativado."

#: ../../library/unittest.rst:2571
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Remove um resultado registado. Uma vez que um resultado tenha sido removido, "
"então :meth:`~TestResult.stop` já não será chamado nesse objeto de resultado "
"em resposta a um control-C."

#: ../../library/unittest.rst:2578
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"Quando chamada sem argumentos, esta função remove o gestor de control-C se "
"ele tiver sido instalado. Esta função também pode ser usada como um "
"decorador de teste para remover temporariamente o gestor enquanto o teste "
"está a ser executado::"
