# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-03 15:04+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/dataclasses.rst:2
msgid ":mod:`!dataclasses` --- Data Classes"
msgstr ":mod:`!dataclasses` --- Classes de Dados"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**Código-fonte:** :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special methods <special method>` such as :meth:`~object."
"__init__` and :meth:`~object.__repr__` to user-defined classes.  It was "
"originally described in :pep:`557`."
msgstr ""
"Este módulo fornece um decorador e funções para adicionar automaticamente :"
"term:`métodos especiais <special method>` gerados, como :meth:`~object."
"__init__` e :meth:`~object.__repr__`, a classes definidas pelo utilizador. "
"Foi originalmente descrito em :pep:`557`."

#: ../../library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"As variáveis membro a usar nestes métodos gerados são definidas usando "
"anotações de tipo :pep:`526`. Por exemplo, este código::"

#: ../../library/dataclasses.rst:22
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Class for keeping track of an item in inventory.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    \"\"\"Classe para acompanhar um item em inventário.\"\"\"\n"
"    name: str\n"
"    unit_price: float\n"
"    quantity_on_hand: int = 0\n"
"\n"
"    def total_cost(self) -> float:\n"
"        return self.unit_price * self.quantity_on_hand"

#: ../../library/dataclasses.rst:34
msgid "will add, among other things, a :meth:`!__init__` that looks like::"
msgstr "irá adicionar, entre outras coisas, um :meth:`!__init__` que parece::"

#: ../../library/dataclasses.rst:36
msgid ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"
msgstr ""
"def __init__(self, name: str, unit_price: float, quantity_on_hand: int = "
"0):\n"
"    self.name = name\n"
"    self.unit_price = unit_price\n"
"    self.quantity_on_hand = quantity_on_hand"

#: ../../library/dataclasses.rst:41
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the :class:`!InventoryItem` definition shown above."
msgstr ""
"Note que este método é adicionado automaticamente à classe: não está "
"especificado diretamente na definição de :class:`!InventoryItem` mostrada "
"acima."

#: ../../library/dataclasses.rst:47
msgid "Module contents"
msgstr "Conteúdos do módulo"

#: ../../library/dataclasses.rst:51
msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special methods <special method>` to classes, as described below."
msgstr ""
"Esta função é um :term:`decorador` que é usado para adicionar :term:`métodos "
"especiais <special method>` gerados a classes, conforme descrito abaixo."

#: ../../library/dataclasses.rst:54
msgid ""
"The ``@dataclass`` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in "
"``@dataclass`` examines the type specified in the variable annotation."
msgstr ""
"O decorador ``@dataclass`` examina a classe para encontrar ``field``s. Um "
"``field`` é definido como uma variável de classe que tem uma :term:`anotação "
"de tipo <variable annotation>`. Com duas exceções descritas abaixo, nada em "
"``@dataclass`` examina o tipo especificado na anotação de variável."

#: ../../library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr ""
"A ordem dos campos em todos os métodos gerados é a ordem em que aparecem na "
"definição da classe."

#: ../../library/dataclasses.rst:63
msgid ""
"The ``@dataclass`` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"O decorador ``@dataclass`` adicionará vários métodos \"dunder\" à classe, "
"descritos abaixo. Se algum dos métodos adicionados já existir na classe, o "
"comportamento depende do parâmetro, conforme documentado abaixo. O decorador "
"retorna a mesma classe em que é chamado; nenhuma nova classe é criada."

#: ../../library/dataclasses.rst:69
msgid ""
"If ``@dataclass`` is used just as a simple decorator with no parameters, it "
"acts as if it has the default values documented in this signature.  That is, "
"these three uses of ``@dataclass`` are equivalent::"
msgstr ""
"Se ``@dataclass`` for usado apenas como um decorador simples sem parâmetros, "
"age como se tivesse os valores predefinidos documentados nesta assinatura. "
"Ou seja, estes três usos de ``@dataclass`` são equivalentes::"

#: ../../library/dataclasses.rst:74
msgid ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."
msgstr ""
"@dataclass\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass()\n"
"class C:\n"
"    ...\n"
"\n"
"@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, "
"frozen=False,\n"
"           match_args=True, kw_only=False, slots=False, weakref_slot=False)\n"
"class C:\n"
"    ..."

#: ../../library/dataclasses.rst:87
msgid "The parameters to ``@dataclass`` are:"
msgstr "Os parâmetros para ``@dataclass`` são:"

#: ../../library/dataclasses.rst:89
msgid ""
"*init*: If true (the default), a :meth:`~object.__init__` method will be "
"generated."
msgstr ""
"*init*: Se verdadeiro (predefinição), um método :meth:`~object.__init__` "
"será gerado."

#: ../../library/dataclasses.rst:92
msgid ""
"If the class already defines :meth:`!__init__`, this parameter is ignored."
msgstr "Se a classe já definir :meth:`!__init__`, este parâmetro é ignorado."

#: ../../library/dataclasses.rst:95
msgid ""
"*repr*: If true (the default), a :meth:`~object.__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"*repr*: Se verdadeiro (predefinição), um método :meth:`~object.__repr__` "
"será gerado. A string repr gerada terá o nome da classe e o nome e repr de "
"cada campo, na ordem em que são definidos na classe. Campos marcados como "
"excluídos do repr não são incluídos. Por exemplo: "
"``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)``."

#: ../../library/dataclasses.rst:102
msgid ""
"If the class already defines :meth:`!__repr__`, this parameter is ignored."
msgstr "Se a classe já definir :meth:`!__repr__`, este parâmetro é ignorado."

#: ../../library/dataclasses.rst:105
msgid ""
"*eq*: If true (the default), an :meth:`~object.__eq__` method will be "
"generated.  This method compares the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type."
msgstr ""
"*eq*: Se verdadeiro (predefinição), um método :meth:`~object.__eq__` será "
"gerado. Este método compara a classe como se fosse um tuplo dos seus campos, "
"por ordem. Ambas as instâncias na comparação devem ser do mesmo tipo."

#: ../../library/dataclasses.rst:110
msgid ""
"If the class already defines :meth:`!__eq__`, this parameter is ignored."
msgstr "Se a classe já definir :meth:`!__eq__`, este parâmetro é ignorado."

#: ../../library/dataclasses.rst:113
msgid ""
"*order*: If true (the default is ``False``), :meth:`~object.__lt__`, :meth:"
"`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` methods "
"will be generated.  These compare the class as if it were a tuple of its "
"fields, in order.  Both instances in the comparison must be of the identical "
"type.  If *order* is true and *eq* is false, a :exc:`ValueError` is raised."
msgstr ""
"*order*: Se verdadeiro (a predefinição é ``False``), os métodos :meth:"
"`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object.__gt__` e :meth:"
"`~object.__ge__` serão gerados. Estes comparam a classe como se fosse um "
"tuplo dos seus campos, por ordem. Ambas as instâncias na comparação devem "
"ser do mesmo tipo. Se *order* for verdadeiro e *eq* for falso, é lançada uma "
"exceção :exc:`ValueError`."

#: ../../library/dataclasses.rst:120
msgid ""
"If the class already defines any of :meth:`!__lt__`, :meth:`!__le__`, :meth:"
"`!__gt__`, or :meth:`!__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"Se a classe já definir algum dos métodos :meth:`!__lt__`, :meth:`!__le__`, :"
"meth:`!__gt__` ou :meth:`!__ge__`, então é lançada uma exceção :exc:"
"`TypeError`."

#: ../../library/dataclasses.rst:124
msgid ""
"*unsafe_hash*: If true, force ``dataclasses`` to create a :meth:`~object."
"__hash__` method, even though it may not be safe to do so. Otherwise, "
"generate a :meth:`~object.__hash__` method according to how *eq* and "
"*frozen* are set. The default value is ``False``."
msgstr ""
"*unsafe_hash*: Se verdadeiro, força ``dataclasses`` a criar um método :meth:"
"`~object.__hash__`, mesmo que não seja seguro fazê-lo. Caso contrário, gera "
"um método :meth:`~object.__hash__` de acordo com a configuração de *eq* e "
"*frozen*. O valor predefinido é ``False``."

#: ../../library/dataclasses.rst:130
msgid ""
":meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a :meth:`!"
"__hash__` implies that instances of the class are immutable. Mutability is a "
"complicated property that depends on the programmer's intent, the existence "
"and behavior of :meth:`!__eq__`, and the values of the *eq* and *frozen* "
"flags in the ``@dataclass`` decorator."
msgstr ""
":meth:`!__hash__` é usado pela função integrada :meth:`hash` e quando "
"objetos são adicionados a coleções com hash, como dicionários e conjuntos. "
"Ter um :meth:`!__hash__` implica que as instâncias da classe são imutáveis. "
"A imutabilidade é uma propriedade complicada que depende da intenção do "
"programador, da existência e comportamento de :meth:`!__eq__` e dos valores "
"das flags *eq* e *frozen* no decorador ``@dataclass``."

#: ../../library/dataclasses.rst:137
msgid ""
"By default, ``@dataclass`` will not implicitly add a :meth:`~object."
"__hash__` method unless it is safe to do so.  Neither will it add or change "
"an existing explicitly defined :meth:`!__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described "
"in the :meth:`!__hash__` documentation."
msgstr ""
"Por predefinição, ``@dataclass`` não adicionará implicitamente um método :"
"meth:`~object.__hash__` a menos que seja seguro fazê-lo. Também não "
"adicionará ou alterará um método :meth:`!__hash__` explicitamente definido. "
"Definir o atributo de classe ``__hash__ = None`` tem um significado "
"específico em Python, conforme descrito na documentação de :meth:`!__hash__`."

#: ../../library/dataclasses.rst:143
msgid ""
"If :meth:`!__hash__` is not explicitly defined, or if it is set to ``None``, "
"then ``@dataclass`` *may* add an implicit :meth:`!__hash__` method. Although "
"not recommended, you can force ``@dataclass`` to create a :meth:`!__hash__` "
"method with ``unsafe_hash=True``. This might be the case if your class is "
"logically immutable but can still be mutated. This is a specialized use case "
"and should be considered carefully."
msgstr ""

#: ../../library/dataclasses.rst:150
msgid ""
"Here are the rules governing implicit creation of a :meth:`!__hash__` "
"method.  Note that you cannot both have an explicit :meth:`!__hash__` method "
"in your dataclass and set ``unsafe_hash=True``; this will result in a :exc:"
"`TypeError`."
msgstr ""
"Aqui estão as regras que governam a criação implícita de um método :meth:`!"
"__hash__`. Note que não pode ter um método :meth:`!__hash__` explícito na "
"sua classe de dados e definir ``unsafe_hash=True``; isto resultará num :exc:"
"`TypeError`."

#: ../../library/dataclasses.rst:155
msgid ""
"If *eq* and *frozen* are both true, by default ``@dataclass`` will generate "
"a :meth:`!__hash__` method for you.  If *eq* is true and *frozen* is false, :"
"meth:`!__hash__` will be set to ``None``, marking it unhashable (which it "
"is, since it is mutable).  If *eq* is false, :meth:`!__hash__` will be left "
"untouched meaning the :meth:`!__hash__` method of the superclass will be "
"used (if the superclass is :class:`object`, this means it will fall back to "
"id-based hashing)."
msgstr ""
"Se *eq* e *frozen* forem ambos verdadeiros, por predefinição, ``@dataclass`` "
"gerará um método :meth:`!__hash__` para si. Se *eq* for verdadeiro e "
"*frozen* for falso, :meth:`!__hash__` será definido como ``None``, marcando-"
"o como não-hashable (o que é verdade, uma vez que é mutável). Se *eq* for "
"falso, :meth:`!__hash__` será deixado inalterado, significando que o método :"
"meth:`!__hash__` da superclasse será usado (se a superclasse for :class:"
"`object`, isto significa que recuará para hashing baseado em ID)."

#: ../../library/dataclasses.rst:163
msgid ""
"*frozen*: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances. See the :"
"ref:`discussion <dataclasses-frozen>` below."
msgstr ""
"*frozen*: Se verdadeiro (a predefinição é ``False``), atribuir valores aos "
"campos gerará uma exceção. Isto emula instâncias congeladas de apenas "
"leitura. Veja a :ref:`discussão <dataclasses-frozen>` abaixo."

#: ../../library/dataclasses.rst:167
msgid ""
"If :meth:`~object.__setattr__` or :meth:`~object.__delattr__` is defined in "
"the class and *frozen* is true, then :exc:`TypeError` is raised."
msgstr ""
"Se :meth:`~object.__setattr__` ou :meth:`~object.__delattr__` estiver "
"definido na classe e *frozen* for verdadeiro, então é lançada uma exceção :"
"exc:`TypeError`."

#: ../../library/dataclasses.rst:170
msgid ""
"*match_args*: If true (the default is ``True``), the :attr:`~object."
"__match_args__` tuple will be created from the list of non keyword-only "
"parameters to the generated :meth:`~object.__init__` method (even if :meth:`!"
"__init__` is not generated, see above).  If false, or if :attr:`!"
"__match_args__` is already defined in the class, then :attr:`!"
"__match_args__` will not be generated."
msgstr ""
"*match_args*: Se verdadeiro (a predefinição é ``True``), o tuplo :attr:"
"`~object.__match_args__` será criado a partir da lista de parâmetros não "
"apenas por palavra-chave para o método :meth:`~object.__init__` gerado "
"(mesmo que :meth:`!__init__` não seja gerado, veja acima). Se falso, ou se :"
"attr:`!__match_args__` já estiver definido na classe, então :attr:`!"
"__match_args__` não será gerado."

#: ../../library/dataclasses.rst:179
msgid ""
"*kw_only*: If true (the default value is ``False``), then all fields will be "
"marked as keyword-only.  If a field is marked as keyword-only, then the only "
"effect is that the :meth:`~object.__init__` parameter generated from a "
"keyword-only field must be specified with a keyword when :meth:`!__init__` "
"is called. See the :term:`parameter` glossary entry for details.  Also see "
"the :const:`KW_ONLY` section."
msgstr ""
"*kw_only*: Se verdadeiro (o valor predefinido é ``False``), então todos os "
"campos serão marcados como apenas por palavra-chave. Se um campo for marcado "
"como apenas por palavra-chave, então o único efeito é que o parâmetro :meth:"
"`~object.__init__` gerado a partir de um campo apenas por palavra-chave deve "
"ser especificado com uma palavra-chave quando :meth:`!__init__` for chamado. "
"Veja a entrada :term:`parameter` no glossário para mais detalhes. Veja "
"também a secção :const:`KW_ONLY`."

#: ../../library/dataclasses.rst:187
msgid "Keyword-only fields are not included in :attr:`!__match_args__`."
msgstr ""
"Campos apenas por palavra-chave não são incluídos em :attr:`!__match_args__`."

#: ../../library/dataclasses.rst:191
msgid ""
"*slots*: If true (the default is ``False``), :attr:`~object.__slots__` "
"attribute will be generated and new class will be returned instead of the "
"original one. If :attr:`!__slots__` is already defined in the class, then :"
"exc:`TypeError` is raised."
msgstr ""
"*slots*: Se verdadeiro (a predefinição é ``False``), o atributo :attr:"
"`~object.__slots__` será gerado e uma nova classe será retornada em vez da "
"original. Se :attr:`!__slots__` já estiver definido na classe, então é "
"lançada uma exceção :exc:`TypeError`."

#: ../../library/dataclasses.rst:197
msgid ""
"Calling no-arg :func:`super` in dataclasses using ``slots=True`` will result "
"in the following exception being raised: ``TypeError: super(type, obj): obj "
"must be an instance or subtype of type``. The two-arg :func:`super` is a "
"valid workaround. See :gh:`90562` for full details."
msgstr ""

#: ../../library/dataclasses.rst:204
msgid ""
"Passing parameters to a base class :meth:`~object.__init_subclass__` when "
"using ``slots=True`` will result in a :exc:`TypeError`. Either use "
"``__init_subclass__`` with no parameters or use default values as a "
"workaround. See :gh:`91126` for full details."
msgstr ""
"Passar parâmetros para um método :meth:`~object.__init_subclass__` de uma "
"classe base ao usar ``slots=True`` resultará num :exc:`TypeError`. Use "
"``__init_subclass__`` sem parâmetros ou use valores predefinidos como "
"solução alternativa. Veja :gh:`91126` para mais detalhes."

#: ../../library/dataclasses.rst:212
msgid ""
"If a field name is already included in the :attr:`!__slots__` of a base "
"class, it will not be included in the generated :attr:`!__slots__` to "
"prevent :ref:`overriding them <datamodel-note-slots>`. Therefore, do not "
"use :attr:`!__slots__` to retrieve the field names of a dataclass. Use :func:"
"`fields` instead. To be able to determine inherited slots, base class :attr:"
"`!__slots__` may be any iterable, but *not* an iterator."
msgstr ""
"Se um nome de campo já estiver incluído no :attr:`!__slots__` de uma classe "
"base, não será incluído no :attr:`!__slots__` gerado para evitar :ref:"
"`substituí-los <datamodel-note-slots>`. Portanto, não use :attr:`!__slots__` "
"para recuperar os nomes dos campos de uma classe de dados. Use :func:"
"`fields` em vez disso. Para ser capaz de determinar slots herdados, o :attr:"
"`!__slots__` da classe base pode ser qualquer iterável, mas *não* um "
"iterador."

#: ../../library/dataclasses.rst:222
msgid ""
"*weakref_slot*: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance :func:`weakref-able "
"<weakref.ref>`. It is an error to specify ``weakref_slot=True`` without also "
"specifying ``slots=True``."
msgstr ""
"*weakref_slot*: Se verdadeiro (a predefinição é ``False``), adiciona um slot "
"chamado \"__weakref__\", que é necessário para tornar uma instância :func:"
"`weakref-able <weakref.ref>`. É um erro especificar ``weakref_slot=True`` "
"sem também especificar ``slots=True``."

#: ../../library/dataclasses.rst:230
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr ""
"Os ``field``s podem opcionalmente especificar um valor predefinido, usando a "
"sintaxe normal do Python::"

#: ../../library/dataclasses.rst:233
msgid ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' has no default value\n"
"    b: int = 0   # assign a default value for 'b'"
msgstr ""
"@dataclass\n"
"class C:\n"
"    a: int       # 'a' não tem valor predefinido\n"
"    b: int = 0   # atribuir um valor predefinido para 'b'"

#: ../../library/dataclasses.rst:238
msgid ""
"In this example, both :attr:`!a` and :attr:`!b` will be included in the "
"added :meth:`~object.__init__` method, which will be defined as::"
msgstr ""
"Neste exemplo, tanto :attr:`!a` como :attr:`!b` serão incluídos no método :"
"meth:`~object.__init__` adicionado, que será definido como::"

#: ../../library/dataclasses.rst:241
msgid "def __init__(self, a: int, b: int = 0):"
msgstr "def __init__(self, a: int, b: int = 0):"

#: ../../library/dataclasses.rst:243
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
"Uma exceção :exc:`TypeError` será lançada se um campo sem valor predefinido "
"seguir um campo com valor predefinido. Isto é verdadeiro quer ocorra numa "
"única classe, quer como resultado de herança de classe."

#: ../../library/dataclasses.rst:249
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`!field` "
"function.  For example::"
msgstr ""
"Para casos de uso comuns e simples, nenhuma outra funcionalidade é "
"necessária. Existem, no entanto, algumas funcionalidades de classes de dados "
"que requerem informação adicional por campo. Para satisfazer esta "
"necessidade de informação adicional, pode substituir o valor predefinido do "
"campo por uma chamada à função :func:`!field` fornecida. Por exemplo::"

#: ../../library/dataclasses.rst:255
msgid ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"
msgstr ""
"@dataclass\n"
"class C:\n"
"    mylist: list[int] = field(default_factory=list)\n"
"\n"
"c = C()\n"
"c.mylist += [1, 2, 3]"

#: ../../library/dataclasses.rst:262
msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"Como mostrado acima, o valor :const:`MISSING` é um objeto sentinela usado "
"para detetar se alguns parâmetros são fornecidos pelo utilizador. Este "
"sentinela é usado porque ``None`` é um valor válido para alguns parâmetros "
"com um significado distinto. Nenhum código deve usar diretamente o valor :"
"const:`MISSING`."

#: ../../library/dataclasses.rst:267
msgid "The parameters to :func:`!field` are:"
msgstr "Os parâmetros para :func:`!field` são:"

#: ../../library/dataclasses.rst:269
msgid ""
"*default*: If provided, this will be the default value for this field.  This "
"is needed because the :func:`!field` call itself replaces the normal "
"position of the default value."
msgstr ""
"*default*: Se fornecido, este será o valor predefinido para este campo. Isto "
"é necessário porque a chamada :func:`!field` substitui a posição normal do "
"valor predefinido."

#: ../../library/dataclasses.rst:273
msgid ""
"*default_factory*: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both *default* and "
"*default_factory*."
msgstr ""
"*default_factory*: Se fornecido, deve ser um objeto invocável sem argumentos "
"que será chamado quando um valor predefinido for necessário para este campo. "
"Entre outras finalidades, isto pode ser usado para especificar campos com "
"valores predefinidos mutáveis, como discutido abaixo. É um erro especificar "
"tanto *default* como *default_factory*."

#: ../../library/dataclasses.rst:279
msgid ""
"*init*: If true (the default), this field is included as a parameter to the "
"generated :meth:`~object.__init__` method."
msgstr ""
"*init*: Se verdadeiro (predefinição), este campo é incluído como parâmetro "
"no método :meth:`~object.__init__` gerado."

#: ../../library/dataclasses.rst:282
msgid ""
"*repr*: If true (the default), this field is included in the string returned "
"by the generated :meth:`~object.__repr__` method."
msgstr ""
"*repr*: Se verdadeiro (predefinição), este campo é incluído na string "
"retornada pelo método :meth:`~object.__repr__` gerado."

#: ../../library/dataclasses.rst:285
msgid ""
"*hash*: This can be a bool or ``None``.  If true, this field is included in "
"the generated :meth:`~object.__hash__` method.  If false, this field is "
"excluded from the generated :meth:`~object.__hash__`. If ``None`` (the "
"default), use the value of *compare*: this would normally be the expected "
"behavior, since a field should be included in the hash if it's used for "
"comparisons.  Setting this value to anything other than ``None`` is "
"discouraged."
msgstr ""
"*hash*: Pode ser um booleano ou ``None``. Se verdadeiro, este campo é "
"incluído no método :meth:`~object.__hash__` gerado. Se falso, este campo é "
"excluído do método :meth:`~object.__hash__` gerado. Se ``None`` "
"(predefinição), usa o valor de *compare*: este seria normalmente o "
"comportamento esperado, uma vez que um campo deve ser incluído no hash se "
"for usado para comparações. Definir este valor para algo diferente de "
"``None`` é desencorajado."

#: ../../library/dataclasses.rst:293
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"Uma possível razão para definir ``hash=False`` mas ``compare=True`` seria se "
"um campo for dispendioso para calcular um valor de hash, esse campo for "
"necessário para testes de igualdade, e existirem outros campos que "
"contribuam para o valor de hash do tipo. Mesmo que um campo seja excluído do "
"hash, ainda será usado para comparações."

#: ../../library/dataclasses.rst:299
msgid ""
"*compare*: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, et al.)."
msgstr ""
"*compare*: Se verdadeiro (predefinição), este campo é incluído nos métodos "
"de igualdade e comparação gerados (:meth:`~object.__eq__`, :meth:`~object."
"__gt__`, etc.)."

#: ../../library/dataclasses.rst:303
msgid ""
"*metadata*: This can be a mapping or ``None``. ``None`` is treated as an "
"empty dict.  This value is wrapped in :func:`~types.MappingProxyType` to "
"make it read-only, and exposed on the :class:`Field` object. It is not used "
"at all by Data Classes, and is provided as a third-party extension "
"mechanism. Multiple third-parties can each have their own key, to use as a "
"namespace in the metadata."
msgstr ""
"*metadata*: Pode ser um mapeamento ou ``None``. ``None`` é tratado como um "
"dicionário vazio. Este valor é envolvido em :func:`~types.MappingProxyType` "
"para torná-lo apenas de leitura, e exposto no objeto :class:`Field`. Não é "
"usado de todo pelas Classes de Dados, e é fornecido como um mecanismo de "
"extensão para terceiros. Vários terceiros podem ter cada um a sua própria "
"chave, para usar como um espaço de nomes nos metadados."

#: ../../library/dataclasses.rst:311
msgid ""
"*kw_only*: If true, this field will be marked as keyword-only. This is used "
"when the generated :meth:`~object.__init__` method's parameters are computed."
msgstr ""
"*kw_only*: Se verdadeiro, este campo será marcado como apenas por palavra-"
"chave. Isto é usado quando os parâmetros do método :meth:`~object.__init__` "
"gerado são calculados."

#: ../../library/dataclasses.rst:315
msgid "Keyword-only fields are also not included in :attr:`!__match_args__`."
msgstr ""
"Campos apenas por palavra-chave também não são incluídos em :attr:`!"
"__match_args__`."

#: ../../library/dataclasses.rst:319
msgid ""
"If the default value of a field is specified by a call to :func:`!field`, "
"then the class attribute for this field will be replaced by the specified "
"*default* value.  If *default* is not provided, then the class attribute "
"will be deleted.  The intent is that after the :deco:`dataclass` decorator "
"runs, the class attributes will all contain the default values for the "
"fields, just as if the default value itself were specified.  For example, "
"after::"
msgstr ""
"Se o valor predefinido de um campo for especificado por uma chamada a :func:"
"`!field`, então o atributo de classe para este campo será substituído pelo "
"valor *default* especificado. Se *default* não for fornecido, então o "
"atributo de classe será eliminado. A intenção é que, após o decorador :deco:"
"`dataclass` ser executado, os atributos de classe conterão todos os valores "
"predefinidos para os campos, como se o valor predefinido em si fosse "
"especificado. Por exemplo, após::"

#: ../../library/dataclasses.rst:328
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"
msgstr ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: int = field(repr=False)\n"
"    z: int = field(repr=False, default=10)\n"
"    t: int = 20"

#: ../../library/dataclasses.rst:335
msgid ""
"The class attribute :attr:`!C.z` will be ``10``, the class attribute :attr:`!"
"C.t` will be ``20``, and the class attributes :attr:`!C.x` and :attr:`!C.y` "
"will not be set."
msgstr ""
"O atributo de classe :attr:`!C.z` será ``10``, o atributo de classe :attr:`!"
"C.t` será ``20``, e os atributos de classe :attr:`!C.x` e :attr:`!C.y` não "
"serão definidos."

#: ../../library/dataclasses.rst:341
msgid ""
":class:`!Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`!Field` object "
"directly.  Its documented attributes are:"
msgstr ""
"Os objetos :class:`!Field` descrevem cada campo definido. Estes objetos são "
"criados internamente e são retornados pelo método :func:`fields` ao nível do "
"módulo (veja abaixo). Os utilizadores nunca devem instanciar diretamente um "
"objeto :class:`!Field`. Os seus atributos documentados são:"

#: ../../library/dataclasses.rst:346
msgid ":attr:`!name`: The name of the field."
msgstr ":attr:`!name`: O nome do campo."

#: ../../library/dataclasses.rst:347
msgid ":attr:`!type`: The type of the field."
msgstr ":attr:`!type`: O tipo do campo."

#: ../../library/dataclasses.rst:348
msgid ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only` have "
"the identical meaning and values as they do in the :func:`field` function."
msgstr ""
":attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :"
"attr:`!hash`, :attr:`!compare`, :attr:`!metadata` e :attr:`!kw_only` têm o "
"mesmo significado e valores que na função :func:`field`."

#: ../../library/dataclasses.rst:352
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr ""
"Outros atributos podem existir, mas são privados e não devem ser "
"inspecionados ou dependidos."

#: ../../library/dataclasses.rst:357
msgid ""
"``InitVar[T]`` type annotations describe variables that are :ref:`init-only "
"<dataclasses-init-only-variables>`. Fields annotated with :class:`!InitVar` "
"are considered pseudo-fields, and thus are neither returned by the :func:"
"`fields` function nor used in any way except adding them as parameters to :"
"meth:`~object.__init__` and an optional :meth:`__post_init__`."
msgstr ""
"As anotações de tipo ``InitVar[T]`` descrevem variáveis que são :ref:`apenas "
"de inicialização <dataclasses-init-only-variables>`. Campos anotados com :"
"class:`!InitVar` são considerados pseudo-campos e, como tal, não são "
"retornados pela função :func:`fields` nem usados de qualquer outra forma, "
"exceto adicioná-los como parâmetros a :meth:`~object.__init__` e um "
"opcional :meth:`__post_init__`."

#: ../../library/dataclasses.rst:366
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"Retorna um tuplo de objetos :class:`Field` que definem os campos para esta "
"classe de dados. Aceita uma classe de dados ou uma instância de uma classe "
"de dados. Lança :exc:`TypeError` se não for passada uma classe de dados ou "
"uma instância de uma. Não retorna pseudo-campos que são ``ClassVar`` ou "
"``InitVar``."

#: ../../library/dataclasses.rst:373
msgid ""
"Converts the dataclass *obj* to a dict (by using the factory function "
"*dict_factory*).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Converte a classe de dados *obj* num dicionário (usando a função fábrica "
"*dict_factory*). Cada classe de dados é convertida num dicionário dos seus "
"campos, como pares ``name: value``. Classes de dados, dicionários, listas e "
"tuplos são percorridos recursivamente. Outros objetos são copiados com :func:"
"`copy.deepcopy`."

#: ../../library/dataclasses.rst:379
msgid "Example of using :func:`!asdict` on nested dataclasses::"
msgstr "Exemplo de uso de :func:`!asdict` em classes de dados aninhadas::"

#: ../../library/dataclasses.rst:381
msgid ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"
msgstr ""
"@dataclass\n"
"class Point:\n"
"     x: int\n"
"     y: int\n"
"\n"
"@dataclass\n"
"class C:\n"
"     mylist: list[Point]\n"
"\n"
"p = Point(10, 20)\n"
"assert asdict(p) == {'x': 10, 'y': 20}\n"
"\n"
"c = C([Point(0, 0), Point(10, 4)])\n"
"assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}"

#: ../../library/dataclasses.rst:396 ../../library/dataclasses.rst:416
msgid "To create a shallow copy, the following workaround may be used::"
msgstr ""
"Para criar uma cópia superficial, a seguinte solução alternativa pode ser "
"usada::"

#: ../../library/dataclasses.rst:398
msgid "{field.name: getattr(obj, field.name) for field in fields(obj)}"
msgstr "{field.name: getattr(obj, field.name) for field in fields(obj)}"

#: ../../library/dataclasses.rst:400
msgid ""
":func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass instance."
msgstr ""
":func:`!asdict` lança :exc:`TypeError` se *obj* não for uma instância de "
"classe de dados."

#: ../../library/dataclasses.rst:405
msgid ""
"Converts the dataclass *obj* to a tuple (by using the factory function "
"*tuple_factory*).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Converte a classe de dados *obj* num tuplo (usando a função fábrica "
"*tuple_factory*). Cada classe de dados é convertida num tuplo dos seus "
"valores de campo. Classes de dados, dicionários, listas e tuplos são "
"percorridos recursivamente. Outros objetos são copiados com :func:`copy."
"deepcopy`."

#: ../../library/dataclasses.rst:411
msgid "Continuing from the previous example::"
msgstr "Continuando do exemplo anterior::"

#: ../../library/dataclasses.rst:413
msgid ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"
msgstr ""
"assert astuple(p) == (10, 20)\n"
"assert astuple(c) == ([(0, 0), (10, 4)],)"

#: ../../library/dataclasses.rst:418
msgid "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"
msgstr "tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))"

#: ../../library/dataclasses.rst:420
msgid ""
":func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass "
"instance."
msgstr ""
":func:`!astuple` lança :exc:`TypeError` se *obj* não for uma instância de "
"classe de dados."

#: ../../library/dataclasses.rst:425
msgid ""
"Creates a new dataclass with name *cls_name*, fields as defined in *fields*, "
"base classes as given in *bases*, and initialized with a namespace as given "
"in *namespace*.  *fields* is an iterable whose elements are each either "
"``name``, ``(name, type)``, or ``(name, type, Field)``.  If just ``name`` is "
"supplied, :data:`typing.Any` is used for ``type``.  The values of *init*, "
"*repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, *kw_only*, "
"*slots*, and *weakref_slot* have the same meaning as they do in :deco:"
"`dataclass`."
msgstr ""
"Cria uma nova classe de dados com o nome *cls_name*, campos definidos em "
"*fields*, classes base dadas em *bases*, e inicializada com um espaço de "
"nomes como dado em *namespace*. *fields* é um iterável cujos elementos são "
"cada um ``name``, ``(name, type)`` ou ``(name, type, Field)``. Se apenas "
"``name`` for fornecido, :data:`typing.Any` é usado para ``type``. Os valores "
"de *init*, *repr*, *eq*, *order*, *unsafe_hash*, *frozen*, *match_args*, "
"*kw_only*, *slots* e *weakref_slot* têm o mesmo significado que em :deco:"
"`dataclass`."

#: ../../library/dataclasses.rst:435
msgid ""
"If *module* is defined, the :attr:`!__module__` attribute of the dataclass "
"is set to that value. By default, it is set to the module name of the caller."
msgstr ""
"Se *module* for definido, o atributo :attr:`!__module__` da classe de dados "
"é definido para esse valor. Por predefinição, é definido para o nome do "
"módulo do chamador."

#: ../../library/dataclasses.rst:439
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with :attr:`!__annotations__` can then apply the :deco:"
"`dataclass` function to convert that class to a dataclass.  This function is "
"provided as a convenience.  For example::"
msgstr ""

#: ../../library/dataclasses.rst:445
msgid ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"
msgstr ""
"C = make_dataclass('C',\n"
"                   [('x', int),\n"
"                     'y',\n"
"                    ('z', int, field(default=5))],\n"
"                   namespace={'add_one': lambda self: self.x + 1})"

#: ../../library/dataclasses.rst:451
msgid "Is equivalent to::"
msgstr "É equivalente a::"

#: ../../library/dataclasses.rst:453
msgid ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"
msgstr ""
"@dataclass\n"
"class C:\n"
"    x: int\n"
"    y: 'typing.Any'\n"
"    z: int = 5\n"
"\n"
"    def add_one(self):\n"
"        return self.x + 1"

#: ../../library/dataclasses.rst:464
msgid ""
"Creates a new object of the same type as *obj*, replacing fields with values "
"from *changes*.  If *obj* is not a Data Class, raises :exc:`TypeError`.  If "
"keys in *changes* are not field names of the given dataclass, raises :exc:"
"`TypeError`."
msgstr ""
"Cria um novo objeto do mesmo tipo que *obj*, substituindo campos com valores "
"de *changes*. Se *obj* não for uma Classe de Dados, lança :exc:`TypeError`. "
"Se as chaves em *changes* não forem nomes de campos da classe de dados dada, "
"lança :exc:`TypeError`."

#: ../../library/dataclasses.rst:469
msgid ""
"The newly returned object is created by calling the :meth:`~object.__init__` "
"method of the dataclass.  This ensures that :meth:`__post_init__`, if "
"present, is also called."
msgstr ""
"O novo objeto retornado é criado chamando o método :meth:`~object.__init__` "
"da classe de dados. Isto garante que :meth:`__post_init__`, se presente, "
"também é chamado."

#: ../../library/dataclasses.rst:473
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`!replace` so that they can be passed to :meth:`!"
"__init__` and :meth:`__post_init__`."
msgstr ""
"Variáveis apenas de inicialização sem valores predefinidos, se existirem, "
"devem ser especificadas na chamada para :func:`!replace` para que possam ser "
"passadas para :meth:`!__init__` e :meth:`__post_init__`."

#: ../../library/dataclasses.rst:477
msgid ""
"It is an error for *changes* to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"É um erro se *changes* contiver quaisquer campos definidos como tendo "
"``init=False``. Uma exceção :exc:`ValueError` será lançada neste caso."

#: ../../library/dataclasses.rst:481
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:`!"
"replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom :func:`!replace` (or similarly named) method which handles "
"instance copying."
msgstr ""
"Esteja avisado sobre como os campos ``init=False`` funcionam durante uma "
"chamada para :func:`!replace`. Eles não são copiados do objeto de origem, "
"mas sim inicializados em :meth:`__post_init__`, se forem inicializados. "
"Espera-se que os campos ``init=False`` sejam usados raramente e com "
"discernimento. Se forem usados, pode ser sábio ter construtores de classe "
"alternativos, ou talvez um método personalizado :func:`!replace` (ou com "
"nome semelhante) que trate da cópia de instâncias."

#: ../../library/dataclasses.rst:490
msgid ""
"Dataclass instances are also supported by generic function :func:`copy."
"replace`."
msgstr ""
"Instâncias de classes de dados também são suportadas pela função genérica :"
"func:`copy.replace`."

#: ../../library/dataclasses.rst:494
msgid ""
"Return ``True`` if its parameter is a dataclass (including subclasses of a "
"dataclass) or an instance of one, otherwise return ``False``."
msgstr ""
"Retorna ``True`` se o seu parâmetro for uma classe de dados (incluindo "
"subclasses de uma classe de dados) ou uma instância de uma, caso contrário "
"retorna ``False``."

#: ../../library/dataclasses.rst:497
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"Se precisar de saber se uma classe é uma instância de uma classe de dados (e "
"não uma classe de dados em si), então adicione uma verificação adicional "
"para ``not isinstance(obj, type)``::"

#: ../../library/dataclasses.rst:501
msgid ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"
msgstr ""
"def is_dataclass_instance(obj):\n"
"    return is_dataclass(obj) and not isinstance(obj, type)"

#: ../../library/dataclasses.rst:506
msgid "A sentinel value signifying a missing default or default_factory."
msgstr ""
"Um valor sentinela que significa um valor predefinido ou default_factory em "
"falta."

#: ../../library/dataclasses.rst:510
msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`!KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`!KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`!KW_ONLY` field.  Keyword-only fields signify :"
"meth:`~object.__init__` parameters that must be specified as keywords when "
"the class is instantiated."
msgstr ""
"Um valor sentinela usado como uma anotação de tipo. Qualquer campo após um "
"pseudo-campo com o tipo :const:`!KW_ONLY` é marcado como um campo apenas por "
"palavra-chave. Note que um pseudo-campo do tipo :const:`!KW_ONLY` é, de "
"outra forma, completamente ignorado. Isto inclui o nome de tal campo. Por "
"convenção, um nome de ``_`` é usado para um campo :const:`!KW_ONLY`. Campos "
"apenas por palavra-chave significam parâmetros :meth:`~object.__init__` que "
"devem ser especificados como palavras-chave quando a classe é instanciada."

#: ../../library/dataclasses.rst:519
msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr ""
"Neste exemplo, os campos ``y`` e ``z`` serão marcados como campos apenas por "
"palavra-chave::"

#: ../../library/dataclasses.rst:521
msgid ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"
msgstr ""
"@dataclass\n"
"class Point:\n"
"    x: float\n"
"    _: KW_ONLY\n"
"    y: float\n"
"    z: float\n"
"\n"
"p = Point(0, y=1.5, z=2.0)"

#: ../../library/dataclasses.rst:530
msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`!KW_ONLY`."
msgstr ""
"Numa única classe de dados, é um erro especificar mais do que um campo cujo "
"tipo é :const:`!KW_ONLY`."

#: ../../library/dataclasses.rst:537
msgid ""
"Raised when an implicitly defined :meth:`~object.__setattr__` or :meth:"
"`~object.__delattr__` is called on a dataclass which was defined with "
"``frozen=True``. It is a subclass of :exc:`AttributeError`."
msgstr ""
"Lançada quando um :meth:`~object.__setattr__` ou :meth:`~object.__delattr__` "
"implicitamente definido é chamado numa classe de dados que foi definida com "
"``frozen=True``. É uma subclasse de :exc:`AttributeError`."

#: ../../library/dataclasses.rst:544
msgid "Post-init processing"
msgstr "Processamento pós-inicialização"

#: ../../library/dataclasses.rst:548
msgid ""
"When defined on the class, it will be called by the generated :meth:`~object."
"__init__`, normally as :meth:`!self.__post_init__`. However, if any "
"``InitVar`` fields are defined, they will also be passed to :meth:`!"
"__post_init__` in the order they were defined in the class.  If no :meth:`!"
"__init__` method is generated, then :meth:`!__post_init__` will not "
"automatically be called."
msgstr ""
"Quando definido na classe, será chamado pelo método :meth:`~object.__init__` "
"gerado, normalmente como :meth:`!self.__post_init__`. No entanto, se "
"quaisquer campos ``InitVar`` forem definidos, eles também serão passados "
"para :meth:`!__post_init__` na ordem em que foram definidos na classe. Se "
"nenhum método :meth:`!__init__` for gerado, então :meth:`!__post_init__` não "
"será chamado automaticamente."

#: ../../library/dataclasses.rst:555
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"Entre outros usos, isto permite inicializar valores de campo que dependem de "
"um ou mais outros campos. Por exemplo::"

#: ../../library/dataclasses.rst:558
msgid ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"
msgstr ""
"@dataclass\n"
"class C:\n"
"    a: float\n"
"    b: float\n"
"    c: float = field(init=False)\n"
"\n"
"    def __post_init__(self):\n"
"        self.c = self.a + self.b"

#: ../../library/dataclasses.rst:567
msgid ""
"The :meth:`~object.__init__` method generated by :deco:`dataclass` does not "
"call base class :meth:`!__init__` methods. If the base class has an :meth:`!"
"__init__` method that has to be called, it is common to call this method in "
"a :meth:`__post_init__` method::"
msgstr ""
"O método :meth:`~object.__init__` gerado por :deco:`dataclass` não chama "
"métodos :meth:`!__init__` da classe base. Se a classe base tiver um método :"
"meth:`!__init__` que precisa ser chamado, é comum chamar este método num "
"método :meth:`__post_init__`::"

#: ../../library/dataclasses.rst:572
msgid ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"        self.height = height\n"
"        self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"
msgstr ""
"class Rectangle:\n"
"    def __init__(self, height, width):\n"
"        self.height = height\n"
"        self.width = width\n"
"\n"
"@dataclass\n"
"class Square(Rectangle):\n"
"    side: float\n"
"\n"
"    def __post_init__(self):\n"
"        super().__init__(self.side, self.side)"

#: ../../library/dataclasses.rst:584
msgid ""
"Note, however, that in general the dataclass-generated :meth:`!__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"Note, no entanto, que em geral os métodos :meth:`!__init__` gerados pela "
"classe de dados não precisam ser chamados, uma vez que a classe de dados "
"derivada cuidará da inicialização de todos os campos de qualquer classe base "
"que seja uma classe de dados."

#: ../../library/dataclasses.rst:588
msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`!__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"Veja a secção abaixo sobre variáveis apenas de inicialização para formas de "
"passar parâmetros para :meth:`!__post_init__`. Veja também o aviso sobre "
"como :func:`replace` trata campos ``init=False``."

#: ../../library/dataclasses.rst:595
msgid "Class variables"
msgstr "Variáveis de classe"

#: ../../library/dataclasses.rst:597
msgid ""
"One of the few places where :deco:`dataclass` actually inspects the type of "
"a field is to determine if a field is a class variable as defined in :pep:"
"`526`.  It does this by checking if the type of the field is :data:`typing."
"ClassVar`.  If a field is a ``ClassVar``, it is excluded from consideration "
"as a field and is ignored by the dataclass mechanisms.  Such ``ClassVar`` "
"pseudo-fields are not returned by the module-level :func:`fields` function."
msgstr ""
"Um dos poucos locais onde :deco:`dataclass` realmente inspeciona o tipo de "
"um campo é para determinar se um campo é uma variável de classe conforme "
"definido em :pep:`526`. Faz isto verificando se o tipo do campo é :data:"
"`typing.ClassVar`. Se um campo for um ``ClassVar``, é excluído da "
"consideração como um campo e é ignorado pelos mecanismos de classe de dados. "
"Tais pseudo-campos ``ClassVar`` não são retornados pela função :func:"
"`fields` ao nível do módulo."

#: ../../library/dataclasses.rst:608
msgid "Init-only variables"
msgstr "Variáveis apenas de inicialização"

#: ../../library/dataclasses.rst:610
msgid ""
"Another place where :deco:`dataclass` inspects a type annotation is to "
"determine if a field is an init-only variable.  It does this by seeing if "
"the type of a field is of type :class:`InitVar`.  If a field is an :class:"
"`InitVar`, it is considered a pseudo-field called an init-only field.  As it "
"is not a true field, it is not returned by the module-level :func:`fields` "
"function.  Init-only fields are added as parameters to the generated :meth:"
"`~object.__init__` method, and are passed to the optional :meth:"
"`__post_init__` method.  They are not otherwise used by dataclasses."
msgstr ""
"Outro local onde :deco:`dataclass` inspeciona uma anotação de tipo é para "
"determinar se um campo é uma variável apenas de inicialização. Faz isto "
"verificando se o tipo de um campo é do tipo :class:`InitVar`. Se um campo "
"for um :class:`InitVar`, é considerado um pseudo-campo chamado campo apenas "
"de inicialização. Como não é um campo verdadeiro, não é retornado pela "
"função :func:`fields` ao nível do módulo. Campos apenas de inicialização são "
"adicionados como parâmetros ao método :meth:`~object.__init__` gerado e são "
"passados ao método opcional :meth:`__post_init__`. Não são usados de outra "
"forma pelas classes de dados."

#: ../../library/dataclasses.rst:620
msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr ""
"Por exemplo, suponha que um campo será inicializado a partir de uma base de "
"dados, se um valor não for fornecido ao criar a classe::"

#: ../../library/dataclasses.rst:623
msgid ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"
msgstr ""
"@dataclass\n"
"class C:\n"
"    i: int\n"
"    j: int | None = None\n"
"    database: InitVar[DatabaseType | None] = None\n"
"\n"
"    def __post_init__(self, database):\n"
"        if self.j is None and database is not None:\n"
"            self.j = database.lookup('j')\n"
"\n"
"c = C(10, database=my_database)"

#: ../../library/dataclasses.rst:635
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for :attr:`!"
"i` and :attr:`!j`, but not for :attr:`!database`."
msgstr ""
"Neste caso, :func:`fields` retornará objetos :class:`Field` para :attr:`!i` "
"e :attr:`!j`, mas não para :attr:`!database`."

#: ../../library/dataclasses.rst:641
msgid "Frozen instances"
msgstr "Instâncias congeladas"

#: ../../library/dataclasses.rst:643
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :deco:`dataclass` decorator you can emulate "
"immutability.  In that case, dataclasses will add :meth:`~object."
"__setattr__` and :meth:`~object.__delattr__` methods to the class.  These "
"methods will raise a :exc:`FrozenInstanceError` when invoked."
msgstr ""
"Não é possível criar objetos Python verdadeiramente imutáveis. No entanto, "
"ao passar ``frozen=True`` para o decorador :deco:`dataclass`, pode emular "
"imutabilidade. Nesse caso, as classes de dados adicionarão métodos :meth:"
"`~object.__setattr__` e :meth:`~object.__delattr__` à classe. Estes métodos "
"lançarão uma exceção :exc:`FrozenInstanceError` quando invocados."

#: ../../library/dataclasses.rst:649
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`~object.__init__` cannot use simple assignment to initialize fields, and "
"must use :meth:`!object.__setattr__`."
msgstr ""
"Existe uma pequena penalização de desempenho ao usar ``frozen=True``: :meth:"
"`~object.__init__` não pode usar atribuição simples para inicializar campos, "
"e deve usar :meth:`!object.__setattr__`."

#: ../../library/dataclasses.rst:658
msgid "Inheritance"
msgstr "Herança"

#: ../../library/dataclasses.rst:660
msgid ""
"When the dataclass is being created by the :deco:`dataclass` decorator, it "
"looks through all of the class's base classes in reverse MRO (that is, "
"starting at :class:`object`) and, for each dataclass that it finds, adds the "
"fields from that base class to an ordered mapping of fields. After all of "
"the base class fields are added, it adds its own fields to the ordered "
"mapping.  All of the generated methods will use this combined, calculated "
"ordered mapping of fields.  Because the fields are in insertion order, "
"derived classes override base classes.  An example::"
msgstr ""
"Quando a classe de dados está a ser criada pelo decorador :deco:`dataclass`, "
"este procura todas as classes base da classe em MRO inverso (ou seja, "
"começando em :class:`object`) e, para cada classe de dados que encontrar, "
"adiciona os campos dessa classe base a um mapeamento ordenado de campos. "
"Depois de todos os campos da classe base serem adicionados, adiciona os seus "
"próprios campos ao mapeamento ordenado. Todos os métodos gerados usarão este "
"mapeamento ordenado combinado e calculado de campos. Como os campos estão na "
"ordem de inserção, as classes derivadas substituem as classes base. Um "
"exemplo::"

#: ../../library/dataclasses.rst:670
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"
msgstr ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    y: int = 0\n"
"\n"
"@dataclass\n"
"class C(Base):\n"
"    z: int = 10\n"
"    x: int = 15"

#: ../../library/dataclasses.rst:680
msgid ""
"The final list of fields is, in order, :attr:`!x`, :attr:`!y`, :attr:`!z`.  "
"The final type of :attr:`!x` is :class:`int`, as specified in class :class:`!"
"C`."
msgstr ""
"A lista final de campos é, por ordem, :attr:`!x`, :attr:`!y`, :attr:`!z`. O "
"tipo final de :attr:`!x` é :class:`int`, conforme especificado na classe :"
"class:`!C`."

#: ../../library/dataclasses.rst:683
msgid ""
"The generated :meth:`~object.__init__` method for :class:`!C` will look "
"like::"
msgstr "O método :meth:`~object.__init__` gerado para :class:`!C` será como::"

#: ../../library/dataclasses.rst:685
msgid "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"
msgstr "def __init__(self, x: int = 15, y: int = 0, z: int = 10):"

#: ../../library/dataclasses.rst:688
msgid "Re-ordering of keyword-only parameters in :meth:`!__init__`"
msgstr ""
"Reordenação de parâmetros apenas por palavra-chave em :meth:`!__init__`"

#: ../../library/dataclasses.rst:690
msgid ""
"After the parameters needed for :meth:`~object.__init__` are computed, any "
"keyword-only parameters are moved to come after all regular (non-keyword-"
"only) parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"Depois de os parâmetros necessários para :meth:`~object.__init__` serem "
"calculados, quaisquer parâmetros apenas por palavra-chave são movidos para "
"depois de todos os parâmetros regulares (não apenas por palavra-chave). Isto "
"é um requisito de como os parâmetros apenas por palavra-chave são "
"implementados em Python: devem vir depois dos parâmetros não apenas por "
"palavra-chave."

#: ../../library/dataclasses.rst:696
msgid ""
"In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are "
"keyword-only fields, and :attr:`!Base.x` and :attr:`!D.z` are regular "
"fields::"
msgstr ""
"Neste exemplo, :attr:`!Base.y`, :attr:`!Base.w` e :attr:`!D.t` são campos "
"apenas por palavra-chave, e :attr:`!Base.x` e :attr:`!D.z` são campos "
"regulares::"

#: ../../library/dataclasses.rst:699
msgid ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"
msgstr ""
"@dataclass\n"
"class Base:\n"
"    x: Any = 15.0\n"
"    _: KW_ONLY\n"
"    y: int = 0\n"
"    w: int = 1\n"
"\n"
"@dataclass\n"
"class D(Base):\n"
"    z: int = 10\n"
"    t: int = field(kw_only=True, default=0)"

#: ../../library/dataclasses.rst:711
msgid "The generated :meth:`!__init__` method for :class:`!D` will look like::"
msgstr "O método :meth:`!__init__` gerado para :class:`!D` será como::"

#: ../../library/dataclasses.rst:713
msgid ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"
msgstr ""
"def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: "
"int = 0):"

#: ../../library/dataclasses.rst:715
msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"Note que os parâmetros foram reordenados em relação à forma como aparecem na "
"lista de campos: parâmetros derivados de campos regulares são seguidos por "
"parâmetros derivados de campos apenas por palavra-chave."

#: ../../library/dataclasses.rst:719
msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`!__init__` parameter list."
msgstr ""
"A ordenação relativa dos parâmetros apenas por palavra-chave é mantida na "
"lista de parâmetros reordenada de :meth:`!__init__`."

#: ../../library/dataclasses.rst:724
msgid "Default factory functions"
msgstr "Funções fábrica predefinidas"

#: ../../library/dataclasses.rst:726
msgid ""
"If a :func:`field` specifies a *default_factory*, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"Se um :func:`field` especificar um *default_factory*, este é chamado com "
"zero argumentos quando um valor predefinido para o campo é necessário. Por "
"exemplo, para criar uma nova instância de uma lista, use::"

#: ../../library/dataclasses.rst:730
msgid "mylist: list = field(default_factory=list)"
msgstr "mylist: list = field(default_factory=list)"

#: ../../library/dataclasses.rst:732
msgid ""
"If a field is excluded from :meth:`~object.__init__` (using ``init=False``) "
"and the field also specifies *default_factory*, then the default factory "
"function will always be called from the generated :meth:`!__init__` "
"function.  This happens because there is no other way to give the field an "
"initial value."
msgstr ""
"Se um campo for excluído de :meth:`~object.__init__` (usando ``init=False``) "
"e o campo também especificar *default_factory*, então a função fábrica "
"predefinida será sempre chamada a partir da função :meth:`!__init__` gerada. "
"Isto acontece porque não há outra forma de dar ao campo um valor inicial."

#: ../../library/dataclasses.rst:739
msgid "Mutable default values"
msgstr "Valores predefinidos mutáveis"

#: ../../library/dataclasses.rst:741
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python armazena valores de variáveis membro predefinidas em atributos de "
"classe. Considere este exemplo, não usando classes de dados::"

#: ../../library/dataclasses.rst:744
msgid ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"
msgstr ""
"class C:\n"
"    x = []\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"o1 = C()\n"
"o2 = C()\n"
"o1.add(1)\n"
"o2.add(2)\n"
"assert o1.x == [1, 2]\n"
"assert o1.x is o2.x"

#: ../../library/dataclasses.rst:756
msgid ""
"Note that the two instances of class :class:`!C` share the same class "
"variable :attr:`!x`, as expected."
msgstr ""
"Note que as duas instâncias da classe :class:`!C` partilham a mesma variável "
"de classe :attr:`!x`, como esperado."

#: ../../library/dataclasses.rst:759
msgid "Using dataclasses, *if* this code was valid::"
msgstr "Usando classes de dados, *se* este código fosse válido::"

#: ../../library/dataclasses.rst:761
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # This code raises ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"
msgstr ""
"@dataclass\n"
"class D:\n"
"    x: list = []      # Este código lança ValueError\n"
"    def add(self, element):\n"
"        self.x.append(element)"

#: ../../library/dataclasses.rst:767
msgid "it would generate code similar to::"
msgstr "geraria código semelhante a::"

#: ../../library/dataclasses.rst:769
msgid ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"
msgstr ""
"class D:\n"
"    x = []\n"
"    def __init__(self, x=x):\n"
"        self.x = x\n"
"    def add(self, element):\n"
"        self.x.append(element)\n"
"\n"
"assert D().x is D().x"

#: ../../library/dataclasses.rst:778
msgid ""
"This has the same issue as the original example using class :class:`!C`. "
"That is, two instances of class :class:`!D` that do not specify a value for :"
"attr:`!x` when creating a class instance will share the same copy of :attr:`!"
"x`.  Because dataclasses just use normal Python class creation they also "
"share this behavior.  There is no general way for Data Classes to detect "
"this condition.  Instead, the :deco:`dataclass` decorator will raise a :exc:"
"`ValueError` if it detects an unhashable default parameter.  The assumption "
"is that if a value is unhashable, it is mutable.  This is a partial "
"solution, but it does protect against many common errors."
msgstr ""
"Isto tem o mesmo problema que o exemplo original usando a classe :class:`!"
"C`. Ou seja, duas instâncias da classe :class:`!D` que não especifiquem um "
"valor para :attr:`!x` ao criar uma instância de classe partilharão a mesma "
"cópia de :attr:`!x`. Como as classes de dados usam apenas a criação normal "
"de classes Python, também partilham este comportamento. Não há uma forma "
"geral para as Classes de Dados detetarem esta condição. Em vez disso, o "
"decorador :deco:`dataclass` lançará uma exceção :exc:`ValueError` se detetar "
"um parâmetro predefinido não-hashable. A suposição é que, se um valor não "
"for hashable, é mutável. Esta é uma solução parcial, mas protege contra "
"muitos erros comuns."

#: ../../library/dataclasses.rst:789
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr ""
"Usar funções fábrica predefinidas é uma forma de criar novas instâncias de "
"tipos mutáveis como valores predefinidos para campos::"

#: ../../library/dataclasses.rst:792
msgid ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"
msgstr ""
"@dataclass\n"
"class D:\n"
"    x: list = field(default_factory=list)\n"
"\n"
"assert D().x is not D().x"

#: ../../library/dataclasses.rst:798
msgid ""
"Instead of looking for and disallowing objects of type :class:`list`, :class:"
"`dict`, or :class:`set`, unhashable objects are now not allowed as default "
"values.  Unhashability is used to approximate mutability."
msgstr ""
"Em vez de procurar e proibir objetos do tipo :class:`list`, :class:`dict` "
"ou :class:`set`, objetos não-hashable não são agora permitidos como valores "
"predefinidos. A não-hashabilidade é usada para aproximar a mutabilidade."

#: ../../library/dataclasses.rst:805
msgid "Descriptor-typed fields"
msgstr "Campos com tipo de descritor"

#: ../../library/dataclasses.rst:807
msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr ""
"Campos aos quais são atribuídos :ref:`objetos descritores <descriptors>` "
"como seu valor predefinido têm os seguintes comportamentos especiais:"

#: ../../library/dataclasses.rst:810
msgid ""
"The value for the field passed to the dataclass's :meth:`~object.__init__` "
"method is passed to the descriptor's :meth:`~object.__set__` method rather "
"than overwriting the descriptor object."
msgstr ""
"O valor para o campo passado ao método :meth:`~object.__init__` da classe de "
"dados é passado para o método :meth:`~object.__set__` do descritor em vez de "
"sobrescrever o objeto descritor."

#: ../../library/dataclasses.rst:814
msgid ""
"Similarly, when getting or setting the field, the descriptor's :meth:"
"`~object.__get__` or :meth:`!__set__` method is called rather than returning "
"or overwriting the descriptor object."
msgstr ""
"Da mesma forma, ao obter ou definir o campo, o método :meth:`~object."
"__get__` ou :meth:`!__set__` do descritor é chamado em vez de retornar ou "
"sobrescrever o objeto descritor."

#: ../../library/dataclasses.rst:818
msgid ""
"To determine whether a field contains a default value, :deco:`dataclass` "
"will call the descriptor's :meth:`!__get__` method using its class access "
"form: ``descriptor.__get__(obj=None, type=cls)``.  If the descriptor returns "
"a value in this case, it will be used as the field's default. On the other "
"hand, if the descriptor raises :exc:`AttributeError` in this situation, no "
"default value will be provided for the field."
msgstr ""
"Para determinar se um campo contém um valor predefinido, :deco:`dataclass` "
"chamará o método :meth:`!__get__` do descritor usando a sua forma de acesso "
"de classe: ``descriptor.__get__(obj=None, type=cls)``. Se o descritor "
"retornar um valor neste caso, este será usado como o valor predefinido do "
"campo. Por outro lado, se o descritor lançar uma exceção :exc:"
"`AttributeError` nesta situação, nenhum valor predefinido será fornecido "
"para o campo."

#: ../../library/dataclasses.rst:828
msgid ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # calls __set__ with 2.5\n"
"print(i.quantity_on_hand)   # 2"
msgstr ""
"class IntConversionDescriptor:\n"
"    def __init__(self, *, default):\n"
"        self._default = default\n"
"\n"
"    def __set_name__(self, owner, name):\n"
"        self._name = \"_\" + name\n"
"\n"
"    def __get__(self, obj, type):\n"
"        if obj is None:\n"
"            return self._default\n"
"\n"
"        return getattr(obj, self._name, self._default)\n"
"\n"
"    def __set__(self, obj, value):\n"
"        setattr(obj, self._name, int(value))\n"
"\n"
"@dataclass\n"
"class InventoryItem:\n"
"    quantity_on_hand: IntConversionDescriptor = "
"IntConversionDescriptor(default=100)\n"
"\n"
"i = InventoryItem()\n"
"print(i.quantity_on_hand)   # 100\n"
"i.quantity_on_hand = 2.5    # chama __set__ com 2.5\n"
"print(i.quantity_on_hand)   # 2"

#: ../../library/dataclasses.rst:853
msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a "
"normal field."
msgstr ""
"Note que se um campo for anotado com um tipo de descritor, mas não lhe for "
"atribuído um objeto descritor como valor predefinido, o campo agirá como um "
"campo normal."
