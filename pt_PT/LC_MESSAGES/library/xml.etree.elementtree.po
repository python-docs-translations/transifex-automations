# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-23 14:12+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/xml.etree.elementtree.rst:2
msgid ":mod:`!xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ":mod:`!xml.etree.ElementTree` — A API XML ElementTree"

#: ../../library/xml.etree.elementtree.rst:9
msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**Código-fonte:** :source:`Lib/xml/etree/ElementTree.py`"

#: ../../library/xml.etree.elementtree.rst:13
msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ""
"O módulo :mod:`xml.etree.ElementTree` implementa uma API simples e eficiente "
"para analisar e criar dados XML."

#: ../../library/xml.etree.elementtree.rst:16
msgid "This module will use a fast implementation whenever available."
msgstr "Este módulo usará uma implementação rápida sempre que disponível."

#: ../../library/xml.etree.elementtree.rst:19
msgid "The :mod:`!xml.etree.cElementTree` module is deprecated."
msgstr "O módulo :mod:`!xml.etree.cElementTree` está obsoleto."

#: ../../library/xml.etree.elementtree.rst:25
msgid ""
"If you need to parse untrusted or unauthenticated data, see :ref:`xml-"
"security`."
msgstr ""
"Se precisar de analisar dados não confiáveis ou não autenticados, consulte :"
"ref:`xml-security`."

#: ../../library/xml.etree.elementtree.rst:29
msgid "Tutorial"
msgstr "Tutorial"

#: ../../library/xml.etree.elementtree.rst:31
msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""
"Este é um breve tutorial sobre a utilização de :mod:`xml.etree.ElementTree` "
"(``ET`` em resumo). O objetivo é demonstrar alguns dos blocos de construção "
"e conceitos básicos do módulo."

#: ../../library/xml.etree.elementtree.rst:36
msgid "XML tree and elements"
msgstr "Árvore XML e elementos"

#: ../../library/xml.etree.elementtree.rst:38
msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - :"
"class:`ElementTree` represents the whole XML document as a tree, and :class:"
"`Element` represents a single node in this tree.  Interactions with the "
"whole document (reading and writing to/from files) are usually done on the :"
"class:`ElementTree` level.  Interactions with a single XML element and its "
"sub-elements are done on the :class:`Element` level."
msgstr ""
"O XML é um formato de dados inerentemente hierárquico, e a forma mais "
"natural de o representar é com uma árvore. ``ET`` tem duas classes para este "
"propósito — :class:`ElementTree` representa todo o documento XML como uma "
"árvore, e :class:`Element` representa um único nó nesta árvore. As "
"interações com todo o documento (leitura e escrita para/de ficheiros) são "
"normalmente feitas ao nível de :class:`ElementTree`. As interações com um "
"único elemento XML e os seus sub-elementos são feitas ao nível de :class:"
"`Element`."

#: ../../library/xml.etree.elementtree.rst:49
msgid "Parsing XML"
msgstr "Analisar XML"

#: ../../library/xml.etree.elementtree.rst:51
msgid ""
"We'll be using the fictive :file:`country_data.xml` XML document as the "
"sample data for this section:"
msgstr ""
"Vamos usar o documento XML fictício :file:`country_data.xml` como dados de "
"exemplo para esta secção:"

#: ../../library/xml.etree.elementtree.rst:53
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Áustria\" direction=\"E\"/>\n"
"        <neighbor name=\"Suíça\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapura\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malásia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panamá\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colômbia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"

#: ../../library/xml.etree.elementtree.rst:79
msgid "We can import this data by reading from a file::"
msgstr "Podemos importar estes dados lendo de um ficheiro:"

#: ../../library/xml.etree.elementtree.rst:81
msgid ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"
msgstr ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"

#: ../../library/xml.etree.elementtree.rst:85
msgid "Or directly from a string::"
msgstr "Ou diretamente de uma string:"

#: ../../library/xml.etree.elementtree.rst:87
msgid "root = ET.fromstring(country_data_as_string)"
msgstr "root = ET.fromstring(country_data_as_string)"

#: ../../library/xml.etree.elementtree.rst:89
msgid ""
":func:`fromstring` parses XML from a string directly into an :class:"
"`Element`, which is the root element of the parsed tree.  Other parsing "
"functions may create an :class:`ElementTree`.  Check the documentation to be "
"sure."
msgstr ""
":func:`fromstring` analisa XML de uma string diretamente para um :class:"
"`Element`, que é o elemento raiz da árvore analisada. Outras funções de "
"análise podem criar um :class:`ElementTree`. Consulte a documentação para "
"ter a certeza."

#: ../../library/xml.etree.elementtree.rst:93
msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr ""
"Como um :class:`Element`, ``root`` tem uma etiqueta e um dicionário de "
"atributos:"

#: ../../library/xml.etree.elementtree.rst:95
msgid ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"
msgstr ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"

#: ../../library/xml.etree.elementtree.rst:100
msgid "It also has children nodes over which we can iterate::"
msgstr "Também tem nós filhos sobre os quais podemos iterar:"

#: ../../library/xml.etree.elementtree.rst:102
msgid ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"
msgstr ""
">>> for child in root:\n"
"...     print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapura'}\n"
"country {'name': 'Panamá'}"

#: ../../library/xml.etree.elementtree.rst:109
msgid "Children are nested, and we can access specific child nodes by index::"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:111
msgid ""
">>> root[0][1].text\n"
"'2008'"
msgstr ""

#: ../../library/xml.etree.elementtree.rst:117
msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can "
"have comments and processing instructions in them; they will be included "
"when generating XML output. A document type declaration may be accessed by "
"passing a custom :class:`TreeBuilder` instance to the :class:`XMLParser` "
"constructor."
msgstr ""
"Nem todos os elementos da entrada XML acabarão como elementos da árvore "
"analisada. Atualmente, este módulo ignora quaisquer comentários XML, "
"instruções de processamento e declarações de tipo de documento na entrada. "
"No entanto, árvores construídas usando a API deste módulo em vez de analisar "
"texto XML podem ter comentários e instruções de processamento; estes serão "
"incluídos ao gerar saída XML. Uma declaração de tipo de documento pode ser "
"acedida passando uma instância personalizada de :class:`TreeBuilder` para o "
"construtor de :class:`XMLParser`."

#: ../../library/xml.etree.elementtree.rst:131
msgid "Pull API for non-blocking parsing"
msgstr "API Pull para análise não bloqueante"

#: ../../library/xml.etree.elementtree.rst:133
msgid ""
"Most parsing functions provided by this module require the whole document to "
"be read at once before returning any result.  It is possible to use an :"
"class:`XMLParser` and feed data into it incrementally, but it is a push API "
"that calls methods on a callback target, which is too low-level and "
"inconvenient for most needs.  Sometimes what the user really wants is to be "
"able to parse XML incrementally, without blocking operations, while enjoying "
"the convenience of fully constructed :class:`Element` objects."
msgstr ""
"A maioria das funções de análise fornecidas por este módulo requer que todo "
"o documento seja lido de uma vez antes de devolver qualquer resultado. É "
"possível usar um :class:`XMLParser` e alimentá-lo com dados de forma "
"incremental, mas é uma API push que chama métodos num alvo de callback, o "
"que é demasiado de baixo nível e inconveniente para a maioria das "
"necessidades. Às vezes, o que o utilizador realmente quer é ser capaz de "
"analisar XML de forma incremental, sem operações bloqueantes, enquanto "
"desfruta da conveniência de objetos :class:`Element` totalmente construídos."

#: ../../library/xml.etree.elementtree.rst:141
msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does "
"not require a blocking read to obtain the XML data, and is instead fed with "
"data incrementally with :meth:`XMLPullParser.feed` calls.  To get the parsed "
"XML elements, call :meth:`XMLPullParser.read_events`.  Here is an example::"
msgstr ""
"A ferramenta mais poderosa para fazer isto é :class:`XMLPullParser`. Não "
"requer uma leitura bloqueante para obter os dados XML, e é alimentado com "
"dados de forma incremental com chamadas a :meth:`XMLPullParser.feed`. Para "
"obter os elementos XML analisados, chame :meth:`XMLPullParser.read_events`. "
"Aqui está um exemplo:"

#: ../../library/xml.etree.elementtree.rst:146
msgid ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"
msgstr ""
">>> parser = ET.XMLPullParser(['start', 'end'])\n"
">>> parser.feed('<mytag>sometext')\n"
">>> list(parser.read_events())\n"
"[('start', <Element 'mytag' at 0x7fa66db2be58>)]\n"
">>> parser.feed(' more text</mytag>')\n"
">>> for event, elem in parser.read_events():\n"
"...     print(event)\n"
"...     print(elem.tag, 'text=', elem.text)\n"
"...\n"
"end\n"
"mytag text= sometext more text"

#: ../../library/xml.etree.elementtree.rst:158
msgid ""
"The obvious use case is applications that operate in a non-blocking fashion "
"where the XML data is being received from a socket or read incrementally "
"from some storage device.  In such cases, blocking reads are unacceptable."
msgstr ""
"O caso de uso óbvio são aplicações que operam de forma não bloqueante, onde "
"os dados XML estão a ser recebidos de um socket ou lidos de forma "
"incremental de algum dispositivo de armazenamento. Nestes casos, leituras "
"bloqueantes são inaceitáveis."

#: ../../library/xml.etree.elementtree.rst:162
msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to use "
"for simpler use-cases.  If you don't mind your application blocking on "
"reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
"Por ser tão flexível, :class:`XMLPullParser` pode ser inconveniente de usar "
"para casos de uso mais simples. Se não se importar que a sua aplicação "
"bloqueie ao ler dados XML, mas ainda assim gostaria de ter capacidades de "
"análise incremental, dê uma vista de olhos a :func:`iterparse`. Pode ser "
"útil quando está a ler um grande documento XML e não quer mantê-lo "
"inteiramente na memória."

#: ../../library/xml.etree.elementtree.rst:168
msgid ""
"Where *immediate* feedback through events is wanted, calling method :meth:"
"`XMLPullParser.flush` can help reduce delay; please make sure to study the "
"related security notes."
msgstr ""
"Quando se deseja feedback *imediato* através de eventos, chamar o método :"
"meth:`XMLPullParser.flush` pode ajudar a reduzir o atraso; certifique-se de "
"estudar as notas de segurança relacionadas."

#: ../../library/xml.etree.elementtree.rst:174
msgid "Finding interesting elements"
msgstr "Encontrar elementos interessantes"

#: ../../library/xml.etree.elementtree.rst:176
msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""
":class:`Element` tem alguns métodos úteis que ajudam a iterar recursivamente "
"sobre toda a sub-árvore abaixo dele (os seus filhos, os filhos deles, e "
"assim por diante). Por exemplo, :meth:`Element.iter`:"

#: ../../library/xml.etree.elementtree.rst:180
msgid ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"
msgstr ""
">>> for neighbor in root.iter('neighbor'):\n"
"...     print(neighbor.attrib)\n"
"...\n"
"{'name': 'Áustria', 'direction': 'E'}\n"
"{'name': 'Suíça', 'direction': 'W'}\n"
"{'name': 'Malásia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colômbia', 'direction': 'E'}"

#: ../../library/xml.etree.elementtree.rst:189
msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's "
"text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""
":meth:`Element.findall` encontra apenas elementos com uma etiqueta que são "
"filhos diretos do elemento atual. :meth:`Element.find` encontra o *primeiro* "
"filho com uma etiqueta particular, e :attr:`Element.text` acede ao conteúdo "
"de texto do elemento. :meth:`Element.get` acede aos atributos do elemento:"

#: ../../library/xml.etree.elementtree.rst:194
msgid ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"
msgstr ""
">>> for country in root.findall('country'):\n"
"...     rank = country.find('rank').text\n"
"...     name = country.get('name')\n"
"...     print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapura 4\n"
"Panamá 68"

#: ../../library/xml.etree.elementtree.rst:203
msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr ""
"Uma especificação mais sofisticada de quais elementos procurar é possível "
"usando :ref:`XPath <elementtree-xpath>`."

#: ../../library/xml.etree.elementtree.rst:207
msgid "Modifying an XML File"
msgstr "Modificar um ficheiro XML"

#: ../../library/xml.etree.elementtree.rst:209
msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""
":class:`ElementTree` fornece uma forma simples de construir documentos XML e "
"escrevê-los em ficheiros. O método :meth:`ElementTree.write` serve este "
"propósito."

#: ../../library/xml.etree.elementtree.rst:212
msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for "
"example with :meth:`Element.append`)."
msgstr ""
"Uma vez criado, um objeto :class:`Element` pode ser manipulado alterando "
"diretamente os seus campos (como :attr:`Element.text`), adicionando e "
"modificando atributos (método :meth:`Element.set`), bem como adicionando "
"novos filhos (por exemplo, com :meth:`Element.append`)."

#: ../../library/xml.etree.elementtree.rst:217
msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr ""
"Suponhamos que queremos adicionar um a cada classificação de país e "
"adicionar um atributo ``updated`` ao elemento de classificação:"

#: ../../library/xml.etree.elementtree.rst:220
msgid ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""
">>> for rank in root.iter('rank'):\n"
"...     new_rank = int(rank.text) + 1\n"
"...     rank.text = str(new_rank)\n"
"...     rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"

#: ../../library/xml.etree.elementtree.rst:227
#: ../../library/xml.etree.elementtree.rst:271
msgid "Our XML now looks like this:"
msgstr "O nosso XML agora parece isto:"

#: ../../library/xml.etree.elementtree.rst:229
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Áustria\" direction=\"E\"/>\n"
"        <neighbor name=\"Suíça\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapura\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malásia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panamá\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colômbia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"

#: ../../library/xml.etree.elementtree.rst:255
msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr ""
"Podemos remover elementos usando :meth:`Element.remove`. Suponhamos que "
"queremos remover todos os países com uma classificação superior a 50:"

#: ../../library/xml.etree.elementtree.rst:258
msgid ""
">>> for country in root.findall('country'):\n"
"...     # using root.findall() to avoid removal during traversal\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""
">>> for country in root.findall('country'):\n"
"...     # usando root.findall() para evitar remoção durante a travessia\n"
"...     rank = int(country.find('rank').text)\n"
"...     if rank > 50:\n"
"...         root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"

#: ../../library/xml.etree.elementtree.rst:266
msgid ""
"Note that concurrent modification while iterating can lead to problems, just "
"like when iterating and modifying Python lists or dicts. Therefore, the "
"example first collects all matching elements with ``root.findall()``, and "
"only then iterates over the list of matches."
msgstr ""
"Note que a modificação concorrente durante a iteração pode levar a "
"problemas, tal como ao iterar e modificar listas ou dicionários Python. Por "
"isso, o exemplo primeiro recolhe todos os elementos correspondentes com "
"``root.findall()``, e só depois itera sobre a lista de correspondências."

#: ../../library/xml.etree.elementtree.rst:273
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Áustria\" direction=\"E\"/>\n"
"        <neighbor name=\"Suíça\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapura\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malásia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"

#: ../../library/xml.etree.elementtree.rst:293
msgid "Building XML documents"
msgstr "Construir documentos XML"

#: ../../library/xml.etree.elementtree.rst:295
msgid ""
"The :func:`SubElement` function also provides a convenient way to create new "
"sub-elements for a given element::"
msgstr ""
"A função :func:`SubElement` também fornece uma forma conveniente de criar "
"novos sub-elementos para um elemento dado:"

#: ../../library/xml.etree.elementtree.rst:298
msgid ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"
msgstr ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"

#: ../../library/xml.etree.elementtree.rst:306
msgid "Parsing XML with Namespaces"
msgstr "Analisar XML com Namespaces"

#: ../../library/xml.etree.elementtree.rst:308
msgid ""
"If the XML input has `namespaces <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, tags and attributes with prefixes in the form ``prefix:"
"sometag`` get expanded to ``{uri}sometag`` where the *prefix* is replaced by "
"the full *URI*. Also, if there is a `default namespace <https://www.w3.org/"
"TR/xml-names/#defaulting>`__, that full URI gets prepended to all of the non-"
"prefixed tags."
msgstr ""
"Se a entrada XML tiver `namespaces <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, etiquetas e atributos com prefixos na forma ``prefix:"
"sometag`` são expandidos para ``{uri}sometag`` onde o *prefixo* é "
"substituído pela *URI* completa. Além disso, se houver um `namespace "
"predefinido <https://www.w3.org/TR/xml-names/#defaulting>`__, essa URI "
"completa é pré-adicionada a todas as etiquetas não prefixadas."

#: ../../library/xml.etree.elementtree.rst:316
msgid ""
"Here is an XML example that incorporates two namespaces, one with the prefix "
"\"fictional\" and the other serving as the default namespace:"
msgstr ""
"Aqui está um exemplo XML que incorpora dois namespaces, um com o prefixo "
"\"fictional\" e o outro servindo como o namespace predefinido:"

#: ../../library/xml.etree.elementtree.rst:319
msgid ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<actors xmlns:fictional=\"http://characters.example.com\"\n"
"        xmlns=\"http://people.example.com\">\n"
"    <actor>\n"
"        <name>John Cleese</name>\n"
"        <fictional:character>Lancelot</fictional:character>\n"
"        <fictional:character>Archie Leach</fictional:character>\n"
"    </actor>\n"
"    <actor>\n"
"        <name>Eric Idle</name>\n"
"        <fictional:character>Sir Robin</fictional:character>\n"
"        <fictional:character>Gunther</fictional:character>\n"
"        <fictional:character>Commander Clement</fictional:character>\n"
"    </actor>\n"
"</actors>"

#: ../../library/xml.etree.elementtree.rst:337
msgid ""
"One way to search and explore this XML example is to manually add the URI to "
"every tag or attribute in the xpath of a :meth:`~Element.find` or :meth:"
"`~Element.findall`::"
msgstr ""
"Uma forma de procurar e explorar este exemplo XML é adicionar manualmente a "
"URI a cada etiqueta ou atributo no xpath de um :meth:`~Element.find` ou :"
"meth:`~Element.findall`:"

#: ../../library/xml.etree.elementtree.rst:341
msgid ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"
msgstr ""
"root = fromstring(xml_text)\n"
"for actor in root.findall('{http://people.example.com}actor'):\n"
"    name = actor.find('{http://people.example.com}name')\n"
"    print(name.text)\n"
"    for char in actor.findall('{http://characters.example.com}character'):\n"
"        print(' |-->', char.text)"

#: ../../library/xml.etree.elementtree.rst:348
msgid ""
"A better way to search the namespaced XML example is to create a dictionary "
"with your own prefixes and use those in the search functions::"
msgstr ""
"Uma melhor forma de procurar no exemplo XML com namespaces é criar um "
"dicionário com os seus próprios prefixos e usá-los nas funções de pesquisa:"

#: ../../library/xml.etree.elementtree.rst:351
msgid ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"
msgstr ""
"ns = {'real_person': 'http://people.example.com',\n"
"      'role': 'http://characters.example.com'}\n"
"\n"
"for actor in root.findall('real_person:actor', ns):\n"
"    name = actor.find('real_person:name', ns)\n"
"    print(name.text)\n"
"    for char in actor.findall('role:character', ns):\n"
"        print(' |-->', char.text)"

#: ../../library/xml.etree.elementtree.rst:360
msgid "These two approaches both output::"
msgstr "Estas duas abordagens produzem a seguinte saída:"

#: ../../library/xml.etree.elementtree.rst:362
msgid ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"
msgstr ""
"John Cleese\n"
" |--> Lancelot\n"
" |--> Archie Leach\n"
"Eric Idle\n"
" |--> Sir Robin\n"
" |--> Gunther\n"
" |--> Commander Clement"

#: ../../library/xml.etree.elementtree.rst:374
msgid "XPath support"
msgstr "Suporte XPath"

#: ../../library/xml.etree.elementtree.rst:376
msgid ""
"This module provides limited support for `XPath expressions <https://www.w3."
"org/TR/xpath>`_ for locating elements in a tree.  The goal is to support a "
"small subset of the abbreviated syntax; a full XPath engine is outside the "
"scope of the module."
msgstr ""
"Este módulo fornece suporte limitado para `expressões XPath <https://www.w3."
"org/TR/xpath>`_ para localizar elementos numa árvore. O objetivo é suportar "
"um pequeno subconjunto da sintaxe abreviada; um motor XPath completo está "
"fora do âmbito deste módulo."

#: ../../library/xml.etree.elementtree.rst:382
#: ../../library/xml.etree.elementtree.rst:781
msgid "Example"
msgstr "Exemplo"

#: ../../library/xml.etree.elementtree.rst:384
msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the :ref:"
"`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"Aqui está um exemplo que demonstra algumas das capacidades XPath do módulo. "
"Vamos usar o documento XML ``countrydata`` da secção :ref:`Analisar XML "
"<elementtree-parsing-xml>`:"

#: ../../library/xml.etree.elementtree.rst:388
msgid ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"
msgstr ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Elementos de nível superior\n"
"root.findall(\".\")\n"
"\n"
"# Todos os 'neighbor' netos de 'country' filhos dos elementos de nível "
"superior\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nós com name='Singapore' que têm um filho 'year'\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# Nós 'year' que são filhos de nós com name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# Todos os nós 'neighbor' que são o segundo filho do seu pai\n"
"root.findall(\".//neighbor[2]\")"

#: ../../library/xml.etree.elementtree.rst:408
msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr ""
"Para XML com namespaces, use a notação qualificada habitual ``{namespace}"
"tag``:"

#: ../../library/xml.etree.elementtree.rst:410
msgid ""
"# All dublin-core \"title\" tags in the document\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"
msgstr ""
"# Todas as etiquetas \"title\" dublin-core no documento\n"
"root.findall(\".//{http://purl.org/dc/elements/1.1/}title\")"

#: ../../library/xml.etree.elementtree.rst:415
msgid "Supported XPath syntax"
msgstr "Sintaxe XPath suportada"

#: ../../library/xml.etree.elementtree.rst:420
msgid "Syntax"
msgstr "Sintaxe"

#: ../../library/xml.etree.elementtree.rst:420
msgid "Meaning"
msgstr "Significado"

#: ../../library/xml.etree.elementtree.rst:422
msgid "``tag``"
msgstr "``tag``"

#: ../../library/xml.etree.elementtree.rst:422
msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects "
"all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  ``{namespace}"
"*`` selects all tags in the given namespace, ``{*}spam`` selects tags named "
"``spam`` in any (or no) namespace, and ``{}*`` only selects tags that are "
"not in a namespace."
msgstr ""
"Selecciona todos os elementos filhos com a etiqueta dada. Por exemplo, "
"``spam`` selecciona todos os elementos filhos chamados ``spam``, e ``spam/"
"egg`` selecciona todos os netos chamados ``egg`` em todos os filhos chamados "
"``spam``. ``{namespace}*`` selecciona todas as etiquetas no namespace dado, "
"``{*}spam`` selecciona etiquetas chamadas ``spam`` em qualquer (ou nenhum) "
"namespace, e ``{}*`` selecciona apenas etiquetas que não estão num namespace."

#: ../../library/xml.etree.elementtree.rst:431
msgid "Support for star-wildcards was added."
msgstr "Foi adicionado suporte para curingas de asterisco."

#: ../../library/xml.etree.elementtree.rst:434
msgid "``*``"
msgstr "``*``"

#: ../../library/xml.etree.elementtree.rst:434
msgid ""
"Selects all child elements, including comments and processing instructions.  "
"For example, ``*/egg`` selects all grandchildren named ``egg``."
msgstr ""
"Selecciona todos os elementos filhos, incluindo comentários e instruções de "
"processamento. Por exemplo, ``*/egg`` selecciona todos os netos chamados "
"``egg``."

#: ../../library/xml.etree.elementtree.rst:438
msgid "``.``"
msgstr "``.``"

#: ../../library/xml.etree.elementtree.rst:438
msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr ""
"Selecciona o nó atual. Isto é maioritariamente útil no início do caminho, "
"para indicar que é um caminho relativo."

#: ../../library/xml.etree.elementtree.rst:442
msgid "``//``"
msgstr "``//``"

#: ../../library/xml.etree.elementtree.rst:442
msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""
"Selecciona todos os sub-elementos, em todos os níveis abaixo do elemento "
"atual. Por exemplo, ``.//egg`` selecciona todos os elementos ``egg`` em toda "
"a árvore."

#: ../../library/xml.etree.elementtree.rst:446
msgid "``..``"
msgstr "``..``"

#: ../../library/xml.etree.elementtree.rst:446
msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr ""
"Selecciona o elemento pai. Devolve ``None`` se o caminho tentar atingir os "
"antepassados do elemento inicial (o elemento em que ``find`` foi chamado)."

#: ../../library/xml.etree.elementtree.rst:450
msgid "``[@attrib]``"
msgstr "``[@attrib]``"

#: ../../library/xml.etree.elementtree.rst:450
msgid "Selects all elements that have the given attribute."
msgstr "Selecciona todos os elementos que têm o atributo dado."

#: ../../library/xml.etree.elementtree.rst:452
msgid "``[@attrib='value']``"
msgstr "``[@attrib='value']``"

#: ../../library/xml.etree.elementtree.rst:452
msgid ""
"Selects all elements for which the given attribute has the given value.  The "
"value cannot contain quotes."
msgstr ""
"Selecciona todos os elementos para os quais o atributo dado tem o valor "
"dado. O valor não pode conter aspas."

#: ../../library/xml.etree.elementtree.rst:456
msgid "``[@attrib!='value']``"
msgstr "``[@attrib!='value']``"

#: ../../library/xml.etree.elementtree.rst:456
msgid ""
"Selects all elements for which the given attribute does not have the given "
"value. The value cannot contain quotes."
msgstr ""
"Selecciona todos os elementos para os quais o atributo dado não tem o valor "
"dado. O valor não pode conter aspas."

#: ../../library/xml.etree.elementtree.rst:462
msgid "``[tag]``"
msgstr "``[tag]``"

#: ../../library/xml.etree.elementtree.rst:462
msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr ""
"Selecciona todos os elementos que têm um filho chamado ``tag``. Apenas "
"filhos imediatos são suportados."

#: ../../library/xml.etree.elementtree.rst:465
msgid "``[.='text']``"
msgstr "``[.='text']``"

#: ../../library/xml.etree.elementtree.rst:465
msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr ""
"Selecciona todos os elementos cujo conteúdo de texto completo, incluindo "
"descendentes, é igual ao ``text`` dado."

#: ../../library/xml.etree.elementtree.rst:470
msgid "``[.!='text']``"
msgstr "``[.!='text']``"

#: ../../library/xml.etree.elementtree.rst:470
msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr ""
"Selecciona todos os elementos cujo conteúdo de texto completo, incluindo "
"descendentes, não é igual ao ``text`` dado."

#: ../../library/xml.etree.elementtree.rst:476
msgid "``[tag='text']``"
msgstr "``[tag='text']``"

#: ../../library/xml.etree.elementtree.rst:476
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr ""
"Selecciona todos os elementos que têm um filho chamado ``tag`` cujo conteúdo "
"de texto completo, incluindo descendentes, é igual ao ``text`` dado."

#: ../../library/xml.etree.elementtree.rst:480
msgid "``[tag!='text']``"
msgstr "``[tag!='text']``"

#: ../../library/xml.etree.elementtree.rst:480
msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr ""
"Selecciona todos os elementos que têm um filho chamado ``tag`` cujo conteúdo "
"de texto completo, incluindo descendentes, não é igual ao ``text`` dado."

#: ../../library/xml.etree.elementtree.rst:486
msgid "``[position]``"
msgstr "``[position]``"

#: ../../library/xml.etree.elementtree.rst:486
msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""
"Selecciona todos os elementos que estão localizados na posição dada. A "
"posição pode ser um inteiro (1 é a primeira posição), a expressão ``last()`` "
"(para a última posição), ou uma posição relativa à última posição (por "
"exemplo, ``last()-1``)."

#: ../../library/xml.etree.elementtree.rst:493
msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr ""
"Os predicados (expressões dentro de parênteses retos) devem ser precedidos "
"por um nome de etiqueta, um asterisco, ou outro predicado. Os predicados de "
"``position`` devem ser precedidos por um nome de etiqueta."

#: ../../library/xml.etree.elementtree.rst:498
#: ../../library/xml.etree.elementtree.rst:833
msgid "Reference"
msgstr "Referência"

#: ../../library/xml.etree.elementtree.rst:503
#: ../../library/xml.etree.elementtree.rst:838
msgid "Functions"
msgstr "Funções"

#: ../../library/xml.etree.elementtree.rst:507
msgid "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr ""
"Função de transformação `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_."

#: ../../library/xml.etree.elementtree.rst:509
msgid ""
"Canonicalization is a way to normalise XML output in a way that allows byte-"
"by-byte comparisons and digital signatures.  It reduces the freedom that XML "
"serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""
"A canonização é uma forma de normalizar a saída XML de uma forma que permite "
"comparações byte-a-byte e assinaturas digitais. Reduz a liberdade que os "
"serializadores XML têm e, em vez disso, gera uma representação XML mais "
"restrita. As principais restrições dizem respeito ao posicionamento das "
"declarações de namespace, à ordenação dos atributos e aos espaços em branco "
"ignoráveis."

#: ../../library/xml.etree.elementtree.rst:515
msgid ""
"This function takes an XML data string (*xml_data*) or a file path or file-"
"like object (*from_file*) as input, converts it to the canonical form, and "
"writes it out using the *out* file(-like) object, if provided, or returns it "
"as a text string if not.  The output file receives text, not bytes.  It "
"should therefore be opened in text mode with ``utf-8`` encoding."
msgstr ""
"Esta função recebe uma string de dados XML (*xml_data*) ou um caminho de "
"ficheiro ou objeto tipo ficheiro (*from_file*) como entrada, converte-o para "
"a forma canónica, e escreve-o usando o objeto *out* tipo ficheiro, se "
"fornecido, ou devolve-o como uma string de texto se não. O ficheiro de saída "
"recebe texto, não bytes. Deve, portanto, ser aberto em modo de texto com "
"codificação ``utf-8``."

#: ../../library/xml.etree.elementtree.rst:522
msgid "Typical uses::"
msgstr "Usos típicos:"

#: ../../library/xml.etree.elementtree.rst:524
msgid ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"
msgstr ""
"xml_data = \"<root>...</root>\"\n"
"print(canonicalize(xml_data))\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(xml_data, out=out_file)\n"
"\n"
"with open(\"c14n_output.xml\", mode='w', encoding='utf-8') as out_file:\n"
"    canonicalize(from_file=\"inputfile.xml\", out=out_file)"

#: ../../library/xml.etree.elementtree.rst:533
msgid "The configuration *options* are as follows:"
msgstr "As opções de configuração são as seguintes:"

#: ../../library/xml.etree.elementtree.rst:535
msgid "*with_comments*: set to true to include comments (default: false)"
msgstr ""
"*with_comments*: defina como verdadeiro para incluir comentários "
"(predefinição: falso)"

#: ../../library/xml.etree.elementtree.rst:536
msgid ""
"*strip_text*: set to true to strip whitespace before and after text content"
msgstr ""
"*strip_text*: defina como verdadeiro para remover espaços em branco antes e "
"depois do conteúdo de texto"

#: ../../library/xml.etree.elementtree.rst:537
#: ../../library/xml.etree.elementtree.rst:539
msgid "(default: false)"
msgstr "(predefinição: falso)"

#: ../../library/xml.etree.elementtree.rst:538
msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr ""
"*rewrite_prefixes*: defina como verdadeiro para substituir prefixos de "
"namespace por \"n{number}\""

#: ../../library/xml.etree.elementtree.rst:540
msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr ""
"*qname_aware_tags*: um conjunto de nomes de etiquetas conscientes de qname "
"em que os prefixos"

#: ../../library/xml.etree.elementtree.rst:541
#: ../../library/xml.etree.elementtree.rst:543
msgid "should be replaced in text content (default: empty)"
msgstr "devem ser substituídos no conteúdo de texto (predefinição: vazio)"

#: ../../library/xml.etree.elementtree.rst:542
msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which prefixes"
msgstr ""
"*qname_aware_attrs*: um conjunto de nomes de atributos conscientes de qname "
"em que os prefixos"

#: ../../library/xml.etree.elementtree.rst:544
msgid "*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr ""
"*exclude_attrs*: um conjunto de nomes de atributos que não devem ser "
"serializados"

#: ../../library/xml.etree.elementtree.rst:545
msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr ""
"*exclude_tags*: um conjunto de nomes de etiquetas que não devem ser "
"serializados"

#: ../../library/xml.etree.elementtree.rst:547
msgid ""
"In the option list above, \"a set\" refers to any collection or iterable of "
"strings, no ordering is expected."
msgstr ""
"Na lista de opções acima, \"um conjunto\" refere-se a qualquer coleção ou "
"iterável de strings, não é esperada nenhuma ordenação."

#: ../../library/xml.etree.elementtree.rst:555
msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""
"Fábrica de elementos de comentário. Esta função de fábrica cria um elemento "
"especial que será serializado como um comentário XML pelo serializador "
"padrão. A string de comentário pode ser uma string de bytes ou uma string "
"Unicode. *text* é uma string contendo a string de comentário. Devolve uma "
"instância de elemento que representa um comentário."

#: ../../library/xml.etree.elementtree.rst:561
msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only contain "
"comment nodes if they have been inserted into to the tree using one of the :"
"class:`Element` methods."
msgstr ""
"Note que :class:`XMLParser` ignora comentários na entrada em vez de criar "
"objetos de comentário para eles. Uma :class:`ElementTree` só conterá nós de "
"comentário se estes tiverem sido inseridos na árvore usando um dos métodos "
"de :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:568
msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr ""
"Escreve uma árvore de elementos ou estrutura de elementos para sys.stdout. "
"Esta função deve ser usada apenas para depuração."

#: ../../library/xml.etree.elementtree.rst:571
msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr ""
"O formato exato da saída depende da implementação. Nesta versão, é escrito "
"como um ficheiro XML comum."

#: ../../library/xml.etree.elementtree.rst:574
msgid "*elem* is an element tree or an individual element."
msgstr "*elem* é uma árvore de elementos ou um elemento individual."

#: ../../library/xml.etree.elementtree.rst:576
msgid ""
"The :func:`dump` function now preserves the attribute order specified by the "
"user."
msgstr ""
"A função :func:`dump` agora preserva a ordem dos atributos especificada pelo "
"utilizador."

#: ../../library/xml.etree.elementtree.rst:583
msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used. Returns an :"
"class:`Element` instance."
msgstr ""
"Analisa uma secção XML a partir de uma constante de string. Igual a :func:"
"`XML`. *text* é uma string contendo dados XML. *parser* é uma instância de "
"analisador opcional. Se não for fornecida, é usado o analisador padrão :"
"class:`XMLParser`. Devolve uma instância de :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:591
msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a "
"list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Analisa um documento XML a partir de uma sequência de fragmentos de string. "
"*sequence* é uma lista ou outra sequência contendo fragmentos de dados XML. "
"*parser* é uma instância de analisador opcional. Se não for fornecida, é "
"usado o analisador padrão :class:`XMLParser`. Devolve uma instância de :"
"class:`Element`."

#: ../../library/xml.etree.elementtree.rst:601
msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can be "
"used to generate pretty-printed XML output. *tree* can be an Element or "
"ElementTree.  *space* is the whitespace string that will be inserted for "
"each indentation level, two space characters by default.  For indenting "
"partial subtrees inside of an already indented tree, pass the initial "
"indentation level as *level*."
msgstr ""
"Adiciona espaços em branco à sub-árvore para indentar a árvore visualmente. "
"Isto pode ser usado para gerar saída XML com formatação bonita. *tree* pode "
"ser um Element ou ElementTree. *space* é a string de espaços em branco que "
"será inserida para cada nível de indentação, dois caracteres de espaço por "
"predefinição. Para indentar sub-árvores parciais dentro de uma árvore já "
"indentada, passe o nível de indentação inicial como *level*."

#: ../../library/xml.etree.elementtree.rst:613
msgid ""
"Check if an object appears to be a valid element object.  *element* is an "
"element instance.  Return ``True`` if this is an element object."
msgstr ""
"Verifica se um objeto parece ser um objeto de elemento válido. *element* é "
"uma instância de elemento. Devolve ``True`` se isto for um objeto de "
"elemento."

#: ../../library/xml.etree.elementtree.rst:619
msgid ""
"Parses an XML section into an element tree incrementally, and reports what's "
"going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a sequence of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the \"ns\" "
"events are used to get detailed namespace information).  If *events* is "
"omitted, only ``\"end\"`` events are reported. *parser* is an optional "
"parser instance.  If not given, the standard :class:`XMLParser` parser is "
"used.  *parser* must be a subclass of :class:`XMLParser` and can only use "
"the default :class:`TreeBuilder` as a target. Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs; it has a ``root`` attribute that "
"references the root element of the resulting XML tree once *source* is fully "
"read. The iterator has the :meth:`!close` method that closes the internal "
"file object if *source* is a filename."
msgstr ""
"Analisa uma secção XML numa árvore de elementos de forma incremental e "
"relata o que está a acontecer ao utilizador. *source* é um nome de ficheiro "
"ou um :term:`objeto de ficheiro` contendo dados XML. *events* é uma "
"sequência de eventos a relatar. Os eventos suportados são as strings "
"``\"start\"``, ``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` e "
"``\"end-ns\"`` (os eventos \"ns\" são usados para obter informações "
"detalhadas de namespace). Se *events* for omitido, apenas os eventos "
"``\"end\"`` são relatados. *parser* é uma instância de analisador opcional. "
"Se não for fornecida, é usado o analisador padrão :class:`XMLParser`. "
"*parser* deve ser uma subclasse de :class:`XMLParser` e só pode usar o :"
"class:`TreeBuilder` predefinido como alvo. Devolve um :term:`iterador` que "
"fornece pares ``(event, elem)``; tem um atributo ``root`` que referencia o "
"elemento raiz da árvore XML resultante assim que *source* for completamente "
"lido. O iterador tem o método :meth:`!close` que fecha o objeto de ficheiro "
"interno se *source* for um nome de ficheiro."

#: ../../library/xml.etree.elementtree.rst:635
msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it issues "
"blocking reads on *source* (or the file it names).  As such, it's unsuitable "
"for applications where blocking reads can't be made.  For fully non-blocking "
"parsing, see :class:`XMLPullParser`."
msgstr ""
"Note que, embora :func:`iterparse` construa a árvore de forma incremental, "
"emite leituras bloqueantes em *source* (ou no ficheiro que nomeia). Como "
"tal, não é adequado para aplicações onde não podem ser feitas leituras "
"bloqueantes. Para análise completamente não bloqueante, consulte :class:"
"`XMLPullParser`."

#: ../../library/xml.etree.elementtree.rst:642
msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined, "
"but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""
":func:`iterparse` garante apenas que viu o carácter \">\" de uma etiqueta de "
"início quando emite um evento \"start\", por isso os atributos estão "
"definidos, mas o conteúdo dos atributos de texto e cauda estão indefinidos "
"nesse ponto. O mesmo se aplica aos filhos do elemento; podem ou não estar "
"presentes."

#: ../../library/xml.etree.elementtree.rst:648
#: ../../library/xml.etree.elementtree.rst:1521
msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr ""
"Se precisar de um elemento completamente preenchido, procure eventos \"end\" "
"em vez disso."

#: ../../library/xml.etree.elementtree.rst:650
msgid "The *parser* argument."
msgstr "O argumento *parser*."

#: ../../library/xml.etree.elementtree.rst:653
#: ../../library/xml.etree.elementtree.rst:1525
msgid "The ``comment`` and ``pi`` events were added."
msgstr "Os eventos ``comment`` e ``pi`` foram adicionados."

#: ../../library/xml.etree.elementtree.rst:656
msgid "Added the :meth:`!close` method."
msgstr "Adicionado o método :meth:`!close`."

#: ../../library/xml.etree.elementtree.rst:662
msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an :"
"class:`ElementTree` instance."
msgstr ""

#: ../../library/xml.etree.elementtree.rst:670
msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if "
"given.  Returns an element instance, representing a processing instruction."
msgstr ""
"Fábrica de elementos PI. Esta função de fábrica cria um elemento especial "
"que será serializado como uma instrução de processamento XML. *target* é uma "
"string contendo o alvo da PI. *text* é uma string contendo o conteúdo da PI, "
"se fornecido. Devolve uma instância de elemento, representando uma instrução "
"de processamento."

#: ../../library/xml.etree.elementtree.rst:675
msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the input "
"instead of creating PI objects for them. An :class:`ElementTree` will only "
"contain processing instruction nodes if they have been inserted into to the "
"tree using one of the :class:`Element` methods."
msgstr ""
"Note que :class:`XMLParser` ignora instruções de processamento na entrada em "
"vez de criar objetos PI para elas. Uma :class:`ElementTree` só conterá nós "
"de instruções de processamento se estes tiverem sido inseridos na árvore "
"usando um dos métodos de :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:683
msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at "
"all possible."
msgstr ""
"Regista um prefixo de namespace. O registo é global, e qualquer mapeamento "
"existente para o prefixo dado ou o URI do namespace será removido. *prefix* "
"é um prefixo de namespace. *uri* é um URI de namespace. Etiquetas e "
"atributos neste namespace serão serializados com o prefixo dado, se possível."

#: ../../library/xml.etree.elementtree.rst:694
msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr ""
"Fábrica de sub-elementos. Esta função cria uma instância de elemento e "
"adiciona-a a um elemento existente."

#: ../../library/xml.etree.elementtree.rst:697
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element "
"attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""
"O nome do elemento, os nomes dos atributos e os valores dos atributos podem "
"ser strings de bytes ou strings Unicode. *parent* é o elemento pai. *tag* é "
"o nome do sub-elemento. *attrib* é um dicionário opcional, contendo "
"atributos do elemento. *extra* contém atributos adicionais, dados como "
"argumentos de palavra-chave. Devolve uma instância de elemento."

#: ../../library/xml.etree.elementtree.rst:708
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns an (optionally) encoded string containing the XML data."
msgstr ""
"Gera uma representação em string de um elemento XML, incluindo todos os sub-"
"elementos. *element* é uma instância de :class:`Element`. *encoding* [1]_ é "
"a codificação de saída (predefinição é US-ASCII). Use "
"``encoding=\"unicode\"`` para gerar uma string Unicode (caso contrário, é "
"gerada uma string de bytes). *method* é ``\"xml\"``, ``\"html\"`` ou "
"``\"text\"`` (predefinição é ``\"xml\"``). *xml_declaration*, "
"*default_namespace* e *short_empty_elements* têm o mesmo significado que em :"
"meth:`ElementTree.write`. Devolve uma string (opcionalmente) codificada "
"contendo os dados XML."

#: ../../library/xml.etree.elementtree.rst:717
#: ../../library/xml.etree.elementtree.rst:744
#: ../../library/xml.etree.elementtree.rst:1198
msgid "Added the *short_empty_elements* parameter."
msgstr "Adicionado o parâmetro *short_empty_elements*."

#: ../../library/xml.etree.elementtree.rst:720
#: ../../library/xml.etree.elementtree.rst:747
msgid "Added the *xml_declaration* and *default_namespace* parameters."
msgstr "Adicionados os parâmetros *xml_declaration* e *default_namespace*."

#: ../../library/xml.etree.elementtree.rst:723
msgid ""
"The :func:`tostring` function now preserves the attribute order specified by "
"the user."
msgstr ""
"A função :func:`tostring` agora preserva a ordem dos atributos especificada "
"pelo utilizador."

#: ../../library/xml.etree.elementtree.rst:732
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns a list of (optionally) encoded strings containing the XML data. It "
"does not guarantee any specific sequence, except that ``b\"\"."
"join(tostringlist(element)) == tostring(element)``."
msgstr ""
"Gera uma representação em string de um elemento XML, incluindo todos os sub-"
"elementos. *element* é uma instância de :class:`Element`. *encoding* [1]_ é "
"a codificação de saída (predefinição é US-ASCII). Use "
"``encoding=\"unicode\"`` para gerar uma string Unicode (caso contrário, é "
"gerada uma string de bytes). *method* é ``\"xml\"``, ``\"html\"`` ou "
"``\"text\"`` (predefinição é ``\"xml\"``). *xml_declaration*, "
"*default_namespace* e *short_empty_elements* têm o mesmo significado que em :"
"meth:`ElementTree.write`. Devolve uma lista de strings (opcionalmente) "
"codificadas contendo os dados XML. Não garante nenhuma sequência específica, "
"exceto que ``b\"\".join(tostringlist(element)) == tostring(element)``."

#: ../../library/xml.etree.elementtree.rst:750
msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ""
"A função :func:`tostringlist` agora preserva a ordem dos atributos "
"especificada pelo utilizador."

#: ../../library/xml.etree.elementtree.rst:757
msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Analisa uma secção XML a partir de uma constante de string. Esta função pode "
"ser usada para incorporar \"literais XML\" em código Python. *text* é uma "
"string contendo dados XML. *parser* é uma instância de analisador opcional. "
"Se não for fornecida, é usado o analisador padrão :class:`XMLParser`. "
"Devolve uma instância de :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:765
msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns a tuple containing an :class:"
"`Element` instance and a dictionary."
msgstr ""
"Analisa uma secção XML a partir de uma constante de string e também devolve "
"um dicionário que mapeia IDs de elementos para elementos. *text* é uma "
"string contendo dados XML. *parser* é uma instância de analisador opcional. "
"Se não for fornecida, é usado o analisador padrão :class:`XMLParser`. "
"Devolve um tuplo contendo uma instância de :class:`Element` e um dicionário."

#: ../../library/xml.etree.elementtree.rst:775
msgid "XInclude support"
msgstr "Suporte XInclude"

#: ../../library/xml.etree.elementtree.rst:777
msgid ""
"This module provides limited support for `XInclude directives <https://www."
"w3.org/TR/xinclude/>`_, via the :mod:`xml.etree.ElementInclude` helper "
"module.  This module can be used to insert subtrees and text strings into "
"element trees, based on information in the tree."
msgstr ""
"Este módulo fornece suporte limitado para `diretivas XInclude <https://www."
"w3.org/TR/xinclude/>`_, através do módulo auxiliar :mod:`xml.etree."
"ElementInclude`. Este módulo pode ser usado para inserir sub-árvores e "
"strings de texto em árvores de elementos, com base em informações na árvore."

#: ../../library/xml.etree.elementtree.rst:783
msgid ""
"Here's an example that demonstrates use of the XInclude module. To include "
"an XML document in the current document, use the ``{http://www.w3.org/2001/"
"XInclude}include`` element and set the **parse** attribute to ``\"xml\"``, "
"and use the **href** attribute to specify the document to include."
msgstr ""
"Aqui está um exemplo que demonstra o uso do módulo XInclude. Para incluir um "
"documento XML no documento atual, use o elemento ``{http://www.w3.org/2001/"
"XInclude}include`` e defina o atributo **parse** para ``\"xml\"``, e use o "
"atributo **href** para especificar o documento a incluir."

#: ../../library/xml.etree.elementtree.rst:785
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <xi:include href=\"source.xml\" parse=\"xml\" />\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:792
msgid ""
"By default, the **href** attribute is treated as a file name. You can use "
"custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"Por predefinição, o atributo **href** é tratado como um nome de ficheiro. "
"Pode usar carregadores personalizados para substituir este comportamento. "
"Note também que o auxiliar padrão não suporta a sintaxe XPointer."

#: ../../library/xml.etree.elementtree.rst:794
msgid ""
"To process this file, load it as usual, and pass the root element to the :"
"mod:`xml.etree.ElementTree` module:"
msgstr ""
"Para processar este ficheiro, carregue-o como habitual e passe o elemento "
"raiz para o módulo :mod:`xml.etree.ElementTree`:"

#: ../../library/xml.etree.elementtree.rst:796
msgid ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"
msgstr ""
"from xml.etree import ElementTree, ElementInclude\n"
"\n"
"tree = ElementTree.parse(\"document.xml\")\n"
"root = tree.getroot()\n"
"\n"
"ElementInclude.include(root)"

#: ../../library/xml.etree.elementtree.rst:805
msgid ""
"The ElementInclude module replaces the ``{http://www.w3.org/2001/XInclude}"
"include`` element with the root element from the **source.xml** document. "
"The result might look something like this:"
msgstr ""
"O módulo ElementInclude substitui o elemento ``{http://www.w3.org/2001/"
"XInclude}include`` pelo elemento raiz do documento **source.xml**. O "
"resultado pode parecer algo como isto:"

#: ../../library/xml.etree.elementtree.rst:807
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>This is a paragraph.</para>\n"
"</document>"
msgstr ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  <para>Este é um parágrafo.</para>\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:813
msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr ""
"Se o atributo **parse** for omitido, o valor predefinido é \"xml\". O "
"atributo href é obrigatório."

#: ../../library/xml.etree.elementtree.rst:815
msgid ""
"To include a text document, use the ``{http://www.w3.org/2001/XInclude}"
"include`` element, and set the **parse** attribute to \"text\":"
msgstr ""
"Para incluir um documento de texto, use o elemento ``{http://www.w3.org/2001/"
"XInclude}include`` e defina o atributo **parse** para \"text\":"

#: ../../library/xml.etree.elementtree.rst:817
msgid ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) <xi:include href=\"year.txt\" parse=\"text\" />.\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:824
msgid "The result might look something like:"
msgstr "O resultado pode parecer algo como:"

#: ../../library/xml.etree.elementtree.rst:826
msgid ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"
msgstr ""
"<document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n"
"  Copyright (c) 2003.\n"
"</document>"

#: ../../library/xml.etree.elementtree.rst:844
msgid ""
"Default loader. This default loader reads an included resource from disk. "
"*href* is a URL.  *parse* is for parse mode either \"xml\" or \"text\". "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``. Returns the expanded resource. If the parse mode is ``\"xml\"``, "
"this is an :class:`~xml.etree.ElementTree.Element` instance. If the parse "
"mode is ``\"text\"``, this is a string. If the loader fails, it can return "
"``None`` or raise an exception."
msgstr ""
"Carregador predefinido. Este carregador predefinido lê um recurso incluído a "
"partir do disco. *href* é um URL. *parse* é para o modo de análise, \"xml\" "
"ou \"text\". *encoding* é uma codificação de texto opcional. Se não for "
"fornecida, a codificação é ``utf-8``. Devolve o recurso expandido. Se o modo "
"de análise for ``\"xml\"``, isto é uma instância de :class:`~xml.etree."
"ElementTree.Element`. Se o modo de análise for ``\"text\"``, isto é uma "
"string. Se o carregador falhar, pode devolver ``None`` ou levantar uma "
"exceção."

#: ../../library/xml.etree.elementtree.rst:855
msgid ""
"This function expands XInclude directives in-place in tree pointed by "
"*elem*. *elem* is either the root :class:`~xml.etree.ElementTree.Element` or "
"an :class:`~xml.etree.ElementTree.ElementTree` instance to find such "
"element. *loader* is an optional resource loader.  If omitted, it defaults "
"to :func:`default_loader`. If given, it should be a callable that implements "
"the same interface as :func:`default_loader`.  *base_url* is base URL of the "
"original file, to resolve relative include file references.  *max_depth* is "
"the maximum number of recursive inclusions.  Limited to reduce the risk of "
"malicious content explosion. Pass ``None`` to disable the limitation."
msgstr ""
"Esta função expande diretivas XInclude no local na árvore apontada por "
"*elem*. *elem* é ou o elemento raiz :class:`~xml.etree.ElementTree.Element` "
"ou uma instância de :class:`~xml.etree.ElementTree.ElementTree` para "
"encontrar tal elemento. *loader* é um carregador de recursos opcional. Se "
"omitido, o predefinido é :func:`default_loader`. Se fornecido, deve ser um "
"objeto chamável que implementa a mesma interface que :func:`default_loader`. "
"*base_url* é o URL base do ficheiro original, para resolver referências de "
"ficheiros incluídos relativos. *max_depth* é o número máximo de inclusões "
"recursivas. Limitado para reduzir o risco de explosão de conteúdo malicioso. "
"Passe ``None`` para desativar a limitação."

#: ../../library/xml.etree.elementtree.rst:865
msgid "Added the *base_url* and *max_depth* parameters."
msgstr "Adicionados os parâmetros *base_url* e *max_depth*."

#: ../../library/xml.etree.elementtree.rst:872
msgid "Element Objects"
msgstr "Objetos Element"

#: ../../library/xml.etree.elementtree.rst:880
msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr ""
"Classe Element. Esta classe define a interface Element e fornece uma "
"implementação de referência desta interface."

#: ../../library/xml.etree.elementtree.rst:883
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"O nome do elemento, os nomes dos atributos e os valores dos atributos podem "
"ser strings de bytes ou strings Unicode. *tag* é o nome do elemento. "
"*attrib* é um dicionário opcional, contendo atributos do elemento. *extra* "
"contém atributos adicionais, dados como argumentos de palavra-chave."

#: ../../library/xml.etree.elementtree.rst:891
msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr ""
"Uma string que identifica que tipo de dados este elemento representa (o tipo "
"de elemento, em outras palavras)."

#: ../../library/xml.etree.elementtree.rst:898
msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds either "
"the text between the element's end tag and the next tag, or ``None``.  For "
"the XML data"
msgstr ""
"Estes atributos podem ser usados para armazenar dados adicionais associados "
"ao elemento. Os seus valores são geralmente strings, mas podem ser qualquer "
"objeto específico da aplicação. Se o elemento for criado a partir de um "
"ficheiro XML, o atributo *text* contém ou o texto entre a etiqueta de início "
"do elemento e o seu primeiro filho ou etiqueta de fim, ou ``None``, e o "
"atributo *tail* contém ou o texto entre a etiqueta de fim do elemento e a "
"próxima etiqueta, ou ``None``. Para os dados XML"

#: ../../library/xml.etree.elementtree.rst:906
msgid "<a><b>1<c>2<d/>3</c></b>4</a>"
msgstr "<a><b>1<c>2<d/>3</c></b>4</a>"

#: ../../library/xml.etree.elementtree.rst:910
msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the *b* "
"element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element has "
"*text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"o elemento *a* tem ``None`` para os atributos *text* e *tail*, o elemento "
"*b* tem *text* ``\"1\"`` e *tail* ``\"4\"``, o elemento *c* tem *text* "
"``\"2\"`` e *tail* ``None``, e o elemento *d* tem *text* ``None`` e *tail* "
"``\"3\"``."

#: ../../library/xml.etree.elementtree.rst:915
msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for example "
"``\"\".join(element.itertext())``."
msgstr ""
"Para recolher o texto interno de um elemento, consulte :meth:`itertext`, por "
"exemplo, ``\"\".join(element.itertext())``."

#: ../../library/xml.etree.elementtree.rst:918
msgid "Applications may store arbitrary objects in these attributes."
msgstr "As aplicações podem armazenar objetos arbitrários nestes atributos."

#: ../../library/xml.etree.elementtree.rst:923
msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create "
"the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""
"Um dicionário contendo os atributos do elemento. Note que, embora o valor de "
"*attrib* seja sempre um dicionário Python mutável real, uma implementação de "
"ElementTree pode optar por usar outra representação interna e criar o "
"dicionário apenas se alguém o solicitar. Para tirar partido de tais "
"implementações, use os métodos de dicionário abaixo sempre que possível."

#: ../../library/xml.etree.elementtree.rst:929
msgid "The following dictionary-like methods work on the element attributes."
msgstr ""
"Os seguintes métodos semelhantes a dicionários funcionam nos atributos do "
"elemento."

#: ../../library/xml.etree.elementtree.rst:934
msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""
"Reinicia um elemento. Esta função remove todos os sub-elementos, limpa todos "
"os atributos e define os atributos de texto e cauda para ``None``."

#: ../../library/xml.etree.elementtree.rst:940
msgid "Gets the element attribute named *key*."
msgstr "Obtém o atributo do elemento chamado *key*."

#: ../../library/xml.etree.elementtree.rst:942
msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr ""
"Devolve o valor do atributo, ou *default* se o atributo não for encontrado."

#: ../../library/xml.etree.elementtree.rst:947
msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr ""
"Devolve os atributos do elemento como uma sequência de pares (nome, valor). "
"Os atributos são devolvidos numa ordem arbitrária."

#: ../../library/xml.etree.elementtree.rst:953
msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr ""
"Devolve os nomes dos atributos do elemento como uma lista. Os nomes são "
"devolvidos numa ordem arbitrária."

#: ../../library/xml.etree.elementtree.rst:959
msgid "Set the attribute *key* on the element to *value*."
msgstr "Define o atributo *key* no elemento para *value*."

#: ../../library/xml.etree.elementtree.rst:961
msgid "The following methods work on the element's children (subelements)."
msgstr "Os seguintes métodos funcionam nos filhos do elemento (sub-elementos)."

#: ../../library/xml.etree.elementtree.rst:966
msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an :class:"
"`Element`."
msgstr ""
"Adiciona o elemento *subelement* ao fim da lista interna de sub-elementos "
"deste elemento. Levanta :exc:`TypeError` se *subelement* não for um :class:"
"`Element`."

#: ../../library/xml.etree.elementtree.rst:973
msgid ""
"Appends *subelements* from an iterable of elements. Raises :exc:`TypeError` "
"if a subelement is not an :class:`Element`."
msgstr ""
"Adiciona *subelementos* de um iterável de elementos. Levanta :exc:"
"`TypeError` se um sub-elemento não for um :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:981
msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or "
"a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Encontra o primeiro sub-elemento correspondente a *match*. *match* pode ser "
"um nome de etiqueta ou um :ref:`caminho <elementtree-xpath>`. Devolve uma "
"instância de elemento ou ``None``. *namespaces* é um mapeamento opcional de "
"prefixo de namespace para nome completo. Passe ``''`` como prefixo para "
"mover todos os nomes de etiqueta não prefixados na expressão para o "
"namespace dado."

#: ../../library/xml.etree.elementtree.rst:990
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Encontra todos os sub-elementos correspondentes, por nome de etiqueta ou :"
"ref:`caminho <elementtree-xpath>`. Devolve uma lista contendo todos os "
"elementos correspondentes na ordem do documento. *namespaces* é um "
"mapeamento opcional de prefixo de namespace para nome completo. Passe ``''`` "
"como prefixo para mover todos os nomes de etiqueta não prefixados na "
"expressão para o namespace dado."

#: ../../library/xml.etree.elementtree.rst:999
msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"Encontra texto para o primeiro sub-elemento correspondente a *match*. "
"*match* pode ser um nome de etiqueta ou um :ref:`caminho <elementtree-"
"xpath>`. Devolve o conteúdo de texto do primeiro elemento correspondente, ou "
"*default* se nenhum elemento for encontrado. Note que se o elemento "
"correspondente não tiver conteúdo de texto, uma string vazia é devolvida. "
"*namespaces* é um mapeamento opcional de prefixo de namespace para nome "
"completo. Passe ``''`` como prefixo para mover todos os nomes de etiqueta "
"não prefixados na expressão para o namespace dado."

#: ../../library/xml.etree.elementtree.rst:1010
msgid ""
"Inserts *subelement* at the given position in this element.  Raises :exc:"
"`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"Insere *subelement* na posição dada neste elemento. Levanta :exc:`TypeError` "
"se *subelement* não for um :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:1016
msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""
"Cria um :term:`iterador` de árvore com o elemento atual como raiz. O "
"iterador itera sobre este elemento e todos os elementos abaixo dele, na "
"ordem do documento (profundidade primeiro). Se *tag* não for ``None`` ou "
"``'*'``, apenas elementos cuja etiqueta seja igual a *tag* são devolvidos "
"pelo iterador. Se a estrutura da árvore for modificada durante a iteração, o "
"resultado é indefinido."

#: ../../library/xml.etree.elementtree.rst:1027
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"Encontra todos os sub-elementos correspondentes, por nome de etiqueta ou :"
"ref:`caminho <elementtree-xpath>`. Devolve um iterável que produz todos os "
"elementos correspondentes na ordem do documento. *namespaces* é um "
"mapeamento opcional de prefixo de namespace para nome completo."

#: ../../library/xml.etree.elementtree.rst:1038
msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""
"Cria um iterador de texto. O iterador percorre este elemento e todos os sub-"
"elementos, na ordem do documento, e devolve todo o texto interno."

#: ../../library/xml.etree.elementtree.rst:1046
msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr ""
"Cria um novo objeto de elemento do mesmo tipo que este elemento. Não chame "
"este método, use a função de fábrica :func:`SubElement` em vez disso."

#: ../../library/xml.etree.elementtree.rst:1052
msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or "
"contents."
msgstr ""
"Remove *subelement* do elemento. Ao contrário dos métodos find\\*, este "
"método compara elementos com base na identidade da instância, não no valor "
"da etiqueta ou conteúdo."

#: ../../library/xml.etree.elementtree.rst:1056
msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__len__`."
msgstr ""
"Os objetos :class:`Element` também suportam os seguintes métodos de tipo de "
"sequência para trabalhar com sub-elementos: :meth:`~object.__delitem__`, :"
"meth:`~object.__getitem__`, :meth:`~object.__setitem__`, :meth:`~object."
"__len__`."

#: ../../library/xml.etree.elementtree.rst:1061
msgid ""
"Caution: Elements with no subelements will test as ``False``.  In a future "
"release of Python, all elements will test as ``True`` regardless of whether "
"subelements exist.  Instead, prefer explicit ``len(elem)`` or ``elem is not "
"None`` tests.::"
msgstr ""
"Cuidado: Elementos sem sub-elementos serão avaliados como ``False``. Numa "
"futura versão do Python, todos os elementos serão avaliados como ``True`` "
"independentemente de existirem sub-elementos. Em vez disso, prefira testes "
"explícitos ``len(elem)`` ou ``elem is not None``."

#: ../../library/xml.etree.elementtree.rst:1066
msgid ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"
msgstr ""
"element = root.find('foo')\n"
"\n"
"if not element:  # cuidado!\n"
"    print(\"elemento não encontrado, ou elemento não tem sub-elementos\")\n"
"\n"
"if element is None:\n"
"    print(\"elemento não encontrado\")"

#: ../../library/xml.etree.elementtree.rst:1074
msgid "Testing the truth value of an Element emits :exc:`DeprecationWarning`."
msgstr ""
"Testar o valor de verdade de um Element emite :exc:`DeprecationWarning`."

#: ../../library/xml.etree.elementtree.rst:1077
msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary "
"reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"Antes do Python 3.8, a ordem de serialização dos atributos XML dos elementos "
"era artificialmente tornada previsível ordenando os atributos pelo seu nome. "
"Com base na ordenação agora garantida dos dicionários, esta reordenação "
"arbitrária foi removida no Python 3.8 para preservar a ordem em que os "
"atributos foram originalmente analisados ou criados pelo código do "
"utilizador."

#: ../../library/xml.etree.elementtree.rst:1083
msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. In "
"cases where deterministic XML output is required, e.g. for cryptographic "
"signing or test data sets, canonical serialisation is available with the :"
"func:`canonicalize` function."
msgstr ""
"Em geral, o código do utilizador não deve depender de uma ordem específica "
"de atributos, dado que o `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ exclui explicitamente a ordem dos atributos de transmitir "
"informação. O código deve estar preparado para lidar com qualquer ordem na "
"entrada. Em casos em que é necessária saída XML determinística, por exemplo, "
"para assinaturas criptográficas ou conjuntos de dados de teste, a "
"serialização canónica está disponível com a função :func:`canonicalize`."

#: ../../library/xml.etree.elementtree.rst:1091
msgid ""
"In cases where canonical output is not applicable but a specific attribute "
"order is still desirable on output, code should aim for creating the "
"attributes directly in the desired order, to avoid perceptual mismatches for "
"readers of the code. In cases where this is difficult to achieve, a recipe "
"like the following can be applied prior to serialisation to enforce an order "
"independently from the Element creation::"
msgstr ""
"Em casos em que a saída canónica não é aplicável, mas uma ordem específica "
"de atributos ainda é desejável na saída, o código deve visar criar os "
"atributos diretamente na ordem desejada, para evitar discrepâncias "
"percetuais para os leitores do código. Em casos em que isto é difícil de "
"alcançar, uma receita como a seguinte pode ser aplicada antes da "
"serialização para impor uma ordem independentemente da criação do Elemento:"

#: ../../library/xml.etree.elementtree.rst:1098
msgid ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # adjust attribute order, e.g. by sorting\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"
msgstr ""
"def reorder_attributes(root):\n"
"    for el in root.iter():\n"
"        attrib = el.attrib\n"
"        if len(attrib) > 1:\n"
"            # ajustar a ordem dos atributos, por exemplo, ordenando\n"
"            attribs = sorted(attrib.items())\n"
"            attrib.clear()\n"
"            attrib.update(attribs)"

#: ../../library/xml.etree.elementtree.rst:1111
msgid "ElementTree Objects"
msgstr "Objetos ElementTree"

#: ../../library/xml.etree.elementtree.rst:1116
msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""
"Classe de invólucro ElementTree. Esta classe representa uma hierarquia de "
"elementos completa e adiciona algum suporte extra para serialização para e a "
"partir de XML padrão."

#: ../../library/xml.etree.elementtree.rst:1120
msgid ""
"*element* is the root element.  The tree is initialized with the contents of "
"the XML *file* if given."
msgstr ""
"*element* é o elemento raiz. A árvore é inicializada com o conteúdo do "
"ficheiro XML *file*, se fornecido."

#: ../../library/xml.etree.elementtree.rst:1126
msgid ""
"Replaces the root element for this tree.  This discards the current contents "
"of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr ""
"Substitui o elemento raiz desta árvore. Isto descarta o conteúdo atual da "
"árvore e substitui-o pelo elemento dado. Use com cuidado. *element* é uma "
"instância de elemento."

#: ../../library/xml.etree.elementtree.rst:1133
msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr "Igual a :meth:`Element.find`, começando na raiz da árvore."

#: ../../library/xml.etree.elementtree.rst:1138
msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr "Igual a :meth:`Element.findall`, começando na raiz da árvore."

#: ../../library/xml.etree.elementtree.rst:1143
msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr "Igual a :meth:`Element.findtext`, começando na raiz da árvore."

#: ../../library/xml.etree.elementtree.rst:1148
msgid "Returns the root element for this tree."
msgstr "Devolve o elemento raiz desta árvore."

#: ../../library/xml.etree.elementtree.rst:1153
msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to "
"look for (default is to return all elements)."
msgstr ""
"Cria e devolve um iterador de árvore para o elemento raiz. O iterador "
"percorre todos os elementos nesta árvore, na ordem da secção. *tag* é a "
"etiqueta a procurar (predefinição é devolver todos os elementos)."

#: ../../library/xml.etree.elementtree.rst:1160
msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr "Igual a :meth:`Element.iterfind`, começando na raiz da árvore."

#: ../../library/xml.etree.elementtree.rst:1167
msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""
"Carrega uma secção XML externa nesta árvore de elementos. *source* é um nome "
"de ficheiro ou :term:`objeto de ficheiro`. *parser* é uma instância de "
"analisador opcional. Se não for fornecida, é usado o analisador padrão :"
"class:`XMLParser`. Devolve o elemento raiz da secção."

#: ../../library/xml.etree.elementtree.rst:1177
msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a :"
"term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``). The keyword-only *short_empty_elements* parameter "
"controls the formatting of elements that contain no content.  If ``True`` "
"(the default), they are emitted as a single self-closed tag, otherwise they "
"are emitted as a pair of start/end tags."
msgstr ""
"Escreve a árvore de elementos num ficheiro, como XML. *file* é um nome de "
"ficheiro ou um :term:`objeto de ficheiro` aberto para escrita. *encoding* "
"[1]_ é a codificação de saída (predefinição é US-ASCII). *xml_declaration* "
"controla se uma declaração XML deve ser adicionada ao ficheiro. Use "
"``False`` para nunca, ``True`` para sempre, ``None`` apenas se não for US-"
"ASCII ou UTF-8 ou Unicode (predefinição é ``None``). *default_namespace* "
"define o namespace XML predefinido (para \"xmlns\"). *method* é ``\"xml\"``, "
"``\"html\"`` ou ``\"text\"`` (predefinição é ``\"xml\"``). O parâmetro "
"*short_empty_elements* apenas de palavra-chave controla a formatação de "
"elementos que não contêm conteúdo. Se ``True`` (predefinição), são emitidos "
"como uma única etiqueta auto-fechada, caso contrário são emitidos como um "
"par de etiquetas de início/fim."

#: ../../library/xml.etree.elementtree.rst:1191
msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""
"A saída é uma string (:class:`str`) ou binária (:class:`bytes`). Isto é "
"controlado pelo argumento *encoding*. Se *encoding* for ``\"unicode\"``, a "
"saída é uma string; caso contrário, é binária. Note que isto pode entrar em "
"conflito com o tipo de *file* se for um :term:`objeto de ficheiro` aberto; "
"certifique-se de que não tenta escrever uma string num fluxo binário e vice-"
"versa."

#: ../../library/xml.etree.elementtree.rst:1201
msgid ""
"The :meth:`write` method now preserves the attribute order specified by the "
"user."
msgstr ""
"O método :meth:`write` agora preserva a ordem dos atributos especificada "
"pelo utilizador."

#: ../../library/xml.etree.elementtree.rst:1206
msgid "This is the XML file that is going to be manipulated::"
msgstr "Este é o ficheiro XML que vai ser manipulado:"

#: ../../library/xml.etree.elementtree.rst:1208
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"
msgstr ""
"<html>\n"
"    <head>\n"
"        <title>Página de exemplo</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Movido para <a href=\"http://example.org/\">example.org</a>\n"
"        ou <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"

#: ../../library/xml.etree.elementtree.rst:1218
msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr ""
"Exemplo de alteração do atributo \"target\" de todas as ligações no primeiro "
"parágrafo:"

#: ../../library/xml.etree.elementtree.rst:1220
msgid ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Finds first occurrence of tag p in body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Returns list of all links\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Iterates through all found links\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"
msgstr ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Encontra a primeira ocorrência da "
"etiqueta p em body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Devolve uma lista de todas as ligações\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Itera através de todas as ligações "
"encontradas\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
"...\n"
">>> tree.write(\"output.xhtml\")"

#: ../../library/xml.etree.elementtree.rst:1238
msgid "QName Objects"
msgstr "Objetos QName"

#: ../../library/xml.etree.elementtree.rst:1243
msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is "
"interpreted as a URI, and this argument is interpreted as a local name. :"
"class:`QName` instances are opaque."
msgstr ""
"Invólucro QName. Isto pode ser usado para envolver um valor de atributo "
"QName, a fim de obter um tratamento adequado de namespace na saída. "
"*text_or_uri* é uma string contendo o valor QName, na forma {uri}local, ou, "
"se o argumento tag for fornecido, a parte URI de um QName. Se *tag* for "
"fornecido, o primeiro argumento é interpretado como um URI, e este argumento "
"é interpretado como um nome local. As instâncias de :class:`QName` são "
"opacas."

#: ../../library/xml.etree.elementtree.rst:1255
msgid "TreeBuilder Objects"
msgstr "Objetos TreeBuilder"

#: ../../library/xml.etree.elementtree.rst:1261
msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"Construtor genérico de estrutura de elementos. Este construtor converte uma "
"sequência de chamadas de métodos start, data, end, comment e pi numa "
"estrutura de elementos bem formada. Pode usar esta classe para construir uma "
"estrutura de elementos usando um analisador XML personalizado, ou um "
"analisador para algum outro formato semelhante a XML."

#: ../../library/xml.etree.elementtree.rst:1266
msgid ""
"*element_factory*, when given, must be a callable accepting two positional "
"arguments: a tag and a dict of attributes.  It is expected to return a new "
"element instance."
msgstr ""
"*element_factory*, quando fornecido, deve ser um objeto chamável que aceite "
"dois argumentos posicionais: uma etiqueta e um dicionário de atributos. "
"Espera-se que devolva uma nova instância de elemento."

#: ../../library/xml.etree.elementtree.rst:1270
msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should behave "
"like the :func:`Comment` and :func:`ProcessingInstruction` functions to "
"create comments and processing instructions.  When not given, the default "
"factories will be used.  When *insert_comments* and/or *insert_pis* is true, "
"comments/pis will be inserted into the tree if they appear within the root "
"element (but not outside of it)."
msgstr ""
"As funções *comment_factory* e *pi_factory*, quando fornecidas, devem "
"comportar-se como as funções :func:`Comment` e :func:`ProcessingInstruction` "
"para criar comentários e instruções de processamento. Quando não fornecidas, "
"serão usadas as fábricas predefinidas. Quando *insert_comments* e/ou "
"*insert_pis* for verdadeiro, comentários/instruções de processamento serão "
"inseridos na árvore se aparecerem dentro do elemento raiz (mas não fora "
"dele)."

#: ../../library/xml.etree.elementtree.rst:1279
msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr ""
"Limpa os buffers do construtor e devolve o elemento de documento de nível "
"superior. Devolve uma instância de :class:`Element`."

#: ../../library/xml.etree.elementtree.rst:1285
msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr ""
"Adiciona texto ao elemento atual. *data* é uma string. Isto deve ser uma "
"string de bytes ou uma string Unicode."

#: ../../library/xml.etree.elementtree.rst:1291
msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr ""
"Fecha o elemento atual. *tag* é o nome do elemento. Devolve o elemento "
"fechado."

#: ../../library/xml.etree.elementtree.rst:1297
msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr ""
"Abre um novo elemento. *tag* é o nome do elemento. *attrs* é um dicionário "
"contendo atributos do elemento. Devolve o elemento aberto."

#: ../../library/xml.etree.elementtree.rst:1303
msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true, "
"this will also add it to the tree."
msgstr ""
"Cria um comentário com o *text* dado. Se ``insert_comments`` for verdadeiro, "
"isto também o adicionará à árvore."

#: ../../library/xml.etree.elementtree.rst:1311
msgid ""
"Creates a process instruction with the given *target* name and *text*. If "
"``insert_pis`` is true, this will also add it to the tree."
msgstr ""
"Cria uma instrução de processamento com o nome *target* e *text* dados. Se "
"``insert_pis`` for verdadeiro, isto também a adicionará à árvore."

#: ../../library/xml.etree.elementtree.rst:1317
msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"methods:"
msgstr ""
"Além disso, um objeto :class:`TreeBuilder` personalizado pode fornecer os "
"seguintes métodos:"

#: ../../library/xml.etree.elementtree.rst:1322
msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not "
"exist on the default :class:`TreeBuilder` class."
msgstr ""
"Trata uma declaração de doctype. *name* é o nome do doctype. *pubid* é o "
"identificador público. *system* é o identificador do sistema. Este método "
"não existe na classe :class:`TreeBuilder` predefinida."

#: ../../library/xml.etree.elementtree.rst:1330
msgid ""
"Is called whenever the parser encounters a new namespace declaration, before "
"the ``start()`` callback for the opening element that defines it. *prefix* "
"is ``''`` for the default namespace and the declared namespace prefix name "
"otherwise.  *uri* is the namespace URI."
msgstr ""
"É chamado sempre que o analisador encontrar uma nova declaração de "
"namespace, antes do callback ``start()`` para o elemento de abertura que o "
"define. *prefix* é ``''`` para o namespace predefinido e o nome do prefixo "
"do namespace declarado, caso contrário. *uri* é o URI do namespace."

#: ../../library/xml.etree.elementtree.rst:1339
msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr ""
"É chamado após o callback ``end()`` de um elemento que declarou um "
"mapeamento de prefixo de namespace, com o nome do *prefix* que saiu do "
"âmbito."

#: ../../library/xml.etree.elementtree.rst:1351
msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are the "
"same as for the :func:`canonicalize` function.  This class does not build a "
"tree but translates the callback events directly into a serialised form "
"using the *write* function."
msgstr ""
"Um escritor `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_. Os argumentos "
"são os mesmos que para a função :func:`canonicalize`. Esta classe não "
"constrói uma árvore, mas traduz os eventos de callback diretamente numa "
"forma serializada usando a função *write*."

#: ../../library/xml.etree.elementtree.rst:1362
msgid "XMLParser Objects"
msgstr "Objetos XMLParser"

#: ../../library/xml.etree.elementtree.rst:1367
msgid ""
"This class is the low-level building block of the module.  It uses :mod:`xml."
"parsers.expat` for efficient, event-based parsing of XML.  It can be fed XML "
"data incrementally with the :meth:`feed` method, and parsing events are "
"translated to a push API - by invoking callbacks on the *target* object.  If "
"*target* is omitted, the standard :class:`TreeBuilder` is used. If "
"*encoding* [1]_ is given, the value overrides the encoding specified in the "
"XML file."
msgstr ""
"Esta classe é o bloco de construção de baixo nível do módulo. Usa :mod:`xml."
"parsers.expat` para análise eficiente e baseada em eventos de XML. Pode ser "
"alimentada com dados XML de forma incremental com o método :meth:`feed`, e "
"os eventos de análise são traduzidos para uma API push - invocando callbacks "
"no objeto *target*. Se *target* for omitido, é usado o :class:`TreeBuilder` "
"padrão. Se *encoding* [1]_ for fornecido, o valor substitui a codificação "
"especificada no ficheiro XML."

#: ../../library/xml.etree.elementtree.rst:1375
msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The *html* "
"argument is no longer supported."
msgstr ""
"Os parâmetros são agora :ref:`apenas de palavra-chave <keyword-"
"only_parameter>`. O argumento *html* já não é suportado."

#: ../../library/xml.etree.elementtree.rst:1382
msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""
"Termina a alimentação de dados para o analisador. Devolve o resultado de "
"chamar o método ``close()`` do *target* passado durante a construção; por "
"predefinição, este é o elemento de documento de nível superior."

#: ../../library/xml.etree.elementtree.rst:1389
msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "Alimenta dados para o analisador. *data* são dados codificados."

#: ../../library/xml.etree.elementtree.rst:1394
#: ../../library/xml.etree.elementtree.rst:1472
msgid ""
"Triggers parsing of any previously fed unparsed data, which can be used to "
"ensure more immediate feedback, in particular with Expat >=2.6.0. The "
"implementation of :meth:`flush` temporarily disables reparse deferral with "
"Expat (if currently enabled) and triggers a reparse. Disabling reparse "
"deferral has security consequences; please see :meth:`xml.parsers.expat."
"xmlparser.SetReparseDeferralEnabled` for details."
msgstr ""
"Dispara a análise de quaisquer dados não analisados alimentados "
"anteriormente, o que pode ser usado para garantir feedback mais imediato, em "
"particular com Expat >=2.6.0. A implementação de :meth:`flush` desativa "
"temporariamente o adiamento de reanálise com Expat (se atualmente ativado) e "
"dispara uma reanálise. Desativar o adiamento de reanálise tem consequências "
"de segurança; consulte :meth:`xml.parsers.expat.xmlparser."
"SetReparseDeferralEnabled` para detalhes."

#: ../../library/xml.etree.elementtree.rst:1401
#: ../../library/xml.etree.elementtree.rst:1479
msgid ""
"Note that :meth:`flush` has been backported to some prior releases of "
"CPython as a security fix.  Check for availability of :meth:`flush` using :"
"func:`hasattr` if used in code running across a variety of Python versions."
msgstr ""
"Note que :meth:`flush` foi retroportado para algumas versões anteriores do "
"CPython como uma correção de segurança. Verifique a disponibilidade de :meth:"
"`flush` usando :func:`hasattr` se usado em código que é executado em várias "
"versões do Python."

#: ../../library/xml.etree.elementtree.rst:1409
msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` method "
"for each opening tag, its ``end(tag)`` method for each closing tag, and data "
"is processed by method ``data(data)``.  For further supported callback "
"methods, see the :class:`TreeBuilder` class.  :meth:`XMLParser.close` calls "
"*target*\\'s method ``close()``. :class:`XMLParser` can be used not only for "
"building a tree structure. This is an example of counting the maximum depth "
"of an XML file::"
msgstr ""
":meth:`XMLParser.feed` chama o método ``start(tag, attrs_dict)`` do *target* "
"para cada etiqueta de abertura, o seu método ``end(tag)`` para cada etiqueta "
"de fecho, e os dados são processados pelo método ``data(data)``. Para "
"métodos de callback adicionais suportados, consulte a classe :class:"
"`TreeBuilder`. :meth:`XMLParser.close` chama o método ``close()`` do "
"*target*. :class:`XMLParser` pode ser usado não apenas para construir uma "
"estrutura de árvore. Este é um exemplo de contagem da profundidade máxima de "
"um ficheiro XML:"

#: ../../library/xml.etree.elementtree.rst:1417
msgid ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"
msgstr ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # O objeto alvo do analisador\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Chamado para cada etiqueta de "
"abertura.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Chamado para cada etiqueta de "
"fecho.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # Não precisamos de fazer nada com os dados.\n"
"...     def close(self):    # Chamado quando todos os dados foram "
"analisados.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"

#: ../../library/xml.etree.elementtree.rst:1453
msgid "XMLPullParser Objects"
msgstr "Objetos XMLPullParser"

#: ../../library/xml.etree.elementtree.rst:1457
msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API is "
"similar to that of :class:`XMLParser`, but instead of pushing calls to a "
"callback target, :class:`XMLPullParser` collects an internal list of parsing "
"events and lets the user read from it. *events* is a sequence of events to "
"report back.  The supported events are the strings ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-"
"ns\"`` (the \"ns\" events are used to get detailed namespace information).  "
"If *events* is omitted, only ``\"end\"`` events are reported."
msgstr ""
"Um analisador pull adequado para aplicações não bloqueantes. A sua API de "
"entrada é semelhante à de :class:`XMLParser`, mas em vez de enviar chamadas "
"para um alvo de callback, :class:`XMLPullParser` recolhe uma lista interna "
"de eventos de análise e permite que o utilizador leia a partir dela. "
"*events* é uma sequência de eventos a relatar. Os eventos suportados são as "
"strings ``\"start\"``, ``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-"
"ns\"`` e ``\"end-ns\"`` (os eventos \"ns\" são usados para obter informações "
"detalhadas de namespace). Se *events* for omitido, apenas os eventos "
"``\"end\"`` são relatados."

#: ../../library/xml.etree.elementtree.rst:1468
msgid "Feed the given bytes data to the parser."
msgstr "Alimenta os dados de bytes dados para o analisador."

#: ../../library/xml.etree.elementtree.rst:1488
msgid ""
"Signal the parser that the data stream is terminated. Unlike :meth:"
"`XMLParser.close`, this method always returns :const:`None`. Any events not "
"yet retrieved when the parser is closed can still be read with :meth:"
"`read_events`."
msgstr ""
"Sinaliza ao analisador que o fluxo de dados foi terminado. Ao contrário de :"
"meth:`XMLParser.close`, este método devolve sempre :const:`None`. Quaisquer "
"eventos ainda não recuperados quando o analisador é fechado ainda podem ser "
"lidos com :meth:`read_events`."

#: ../../library/xml.etree.elementtree.rst:1495
msgid ""
"Return an iterator over the events which have been encountered in the data "
"fed to the parser.  The iterator yields ``(event, elem)`` pairs, where "
"*event* is a string representing the type of event (e.g. ``\"end\"``) and "
"*elem* is the encountered :class:`Element` object, or other context value as "
"follows."
msgstr ""
"Devolve um iterador sobre os eventos que foram encontrados nos dados "
"alimentados para o analisador. O iterador produz pares ``(event, elem)``, "
"onde *event* é uma string representando o tipo de evento (por exemplo, "
"``\"end\"``) e *elem* é o objeto :class:`Element` encontrado, ou outro valor "
"de contexto como se segue."

#: ../../library/xml.etree.elementtree.rst:1501
msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``end``: o Element atual."

#: ../../library/xml.etree.elementtree.rst:1502
msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr "``comment``, ``pi``: o comentário / instrução de processamento atual"

#: ../../library/xml.etree.elementtree.rst:1503
msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr ""
"``start-ns``: um tuplo ``(prefix, uri)`` que nomeia o mapeamento de "
"namespace declarado."

#: ../../library/xml.etree.elementtree.rst:1505
msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns``: :const:`None` (isto pode mudar numa versão futura)"

#: ../../library/xml.etree.elementtree.rst:1507
msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when they "
"are retrieved from the iterator, so multiple readers iterating in parallel "
"over iterators obtained from :meth:`read_events` will have unpredictable "
"results."
msgstr ""
"Os eventos fornecidos numa chamada anterior a :meth:`read_events` não serão "
"produzidos novamente. Os eventos são consumidos da fila interna apenas "
"quando são recuperados do iterador, por isso vários leitores a iterar em "
"paralelo sobre iteradores obtidos de :meth:`read_events` terão resultados "
"imprevisíveis."

#: ../../library/xml.etree.elementtree.rst:1515
msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" character "
"of a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined at "
"that point.  The same applies to the element children; they may or may not "
"be present."
msgstr ""
":class:`XMLPullParser` garante apenas que viu o carácter \">\" de uma "
"etiqueta de início quando emite um evento \"start\", por isso os atributos "
"estão definidos, mas o conteúdo dos atributos de texto e cauda estão "
"indefinidos nesse ponto. O mesmo se aplica aos filhos do elemento; podem ou "
"não estar presentes."

#: ../../library/xml.etree.elementtree.rst:1530
msgid "Exceptions"
msgstr "Exceções"

#: ../../library/xml.etree.elementtree.rst:1534
msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""
"Erro de análise XML, levantado pelos vários métodos de análise neste módulo "
"quando a análise falha. A representação em string de uma instância desta "
"exceção conterá uma mensagem de erro amigável. Além disso, terá os seguintes "
"atributos disponíveis:"

#: ../../library/xml.etree.elementtree.rst:1541
msgid ""
"A numeric error code from the expat parser. See the documentation of :mod:"
"`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""
"Um código de erro numérico do analisador expat. Consulte a documentação de :"
"mod:`xml.parsers.expat` para a lista de códigos de erro e os seus "
"significados."

#: ../../library/xml.etree.elementtree.rst:1546
msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr ""
"Um tuplo de números de *linha* e *coluna*, especificando onde ocorreu o erro."

#: ../../library/xml.etree.elementtree.rst:1549
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/xml.etree.elementtree.rst:1550
msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and https://"
"www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"A string de codificação incluída na saída XML deve estar em conformidade com "
"os padrões apropriados. Por exemplo, \"UTF-8\" é válido, mas \"UTF8\" não é. "
"Consulte https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl e "
"https://www.iana.org/assignments/character-sets/character-sets.xhtml."
