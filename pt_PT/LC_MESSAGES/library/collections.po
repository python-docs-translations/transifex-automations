# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-03 15:04+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/collections.rst:2
msgid ":mod:`!collections` --- Container datatypes"
msgstr ":mod:`!collections` --- Tipos de dados de contentores"

#: ../../library/collections.rst:10
msgid "**Source code:** :source:`Lib/collections/__init__.py`"
msgstr "**Código-fonte:** :source:`Lib/collections/__init__.py`"

#: ../../library/collections.rst:20
msgid ""
"This module implements specialized container datatypes providing "
"alternatives to Python's general purpose built-in containers, :class:"
"`dict`, :class:`list`, :class:`set`, and :class:`tuple`."
msgstr ""
"Este módulo implementa tipos de dados de contentores especializados que "
"fornecem alternativas aos contentores de uso geral integrados do Python, :"
"class:`dict`, :class:`list`, :class:`set` e :class:`tuple`."

#: ../../library/collections.rst:25
msgid ":func:`namedtuple`"
msgstr ":func:`namedtuple`"

#: ../../library/collections.rst:25
msgid "factory function for creating tuple subclasses with named fields"
msgstr "função de fábrica para criar subclasses de tuplos com campos nomeados"

#: ../../library/collections.rst:26
msgid ":class:`deque`"
msgstr ":class:`deque`"

#: ../../library/collections.rst:26
msgid "list-like container with fast appends and pops on either end"
msgstr ""
"contentor semelhante a listas com operações rápidas de adição e remoção em "
"ambas as extremidades"

#: ../../library/collections.rst:27
msgid ":class:`ChainMap`"
msgstr ":class:`ChainMap`"

#: ../../library/collections.rst:27
msgid "dict-like class for creating a single view of multiple mappings"
msgstr ""
"classe semelhante a dicionários para criar uma única vista de vários "
"mapeamentos"

#: ../../library/collections.rst:28
msgid ":class:`Counter`"
msgstr ":class:`Counter`"

#: ../../library/collections.rst:28
msgid "dict subclass for counting :term:`hashable` objects"
msgstr "subclasse de dicionário para contar objetos :term:`hashable`"

#: ../../library/collections.rst:29
msgid ":class:`OrderedDict`"
msgstr ":class:`OrderedDict`"

#: ../../library/collections.rst:29
msgid "dict subclass that remembers the order entries were added"
msgstr ""
"subclasse de dicionário que recorda a ordem pela qual as entradas foram "
"adicionadas"

#: ../../library/collections.rst:30
msgid ":class:`defaultdict`"
msgstr ":class:`defaultdict`"

#: ../../library/collections.rst:30
msgid "dict subclass that calls a factory function to supply missing values"
msgstr ""
"subclasse de dicionário que chama uma função de fábrica para fornecer "
"valores em falta"

#: ../../library/collections.rst:31
msgid ":class:`UserDict`"
msgstr ":class:`UserDict`"

#: ../../library/collections.rst:31
msgid "wrapper around dictionary objects for easier dict subclassing"
msgstr ""
"invólucro em torno de objetos de dicionário para facilitar a criação de "
"subclasses de dicionários"

#: ../../library/collections.rst:32
msgid ":class:`UserList`"
msgstr ":class:`UserList`"

#: ../../library/collections.rst:32
msgid "wrapper around list objects for easier list subclassing"
msgstr ""
"invólucro em torno de objetos de lista para facilitar a criação de "
"subclasses de listas"

#: ../../library/collections.rst:33
msgid ":class:`UserString`"
msgstr ":class:`UserString`"

#: ../../library/collections.rst:33
msgid "wrapper around string objects for easier string subclassing"
msgstr ""
"invólucro em torno de objetos de string para facilitar a criação de "
"subclasses de strings"

#: ../../library/collections.rst:38
msgid ":class:`ChainMap` objects"
msgstr "Objetos :class:`ChainMap`"

#: ../../library/collections.rst:42
msgid ""
"A :class:`ChainMap` class is provided for quickly linking a number of "
"mappings so they can be treated as a single unit.  It is often much faster "
"than creating a new dictionary and running multiple :meth:`~dict.update` "
"calls."
msgstr ""
"A classe :class:`ChainMap` é fornecida para ligar rapidamente vários "
"mapeamentos de modo a que possam ser tratados como uma única unidade. É "
"muitas vezes muito mais rápido do que criar um novo dicionário e executar "
"várias chamadas a :meth:`~dict.update`."

#: ../../library/collections.rst:46
msgid ""
"The class can be used to simulate nested scopes and is useful in templating."
msgstr ""
"A classe pode ser usada para simular âmbitos aninhados e é útil em templates."

#: ../../library/collections.rst:50
msgid ""
"A :class:`ChainMap` groups multiple dicts or other mappings together to "
"create a single, updateable view.  If no *maps* are specified, a single "
"empty dictionary is provided so that a new chain always has at least one "
"mapping."
msgstr ""
"Um :class:`ChainMap` agrupa vários dicionários ou outros mapeamentos para "
"criar uma única vista atualizável. Se não forem especificados *maps*, é "
"fornecido um único dicionário vazio, de modo que uma nova cadeia tenha "
"sempre pelo menos um mapeamento."

#: ../../library/collections.rst:54
msgid ""
"The underlying mappings are stored in a list.  That list is public and can "
"be accessed or updated using the *maps* attribute.  There is no other state."
msgstr ""
"Os mapeamentos subjacentes são armazenados numa lista. Essa lista é pública "
"e pode ser acedida ou atualizada usando o atributo *maps*. Não existe outro "
"estado."

#: ../../library/collections.rst:57
msgid ""
"Lookups search the underlying mappings successively until a key is found.  "
"In contrast, writes, updates, and deletions only operate on the first "
"mapping."
msgstr ""
"As pesquisas procuram nos mapeamentos subjacentes sucessivamente até que uma "
"chave seja encontrada. Em contraste, as operações de escrita, atualização e "
"eliminação atuam apenas no primeiro mapeamento."

#: ../../library/collections.rst:60
msgid ""
"A :class:`ChainMap` incorporates the underlying mappings by reference.  So, "
"if one of the underlying mappings gets updated, those changes will be "
"reflected in :class:`ChainMap`."
msgstr ""
"Um :class:`ChainMap` incorpora os mapeamentos subjacentes por referência. "
"Assim, se um dos mapeamentos subjacentes for atualizado, essas alterações "
"serão refletidas no :class:`ChainMap`."

#: ../../library/collections.rst:64
msgid ""
"All of the usual dictionary methods are supported.  In addition, there is a "
"*maps* attribute, a method for creating new subcontexts, and a property for "
"accessing all but the first mapping:"
msgstr ""
"Todos os métodos habituais de dicionário são suportados. Além disso, existe "
"um atributo *maps*, um método para criar novos subcontextos e uma "
"propriedade para aceder a todos os mapeamentos, exceto o primeiro:"

#: ../../library/collections.rst:70
msgid ""
"A user updateable list of mappings.  The list is ordered from first-searched "
"to last-searched.  It is the only stored state and can be modified to change "
"which mappings are searched.  The list should always contain at least one "
"mapping."
msgstr ""
"Uma lista de mapeamentos atualizável pelo utilizador. A lista está ordenada "
"do primeiro pesquisado para o último pesquisado. É o único estado armazenado "
"e pode ser modificado para alterar quais mapeamentos são pesquisados. A "
"lista deve conter sempre pelo menos um mapeamento."

#: ../../library/collections.rst:77
msgid ""
"Returns a new :class:`ChainMap` containing a new map followed by all of the "
"maps in the current instance.  If ``m`` is specified, it becomes the new map "
"at the front of the list of mappings; if not specified, an empty dict is "
"used, so that a call to ``d.new_child()`` is equivalent to: ``ChainMap({}, "
"*d.maps)``. If any keyword arguments are specified, they update passed map "
"or new empty dict. This method is used for creating subcontexts that can be "
"updated without altering values in any of the parent mappings."
msgstr ""
"Devolve um novo :class:`ChainMap` contendo um novo mapa seguido de todos os "
"mapas na instância atual. Se ``m`` for especificado, torna-se o novo mapa na "
"frente da lista de mapeamentos; se não for especificado, é usado um "
"dicionário vazio, de modo que uma chamada a ``d.new_child()`` é equivalente "
"a: ``ChainMap({}, *d.maps)``. Se forem especificados argumentos de palavra-"
"chave, atualizam o mapa passado ou o novo dicionário vazio. Este método é "
"usado para criar subcontextos que podem ser atualizados sem alterar valores "
"em quaisquer dos mapeamentos pais."

#: ../../library/collections.rst:86
msgid "The optional ``m`` parameter was added."
msgstr "O parâmetro opcional ``m`` foi adicionado."

#: ../../library/collections.rst:89
msgid "Keyword arguments support was added."
msgstr "Foi adicionado suporte para argumentos de palavra-chave."

#: ../../library/collections.rst:94
msgid ""
"Property returning a new :class:`ChainMap` containing all of the maps in the "
"current instance except the first one.  This is useful for skipping the "
"first map in the search.  Use cases are similar to those for the :keyword:"
"`nonlocal` keyword used in :term:`nested scopes <nested scope>`.  The use "
"cases also parallel those for the built-in :func:`super` function.  A "
"reference to ``d.parents`` is equivalent to: ``ChainMap(*d.maps[1:])``."
msgstr ""
"Propriedade que devolve um novo :class:`ChainMap` contendo todos os mapas na "
"instância atual, exceto o primeiro. Isto é útil para ignorar o primeiro mapa "
"na pesquisa. Os casos de uso são semelhantes aos da palavra-chave :keyword:"
"`nonlocal` usada em :term:`âmbitos aninhados <nested scope>`. Os casos de "
"uso também são paralelos aos da função integrada :func:`super`. Uma "
"referência a ``d.parents`` é equivalente a: ``ChainMap(*d.maps[1:])``."

#: ../../library/collections.rst:102
msgid ""
"Note, the iteration order of a :class:`ChainMap` is determined by scanning "
"the mappings last to first::"
msgstr ""
"Nota: a ordem de iteração de um :class:`ChainMap` é determinada pela "
"varredura dos mapeamentos do último para o primeiro:"

#: ../../library/collections.rst:105
msgid ""
">>> baseline = {'music': 'bach', 'art': 'rembrandt'}\n"
">>> adjustments = {'art': 'van gogh', 'opera': 'carmen'}\n"
">>> list(ChainMap(adjustments, baseline))\n"
"['music', 'art', 'opera']"
msgstr ""
">>> baseline = {'música': 'bach', 'arte': 'rembrandt'}\n"
">>> ajustes = {'arte': 'van gogh', 'ópera': 'carmen'}\n"
">>> list(ChainMap(ajustes, baseline))\n"
"['música', 'arte', 'ópera']"

#: ../../library/collections.rst:110
msgid ""
"This gives the same ordering as a series of :meth:`dict.update` calls "
"starting with the last mapping::"
msgstr ""
"Isto dá a mesma ordem que uma série de chamadas :meth:`dict.update` "
"começando com o último mapeamento:"

#: ../../library/collections.rst:113
msgid ""
">>> combined = baseline.copy()\n"
">>> combined.update(adjustments)\n"
">>> list(combined)\n"
"['music', 'art', 'opera']"
msgstr ""
">>> combinado = baseline.copy()\n"
">>> combinado.update(ajustes)\n"
">>> list(combinado)\n"
"['música', 'arte', 'ópera']"

#: ../../library/collections.rst:118
msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr ""
"Adicionado suporte para os operadores ``|`` e ``|=``, especificados em :pep:"
"`584`."

#: ../../library/collections.rst:123
msgid ""
"The `MultiContext class <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ in the Enthought `CodeTools package "
"<https://github.com/enthought/codetools>`_ has options to support writing to "
"any mapping in the chain."
msgstr ""
"A classe `MultiContext <https://github.com/enthought/codetools/blob/4.0.0/"
"codetools/contexts/multi_context.py>`_ no pacote `CodeTools da Enthought "
"<https://github.com/enthought/codetools>`_ tem opções para suportar escrita "
"em qualquer mapeamento na cadeia."

#: ../../library/collections.rst:129
msgid ""
"Django's `Context class <https://github.com/django/django/blob/main/django/"
"template/context.py>`_ for templating is a read-only chain of mappings.  It "
"also features pushing and popping of contexts similar to the :meth:"
"`~collections.ChainMap.new_child` method and the :attr:`~collections."
"ChainMap.parents` property."
msgstr ""
"A classe `Context do Django <https://github.com/django/django/blob/main/"
"django/template/context.py>`_ para templates é uma cadeia de mapeamentos "
"apenas de leitura. Também possui funcionalidades de empurrar e retirar "
"contextos semelhantes ao método :meth:`~collections.ChainMap.new_child` e à "
"propriedade :attr:`~collections.ChainMap.parents`."

#: ../../library/collections.rst:136
msgid ""
"The `Nested Contexts recipe <https://code.activestate.com/recipes/577434-"
"nested-contexts-a-chain-of-mapping-objects/>`_ has options to control "
"whether writes and other mutations apply only to the first mapping or to any "
"mapping in the chain."
msgstr ""
"A receita `Contextos Aninhados <https://code.activestate.com/recipes/577434-"
"nested-contexts-a-chain-of-mapping-objects/>`_ tem opções para controlar se "
"as escritas e outras mutações se aplicam apenas ao primeiro mapeamento ou a "
"qualquer mapeamento na cadeia."

#: ../../library/collections.rst:141
msgid ""
"A `greatly simplified read-only version of Chainmap <https://code."
"activestate.com/recipes/305268/>`_."
msgstr ""
"Uma versão `simplificada apenas de leitura de Chainmap <https://code."
"activestate.com/recipes/305268/>`_."

#: ../../library/collections.rst:146
msgid ":class:`ChainMap` Examples and Recipes"
msgstr "Exemplos e Receitas de :class:`ChainMap`"

#: ../../library/collections.rst:148
msgid "This section shows various approaches to working with chained maps."
msgstr ""
"Esta secção mostra várias abordagens para trabalhar com mapas encadeados."

#: ../../library/collections.rst:151
msgid "Example of simulating Python's internal lookup chain::"
msgstr "Exemplo de simulação da cadeia de pesquisa interna do Python:"

#: ../../library/collections.rst:153
msgid ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"
msgstr ""
"import builtins\n"
"pylookup = ChainMap(locals(), globals(), vars(builtins))"

#: ../../library/collections.rst:156
msgid ""
"Example of letting user specified command-line arguments take precedence "
"over environment variables which in turn take precedence over default "
"values::"
msgstr ""
"Exemplo de como permitir que argumentos de linha de comandos especificados "
"pelo utilizador tenham precedência sobre variáveis de ambiente, que por sua "
"vez têm precedência sobre valores predefinidos:"

#: ../../library/collections.rst:159
msgid ""
"import os, argparse\n"
"\n"
"defaults = {'color': 'red', 'user': 'guest'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--user')\n"
"parser.add_argument('-c', '--color')\n"
"namespace = parser.parse_args()\n"
"command_line_args = {k: v for k, v in vars(namespace).items() if v is not "
"None}\n"
"\n"
"combined = ChainMap(command_line_args, os.environ, defaults)\n"
"print(combined['color'])\n"
"print(combined['user'])"
msgstr ""
"import os, argparse\n"
"\n"
"predefinições = {'cor': 'vermelho', 'utilizador': 'convidado'}\n"
"\n"
"parser = argparse.ArgumentParser()\n"
"parser.add_argument('-u', '--utilizador')\n"
"parser.add_argument('-c', '--cor')\n"
"namespace = parser.parse_args()\n"
"argumentos_linha_comando = {k: v for k, v in vars(namespace).items() if v is "
"not None}\n"
"\n"
"combinado = ChainMap(argumentos_linha_comando, os.environ, predefinições)\n"
"print(combinado['cor'])\n"
"print(combinado['utilizador'])"

#: ../../library/collections.rst:173
msgid ""
"Example patterns for using the :class:`ChainMap` class to simulate nested "
"contexts::"
msgstr ""
"Exemplos de padrões para usar a classe :class:`ChainMap` para simular "
"contextos aninhados:"

#: ../../library/collections.rst:176
msgid ""
"c = ChainMap()        # Create root context\n"
"d = c.new_child()     # Create nested child context\n"
"e = c.new_child()     # Child of c, independent from d\n"
"e.maps[0]             # Current context dictionary -- like Python's "
"locals()\n"
"e.maps[-1]            # Root context -- like Python's globals()\n"
"e.parents             # Enclosing context chain -- like Python's nonlocals\n"
"\n"
"d['x'] = 1            # Set value in current context\n"
"d['x']                # Get first key in the chain of contexts\n"
"del d['x']            # Delete from current context\n"
"list(d)               # All nested values\n"
"k in d                # Check all nested values\n"
"len(d)                # Number of nested values\n"
"d.items()             # All nested items\n"
"dict(d)               # Flatten into a regular dictionary"
msgstr ""
"c = ChainMap()        # Criar contexto raiz\n"
"d = c.new_child()     # Criar contexto filho aninhado\n"
"e = c.new_child()     # Filho de c, independente de d\n"
"e.maps[0]             # Dicionário de contexto atual -- como locals() do "
"Python\n"
"e.maps[-1]            # Contexto raiz -- como globals() do Python\n"
"e.parents             # Cadeia de contexto envolvente -- como nonlocals do "
"Python\n"
"\n"
"d['x'] = 1            # Definir valor no contexto atual\n"
"d['x']                # Obter primeira chave na cadeia de contextos\n"
"del d['x']            # Apagar do contexto atual\n"
"list(d)               # Todos os valores aninhados\n"
"k in d                # Verificar todos os valores aninhados\n"
"len(d)                # Número de valores aninhados\n"
"d.items()             # Todos os itens aninhados\n"
"dict(d)               # Achatar num dicionário regular"

#: ../../library/collections.rst:192
msgid ""
"The :class:`ChainMap` class only makes updates (writes and deletions) to the "
"first mapping in the chain while lookups will search the full chain.  "
"However, if deep writes and deletions are desired, it is easy to make a "
"subclass that updates keys found deeper in the chain::"
msgstr ""
"A classe :class:`ChainMap` só faz atualizações (escritas e eliminações) no "
"primeiro mapeamento da cadeia, enquanto as pesquisas procuram em toda a "
"cadeia. No entanto, se forem desejadas escritas e eliminações profundas, é "
"fácil criar uma subclasse que atualiza chaves encontradas mais profundamente "
"na cadeia:"

#: ../../library/collections.rst:197
msgid ""
"class DeepChainMap(ChainMap):\n"
"    'Variant of ChainMap that allows direct updates to inner scopes'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'black'}, {'elephant': 'blue'}, {'lion': "
"'yellow'})\n"
">>> d['lion'] = 'orange'         # update an existing key two levels down\n"
">>> d['snake'] = 'red'           # new keys get added to the topmost dict\n"
">>> del d['elephant']            # remove an existing key one level down\n"
">>> d                            # display result\n"
"DeepChainMap({'zebra': 'black', 'snake': 'red'}, {}, {'lion': 'orange'})"
msgstr ""
"class DeepChainMap(ChainMap):\n"
"    'Variante de ChainMap que permite atualizações diretas em âmbitos "
"internos'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                mapping[key] = value\n"
"                return\n"
"        self.maps[0][key] = value\n"
"\n"
"    def __delitem__(self, key):\n"
"        for mapping in self.maps:\n"
"            if key in mapping:\n"
"                del mapping[key]\n"
"                return\n"
"        raise KeyError(key)\n"
"\n"
">>> d = DeepChainMap({'zebra': 'preto'}, {'elefante': 'azul'}, {'leão': "
"'amarelo'})\n"
">>> d['leão'] = 'laranja'         # atualizar uma chave existente dois "
"níveis abaixo\n"
">>> d['cobra'] = 'vermelho'       # novas chaves são adicionadas ao "
"dicionário superior\n"
">>> del d['elefante']              # remover uma chave existente um nível "
"abaixo\n"
">>> d                            # mostrar resultado\n"
"DeepChainMap({'zebra': 'preto', 'cobra': 'vermelho'}, {}, {'leão': "
"'laranja'})"

#: ../../library/collections.rst:223
msgid ":class:`Counter` objects"
msgstr "Objetos :class:`Counter`"

#: ../../library/collections.rst:225
msgid ""
"A counter tool is provided to support convenient and rapid tallies. For "
"example::"
msgstr ""
"Uma ferramenta de contagem é fornecida para suportar contagens convenientes "
"e rápidas. Por exemplo:"

#: ../../library/collections.rst:228
msgid ""
">>> # Tally occurrences of words in a list\n"
">>> cnt = Counter()\n"
">>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'blue': 3, 'red': 2, 'green': 1})\n"
"\n"
">>> # Find the ten most common words in Hamlet\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"
msgstr ""
">>> # Contar ocorrências de palavras numa lista\n"
">>> cnt = Counter()\n"
">>> for word in ['vermelho', 'azul', 'vermelho', 'verde', 'azul', 'azul']:\n"
"...     cnt[word] += 1\n"
"...\n"
">>> cnt\n"
"Counter({'azul': 3, 'vermelho': 2, 'verde': 1})\n"
"\n"
">>> # Encontrar as dez palavras mais comuns em Hamlet\n"
">>> import re\n"
">>> words = re.findall(r'\\w+', open('hamlet.txt').read().lower())\n"
">>> Counter(words).most_common(10)\n"
"[('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631),\n"
" ('you', 554),  ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)]"

#: ../../library/collections.rst:245
msgid ""
"A :class:`Counter` is a :class:`dict` subclass for counting :term:`hashable` "
"objects. It is a collection where elements are stored as dictionary keys and "
"their counts are stored as dictionary values.  Counts are allowed to be any "
"integer value including zero or negative counts.  The :class:`Counter` class "
"is similar to bags or multisets in other languages."
msgstr ""
"Um :class:`Counter` é uma subclasse de :class:`dict` para contar objetos :"
"term:`hashable`. É uma coleção onde os elementos são armazenados como chaves "
"de dicionário e as suas contagens são armazenadas como valores de "
"dicionário. As contagens podem ser qualquer valor inteiro, incluindo zero ou "
"contagens negativas. A classe :class:`Counter` é semelhante a sacos ou "
"multiconjuntos em outras linguagens."

#: ../../library/collections.rst:251
msgid ""
"Elements are counted from an *iterable* or initialized from another "
"*mapping* (or counter):"
msgstr ""
"Os elementos são contados a partir de um *iterável* ou inicializados a "
"partir de outro *mapeamento* (ou contador):"

#: ../../library/collections.rst:259
msgid ""
"Counter objects have a dictionary interface except that they return a zero "
"count for missing items instead of raising a :exc:`KeyError`:"
msgstr ""
"Os objetos Counter têm uma interface de dicionário, exceto que devolvem uma "
"contagem zero para itens em falta em vez de levantar uma exceção :exc:"
"`KeyError`:"

#: ../../library/collections.rst:266
msgid ""
"Setting a count to zero does not remove an element from a counter. Use "
"``del`` to remove it entirely:"
msgstr ""
"Definir uma contagem para zero não remove um elemento de um contador. Use "
"``del`` para removê-lo completamente:"

#: ../../library/collections.rst:274
msgid ""
"As a :class:`dict` subclass, :class:`Counter` inherited the capability to "
"remember insertion order.  Math operations on *Counter* objects also "
"preserve order.  Results are ordered according to when an element is first "
"encountered in the left operand and then by the order encountered in the "
"right operand."
msgstr ""
"Como uma subclasse de :class:`dict`, :class:`Counter` herdou a capacidade de "
"recordar a ordem de inserção. As operações matemáticas em objetos *Counter* "
"também preservam a ordem. Os resultados são ordenados de acordo com quando "
"um elemento é encontrado pela primeira vez no operando esquerdo e depois "
"pela ordem encontrada no operando direito."

#: ../../library/collections.rst:280
msgid ""
"Counter objects support additional methods beyond those available for all "
"dictionaries:"
msgstr ""
"Os objetos Counter suportam métodos adicionais além daqueles disponíveis "
"para todos os dicionários:"

#: ../../library/collections.rst:285
msgid ""
"Return an iterator over elements repeating each as many times as its count.  "
"Elements are returned in the order first encountered. If an element's count "
"is less than one, :meth:`elements` will ignore it."
msgstr ""
"Devolve um iterador sobre elementos repetindo cada um tantas vezes quanto a "
"sua contagem. Os elementos são devolvidos pela ordem em que foram "
"encontrados pela primeira vez. Se a contagem de um elemento for menor que "
"um, :meth:`elements` ignorá-lo-á."

#: ../../library/collections.rst:295
msgid ""
"Return a list of the *n* most common elements and their counts from the most "
"common to the least.  If *n* is omitted or ``None``, :meth:`most_common` "
"returns *all* elements in the counter. Elements with equal counts are "
"ordered in the order first encountered:"
msgstr ""
"Devolve uma lista dos *n* elementos mais comuns e as suas contagens, do mais "
"comum para o menos comum. Se *n* for omitido ou ``None``, :meth:"
"`most_common` devolve *todos* os elementos no contador. Elementos com "
"contagens iguais são ordenados pela ordem em que foram encontrados pela "
"primeira vez:"

#: ../../library/collections.rst:305
msgid ""
"Elements are subtracted from an *iterable* or from another *mapping* (or "
"counter).  Like :meth:`dict.update` but subtracts counts instead of "
"replacing them.  Both inputs and outputs may be zero or negative."
msgstr ""
"Os elementos são subtraídos de um *iterável* ou de outro *mapeamento* (ou "
"contador). Semelhante a :meth:`dict.update`, mas subtrai contagens em vez de "
"as substituir. Tanto as entradas como as saídas podem ser zero ou negativas."

#: ../../library/collections.rst:319
msgid "Compute the sum of the counts."
msgstr "Calcula a soma das contagens."

#: ../../library/collections.rst:327
msgid ""
"The usual dictionary methods are available for :class:`Counter` objects "
"except for two which work differently for counters."
msgstr ""
"Os métodos habituais de dicionário estão disponíveis para objetos :class:"
"`Counter`, exceto dois que funcionam de forma diferente para contadores."

#: ../../library/collections.rst:332
msgid "This class method is not implemented for :class:`Counter` objects."
msgstr ""
"Este método de classe não está implementado para objetos :class:`Counter`."

#: ../../library/collections.rst:336
msgid ""
"Elements are counted from an *iterable* or added-in from another *mapping* "
"(or counter).  Like :meth:`dict.update` but adds counts instead of replacing "
"them.  Also, the *iterable* is expected to be a sequence of elements, not a "
"sequence of ``(key, value)`` pairs."
msgstr ""
"Os elementos são contados a partir de um *iterável* ou adicionados a partir "
"de outro *mapeamento* (ou contador). Semelhante a :meth:`dict.update`, mas "
"adiciona contagens em vez de as substituir. Além disso, espera-se que o "
"*iterável* seja uma sequência de elementos, não uma sequência de pares "
"``(key, value)``."

#: ../../library/collections.rst:341
msgid ""
"Counters support rich comparison operators for equality, subset, and "
"superset relationships: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``. All of "
"those tests treat missing elements as having zero counts so that "
"``Counter(a=1) == Counter(a=1, b=0)`` returns true."
msgstr ""
"Os contadores suportam operadores de comparação rica para relações de "
"igualdade, subconjunto e superconjunto: ``==``, ``!=``, ``<``, ``<=``, "
"``>``, ``>=``. Todos esses testes tratam elementos em falta como tendo "
"contagens zero, de modo que ``Counter(a=1) == Counter(a=1, b=0)`` devolve "
"verdadeiro."

#: ../../library/collections.rst:346
msgid "Rich comparison operations were added."
msgstr "Foram adicionadas operações de comparação rica."

#: ../../library/collections.rst:349
msgid ""
"In equality tests, missing elements are treated as having zero counts. "
"Formerly, ``Counter(a=3)`` and ``Counter(a=3, b=0)`` were considered "
"distinct."
msgstr ""
"Nos testes de igualdade, os elementos em falta são tratados como tendo "
"contagens zero. Anteriormente, ``Counter(a=3)`` e ``Counter(a=3, b=0)`` eram "
"considerados distintos."

#: ../../library/collections.rst:354
msgid "Common patterns for working with :class:`Counter` objects::"
msgstr "Padrões comuns para trabalhar com objetos :class:`Counter`:"

#: ../../library/collections.rst:356
msgid ""
"c.total()                       # total of all counts\n"
"c.clear()                       # reset all counts\n"
"list(c)                         # list unique elements\n"
"set(c)                          # convert to a set\n"
"dict(c)                         # convert to a regular dictionary\n"
"c.items()                       # access the (elem, cnt) pairs\n"
"Counter(dict(list_of_pairs))    # convert from a list of (elem, cnt) pairs\n"
"c.most_common()[:-n-1:-1]       # n least common elements\n"
"+c                              # remove zero and negative counts"
msgstr ""
"c.total()                       # total de todas as contagens\n"
"c.clear()                       # redefinir todas as contagens\n"
"list(c)                         # listar elementos únicos\n"
"set(c)                          # converter para um conjunto\n"
"dict(c)                         # converter para um dicionário regular\n"
"c.items()                       # aceder aos pares (elem, cnt)\n"
"Counter(dict(lista_de_pares))   # converter a partir de uma lista de pares "
"(elem, cnt)\n"
"c.most_common()[:-n-1:-1]       # n elementos menos comuns\n"
"+c                              # remover contagens zero e negativas"

#: ../../library/collections.rst:366
msgid ""
"Several mathematical operations are provided for combining :class:`Counter` "
"objects to produce multisets (counters that have counts greater than zero). "
"Addition and subtraction combine counters by adding or subtracting the "
"counts of corresponding elements.  Intersection and union return the minimum "
"and maximum of corresponding counts.  Equality and inclusion compare "
"corresponding counts.  Each operation can accept inputs with signed counts, "
"but the output will exclude results with counts of zero or less."
msgstr ""
"Várias operações matemáticas são fornecidas para combinar objetos :class:"
"`Counter` para produzir multiconjuntos (contadores que têm contagens maiores "
"que zero). A adição e subtração combinam contadores adicionando ou "
"subtraindo as contagens de elementos correspondentes. A interseção e união "
"devolvem o mínimo e o máximo das contagens correspondentes. A igualdade e "
"inclusão comparam contagens correspondentes. Cada operação pode aceitar "
"entradas com contagens assinadas, mas a saída excluirá resultados com "
"contagens zero ou negativas."

#: ../../library/collections.rst:374
msgid ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # add two counters together:  c[x] + d[x]\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # subtract (keeping only positive counts)\n"
"Counter({'a': 2})\n"
">>> c & d                       # intersection:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # union:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # equality:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # inclusion:  c[x] <= d[x]\n"
"False"
msgstr ""
">>> c = Counter(a=3, b=1)\n"
">>> d = Counter(a=1, b=2)\n"
">>> c + d                       # adicionar dois contadores:  c[x] + d[x]\n"
"Counter({'a': 4, 'b': 3})\n"
">>> c - d                       # subtrair (mantendo apenas contagens "
"positivas)\n"
"Counter({'a': 2})\n"
">>> c & d                       # interseção:  min(c[x], d[x])\n"
"Counter({'a': 1, 'b': 1})\n"
">>> c | d                       # união:  max(c[x], d[x])\n"
"Counter({'a': 3, 'b': 2})\n"
">>> c == d                      # igualdade:  c[x] == d[x]\n"
"False\n"
">>> c <= d                      # inclusão:  c[x] <= d[x]\n"
"False"

#: ../../library/collections.rst:391
msgid ""
"Unary addition and subtraction are shortcuts for adding an empty counter or "
"subtracting from an empty counter."
msgstr ""
"A adição e subtração unárias são atalhos para adicionar um contador vazio ou "
"subtrair de um contador vazio."

#: ../../library/collections.rst:400
msgid ""
"Added support for unary plus, unary minus, and in-place multiset operations."
msgstr ""
"Adicionado suporte para mais unário, menos unário e operações de "
"multiconjunto no local."

#: ../../library/collections.rst:405
msgid ""
"Counters were primarily designed to work with positive integers to represent "
"running counts; however, care was taken to not unnecessarily preclude use "
"cases needing other types or negative values.  To help with those use cases, "
"this section documents the minimum range and type restrictions."
msgstr ""
"Os contadores foram principalmente concebidos para trabalhar com inteiros "
"positivos para representar contagens em execução; no entanto, foi tido "
"cuidado para não excluir desnecessariamente casos de uso que necessitem de "
"outros tipos ou valores negativos. Para ajudar com esses casos de uso, esta "
"secção documenta as restrições mínimas de intervalo e tipo."

#: ../../library/collections.rst:410
msgid ""
"The :class:`Counter` class itself is a dictionary subclass with no "
"restrictions on its keys and values.  The values are intended to be numbers "
"representing counts, but you *could* store anything in the value field."
msgstr ""
"A classe :class:`Counter` em si é uma subclasse de dicionário sem restrições "
"nas suas chaves e valores. Os valores são destinados a ser números que "
"representam contagens, mas *poderia* armazenar qualquer coisa no campo de "
"valor."

#: ../../library/collections.rst:414
msgid ""
"The :meth:`~Counter.most_common` method requires only that the values be "
"orderable."
msgstr ""
"O método :meth:`~Counter.most_common` requer apenas que os valores sejam "
"ordenáveis."

#: ../../library/collections.rst:416
msgid ""
"For in-place operations such as ``c[key] += 1``, the value type need only "
"support addition and subtraction.  So fractions, floats, and decimals would "
"work and negative values are supported.  The same is also true for :meth:"
"`~Counter.update` and :meth:`~Counter.subtract` which allow negative and "
"zero values for both inputs and outputs."
msgstr ""
"Para operações no local, como ``c[key] += 1``, o tipo de valor precisa "
"apenas de suportar adição e subtração. Assim, frações, floats e decimais "
"funcionariam e valores negativos são suportados. O mesmo também é verdadeiro "
"para :meth:`~Counter.update` e :meth:`~Counter.subtract`, que permitem "
"valores negativos e zero para entradas e saídas."

#: ../../library/collections.rst:422
msgid ""
"The multiset methods are designed only for use cases with positive values. "
"The inputs may be negative or zero, but only outputs with positive values "
"are created.  There are no type restrictions, but the value type needs to "
"support addition, subtraction, and comparison."
msgstr ""
"Os métodos de multiconjunto são concebidos apenas para casos de uso com "
"valores positivos. As entradas podem ser negativas ou zero, mas apenas "
"saídas com valores positivos são criadas. Não há restrições de tipo, mas o "
"tipo de valor precisa de suportar adição, subtração e comparação."

#: ../../library/collections.rst:427
msgid ""
"The :meth:`~Counter.elements` method requires integer counts.  It ignores "
"zero and negative counts."
msgstr ""
"O método :meth:`~Counter.elements` requer contagens inteiras. Ignora "
"contagens zero e negativas."

#: ../../library/collections.rst:432
msgid ""
"`Bag class <https://www.gnu.org/software/smalltalk/manual-base/html_node/Bag."
"html>`_ in Smalltalk."
msgstr ""
"Classe `Bag <https://www.gnu.org/software/smalltalk/manual-base/html_node/"
"Bag.html>`_ em Smalltalk."

#: ../../library/collections.rst:435
msgid ""
"Wikipedia entry for `Multisets <https://en.wikipedia.org/wiki/Multiset>`_."
msgstr ""
"Entrada da Wikipedia para `Multiconjuntos <https://en.wikipedia.org/wiki/"
"Multiset>`_."

#: ../../library/collections.rst:437
msgid ""
"`C++ multisets <http://www.java2s.com/Tutorial/Cpp/0380__set-multiset/"
"Catalog0380__set-multiset.htm>`_ tutorial with examples."
msgstr ""
"Tutorial de `multiconjuntos C++ <http://www.java2s.com/Tutorial/"
"Cpp/0380__set-multiset/Catalog0380__set-multiset.htm>`_ com exemplos."

#: ../../library/collections.rst:440
msgid ""
"For mathematical operations on multisets and their use cases, see *Knuth, "
"Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise "
"19*."
msgstr ""
"Para operações matemáticas em multiconjuntos e seus casos de uso, veja "
"*Knuth, Donald. A Arte da Programação de Computadores Volume II, Secção "
"4.6.3, Exercício 19*."

#: ../../library/collections.rst:444
msgid ""
"To enumerate all distinct multisets of a given size over a given set of "
"elements, see :func:`itertools.combinations_with_replacement`::"
msgstr ""
"Para enumerar todos os multiconjuntos distintos de um determinado tamanho "
"sobre um conjunto dado de elementos, veja :func:`itertools."
"combinations_with_replacement`:"

#: ../../library/collections.rst:447
msgid ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB BC CC"
msgstr ""
"map(Counter, combinations_with_replacement('ABC', 2)) # --> AA AB AC BB BC CC"

#: ../../library/collections.rst:451
msgid ":class:`deque` objects"
msgstr "Objetos :class:`deque`"

#: ../../library/collections.rst:455
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""
"Devolve um novo objeto deque inicializado da esquerda para a direita "
"(usando :meth:`append`) com dados de *iterável*. Se *iterável* não for "
"especificado, o novo deque está vazio."

#: ../../library/collections.rst:458
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same *O*\\ (1) performance in either direction."
msgstr ""
"Deques são uma generalização de pilhas e filas (o nome é pronunciado "
"\"deck\" e é uma abreviatura de \"fila de duas extremidades\"). Deques "
"suportam adições e remoções eficientes em termos de memória e seguras para "
"threads em qualquer extremidade do deque com um desempenho aproximadamente "
"*O*\\ (1) em qualquer direção."

#: ../../library/collections.rst:463
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur *O*\\ (*n*) memory movement costs "
"for ``pop(0)`` and ``insert(0, v)`` operations which change both the size "
"and position of the underlying data representation."
msgstr ""
"Embora os objetos :class:`list` suportem operações semelhantes, eles são "
"otimizados para operações de comprimento fixo rápido e incorrem em custos de "
"movimento de memória *O*\\ (*n*) para operações ``pop(0)`` e ``insert(0, "
"v)`` que alteram tanto o tamanho como a posição da representação de dados "
"subjacente."

#: ../../library/collections.rst:469
msgid ""
"If *maxlen* is not specified or is ``None``, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""
"Se *maxlen* não for especificado ou for ``None``, os deques podem crescer "
"até um comprimento arbitrário. Caso contrário, o deque é limitado ao "
"comprimento máximo especificado. Uma vez que um deque de comprimento "
"limitado esteja cheio, quando novos itens são adicionados, um número "
"correspondente de itens é descartado da extremidade oposta. Deques de "
"comprimento limitado fornecem funcionalidade semelhante ao filtro ``tail`` "
"no Unix. Também são úteis para rastrear transações e outros conjuntos de "
"dados onde apenas a atividade mais recente é de interesse."

#: ../../library/collections.rst:478
msgid "Deque objects support the following methods:"
msgstr "Os objetos Deque suportam os seguintes métodos:"

#: ../../library/collections.rst:482
msgid "Add *x* to the right side of the deque."
msgstr "Adiciona *x* ao lado direito do deque."

#: ../../library/collections.rst:487
msgid "Add *x* to the left side of the deque."
msgstr "Adiciona *x* ao lado esquerdo do deque."

#: ../../library/collections.rst:492
msgid "Remove all elements from the deque leaving it with length 0."
msgstr "Remove todos os elementos do deque, deixando-o com comprimento 0."

#: ../../library/collections.rst:497
msgid "Create a shallow copy of the deque."
msgstr "Cria uma cópia superficial do deque."

#: ../../library/collections.rst:504
msgid "Count the number of deque elements equal to *x*."
msgstr "Conta o número de elementos do deque iguais a *x*."

#: ../../library/collections.rst:511
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""
"Estende o lado direito do deque anexando elementos do argumento iterável."

#: ../../library/collections.rst:517
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""
"Estende o lado esquerdo do deque anexando elementos de *iterável*. Note que "
"a série de anexações à esquerda resulta na inversão da ordem dos elementos "
"no argumento iterável."

#: ../../library/collections.rst:524
msgid ""
"Return the position of *x* in the deque (at or after index *start* and "
"before index *stop*).  Returns the first match or raises :exc:`ValueError` "
"if not found."
msgstr ""
"Devolve a posição de *x* no deque (no ou após o índice *start* e antes do "
"índice *stop*). Devolve a primeira correspondência ou levanta :exc:"
"`ValueError` se não for encontrado."

#: ../../library/collections.rst:533
msgid "Insert *x* into the deque at position *i*."
msgstr "Insere *x* no deque na posição *i*."

#: ../../library/collections.rst:535
msgid ""
"If the insertion would cause a bounded deque to grow beyond *maxlen*, an :"
"exc:`IndexError` is raised."
msgstr ""
"Se a inserção fizesse com que um deque limitado crescesse além de *maxlen*, "
"é levantado um :exc:`IndexError`."

#: ../../library/collections.rst:543
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""
"Remove e devolve um elemento do lado direito do deque. Se não houver "
"elementos presentes, levanta um :exc:`IndexError`."

#: ../../library/collections.rst:549
msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""
"Remove e devolve um elemento do lado esquerdo do deque. Se não houver "
"elementos presentes, levanta um :exc:`IndexError`."

#: ../../library/collections.rst:555
msgid ""
"Remove the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""
"Remove a primeira ocorrência de *valor*. Se não for encontrado, levanta um :"
"exc:`ValueError`."

#: ../../library/collections.rst:561
msgid "Reverse the elements of the deque in-place and then return ``None``."
msgstr "Inverte os elementos do deque no local e depois devolve ``None``."

#: ../../library/collections.rst:568
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left."
msgstr ""
"Roda o deque *n* passos para a direita. Se *n* for negativo, roda para a "
"esquerda."

#: ../../library/collections.rst:571
msgid ""
"When the deque is not empty, rotating one step to the right is equivalent to "
"``d.appendleft(d.pop())``, and rotating one step to the left is equivalent "
"to ``d.append(d.popleft())``."
msgstr ""
"Quando o deque não está vazio, rodar um passo para a direita é equivalente a "
"``d.appendleft(d.pop())``, e rodar um passo para a esquerda é equivalente a "
"``d.append(d.popleft())``."

#: ../../library/collections.rst:576
msgid "Deque objects also provide one read-only attribute:"
msgstr "Os objetos Deque também fornecem um atributo apenas de leitura:"

#: ../../library/collections.rst:580
msgid "Maximum size of a deque or ``None`` if unbounded."
msgstr "Tamanho máximo de um deque ou ``None`` se não limitado."

#: ../../library/collections.rst:585
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as ``d[0]`` "
"to access the first element.  Indexed access is *O*\\ (1) at both ends but "
"slows to *O*\\ (*n*) in the middle.  For fast random access, use lists "
"instead."
msgstr ""
"Além do acima, os deques suportam iteração, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, teste de pertença "
"com o operador :keyword:`in`, e referências de subíndice como ``d[0]`` para "
"aceder ao primeiro elemento. O acesso indexado é *O*\\ (1) em ambas as "
"extremidades, mas torna-se *O*\\ (*n*) no meio. Para acesso aleatório "
"rápido, use listas em vez disso."

#: ../../library/collections.rst:591
msgid ""
"Starting in version 3.5, deques support ``__add__()``, ``__mul__()``, and "
"``__imul__()``."
msgstr ""
"A partir da versão 3.5, os deques suportam ``__add__()``, ``__mul__()`` e "
"``__imul__()``."

#: ../../library/collections.rst:594
msgid "Example:"
msgstr "Exemplo:"

#: ../../library/collections.rst:596
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in "
"reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input "
"order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # criar um novo deque com três itens\n"
">>> for elem in d:                   # iterar sobre os elementos do deque\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # adicionar uma nova entrada ao lado "
"direito\n"
">>> d.appendleft('f')                # adicionar uma nova entrada ao lado "
"esquerdo\n"
">>> d                                # mostrar a representação do deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # devolver e remover o item mais à "
"direita\n"
"'j'\n"
">>> d.popleft()                      # devolver e remover o item mais à "
"esquerda\n"
"'f'\n"
">>> list(d)                          # listar os conteúdos do deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # espreitar o item mais à esquerda\n"
"'g'\n"
">>> d[-1]                            # espreitar o item mais à direita\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # listar os conteúdos de um deque em "
"ordem inversa\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # pesquisar no deque\n"
"True\n"
">>> d.extend('jkl')                  # adicionar vários elementos de uma "
"vez\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # rotação para a direita\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # rotação para a esquerda\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # criar um novo deque em ordem inversa\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # esvaziar o deque\n"
">>> d.pop()                          # não é possível remover de um deque "
"vazio\n"
"Traceback (most recent call last):\n"
"    File \"<pyshell#6>\", line 1, in -toplevel-\n"
"        d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() inverte a ordem de "
"entrada\n"
">>> d\n"
"deque(['c', 'b', 'a'])"

#: ../../library/collections.rst:651
msgid ":class:`deque` Recipes"
msgstr "Receitas de :class:`deque`"

#: ../../library/collections.rst:653
msgid "This section shows various approaches to working with deques."
msgstr "Esta secção mostra várias abordagens para trabalhar com deques."

#: ../../library/collections.rst:655
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""
"Deques de comprimento limitado fornecem funcionalidade semelhante ao filtro "
"``tail`` no Unix:"

#: ../../library/collections.rst:658
msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    with open(filename) as f:\n"
"        return deque(f, n)"
msgstr ""
"def tail(nome_ficheiro, n=10):\n"
"    'Devolve as últimas n linhas de um ficheiro'\n"
"    with open(nome_ficheiro) as f:\n"
"        return deque(f, n)"

#: ../../library/collections.rst:663
msgid ""
"Another approach to using deques is to maintain a sequence of recently added "
"elements by appending to the right and popping to the left::"
msgstr ""
"Outra abordagem para usar deques é manter uma sequência de elementos "
"recentemente adicionados, anexando à direita e removendo da esquerda:"

#: ../../library/collections.rst:666
msgid ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"
msgstr ""
"def moving_average(iterável, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # https://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterável)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / n"

#: ../../library/collections.rst:678
msgid ""
"A `round-robin scheduler <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ can be implemented with input iterators stored in a :"
"class:`deque`.  Values are yielded from the active iterator in position "
"zero.  If that iterator is exhausted, it can be removed with :meth:`~deque."
"popleft`; otherwise, it can be cycled back to the end with the :meth:`~deque."
"rotate` method::"
msgstr ""
"Um `agendador round-robin <https://en.wikipedia.org/wiki/Round-"
"robin_scheduling>`_ pode ser implementado com iteradores de entrada "
"armazenados num :class:`deque`. Os valores são produzidos a partir do "
"iterador ativo na posição zero. Se esse iterador estiver esgotado, pode ser "
"removido com :meth:`~deque.popleft`; caso contrário, pode ser reciclado para "
"o final com o método :meth:`~deque.rotate`:"

#: ../../library/collections.rst:685
msgid ""
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iterators = deque(map(iter, iterables))\n"
"    while iterators:\n"
"        try:\n"
"            while True:\n"
"                yield next(iterators[0])\n"
"                iterators.rotate(-1)\n"
"        except StopIteration:\n"
"            # Remove an exhausted iterator.\n"
"            iterators.popleft()"
msgstr ""
"def roundrobin(*iteráveis):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    iteradores = deque(map(iter, iteráveis))\n"
"    while iteradores:\n"
"        try:\n"
"            while True:\n"
"                yield next(iteradores[0])\n"
"                iteradores.rotate(-1)\n"
"        except StopIteration:\n"
"            # Remove um iterador esgotado.\n"
"            iteradores.popleft()"

#: ../../library/collections.rst:697
msgid ""
"The :meth:`~deque.rotate` method provides a way to implement :class:`deque` "
"slicing and deletion.  For example, a pure Python implementation of ``del "
"d[n]`` relies on the ``rotate()`` method to position elements to be popped::"
msgstr ""
"O método :meth:`~deque.rotate` fornece uma forma de implementar a fatiação e "
"eliminação de :class:`deque`. Por exemplo, uma implementação pura em Python "
"de ``del d[n]`` depende do método ``rotate()`` para posicionar os elementos "
"a serem removidos:"

#: ../../library/collections.rst:701
msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"

#: ../../library/collections.rst:706
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`~deque.rotate` to bring a target element to the left side of the deque. "
"Remove old entries with :meth:`~deque.popleft`, add new entries with :meth:"
"`~deque.extend`, and then reverse the rotation. With minor variations on "
"that approach, it is easy to implement Forth style stack manipulations such "
"as ``dup``, ``drop``, ``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""
"Para implementar a fatiação de :class:`deque`, use uma abordagem semelhante "
"aplicando :meth:`~deque.rotate` para trazer um elemento alvo para o lado "
"esquerdo do deque. Remova entradas antigas com :meth:`~deque.popleft`, "
"adicione novas entradas com :meth:`~deque.extend` e depois inverta a "
"rotação. Com pequenas variações nessa abordagem, é fácil implementar "
"manipulações de pilha no estilo Forth, como ``dup``, ``drop``, ``swap``, "
"``over``, ``pick``, ``rot`` e ``roll``."

#: ../../library/collections.rst:716
msgid ":class:`defaultdict` objects"
msgstr "Objetos :class:`defaultdict`"

#: ../../library/collections.rst:720
msgid ""
"Return a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""
"Devolve um novo objeto semelhante a um dicionário. :class:`defaultdict` é "
"uma subclasse da classe integrada :class:`dict`. Substitui um método e "
"adiciona uma variável de instância gravável. A funcionalidade restante é a "
"mesma que a da classe :class:`dict` e não está documentada aqui."

#: ../../library/collections.rst:725
msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""
"O primeiro argumento fornece o valor inicial para o atributo :attr:"
"`default_factory`; por defeito é ``None``. Todos os argumentos restantes são "
"tratados da mesma forma como se fossem passados para o construtor :class:"
"`dict`, incluindo argumentos de palavra-chave."

#: ../../library/collections.rst:731
msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""
"Os objetos :class:`defaultdict` suportam o seguinte método além das "
"operações padrão :class:`dict`:"

#: ../../library/collections.rst:736
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""
"Se o atributo :attr:`default_factory` for ``None``, isto levanta uma "
"exceção :exc:`KeyError` com a *chave* como argumento."

#: ../../library/collections.rst:739
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""
"Se :attr:`default_factory` não for ``None``, é chamado sem argumentos para "
"fornecer um valor predefinido para a *chave* dada, este valor é inserido no "
"dicionário para a *chave* e devolvido."

#: ../../library/collections.rst:743
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""
"Se chamar :attr:`default_factory` levantar uma exceção, esta exceção é "
"propagada sem alterações."

#: ../../library/collections.rst:746
msgid ""
"This method is called by the :meth:`~object.__getitem__` method of the :"
"class:`dict` class when the requested key is not found; whatever it returns "
"or raises is then returned or raised by :meth:`~object.__getitem__`."
msgstr ""
"Este método é chamado pelo método :meth:`~object.__getitem__` da classe :"
"class:`dict` quando a chave solicitada não é encontrada; qualquer coisa que "
"retorne ou levante é então retornada ou levantada por :meth:`~object."
"__getitem__`."

#: ../../library/collections.rst:750
msgid ""
"Note that :meth:`__missing__` is *not* called for any operations besides :"
"meth:`~object.__getitem__`. This means that :meth:`~dict.get` will, like "
"normal dictionaries, return ``None`` as a default rather than using :attr:"
"`default_factory`."
msgstr ""
"Note que :meth:`__missing__` *não* é chamado para quaisquer operações além "
"de :meth:`~object.__getitem__`. Isto significa que :meth:`~dict.get` "
"retornará, como dicionários normais, ``None`` como predefinição em vez de "
"usar :attr:`default_factory`."

#: ../../library/collections.rst:756
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ""
"Os objetos :class:`defaultdict` suportam a seguinte variável de instância:"

#: ../../library/collections.rst:761
msgid ""
"This attribute is used by the :meth:`~defaultdict.__missing__` method; it is "
"initialized from the first argument to the constructor, if present, or to "
"``None``, if absent."
msgstr ""
"Este atributo é usado pelo método :meth:`~defaultdict.__missing__`; é "
"inicializado a partir do primeiro argumento passado ao construtor, se "
"presente, ou para ``None``, se ausente."

#: ../../library/collections.rst:765 ../../library/collections.rst:1192
msgid ""
"Added merge (``|``) and update (``|=``) operators, specified in :pep:`584`."
msgstr ""
"Adicionados os operadores de fusão (``|``) e atualização (``|=``), "
"especificados em :pep:`584`."

#: ../../library/collections.rst:771
msgid ":class:`defaultdict` Examples"
msgstr "Exemplos de :class:`defaultdict`"

#: ../../library/collections.rst:773
msgid ""
"Using :class:`list` as the :attr:`~defaultdict.default_factory`, it is easy "
"to group a sequence of key-value pairs into a dictionary of lists:"
msgstr ""
"Usando :class:`list` como :attr:`~defaultdict.default_factory`, é fácil "
"agrupar uma sequência de pares chave-valor num dicionário de listas:"

#: ../../library/collections.rst:784
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:`~defaultdict."
"default_factory` function which returns an empty :class:`list`.  The :meth:"
"`list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""
"Quando cada chave é encontrada pela primeira vez, não está ainda no "
"mapeamento; assim, uma entrada é criada automaticamente usando a função :"
"attr:`~defaultdict.default_factory`, que devolve uma :class:`list` vazia. A "
"operação :meth:`list.append` anexa então o valor à nova lista. Quando as "
"chaves são encontradas novamente, a pesquisa prossegue normalmente "
"(devolvendo a lista para essa chave) e a operação :meth:`list.append` "
"adiciona outro valor à lista. Esta técnica é mais simples e rápida do que "
"uma técnica equivalente usando :meth:`dict.setdefault`:"

#: ../../library/collections.rst:799
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`int` makes the :"
"class:`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""
"Definir o :attr:`~defaultdict.default_factory` para :class:`int` torna o :"
"class:`defaultdict` útil para contagens (como um saco ou multiconjunto em "
"outras linguagens):"

#: ../../library/collections.rst:811
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`~defaultdict.default_factory` function calls :func:`int` to supply a "
"default count of zero.  The increment operation then builds up the count for "
"each letter."
msgstr ""
"Quando uma letra é encontrada pela primeira vez, está em falta no "
"mapeamento, então a função :attr:`~defaultdict.default_factory` chama :func:"
"`int` para fornecer uma contagem predefinida de zero. A operação de "
"incremento constrói então a contagem para cada letra."

#: ../../library/collections.rst:815
msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use a lambda function which can supply any constant value "
"(not just zero):"
msgstr ""
"A função :func:`int`, que sempre devolve zero, é apenas um caso especial de "
"funções constantes. Uma forma mais rápida e flexível de criar funções "
"constantes é usar uma função lambda, que pode fornecer qualquer valor "
"constante (não apenas zero):"

#: ../../library/collections.rst:828
msgid ""
"Setting the :attr:`~defaultdict.default_factory` to :class:`set` makes the :"
"class:`defaultdict` useful for building a dictionary of sets:"
msgstr ""
"Definir o :attr:`~defaultdict.default_factory` para :class:`set` torna o :"
"class:`defaultdict` útil para construir um dicionário de conjuntos:"

#: ../../library/collections.rst:841
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ":func:`namedtuple` Função de Fábrica para Tuplos com Campos Nomeados"

#: ../../library/collections.rst:843
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""
"Os tuplos nomeados atribuem significado a cada posição num tuplo e permitem "
"um código mais legível e auto-documentado. Podem ser usados onde quer que "
"tuplos regulares sejam usados, e adicionam a capacidade de aceder aos campos "
"por nome em vez de índice de posição."

#: ../../library/collections.rst:849
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with *typename* and *field_names*) and a helpful :meth:"
"`~object.__repr__` method which lists the tuple contents in a ``name=value`` "
"format."
msgstr ""
"Devolve uma nova subclasse de tuplo chamada *typename*. A nova subclasse é "
"usada para criar objetos semelhantes a tuplos que têm campos acessíveis por "
"pesquisa de atributo, bem como sendo indexáveis e iteráveis. As instâncias "
"da subclasse também têm uma docstring útil (com *typename* e *field_names*) "
"e um método útil :meth:`~object.__repr__` que lista o conteúdo do tuplo num "
"formato ``name=value``."

#: ../../library/collections.rst:856
msgid ""
"The *field_names* are a sequence of strings such as ``['x', 'y']``. "
"Alternatively, *field_names* can be a single string with each fieldname "
"separated by whitespace and/or commas, for example ``'x y'`` or ``'x, y'``."
msgstr ""
"Os *field_names* são uma sequência de strings como ``['x', 'y']``. "
"Alternativamente, *field_names* pode ser uma única string com cada nome de "
"campo separado por espaços em branco e/ou vírgulas, por exemplo ``'x y'`` ou "
"``'x, y'``."

#: ../../library/collections.rst:860
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, or *raise*."
msgstr ""
"Qualquer identificador Python válido pode ser usado para um nome de campo, "
"exceto nomes que comecem com um sublinhado. Identificadores válidos "
"consistem em letras, dígitos e sublinhados, mas não começam com um dígito ou "
"sublinhado e não podem ser uma :mod:`keyword` como *class*, *for*, *return*, "
"*global*, *pass* ou *raise*."

#: ../../library/collections.rst:866
msgid ""
"If *rename* is true, invalid fieldnames are automatically replaced with "
"positional names.  For example, ``['abc', 'def', 'ghi', 'abc']`` is "
"converted to ``['abc', '_1', 'ghi', '_3']``, eliminating the keyword ``def`` "
"and the duplicate fieldname ``abc``."
msgstr ""
"Se *rename* for verdadeiro, nomes de campo inválidos são automaticamente "
"substituídos por nomes posicionais. Por exemplo, ``['abc', 'def', 'ghi', "
"'abc']`` é convertido para ``['abc', '_1', 'ghi', '_3']``, eliminando a "
"palavra-chave ``def`` e o nome de campo duplicado ``abc``."

#: ../../library/collections.rst:871
msgid ""
"*defaults* can be ``None`` or an :term:`iterable` of default values. Since "
"fields with a default value must come after any fields without a default, "
"the *defaults* are applied to the rightmost parameters.  For example, if the "
"fieldnames are ``['x', 'y', 'z']`` and the defaults are ``(1, 2)``, then "
"``x`` will be a required argument, ``y`` will default to ``1``, and ``z`` "
"will default to ``2``."
msgstr ""
"*defaults* pode ser ``None`` ou um :term:`iterável` de valores predefinidos. "
"Como os campos com um valor predefinido devem vir depois de quaisquer campos "
"sem um valor predefinido, os *defaults* são aplicados aos parâmetros mais à "
"direita. Por exemplo, se os nomes dos campos forem ``['x', 'y', 'z']`` e os "
"valores predefinidos forem ``(1, 2)``, então ``x`` será um argumento "
"obrigatório, ``y`` terá o valor predefinido ``1`` e ``z`` terá o valor "
"predefinido ``2``."

#: ../../library/collections.rst:878
msgid ""
"If *module* is defined, the :attr:`~type.__module__` attribute of the named "
"tuple is set to that value."
msgstr ""
"Se *module* for definido, o atributo :attr:`~type.__module__` do tuplo "
"nomeado é definido para esse valor."

#: ../../library/collections.rst:881
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""
"As instâncias de tuplos nomeados não têm dicionários por instância, por isso "
"são leves e não requerem mais memória do que tuplos regulares."

#: ../../library/collections.rst:884
msgid ""
"To support pickling, the named tuple class should be assigned to a variable "
"that matches *typename*."
msgstr ""
"Para suportar pickling, a classe de tuplo nomeado deve ser atribuída a uma "
"variável que corresponda a *typename*."

#: ../../library/collections.rst:887
msgid "Added support for *rename*."
msgstr "Adicionado suporte para *rename*."

#: ../../library/collections.rst:890
msgid ""
"The *verbose* and *rename* parameters became :ref:`keyword-only arguments "
"<keyword-only_parameter>`."
msgstr ""
"Os parâmetros *verbose* e *rename* tornaram-se :ref:`argumentos apenas de "
"palavra-chave <keyword-only_parameter>`."

#: ../../library/collections.rst:894
msgid "Added the *module* parameter."
msgstr "Adicionado o parâmetro *module*."

#: ../../library/collections.rst:897
msgid "Removed the *verbose* parameter and the :attr:`!_source` attribute."
msgstr "Removido o parâmetro *verbose* e o atributo :attr:`!_source`."

#: ../../library/collections.rst:900
msgid ""
"Added the *defaults* parameter and the :attr:`~somenamedtuple."
"_field_defaults` attribute."
msgstr ""
"Adicionado o parâmetro *defaults* e o atributo :attr:`~somenamedtuple."
"_field_defaults`."

#: ../../library/collections.rst:904
msgid ""
">>> # Basic example\n"
">>> Point = namedtuple('Point', ['x', 'y'])\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword "
"arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)"
msgstr ""
">>> # Exemplo básico\n"
">>> Ponto = namedtuple('Ponto', ['x', 'y'])\n"
">>> p = Ponto(11, y=22)     # instanciar com argumentos posicionais ou de "
"palavra-chave\n"
">>> p[0] + p[1]             # indexável como o tuplo simples (11, 22)\n"
"33\n"
">>> x, y = p                # desempacotar como um tuplo regular\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # campos também acessíveis por nome\n"
"33\n"
">>> p                       # __repr__ legível com estilo nome=valor\n"
"Ponto(x=11, y=22)"

#: ../../library/collections.rst:920
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""
"Os tuplos nomeados são especialmente úteis para atribuir nomes de campo a "
"tuplos de resultado devolvidos pelos módulos :mod:`csv` ou :mod:`sqlite3`:"

#: ../../library/collections.rst:923
msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, "
"paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"
msgstr ""
"RegistroEmpregado = namedtuple('RegistroEmpregado', 'nome, idade, cargo, "
"departamento, nível_salário')\n"
"\n"
"import csv\n"
"for emp in map(RegistroEmpregado._make, csv.reader(open(\"empregados.csv\", "
"\"rb\"))):\n"
"    print(emp.nome, emp.cargo)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/dados_empresa')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT nome, idade, cargo, departamento, nível_salário FROM "
"empregados')\n"
"for emp in map(RegistroEmpregado._make, cursor.fetchall()):\n"
"    print(emp.nome, emp.cargo)"

#: ../../library/collections.rst:936
msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and two attributes.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""
"Além dos métodos herdados de tuplos, os tuplos nomeados suportam três "
"métodos adicionais e dois atributos. Para evitar conflitos com nomes de "
"campo, os nomes de métodos e atributos começam com um sublinhado."

#: ../../library/collections.rst:942
msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""
"Método de classe que cria uma nova instância a partir de uma sequência ou "
"iterável existente."

#: ../../library/collections.rst:944
msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""
">>> t = [11, 22]\n"
">>> Ponto._make(t)\n"
"Ponto(x=11, y=22)"

#: ../../library/collections.rst:952
msgid ""
"Return a new :class:`dict` which maps field names to their corresponding "
"values:"
msgstr ""
"Devolve um novo :class:`dict` que mapeia nomes de campo aos seus valores "
"correspondentes:"

#: ../../library/collections.rst:955
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""
">>> p = Ponto(x=11, y=22)\n"
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"

#: ../../library/collections.rst:961
msgid "Returns an :class:`OrderedDict` instead of a regular :class:`dict`."
msgstr "Devolve um :class:`OrderedDict` em vez de um :class:`dict` regular."

#: ../../library/collections.rst:964
msgid ""
"Returns a regular :class:`dict` instead of an :class:`OrderedDict`. As of "
"Python 3.7, regular dicts are guaranteed to be ordered.  If the extra "
"features of :class:`OrderedDict` are required, the suggested remediation is "
"to cast the result to the desired type: ``OrderedDict(nt._asdict())``."
msgstr ""
"Devolve um :class:`dict` regular em vez de um :class:`OrderedDict`. A partir "
"do Python 3.7, os dicionários regulares são garantidamente ordenados. Se as "
"funcionalidades extras de :class:`OrderedDict` forem necessárias, a solução "
"sugerida é converter o resultado para o tipo desejado: ``OrderedDict(nt."
"_asdict())``."

#: ../../library/collections.rst:973
msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values::"
msgstr ""
"Devolve uma nova instância do tuplo nomeado substituindo os campos "
"especificados por novos valores:"

#: ../../library/collections.rst:976
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], "
"timestamp=time.now())"
msgstr ""
">>> p = Ponto(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Ponto(x=33, y=22)\n"
"\n"
">>> for num_peça, registo in inventário.items():\n"
"...     inventário[num_peça] = registo._replace(preço=novo_preços[num_peça], "
"carimbo_tempo=time.now())"

#: ../../library/collections.rst:983
msgid ""
"Named tuples are also supported by generic function :func:`copy.replace`."
msgstr ""
"Os tuplos nomeados também são suportados pela função genérica :func:`copy."
"replace`."

#: ../../library/collections.rst:985
msgid ""
"Raise :exc:`TypeError` instead of :exc:`ValueError` for invalid keyword "
"arguments."
msgstr ""
"Levanta :exc:`TypeError` em vez de :exc:`ValueError` para argumentos de "
"palavra-chave inválidos."

#: ../../library/collections.rst:991
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""
"Tuplo de strings que lista os nomes dos campos. Útil para introspeção e para "
"criar novos tipos de tuplos nomeados a partir de tuplos nomeados existentes."

#: ../../library/collections.rst:994
msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""
">>> p._fields            # ver os nomes dos campos\n"
"('x', 'y')\n"
"\n"
">>> Cor = namedtuple('Cor', 'vermelho verde azul')\n"
">>> Pixel = namedtuple('Pixel', Ponto._fields + Cor._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, vermelho=128, verde=255, azul=0)"

#: ../../library/collections.rst:1006
msgid "Dictionary mapping field names to default values."
msgstr "Dicionário que mapeia nomes de campo para valores predefinidos."

#: ../../library/collections.rst:1008
msgid ""
">>> Account = namedtuple('Account', ['type', 'balance'], defaults=[0])\n"
">>> Account._field_defaults\n"
"{'balance': 0}\n"
">>> Account('premium')\n"
"Account(type='premium', balance=0)"
msgstr ""
">>> Conta = namedtuple('Conta', ['tipo', 'saldo'], defaults=[0])\n"
">>> Conta._field_defaults\n"
"{'saldo': 0}\n"
">>> Conta('premium')\n"
"Conta(tipo='premium', saldo=0)"

#: ../../library/collections.rst:1016
msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""
"Para recuperar um campo cujo nome está armazenado numa string, use a função :"
"func:`getattr`:"

#: ../../library/collections.rst:1022
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""
"Para converter um dicionário num tuplo nomeado, use o operador de duplo "
"asterisco (como descrito em :ref:`tut-unpacking-arguments`):"

#: ../../library/collections.rst:1029
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""
"Como um tuplo nomeado é uma classe Python regular, é fácil adicionar ou "
"alterar funcionalidades com uma subclasse. Aqui está como adicionar um campo "
"calculado e um formato de impressão de largura fixa:"

#: ../../library/collections.rst:1033
msgid ""
">>> class Point(namedtuple('Point', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hypot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Point: x=%6.3f  y=%6.3f  hypot=%6.3f' % (self.x, self.y, "
"self.hypot)\n"
"\n"
">>> for p in Point(3, 4), Point(14, 5/7):\n"
"...     print(p)\n"
"Point: x= 3.000  y= 4.000  hypot= 5.000\n"
"Point: x=14.000  y= 0.714  hypot=14.018"
msgstr ""
">>> class Ponto(namedtuple('Ponto', ['x', 'y'])):\n"
"...     __slots__ = ()\n"
"...     @property\n"
"...     def hipot(self):\n"
"...         return (self.x ** 2 + self.y ** 2) ** 0.5\n"
"...     def __str__(self):\n"
"...         return 'Ponto: x=%6.3f  y=%6.3f  hipot=%6.3f' % (self.x, self.y, "
"self.hipot)\n"
"\n"
">>> for p in Ponto(3, 4), Ponto(14, 5/7):\n"
"...     print(p)\n"
"Ponto: x= 3.000  y= 4.000  hipot= 5.000\n"
"Ponto: x=14.000  y= 0.714  hipot=14.018"

#: ../../library/collections.rst:1048
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""
"A subclasse mostrada acima define ``__slots__`` como um tuplo vazio. Isto "
"ajuda a manter os requisitos de memória baixos, evitando a criação de "
"dicionários de instância."

#: ../../library/collections.rst:1051
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`~somenamedtuple._fields` "
"attribute:"
msgstr ""
"A criação de subclasses não é útil para adicionar novos campos armazenados. "
"Em vez disso, simplesmente crie um novo tipo de tuplo nomeado a partir do "
"atributo :attr:`~somenamedtuple._fields`:"

#: ../../library/collections.rst:1056
msgid ""
"Docstrings can be customized by making direct assignments to the ``__doc__`` "
"fields:"
msgstr ""
"As docstrings podem ser personalizadas fazendo atribuições diretas aos "
"campos ``__doc__``:"

#: ../../library/collections.rst:1065
msgid "Property docstrings became writeable."
msgstr "As docstrings de propriedade tornaram-se graváveis."

#: ../../library/collections.rst:1070
msgid ""
"See :class:`typing.NamedTuple` for a way to add type hints for named "
"tuples.  It also provides an elegant notation using the :keyword:`class` "
"keyword::"
msgstr ""
"Veja :class:`typing.NamedTuple` para uma forma de adicionar dicas de tipo "
"para tuplos nomeados. Também fornece uma notação elegante usando a palavra-"
"chave :keyword:`class`:"

#: ../../library/collections.rst:1074
msgid ""
"class Component(NamedTuple):\n"
"    part_number: int\n"
"    weight: float\n"
"    description: Optional[str] = None"
msgstr ""
"class Componente(NamedTuple):\n"
"    número_peça: int\n"
"    peso: float\n"
"    descrição: Optional[str] = None"

#: ../../library/collections.rst:1079
msgid ""
"See :meth:`types.SimpleNamespace` for a mutable namespace based on an "
"underlying dictionary instead of a tuple."
msgstr ""
"Veja :meth:`types.SimpleNamespace` para um espaço de nomes mutável baseado "
"num dicionário subjacente em vez de um tuplo."

#: ../../library/collections.rst:1082
msgid ""
"The :mod:`dataclasses` module provides a decorator and functions for "
"automatically adding generated special methods to user-defined classes."
msgstr ""
"O módulo :mod:`dataclasses` fornece um decorador e funções para adicionar "
"automaticamente métodos especiais gerados a classes definidas pelo "
"utilizador."

#: ../../library/collections.rst:1087
msgid ":class:`OrderedDict` objects"
msgstr "Objetos :class:`OrderedDict`"

#: ../../library/collections.rst:1089
msgid ""
"Ordered dictionaries are just like regular dictionaries but have some extra "
"capabilities relating to ordering operations.  They have become less "
"important now that the built-in :class:`dict` class gained the ability to "
"remember insertion order (this new behavior became guaranteed in Python 3.7)."
msgstr ""
"Os dicionários ordenados são exatamente como dicionários regulares, mas têm "
"algumas capacidades extras relacionadas com operações de ordenação. Tornaram-"
"se menos importantes agora que a classe integrada :class:`dict` ganhou a "
"capacidade de lembrar a ordem de inserção (este novo comportamento tornou-se "
"garantido no Python 3.7)."

#: ../../library/collections.rst:1095
msgid "Some differences from :class:`dict` still remain:"
msgstr "Algumas diferenças em relação a :class:`dict` ainda permanecem:"

#: ../../library/collections.rst:1097
msgid ""
"The regular :class:`dict` was designed to be very good at mapping "
"operations.  Tracking insertion order was secondary."
msgstr ""
"O :class:`dict` regular foi concebido para ser muito bom em operações de "
"mapeamento. O rastreio da ordem de inserção era secundário."

#: ../../library/collections.rst:1100
msgid ""
"The :class:`OrderedDict` was designed to be good at reordering operations. "
"Space efficiency, iteration speed, and the performance of update operations "
"were secondary."
msgstr ""
"O :class:`OrderedDict` foi concebido para ser bom em operações de "
"reordenação. A eficiência de espaço, a velocidade de iteração e o desempenho "
"das operações de atualização eram secundários."

#: ../../library/collections.rst:1104
msgid ""
"The :class:`OrderedDict` algorithm can handle frequent reordering operations "
"better than :class:`dict`.  As shown in the recipes below, this makes it "
"suitable for implementing various kinds of LRU caches."
msgstr ""
"O algoritmo :class:`OrderedDict` pode lidar melhor com operações frequentes "
"de reordenação do que :class:`dict`. Como mostrado nas receitas abaixo, isto "
"torna-o adequado para implementar vários tipos de caches LRU."

#: ../../library/collections.rst:1108
msgid ""
"The equality operation for :class:`OrderedDict` checks for matching order."
msgstr ""
"A operação de igualdade para :class:`OrderedDict` verifica a correspondência "
"da ordem."

#: ../../library/collections.rst:1110
msgid ""
"A regular :class:`dict` can emulate the order sensitive equality test with "
"``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."
msgstr ""
"Um :class:`dict` regular pode emular o teste de igualdade sensível à ordem "
"com ``p == q and all(k1 == k2 for k1, k2 in zip(p, q))``."

#: ../../library/collections.rst:1113
msgid ""
"The :meth:`~OrderedDict.popitem` method of :class:`OrderedDict` has a "
"different signature.  It accepts an optional argument to specify which item "
"is popped."
msgstr ""
"O método :meth:`~OrderedDict.popitem` de :class:`OrderedDict` tem uma "
"assinatura diferente. Aceita um argumento opcional para especificar qual "
"item é removido."

#: ../../library/collections.rst:1116
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=True)`` "
"with ``d.popitem()`` which is guaranteed to pop the rightmost (last) item."
msgstr ""
"Um :class:`dict` regular pode emular ``od.popitem(last=True)`` de "
"OrderedDict com ``d.popitem()``, que é garantido remover o item mais à "
"direita (último)."

#: ../../library/collections.rst:1119
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.popitem(last=False)`` "
"with ``(k := next(iter(d)), d.pop(k))`` which will return and remove the "
"leftmost (first) item if it exists."
msgstr ""
"Um :class:`dict` regular pode emular ``od.popitem(last=False)`` de "
"OrderedDict com ``(k := next(iter(d)), d.pop(k))``, que devolverá e removerá "
"o item mais à esquerda (primeiro), se existir."

#: ../../library/collections.rst:1123
msgid ""
":class:`OrderedDict` has a :meth:`~OrderedDict.move_to_end` method to "
"efficiently reposition an element to an endpoint."
msgstr ""
":class:`OrderedDict` tem um método :meth:`~OrderedDict.move_to_end` para "
"reposicionar eficientemente um elemento para uma extremidade."

#: ../../library/collections.rst:1126
msgid ""
"A regular :class:`dict` can emulate OrderedDict's ``od.move_to_end(k, "
"last=True)`` with ``d[k] = d.pop(k)`` which will move the key and its "
"associated value to the rightmost (last) position."
msgstr ""
"Um :class:`dict` regular pode emular ``od.move_to_end(k, last=True)`` de "
"OrderedDict com ``d[k] = d.pop(k)``, que moverá a chave e o seu valor "
"associado para a posição mais à direita (última)."

#: ../../library/collections.rst:1130
msgid ""
"A regular :class:`dict` does not have an efficient equivalent for "
"OrderedDict's ``od.move_to_end(k, last=False)`` which moves the key and its "
"associated value to the leftmost (first) position."
msgstr ""
"Um :class:`dict` regular não tem um equivalente eficiente para ``od."
"move_to_end(k, last=False)`` de OrderedDict, que move a chave e o seu valor "
"associado para a posição mais à esquerda (primeira)."

#: ../../library/collections.rst:1134
msgid ""
"Until Python 3.8, :class:`dict` lacked a :meth:`~object.__reversed__` method."
msgstr ""
"Até ao Python 3.8, :class:`dict` não tinha um método :meth:`~object."
"__reversed__`."

#: ../../library/collections.rst:1139
msgid ""
"Return an instance of a :class:`dict` subclass that has methods specialized "
"for rearranging dictionary order."
msgstr ""
"Devolve uma instância de uma subclasse de :class:`dict` que tem métodos "
"especializados para reordenar a ordem do dicionário."

#: ../../library/collections.rst:1146
msgid ""
"The :meth:`popitem` method for ordered dictionaries returns and removes a "
"(key, value) pair.  The pairs are returned in :abbr:`LIFO (last-in, first-"
"out)` order if *last* is true or :abbr:`FIFO (first-in, first-out)` order if "
"false."
msgstr ""
"O método :meth:`popitem` para dicionários ordenados devolve e remove um par "
"(chave, valor). Os pares são devolvidos em ordem :abbr:`LIFO (último a "
"entrar, primeiro a sair)` se *last* for verdadeiro ou em ordem :abbr:`FIFO "
"(primeiro a entrar, primeiro a sair)` se for falso."

#: ../../library/collections.rst:1153
msgid ""
"Move an existing *key* to either end of an ordered dictionary.  The item is "
"moved to the right end if *last* is true (the default) or to the beginning "
"if *last* is false.  Raises :exc:`KeyError` if the *key* does not exist:"
msgstr ""
"Move uma *chave* existente para qualquer extremidade de um dicionário "
"ordenado. O item é movido para a extremidade direita se *last* for "
"verdadeiro (o predefinido) ou para o início se *last* for falso. Levanta :"
"exc:`KeyError` se a *chave* não existir:"

#: ../../library/collections.rst:1158
msgid ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"
msgstr ""
">>> d = OrderedDict.fromkeys('abcde')\n"
">>> d.move_to_end('b')\n"
">>> ''.join(d)\n"
"'acdeb'\n"
">>> d.move_to_end('b', last=False)\n"
">>> ''.join(d)\n"
"'bacde'"

#: ../../library/collections.rst:1170
msgid ""
"In addition to the usual mapping methods, ordered dictionaries also support "
"reverse iteration using :func:`reversed`."
msgstr ""
"Além dos métodos habituais de mapeamento, os dicionários ordenados também "
"suportam iteração reversa usando :func:`reversed`."

#: ../../library/collections.rst:1175
msgid ""
"Equality tests between :class:`OrderedDict` objects are order-sensitive and "
"are roughly equivalent to ``list(od1.items())==list(od2.items())``."
msgstr ""
"Os testes de igualdade entre objetos :class:`OrderedDict` são sensíveis à "
"ordem e são aproximadamente equivalentes a ``list(od1.items())==list(od2."
"items())``."

#: ../../library/collections.rst:1178
msgid ""
"Equality tests between :class:`OrderedDict` objects and other :class:"
"`~collections.abc.Mapping` objects are order-insensitive like regular "
"dictionaries.  This allows :class:`OrderedDict` objects to be substituted "
"anywhere a regular dictionary is used."
msgstr ""
"Os testes de igualdade entre objetos :class:`OrderedDict` e outros objetos :"
"class:`~collections.abc.Mapping` são insensíveis à ordem, como os "
"dicionários regulares. Isto permite que os objetos :class:`OrderedDict` "
"sejam substituídos em qualquer lugar onde um dicionário regular é usado."

#: ../../library/collections.rst:1183
msgid ""
"The items, keys, and values :term:`views <dictionary view>` of :class:"
"`OrderedDict` now support reverse iteration using :func:`reversed`."
msgstr ""
"As vistas :term:`views <dictionary view>` de itens, chaves e valores de :"
"class:`OrderedDict` agora suportam iteração reversa usando :func:`reversed`."

#: ../../library/collections.rst:1187
msgid ""
"With the acceptance of :pep:`468`, order is retained for keyword arguments "
"passed to the :class:`OrderedDict` constructor and its :meth:`~dict.update` "
"method."
msgstr ""
"Com a aceitação de :pep:`468`, a ordem é mantida para argumentos de palavra-"
"chave passados ao construtor :class:`OrderedDict` e ao seu método :meth:"
"`~dict.update`."

#: ../../library/collections.rst:1197
msgid ":class:`OrderedDict` Examples and Recipes"
msgstr "Exemplos e Receitas de :class:`OrderedDict`"

#: ../../library/collections.rst:1199
msgid ""
"It is straightforward to create an ordered dictionary variant that remembers "
"the order the keys were *last* inserted. If a new entry overwrites an "
"existing entry, the original insertion position is changed and moved to the "
"end::"
msgstr ""
"É simples criar uma variante de dicionário ordenado que recorda a ordem em "
"que as chaves foram inseridas pela *última* vez. Se uma nova entrada "
"sobrescrever uma entrada existente, a posição de inserção original é "
"alterada e movida para o fim:"

#: ../../library/collections.rst:1204
msgid ""
"class LastUpdatedOrderedDict(OrderedDict):\n"
"    'Store items in the order the keys were last added'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"
msgstr ""
"class ÚltimoAtualizadoOrderedDict(OrderedDict):\n"
"    'Armazena itens pela ordem em que as chaves foram adicionadas pela "
"última vez'\n"
"\n"
"    def __setitem__(self, key, value):\n"
"        super().__setitem__(key, value)\n"
"        self.move_to_end(key)"

#: ../../library/collections.rst:1211
msgid ""
"An :class:`OrderedDict` would also be useful for implementing variants of :"
"func:`functools.lru_cache`:"
msgstr ""
"Um :class:`OrderedDict` também seria útil para implementar variantes de :"
"func:`functools.lru_cache`:"

#: ../../library/collections.rst:1214
msgid ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class TimeBoundedLRU:\n"
"    \"LRU Cache that invalidates and refreshes old entries.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (timestamp, result)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            timestamp, result = self.cache[args]\n"
"            if time() - timestamp <= self.maxage:\n"
"                return result\n"
"        result = self.func(*args)\n"
"        self.cache[args] = time(), result\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return result"
msgstr ""
"from collections import OrderedDict\n"
"from time import time\n"
"\n"
"class LRUTemporalLimitado:\n"
"    \"Cache LRU que invalida e atualiza entradas antigas.\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxage=30):\n"
"        self.cache = OrderedDict()      # { args : (carimbo_tempo, "
"resultado)}\n"
"        self.func = func\n"
"        self.maxsize = maxsize\n"
"        self.maxage = maxage\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            carimbo_tempo, resultado = self.cache[args]\n"
"            if time() - carimbo_tempo <= self.maxage:\n"
"                return resultado\n"
"        resultado = self.func(*args)\n"
"        self.cache[args] = time(), resultado\n"
"        if len(self.cache) > self.maxsize:\n"
"            self.cache.popitem(last=False)\n"
"        return resultado"

#: ../../library/collections.rst:1241
msgid ""
"class MultiHitLRUCache:\n"
"    \"\"\" LRU cache that defers caching a result until\n"
"        it has been requested multiple times.\n"
"\n"
"        To avoid flushing the LRU cache with one-time requests,\n"
"        we don't cache until a request has been made more than once.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.requests = OrderedDict()   # { uncached_key : request_count }\n"
"        self.cache = OrderedDict()      # { cached_key : function_result }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # max number of uncached requests\n"
"        self.maxsize = maxsize          # max number of stored return "
"values\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        result = self.func(*args)\n"
"        self.requests[args] = self.requests.get(args, 0) + 1\n"
"        if self.requests[args] <= self.cache_after:\n"
"            self.requests.move_to_end(args)\n"
"            if len(self.requests) > self.maxrequests:\n"
"                self.requests.popitem(last=False)\n"
"        else:\n"
"            self.requests.pop(args, None)\n"
"            self.cache[args] = result\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return result"
msgstr ""
"class CacheLRUMúltiplasAcertos:\n"
"    \"\"\" Cache LRU que adia o armazenamento em cache de um resultado até\n"
"        que tenha sido solicitado várias vezes.\n"
"\n"
"        Para evitar limpar a cache LRU com pedidos únicos,\n"
"        não armazenamos em cache até que um pedido tenha sido feito mais do "
"que uma vez.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, func, maxsize=128, maxrequests=4096, cache_after=1):\n"
"        self.pedidos = OrderedDict()   # { chave_não_armazenada : "
"contagem_pedidos }\n"
"        self.cache = OrderedDict()      # { chave_armazenada : "
"resultado_função }\n"
"        self.func = func\n"
"        self.maxrequests = maxrequests  # número máximo de pedidos não "
"armazenados\n"
"        self.maxsize = maxsize          # número máximo de valores de "
"retorno armazenados\n"
"        self.cache_after = cache_after\n"
"\n"
"    def __call__(self, *args):\n"
"        if args in self.cache:\n"
"            self.cache.move_to_end(args)\n"
"            return self.cache[args]\n"
"        resultado = self.func(*args)\n"
"        self.pedidos[args] = self.pedidos.get(args, 0) + 1\n"
"        if self.pedidos[args] <= self.cache_after:\n"
"            self.pedidos.move_to_end(args)\n"
"            if len(self.pedidos) > self.maxrequests:\n"
"                self.pedidos.popitem(last=False)\n"
"        else:\n"
"            self.pedidos.pop(args, None)\n"
"            self.cache[args] = resultado\n"
"            if len(self.cache) > self.maxsize:\n"
"                self.cache.popitem(last=False)\n"
"        return resultado"

#: ../../library/collections.rst:1310
msgid ":class:`UserDict` objects"
msgstr "Objetos :class:`UserDict`"

#: ../../library/collections.rst:1312
msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier to "
"work with because the underlying dictionary is accessible as an attribute."
msgstr ""
"A classe :class:`UserDict` atua como um invólucro em torno de objetos de "
"dicionário. A necessidade desta classe foi parcialmente substituída pela "
"capacidade de criar subclasses diretamente de :class:`dict`; no entanto, "
"esta classe pode ser mais fácil de trabalhar porque o dicionário subjacente "
"é acessível como um atributo."

#: ../../library/collections.rst:1320
msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a "
"regular dictionary, which is accessible via the :attr:`data` attribute of :"
"class:`UserDict` instances.  If *initialdata* is provided, :attr:`data` is "
"initialized with its contents; note that a reference to *initialdata* will "
"not be kept, allowing it to be used for other purposes."
msgstr ""
"Classe que simula um dicionário. O conteúdo da instância é mantido num "
"dicionário regular, que é acessível através do atributo :attr:`data` das "
"instâncias :class:`UserDict`. Se *initialdata* for fornecido, :attr:`data` é "
"inicializado com o seu conteúdo; note que uma referência a *initialdata* não "
"será mantida, permitindo que seja usado para outros fins."

#: ../../library/collections.rst:1326
msgid ""
"In addition to supporting the methods and operations of mappings, :class:"
"`UserDict` instances provide the following attribute:"
msgstr ""
"Além de suportar os métodos e operações de mapeamentos, as instâncias :class:"
"`UserDict` fornecem o seguinte atributo:"

#: ../../library/collections.rst:1331
msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` class."
msgstr ""
"Um dicionário real usado para armazenar os conteúdos da classe :class:"
"`UserDict`."

#: ../../library/collections.rst:1337
msgid ":class:`UserList` objects"
msgstr "Objetos :class:`UserList`"

#: ../../library/collections.rst:1339
msgid ""
"This class acts as a wrapper around list objects.  It is a useful base class "
"for your own list-like classes which can inherit from them and override "
"existing methods or add new ones.  In this way, one can add new behaviors to "
"lists."
msgstr ""
"Esta classe atua como um invólucro em torno de objetos de lista. É uma "
"classe base útil para as suas próprias classes semelhantes a listas, que "
"podem herdar delas e substituir métodos existentes ou adicionar novos. Desta "
"forma, pode-se adicionar novos comportamentos a listas."

#: ../../library/collections.rst:1344
msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier to "
"work with because the underlying list is accessible as an attribute."
msgstr ""
"A necessidade desta classe foi parcialmente substituída pela capacidade de "
"criar subclasses diretamente de :class:`list`; no entanto, esta classe pode "
"ser mais fácil de trabalhar porque a lista subjacente é acessível como um "
"atributo."

#: ../../library/collections.rst:1350
msgid ""
"Class that simulates a list.  The instance's contents are kept in a regular "
"list, which is accessible via the :attr:`data` attribute of :class:"
"`UserList` instances.  The instance's contents are initially set to a copy "
"of *list*, defaulting to the empty list ``[]``.  *list* can be any iterable, "
"for example a real Python list or a :class:`UserList` object."
msgstr ""
"Classe que simula uma lista. O conteúdo da instância é mantido numa lista "
"regular, que é acessível através do atributo :attr:`data` das instâncias :"
"class:`UserList`. O conteúdo da instância é inicialmente definido como uma "
"cópia de *list*, predefinindo para a lista vazia ``[]``. *list* pode ser "
"qualquer iterável, por exemplo uma lista Python real ou um objeto :class:"
"`UserList`."

#: ../../library/collections.rst:1356
msgid ""
"In addition to supporting the methods and operations of mutable sequences, :"
"class:`UserList` instances provide the following attribute:"
msgstr ""
"Além de suportar os métodos e operações de sequências mutáveis, as "
"instâncias :class:`UserList` fornecem o seguinte atributo:"

#: ../../library/collections.rst:1361
msgid ""
"A real :class:`list` object used to store the contents of the :class:"
"`UserList` class."
msgstr ""
"Um objeto :class:`list` real usado para armazenar os conteúdos da classe :"
"class:`UserList`."

#: ../../library/collections.rst:1364
msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are expected "
"to offer a constructor which can be called with either no arguments or one "
"argument.  List operations which return a new sequence attempt to create an "
"instance of the actual implementation class.  To do so, it assumes that the "
"constructor can be called with a single parameter, which is a sequence "
"object used as a data source."
msgstr ""
"**Requisitos de subclassificação:** Espera-se que as subclasses de :class:"
"`UserList` ofereçam um construtor que possa ser chamado sem argumentos ou "
"com um argumento. As operações de lista que devolvem uma nova sequência "
"tentam criar uma instância da classe de implementação real. Para tal, assume "
"que o construtor pode ser chamado com um único parâmetro, que é um objeto de "
"sequência usado como fonte de dados."

#: ../../library/collections.rst:1371
msgid ""
"If a derived class does not wish to comply with this requirement, all of the "
"special methods supported by this class will need to be overridden; please "
"consult the sources for information about the methods which need to be "
"provided in that case."
msgstr ""
"Se uma classe derivada não desejar cumprir este requisito, todos os métodos "
"especiais suportados por esta classe terão de ser substituídos; consulte as "
"fontes para obter informações sobre os métodos que precisam de ser "
"fornecidos nesse caso."

#: ../../library/collections.rst:1377
msgid ":class:`UserString` objects"
msgstr "Objetos :class:`UserString`"

#: ../../library/collections.rst:1379
msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. The "
"need for this class has been partially supplanted by the ability to subclass "
"directly from :class:`str`; however, this class can be easier to work with "
"because the underlying string is accessible as an attribute."
msgstr ""
"A classe :class:`UserString` atua como um invólucro em torno de objetos de "
"string. A necessidade desta classe foi parcialmente substituída pela "
"capacidade de criar subclasses diretamente de :class:`str`; no entanto, esta "
"classe pode ser mais fácil de trabalhar porque a string subjacente é "
"acessível como um atributo."

#: ../../library/collections.rst:1387
msgid ""
"Class that simulates a string object.  The instance's content is kept in a "
"regular string object, which is accessible via the :attr:`data` attribute "
"of :class:`UserString` instances.  The instance's contents are initially set "
"to a copy of *seq*.  The *seq* argument can be any object which can be "
"converted into a string using the built-in :func:`str` function."
msgstr ""
"Classe que simula um objeto de string. O conteúdo da instância é mantido num "
"objeto de string regular, que é acessível através do atributo :attr:`data` "
"das instâncias :class:`UserString`. O conteúdo da instância é inicialmente "
"definido como uma cópia de *seq*. O argumento *seq* pode ser qualquer objeto "
"que possa ser convertido numa string usando a função integrada :func:`str`."

#: ../../library/collections.rst:1394
msgid ""
"In addition to supporting the methods and operations of strings, :class:"
"`UserString` instances provide the following attribute:"
msgstr ""
"Além de suportar os métodos e operações de strings, as instâncias :class:"
"`UserString` fornecem o seguinte atributo:"

#: ../../library/collections.rst:1399
msgid ""
"A real :class:`str` object used to store the contents of the :class:"
"`UserString` class."
msgstr ""
"Um objeto :class:`str` real usado para armazenar os conteúdos da classe :"
"class:`UserString`."

#: ../../library/collections.rst:1402
msgid ""
"New methods ``__getnewargs__``, ``__rmod__``, ``casefold``, ``format_map``, "
"``isprintable``, and ``maketrans``."
msgstr ""
"Novos métodos ``__getnewargs__``, ``__rmod__``, ``casefold``, "
"``format_map``, ``isprintable`` e ``maketrans``."
