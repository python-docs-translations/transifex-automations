# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-19 15:26+0000\n"
"PO-Revision-Date: 2025-09-15 01:04+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/decimal.rst:2
msgid ":mod:`!decimal` --- Decimal fixed-point and floating-point arithmetic"
msgstr ""
":mod:`!decimal` — Aritmética decimal de ponto fixo e de vírgula flutuante"

#: ../../library/decimal.rst:15
msgid "**Source code:** :source:`Lib/decimal.py`"
msgstr "**Código-fonte:** :source:`Lib/decimal.py`"

#: ../../library/decimal.rst:33
msgid ""
"The :mod:`decimal` module provides support for fast correctly rounded "
"decimal floating-point arithmetic. It offers several advantages over the :"
"class:`float` datatype:"
msgstr ""
"O módulo :mod:`decimal` fornece suporte para aritmética decimal de vírgula "
"flutuante rápida e corretamente arredondada. Oferece várias vantagens em "
"relação ao tipo de dados :class:`float`:"

#: ../../library/decimal.rst:37
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"A aritmética decimal \"é baseada num modelo de vírgula flutuante que foi "
"concebido tendo as pessoas em mente, e tem necessariamente um princípio "
"orientador primordial — os computadores devem fornecer uma aritmética que "
"funcione da mesma forma que a aritmética que as pessoas aprendem na escola."
"\" — excerto da especificação da aritmética decimal."

#: ../../library/decimal.rst:42
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like "
"``1.1`` and ``2.2`` do not have exact representations in binary floating "
"point. End users typically would not expect ``1.1 + 2.2`` to display as "
"``3.3000000000000003`` as it does with binary floating point."
msgstr ""
"Os números decimais podem ser representados exatamente. Em contraste, "
"números como ``1.1`` e ``2.2`` não têm representações exatas em vírgula "
"flutuante binária. Os utilizadores finais tipicamente não esperariam que "
"``1.1 + 2.2`` fosse apresentado como ``3.3000000000000003`` como acontece "
"com a vírgula flutuante binária."

#: ../../library/decimal.rst:47
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is ``5.5511151231257827e-017``.  While near to zero, the "
"differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""
"A exatidão estende-se à aritmética. Em vírgula flutuante decimal, ``0.1 + "
"0.1 + 0.1 - 0.3`` é exatamente igual a zero. Em vírgula flutuante binária, o "
"resultado é ``5.5511151231257827e-017``. Embora próximo de zero, as "
"diferenças impedem testes de igualdade fiáveis e as diferenças podem "
"acumular-se. Por esta razão, o decimal é preferido em aplicações de "
"contabilidade que têm invariantes de igualdade estritos."

#: ../../library/decimal.rst:54
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is ``2.50``.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives ``1.56`` while ``1.30 * "
"1.20`` gives ``1.5600``."
msgstr ""
"O módulo decimal incorpora uma noção de casas significativas, de modo que "
"``1.30 + 1.20`` é ``2.50``. O zero à direita é mantido para indicar "
"significância. Esta é a apresentação habitual para aplicações monetárias. "
"Para a multiplicação, a abordagem \"escolar\" usa todas as figuras nos "
"multiplicandos. Por exemplo, ``1.3 * 1.2`` dá ``1.56`` enquanto ``1.30 * "
"1.20`` dá ``1.5600``."

#: ../../library/decimal.rst:61
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""
"Ao contrário da vírgula flutuante binária baseada em hardware, o módulo "
"decimal tem uma precisão alterável pelo utilizador (predefinida para 28 "
"casas) que pode ser tão grande quanto necessário para um dado problema:"

#: ../../library/decimal.rst:73
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""
"Tanto a vírgula flutuante binária como a decimal são implementadas em termos "
"de padrões publicados. Embora o tipo float integrado exponha apenas uma "
"parte modesta das suas capacidades, o módulo decimal expõe todas as partes "
"necessárias do padrão. Quando necessário, o programador tem controle total "
"sobre o arredondamento e o tratamento de sinais. Isto inclui uma opção para "
"impor aritmética exata usando exceções para bloquear quaisquer operações "
"inexatas."

#: ../../library/decimal.rst:80
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""
"O módulo decimal foi concebido para suportar \"sem prejuízo, tanto a "
"aritmética decimal exata não arredondada (por vezes chamada aritmética de "
"ponto fixo) como a aritmética de vírgula flutuante arredondada.\" — excerto "
"da especificação da aritmética decimal."

#: ../../library/decimal.rst:85
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""
"O design do módulo está centrado em três conceitos: o número decimal, o "
"contexto para aritmética e os sinais."

#: ../../library/decimal.rst:88
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as ``Infinity``, "
"``-Infinity``, and ``NaN``.  The standard also differentiates ``-0`` from "
"``+0``."
msgstr ""
"Um número decimal é imutável. Tem um sinal, dígitos de coeficiente e um "
"expoente. Para preservar a significância, os dígitos do coeficiente não "
"truncam zeros à direita. Os decimais também incluem valores especiais como "
"``Infinity``, ``-Infinity`` e ``NaN``. O padrão também diferencia ``-0`` de "
"``+0``."

#: ../../library/decimal.rst:94
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""
"O contexto para aritmética é um ambiente que especifica precisão, regras de "
"arredondamento, limites nos expoentes, flags que indicam os resultados das "
"operações e ativadores de armadilhas que determinam se os sinais são "
"tratados como exceções. As opções de arredondamento incluem :const:"
"`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:`ROUND_FLOOR`, :const:"
"`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:`ROUND_HALF_UP`, :const:"
"`ROUND_UP` e :const:`ROUND_05UP`."

#: ../../library/decimal.rst:101
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, :const:`Underflow` and :const:"
"`FloatOperation`."
msgstr ""
"Os sinais são grupos de condições excecionais que surgem durante o curso da "
"computação. Dependendo das necessidades da aplicação, os sinais podem ser "
"ignorados, considerados informativos ou tratados como exceções. Os sinais no "
"módulo decimal são: :const:`Clamped`, :const:`InvalidOperation`, :const:"
"`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:`Subnormal`, :"
"const:`Overflow`, :const:`Underflow` e :const:`FloatOperation`."

#: ../../library/decimal.rst:108
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""
"Para cada sinal, existe uma flag e um ativador de armadilha. Quando um sinal "
"é encontrado, a sua flag é definida para um, depois, se o ativador de "
"armadilha for definido para um, uma exceção é levantada. As flags são "
"persistentes, por isso o utilizador precisa de as redefinir antes de "
"monitorizar um cálculo."

#: ../../library/decimal.rst:116
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."
msgstr ""
"Especificação de Aritmética Decimal Geral da IBM, `The General Decimal "
"Arithmetic Specification <https://speleotrove.com/decimal/decarith.html>`_."

#: ../../library/decimal.rst:125
msgid "Quick-start tutorial"
msgstr "Tutorial de início rápido"

#: ../../library/decimal.rst:127
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""
"O início habitual para usar decimais é importar o módulo, visualizar o "
"contexto atual com :func:`getcontext` e, se necessário, definir novos "
"valores para precisão, arredondamento ou armadilhas ativadas::"

#: ../../library/decimal.rst:131
msgid ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # Set a new precision"
msgstr ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # Definir uma nova precisão"

#: ../../library/decimal.rst:139
msgid ""
"Decimal instances can be constructed from integers, strings, floats, or "
"tuples. Construction from an integer or a float performs an exact conversion "
"of the value of that integer or float.  Decimal numbers include special "
"values such as ``NaN`` which stands for \"Not a number\", positive and "
"negative ``Infinity``, and ``-0``::"
msgstr ""
"Instâncias decimais podem ser construídas a partir de inteiros, strings, "
"floats ou tuplos. A construção a partir de um inteiro ou float realiza uma "
"conversão exata do valor desse inteiro ou float. Os números decimais incluem "
"valores especiais como ``NaN`` que significa \"Não é um número\", "
"``Infinity`` positivo e negativo e ``-0``::"

#: ../../library/decimal.rst:145
msgid ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3.14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2.0 ** 0.5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"
msgstr ""
">>> getcontext().prec = 28\n"
">>> Decimal(10)\n"
"Decimal('10')\n"
">>> Decimal('3.14')\n"
"Decimal('3.14')\n"
">>> Decimal(3.14)\n"
"Decimal('3.140000000000000124344978758017532527446746826171875')\n"
">>> Decimal((0, (3, 1, 4), -2))\n"
"Decimal('3.14')\n"
">>> Decimal(str(2.0 ** 0.5))\n"
"Decimal('1.4142135623730951')\n"
">>> Decimal(2) ** Decimal('0.5')\n"
"Decimal('1.414213562373095048801688724')\n"
">>> Decimal('NaN')\n"
"Decimal('NaN')\n"
">>> Decimal('-Infinity')\n"
"Decimal('-Infinity')"

#: ../../library/decimal.rst:163
msgid ""
"If the :exc:`FloatOperation` signal is trapped, accidental mixing of "
"decimals and floats in constructors or ordering comparisons raises an "
"exception::"
msgstr ""
"Se o sinal :exc:`FloatOperation` for capturado, a mistura acidental de "
"decimais e floats em construtores ou comparações de ordenação levanta uma "
"exceção::"

#: ../../library/decimal.rst:167
msgid ""
">>> c = getcontext()\n"
">>> c.traps[FloatOperation] = True\n"
">>> Decimal(3.14)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') < 3.7\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') == 3.5\n"
"True"
msgstr ""
">>> c = getcontext()\n"
">>> c.traps[FloatOperation] = True\n"
">>> Decimal(3.14)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') < 3.7\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.FloatOperation: [<class 'decimal.FloatOperation'>]\n"
">>> Decimal('3.5') == 3.5\n"
"True"

#: ../../library/decimal.rst:182
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""
"A significância de um novo Decimal é determinada unicamente pelo número de "
"dígitos introduzidos. A precisão e o arredondamento do contexto só entram em "
"jogo durante operações aritméticas."

#: ../../library/decimal.rst:186
msgid ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"
msgstr ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"

#: ../../library/decimal.rst:199
msgid ""
"If the internal limits of the C version are exceeded, constructing a decimal "
"raises :class:`InvalidOperation`::"
msgstr ""
"Se os limites internos da versão C forem excedidos, a construção de um "
"decimal levanta :class:`InvalidOperation`::"

#: ../../library/decimal.rst:202
msgid ""
">>> Decimal(\"1e9999999999999999999\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"
msgstr ""
">>> Decimal(\"1e9999999999999999999\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]"

#: ../../library/decimal.rst:209
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating-point flying circus:"
msgstr ""
"Os decimais interagem bem com grande parte do resto do Python. Aqui está um "
"pequeno circo voador de vírgula flutuante decimal:"

#: ../../library/decimal.rst:212
msgid ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> round(a, 1)\n"
"Decimal('1.3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"
msgstr ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.34\n"
">>> round(a, 1)\n"
"Decimal('1.3')\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"

#: ../../library/decimal.rst:241
msgid "And some mathematical functions are also available to Decimal:"
msgstr "E algumas funções matemáticas também estão disponíveis para Decimal:"

#: ../../library/decimal.rst:253
msgid ""
"The :meth:`~Decimal.quantize` method rounds a number to a fixed exponent.  "
"This method is useful for monetary applications that often round results to "
"a fixed number of places:"
msgstr ""
"O método :meth:`~Decimal.quantize` arredonda um número para um expoente "
"fixo. Este método é útil para aplicações monetárias que frequentemente "
"arredondam resultados para um número fixo de casas decimais:"

#: ../../library/decimal.rst:262
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""
"Como mostrado acima, a função :func:`getcontext` acede ao contexto atual e "
"permite que as definições sejam alteradas. Esta abordagem satisfaz as "
"necessidades da maioria das aplicações."

#: ../../library/decimal.rst:266
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the :meth:`Context` constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""

#: ../../library/decimal.rst:270
msgid ""
"In accordance with the standard, the :mod:`decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""
"De acordo com o padrão, o módulo :mod:`decimal` fornece dois contextos "
"padrão prontos a usar, :const:`BasicContext` e :const:`ExtendedContext`. O "
"primeiro é especialmente útil para depuração porque muitas das armadilhas "
"estão ativadas:"

#: ../../library/decimal.rst:275
msgid ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"

#: ../../library/decimal.rst:299
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`~Context.clear_flags` method. ::"
msgstr ""
"Os contextos também têm flags de sinal para monitorizar condições "
"excecionais encontradas durante os cálculos. As flags permanecem definidas "
"até serem explicitamente limpas, por isso é melhor limpar as flags antes de "
"cada conjunto de cálculos monitorizados usando o método :meth:`~Context."
"clear_flags`. ::"

#: ../../library/decimal.rst:304
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])"
msgstr ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n"
"        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])"

#: ../../library/decimal.rst:312
msgid ""
"The *flags* entry shows that the rational approximation to pi was rounded "
"(digits beyond the context precision were thrown away) and that the result "
"is inexact (some of the discarded digits were non-zero)."
msgstr ""
"A entrada *flags* mostra que a aproximação racional de pi foi arredondada "
"(dígitos além da precisão do contexto foram descartados) e que o resultado é "
"inexato (alguns dos dígitos descartados eram não-zero)."

#: ../../library/decimal.rst:316
msgid ""
"Individual traps are set using the dictionary in the :attr:`~Context.traps` "
"attribute of a context:"
msgstr ""
"As armadilhas individuais são definidas usando o dicionário no atributo :"
"attr:`~Context.traps` de um contexto:"

#: ../../library/decimal.rst:319
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"

#: ../../library/decimal.rst:331
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""
"A maioria dos programas ajusta o contexto atual apenas uma vez, no início do "
"programa. E, em muitas aplicações, os dados são convertidos para :class:"
"`Decimal` com um único cast dentro de um ciclo. Com o contexto definido e os "
"decimais criados, a maior parte do programa manipula os dados de forma não "
"diferente de outros tipos numéricos do Python."

#: ../../library/decimal.rst:343
msgid "Decimal objects"
msgstr "Objetos Decimal"

#: ../../library/decimal.rst:348
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr "Constrói um novo objeto :class:`Decimal` com base em *value*."

#: ../../library/decimal.rst:350
msgid ""
"*value* can be an integer, string, tuple, :class:`float`, or another :class:"
"`Decimal` object. If no *value* is given, returns ``Decimal('0')``.  If "
"*value* is a string, it should conform to the decimal numeric string syntax "
"after leading and trailing whitespace characters, as well as underscores "
"throughout, are removed::"
msgstr ""
"*value* pode ser um inteiro, string, tuplo, :class:`float` ou outro objeto :"
"class:`Decimal`. Se nenhum *value* for dado, retorna ``Decimal('0')``. Se "
"*value* for uma string, deve estar conforme a sintaxe de string numérica "
"decimal após a remoção de caracteres de espaço em branco à esquerda e à "
"direita, bem como sublinhados em todo o lado::"

#: ../../library/decimal.rst:355
msgid ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | "
"'9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"
msgstr ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | "
"'9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"

#: ../../library/decimal.rst:366
msgid ""
"Other Unicode decimal digits are also permitted where ``digit`` appears "
"above.  These include decimal digits from various other alphabets (for "
"example, Arabic-Indic and Devanāgarī digits) along with the fullwidth digits "
"``'\\uff10'`` through ``'\\uff19'``. Case is not significant, so, for "
"example, ``inf``, ``Inf``, ``INFINITY``, and ``iNfINity`` are all acceptable "
"spellings for positive infinity."
msgstr ""
"Outros dígitos decimais Unicode também são permitidos onde ``digit`` aparece "
"acima. Estes incluem dígitos decimais de vários outros alfabetos (por "
"exemplo, dígitos Árabe-Indic e Devanāgarī) juntamente com os dígitos de "
"largura total ``'\\uff10'`` a ``'\\uff19'``. A caixa não é significativa, "
"por isso, por exemplo, ``inf``, ``Inf``, ``INFINITY`` e ``iNfINity`` são "
"todas grafias aceitáveis para infinito positivo."

#: ../../library/decimal.rst:373
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign "
"(``0`` for positive or ``1`` for negative), a :class:`tuple` of digits, and "
"an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), -3))`` returns "
"``Decimal('1.414')``."
msgstr ""
"Se *value* for um :class:`tuple`, deve ter três componentes, um sinal (``0`` "
"para positivo ou ``1`` para negativo), um :class:`tuple` de dígitos e um "
"expoente inteiro. Por exemplo, ``Decimal((0, (1, 4, 1, 4), -3))`` retorna "
"``Decimal('1.414')``."

#: ../../library/decimal.rst:378
msgid ""
"If *value* is a :class:`float`, the binary floating-point value is "
"losslessly converted to its exact decimal equivalent.  This conversion can "
"often require 53 or more digits of precision.  For example, "
"``Decimal(float('1.1'))`` converts to "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."
msgstr ""
"Se *value* for um :class:`float`, o valor de vírgula flutuante binária é "
"convertido sem perda para o seu equivalente decimal exato. Esta conversão "
"pode frequentemente requerer 53 ou mais dígitos de precisão. Por exemplo, "
"``Decimal(float('1.1'))`` converte para "
"``Decimal('1.100000000000000088817841970012523233890533447265625')``."

#: ../../library/decimal.rst:384
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""
"A precisão do *context* não afeta quantos dígitos são armazenados. Isso é "
"determinado exclusivamente pelo número de dígitos em *value*. Por exemplo, "
"``Decimal('3.00000')`` regista todos os cinco zeros mesmo que a precisão do "
"contexto seja apenas três."

#: ../../library/decimal.rst:389
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of ``NaN``."
msgstr ""
"O propósito do argumento *context* é determinar o que fazer se *value* for "
"uma string malformada. Se o contexto capturar :const:`InvalidOperation`, uma "
"exceção é levantada; caso contrário, o construtor retorna um novo Decimal "
"com o valor de ``NaN``."

#: ../../library/decimal.rst:394
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr "Uma vez construídos, os objetos :class:`Decimal` são imutáveis."

#: ../../library/decimal.rst:396
msgid ""
"The argument to the constructor is now permitted to be a :class:`float` "
"instance."
msgstr ""
"O argumento para o construtor agora pode ser uma instância :class:`float`."

#: ../../library/decimal.rst:400
msgid ""
":class:`float` arguments raise an exception if the :exc:`FloatOperation` "
"trap is set. By default the trap is off."
msgstr ""
"Os argumentos :class:`float` levantam uma exceção se a armadilha :exc:"
"`FloatOperation` estiver definida. Por predefinição, a armadilha está "
"desativada."

#: ../../library/decimal.rst:404
msgid ""
"Underscores are allowed for grouping, as with integral and floating-point "
"literals in code."
msgstr ""
"Os sublinhados são permitidos para agrupamento, como com literais inteiros e "
"de vírgula flutuante no código."

#: ../../library/decimal.rst:408
msgid ""
"Decimal floating-point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`int`)."
msgstr ""
"Os objetos de vírgula flutuante decimal partilham muitas propriedades com os "
"outros tipos numéricos integrados, como :class:`float` e :class:`int`. Todas "
"as operações matemáticas habituais e métodos especiais aplicam-se. Da mesma "
"forma, os objetos decimais podem ser copiados, serializados, impressos, "
"usados como chaves de dicionário, usados como elementos de conjunto, "
"comparados, ordenados e convertidos para outro tipo (como :class:`float` ou :"
"class:`int`)."

#: ../../library/decimal.rst:415
msgid ""
"There are some small differences between arithmetic on Decimal objects and "
"arithmetic on integers and floats.  When the remainder operator ``%`` is "
"applied to Decimal objects, the sign of the result is the sign of the "
"*dividend* rather than the sign of the divisor::"
msgstr ""
"Existem algumas pequenas diferenças entre a aritmética em objetos Decimal e "
"a aritmética em inteiros e floats. Quando o operador de resto ``%`` é "
"aplicado a objetos Decimal, o sinal do resultado é o sinal do *dividendo* em "
"vez do sinal do divisor::"

#: ../../library/decimal.rst:420
msgid ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"
msgstr ""
">>> (-7) % 4\n"
"1\n"
">>> Decimal(-7) % Decimal(4)\n"
"Decimal('-3')"

#: ../../library/decimal.rst:425
msgid ""
"The integer division operator ``//`` behaves analogously, returning the "
"integer part of the true quotient (truncating towards zero) rather than its "
"floor, so as to preserve the usual identity ``x == (x // y) * y + x % y``::"
msgstr ""
"O operador de divisão inteira ``//`` comporta-se de forma análoga, "
"retornando a parte inteira do quociente verdadeiro (truncando para zero) em "
"vez do seu piso, de modo a preservar a identidade habitual ``x == (x // y) * "
"y + x % y``::"

#: ../../library/decimal.rst:429
msgid ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"
msgstr ""
">>> -7 // 4\n"
"-2\n"
">>> Decimal(-7) // Decimal(4)\n"
"Decimal('-1')"

#: ../../library/decimal.rst:434
msgid ""
"The ``%`` and ``//`` operators implement the ``remainder`` and ``divide-"
"integer`` operations (respectively) as described in the specification."
msgstr ""
"Os operadores ``%`` e ``//`` implementam as operações ``remainder`` e "
"``divide-integer`` (respetivamente) como descrito na especificação."

#: ../../library/decimal.rst:438
msgid ""
"Decimal objects cannot generally be combined with floats or instances of :"
"class:`fractions.Fraction` in arithmetic operations: an attempt to add a :"
"class:`Decimal` to a :class:`float`, for example, will raise a :exc:"
"`TypeError`.  However, it is possible to use Python's comparison operators "
"to compare a :class:`Decimal` instance ``x`` with another number ``y``.  "
"This avoids confusing results when doing equality comparisons between "
"numbers of different types."
msgstr ""
"Os objetos Decimal geralmente não podem ser combinados com floats ou "
"instâncias de :class:`fractions.Fraction` em operações aritméticas: uma "
"tentativa de adicionar um :class:`Decimal` a um :class:`float`, por exemplo, "
"levantará um :exc:`TypeError`. No entanto, é possível usar os operadores de "
"comparação do Python para comparar uma instância :class:`Decimal` ``x`` com "
"outro número ``y``. Isto evita resultados confusos ao fazer comparações de "
"igualdade entre números de tipos diferentes."

#: ../../library/decimal.rst:446
msgid ""
"Mixed-type comparisons between :class:`Decimal` instances and other numeric "
"types are now fully supported."
msgstr ""
"As comparações de tipo misto entre instâncias :class:`Decimal` e outros "
"tipos numéricos são agora totalmente suportadas."

#: ../../library/decimal.rst:450
msgid ""
"In addition to the standard numeric properties, decimal floating-point "
"objects also have a number of specialized methods:"
msgstr ""
"Além das propriedades numéricas padrão, os objetos de vírgula flutuante "
"decimal também têm vários métodos especializados:"

#: ../../library/decimal.rst:456
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""
"Retorna o expoente ajustado após deslocar os dígitos mais à direita do "
"coeficiente até que apenas o dígito principal permaneça: ``Decimal('321e+5')."
"adjusted()`` retorna sete. Usado para determinar a posição do dígito mais "
"significativo em relação ao ponto decimal."

#: ../../library/decimal.rst:463
msgid ""
"Return a pair ``(n, d)`` of integers that represent the given :class:"
"`Decimal` instance as a fraction, in lowest terms and with a positive "
"denominator::"
msgstr ""
"Retorna um par ``(n, d)`` de inteiros que representam a instância :class:"
"`Decimal` dada como uma fração, nos termos mais baixos e com um denominador "
"positivo::"

#: ../../library/decimal.rst:467
msgid ""
">>> Decimal('-3.14').as_integer_ratio()\n"
"(-157, 50)"
msgstr ""
">>> Decimal('-3.14').as_integer_ratio()\n"
"(-157, 50)"

#: ../../library/decimal.rst:470
msgid ""
"The conversion is exact.  Raise OverflowError on infinities and ValueError "
"on NaNs."
msgstr ""
"A conversão é exata. Levanta OverflowError em infinitos e ValueError em NaNs."

#: ../../library/decimal.rst:477
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""
"Retorna uma representação de :term:`named tuple` do número: "
"``DecimalTuple(sign, digits, exponent)``."

#: ../../library/decimal.rst:483
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""
"Retorna a codificação canónica do argumento. Atualmente, a codificação de "
"uma instância :class:`Decimal` é sempre canónica, por isso esta operação "
"retorna o seu argumento inalterado."

#: ../../library/decimal.rst:489
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""
"Compara os valores de duas instâncias Decimal. :meth:`compare` retorna uma "
"instância Decimal, e se algum dos operandos for um NaN, então o resultado é "
"um NaN::"

#: ../../library/decimal.rst:493
msgid ""
"a or b is a NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"
msgstr ""
"a ou b é um NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"

#: ../../library/decimal.rst:500
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""
"Esta operação é idêntica ao método :meth:`compare`, exceto que todos os NaNs "
"sinalizam. Ou seja, se nenhum dos operandos for um NaN de sinalização, então "
"qualquer operando NaN silencioso é tratado como se fosse um NaN de "
"sinalização."

#: ../../library/decimal.rst:506
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""
"Compara dois operandos usando a sua representação abstrata em vez do seu "
"valor numérico. Semelhante ao método :meth:`compare`, mas o resultado dá uma "
"ordenação total em instâncias :class:`Decimal`. Duas instâncias :class:"
"`Decimal` com o mesmo valor numérico, mas representações diferentes, "
"comparam-se como desiguais nesta ordenação:"

#: ../../library/decimal.rst:515
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""
"NaNs silenciosos e de sinalização também estão incluídos na ordenação total. "
"O resultado desta função é ``Decimal('0')`` se ambos os operandos tiverem a "
"mesma representação, ``Decimal('-1')`` se o primeiro operando for inferior "
"na ordem total do que o segundo, e ``Decimal('1')`` se o primeiro operando "
"for superior na ordem total do que o segundo operando. Consulte a "
"especificação para detalhes da ordem total."

#: ../../library/decimal.rst:522 ../../library/decimal.rst:533
#: ../../library/decimal.rst:561 ../../library/decimal.rst:848
msgid ""
"This operation is unaffected by context and is quiet: no flags are changed "
"and no rounding is performed.  As an exception, the C version may raise "
"InvalidOperation if the second operand cannot be converted exactly."
msgstr ""
"Esta operação não é afetada pelo contexto e é silenciosa: nenhuma flag é "
"alterada e nenhum arredondamento é realizado. Como exceção, a versão C pode "
"levantar InvalidOperation se o segundo operando não puder ser convertido "
"exatamente."

#: ../../library/decimal.rst:528
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""
"Compara dois operandos usando a sua representação abstrata em vez do seu "
"valor como em :meth:`compare_total`, mas ignorando o sinal de cada operando. "
"``x.compare_total_mag(y)`` é equivalente a ``x.copy_abs().compare_total(y."
"copy_abs())``."

#: ../../library/decimal.rst:539
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""
"Apenas retorna self, este método existe apenas para cumprir a Especificação "
"Decimal."

#: ../../library/decimal.rst:544
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Retorna o valor absoluto do argumento. Esta operação não é afetada pelo "
"contexto e é silenciosa: nenhuma flag é alterada e nenhum arredondamento é "
"realizado."

#: ../../library/decimal.rst:550
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""
"Retorna a negação do argumento. Esta operação não é afetada pelo contexto e "
"é silenciosa: nenhuma flag é alterada e nenhum arredondamento é realizado."

#: ../../library/decimal.rst:555
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""
"Retorna uma cópia do primeiro operando com o sinal definido para ser o mesmo "
"que o sinal do segundo operando. Por exemplo:"

#: ../../library/decimal.rst:567
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""
"Retorna o valor da função exponencial (natural) ``e**x`` no número dado. O "
"resultado é corretamente arredondado usando o modo de arredondamento :const:"
"`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:578
msgid ""
"Alternative constructor that only accepts instances of :class:`float` or :"
"class:`int`."
msgstr ""
"Construtor alternativo que aceita apenas instâncias de :class:`float` ou :"
"class:`int`."

#: ../../library/decimal.rst:581
msgid ""
"Note ``Decimal.from_float(0.1)`` is not the same as ``Decimal('0.1')``. "
"Since 0.1 is not exactly representable in binary floating point, the value "
"is stored as the nearest representable value which is "
"``0x1.999999999999ap-4``.  That equivalent value in decimal is "
"``0.1000000000000000055511151231257827021181583404541015625``."
msgstr ""
"Note que ``Decimal.from_float(0.1)`` não é o mesmo que ``Decimal('0.1')``. "
"Uma vez que 0.1 não é exatamente representável em vírgula flutuante binária, "
"o valor é armazenado como o valor representável mais próximo que é "
"``0x1.999999999999ap-4``. Esse valor equivalente em decimal é "
"``0.1000000000000000055511151231257827021181583404541015625``."

#: ../../library/decimal.rst:587
msgid ""
"From Python 3.2 onwards, a :class:`Decimal` instance can also be constructed "
"directly from a :class:`float`."
msgstr ""
"A partir do Python 3.2, uma instância :class:`Decimal` também pode ser "
"construída diretamente a partir de um :class:`float`."

#: ../../library/decimal.rst:590
msgid ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Infinity')"
msgstr ""
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
">>> Decimal.from_float(float('nan'))\n"
"Decimal('NaN')\n"
">>> Decimal.from_float(float('inf'))\n"
"Decimal('Infinity')\n"
">>> Decimal.from_float(float('-inf'))\n"
"Decimal('-Infinity')"

#: ../../library/decimal.rst:605
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""
"Multiplicação-soma fundida. Retorna self*other+third sem arredondamento do "
"produto intermédio self*other."

#: ../../library/decimal.rst:613
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""
"Retorna :const:`True` se o argumento for canónico e :const:`False` caso "
"contrário. Atualmente, uma instância :class:`Decimal` é sempre canónica, por "
"isso esta operação sempre retorna :const:`True`."

#: ../../library/decimal.rst:619
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""
"Retorna :const:`True` se o argumento for um número finito, e :const:`False` "
"se o argumento for um infinito ou um NaN."

#: ../../library/decimal.rst:624
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for infinito positivo ou negativo e :"
"const:`False` caso contrário."

#: ../../library/decimal.rst:629
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um NaN (silencioso ou de "
"sinalização) e :const:`False` caso contrário."

#: ../../library/decimal.rst:634
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""
"Retorna :const:`True` se o argumento for um número finito *normal*. Retorna :"
"const:`False` se o argumento for zero, subnormal, infinito ou um NaN."

#: ../../library/decimal.rst:639
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um NaN silencioso, e :const:`False` "
"caso contrário."

#: ../../library/decimal.rst:644
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""
"Retorna :const:`True` se o argumento tiver um sinal negativo e :const:"
"`False` caso contrário. Note que zeros e NaNs podem ambos ter sinais."

#: ../../library/decimal.rst:649
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um NaN de sinalização e :const:"
"`False` caso contrário."

#: ../../library/decimal.rst:654
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for subnormal, e :const:`False` caso "
"contrário."

#: ../../library/decimal.rst:659
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""
"Retorna :const:`True` se o argumento for um zero (positivo ou negativo) e :"
"const:`False` caso contrário."

#: ../../library/decimal.rst:664
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Retorna o logaritmo natural (base e) do operando. O resultado é corretamente "
"arredondado usando o modo de arredondamento :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:669
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""
"Retorna o logaritmo de base dez do operando. O resultado é corretamente "
"arredondado usando o modo de arredondamento :const:`ROUND_HALF_EVEN`."

#: ../../library/decimal.rst:674
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""
"Para um número não zero, retorna o expoente ajustado do seu operando como "
"uma instância :class:`Decimal`. Se o operando for um zero, então ``Decimal('-"
"Infinity')`` é retornado e a flag :const:`DivisionByZero` é levantada. Se o "
"operando for um infinito, então ``Decimal('Infinity')`` é retornado."

#: ../../library/decimal.rst:682
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""
":meth:`logical_and` é uma operação lógica que recebe dois *operandos "
"lógicos* (veja :ref:`logical_operands_label`). O resultado é o ``and`` "
"dígito a dígito dos dois operandos."

#: ../../library/decimal.rst:688
msgid ""
":meth:`logical_invert` is a logical operation.  The result is the digit-wise "
"inversion of the operand."
msgstr ""
":meth:`logical_invert` é uma operação lógica. O resultado é a inversão "
"dígito a dígito do operando."

#: ../../library/decimal.rst:693
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""
":meth:`logical_or` é uma operação lógica que recebe dois *operandos lógicos* "
"(veja :ref:`logical_operands_label`). O resultado é o ``or`` dígito a dígito "
"dos dois operandos."

#: ../../library/decimal.rst:699
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""
":meth:`logical_xor` é uma operação lógica que recebe dois *operandos "
"lógicos* (veja :ref:`logical_operands_label`). O resultado é o ou exclusivo "
"dígito a dígito dos dois operandos."

#: ../../library/decimal.rst:705
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Semelhante a ``max(self, other)`` exceto que a regra de arredondamento do "
"contexto é aplicada antes de retornar e que os valores ``NaN`` são "
"sinalizados ou ignorados (dependendo do contexto e se são de sinalização ou "
"silenciosos)."

#: ../../library/decimal.rst:712
msgid ""
"Similar to the :meth:`.max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Semelhante ao método :meth:`.max`, mas a comparação é feita usando os "
"valores absolutos dos operandos."

#: ../../library/decimal.rst:717
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that ``NaN`` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""
"Semelhante a ``min(self, other)`` exceto que a regra de arredondamento do "
"contexto é aplicada antes de retornar e que os valores ``NaN`` são "
"sinalizados ou ignorados (dependendo do contexto e se são de sinalização ou "
"silenciosos)."

#: ../../library/decimal.rst:724
msgid ""
"Similar to the :meth:`.min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""
"Semelhante ao método :meth:`.min`, mas a comparação é feita usando os "
"valores absolutos dos operandos."

#: ../../library/decimal.rst:729
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""
"Retorna o maior número representável no contexto dado (ou no contexto da "
"thread atual se nenhum contexto for dado) que é menor que o operando dado."

#: ../../library/decimal.rst:735
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""
"Retorna o menor número representável no contexto dado (ou no contexto da "
"thread atual se nenhum contexto for dado) que é maior que o operando dado."

#: ../../library/decimal.rst:741
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""
"Se os dois operandos forem desiguais, retorna o número mais próximo do "
"primeiro operando na direção do segundo operando. Se ambos os operandos "
"forem numericamete iguais, retorna uma cópia do primeiro operando com o "
"sinal definido para ser o mesmo que o sinal do segundo operando."

#: ../../library/decimal.rst:748
msgid ""
"Used for producing canonical values of an equivalence class within either "
"the current context or the specified context."
msgstr ""
"Usado para produzir valores canónicos de uma classe de equivalência dentro "
"do contexto atual ou do contexto especificado."

#: ../../library/decimal.rst:751
msgid ""
"This has the same semantics as the unary plus operation, except that if the "
"final result is finite it is reduced to its simplest form, with all trailing "
"zeros removed and its sign preserved. That is, while the coefficient is non-"
"zero and a multiple of ten the coefficient is divided by ten and the "
"exponent is incremented by 1. Otherwise (the coefficient is zero) the "
"exponent is set to 0. In all cases the sign is unchanged."
msgstr ""
"Isto tem a mesma semântica que a operação unária de mais, exceto que se o "
"resultado final for finito, é reduzido à sua forma mais simples, com todos "
"os zeros à direita removidos e o seu sinal preservado. Ou seja, enquanto o "
"coeficiente for não-zero e um múltiplo de dez, o coeficiente é dividido por "
"dez e o expoente é incrementado por 1. Caso contrário (o coeficiente é "
"zero), o expoente é definido para 0. Em todos os casos, o sinal permanece "
"inalterado."

#: ../../library/decimal.rst:758
msgid ""
"For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both "
"normalize to the equivalent value ``Decimal('32.1')``."
msgstr ""
"Por exemplo, ``Decimal('32.100')`` e ``Decimal('0.321000e+2')`` ambos "
"normalizam para o valor equivalente ``Decimal('32.1')``."

#: ../../library/decimal.rst:761
msgid "Note that rounding is applied *before* reducing to simplest form."
msgstr ""
"Note que o arredondamento é aplicado *antes* de reduzir para a forma mais "
"simples."

#: ../../library/decimal.rst:763
msgid ""
"In the latest versions of the specification, this operation is also known as "
"``reduce``."
msgstr ""
"Nas versões mais recentes da especificação, esta operação também é conhecida "
"como ``reduce``."

#: ../../library/decimal.rst:768
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""
"Retorna uma string que descreve a *classe* do operando. O valor retornado é "
"uma das seguintes dez strings."

#: ../../library/decimal.rst:771
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr "``\"-Infinity\"``, indicando que o operando é infinito negativo."

#: ../../library/decimal.rst:772
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr "``\"-Normal\"``, indicando que o operando é um número normal negativo."

#: ../../library/decimal.rst:773
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr "``\"-Subnormal\"``, indicando que o operando é negativo e subnormal."

#: ../../library/decimal.rst:774
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr "``\"-Zero\"``, indicando que o operando é um zero negativo."

#: ../../library/decimal.rst:775
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr "``\"+Zero\"``, indicando que o operando é um zero positivo."

#: ../../library/decimal.rst:776
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr "``\"+Subnormal\"``, indicando que o operando é positivo e subnormal."

#: ../../library/decimal.rst:777
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr "``\"+Normal\"``, indicando que o operando é um número normal positivo."

#: ../../library/decimal.rst:778
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr "``\"+Infinity\"``, indicando que o operando é infinito positivo."

#: ../../library/decimal.rst:779
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""
"``\"NaN\"``, indicando que o operando é um NaN silencioso (Não é um Número)."

#: ../../library/decimal.rst:780
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr "``\"sNaN\"``, indicando que o operando é um NaN de sinalização."

#: ../../library/decimal.rst:784
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""
"Retorna um valor igual ao primeiro operando após arredondamento e tendo o "
"expoente do segundo operando."

#: ../../library/decimal.rst:790
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""
"Ao contrário de outras operações, se o comprimento do coeficiente após a "
"operação de quantização for maior que a precisão, então um :const:"
"`InvalidOperation` é sinalizado. Isto garante que, a menos que haja uma "
"condição de erro, o expoente quantizado é sempre igual ao do operando do "
"lado direito."

#: ../../library/decimal.rst:796
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""
"Ao contrário de outras operações, quantize nunca sinaliza Underflow, mesmo "
"que o resultado seja subnormal e inexato."

#: ../../library/decimal.rst:799
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""
"Se o expoente do segundo operando for maior que o do primeiro, então o "
"arredondamento pode ser necessário. Neste caso, o modo de arredondamento é "
"determinado pelo argumento ``rounding``, se fornecido, caso contrário pelo "
"argumento ``context`` fornecido; se nenhum argumento for fornecido, o modo "
"de arredondamento do contexto da thread atual é usado."

#: ../../library/decimal.rst:805
msgid ""
"An error is returned whenever the resulting exponent is greater than :attr:"
"`~Context.Emax` or less than :meth:`~Context.Etiny`."
msgstr ""
"Um erro é retornado sempre que o expoente resultante for maior que :attr:"
"`~Context.Emax` ou menor que :meth:`~Context.Etiny`."

#: ../../library/decimal.rst:810
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""
"Retorna ``Decimal(10)``, a base (radix) na qual a classe :class:`Decimal` "
"faz toda a sua aritmética. Incluído para compatibilidade com a especificação."

#: ../../library/decimal.rst:816
msgid ""
"Return the remainder from dividing *self* by *other*.  This differs from "
"``self % other`` in that the sign of the remainder is chosen so as to "
"minimize its absolute value.  More precisely, the return value is ``self - n "
"* other`` where ``n`` is the integer nearest to the exact value of ``self / "
"other``, and if two integers are equally near then the even one is chosen."
msgstr ""
"Retorna o resto da divisão de *self* por *other*. Isto difere de ``self % "
"other`` no sentido em que o sinal do resto é escolhido de forma a minimizar "
"o seu valor absoluto. Mais precisamente, o valor de retorno é ``self - n * "
"other`` onde ``n`` é o inteiro mais próximo do valor exato de ``self / "
"other``, e se dois inteiros estiverem igualmente próximos, então o par é "
"escolhido."

#: ../../library/decimal.rst:823
msgid "If the result is zero then its sign will be the sign of *self*."
msgstr "Se o resultado for zero, então o seu sinal será o sinal de *self*."

#: ../../library/decimal.rst:834
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""
"Retorna o resultado da rotação dos dígitos do primeiro operando por uma "
"quantidade especificada pelo segundo operando. O segundo operando deve ser "
"um inteiro no intervalo -precisão até precisão. O valor absoluto do segundo "
"operando dá o número de posições a rotacionar. Se o segundo operando for "
"positivo, então a rotação é para a esquerda; caso contrário, a rotação é "
"para a direita. O coeficiente do primeiro operando é preenchido à esquerda "
"com zeros até ao comprimento da precisão, se necessário. O sinal e o "
"expoente do primeiro operando permanecem inalterados."

#: ../../library/decimal.rst:845
msgid ""
"Test whether self and other have the same exponent or whether both are "
"``NaN``."
msgstr "Testa se self e other têm o mesmo expoente ou se ambos são ``NaN``."

#: ../../library/decimal.rst:854
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""
"Retorna o primeiro operando com o expoente ajustado pelo segundo. "
"Equivalentemente, retorna o primeiro operando multiplicado por "
"``10**other``. O segundo operando deve ser um inteiro."

#: ../../library/decimal.rst:860
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""
"Retorna o resultado do deslocamento dos dígitos do primeiro operando por uma "
"quantidade especificada pelo segundo operando. O segundo operando deve ser "
"um inteiro no intervalo -precisão até precisão. O valor absoluto do segundo "
"operando dá o número de posições a deslocar. Se o segundo operando for "
"positivo, então o deslocamento é para a esquerda; caso contrário, o "
"deslocamento é para a direita. Os dígitos deslocados para o coeficiente são "
"zeros. O sinal e o expoente do primeiro operando permanecem inalterados."

#: ../../library/decimal.rst:870
msgid "Return the square root of the argument to full precision."
msgstr "Retorna a raiz quadrada do argumento com precisão total."

#: ../../library/decimal.rst:875 ../../library/decimal.rst:1524
msgid ""
"Convert to a string, using engineering notation if an exponent is needed."
msgstr ""
"Converte para uma string, usando notação de engenharia se um expoente for "
"necessário."

#: ../../library/decimal.rst:877 ../../library/decimal.rst:1526
msgid ""
"Engineering notation has an exponent which is a multiple of 3.  This can "
"leave up to 3 digits to the left of the decimal place and may require the "
"addition of either one or two trailing zeros."
msgstr ""
"A notação de engenharia tem um expoente que é um múltiplo de 3. Isto pode "
"deixar até 3 dígitos à esquerda do ponto decimal e pode requerer a adição de "
"um ou dois zeros à direita."

#: ../../library/decimal.rst:881
msgid ""
"For example, this converts ``Decimal('123E+1')`` to ``Decimal('1.23E+3')``."
msgstr ""
"Por exemplo, isto converte ``Decimal('123E+1')`` para ``Decimal('1.23E+3')``."

#: ../../library/decimal.rst:885
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""
"Idêntico ao método :meth:`to_integral_value`. O nome ``to_integral`` foi "
"mantido para compatibilidade com versões mais antigas."

#: ../../library/decimal.rst:890
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""
"Arredonda para o inteiro mais próximo, sinalizando :const:`Inexact` ou :"
"const:`Rounded` conforme apropriado se ocorrer arredondamento. O modo de "
"arredondamento é determinado pelo parâmetro ``rounding``, se fornecido, caso "
"contrário pelo ``context`` fornecido; se nenhum parâmetro for fornecido, "
"então o modo de arredondamento do contexto atual é usado."

#: ../../library/decimal.rst:898
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""
"Arredonda para o inteiro mais próximo sem sinalizar :const:`Inexact` ou :"
"const:`Rounded`. Se fornecido, aplica *rounding*; caso contrário, usa o "
"método de arredondamento no *context* fornecido ou no contexto atual."

#: ../../library/decimal.rst:902
msgid "Decimal numbers can be rounded using the :func:`.round` function:"
msgstr ""
"Os números decimais podem ser arredondados usando a função :func:`.round`:"

#: ../../library/decimal.rst:907
msgid ""
"If *ndigits* is not given or ``None``, returns the nearest :class:`int` to "
"*number*, rounding ties to even, and ignoring the rounding mode of the :"
"class:`Decimal` context.  Raises :exc:`OverflowError` if *number* is an "
"infinity or :exc:`ValueError` if it is a (quiet or signaling) NaN."
msgstr ""
"Se *ndigits* não for fornecido ou for ``None``, retorna o :class:`int` mais "
"próximo de *number*, arredondando empates para par, e ignorando o modo de "
"arredondamento do contexto :class:`Decimal`. Levanta :exc:`OverflowError` se "
"*number* for um infinito ou :exc:`ValueError` se for um NaN (silencioso ou "
"de sinalização)."

#: ../../library/decimal.rst:913
msgid ""
"If *ndigits* is an :class:`int`, the context's rounding mode is respected "
"and a :class:`Decimal` representing *number* rounded to the nearest multiple "
"of ``Decimal('1E-ndigits')`` is returned; in this case, ``round(number, "
"ndigits)`` is equivalent to ``self.quantize(Decimal('1E-ndigits'))``.  "
"Returns ``Decimal('NaN')`` if *number* is a quiet NaN.  Raises :class:"
"`InvalidOperation` if *number* is an infinity, a signaling NaN, or if the "
"length of the coefficient after the quantize operation would be greater than "
"the current context's precision.  In other words, for the non-corner cases:"
msgstr ""
"Se *ndigits* for um :class:`int`, o modo de arredondamento do contexto é "
"respeitado e um :class:`Decimal` que representa *number* arredondado para o "
"múltiplo mais próximo de ``Decimal('1E-ndigits')`` é retornado; neste caso, "
"``round(number, ndigits)`` é equivalente a ``self.quantize(Decimal('1E-"
"ndigits'))``. Retorna ``Decimal('NaN')`` se *number* for um NaN silencioso. "
"Levanta :class:`InvalidOperation` se *number* for um infinito, um NaN de "
"sinalização, ou se o comprimento do coeficiente após a operação de "
"quantização for maior que a precisão do contexto atual. Em outras palavras, "
"para os casos não extremos:"

#: ../../library/decimal.rst:923
msgid ""
"if *ndigits* is positive, return *number* rounded to *ndigits* decimal "
"places;"
msgstr ""
"se *ndigits* for positivo, retorna *number* arredondado para *ndigits* casas "
"decimais;"

#: ../../library/decimal.rst:925
msgid "if *ndigits* is zero, return *number* rounded to the nearest integer;"
msgstr ""
"se *ndigits* for zero, retorna *number* arredondado para o inteiro mais "
"próximo;"

#: ../../library/decimal.rst:926
msgid ""
"if *ndigits* is negative, return *number* rounded to the nearest multiple of "
"``10**abs(ndigits)``."
msgstr ""
"se *ndigits* for negativo, retorna *number* arredondado para o múltiplo mais "
"próximo de ``10**abs(ndigits)``."

#: ../../library/decimal.rst:929
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/decimal.rst:931
msgid ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().rounding = ROUND_DOWN\n"
">>> round(Decimal('3.75'))     # context rounding ignored\n"
"4\n"
">>> round(Decimal('3.5'))      # round-ties-to-even\n"
"4\n"
">>> round(Decimal('3.75'), 0)  # uses the context rounding\n"
"Decimal('3')\n"
">>> round(Decimal('3.75'), 1)\n"
"Decimal('3.7')\n"
">>> round(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"
msgstr ""
">>> from decimal import Decimal, getcontext, ROUND_DOWN\n"
">>> getcontext().rounding = ROUND_DOWN\n"
">>> round(Decimal('3.75'))     # arredondamento do contexto ignorado\n"
"4\n"
">>> round(Decimal('3.5'))      # arredondar-empates-para-par\n"
"4\n"
">>> round(Decimal('3.75'), 0)  # usa o arredondamento do contexto\n"
"Decimal('3')\n"
">>> round(Decimal('3.75'), 1)\n"
"Decimal('3.7')\n"
">>> round(Decimal('3.75'), -1)\n"
"Decimal('0E+1')"

#: ../../library/decimal.rst:948
msgid "Logical operands"
msgstr "Operandos lógicos"

#: ../../library/decimal.rst:950
msgid ""
"The :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, :meth:"
"`~Decimal.logical_or`, and :meth:`~Decimal.logical_xor` methods expect their "
"arguments to be *logical operands*.  A *logical operand* is a :class:"
"`Decimal` instance whose exponent and sign are both zero, and whose digits "
"are all either ``0`` or ``1``."
msgstr ""
"Os métodos :meth:`~Decimal.logical_and`, :meth:`~Decimal.logical_invert`, :"
"meth:`~Decimal.logical_or` e :meth:`~Decimal.logical_xor` esperam que os "
"seus argumentos sejam *operandos lógicos*. Um *operando lógico* é uma "
"instância :class:`Decimal` cujo expoente e sinal são ambos zero, e cujos "
"dígitos são todos ``0`` ou ``1``."

#: ../../library/decimal.rst:962
msgid "Context objects"
msgstr "Objetos de contexto"

#: ../../library/decimal.rst:964
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""
"Os contextos são ambientes para operações aritméticas. Eles governam a "
"precisão, definem regras de arredondamento, determinam quais sinais são "
"tratados como exceções e limitam o intervalo para expoentes."

#: ../../library/decimal.rst:968
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""
"Cada thread tem o seu próprio contexto atual, que é acedido ou alterado "
"usando as funções :func:`getcontext` e :func:`setcontext`:"

#: ../../library/decimal.rst:974
msgid "Return the current context for the active thread."
msgstr "Retorna o contexto atual para a thread ativa."

#: ../../library/decimal.rst:979
msgid "Set the current context for the active thread to *c*."
msgstr "Define o contexto atual para a thread ativa como *c*."

#: ../../library/decimal.rst:981
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""
"Também pode usar a instrução :keyword:`with` e a função :func:`localcontext` "
"para alterar temporariamente o contexto ativo."

#: ../../library/decimal.rst:986
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *ctx* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used.  The *kwargs* argument is "
"used to set the attributes of the new context."
msgstr ""
"Retorna um gestor de contexto que definirá o contexto atual para a thread "
"ativa como uma cópia de *ctx* na entrada da instrução with e restaurará o "
"contexto anterior ao sair da instrução with. Se nenhum contexto for "
"especificado, uma cópia do contexto atual é usada. O argumento *kwargs* é "
"usado para definir os atributos do novo contexto."

#: ../../library/decimal.rst:992
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""
"Por exemplo, o seguinte código define a precisão decimal atual para 42 "
"casas, realiza um cálculo e depois restaura automaticamente o contexto "
"anterior::"

#: ../../library/decimal.rst:995
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # Perform a high precision calculation\n"
"    s = calculate_something()\n"
"s = +s  # Round the final result back to the default precision"
msgstr ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # Realizar um cálculo de alta precisão\n"
"    s = calculate_something()\n"
"s = +s  # Arredondar o resultado final de volta à precisão predefinida"

#: ../../library/decimal.rst:1002
msgid "Using keyword arguments, the code would be the following::"
msgstr "Usando argumentos de palavra-chave, o código seria o seguinte::"

#: ../../library/decimal.rst:1004
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext(prec=42) as ctx:\n"
"    s = calculate_something()\n"
"s = +s"
msgstr ""
"from decimal import localcontext\n"
"\n"
"with localcontext(prec=42) as ctx:\n"
"    s = calculate_something()\n"
"s = +s"

#: ../../library/decimal.rst:1010
msgid ""
"Raises :exc:`TypeError` if *kwargs* supplies an attribute that :class:"
"`Context` doesn't support.  Raises either :exc:`TypeError` or :exc:"
"`ValueError` if *kwargs* supplies an invalid value for an attribute."
msgstr ""
"Levanta :exc:`TypeError` se *kwargs* fornecer um atributo que :class:"
"`Context` não suporta. Levanta :exc:`TypeError` ou :exc:`ValueError` se "
"*kwargs* fornecer um valor inválido para um atributo."

#: ../../library/decimal.rst:1014
msgid ""
":meth:`localcontext` now supports setting context attributes through the use "
"of keyword arguments."
msgstr ""
":meth:`localcontext` agora suporta a definição de atributos de contexto "
"através do uso de argumentos de palavra-chave."

#: ../../library/decimal.rst:1017
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""
"Novos contextos também podem ser criados usando o construtor :class:"
"`Context` descrito abaixo. Além disso, o módulo fornece três contextos pré-"
"definidos:"

#: ../../library/decimal.rst:1023
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""
"Este é um contexto padrão definido pela Especificação de Aritmética Decimal "
"Geral. A precisão é definida para nove. O arredondamento é definido para :"
"const:`ROUND_HALF_UP`. Todas as flags são limpas. Todas as armadilhas estão "
"ativadas (tratadas como exceções) exceto :const:`Inexact`, :const:`Rounded` "
"e :const:`Subnormal`."

#: ../../library/decimal.rst:1029
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""
"Como muitas das armadilhas estão ativadas, este contexto é útil para "
"depuração."

#: ../../library/decimal.rst:1034
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""
"Este é um contexto padrão definido pela Especificação de Aritmética Decimal "
"Geral. A precisão é definida para nove. O arredondamento é definido para :"
"const:`ROUND_HALF_EVEN`. Todas as flags são limpas. Nenhuma armadilha está "
"ativada (para que exceções não sejam levantadas durante os cálculos)."

#: ../../library/decimal.rst:1039
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of ``NaN`` or ``Infinity`` instead of raising "
"exceptions.  This allows an application to complete a run in the presence of "
"conditions that would otherwise halt the program."
msgstr ""
"Como as armadilhas estão desativadas, este contexto é útil para aplicações "
"que preferem ter valores de resultado de ``NaN`` ou ``Infinity`` em vez de "
"levantar exceções. Isto permite que uma aplicação complete uma execução na "
"presença de condições que, de outra forma, parariam o programa."

#: ../../library/decimal.rst:1047
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts created by the :class:`Context` "
"constructor."
msgstr ""
"Este contexto é usado pelo construtor :class:`Context` como um protótipo "
"para novos contextos. Alterar um campo (como a precisão) tem o efeito de "
"alterar o valor predefinido para novos contextos criados pelo construtor :"
"class:`Context`."

#: ../../library/decimal.rst:1051
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""
"Este contexto é mais útil em ambientes multi-thread. Alterar um dos campos "
"antes de as threads serem iniciadas tem o efeito de definir valores "
"predefinidos em todo o sistema. Alterar os campos após as threads terem sido "
"iniciadas não é recomendado, pois exigiria sincronização de threads para "
"evitar condições de corrida."

#: ../../library/decimal.rst:1056
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""
"Em ambientes de thread única, é preferível não usar este contexto de todo. "
"Em vez disso, simplesmente crie contextos explicitamente como descrito "
"abaixo."

#: ../../library/decimal.rst:1059
msgid ""
"The default values are :attr:`Context.prec`\\ =\\ ``28``, :attr:`Context."
"rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, and enabled traps for :class:"
"`Overflow`, :class:`InvalidOperation`, and :class:`DivisionByZero`."
msgstr ""
"Os valores predefinidos são :attr:`Context.prec`\\ =\\ ``28``, :attr:"
"`Context.rounding`\\ =\\ :const:`ROUND_HALF_EVEN`, e armadilhas ativadas "
"para :class:`Overflow`, :class:`InvalidOperation` e :class:`DivisionByZero`."

#: ../../library/decimal.rst:1064
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""
"Além dos três contextos fornecidos, novos contextos podem ser criados com o "
"construtor :class:`Context`."

#: ../../library/decimal.rst:1070
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""
"Cria um novo contexto. Se um campo não for especificado ou for :const:"
"`None`, os valores predefinidos são copiados do :const:`DefaultContext`. Se "
"o campo *flags* não for especificado ou for :const:`None`, todas as flags "
"são limpas."

#: ../../library/decimal.rst:1076
msgid ""
"An integer in the range [``1``, :const:`MAX_PREC`] that sets the precision "
"for arithmetic operations in the context."
msgstr ""
"Um inteiro no intervalo [``1``, :const:`MAX_PREC`] que define a precisão "
"para operações aritméticas no contexto."

#: ../../library/decimal.rst:1081
msgid "One of the constants listed in the section `Rounding Modes`_."
msgstr "Uma das constantes listadas na secção `Modos de Arredondamento`_."

#: ../../library/decimal.rst:1086
msgid ""
"Lists of any signals to be set. Generally, new contexts should only set "
"traps and leave the flags clear."
msgstr ""
"Listas de quaisquer sinais a serem definidos. Geralmente, novos contextos "
"devem definir apenas armadilhas e deixar as flags limpas."

#: ../../library/decimal.rst:1092
msgid ""
"Integers specifying the outer limits allowable for exponents. *Emin* must be "
"in the range [:const:`MIN_EMIN`, ``0``], *Emax* in the range [``0``, :const:"
"`MAX_EMAX`]."
msgstr ""
"Inteiros que especificam os limites externos permitidos para expoentes. "
"*Emin* deve estar no intervalo [:const:`MIN_EMIN`, ``0``], *Emax* no "
"intervalo [``0``, :const:`MAX_EMAX`]."

#: ../../library/decimal.rst:1098
msgid ""
"Either ``0`` or ``1`` (the default). If set to ``1``, exponents are printed "
"with a capital ``E``; otherwise, a lowercase ``e`` is used: "
"``Decimal('6.02e+23')``."
msgstr ""
"Ou ``0`` ou ``1`` (o predefinido). Se definido como ``1``, os expoentes são "
"impressos com um ``E`` maiúsculo; caso contrário, é usado um ``e`` "
"minúsculo: ``Decimal('6.02e+23')``."

#: ../../library/decimal.rst:1104
msgid ""
"Either ``0`` (the default) or ``1``.  If set to ``1``, the exponent ``e`` of "
"a :class:`Decimal` instance representable in this context is strictly "
"limited to the range ``Emin - prec + 1 <= e <= Emax - prec + 1``. If *clamp* "
"is ``0`` then a weaker condition holds: the adjusted exponent of the :class:"
"`Decimal` instance is at most :attr:`~Context.Emax`.  When *clamp* is ``1``, "
"a large normal number will, where possible, have its exponent reduced and a "
"corresponding number of zeros added to its coefficient, in order to fit the "
"exponent constraints; this preserves the value of the number but loses "
"information about significant trailing zeros.  For example::"
msgstr ""
"Ou ``0`` (o predefinido) ou ``1``. Se definido como ``1``, o expoente ``e`` "
"de uma instância :class:`Decimal` representável neste contexto é "
"estritamente limitado ao intervalo ``Emin - prec + 1 <= e <= Emax - prec + "
"1``. Se *clamp* for ``0``, então uma condição mais fraca é mantida: o "
"expoente ajustado da instância :class:`Decimal` é no máximo :attr:`~Context."
"Emax`. Quando *clamp* é ``1``, um grande número normal terá, sempre que "
"possível, o seu expoente reduzido e um número correspondente de zeros "
"adicionados ao seu coeficiente, a fim de se ajustar às restrições do "
"expoente; isto preserva o valor do número, mas perde informações sobre zeros "
"significativos à direita. Por exemplo::"

#: ../../library/decimal.rst:1115
msgid ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"
msgstr ""
">>> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999')\n"
"Decimal('1.23000E+999')"

#: ../../library/decimal.rst:1118
msgid ""
"A *clamp* value of ``1`` allows compatibility with the fixed-width decimal "
"interchange formats specified in IEEE 754."
msgstr ""
"Um valor de *clamp* de ``1`` permite compatibilidade com os formatos de "
"intercâmbio decimal de largura fixa especificados no IEEE 754."

#: ../../library/decimal.rst:1121
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`~Decimal.adjusted` and :meth:"
"`~Decimal.as_tuple` methods) there is a corresponding :class:`Context` "
"method.  For example, for a :class:`Context` instance ``C`` and :class:"
"`Decimal` instance ``x``, ``C.exp(x)`` is equivalent to ``x."
"exp(context=C)``.  Each :class:`Context` method accepts a Python integer (an "
"instance of :class:`int`) anywhere that a Decimal instance is accepted."
msgstr ""
"A classe :class:`Context` define vários métodos de propósito geral, bem como "
"um grande número de métodos para fazer aritmética diretamente num dado "
"contexto. Além disso, para cada um dos métodos :class:`Decimal` descritos "
"acima (com exceção dos métodos :meth:`~Decimal.adjusted` e :meth:`~Decimal."
"as_tuple`), existe um método correspondente :class:`Context`. Por exemplo, "
"para uma instância :class:`Context` ``C`` e uma instância :class:`Decimal` "
"``x``, ``C.exp(x)`` é equivalente a ``x.exp(context=C)``. Cada método :class:"
"`Context` aceita um inteiro Python (uma instância de :class:`int`) em "
"qualquer lugar onde uma instância Decimal é aceita."

#: ../../library/decimal.rst:1134
msgid "Resets all of the flags to ``0``."
msgstr "Redefine todas as flags para ``0``."

#: ../../library/decimal.rst:1138
msgid "Resets all of the traps to ``0``."
msgstr "Redefine todas as armadilhas para ``0``."

#: ../../library/decimal.rst:1144
msgid "Return a duplicate of the context."
msgstr "Retorna uma duplicata do contexto."

#: ../../library/decimal.rst:1148
msgid "Return a copy of the Decimal instance num."
msgstr "Retorna uma cópia da instância Decimal num."

#: ../../library/decimal.rst:1152
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""
"Cria uma nova instância Decimal a partir de *num*, mas usando *self* como "
"contexto. Ao contrário do construtor :class:`Decimal`, a precisão do "
"contexto, o método de arredondamento, as flags e as armadilhas são aplicadas "
"à conversão."

#: ../../library/decimal.rst:1156
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""
"Isto é útil porque as constantes são frequentemente dadas com uma precisão "
"maior do que a necessária pela aplicação. Outro benefício é que o "
"arredondamento elimina imediatamente efeitos não intencionais de dígitos "
"além da precisão atual. No exemplo seguinte, usar entradas não arredondadas "
"significa que adicionar zero a uma soma pode alterar o resultado:"

#: ../../library/decimal.rst:1162
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"

#: ../../library/decimal.rst:1170
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace or underscores "
"are permitted."
msgstr ""
"Este método implementa a operação to-number da especificação IBM. Se o "
"argumento for uma string, não são permitidos espaços em branco ou "
"sublinhados à esquerda ou à direita."

#: ../../library/decimal.rst:1176
msgid ""
"Creates a new Decimal instance from a float *f* but rounding using *self* as "
"the context.  Unlike the :meth:`Decimal.from_float` class method, the "
"context precision, rounding method, flags, and traps are applied to the "
"conversion."
msgstr ""
"Cria uma nova instância Decimal a partir de um float *f*, mas arredondando "
"usando *self* como contexto. Ao contrário do método de classe :meth:`Decimal."
"from_float`, a precisão do contexto, o método de arredondamento, as flags e "
"as armadilhas são aplicadas à conversão."

#: ../../library/decimal.rst:1181
msgid ""
">>> context = Context(prec=5, rounding=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3.1415')\n"
">>> context = Context(prec=5, traps=[Inexact])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"decimal.Inexact: None"
msgstr ""
">>> context = Context(prec=5, rounding=ROUND_DOWN)\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Decimal('3.1415')\n"
">>> context = Context(prec=5, traps=[Inexact])\n"
">>> context.create_decimal_from_float(math.pi)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"decimal.Inexact: None"

#: ../../library/decimal.rst:1196
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""
"Retorna um valor igual a ``Emin - prec + 1``, que é o valor mínimo do "
"expoente para resultados subnormais. Quando ocorre underflow, o expoente é "
"definido para :const:`Etiny`."

#: ../../library/decimal.rst:1202
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr "Retorna um valor igual a ``Emax - prec + 1``."

#: ../../library/decimal.rst:1204
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""
"A abordagem habitual para trabalhar com decimais é criar instâncias :class:"
"`Decimal` e depois aplicar operações aritméticas que ocorrem dentro do "
"contexto atual para a thread ativa. Uma abordagem alternativa é usar métodos "
"de contexto para calcular dentro de um contexto específico. Os métodos são "
"semelhantes aos da classe :class:`Decimal` e são apenas brevemente "
"recontados aqui."

#: ../../library/decimal.rst:1214
msgid "Returns the absolute value of *x*."
msgstr "Retorna o valor absoluto de *x*."

#: ../../library/decimal.rst:1219
msgid "Return the sum of *x* and *y*."
msgstr "Retorna a soma de *x* e *y*."

#: ../../library/decimal.rst:1224
msgid "Returns the same Decimal object *x*."
msgstr "Retorna o mesmo objeto Decimal *x*."

#: ../../library/decimal.rst:1229
msgid "Compares *x* and *y* numerically."
msgstr "Compara *x* e *y* numericamete."

#: ../../library/decimal.rst:1234
msgid "Compares the values of the two operands numerically."
msgstr "Compara os valores dos dois operandos numericamete."

#: ../../library/decimal.rst:1239
msgid "Compares two operands using their abstract representation."
msgstr "Compara dois operandos usando a sua representação abstrata."

#: ../../library/decimal.rst:1244
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""
"Compara dois operandos usando a sua representação abstrata, ignorando o "
"sinal."

#: ../../library/decimal.rst:1249
msgid "Returns a copy of *x* with the sign set to 0."
msgstr "Retorna uma cópia de *x* com o sinal definido para 0."

#: ../../library/decimal.rst:1254
msgid "Returns a copy of *x* with the sign inverted."
msgstr "Retorna uma cópia de *x* com o sinal invertido."

#: ../../library/decimal.rst:1259
msgid "Copies the sign from *y* to *x*."
msgstr "Copia o sinal de *y* para *x*."

#: ../../library/decimal.rst:1264
msgid "Return *x* divided by *y*."
msgstr "Retorna *x* dividido por *y*."

#: ../../library/decimal.rst:1269
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr "Retorna *x* dividido por *y*, truncado para um inteiro."

#: ../../library/decimal.rst:1274
msgid "Divides two numbers and returns the integer part of the result."
msgstr "Divide dois números e retorna a parte inteira do resultado."

#: ../../library/decimal.rst:1279
msgid "Returns ``e ** x``."
msgstr "Retorna ``e ** x``."

#: ../../library/decimal.rst:1284
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr "Retorna *x* multiplicado por *y*, mais *z*."

#: ../../library/decimal.rst:1289
msgid "Returns ``True`` if *x* is canonical; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for canónico; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1294
msgid "Returns ``True`` if *x* is finite; otherwise returns ``False``."
msgstr "Retorna ``True`` se *x* for finito; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1299
msgid "Returns ``True`` if *x* is infinite; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for infinito; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1304
msgid "Returns ``True`` if *x* is a qNaN or sNaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um qNaN ou sNaN; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1309
msgid ""
"Returns ``True`` if *x* is a normal number; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um número normal; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1314
msgid "Returns ``True`` if *x* is a quiet NaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um NaN silencioso; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1319
msgid "Returns ``True`` if *x* is negative; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for negativo; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1324
msgid ""
"Returns ``True`` if *x* is a signaling NaN; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um NaN de sinalização; caso contrário, retorna "
"``False``."

#: ../../library/decimal.rst:1329
msgid "Returns ``True`` if *x* is subnormal; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for subnormal; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1334
msgid "Returns ``True`` if *x* is a zero; otherwise returns ``False``."
msgstr ""
"Retorna ``True`` se *x* for um zero; caso contrário, retorna ``False``."

#: ../../library/decimal.rst:1339
msgid "Returns the natural (base e) logarithm of *x*."
msgstr "Retorna o logaritmo natural (base e) de *x*."

#: ../../library/decimal.rst:1344
msgid "Returns the base 10 logarithm of *x*."
msgstr "Retorna o logaritmo de base 10 de *x*."

#: ../../library/decimal.rst:1349
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr "Retorna o expoente da magnitude do MSD do operando."

#: ../../library/decimal.rst:1354
msgid "Applies the logical operation *and* between each operand's digits."
msgstr "Aplica a operação lógica *and* entre cada dígito dos operandos."

#: ../../library/decimal.rst:1359
msgid "Invert all the digits in *x*."
msgstr "Inverte todos os dígitos em *x*."

#: ../../library/decimal.rst:1364
msgid "Applies the logical operation *or* between each operand's digits."
msgstr "Aplica a operação lógica *or* entre cada dígito dos operandos."

#: ../../library/decimal.rst:1369
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr "Aplica a operação lógica *xor* entre cada dígito dos operandos."

#: ../../library/decimal.rst:1374
msgid "Compares two values numerically and returns the maximum."
msgstr "Compara dois valores numericamete e retorna o máximo."

#: ../../library/decimal.rst:1379 ../../library/decimal.rst:1389
msgid "Compares the values numerically with their sign ignored."
msgstr "Compara os valores numericamete ignorando o seu sinal."

#: ../../library/decimal.rst:1384
msgid "Compares two values numerically and returns the minimum."
msgstr "Compara dois valores numericamete e retorna o mínimo."

#: ../../library/decimal.rst:1394
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr "Menos corresponde ao operador unário de prefixo menos em Python."

#: ../../library/decimal.rst:1399
msgid "Return the product of *x* and *y*."
msgstr "Retorna o produto de *x* e *y*."

#: ../../library/decimal.rst:1404
msgid "Returns the largest representable number smaller than *x*."
msgstr "Retorna o maior número representável menor que *x*."

#: ../../library/decimal.rst:1409
msgid "Returns the smallest representable number larger than *x*."
msgstr "Retorna o menor número representável maior que *x*."

#: ../../library/decimal.rst:1414
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr "Retorna o número mais próximo de *x*, na direção de *y*."

#: ../../library/decimal.rst:1419
msgid "Reduces *x* to its simplest form."
msgstr "Reduz *x* à sua forma mais simples."

#: ../../library/decimal.rst:1424
msgid "Returns an indication of the class of *x*."
msgstr "Retorna uma indicação da classe de *x*."

#: ../../library/decimal.rst:1429
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""
"Mais corresponde ao operador unário de prefixo mais em Python. Esta operação "
"aplica a precisão e o arredondamento do contexto, por isso *não* é uma "
"operação de identidade."

#: ../../library/decimal.rst:1436
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""
"Retorna ``x`` elevado à potência de ``y``, reduzido módulo ``modulo``, se "
"fornecido."

#: ../../library/decimal.rst:1438
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"rounding mode of the context is used. Results are always correctly rounded "
"in the Python version."
msgstr ""
"Com dois argumentos, calcula ``x**y``. Se ``x`` for negativo, então ``y`` "
"deve ser integral. O resultado será inexato a menos que ``y`` seja integral "
"e o resultado seja finito e possa ser expresso exatamente em 'precision' "
"dígitos. O modo de arredondamento do contexto é usado. Os resultados são "
"sempre corretamente arredondados na versão Python."

#: ../../library/decimal.rst:1444
msgid ""
"``Decimal(0) ** Decimal(0)`` results in ``InvalidOperation``, and if "
"``InvalidOperation`` is not trapped, then results in ``Decimal('NaN')``."
msgstr ""
"``Decimal(0) ** Decimal(0)`` resulta em ``InvalidOperation``, e se "
"``InvalidOperation`` não for capturado, então resulta em ``Decimal('NaN')``."

#: ../../library/decimal.rst:1447
msgid ""
"The C module computes :meth:`power` in terms of the correctly rounded :meth:"
"`exp` and :meth:`ln` functions. The result is well-defined but only \"almost "
"always correctly rounded\"."
msgstr ""
"O módulo C calcula :meth:`power` em termos das funções :meth:`exp` e :meth:"
"`ln` corretamente arredondadas. O resultado é bem definido, mas apenas "
"\"quase sempre corretamente arredondado\"."

#: ../../library/decimal.rst:1452
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""
"Com três argumentos, calcula ``(x**y) % modulo``. Para a forma de três "
"argumentos, as seguintes restrições aos argumentos aplicam-se:"

#: ../../library/decimal.rst:1455
msgid "all three arguments must be integral"
msgstr "todos os três argumentos devem ser integrais"

#: ../../library/decimal.rst:1456
msgid "``y`` must be nonnegative"
msgstr "``y`` deve ser não negativo"

#: ../../library/decimal.rst:1457
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr "pelo menos um de ``x`` ou ``y`` deve ser não zero"

#: ../../library/decimal.rst:1458
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr "``modulo`` deve ser não zero e ter no máximo 'precision' dígitos"

#: ../../library/decimal.rst:1460
msgid ""
"The value resulting from ``Context.power(x, y, modulo)`` is equal to the "
"value that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  The exponent of the result is "
"zero, regardless of the exponents of ``x``, ``y`` and ``modulo``.  The "
"result is always exact."
msgstr ""
"O valor resultante de ``Context.power(x, y, modulo)`` é igual ao valor que "
"seria obtido calculando ``(x**y) % modulo`` com precisão ilimitada, mas é "
"calculado de forma mais eficiente. O expoente do resultado é zero, "
"independentemente dos expoentes de ``x``, ``y`` e ``modulo``. O resultado é "
"sempre exato."

#: ../../library/decimal.rst:1470
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr "Retorna um valor igual a *x* (arredondado), tendo o expoente de *y*."

#: ../../library/decimal.rst:1475
msgid "Just returns 10, as this is Decimal, :)"
msgstr "Apenas retorna 10, já que isto é Decimal, :)"

#: ../../library/decimal.rst:1480
msgid "Returns the remainder from integer division."
msgstr "Retorna o resto da divisão inteira."

#: ../../library/decimal.rst:1482
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""
"O sinal do resultado, se não zero, é o mesmo que o do dividendo original."

#: ../../library/decimal.rst:1488
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""
"Retorna ``x - y * n``, onde *n* é o inteiro mais próximo do valor exato de "
"``x / y`` (se o resultado for 0, então o seu sinal será o sinal de *x*)."

#: ../../library/decimal.rst:1494
msgid "Returns a rotated copy of *x*, *y* times."
msgstr "Retorna uma cópia rotacionada de *x*, *y* vezes."

#: ../../library/decimal.rst:1499
msgid "Returns ``True`` if the two operands have the same exponent."
msgstr "Retorna ``True`` se os dois operandos tiverem o mesmo expoente."

#: ../../library/decimal.rst:1504
msgid "Returns the first operand after adding the second value its exp."
msgstr ""
"Retorna o primeiro operando após adicionar o segundo valor ao seu expoente."

#: ../../library/decimal.rst:1509
msgid "Returns a shifted copy of *x*, *y* times."
msgstr "Retorna uma cópia deslocada de *x*, *y* vezes."

#: ../../library/decimal.rst:1514
msgid "Square root of a non-negative number to context precision."
msgstr "Raiz quadrada de um número não negativo com a precisão do contexto."

#: ../../library/decimal.rst:1519
msgid "Return the difference between *x* and *y*."
msgstr "Retorna a diferença entre *x* e *y*."

#: ../../library/decimal.rst:1533
msgid "Rounds to an integer."
msgstr "Arredonda para um inteiro."

#: ../../library/decimal.rst:1538
msgid "Converts a number to a string using scientific notation."
msgstr "Converte um número para uma string usando notação científica."

#: ../../library/decimal.rst:1545
msgid "Constants"
msgstr "Constantes"

#: ../../library/decimal.rst:1547
msgid ""
"The constants in this section are only relevant for the C module. They are "
"also included in the pure Python version for compatibility."
msgstr ""
"As constantes nesta secção são relevantes apenas para o módulo C. Também "
"estão incluídas na versão pura Python para compatibilidade."

#: ../../library/decimal.rst:1551
msgid "32-bit"
msgstr "32-bit"

#: ../../library/decimal.rst:1551
msgid "64-bit"
msgstr "64-bit"

#: ../../library/decimal.rst:1553 ../../library/decimal.rst:1555
msgid "``425000000``"
msgstr "``425000000``"

#: ../../library/decimal.rst:1553 ../../library/decimal.rst:1555
msgid "``999999999999999999``"
msgstr "``999999999999999999``"

#: ../../library/decimal.rst:1557
msgid "``-425000000``"
msgstr "``-425000000``"

#: ../../library/decimal.rst:1557
msgid "``-999999999999999999``"
msgstr "``-999999999999999999``"

#: ../../library/decimal.rst:1559
msgid "``-849999999``"
msgstr "``-849999999``"

#: ../../library/decimal.rst:1559
msgid "``-1999999999999999997``"
msgstr "``-1999999999999999997``"

#: ../../library/decimal.rst:1565
msgid ""
"The value is ``True``.  Deprecated, because Python now always has threads."
msgstr ""
"O valor é ``True``. Obsoleto, porque o Python agora sempre tem threads."

#: ../../library/decimal.rst:1571
msgid ""
"The default value is ``True``. If Python is :option:`configured using the --"
"without-decimal-contextvar option <--without-decimal-contextvar>`, the C "
"version uses a thread-local rather than a coroutine-local context and the "
"value is ``False``.  This is slightly faster in some nested context "
"scenarios."
msgstr ""
"O valor predefinido é ``True``. Se o Python for :option:`configurado usando "
"a opção --without-decimal-contextvar <--without-decimal-contextvar>`, a "
"versão C usa um contexto local à thread em vez de um contexto local à "
"corrotina e o valor é ``False``. Isto é ligeiramente mais rápido em alguns "
"cenários de contexto aninhado."

#: ../../library/decimal.rst:1580
msgid "Rounding modes"
msgstr "Modos de arredondamento"

#: ../../library/decimal.rst:1584
msgid "Round towards ``Infinity``."
msgstr "Arredonda para ``Infinity``."

#: ../../library/decimal.rst:1588
msgid "Round towards zero."
msgstr "Arredonda para zero."

#: ../../library/decimal.rst:1592
msgid "Round towards ``-Infinity``."
msgstr "Arredonda para ``-Infinity``."

#: ../../library/decimal.rst:1596
msgid "Round to nearest with ties going towards zero."
msgstr "Arredonda para o mais próximo com empates a irem para zero."

#: ../../library/decimal.rst:1600
msgid "Round to nearest with ties going to nearest even integer."
msgstr ""
"Arredonda para o mais próximo com empates a irem para o inteiro par mais "
"próximo."

#: ../../library/decimal.rst:1604
msgid "Round to nearest with ties going away from zero."
msgstr "Arredonda para o mais próximo com empates a irem para longe de zero."

#: ../../library/decimal.rst:1608
msgid "Round away from zero."
msgstr "Arredonda para longe de zero."

#: ../../library/decimal.rst:1612
msgid ""
"Round away from zero if last digit after rounding towards zero would have "
"been 0 or 5; otherwise round towards zero."
msgstr ""
"Arredonda para longe de zero se o último dígito após o arredondamento para "
"zero fosse 0 ou 5; caso contrário, arredonda para zero."

#: ../../library/decimal.rst:1619
msgid "Signals"
msgstr "Sinais"

#: ../../library/decimal.rst:1621
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""
"Os sinais representam condições que surgem durante a computação. Cada um "
"corresponde a uma flag de contexto e a um ativador de armadilha de contexto."

#: ../../library/decimal.rst:1624
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""
"A flag de contexto é definida sempre que a condição é encontrada. Após a "
"computação, as flags podem ser verificadas para fins informativos (por "
"exemplo, para determinar se uma computação foi exata). Após verificar as "
"flags, certifique-se de limpar todas as flags antes de iniciar a próxima "
"computação."

#: ../../library/decimal.rst:1629
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""
"Se o ativador de armadilha do contexto estiver definido para o sinal, então "
"a condição faz com que uma exceção Python seja levantada. Por exemplo, se a "
"armadilha :class:`DivisionByZero` estiver definida, então uma exceção :exc:"
"`DivisionByZero` é levantada ao encontrar a condição."

#: ../../library/decimal.rst:1637
msgid "Altered an exponent to fit representation constraints."
msgstr "Alterou um expoente para se ajustar às restrições de representação."

#: ../../library/decimal.rst:1639
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`~Context.Emin` and :attr:`~Context.Emax` limits.  If possible, the "
"exponent is reduced to fit by adding zeros to the coefficient."
msgstr ""
"Tipicamente, o clamping ocorre quando um expoente cai fora dos limites :attr:"
"`~Context.Emin` e :attr:`~Context.Emax` do contexto. Se possível, o expoente "
"é reduzido para se ajustar, adicionando zeros ao coeficiente."

#: ../../library/decimal.rst:1646
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr ""
"Classe base para outros sinais e uma subclasse de :exc:`ArithmeticError`."

#: ../../library/decimal.rst:1651
msgid "Signals the division of a non-infinite number by zero."
msgstr "Sinaliza a divisão de um número não infinito por zero."

#: ../../library/decimal.rst:1653
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns ``Infinity`` or ``-"
"Infinity`` with the sign determined by the inputs to the calculation."
msgstr ""
"Pode ocorrer com divisão, divisão módulo, ou ao elevar um número a uma "
"potência negativa. Se este sinal não for capturado, retorna ``Infinity`` ou "
"``-Infinity`` com o sinal determinado pelas entradas do cálculo."

#: ../../library/decimal.rst:1660
msgid "Indicates that rounding occurred and the result is not exact."
msgstr "Indica que ocorreu arredondamento e o resultado não é exato."

#: ../../library/decimal.rst:1662
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""
"Sinaliza quando dígitos não-zero foram descartados durante o arredondamento. "
"O resultado arredondado é retornado. A flag de sinal ou armadilha é usada "
"para detetar quando os resultados são inexatos."

#: ../../library/decimal.rst:1669
msgid "An invalid operation was performed."
msgstr "Foi realizada uma operação inválida."

#: ../../library/decimal.rst:1671
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns ``NaN``.  Possible causes include::"
msgstr ""
"Indica que foi solicitada uma operação que não faz sentido. Se não for "
"capturado, retorna ``NaN``. Possíveis causas incluem::"

#: ../../library/decimal.rst:1674
msgid ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"sqrt(-x) and x > 0\n"
"0 ** 0\n"
"x ** (non-integer)\n"
"x ** Infinity"
msgstr ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"sqrt(-x) e x > 0\n"
"0 ** 0\n"
"x ** (não-inteiro)\n"
"x ** Infinity"

#: ../../library/decimal.rst:1687
msgid "Numerical overflow."
msgstr "Overflow numérico."

#: ../../library/decimal.rst:1689
msgid ""
"Indicates the exponent is larger than :attr:`Context.Emax` after rounding "
"has occurred.  If not trapped, the result depends on the rounding mode, "
"either pulling inward to the largest representable finite number or rounding "
"outward to ``Infinity``.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""
"Indica que o expoente é maior que :attr:`Context.Emax` após o arredondamento "
"ter ocorrido. Se não for capturado, o resultado depende do modo de "
"arredondamento, puxando para dentro para o maior número finito representável "
"ou arredondando para fora para ``Infinity``. Em qualquer caso, :class:"
"`Inexact` e :class:`Rounded` também são sinalizados."

#: ../../library/decimal.rst:1698
msgid "Rounding occurred though possibly no information was lost."
msgstr ""
"Ocorreu arredondamento, embora possivelmente nenhuma informação tenha sido "
"perdida."

#: ../../library/decimal.rst:1700
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding ``5.00`` to ``5.0``).  If not trapped, returns the result "
"unchanged.  This signal is used to detect loss of significant digits."
msgstr ""
"Sinalizado sempre que o arredondamento descarta dígitos; mesmo que esses "
"dígitos sejam zero (como arredondar ``5.00`` para ``5.0``). Se não for "
"capturado, retorna o resultado inalterado. Este sinal é usado para detetar a "
"perda de dígitos significativos."

#: ../../library/decimal.rst:1708
msgid "Exponent was lower than :attr:`~Context.Emin` prior to rounding."
msgstr ""
"O expoente era inferior a :attr:`~Context.Emin` antes do arredondamento."

#: ../../library/decimal.rst:1710
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""
"Ocorre quando o resultado de uma operação é subnormal (o expoente é "
"demasiado pequeno). Se não for capturado, retorna o resultado inalterado."

#: ../../library/decimal.rst:1716
msgid "Numerical underflow with result rounded to zero."
msgstr "Underflow numérico com resultado arredondado para zero."

#: ../../library/decimal.rst:1718
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""

#: ../../library/decimal.rst:1724
msgid "Enable stricter semantics for mixing floats and Decimals."
msgstr "Ativar semântica mais rigorosa para misturar floats e Decimals."

#: ../../library/decimal.rst:1726
msgid ""
"If the signal is not trapped (default), mixing floats and Decimals is "
"permitted in the :class:`~decimal.Decimal` constructor, :meth:`~decimal."
"Context.create_decimal` and all comparison operators. Both conversion and "
"comparisons are exact. Any occurrence of a mixed operation is silently "
"recorded by setting :exc:`FloatOperation` in the context flags. Explicit "
"conversions with :meth:`~decimal.Decimal.from_float` or :meth:`~decimal."
"Context.create_decimal_from_float` do not set the flag."
msgstr ""
"Se o sinal não for capturado (predefinição), misturar floats e Decimals é "
"permitido no construtor :class:`~decimal.Decimal`, :meth:`~decimal.Context."
"create_decimal` e todos os operadores de comparação. Tanto a conversão como "
"as comparações são exatas. Qualquer ocorrência de uma operação mista é "
"registada silenciosamente definindo :exc:`FloatOperation` nas flags do "
"contexto. Conversões explícitas com :meth:`~decimal.Decimal.from_float` ou :"
"meth:`~decimal.Context.create_decimal_from_float` não definem a flag."

#: ../../library/decimal.rst:1734
msgid ""
"Otherwise (the signal is trapped), only equality comparisons and explicit "
"conversions are silent. All other mixed operations raise :exc:"
"`FloatOperation`."
msgstr ""
"Caso contrário (o sinal é capturado), apenas as comparações de igualdade e "
"conversões explícitas são silenciosas. Todas as outras operações mistas "
"levantam :exc:`FloatOperation`."

#: ../../library/decimal.rst:1738
msgid "The following table summarizes the hierarchy of signals::"
msgstr "A tabela seguinte resume a hierarquia de sinais::"

#: ../../library/decimal.rst:1740
msgid ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, exceptions.TypeError)"
msgstr ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal\n"
"        FloatOperation(DecimalException, exceptions.TypeError)"

#: ../../library/decimal.rst:1759
msgid "Floating-point notes"
msgstr "Notas sobre vírgula flutuante"

#: ../../library/decimal.rst:1763
msgid "Mitigating round-off error with increased precision"
msgstr "Mitigar erro de arredondamento com maior precisão"

#: ../../library/decimal.rst:1765
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent ``0.1`` exactly); however, some operations "
"can still incur round-off error when non-zero digits exceed the fixed "
"precision."
msgstr ""
"O uso de vírgula flutuante decimal elimina o erro de representação decimal "
"(tornando possível representar ``0.1`` exatamente); no entanto, algumas "
"operações ainda podem incorrer em erro de arredondamento quando dígitos não-"
"zero excedem a precisão fixa."

#: ../../library/decimal.rst:1769
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating-point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""
"Os efeitos do erro de arredondamento podem ser amplificados pela adição ou "
"subtração de quantidades quase compensatórias, resultando em perda de "
"significância. Knuth fornece dois exemplos instrutivos onde a aritmética de "
"vírgula flutuante arredondada com precisão insuficiente causa a quebra das "
"propriedades associativa e distributiva da adição:"

#: ../../library/decimal.rst:1775
msgid ""
"# Examples from Seminumerical Algorithms, Section 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""
"# Exemplos de Seminumerical Algorithms, Secção 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"

#: ../../library/decimal.rst:1793
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""
"O módulo :mod:`decimal` torna possível restaurar as identidades expandindo a "
"precisão suficientemente para evitar a perda de significância:"

#: ../../library/decimal.rst:1796
msgid ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"

#: ../../library/decimal.rst:1813
msgid "Special values"
msgstr "Valores especiais"

#: ../../library/decimal.rst:1815
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, and two zeros, "
"``+0`` and ``-0``."
msgstr ""
"O sistema numérico para o módulo :mod:`decimal` fornece valores especiais, "
"incluindo ``NaN``, ``sNaN``, ``-Infinity``, ``Infinity``, e dois zeros, "
"``+0`` e ``-0``."

#: ../../library/decimal.rst:1819
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""
"Os infinitos podem ser construídos diretamente com: ``Decimal('Infinity')``. "
"Também podem surgir da divisão por zero quando o sinal :exc:`DivisionByZero` "
"não é capturado. Da mesma forma, quando o sinal :exc:`Overflow` não é "
"capturado, o infinito pode resultar do arredondamento além dos limites do "
"maior número representável."

#: ../../library/decimal.rst:1824
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""
"Os infinitos são assinados (afins) e podem ser usados em operações "
"aritméticas onde são tratados como números muito grandes e indeterminados. "
"Por exemplo, adicionar uma constante ao infinito dá outro resultado infinito."

#: ../../library/decimal.rst:1828
msgid ""
"Some operations are indeterminate and return ``NaN``, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns ``NaN`` which means \"not a number\".  This variety of "
"``NaN`` is quiet and, once created, will flow through other computations "
"always resulting in another ``NaN``.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""
"Algumas operações são indeterminadas e retornam ``NaN``, ou, se o sinal :exc:"
"`InvalidOperation` for capturado, levantam uma exceção. Por exemplo, ``0/0`` "
"retorna ``NaN``, que significa \"não é um número\". Esta variedade de "
"``NaN`` é silenciosa e, uma vez criada, fluirá através de outras "
"computações, resultando sempre em outro ``NaN``. Este comportamento pode ser "
"útil para uma série de computações que ocasionalmente têm entradas em falta "
"— permite que o cálculo prossiga, sinalizando resultados específicos como "
"inválidos."

#: ../../library/decimal.rst:1836
msgid ""
"A variant is ``sNaN`` which signals rather than remaining quiet after every "
"operation.  This is a useful return value when an invalid result needs to "
"interrupt a calculation for special handling."
msgstr ""
"Uma variante é ``sNaN``, que sinaliza em vez de permanecer silencioso após "
"cada operação. Este é um valor de retorno útil quando um resultado inválido "
"precisa interromper um cálculo para tratamento especial."

#: ../../library/decimal.rst:1840
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a ``NaN`` is involved.  A test for equality where one of the operands "
"is a quiet or signaling ``NaN`` always returns :const:`False` (even when "
"doing ``Decimal('NaN')==Decimal('NaN')``), while a test for inequality "
"always returns :const:`True`.  An attempt to compare two Decimals using any "
"of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :exc:"
"`InvalidOperation` signal if either operand is a ``NaN``, and return :const:"
"`False` if this signal is not trapped.  Note that the General Decimal "
"Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a ``NaN`` were taken from "
"the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`~Decimal.compare` and :meth:`~Decimal."
"compare_signal` methods instead."
msgstr ""
"O comportamento dos operadores de comparação do Python pode ser um pouco "
"surpreendente quando um ``NaN`` está envolvido. Um teste de igualdade em que "
"um dos operandos é um ``NaN`` silencioso ou de sinalização sempre retorna :"
"const:`False` (mesmo ao fazer ``Decimal('NaN')==Decimal('NaN')``), enquanto "
"um teste de desigualdade sempre retorna :const:`True`. Uma tentativa de "
"comparar dois Decimals usando qualquer um dos operadores ``<``, ``<=``, "
"``>`` ou ``>=`` levantará o sinal :exc:`InvalidOperation` se algum dos "
"operandos for um ``NaN``, e retornará :const:`False` se este sinal não for "
"capturado. Note que a especificação de Aritmética Decimal Geral não "
"especifica o comportamento de comparações diretas; estas regras para "
"comparações envolvendo um ``NaN`` foram retiradas do padrão IEEE 854 (ver "
"Tabela 3 na secção 5.7). Para garantir conformidade estrita com os padrões, "
"use os métodos :meth:`~Decimal.compare` e :meth:`~Decimal.compare_signal` em "
"vez disso."

#: ../../library/decimal.rst:1853
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""
"Os zeros assinados podem resultar de cálculos que sofrem underflow. Eles "
"mantêm o sinal que teria resultado se o cálculo tivesse sido realizado com "
"maior precisão. Uma vez que a sua magnitude é zero, tanto os zeros positivos "
"como negativos são tratados como iguais e o seu sinal é informativo."

#: ../../library/decimal.rst:1858
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating-point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""
"Além dos dois zeros assinados, que são distintos mas iguais, existem várias "
"representações de zero com precisões diferentes, mas equivalentes em valor. "
"Isto requer algum tempo para se habituar. Para um olho acostumado a "
"representações de vírgula flutuante normalizadas, não é imediatamente óbvio "
"que o seguinte cálculo retorna um valor igual a zero:"

#: ../../library/decimal.rst:1873
msgid "Working with threads"
msgstr "A trabalhar com threads"

#: ../../library/decimal.rst:1875
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext().prec=10``) without interfering with "
"other threads."
msgstr ""
"A função :func:`getcontext` acede a um objeto :class:`Context` diferente "
"para cada thread. Ter contextos de thread separados significa que as threads "
"podem fazer alterações (como ``getcontext().prec=10``) sem interferir com "
"outras threads."

#: ../../library/decimal.rst:1879
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""
"Da mesma forma, a função :func:`setcontext` atribui automaticamente o seu "
"alvo à thread atual."

#: ../../library/decimal.rst:1882
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""

#: ../../library/decimal.rst:1886
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""

#: ../../library/decimal.rst:1892
msgid ""
"# Set applicationwide defaults for all threads about to be launched\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Afterwards, the threads can be started\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."
msgstr ""
"# Definir valores predefinidos para toda a aplicação para todas as threads "
"prestes a serem lançadas\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Depois, as threads podem ser iniciadas\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."

#: ../../library/decimal.rst:1911
msgid "Recipes"
msgstr "Receitas"

#: ../../library/decimal.rst:1913
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""
"Aqui estão algumas receitas que servem como funções utilitárias e que "
"demonstram formas de trabalhar com a classe :class:`Decimal`::"

#: ../../library/decimal.rst:1916
msgid ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Convert Decimal to a money formatted string.\n"
"\n"
"    places:  required number of places after the decimal point\n"
"    curr:    optional currency symbol before the sign (may be blank)\n"
"    sep:     optional grouping separator (comma, period, space, or blank)\n"
"    dp:      decimal point indicator (comma or period)\n"
"             only specify as blank when places is zero\n"
"    pos:     optional sign for positive numbers: '+', space or blank\n"
"    neg:     optional sign for negative numbers: '-', '(', space or blank\n"
"    trailneg:optional trailing minus indicator:  '-', ')', space or blank\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 places --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    if places:\n"
"        build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"Compute Pi to the current precision.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # extra digits for intermediate steps\n"
"    three = Decimal(3)      # substitute \"three=3.0\" for regular floats\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # unary plus applies the new precision\n"
"\n"
"def exp(x):\n"
"    \"\"\"Return e raised to the power of x.  Result type matches input "
"type.\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Return the cosine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Return the sine of x as measured in radians.\n"
"\n"
"    The Taylor series approximation works best for a small value of x.\n"
"    For larger values, first compute x = x % (2 * pi).\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"
msgstr ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Converte Decimal para uma string formatada como moeda.\n"
"\n"
"    places:  número necessário de casas após o ponto decimal\n"
"    curr:    símbolo de moeda opcional antes do sinal (pode estar vazio)\n"
"    sep:     separador de agrupamento opcional (vírgula, ponto, espaço ou "
"vazio)\n"
"    dp:      indicador de ponto decimal (vírgula ou ponto)\n"
"             só especificar como vazio quando places é zero\n"
"    pos:     sinal opcional para números positivos: '+', espaço ou vazio\n"
"    neg:     sinal opcional para números negativos: '-', '(', espaço ou "
"vazio\n"
"    trailneg:indicador de menos à direita opcional:  '-', ')', espaço ou "
"vazio\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 casas --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    if places:\n"
"        build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"Calcula Pi com a precisão atual.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # dígitos extra para passos intermédios\n"
"    three = Decimal(3)      # substituir \"three=3.0\" para floats normais\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # mais unário aplica a nova precisão\n"
"\n"
"def exp(x):\n"
"    \"\"\"Retorna e elevado à potência de x. O tipo do resultado corresponde "
"ao tipo de entrada.\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Retorna o cosseno de x medido em radianos.\n"
"\n"
"    A aproximação da série de Taylor funciona melhor para um valor pequeno "
"de x.\n"
"    Para valores maiores, calcular primeiro x = x % (2 * pi).\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Retorna o seno de x medido em radianos.\n"
"\n"
"    A aproximação da série de Taylor funciona melhor para um valor pequeno "
"de x.\n"
"    Para valores maiores, calcular primeiro x = x % (2 * pi).\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.4779425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"

#: ../../library/decimal.rst:2068
msgid "Decimal FAQ"
msgstr "FAQ do Decimal"

#: ../../library/decimal.rst:2070
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""
"P. É trabalhoso digitar ``decimal.Decimal('1234.5')``. Existe uma forma de "
"minimizar a digitação ao usar o interpretador interativo?"

#: ../../library/decimal.rst:2073
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr "R. Alguns utilizadores abreviam o construtor para apenas uma letra:"

#: ../../library/decimal.rst:2079
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""
"P. Numa aplicação de ponto fixo com duas casas decimais, algumas entradas "
"têm muitas casas e precisam de ser arredondadas. Outras não devem ter "
"dígitos em excesso e precisam de ser validadas. Que métodos devem ser usados?"

#: ../../library/decimal.rst:2083
msgid ""
"A. The :meth:`~Decimal.quantize` method rounds to a fixed number of decimal "
"places. If the :const:`Inexact` trap is set, it is also useful for "
"validation:"
msgstr ""
"R. O método :meth:`~Decimal.quantize` arredonda para um número fixo de casas "
"decimais. Se a armadilha :const:`Inexact` estiver definida, também é útil "
"para validação:"

#: ../../library/decimal.rst:2101
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""
"P. Uma vez que tenho entradas válidas com duas casas decimais, como mantenho "
"esse invariante em toda a aplicação?"

#: ../../library/decimal.rst:2104
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`~Decimal.quantize` step:"
msgstr ""
"R. Algumas operações, como adição, subtração e multiplicação por um inteiro, "
"preservarão automaticamente o ponto fixo. Outras operações, como divisão e "
"multiplicação não inteira, alterarão o número de casas decimais e precisam "
"de ser seguidas por um passo :meth:`~Decimal.quantize`:"

#: ../../library/decimal.rst:2122
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`~Decimal.quantize` step:"
msgstr ""
"No desenvolvimento de aplicações de ponto fixo, é conveniente definir "
"funções para lidar com o passo :meth:`~Decimal.quantize`:"

#: ../../library/decimal.rst:2136
msgid ""
"Q. There are many ways to express the same value.  The numbers ``200``, "
"``200.000``, ``2E2``, and ``.02E+4`` all have the same value at various "
"precisions. Is there a way to transform them to a single recognizable "
"canonical value?"
msgstr ""
"P. Existem muitas formas de expressar o mesmo valor. Os números ``200``, "
"``200.000``, ``2E2`` e ``.02E+4`` têm todos o mesmo valor em várias "
"precisões. Existe uma forma de os transformar num único valor canónico "
"reconhecível?"

#: ../../library/decimal.rst:2141
msgid ""
"A. The :meth:`~Decimal.normalize` method maps all equivalent values to a "
"single representative:"
msgstr ""
"R. O método :meth:`~Decimal.normalize` mapeia todos os valores equivalentes "
"para um único representante:"

#: ../../library/decimal.rst:2148
msgid "Q. When does rounding occur in a computation?"
msgstr "P. Quando é que o arredondamento ocorre num cálculo?"

#: ../../library/decimal.rst:2150
msgid ""
"A. It occurs *after* the computation.  The philosophy of the decimal "
"specification is that numbers are considered exact and are created "
"independent of the current context.  They can even have greater precision "
"than current context.  Computations process with those exact inputs and then "
"rounding (or other context operations) is applied to the *result* of the "
"computation::"
msgstr ""
"R. Ocorre *depois* do cálculo. A filosofia da especificação decimal é que os "
"números são considerados exatos e são criados independentemente do contexto "
"atual. Eles podem até ter maior precisão do que o contexto atual. Os "
"cálculos processam-se com essas entradas exatas e depois o arredondamento "
"(ou outras operações de contexto) é aplicado ao *resultado* do cálculo::"

#: ../../library/decimal.rst:2157
msgid ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535')   # More than 5 digits\n"
">>> pi                             # All digits are retained\n"
"Decimal('3.1415926535')\n"
">>> pi + 0                         # Rounded after an addition\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005')        # Subtract unrounded numbers, then round\n"
"Decimal('3.1415')\n"
">>> pi + 0 - Decimal('0.00005').   # Intermediate values are rounded\n"
"Decimal('3.1416')"
msgstr ""
">>> getcontext().prec = 5\n"
">>> pi = Decimal('3.1415926535')   # Mais de 5 dígitos\n"
">>> pi                             # Todos os dígitos são retidos\n"
"Decimal('3.1415926535')\n"
">>> pi + 0                         # Arredondado após uma adição\n"
"Decimal('3.1416')\n"
">>> pi - Decimal('0.00005')        # Subtrair números não arredondados, "
"depois arredondar\n"
"Decimal('3.1415')\n"
">>> pi + 0 - Decimal('0.00005')    # Valores intermédios são arredondados\n"
"Decimal('3.1416')"

#: ../../library/decimal.rst:2168
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""
"P. Alguns valores decimais são sempre impressos com notação exponencial. "
"Existe uma forma de obter uma representação não exponencial?"

#: ../../library/decimal.rst:2171
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing "
"``5.0E+3`` as ``5000`` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""
"R. Para alguns valores, a notação exponencial é a única forma de expressar o "
"número de casas significativas no coeficiente. Por exemplo, expressar "
"``5.0E+3`` como ``5000`` mantém o valor constante, mas não pode mostrar a "
"significância de duas casas do original."

#: ../../library/decimal.rst:2176
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""
"Se uma aplicação não se preocupa em rastrear a significância, é fácil "
"remover o expoente e os zeros à direita, perdendo a significância, mas "
"mantendo o valor inalterado:"

#: ../../library/decimal.rst:2186
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""
"P. Existe uma forma de converter um float regular para um :class:`Decimal`?"

#: ../../library/decimal.rst:2188
msgid ""
"A. Yes, any binary floating-point number can be exactly expressed as a "
"Decimal though an exact conversion may take more precision than intuition "
"would suggest:"
msgstr ""
"R. Sim, qualquer número de vírgula flutuante binária pode ser expresso "
"exatamente como um Decimal, embora uma conversão exata possa exigir mais "
"precisão do que a intuição sugeriria:"

#: ../../library/decimal.rst:2192
msgid ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"
msgstr ""
">>> Decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"

#: ../../library/decimal.rst:2197
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""
"P. Dentro de um cálculo complexo, como posso ter a certeza de que não obtive "
"um resultado espúrio devido a precisão insuficiente ou anomalias de "
"arredondamento?"

#: ../../library/decimal.rst:2200
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""
"R. O módulo decimal facilita o teste de resultados. Uma boa prática é re-"
"executar cálculos usando maior precisão e com vários modos de "
"arredondamento. Resultados muito diferentes indicam precisão insuficiente, "
"problemas com o modo de arredondamento, entradas mal condicionadas ou um "
"algoritmo numericamete instável."

#: ../../library/decimal.rst:2205
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""
"P. Notei que a precisão do contexto é aplicada aos resultados das operações, "
"mas não às entradas. Existe algo a que deva estar atento ao misturar valores "
"de diferentes precisões?"

#: ../../library/decimal.rst:2209
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""

#: ../../library/decimal.rst:2214
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"

#: ../../library/decimal.rst:2222
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""
"A solução é aumentar a precisão ou forçar o arredondamento das entradas "
"usando a operação de mais unário:"

#: ../../library/decimal.rst:2225
msgid ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # unary plus triggers rounding\n"
"Decimal('1.23')"
msgstr ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # mais unário desencadeia arredondamento\n"
"Decimal('1.23')"

#: ../../library/decimal.rst:2231
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""
"Alternativamente, as entradas podem ser arredondadas na criação usando o "
"método :meth:`Context.create_decimal`:"

#: ../../library/decimal.rst:2237
msgid "Q. Is the CPython implementation fast for large numbers?"
msgstr "P. A implementação CPython é rápida para números grandes?"

#: ../../library/decimal.rst:2239
msgid ""
"A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of "
"the decimal module integrate the high speed `libmpdec <https://www.bytereef."
"org/mpdecimal/doc/libmpdec/index.html>`_ library for arbitrary precision "
"correctly rounded decimal floating-point arithmetic [#]_. ``libmpdec`` uses "
"`Karatsuba multiplication <https://en.wikipedia.org/wiki/"
"Karatsuba_algorithm>`_ for medium-sized numbers and the `Number Theoretic "
"Transform <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ for very "
"large numbers."
msgstr ""
"R. Sim. Nas implementações CPython e PyPy3, as versões C/CFFI do módulo "
"decimal integram a biblioteca de alta velocidade `libmpdec <https://www."
"bytereef.org/mpdecimal/doc/libmpdec/index.html>`_ para aritmética decimal de "
"vírgula flutuante de precisão arbitrária corretamente arredondada [#]_. "
"``libmpdec`` usa a `multiplicação de Karatsuba <https://en.wikipedia.org/"
"wiki/Karatsuba_algorithm>`_ para números de tamanho médio e a `Transformada "
"Teórica dos Números <https://en.wikipedia.org/wiki/"
"Discrete_Fourier_transform_(general)#Number-theoretic_transform>`_ para "
"números muito grandes."

#: ../../library/decimal.rst:2249
msgid ""
"The context must be adapted for exact arbitrary precision arithmetic. :attr:"
"`~Context.Emin` and :attr:`~Context.Emax` should always be set to the "
"maximum values, :attr:`~Context.clamp` should always be 0 (the default).  "
"Setting :attr:`~Context.prec` requires some care."
msgstr ""
"O contexto deve ser adaptado para aritmética de precisão arbitrária exata. :"
"attr:`~Context.Emin` e :attr:`~Context.Emax` devem sempre ser definidos para "
"os valores máximos, :attr:`~Context.clamp` deve sempre ser 0 (o "
"predefinido). Definir :attr:`~Context.prec` requer algum cuidado."

#: ../../library/decimal.rst:2253
msgid ""
"The easiest approach for trying out bignum arithmetic is to use the maximum "
"value for :attr:`~Context.prec` as well [#]_::"
msgstr ""
"A abordagem mais fácil para experimentar aritmética bignum é usar também o "
"valor máximo para :attr:`~Context.prec` [#]_:"

#: ../../library/decimal.rst:2256
msgid ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"
msgstr ""
">>> setcontext(Context(prec=MAX_PREC, Emax=MAX_EMAX, Emin=MIN_EMIN))\n"
">>> x = Decimal(2) ** 256\n"
">>> x / 128\n"
"Decimal('904625697166532776746648320380374280103671755200316906558262375061821325312')"

#: ../../library/decimal.rst:2262
msgid ""
"For inexact results, :const:`MAX_PREC` is far too large on 64-bit platforms "
"and the available memory will be insufficient::"
msgstr ""
"Para resultados inexatos, :const:`MAX_PREC` é demasiado grande em "
"plataformas de 64-bit e a memória disponível será insuficiente::"

#: ../../library/decimal.rst:2265
msgid ""
">>> Decimal(1) / 3\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"MemoryError"
msgstr ""
">>> Decimal(1) / 3\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"MemoryError"

#: ../../library/decimal.rst:2270
msgid ""
"On systems with overallocation (e.g. Linux), a more sophisticated approach "
"is to adjust :attr:`~Context.prec` to the amount of available RAM.  Suppose "
"that you have 8GB of RAM and expect 10 simultaneous operands using a maximum "
"of 500MB each::"
msgstr ""
"Em sistemas com sobrealocação (por exemplo, Linux), uma abordagem mais "
"sofisticada é ajustar :attr:`~Context.prec` à quantidade de RAM disponível. "
"Suponha que tem 8GB de RAM e espera 10 operandos simultâneos usando um "
"máximo de 500MB cada::"

#: ../../library/decimal.rst:2274
msgid ""
">>> import sys\n"
">>>\n"
">>> # Maximum number of digits for a single operand using 500MB in 8-byte "
"words\n"
">>> # with 19 digits per word (4-byte and 9 digits for the 32-bit build):\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # Check that this works:\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # Fill the available precision with nines:\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"
msgstr ""
">>> import sys\n"
">>>\n"
">>> # Número máximo de dígitos para um único operando usando 500MB em "
"palavras de 8-byte\n"
">>> # com 19 dígitos por palavra (4-byte e 9 dígitos para a construção de 32-"
"bit):\n"
">>> maxdigits = 19 * ((500 * 1024**2) // 8)\n"
">>>\n"
">>> # Verificar que isto funciona:\n"
">>> c = Context(prec=maxdigits, Emax=MAX_EMAX, Emin=MIN_EMIN)\n"
">>> c.traps[Inexact] = True\n"
">>> setcontext(c)\n"
">>>\n"
">>> # Preencher a precisão disponível com noves:\n"
">>> x = Decimal(0).logical_invert() * 9\n"
">>> sys.getsizeof(x)\n"
"524288112\n"
">>> x + 2\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  decimal.Inexact: [<class 'decimal.Inexact'>]"

#: ../../library/decimal.rst:2294
msgid ""
"In general (and especially on systems without overallocation), it is "
"recommended to estimate even tighter bounds and set the :attr:`Inexact` trap "
"if all calculations are expected to be exact."
msgstr ""
"Em geral (e especialmente em sistemas sem sobrealocação), é recomendado "
"estimar limites ainda mais apertados e definir a armadilha :attr:`Inexact` "
"se todos os cálculos forem esperados como exatos."

#: ../../library/decimal.rst:2303
msgid ""
"This approach now works for all exact results except for non-integer powers."
msgstr ""
"Esta abordagem agora funciona para todos os resultados exatos, exceto para "
"potências não inteiras."
