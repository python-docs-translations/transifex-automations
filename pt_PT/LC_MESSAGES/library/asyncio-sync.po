# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-03 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/asyncio-sync.rst:7
msgid "Synchronization Primitives"
msgstr "Primitivas de sincronização"

#: ../../library/asyncio-sync.rst:9
msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**Código-fonte:** :source:`Lib/asyncio/locks.py`"

#: ../../library/asyncio-sync.rst:13
msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr ""
"As primitivas de sincronização do asyncio foram concebidas para serem "
"semelhantes às do módulo :mod:`threading`, com duas ressalvas importantes:"

#: ../../library/asyncio-sync.rst:16
msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""
"as primitivas do asyncio não são *thread-safe*, pelo que não devem ser "
"usadas para sincronização de *threads* do sistema operativo (utilize :mod:"
"`threading` para isso);"

#: ../../library/asyncio-sync.rst:20
msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr ""
"os métodos destas primitivas de sincronização não aceitam o argumento "
"*timeout*; utilize a função :func:`asyncio.wait_for` para realizar operações "
"com *timeouts*."

#: ../../library/asyncio-sync.rst:24
msgid "asyncio has the following basic synchronization primitives:"
msgstr "O asyncio possui as seguintes primitivas básicas de sincronização:"

#: ../../library/asyncio-sync.rst:26
msgid ":class:`Lock`"
msgstr ":class:`Lock`"

#: ../../library/asyncio-sync.rst:27
msgid ":class:`Event`"
msgstr ":class:`Event`"

#: ../../library/asyncio-sync.rst:28
msgid ":class:`Condition`"
msgstr ":class:`Condition`"

#: ../../library/asyncio-sync.rst:29
msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

#: ../../library/asyncio-sync.rst:30
msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

#: ../../library/asyncio-sync.rst:31
msgid ":class:`Barrier`"
msgstr ":class:`Barrier`"

#: ../../library/asyncio-sync.rst:38
msgid "Lock"
msgstr "Bloqueio"

#: ../../library/asyncio-sync.rst:42
msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr ""
"Implementa um bloqueio mútuo (*mutex*) para tarefas asyncio. Não é *thread-"
"safe*."

#: ../../library/asyncio-sync.rst:44
msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""
"Um bloqueio asyncio pode ser usado para garantir acesso exclusivo a um "
"recurso partilhado."

#: ../../library/asyncio-sync.rst:47
msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""
"A forma preferencial de usar um bloqueio é com a instrução :keyword:`async "
"with`::"

#: ../../library/asyncio-sync.rst:50
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"async with lock:\n"
"    # access shared state"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... mais tarde\n"
"async with lock:\n"
"    # aceder ao estado partilhado"

#: ../../library/asyncio-sync.rst:56 ../../library/asyncio-sync.rst:201
#: ../../library/asyncio-sync.rst:309
msgid "which is equivalent to::"
msgstr "que é equivalente a::"

#: ../../library/asyncio-sync.rst:58
msgid ""
"lock = asyncio.Lock()\n"
"\n"
"# ... later\n"
"await lock.acquire()\n"
"try:\n"
"    # access shared state\n"
"finally:\n"
"    lock.release()"
msgstr ""
"lock = asyncio.Lock()\n"
"\n"
"# ... mais tarde\n"
"await lock.acquire()\n"
"try:\n"
"    # aceder ao estado partilhado\n"
"finally:\n"
"    lock.release()"

#: ../../library/asyncio-sync.rst:67 ../../library/asyncio-sync.rst:113
#: ../../library/asyncio-sync.rst:189 ../../library/asyncio-sync.rst:297
#: ../../library/asyncio-sync.rst:353
msgid "Removed the *loop* parameter."
msgstr "Removido o parâmetro *loop*."

#: ../../library/asyncio-sync.rst:73
msgid "Acquire the lock."
msgstr "Adquire o bloqueio."

#: ../../library/asyncio-sync.rst:75
msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""
"Este método aguarda até que o bloqueio esteja *desbloqueado*, define-o como "
"*bloqueado* e devolve ``True``."

#: ../../library/asyncio-sync.rst:78
msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr ""
"Quando mais do que uma corrotina está bloqueada em :meth:`acquire` à espera "
"que o bloqueio seja desbloqueado, apenas uma corrotina prossegue."

#: ../../library/asyncio-sync.rst:82
msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr ""
"A aquisição de um bloqueio é *justa*: a corrotina que prossegue será a "
"primeira que começou a esperar pelo bloqueio."

#: ../../library/asyncio-sync.rst:87
msgid "Release the lock."
msgstr "Liberta o bloqueio."

#: ../../library/asyncio-sync.rst:89
msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr ""
"Quando o bloqueio está *bloqueado*, redefine-o para *desbloqueado* e devolve."

#: ../../library/asyncio-sync.rst:91
msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr ""
"Se o bloqueio estiver *desbloqueado*, é levantada uma exceção :exc:"
"`RuntimeError`."

#: ../../library/asyncio-sync.rst:95
msgid "Return ``True`` if the lock is *locked*."
msgstr "Devolve ``True`` se o bloqueio estiver *bloqueado*."

#: ../../library/asyncio-sync.rst:99
msgid "Event"
msgstr "Evento"

#: ../../library/asyncio-sync.rst:103
msgid "An event object.  Not thread-safe."
msgstr "Um objeto de evento. Não é *thread-safe*."

#: ../../library/asyncio-sync.rst:105
msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""
"Um evento asyncio pode ser usado para notificar várias tarefas asyncio de "
"que algum evento ocorreu."

#: ../../library/asyncio-sync.rst:108
msgid ""
"An Event object manages an internal flag that can be set to *true* with the :"
"meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Um objeto Evento gere uma *flag* interna que pode ser definida como "
"*verdadeira* com o método :meth:`~Event.set` e redefinida como *falsa* com o "
"método :meth:`clear`. O método :meth:`~Event.wait` bloqueia até que a *flag* "
"seja definida como *verdadeira*. A *flag* é definida como *falsa* "
"inicialmente."

#: ../../library/asyncio-sync.rst:118 ../../library/asyncio-sync.rst:377
msgid "Example::"
msgstr "Exemplo::"

#: ../../library/asyncio-sync.rst:120
msgid ""
"async def waiter(event):\n"
"    print('waiting for it ...')\n"
"    await event.wait()\n"
"    print('... got it!')\n"
"\n"
"async def main():\n"
"    # Create an Event object.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Spawn a Task to wait until 'event' is set.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Sleep for 1 second and set the event.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Wait until the waiter task is finished.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def waiter(event):\n"
"    print('à espera ...')\n"
"    await event.wait()\n"
"    print('... obtido!')\n"
"\n"
"async def main():\n"
"    # Criar um objeto Evento.\n"
"    event = asyncio.Event()\n"
"\n"
"    # Criar uma tarefa para esperar até que 'event' seja definido.\n"
"    waiter_task = asyncio.create_task(waiter(event))\n"
"\n"
"    # Dormir 1 segundo e definir o evento.\n"
"    await asyncio.sleep(1)\n"
"    event.set()\n"
"\n"
"    # Esperar até que a tarefa de espera termine.\n"
"    await waiter_task\n"
"\n"
"asyncio.run(main())"

#: ../../library/asyncio-sync.rst:144
msgid "Wait until the event is set."
msgstr "Aguarda até que o evento seja definido."

#: ../../library/asyncio-sync.rst:146
msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr ""
"Se o evento estiver definido, devolve ``True`` imediatamente. Caso "
"contrário, bloqueia até que outra tarefa chame :meth:`~Event.set`."

#: ../../library/asyncio-sync.rst:151
msgid "Set the event."
msgstr "Define o evento."

#: ../../library/asyncio-sync.rst:153
msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""
"Todas as tarefas à espera de que o evento seja definido serão imediatamente "
"despertadas."

#: ../../library/asyncio-sync.rst:158
msgid "Clear (unset) the event."
msgstr "Limpa (redefine) o evento."

#: ../../library/asyncio-sync.rst:160
msgid ""
"Subsequent tasks awaiting on :meth:`~Event.wait` will now block until the :"
"meth:`~Event.set` method is called again."
msgstr ""
"As tarefas subsequentes à espera em :meth:`~Event.wait` bloquearão agora até "
"que o método :meth:`~Event.set` seja chamado novamente."

#: ../../library/asyncio-sync.rst:165
msgid "Return ``True`` if the event is set."
msgstr "Devolve ``True`` se o evento estiver definido."

#: ../../library/asyncio-sync.rst:169
msgid "Condition"
msgstr "Condição"

#: ../../library/asyncio-sync.rst:173
msgid "A Condition object.  Not thread-safe."
msgstr "Um objeto Condição. Não é *thread-safe*."

#: ../../library/asyncio-sync.rst:175
msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr ""
"Uma primitiva de condição asyncio pode ser usada por uma tarefa para esperar "
"que algum evento ocorra e, em seguida, obter acesso exclusivo a um recurso "
"partilhado."

#: ../../library/asyncio-sync.rst:179
msgid ""
"In essence, a Condition object combines the functionality of an :class:"
"`Event` and a :class:`Lock`.  It is possible to have multiple Condition "
"objects share one Lock, which allows coordinating exclusive access to a "
"shared resource between different tasks interested in particular states of "
"that shared resource."
msgstr ""
"Em essência, um objeto Condição combina a funcionalidade de um :class:"
"`Event` e um :class:`Lock`. É possível ter vários objetos Condição a "
"partilhar um Bloqueio, o que permite coordenar o acesso exclusivo a um "
"recurso partilhado entre diferentes tarefas interessadas em estados "
"particulares desse recurso."

#: ../../library/asyncio-sync.rst:185
msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In "
"the latter case a new Lock object is created automatically."
msgstr ""
"O argumento opcional *lock* deve ser um objeto :class:`Lock` ou ``None``. "
"Neste último caso, um novo objeto Bloqueio é criado automaticamente."

#: ../../library/asyncio-sync.rst:192
msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr ""
"A forma preferencial de usar uma Condição é com a instrução :keyword:`async "
"with`::"

#: ../../library/asyncio-sync.rst:195
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"async with cond:\n"
"    await cond.wait()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... mais tarde\n"
"async with cond:\n"
"    await cond.wait()"

#: ../../library/asyncio-sync.rst:203
msgid ""
"cond = asyncio.Condition()\n"
"\n"
"# ... later\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"
msgstr ""
"cond = asyncio.Condition()\n"
"\n"
"# ... mais tarde\n"
"await cond.acquire()\n"
"try:\n"
"    await cond.wait()\n"
"finally:\n"
"    cond.release()"

#: ../../library/asyncio-sync.rst:215
msgid "Acquire the underlying lock."
msgstr "Adquire o bloqueio subjacente."

#: ../../library/asyncio-sync.rst:217
msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""
"Este método aguarda até que o bloqueio subjacente esteja *desbloqueado*, "
"define-o como *bloqueado* e devolve ``True``."

#: ../../library/asyncio-sync.rst:222
msgid ""
"Wake up *n* tasks (1 by default) waiting on this condition.  If fewer than "
"*n* tasks are waiting they are all awakened."
msgstr ""
"Desperta *n* tarefas (1 por predefinição) à espera nesta condição. Se menos "
"de *n* tarefas estiverem à espera, todas são despertadas."

#: ../../library/asyncio-sync.rst:225 ../../library/asyncio-sync.rst:240
msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"O bloqueio deve ser adquirido antes de este método ser chamado e libertado "
"pouco depois. Se for chamado com um bloqueio *desbloqueado*, é levantada uma "
"exceção :exc:`RuntimeError`."

#: ../../library/asyncio-sync.rst:231
msgid "Return ``True`` if the underlying lock is acquired."
msgstr "Devolve ``True`` se o bloqueio subjacente estiver adquirido."

#: ../../library/asyncio-sync.rst:235
msgid "Wake up all tasks waiting on this condition."
msgstr "Desperta todas as tarefas à espera nesta condição."

#: ../../library/asyncio-sync.rst:237
msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""
"Este método age como :meth:`notify`, mas desperta todas as tarefas à espera."

#: ../../library/asyncio-sync.rst:246
msgid "Release the underlying lock."
msgstr "Liberta o bloqueio subjacente."

#: ../../library/asyncio-sync.rst:248
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"Quando invocado num bloqueio desbloqueado, é levantada uma exceção :exc:"
"`RuntimeError`."

#: ../../library/asyncio-sync.rst:254
msgid "Wait until notified."
msgstr "Aguarda até ser notificado."

#: ../../library/asyncio-sync.rst:256
msgid ""
"If the calling task has not acquired the lock when this method is called, a :"
"exc:`RuntimeError` is raised."
msgstr ""
"Se a tarefa chamadora não tiver adquirido o bloqueio quando este método é "
"chamado, é levantada uma exceção :exc:`RuntimeError`."

#: ../../library/asyncio-sync.rst:259
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"Este método liberta o bloqueio subjacente e, em seguida, bloqueia até ser "
"despertado por uma chamada a :meth:`notify` ou :meth:`notify_all`. Assim que "
"despertado, a Condição readquire o seu bloqueio e este método devolve "
"``True``."

#: ../../library/asyncio-sync.rst:264
msgid ""
"Note that a task *may* return from this call spuriously, which is why the "
"caller should always re-check the state and be prepared to :meth:`~Condition."
"wait` again. For this reason, you may prefer to use :meth:`~Condition."
"wait_for` instead."
msgstr ""
"Note que uma tarefa *pode* retornar desta chamada de forma espúria, razão "
"pela qual o chamador deve sempre reverificar o estado e estar preparado para "
"chamar :meth:`~Condition.wait` novamente. Por esta razão, pode preferir "
"usar :meth:`~Condition.wait_for` em vez disso."

#: ../../library/asyncio-sync.rst:272
msgid "Wait until a predicate becomes *true*."
msgstr "Aguarda até que um predicado se torne *verdadeiro*."

#: ../../library/asyncio-sync.rst:274
msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The method will repeatedly :meth:`~Condition.wait` until the "
"predicate evaluates to *true*. The final value is the return value."
msgstr ""
"O predicado deve ser um objeto invocável cujo resultado será interpretado "
"como um valor booleano. O método chamará repetidamente :meth:`~Condition."
"wait` até que o predicado avalie como *verdadeiro*. O valor final é o valor "
"de retorno."

#: ../../library/asyncio-sync.rst:281
msgid "Semaphore"
msgstr "Semáforo"

#: ../../library/asyncio-sync.rst:285
msgid "A Semaphore object.  Not thread-safe."
msgstr "Um objeto Semáforo. Não é *thread-safe*."

#: ../../library/asyncio-sync.rst:287
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call. The counter can "
"never go below zero; when :meth:`acquire` finds that it is zero, it blocks, "
"waiting until some task calls :meth:`release`."
msgstr ""
"Um semáforo gere um contador interno que é decrementado por cada chamada a :"
"meth:`acquire` e incrementado por cada chamada a :meth:`release`. O contador "
"nunca pode ser inferior a zero; quando :meth:`acquire` verifica que é zero, "
"bloqueia, aguardando até que alguma tarefa chame :meth:`release`."

#: ../../library/asyncio-sync.rst:293
msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a :exc:"
"`ValueError` is raised."
msgstr ""
"O argumento opcional *value* define o valor inicial para o contador interno "
"(``1`` por predefinição). Se o valor fornecido for inferior a ``0``, é "
"levantada uma exceção :exc:`ValueError`."

#: ../../library/asyncio-sync.rst:300
msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr ""
"A forma preferencial de usar um Semáforo é com a instrução :keyword:`async "
"with`::"

#: ../../library/asyncio-sync.rst:303
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"async with sem:\n"
"    # work with shared resource"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... mais tarde\n"
"async with sem:\n"
"    # trabalhar com o recurso partilhado"

#: ../../library/asyncio-sync.rst:311
msgid ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... later\n"
"await sem.acquire()\n"
"try:\n"
"    # work with shared resource\n"
"finally:\n"
"    sem.release()"
msgstr ""
"sem = asyncio.Semaphore(10)\n"
"\n"
"# ... mais tarde\n"
"await sem.acquire()\n"
"try:\n"
"    # trabalhar com o recurso partilhado\n"
"finally:\n"
"    sem.release()"

#: ../../library/asyncio-sync.rst:323
msgid "Acquire a semaphore."
msgstr "Adquire um semáforo."

#: ../../library/asyncio-sync.rst:325
msgid ""
"If the internal counter is greater than zero, decrement it by one and return "
"``True`` immediately.  If it is zero, wait until a :meth:`release` is called "
"and return ``True``."
msgstr ""
"Se o contador interno for maior que zero, decrementa-o em um e devolve "
"``True`` imediatamente. Se for zero, aguarda até que :meth:`release` seja "
"chamado e devolve ``True``."

#: ../../library/asyncio-sync.rst:331
msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "Devolve ``True`` se o semáforo não puder ser adquirido imediatamente."

#: ../../library/asyncio-sync.rst:335
msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a "
"task waiting to acquire the semaphore."
msgstr ""
"Liberta um semáforo, incrementando o contador interno em um. Pode despertar "
"uma tarefa à espera de adquirir o semáforo."

#: ../../library/asyncio-sync.rst:338
msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
"Ao contrário de :class:`BoundedSemaphore`, :class:`Semaphore` permite fazer "
"mais chamadas a ``release()`` do que a ``acquire()``."

#: ../../library/asyncio-sync.rst:343
msgid "BoundedSemaphore"
msgstr "SemáforoLimitado"

#: ../../library/asyncio-sync.rst:347
msgid "A bounded semaphore object.  Not thread-safe."
msgstr "Um objeto SemáforoLimitado. Não é *thread-safe*."

#: ../../library/asyncio-sync.rst:349
msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a :exc:"
"`ValueError` in :meth:`~Semaphore.release` if it increases the internal "
"counter above the initial *value*."
msgstr ""
"Bounded Semaphore é uma versão de :class:`Semaphore` que levanta uma "
"exceção :exc:`ValueError` em :meth:`~Semaphore.release` se aumentar o "
"contador interno acima do *valor* inicial."

#: ../../library/asyncio-sync.rst:358
msgid "Barrier"
msgstr "Barreira"

#: ../../library/asyncio-sync.rst:362
msgid "A barrier object.  Not thread-safe."
msgstr "Um objeto Barreira. Não é *thread-safe*."

#: ../../library/asyncio-sync.rst:364
msgid ""
"A barrier is a simple synchronization primitive that allows to block until "
"*parties* number of tasks are waiting on it. Tasks can wait on the :meth:"
"`~Barrier.wait` method and would be blocked until the specified number of "
"tasks end up waiting on :meth:`~Barrier.wait`. At that point all of the "
"waiting tasks would unblock simultaneously."
msgstr ""
"Uma barreira é uma primitiva de sincronização simples que permite bloquear "
"até que um número de *parties* de tarefas esteja à sua espera. As tarefas "
"podem esperar no método :meth:`~Barrier.wait` e serão bloqueadas até que o "
"número especificado de tarefas acabe por esperar em :meth:`~Barrier.wait`. "
"Nesse momento, todas as tarefas à espera serão desbloqueadas simultaneamente."

#: ../../library/asyncio-sync.rst:370
msgid ""
":keyword:`async with` can be used as an alternative to awaiting on :meth:"
"`~Barrier.wait`."
msgstr ""
":keyword:`async with` pode ser usado como alternativa a aguardar em :meth:"
"`~Barrier.wait`."

#: ../../library/asyncio-sync.rst:373
msgid "The barrier can be reused any number of times."
msgstr "A barreira pode ser reutilizada qualquer número de vezes."

#: ../../library/asyncio-sync.rst:379
msgid ""
"async def example_barrier():\n"
"   # barrier with 3 parties\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # create 2 new waiting tasks\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # The third .wait() call passes the barrier\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barrier passed\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"
msgstr ""
"async def example_barrier():\n"
"   # barreira com 3 participantes\n"
"   b = asyncio.Barrier(3)\n"
"\n"
"   # criar 2 novas tarefas à espera\n"
"   asyncio.create_task(b.wait())\n"
"   asyncio.create_task(b.wait())\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"   # A terceira chamada a .wait() ultrapassa a barreira\n"
"   await b.wait()\n"
"   print(b)\n"
"   print(\"barreira ultrapassada\")\n"
"\n"
"   await asyncio.sleep(0)\n"
"   print(b)\n"
"\n"
"asyncio.run(example_barrier())"

#: ../../library/asyncio-sync.rst:400
msgid "Result of this example is::"
msgstr "O resultado deste exemplo é::"

#: ../../library/asyncio-sync.rst:402
msgid ""
"<asyncio.locks.Barrier object at 0x... [filling, waiters:2/3]>\n"
"<asyncio.locks.Barrier object at 0x... [draining, waiters:0/3]>\n"
"barrier passed\n"
"<asyncio.locks.Barrier object at 0x... [filling, waiters:0/3]>"
msgstr ""
"<objeto asyncio.locks.Barrier em 0x... [a encher, à espera:2/3]>\n"
"<objeto asyncio.locks.Barrier em 0x... [a esvaziar, à espera:0/3]>\n"
"barreira ultrapassada\n"
"<objeto asyncio.locks.Barrier em 0x... [a encher, à espera:0/3]>"

#: ../../library/asyncio-sync.rst:412
msgid ""
"Pass the barrier. When all the tasks party to the barrier have called this "
"function, they are all unblocked simultaneously."
msgstr ""
"Ultrapassa a barreira. Quando todas as tarefas participantes na barreira "
"chamarem esta função, todas são desbloqueadas simultaneamente."

#: ../../library/asyncio-sync.rst:415
msgid ""
"When a waiting or blocked task in the barrier is cancelled, this task exits "
"the barrier which stays in the same state. If the state of the barrier is "
"\"filling\", the number of waiting task decreases by 1."
msgstr ""
"Quando uma tarefa à espera ou bloqueada na barreira é cancelada, esta tarefa "
"sai da barreira, que permanece no mesmo estado. Se o estado da barreira for "
"\"a encher\", o número de tarefas à espera diminui em 1."

#: ../../library/asyncio-sync.rst:420
msgid ""
"The return value is an integer in the range of 0 to ``parties-1``, different "
"for each task. This can be used to select a task to do some special "
"housekeeping, e.g.::"
msgstr ""
"O valor de retorno é um inteiro no intervalo de 0 a ``parties-1``, diferente "
"para cada tarefa. Isto pode ser usado para selecionar uma tarefa para fazer "
"alguma manutenção especial, por exemplo::"

#: ../../library/asyncio-sync.rst:424
msgid ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Only one task prints this\n"
"      print('End of *draining phase*')"
msgstr ""
"...\n"
"async with barrier as position:\n"
"   if position == 0:\n"
"      # Apenas uma tarefa imprime isto\n"
"      print('Fim da *fase de esvaziamento*')"

#: ../../library/asyncio-sync.rst:430
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a task is waiting. It could raise a :exc:"
"`CancelledError` if a task is cancelled."
msgstr ""
"Este método pode levantar uma exceção :class:`BrokenBarrierError` se a "
"barreira for quebrada ou reiniciada enquanto uma tarefa está à espera. Pode "
"levantar uma exceção :exc:`CancelledError` se uma tarefa for cancelada."

#: ../../library/asyncio-sync.rst:437
msgid ""
"Return the barrier to the default, empty state.  Any tasks waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Devolve a barreira ao estado predefinido, vazio. Todas as tarefas à sua "
"espera receberão a exceção :class:`BrokenBarrierError`."

#: ../../library/asyncio-sync.rst:440
msgid ""
"If a barrier is broken it may be better to just leave it and create a new "
"one."
msgstr ""
"Se uma barreira estiver quebrada, pode ser melhor deixá-la e criar uma nova."

#: ../../library/asyncio-sync.rst:445
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`~Barrier.wait` to fail with the :class:`BrokenBarrierError`. Use "
"this for example if one of the tasks needs to abort, to avoid infinite "
"waiting tasks."
msgstr ""
"Coloca a barreira num estado quebrado. Isto faz com que quaisquer chamadas "
"ativas ou futuras a :meth:`~Barrier.wait` falhem com a exceção :class:"
"`BrokenBarrierError`. Utilize isto, por exemplo, se uma das tarefas precisar "
"de abortar, para evitar tarefas em espera infinita."

#: ../../library/asyncio-sync.rst:452
msgid "The number of tasks required to pass the barrier."
msgstr "O número de tarefas necessárias para ultrapassar a barreira."

#: ../../library/asyncio-sync.rst:456
msgid "The number of tasks currently waiting in the barrier while filling."
msgstr ""
"O número de tarefas atualmente à espera na barreira enquanto esta está a "
"encher."

#: ../../library/asyncio-sync.rst:460
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr "Um booleano que é ``True`` se a barreira estiver no estado quebrado."

#: ../../library/asyncio-sync.rst:465
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Esta exceção, uma subclasse de :exc:`RuntimeError`, é levantada quando o "
"objeto :class:`Barrier` é reiniciado ou quebrado."

#: ../../library/asyncio-sync.rst:473
msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or :keyword:"
"`with` statement (``with await lock``, ``with (yield from lock)``) was "
"removed.  Use ``async with lock`` instead."
msgstr ""
"A aquisição de um bloqueio usando ``await lock`` ou ``yield from lock`` e/ou "
"a instrução :keyword:`with` (``with await lock``, ``with (yield from "
"lock)``) foi removida. Utilize ``async with lock`` em vez disso."
