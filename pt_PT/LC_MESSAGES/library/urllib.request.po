# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-21 14:14+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/urllib.request.rst:2
msgid ":mod:`!urllib.request` --- Extensible library for opening URLs"
msgstr ":mod:`!urllib.request` --- Biblioteca extensível para abrir URLs"

#: ../../library/urllib.request.rst:11
msgid "**Source code:** :source:`Lib/urllib/request.py`"
msgstr "**Código-fonte:** :source:`Lib/urllib/request.py`"

#: ../../library/urllib.request.rst:15
msgid ""
"The :mod:`urllib.request` module defines functions and classes which help in "
"opening URLs (mostly HTTP) in a complex world --- basic and digest "
"authentication, redirections, cookies and more."
msgstr ""
"O módulo :mod:`urllib.request` define funções e classes que ajudam a abrir "
"URLs (principalmente HTTP) num ambiente complexo — autenticação básica e "
"digest, redirecionamentos, cookies e mais."

#: ../../library/urllib.request.rst:21
msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"O pacote `Requests <https://requests.readthedocs.io/en/master/>`_ é "
"recomendado para uma interface de cliente HTTP de nível superior."

#: ../../library/urllib.request.rst:26
msgid ""
"On macOS it is unsafe to use this module in programs using :func:`os.fork` "
"because the :func:`getproxies` implementation for macOS uses a higher-level "
"system API. Set the environment variable ``no_proxy`` to ``*`` to avoid this "
"problem (e.g. ``os.environ[\"no_proxy\"] = \"*\"``)."
msgstr ""
"No macOS, não é seguro usar este módulo em programas que usam :func:`os."
"fork` porque a implementação de :func:`getproxies` para macOS usa uma API de "
"sistema de nível superior. Defina a variável de ambiente ``no_proxy`` para "
"``*`` para evitar este problema (por exemplo, ``os.environ[\"no_proxy\"] = "
"\"*\"``)."

#: ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Disponibilidade"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Este módulo não funciona ou não está disponível em WebAssembly. Consulte :"
"ref:`wasm-availability` para mais informações."

#: ../../library/urllib.request.rst:34
msgid "The :mod:`urllib.request` module defines the following functions:"
msgstr "O módulo :mod:`urllib.request` define as seguintes funções:"

#: ../../library/urllib.request.rst:39
msgid ""
"Open *url*, which can be either a string containing a valid, properly "
"encoded URL, or a :class:`Request` object."
msgstr ""
"Abre *url*, que pode ser uma string contendo uma URL válida e corretamente "
"codificada, ou um objeto :class:`Request`."

#: ../../library/urllib.request.rst:42
msgid ""
"*data* must be an object specifying additional data to be sent to the "
"server, or ``None`` if no such data is needed.  See :class:`Request` for "
"details."
msgstr ""
"*data* deve ser um objeto que especifica dados adicionais a serem enviados "
"para o servidor, ou ``None`` se não forem necessários tais dados. Veja :"
"class:`Request` para detalhes."

#: ../../library/urllib.request.rst:46
msgid ""
"urllib.request module uses HTTP/1.1 and includes ``Connection:close`` header "
"in its HTTP requests."
msgstr ""
"O módulo urllib.request usa HTTP/1.1 e inclui o cabeçalho ``Connection:"
"close`` nas suas requisições HTTP."

#: ../../library/urllib.request.rst:49
msgid ""
"The optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used).  This actually only works for HTTP, HTTPS and "
"FTP connections."
msgstr ""
"O parâmetro opcional *timeout* especifica um tempo limite em segundos para "
"operações de bloqueio como a tentativa de conexão (se não for especificado, "
"a configuração de tempo limite global padrão será usada). Isto na verdade só "
"funciona para conexões HTTP, HTTPS e FTP."

#: ../../library/urllib.request.rst:54
msgid ""
"If *context* is specified, it must be a :class:`ssl.SSLContext` instance "
"describing the various SSL options. See :class:`~http.client."
"HTTPSConnection` for more details."
msgstr ""
"Se *context* for especificado, deve ser uma instância :class:`ssl."
"SSLContext` que descreve as várias opções SSL. Veja :class:`~http.client."
"HTTPSConnection` para mais detalhes."

#: ../../library/urllib.request.rst:58
msgid ""
"This function always returns an object which can work as a :term:`context "
"manager` and has the properties *url*, *headers*, and *status*. See :class:"
"`urllib.response.addinfourl` for more detail on these properties."
msgstr ""
"Esta função sempre retorna um objeto que pode funcionar como um :term:"
"`gestor de contexto` e tem as propriedades *url*, *headers* e *status*. "
"Veja :class:`urllib.response.addinfourl` para mais detalhes sobre estas "
"propriedades."

#: ../../library/urllib.request.rst:62
msgid ""
"For HTTP and HTTPS URLs, this function returns a :class:`http.client."
"HTTPResponse` object slightly modified. In addition to the three new methods "
"above, the msg attribute contains the same information as the :attr:`~http."
"client.HTTPResponse.reason` attribute --- the reason phrase returned by "
"server --- instead of the response headers as it is specified in the "
"documentation for :class:`~http.client.HTTPResponse`."
msgstr ""
"Para URLs HTTP e HTTPS, esta função retorna um objeto :class:`http.client."
"HTTPResponse` ligeiramente modificado. Além dos três novos métodos acima, o "
"atributo msg contém a mesma informação que o atributo :attr:`~http.client."
"HTTPResponse.reason` — a frase de razão retornada pelo servidor — em vez dos "
"cabeçalhos de resposta como está especificado na documentação para :class:"
"`~http.client.HTTPResponse`."

#: ../../library/urllib.request.rst:70
msgid ""
"For FTP, file, and data URLs, this function returns a :class:`urllib."
"response.addinfourl` object."
msgstr ""
"Para URLs FTP, ficheiro e dados, esta função retorna um objeto :class:"
"`urllib.response.addinfourl`."

#: ../../library/urllib.request.rst:73
msgid "Raises :exc:`~urllib.error.URLError` on protocol errors."
msgstr "Levanta :exc:`~urllib.error.URLError` em erros de protocolo."

#: ../../library/urllib.request.rst:75
msgid ""
"Note that ``None`` may be returned if no handler handles the request (though "
"the default installed global :class:`OpenerDirector` uses :class:"
"`UnknownHandler` to ensure this never happens)."
msgstr ""
"Note que ``None`` pode ser retornado se nenhum manipulador tratar a "
"requisição (embora o :class:`OpenerDirector` global instalado por padrão "
"use :class:`UnknownHandler` para garantir que isto nunca aconteça)."

#: ../../library/urllib.request.rst:79
msgid ""
"In addition, if proxy settings are detected (for example, when a ``*_proxy`` "
"environment variable like :envvar:`!http_proxy` is set), :class:"
"`ProxyHandler` is default installed and makes sure the requests are handled "
"through the proxy."
msgstr ""
"Além disso, se as configurações de proxy forem detetadas (por exemplo, "
"quando uma variável de ambiente ``*_proxy`` como :envvar:`!http_proxy` está "
"definida), :class:`ProxyHandler` é instalado por padrão e garante que as "
"requisições sejam tratadas através do proxy."

#: ../../library/urllib.request.rst:84
msgid ""
"The legacy ``urllib.urlopen`` function from Python 2.6 and earlier has been "
"discontinued; :func:`urllib.request.urlopen` corresponds to the old "
"``urllib2.urlopen``.  Proxy handling, which was done by passing a dictionary "
"parameter to ``urllib.urlopen``, can be obtained by using :class:"
"`ProxyHandler` objects."
msgstr ""
"A função legada ``urllib.urlopen`` do Python 2.6 e anteriores foi "
"descontinuada; :func:`urllib.request.urlopen` corresponde ao antigo "
"``urllib2.urlopen``. O tratamento de proxy, que era feito passando um "
"parâmetro de dicionário para ``urllib.urlopen``, pode ser obtido usando "
"objetos :class:`ProxyHandler`."

#: ../../library/urllib.request.rst:90 ../../library/urllib.request.rst:92
msgid ""
"The default opener raises an :ref:`auditing event <auditing>` ``urllib."
"Request`` with arguments ``fullurl``, ``data``, ``headers``, ``method`` "
"taken from the request object."
msgstr ""
"O opener padrão levanta um :ref:`evento de auditoria <auditing>` ``urllib."
"Request`` com argumentos ``fullurl``, ``data``, ``headers``, ``method`` "
"obtidos do objeto de requisição."

#: ../../library/urllib.request.rst:96
msgid "*cafile* and *capath* were added."
msgstr "Os parâmetros *cafile* e *capath* foram adicionados."

#: ../../library/urllib.request.rst:99
msgid ""
"HTTPS virtual hosts are now supported if possible (that is, if :const:`ssl."
"HAS_SNI` is true)."
msgstr ""
"Os hosts virtuais HTTPS agora são suportados, se possível (ou seja, se :"
"const:`ssl.HAS_SNI` for verdadeiro)."

#: ../../library/urllib.request.rst:102
msgid "*data* can be an iterable object."
msgstr "*data* pode ser um objeto iterável."

#: ../../library/urllib.request.rst:104
msgid "*cadefault* was added."
msgstr "O parâmetro *cadefault* foi adicionado."

#: ../../library/urllib.request.rst:107
msgid "*context* was added."
msgstr "O parâmetro *context* foi adicionado."

#: ../../library/urllib.request.rst:110
msgid ""
"HTTPS connection now send an ALPN extension with protocol indicator "
"``http/1.1`` when no *context* is given. Custom *context* should set ALPN "
"protocols with :meth:`~ssl.SSLContext.set_alpn_protocols`."
msgstr ""
"A conexão HTTPS agora envia uma extensão ALPN com o indicador de protocolo "
"``http/1.1`` quando nenhum *context* é fornecido. O *context* personalizado "
"deve definir protocolos ALPN com :meth:`~ssl.SSLContext.set_alpn_protocols`."

#: ../../library/urllib.request.rst:115
msgid ""
"Remove *cafile*, *capath* and *cadefault* parameters: use the *context* "
"parameter instead."
msgstr ""
"Remover os parâmetros *cafile*, *capath* e *cadefault*: usar o parâmetro "
"*context* em vez disso."

#: ../../library/urllib.request.rst:122
msgid ""
"Install an :class:`OpenerDirector` instance as the default global opener. "
"Installing an opener is only necessary if you want urlopen to use that "
"opener; otherwise, simply call :meth:`OpenerDirector.open` instead of :func:"
"`~urllib.request.urlopen`.  The code does not check for a real :class:"
"`OpenerDirector`, and any class with the appropriate interface will work."
msgstr ""
"Instala uma instância :class:`OpenerDirector` como o opener global padrão. A "
"instalação de um opener só é necessária se quiser que o urlopen use esse "
"opener; caso contrário, basta chamar :meth:`OpenerDirector.open` em vez de :"
"func:`~urllib.request.urlopen`. O código não verifica se é um :class:"
"`OpenerDirector` real, e qualquer classe com a interface apropriada "
"funcionará."

#: ../../library/urllib.request.rst:132
msgid ""
"Return an :class:`OpenerDirector` instance, which chains the handlers in the "
"order given. *handler*\\s can be either instances of :class:`BaseHandler`, "
"or subclasses of :class:`BaseHandler` (in which case it must be possible to "
"call the constructor without any parameters).  Instances of the following "
"classes will be in front of the *handler*\\s, unless the *handler*\\s "
"contain them, instances of them or subclasses of them: :class:`ProxyHandler` "
"(if proxy settings are detected), :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."
msgstr ""
"Retorna uma instância :class:`OpenerDirector`, que encadeia os manipuladores "
"na ordem dada. *handler*\\s podem ser instâncias de :class:`BaseHandler`, ou "
"subclasses de :class:`BaseHandler` (caso em que deve ser possível chamar o "
"construtor sem quaisquer parâmetros). Instâncias das seguintes classes "
"estarão à frente dos *handler*\\s, a menos que os *handler*\\s as contenham, "
"instâncias delas ou subclasses delas: :class:`ProxyHandler` (se as "
"configurações de proxy forem detetadas), :class:`UnknownHandler`, :class:"
"`HTTPHandler`, :class:`HTTPDefaultErrorHandler`, :class:"
"`HTTPRedirectHandler`, :class:`FTPHandler`, :class:`FileHandler`, :class:"
"`HTTPErrorProcessor`."

#: ../../library/urllib.request.rst:142
msgid ""
"If the Python installation has SSL support (i.e., if the :mod:`ssl` module "
"can be imported), :class:`HTTPSHandler` will also be added."
msgstr ""
"Se a instalação do Python tiver suporte SSL (ou seja, se o módulo :mod:`ssl` "
"puder ser importado), :class:`HTTPSHandler` também será adicionado."

#: ../../library/urllib.request.rst:145
msgid ""
"A :class:`BaseHandler` subclass may also change its :attr:`handler_order` "
"attribute to modify its position in the handlers list."
msgstr ""
"Uma subclasse :class:`BaseHandler` também pode alterar o seu atributo :attr:"
"`handler_order` para modificar a sua posição na lista de manipuladores."

#: ../../library/urllib.request.rst:151
msgid ""
"Convert the given local path to a ``file:`` URL. This function uses :func:"
"`~urllib.parse.quote` function to encode the path."
msgstr ""
"Converte o caminho local dado para uma URL ``file:``. Esta função usa a "
"função :func:`~urllib.parse.quote` para codificar o caminho."

#: ../../library/urllib.request.rst:154
msgid ""
"If *add_scheme* is false (the default), the return value omits the ``file:`` "
"scheme prefix. Set *add_scheme* to true to return a complete URL."
msgstr ""
"Se *add_scheme* for falso (o padrão), o valor de retorno omite o prefixo do "
"esquema ``file:``. Defina *add_scheme* como verdadeiro para retornar uma URL "
"completa."

#: ../../library/urllib.request.rst:157 ../../library/urllib.request.rst:195
msgid "This example shows the function being used on Windows::"
msgstr "Este exemplo mostra a função a ser usada no Windows::"

#: ../../library/urllib.request.rst:159
msgid ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> pathname2url(path, add_scheme=True)\n"
"'file:///C:/Program%20Files'"
msgstr ""
">>> from urllib.request import pathname2url\n"
">>> path = 'C:\\\\Program Files'\n"
">>> pathname2url(path, add_scheme=True)\n"
"'file:///C:/Program%20Files'"

#: ../../library/urllib.request.rst:164 ../../library/urllib.request.rst:202
msgid ""
"Windows drive letters are no longer converted to uppercase, and ``:`` "
"characters not following a drive letter no longer cause an :exc:`OSError` "
"exception to be raised on Windows."
msgstr ""
"As letras de unidade do Windows já não são convertidas para maiúsculas, e os "
"caracteres ``:`` que não seguem uma letra de unidade já não causam uma "
"exceção :exc:`OSError` no Windows."

#: ../../library/urllib.request.rst:169
msgid ""
"Paths beginning with a slash are converted to URLs with authority sections. "
"For example, the path ``/etc/hosts`` is converted to the URL ``///etc/"
"hosts``."
msgstr ""
"Caminhos que começam com uma barra são convertidos para URLs com secções de "
"autoridade. Por exemplo, o caminho ``/etc/hosts`` é convertido para a URL "
"``///etc/hosts``."

#: ../../library/urllib.request.rst:174
msgid "The *add_scheme* parameter was added."
msgstr "O parâmetro *add_scheme* foi adicionado."

#: ../../library/urllib.request.rst:180
msgid ""
"Convert the given ``file:`` URL to a local path. This function uses :func:"
"`~urllib.parse.unquote` to decode the URL."
msgstr ""
"Converte a URL ``file:`` dada para um caminho local. Esta função usa :func:"
"`~urllib.parse.unquote` para decodificar a URL."

#: ../../library/urllib.request.rst:183
msgid ""
"If *require_scheme* is false (the default), the given value should omit a "
"``file:`` scheme prefix. If *require_scheme* is set to true, the given value "
"should include the prefix; a :exc:`~urllib.error.URLError` is raised if it "
"doesn't."
msgstr ""
"Se *require_scheme* for falso (o padrão), o valor dado deve omitir o prefixo "
"do esquema ``file:``. Se *require_scheme* for definido como verdadeiro, o "
"valor dado deve incluir o prefixo; uma exceção :exc:`~urllib.error.URLError` "
"é levantada se não o fizer."

#: ../../library/urllib.request.rst:188
msgid ""
"The URL authority is discarded if it is empty, ``localhost``, or the local "
"hostname. Otherwise, if *resolve_host* is set to true, the authority is "
"resolved using :func:`socket.gethostbyname` and discarded if it matches a "
"local IP address (as per :rfc:`RFC 8089 §3 <8089#section-3>`). If the "
"authority is still unhandled, then on Windows a UNC path is returned, and on "
"other platforms a :exc:`~urllib.error.URLError` is raised."
msgstr ""
"A autoridade da URL é descartada se estiver vazia, for ``localhost``, ou o "
"nome do host local. Caso contrário, se *resolve_host* for definido como "
"verdadeiro, a autoridade é resolvida usando :func:`socket.gethostbyname` e "
"descartada se corresponder a um endereço IP local (conforme :rfc:`RFC 8089 "
"§3 <8089#section-3>`). Se a autoridade ainda não for tratada, então no "
"Windows um caminho UNC é retornado, e em outras plataformas uma exceção :exc:"
"`~urllib.error.URLError` é levantada."

#: ../../library/urllib.request.rst:197
msgid ""
">>> from urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url, require_scheme=True)\n"
"'C:\\\\Program Files'"
msgstr ""
">>> from urllib.request import url2pathname\n"
">>> url = 'file:///C:/Program%20Files'\n"
">>> url2pathname(url, require_scheme=True)\n"
"'C:\\\\Program Files'"

#: ../../library/urllib.request.rst:207
msgid ""
"The URL authority is discarded if it matches the local hostname. Otherwise, "
"if the authority isn't empty or ``localhost``, then on Windows a UNC path is "
"returned (as before), and on other platforms a :exc:`~urllib.error.URLError` "
"is raised."
msgstr ""
"A autoridade da URL é descartada se corresponder ao nome do host local. Caso "
"contrário, se a autoridade não estiver vazia ou for ``localhost``, então no "
"Windows um caminho UNC é retornado (como antes), e em outras plataformas uma "
"exceção :exc:`~urllib.error.URLError` é levantada."

#: ../../library/urllib.request.rst:213
msgid "The URL query and fragment components are discarded if present."
msgstr ""
"Os componentes de consulta e fragmento da URL são descartados, se presentes."

#: ../../library/urllib.request.rst:216
msgid "The *require_scheme* and *resolve_host* parameters were added."
msgstr "Os parâmetros *require_scheme* e *resolve_host* foram adicionados."

#: ../../library/urllib.request.rst:222
msgid ""
"This helper function returns a dictionary of scheme to proxy server URL "
"mappings. It scans the environment for variables named ``<scheme>_proxy``, "
"in a case insensitive approach, for all operating systems first, and when it "
"cannot find it, looks for proxy information from System Configuration for "
"macOS and Windows Systems Registry for Windows. If both lowercase and "
"uppercase environment variables exist (and disagree), lowercase is preferred."
msgstr ""
"Esta função auxiliar retorna um dicionário de mapeamentos de esquema para "
"URL do servidor proxy. Ela verifica o ambiente para variáveis nomeadas "
"``<scheme>_proxy``, de forma insensível a maiúsculas e minúsculas, primeiro "
"para todos os sistemas operativos e, quando não a encontra, procura "
"informações de proxy na Configuração do Sistema para macOS e no Registo do "
"Sistema para Windows. Se existirem variáveis de ambiente em minúsculas e "
"maiúsculas (e discordarem), as minúsculas são preferidas."

#: ../../library/urllib.request.rst:232
msgid ""
"If the environment variable ``REQUEST_METHOD`` is set, which usually "
"indicates your script is running in a CGI environment, the environment "
"variable ``HTTP_PROXY`` (uppercase ``_PROXY``) will be ignored. This is "
"because that variable can be injected by a client using the \"Proxy:\" HTTP "
"header. If you need to use an HTTP proxy in a CGI environment, either use "
"``ProxyHandler`` explicitly, or make sure the variable name is in lowercase "
"(or at least the ``_proxy`` suffix)."
msgstr ""
"Se a variável de ambiente ``REQUEST_METHOD`` estiver definida, o que "
"geralmente indica que o seu script está a ser executado num ambiente CGI, a "
"variável de ambiente ``HTTP_PROXY`` (maiúsculas ``_PROXY``) será ignorada. "
"Isto porque essa variável pode ser injetada por um cliente usando o "
"cabeçalho HTTP \"Proxy:\". Se precisar de usar um proxy HTTP num ambiente "
"CGI, use explicitamente ``ProxyHandler``, ou certifique-se de que o nome da "
"variável está em minúsculas (ou pelo menos o sufixo ``_proxy``)."

#: ../../library/urllib.request.rst:241
msgid "The following classes are provided:"
msgstr "As seguintes classes são fornecidas:"

#: ../../library/urllib.request.rst:245
msgid "This class is an abstraction of a URL request."
msgstr "Esta classe é uma abstração de um pedido de URL."

#: ../../library/urllib.request.rst:247
msgid "*url* should be a string containing a valid, properly encoded URL."
msgstr ""
"*url* deve ser uma string contendo uma URL válida e corretamente codificada."

#: ../../library/urllib.request.rst:249
msgid ""
"*data* must be an object specifying additional data to send to the server, "
"or ``None`` if no such data is needed.  Currently HTTP requests are the only "
"ones that use *data*.  The supported object types include bytes, file-like "
"objects, and iterables of bytes-like objects. If no ``Content-Length`` nor "
"``Transfer-Encoding`` header field has been provided, :class:`HTTPHandler` "
"will set these headers according to the type of *data*.  ``Content-Length`` "
"will be used to send bytes objects, while ``Transfer-Encoding: chunked`` as "
"specified in :rfc:`7230`, Section 3.3.1 will be used to send files and other "
"iterables."
msgstr ""
"*data* deve ser um objeto que especifica dados adicionais a enviar para o "
"servidor, ou ``None`` se não forem necessários tais dados. Atualmente, "
"apenas os pedidos HTTP usam *data*. Os tipos de objetos suportados incluem "
"bytes, objetos semelhantes a ficheiros e iteráveis de objetos semelhantes a "
"bytes. Se nenhum campo de cabeçalho ``Content-Length`` ou ``Transfer-"
"Encoding`` tiver sido fornecido, :class:`HTTPHandler` definirá estes "
"cabeçalhos de acordo com o tipo de *data*. ``Content-Length`` será usado "
"para enviar objetos de bytes, enquanto ``Transfer-Encoding: chunked``, "
"conforme especificado em :rfc:`7230`, Secção 3.3.1, será usado para enviar "
"ficheiros e outros iteráveis."

#: ../../library/urllib.request.rst:259
msgid ""
"For an HTTP POST request method, *data* should be a buffer in the standard :"
"mimetype:`application/x-www-form-urlencoded` format.  The :func:`urllib."
"parse.urlencode` function takes a mapping or sequence of 2-tuples and "
"returns an ASCII string in this format. It should be encoded to bytes before "
"being used as the *data* parameter."
msgstr ""
"Para um método de pedido HTTP POST, *data* deve ser um buffer no formato "
"padrão :mimetype:`application/x-www-form-urlencoded`. A função :func:`urllib."
"parse.urlencode` recebe um mapeamento ou sequência de 2-tuplos e retorna uma "
"string ASCII neste formato. Deve ser codificada para bytes antes de ser "
"usada como o parâmetro *data*."

#: ../../library/urllib.request.rst:265
msgid ""
"*headers* should be a dictionary, and will be treated as if :meth:"
"`add_header` was called with each key and value as arguments. This is often "
"used to \"spoof\" the ``User-Agent`` header value, which is used by a "
"browser to identify itself -- some HTTP servers only allow requests coming "
"from common browsers as opposed to scripts. For example, Mozilla Firefox may "
"identify itself as ``\"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 "
"Firefox/2.0.0.11\"``, while :mod:`urllib`'s default user agent string is "
"``\"Python-urllib/2.6\"`` (on Python 2.6). All header keys are sent in camel "
"case."
msgstr ""
"*headers* deve ser um dicionário e será tratado como se :meth:`add_header` "
"fosse chamado com cada chave e valor como argumentos. Isto é frequentemente "
"usado para \"falsificar\" o valor do cabeçalho ``User-Agent``, que é usado "
"por um navegador para se identificar — alguns servidores HTTP só permitem "
"pedidos provenientes de navegadores comuns em oposição a scripts. Por "
"exemplo, o Mozilla Firefox pode identificar-se como ``\"Mozilla/5.0 (X11; U; "
"Linux i686) Gecko/20071127 Firefox/2.0.0.11\"``, enquanto a string de agente "
"de utilizador predefinida do :mod:`urllib` é ``\"Python-urllib/2.6\"`` (no "
"Python 2.6). Todas as chaves de cabeçalho são enviadas em camel case."

#: ../../library/urllib.request.rst:276
msgid ""
"An appropriate ``Content-Type`` header should be included if the *data* "
"argument is present.  If this header has not been provided and *data* is not "
"``None``, ``Content-Type: application/x-www-form-urlencoded`` will be added "
"as a default."
msgstr ""
"Um cabeçalho ``Content-Type`` apropriado deve ser incluído se o argumento "
"*data* estiver presente. Se este cabeçalho não tiver sido fornecido e *data* "
"não for ``None``, ``Content-Type: application/x-www-form-urlencoded`` será "
"adicionado como padrão."

#: ../../library/urllib.request.rst:281
msgid ""
"The next two arguments are only of interest for correct handling of third-"
"party HTTP cookies:"
msgstr ""
"Os próximos dois argumentos são apenas de interesse para o tratamento "
"correto de cookies HTTP de terceiros:"

#: ../../library/urllib.request.rst:284
msgid ""
"*origin_req_host* should be the request-host of the origin transaction, as "
"defined by :rfc:`2965`.  It defaults to ``http.cookiejar."
"request_host(self)``.  This is the host name or IP address of the original "
"request that was initiated by the user. For example, if the request is for "
"an image in an HTML document, this should be the request-host of the request "
"for the page containing the image."
msgstr ""
"*origin_req_host* deve ser o request-host da transação de origem, conforme "
"definido por :rfc:`2965`. O valor predefinido é ``http.cookiejar."
"request_host(self)``. Este é o nome do host ou endereço IP do pedido "
"original que foi iniciado pelo utilizador. Por exemplo, se o pedido for para "
"uma imagem num documento HTML, este deve ser o request-host do pedido para a "
"página que contém a imagem."

#: ../../library/urllib.request.rst:292
msgid ""
"*unverifiable* should indicate whether the request is unverifiable, as "
"defined by :rfc:`2965`.  It defaults to ``False``.  An unverifiable request "
"is one whose URL the user did not have the option to approve.  For example, "
"if the request is for an image in an HTML document, and the user had no "
"option to approve the automatic fetching of the image, this should be true."
msgstr ""
"*unverifiable* deve indicar se o pedido é não verificável, conforme definido "
"por :rfc:`2965`. O valor predefinido é ``False``. Um pedido não verificável "
"é aquele cuja URL o utilizador não teve a opção de aprovar. Por exemplo, se "
"o pedido for para uma imagem num documento HTML, e o utilizador não teve a "
"opção de aprovar a obtenção automática da imagem, isto deve ser verdadeiro."

#: ../../library/urllib.request.rst:299
msgid ""
"*method* should be a string that indicates the HTTP request method that will "
"be used (e.g. ``'HEAD'``).  If provided, its value is stored in the :attr:"
"`~Request.method` attribute and is used by :meth:`get_method`. The default "
"is ``'GET'`` if *data* is ``None`` or ``'POST'`` otherwise. Subclasses may "
"indicate a different default method by setting the :attr:`~Request.method` "
"attribute in the class itself."
msgstr ""
"*method* deve ser uma string que indica o método de pedido HTTP que será "
"usado (por exemplo, ``'HEAD'``). Se fornecido, o seu valor é armazenado no "
"atributo :attr:`~Request.method` e é usado por :meth:`get_method`. O valor "
"predefinido é ``'GET'`` se *data* for ``None`` ou ``'POST'`` caso contrário. "
"Subclasses podem indicar um método predefinido diferente definindo o "
"atributo :attr:`~Request.method` na própria classe."

#: ../../library/urllib.request.rst:307
msgid ""
"The request will not work as expected if the data object is unable to "
"deliver its content more than once (e.g. a file or an iterable that can "
"produce the content only once) and the request is retried for HTTP redirects "
"or authentication.  The *data* is sent to the HTTP server right away after "
"the headers.  There is no support for a 100-continue expectation in the "
"library."
msgstr ""
"O pedido não funcionará como esperado se o objeto de dados não puder "
"fornecer o seu conteúdo mais do que uma vez (por exemplo, um ficheiro ou um "
"iterável que só pode produzir o conteúdo uma vez) e o pedido for repetido "
"para redirecionamentos HTTP ou autenticação. Os *data* são enviados para o "
"servidor HTTP imediatamente após os cabeçalhos. Não há suporte para uma "
"expectativa de 100-continue na biblioteca."

#: ../../library/urllib.request.rst:314
msgid ":attr:`Request.method` argument is added to the Request class."
msgstr "O argumento :attr:`Request.method` foi adicionado à classe Request."

#: ../../library/urllib.request.rst:317
msgid "Default :attr:`Request.method` may be indicated at the class level."
msgstr ""
"O :attr:`Request.method` predefinido pode ser indicado ao nível da classe."

#: ../../library/urllib.request.rst:320
msgid ""
"Do not raise an error if the ``Content-Length`` has not been provided and "
"*data* is neither ``None`` nor a bytes object. Fall back to use chunked "
"transfer encoding instead."
msgstr ""
"Não levante um erro se o ``Content-Length`` não tiver sido fornecido e "
"*data* não for ``None`` nem um objeto de bytes. Em vez disso, recorra à "
"codificação de transferência em blocos."

#: ../../library/urllib.request.rst:327
msgid ""
"The :class:`OpenerDirector` class opens URLs via :class:`BaseHandler`\\ s "
"chained together. It manages the chaining of handlers, and recovery from "
"errors."
msgstr ""
"A classe :class:`OpenerDirector` abre URLs através de :class:"
"`BaseHandler`\\s encadeados. Ela gere o encadeamento dos manipuladores e a "
"recuperação de erros."

#: ../../library/urllib.request.rst:333
msgid ""
"This is the base class for all registered handlers --- and handles only the "
"simple mechanics of registration."
msgstr ""
"Esta é a classe base para todos os manipuladores registados — e trata apenas "
"da mecânica simples de registo."

#: ../../library/urllib.request.rst:339
msgid ""
"A class which defines a default handler for HTTP error responses; all "
"responses are turned into :exc:`~urllib.error.HTTPError` exceptions."
msgstr ""
"Uma classe que define um manipulador predefinido para respostas de erro "
"HTTP; todas as respostas são convertidas em exceções :exc:`~urllib.error."
"HTTPError`."

#: ../../library/urllib.request.rst:345
msgid "A class to handle redirections."
msgstr "Uma classe para tratar redirecionamentos."

#: ../../library/urllib.request.rst:350
msgid "A class to handle HTTP Cookies."
msgstr "Uma classe para tratar cookies HTTP."

#: ../../library/urllib.request.rst:355
msgid ""
"Cause requests to go through a proxy. If *proxies* is given, it must be a "
"dictionary mapping protocol names to URLs of proxies. The default is to read "
"the list of proxies from the environment variables ``<protocol>_proxy``.  If "
"no proxy environment variables are set, then in a Windows environment proxy "
"settings are obtained from the registry's Internet Settings section, and in "
"a macOS environment proxy information is retrieved from the System "
"Configuration Framework."
msgstr ""
"Faz com que os pedidos passem por um proxy. Se *proxies* for fornecido, deve "
"ser um dicionário que mapeia nomes de protocolos para URLs de proxies. O "
"valor predefinido é ler a lista de proxies das variáveis de ambiente "
"``<protocol>_proxy``. Se nenhuma variável de ambiente de proxy estiver "
"definida, então, num ambiente Windows, as configurações de proxy são obtidas "
"da secção Internet Settings do registo, e num ambiente macOS, as informações "
"de proxy são recuperadas do System Configuration Framework."

#: ../../library/urllib.request.rst:363
msgid "To disable autodetected proxy pass an empty dictionary."
msgstr "Para desativar o proxy autodetetado, passe um dicionário vazio."

#: ../../library/urllib.request.rst:365
msgid ""
"The :envvar:`no_proxy` environment variable can be used to specify hosts "
"which shouldn't be reached via proxy; if set, it should be a comma-separated "
"list of hostname suffixes, optionally with ``:port`` appended, for example "
"``cern.ch,ncsa.uiuc.edu,some.host:8080``."
msgstr ""
"A variável de ambiente :envvar:`no_proxy` pode ser usada para especificar "
"hosts que não devem ser alcançados via proxy; se definida, deve ser uma "
"lista separada por vírgulas de sufixos de nomes de host, opcionalmente com "
"``:port`` anexado, por exemplo, ``cern.ch,ncsa.uiuc.edu,some.host:8080``."

#: ../../library/urllib.request.rst:372
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` será ignorado se uma variável ``REQUEST_METHOD`` estiver "
"definida; veja a documentação em :func:`~urllib.request.getproxies`."

#: ../../library/urllib.request.rst:378
msgid "Keep a database of  ``(realm, uri) -> (user, password)`` mappings."
msgstr ""
"Mantém uma base de dados de mapeamentos ``(realm, uri) -> (user, password)``."

#: ../../library/urllib.request.rst:383
msgid ""
"Keep a database of  ``(realm, uri) -> (user, password)`` mappings. A realm "
"of ``None`` is considered a catch-all realm, which is searched if no other "
"realm fits."
msgstr ""
"Mantém uma base de dados de mapeamentos ``(realm, uri) -> (user, "
"password)``. Um realm de ``None`` é considerado um realm abrangente, que é "
"pesquisado se nenhum outro realm for adequado."

#: ../../library/urllib.request.rst:390
msgid ""
"A variant of :class:`HTTPPasswordMgrWithDefaultRealm` that also has a "
"database of ``uri -> is_authenticated`` mappings.  Can be used by a "
"BasicAuth handler to determine when to send authentication credentials "
"immediately instead of waiting for a ``401`` response first."
msgstr ""
"Uma variante de :class:`HTTPPasswordMgrWithDefaultRealm` que também tem uma "
"base de dados de mapeamentos ``uri -> is_authenticated``. Pode ser usada por "
"um manipulador BasicAuth para determinar quando enviar credenciais de "
"autenticação imediatamente em vez de esperar por uma resposta ``401`` "
"primeiro."

#: ../../library/urllib.request.rst:400
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be "
"supported.  If *passwd_mgr* also provides ``is_authenticated`` and "
"``update_authenticated`` methods (see :ref:`http-password-mgr-with-prior-"
"auth`), then the handler will use the ``is_authenticated`` result for a "
"given URI to determine whether or not to send authentication credentials "
"with the request.  If ``is_authenticated`` returns ``True`` for the URI, "
"credentials are sent.  If ``is_authenticated`` is ``False``, credentials are "
"not sent, and then if a ``401`` response is received the request is re-sent "
"with the authentication credentials.  If authentication succeeds, "
"``update_authenticated`` is called to set ``is_authenticated`` ``True`` for "
"the URI, so that subsequent requests to the URI or any of its super-URIs "
"will automatically include the authentication credentials."
msgstr ""
"Esta é uma classe mixin que ajuda com a autenticação HTTP, tanto para o host "
"remoto como para um proxy. *password_mgr*, se fornecido, deve ser algo que "
"seja compatível com :class:`HTTPPasswordMgr`; consulte a secção :ref:`http-"
"password-mgr` para informações sobre a interface que deve ser suportada. Se "
"*passwd_mgr* também fornecer métodos ``is_authenticated`` e "
"``update_authenticated`` (veja :ref:`http-password-mgr-with-prior-auth`), "
"então o manipulador usará o resultado ``is_authenticated`` para um URI dado "
"para determinar se deve ou não enviar credenciais de autenticação com o "
"pedido. Se ``is_authenticated`` retornar ``True`` para o URI, as credenciais "
"são enviadas. Se ``is_authenticated`` for ``False``, as credenciais não são "
"enviadas, e então, se uma resposta ``401`` for recebida, o pedido é "
"reenviado com as credenciais de autenticação. Se a autenticação for bem-"
"sucedida, ``update_authenticated`` é chamado para definir "
"``is_authenticated`` como ``True`` para o URI, de modo que pedidos "
"subsequentes ao URI ou a quaisquer dos seus super-URIs incluirão "
"automaticamente as credenciais de autenticação."

#: ../../library/urllib.request.rst:417
msgid "Added ``is_authenticated`` support."
msgstr "Adicionado suporte para ``is_authenticated``."

#: ../../library/urllib.request.rst:423
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. HTTPBasicAuthHandler will raise a :exc:`ValueError` when "
"presented with a wrong Authentication scheme."
msgstr ""
"Trata a autenticação com o host remoto. *password_mgr*, se fornecido, deve "
"ser algo que seja compatível com :class:`HTTPPasswordMgr`; consulte a "
"secção :ref:`http-password-mgr` para informações sobre a interface que deve "
"ser suportada. HTTPBasicAuthHandler levantará uma exceção :exc:`ValueError` "
"quando apresentado com um esquema de Autenticação errado."

#: ../../library/urllib.request.rst:432 ../../library/urllib.request.rst:469
msgid ""
"Handle authentication with the proxy. *password_mgr*, if given, should be "
"something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported."
msgstr ""
"Trata a autenticação com o proxy. *password_mgr*, se fornecido, deve ser "
"algo que seja compatível com :class:`HTTPPasswordMgr`; consulte a secção :"
"ref:`http-password-mgr` para informações sobre a interface que deve ser "
"suportada."

#: ../../library/urllib.request.rst:440
msgid ""
"This is a mixin class that helps with HTTP authentication, both to the "
"remote host and to a proxy. *password_mgr*, if given, should be something "
"that is compatible with :class:`HTTPPasswordMgr`; refer to section :ref:"
"`http-password-mgr` for information on the interface that must be supported."
msgstr ""
"Esta é uma classe mixin que ajuda com a autenticação HTTP, tanto para o host "
"remoto como para um proxy. *password_mgr*, se fornecido, deve ser algo que "
"seja compatível com :class:`HTTPPasswordMgr`; consulte a secção :ref:`http-"
"password-mgr` para informações sobre a interface que deve ser suportada."

#: ../../library/urllib.request.rst:446
msgid "Added support for HTTP digest authentication algorithm ``SHA-256``."
msgstr ""
"Adicionado suporte para o algoritmo de autenticação digest HTTP ``SHA-256``."

#: ../../library/urllib.request.rst:452
msgid ""
"Handle authentication with the remote host. *password_mgr*, if given, should "
"be something that is compatible with :class:`HTTPPasswordMgr`; refer to "
"section :ref:`http-password-mgr` for information on the interface that must "
"be supported. When both Digest Authentication Handler and Basic "
"Authentication Handler are both added, Digest Authentication is always tried "
"first. If the Digest Authentication returns a 40x response again, it is sent "
"to Basic Authentication handler to Handle.  This Handler method will raise "
"a :exc:`ValueError` when presented with an authentication scheme other than "
"Digest or Basic."
msgstr ""
"Trata a autenticação com o host remoto. *password_mgr*, se fornecido, deve "
"ser algo que seja compatível com :class:`HTTPPasswordMgr`; consulte a "
"secção :ref:`http-password-mgr` para informações sobre a interface que deve "
"ser suportada. Quando tanto o Manipulador de Autenticação Digest como o "
"Manipulador de Autenticação Básica são adicionados, a Autenticação Digest é "
"sempre tentada primeiro. Se a Autenticação Digest retornar uma resposta 40x "
"novamente, ela é enviada para o manipulador de Autenticação Básica para "
"tratar. Este método do Manipulador levantará uma exceção :exc:`ValueError` "
"quando apresentado com um esquema de autenticação diferente de Digest ou "
"Básico."

#: ../../library/urllib.request.rst:462
msgid "Raise :exc:`ValueError` on unsupported Authentication Scheme."
msgstr "Levanta :exc:`ValueError` em esquema de Autenticação não suportado."

#: ../../library/urllib.request.rst:477
msgid "A class to handle opening of HTTP URLs."
msgstr "Uma classe para tratar a abertura de URLs HTTP."

#: ../../library/urllib.request.rst:482
msgid ""
"A class to handle opening of HTTPS URLs.  *context* and *check_hostname* "
"have the same meaning as in :class:`http.client.HTTPSConnection`."
msgstr ""
"Uma classe para tratar a abertura de URLs HTTPS. *context* e "
"*check_hostname* têm o mesmo significado que em :class:`http.client."
"HTTPSConnection`."

#: ../../library/urllib.request.rst:485
msgid "*context* and *check_hostname* were added."
msgstr "Os parâmetros *context* e *check_hostname* foram adicionados."

#: ../../library/urllib.request.rst:491
msgid "Open local files."
msgstr "Abre ficheiros locais."

#: ../../library/urllib.request.rst:495
msgid "Open data URLs."
msgstr "Abre URLs de dados."

#: ../../library/urllib.request.rst:501
msgid "Open FTP URLs."
msgstr "Abre URLs FTP."

#: ../../library/urllib.request.rst:506
msgid ""
"Open FTP URLs, keeping a cache of open FTP connections to minimize delays."
msgstr ""
"Abre URLs FTP, mantendo uma cache de conexões FTP abertas para minimizar "
"atrasos."

#: ../../library/urllib.request.rst:511
msgid "A catch-all class to handle unknown URLs."
msgstr "Uma classe abrangente para tratar URLs desconhecidas."

#: ../../library/urllib.request.rst:516 ../../library/urllib.request.rst:1225
msgid "Process HTTP error responses."
msgstr "Processa respostas de erro HTTP."

#: ../../library/urllib.request.rst:522
msgid "Request Objects"
msgstr "Objetos Request"

#: ../../library/urllib.request.rst:524
msgid ""
"The following methods describe :class:`Request`'s public interface, and so "
"all may be overridden in subclasses.  It also defines several public "
"attributes that can be used by clients to inspect the parsed request."
msgstr ""
"Os seguintes métodos descrevem a interface pública de :class:`Request`, e "
"portanto todos podem ser substituídos em subclasses. Também define vários "
"atributos públicos que podem ser usados pelos clientes para inspecionar o "
"pedido analisado."

#: ../../library/urllib.request.rst:531
msgid "The original URL passed to the constructor."
msgstr "A URL original passada ao construtor."

#: ../../library/urllib.request.rst:535
msgid ""
"Request.full_url is a property with setter, getter and a deleter. Getting :"
"attr:`~Request.full_url` returns the original request URL with the fragment, "
"if it was present."
msgstr ""
"Request.full_url é uma propriedade com setter, getter e um deleter. Obter :"
"attr:`~Request.full_url` retorna a URL original do pedido com o fragmento, "
"se estiver presente."

#: ../../library/urllib.request.rst:541
msgid "The URI scheme."
msgstr "O esquema do URI."

#: ../../library/urllib.request.rst:545
msgid ""
"The URI authority, typically a host, but may also contain a port separated "
"by a colon."
msgstr ""
"A autoridade do URI, tipicamente um host, mas também pode conter uma porta "
"separada por dois pontos."

#: ../../library/urllib.request.rst:550
msgid "The original host for the request, without port."
msgstr "O host original do pedido, sem porta."

#: ../../library/urllib.request.rst:554
msgid ""
"The URI path.  If the :class:`Request` uses a proxy, then selector will be "
"the full URL that is passed to the proxy."
msgstr ""
"O caminho do URI. Se o :class:`Request` usar um proxy, então o seletor será "
"a URL completa que é passada ao proxy."

#: ../../library/urllib.request.rst:559
msgid "The entity body for the request, or ``None`` if not specified."
msgstr ""
"O corpo da entidade para o pedido, ou ``None`` se não for especificado."

#: ../../library/urllib.request.rst:561
msgid ""
"Changing value of :attr:`Request.data` now deletes \"Content-Length\" header "
"if it was previously set or calculated."
msgstr ""
"Alterar o valor de :attr:`Request.data` agora apaga o cabeçalho \"Content-"
"Length\" se este tiver sido definido ou calculado anteriormente."

#: ../../library/urllib.request.rst:567
msgid ""
"boolean, indicates whether the request is unverifiable as defined by :rfc:"
"`2965`."
msgstr ""
"booleano, indica se o pedido é não verificável conforme definido por :rfc:"
"`2965`."

#: ../../library/urllib.request.rst:572
msgid ""
"The HTTP request method to use.  By default its value is :const:`None`, "
"which means that :meth:`~Request.get_method` will do its normal computation "
"of the method to be used.  Its value can be set (thus overriding the default "
"computation in :meth:`~Request.get_method`) either by providing a default "
"value by setting it at the class level in a :class:`Request` subclass, or by "
"passing a value in to the :class:`Request` constructor via the *method* "
"argument."
msgstr ""
"O método de pedido HTTP a usar. Por padrão, o seu valor é :const:`None`, o "
"que significa que :meth:`~Request.get_method` fará o seu cálculo normal do "
"método a ser usado. O seu valor pode ser definido (assim substituindo o "
"cálculo predefinido em :meth:`~Request.get_method`) fornecendo um valor "
"predefinido ao defini-lo ao nível da classe numa subclasse :class:`Request`, "
"ou passando um valor para o construtor :class:`Request` através do argumento "
"*method*."

#: ../../library/urllib.request.rst:582
msgid ""
"A default value can now be set in subclasses; previously it could only be "
"set via the constructor argument."
msgstr ""
"Um valor predefinido pode agora ser definido em subclasses; anteriormente só "
"podia ser definido através do argumento do construtor."

#: ../../library/urllib.request.rst:589
msgid ""
"Return a string indicating the HTTP request method.  If :attr:`Request."
"method` is not ``None``, return its value, otherwise return ``'GET'`` if :"
"attr:`Request.data` is ``None``, or ``'POST'`` if it's not. This is only "
"meaningful for HTTP requests."
msgstr ""
"Retorna uma string indicando o método de pedido HTTP. Se :attr:`Request."
"method` não for ``None``, retorna o seu valor, caso contrário retorna "
"``'GET'`` se :attr:`Request.data` for ``None``, ou ``'POST'`` se não for. "
"Isto só é significativo para pedidos HTTP."

#: ../../library/urllib.request.rst:594
msgid "get_method now looks at the value of :attr:`Request.method`."
msgstr "get_method agora verifica o valor de :attr:`Request.method`."

#: ../../library/urllib.request.rst:600
msgid ""
"Add another header to the request.  Headers are currently ignored by all "
"handlers except HTTP handlers, where they are added to the list of headers "
"sent to the server.  Note that there cannot be more than one header with the "
"same name, and later calls will overwrite previous calls in case the *key* "
"collides. Currently, this is no loss of HTTP functionality, since all "
"headers which have meaning when used more than once have a (header-specific) "
"way of gaining the same functionality using only one header.  Note that "
"headers added using this method are also added to redirected requests."
msgstr ""
"Adiciona outro cabeçalho ao pedido. Os cabeçalhos são atualmente ignorados "
"por todos os manipuladores exceto os manipuladores HTTP, onde são "
"adicionados à lista de cabeçalhos enviados para o servidor. Note que não "
"pode haver mais do que um cabeçalho com o mesmo nome, e chamadas posteriores "
"substituirão chamadas anteriores no caso de colisão da *key*. Atualmente, "
"isto não representa perda de funcionalidade HTTP, uma vez que todos os "
"cabeçalhos que têm significado quando usados mais do que uma vez têm uma "
"forma (específica do cabeçalho) de obter a mesma funcionalidade usando "
"apenas um cabeçalho. Note que os cabeçalhos adicionados usando este método "
"também são adicionados a pedidos redirecionados."

#: ../../library/urllib.request.rst:612
msgid "Add a header that will not be added to a redirected request."
msgstr ""
"Adiciona um cabeçalho que não será adicionado a um pedido redirecionado."

#: ../../library/urllib.request.rst:617
msgid ""
"Return whether the instance has the named header (checks both regular and "
"unredirected)."
msgstr ""
"Retorna se a instância tem o cabeçalho nomeado (verifica tanto os cabeçalhos "
"regulares como os não redirecionados)."

#: ../../library/urllib.request.rst:623
msgid ""
"Remove named header from the request instance (both from regular and "
"unredirected headers)."
msgstr ""
"Remove o cabeçalho nomeado da instância do pedido (tanto dos cabeçalhos "
"regulares como dos não redirecionados)."

#: ../../library/urllib.request.rst:631
msgid "Return the URL given in the constructor."
msgstr "Retorna a URL fornecida no construtor."

#: ../../library/urllib.request.rst:635
msgid "Returns :attr:`Request.full_url`"
msgstr "Retorna :attr:`Request.full_url`"

#: ../../library/urllib.request.rst:640
msgid ""
"Prepare the request by connecting to a proxy server. The *host* and *type* "
"will replace those of the instance, and the instance's selector will be the "
"original URL given in the constructor."
msgstr ""
"Prepara o pedido conectando-se a um servidor proxy. O *host* e *type* "
"substituirão os da instância, e o seletor da instância será a URL original "
"fornecida no construtor."

#: ../../library/urllib.request.rst:647
msgid ""
"Return the value of the given header. If the header is not present, return "
"the default value."
msgstr ""
"Retorna o valor do cabeçalho dado. Se o cabeçalho não estiver presente, "
"retorna o valor predefinido."

#: ../../library/urllib.request.rst:653
msgid ""
"Return a list of tuples (header_name, header_value) of the Request headers."
msgstr ""
"Retorna uma lista de tuplos (header_name, header_value) dos cabeçalhos do "
"Pedido."

#: ../../library/urllib.request.rst:655
msgid ""
"The request methods add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host and is_unverifiable that were deprecated "
"since 3.3 have been removed."
msgstr ""
"Os métodos de pedido add_data, has_data, get_data, get_type, get_host, "
"get_selector, get_origin_req_host e is_unverifiable, que estavam obsoletos "
"desde a versão 3.3, foram removidos."

#: ../../library/urllib.request.rst:664
msgid "OpenerDirector Objects"
msgstr "Objetos OpenerDirector"

#: ../../library/urllib.request.rst:666
msgid ":class:`OpenerDirector` instances have the following methods:"
msgstr "As instâncias :class:`OpenerDirector` têm os seguintes métodos:"

#: ../../library/urllib.request.rst:671
msgid ""
"*handler* should be an instance of :class:`BaseHandler`.  The following "
"methods are searched, and added to the possible chains (note that HTTP "
"errors are a special case).  Note that, in the following, *protocol* should "
"be replaced with the actual protocol to handle, for example :meth:"
"`http_response` would be the HTTP protocol response handler.  Also *type* "
"should be replaced with the actual HTTP code, for example :meth:"
"`http_error_404` would handle HTTP 404 errors."
msgstr ""
"*handler* deve ser uma instância de :class:`BaseHandler`. Os seguintes "
"métodos são procurados e adicionados às possíveis cadeias (note que os erros "
"HTTP são um caso especial). Note que, no seguinte, *protocol* deve ser "
"substituído pelo protocolo real a ser tratado, por exemplo, :meth:"
"`http_response` seria o manipulador de resposta do protocolo HTTP. Também "
"*type* deve ser substituído pelo código HTTP real, por exemplo, :meth:"
"`http_error_404` trataria erros HTTP 404."

#: ../../library/urllib.request.rst:679
msgid ""
":meth:`!<protocol>_open` --- signal that the handler knows how to open "
"*protocol* URLs."
msgstr ""
":meth:`!<protocol>_open` --- sinaliza que o manipulador sabe como abrir URLs "
"*protocol*."

#: ../../library/urllib.request.rst:682
msgid "See |protocol_open|_ for more information."
msgstr "Veja |protocol_open|_ para mais informações."

#: ../../library/urllib.request.rst:684
msgid ""
":meth:`!http_error_\\<type\\>` --- signal that the handler knows how to "
"handle HTTP errors with HTTP error code *type*."
msgstr ""
":meth:`!http_error_\\<type\\>` --- sinaliza que o manipulador sabe como "
"tratar erros HTTP com o código de erro HTTP *type*."

#: ../../library/urllib.request.rst:687
msgid "See |http_error_nnn|_ for more information."
msgstr "Veja |http_error_nnn|_ para mais informações."

#: ../../library/urllib.request.rst:689
msgid ""
":meth:`!<protocol>_error` --- signal that the handler knows how to handle "
"errors from (non-\\ ``http``) *protocol*."
msgstr ""
":meth:`!<protocol>_error` --- sinaliza que o manipulador sabe como tratar "
"erros do protocolo (não-\\ ``http``) *protocol*."

#: ../../library/urllib.request.rst:692
msgid ""
":meth:`!<protocol>_request` --- signal that the handler knows how to pre-"
"process *protocol* requests."
msgstr ""
":meth:`!<protocol>_request` --- sinaliza que o manipulador sabe como pré-"
"processar pedidos *protocol*."

#: ../../library/urllib.request.rst:695
msgid "See |protocol_request|_ for more information."
msgstr "Veja |protocol_request|_ para mais informações."

#: ../../library/urllib.request.rst:697
msgid ""
":meth:`!<protocol>_response` --- signal that the handler knows how to post-"
"process *protocol* responses."
msgstr ""
":meth:`!<protocol>_response` --- sinaliza que o manipulador sabe como pós-"
"processar respostas *protocol*."

#: ../../library/urllib.request.rst:700
msgid "See |protocol_response|_ for more information."
msgstr "Veja |protocol_response|_ para mais informações."

#: ../../library/urllib.request.rst:709
msgid ""
"Open the given *url* (which can be a request object or a string), optionally "
"passing the given *data*. Arguments, return values and exceptions raised are "
"the same as those of :func:`urlopen` (which simply calls the :meth:`open` "
"method on the currently installed global :class:`OpenerDirector`).  The "
"optional *timeout* parameter specifies a timeout in seconds for blocking "
"operations like the connection attempt (if not specified, the global default "
"timeout setting will be used). The timeout feature actually works only for "
"HTTP, HTTPS and FTP connections."
msgstr ""
"Abre a *url* dada (que pode ser um objeto de pedido ou uma string), "
"opcionalmente passando os *data* dados. Argumentos, valores de retorno e "
"exceções levantadas são os mesmos que os de :func:`urlopen` (que "
"simplesmente chama o método :meth:`open` no :class:`OpenerDirector` global "
"atualmente instalado). O parâmetro opcional *timeout* especifica um tempo "
"limite em segundos para operações de bloqueio como a tentativa de conexão "
"(se não for especificado, a configuração de tempo limite global padrão será "
"usada). A funcionalidade de tempo limite na verdade só funciona para "
"conexões HTTP, HTTPS e FTP."

#: ../../library/urllib.request.rst:721
msgid ""
"Handle an error of the given protocol.  This will call the registered error "
"handlers for the given protocol with the given arguments (which are protocol "
"specific).  The HTTP protocol is a special case which uses the HTTP response "
"code to determine the specific error handler; refer to the :meth:`!"
"http_error_\\<type\\>` methods of the handler classes."
msgstr ""
"Trata um erro do protocolo dado. Isto chamará os manipuladores de erro "
"registados para o protocolo dado com os argumentos dados (que são "
"específicos do protocolo). O protocolo HTTP é um caso especial que usa o "
"código de resposta HTTP para determinar o manipulador de erro específico; "
"consulte os métodos :meth:`!http_error_\\<type\\>` das classes de "
"manipuladores."

#: ../../library/urllib.request.rst:727
msgid ""
"Return values and exceptions raised are the same as those of :func:`urlopen`."
msgstr ""
"Os valores de retorno e exceções levantadas são os mesmos que os de :func:"
"`urlopen`."

#: ../../library/urllib.request.rst:729
msgid "OpenerDirector objects open URLs in three stages:"
msgstr "Os objetos OpenerDirector abrem URLs em três etapas:"

#: ../../library/urllib.request.rst:731
msgid ""
"The order in which these methods are called within each stage is determined "
"by sorting the handler instances."
msgstr ""
"A ordem pela qual estes métodos são chamados dentro de cada etapa é "
"determinada pela ordenação das instâncias de manipuladores."

#: ../../library/urllib.request.rst:734
msgid ""
"Every handler with a method named like :meth:`!<protocol>_request` has that "
"method called to pre-process the request."
msgstr ""
"Cada manipulador com um método nomeado como :meth:`!<protocol>_request` tem "
"esse método chamado para pré-processar o pedido."

#: ../../library/urllib.request.rst:737
msgid ""
"Handlers with a method named like :meth:`!<protocol>_open` are called to "
"handle the request. This stage ends when a handler either returns a non-\\ :"
"const:`None` value (ie. a response), or raises an exception (usually :exc:"
"`~urllib.error.URLError`).  Exceptions are allowed to propagate."
msgstr ""
"Manipuladores com um método nomeado como :meth:`!<protocol>_open` são "
"chamados para tratar o pedido. Esta etapa termina quando um manipulador "
"retorna um valor não-\\ :const:`None` (ou seja, uma resposta), ou levanta "
"uma exceção (geralmente :exc:`~urllib.error.URLError`). As exceções são "
"permitidas propagar-se."

#: ../../library/urllib.request.rst:742
msgid ""
"In fact, the above algorithm is first tried for methods named :meth:"
"`~BaseHandler.default_open`.  If all such methods return :const:`None`, the "
"algorithm is repeated for methods named like :meth:`!<protocol>_open`.  If "
"all such methods return :const:`None`, the algorithm is repeated for methods "
"named :meth:`~BaseHandler.unknown_open`."
msgstr ""
"Na verdade, o algoritmo acima é primeiro tentado para métodos nomeados :meth:"
"`~BaseHandler.default_open`. Se todos esses métodos retornarem :const:"
"`None`, o algoritmo é repetido para métodos nomeados como :meth:`!"
"<protocol>_open`. Se todos esses métodos retornarem :const:`None`, o "
"algoritmo é repetido para métodos nomeados :meth:`~BaseHandler.unknown_open`."

#: ../../library/urllib.request.rst:748
msgid ""
"Note that the implementation of these methods may involve calls of the "
"parent :class:`OpenerDirector` instance's :meth:`~OpenerDirector.open` and :"
"meth:`~OpenerDirector.error` methods."
msgstr ""
"Note que a implementação destes métodos pode envolver chamadas dos métodos :"
"meth:`~OpenerDirector.open` e :meth:`~OpenerDirector.error` da instância "
"pai :class:`OpenerDirector`."

#: ../../library/urllib.request.rst:752
msgid ""
"Every handler with a method named like :meth:`!<protocol>_response` has that "
"method called to post-process the response."
msgstr ""
"Cada manipulador com um método nomeado como :meth:`!<protocol>_response` tem "
"esse método chamado para pós-processar a resposta."

#: ../../library/urllib.request.rst:759
msgid "BaseHandler Objects"
msgstr "Objetos BaseHandler"

#: ../../library/urllib.request.rst:761
msgid ""
":class:`BaseHandler` objects provide a couple of methods that are directly "
"useful, and others that are meant to be used by derived classes.  These are "
"intended for direct use:"
msgstr ""
"Os objetos :class:`BaseHandler` fornecem alguns métodos que são diretamente "
"úteis, e outros que são destinados a serem usados por classes derivadas. "
"Estes são destinados a uso direto:"

#: ../../library/urllib.request.rst:768
msgid "Add a director as parent."
msgstr "Adiciona um diretor como pai."

#: ../../library/urllib.request.rst:773
msgid "Remove any parents."
msgstr "Remove quaisquer pais."

#: ../../library/urllib.request.rst:775
msgid ""
"The following attribute and methods should only be used by classes derived "
"from :class:`BaseHandler`."
msgstr ""
"O seguinte atributo e métodos devem ser usados apenas por classes derivadas "
"de :class:`BaseHandler`."

#: ../../library/urllib.request.rst:780
msgid ""
"The convention has been adopted that subclasses defining :meth:`!"
"<protocol>_request` or :meth:`!<protocol>_response` methods are named :class:"
"`!\\*Processor`; all others are named :class:`!\\*Handler`."
msgstr ""
"A convenção adotada é que as subclasses que definem métodos :meth:`!"
"<protocol>_request` ou :meth:`!<protocol>_response` são chamadas :class:`!"
"\\*Processor`; todas as outras são chamadas :class:`!\\*Handler`."

#: ../../library/urllib.request.rst:787
msgid ""
"A valid :class:`OpenerDirector`, which can be used to open using a different "
"protocol, or handle errors."
msgstr ""
"Um :class:`OpenerDirector` válido, que pode ser usado para abrir usando um "
"protocolo diferente, ou tratar erros."

#: ../../library/urllib.request.rst:793
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs."
msgstr ""
"Este método *não* está definido em :class:`BaseHandler`, mas as subclasses "
"devem defini-lo se quiserem capturar todas as URLs."

#: ../../library/urllib.request.rst:796
msgid ""
"This method, if implemented, will be called by the parent :class:"
"`OpenerDirector`.  It should return a file-like object as described in the "
"return value of the :meth:`~OpenerDirector.open` method of :class:"
"`OpenerDirector`, or ``None``. It should raise :exc:`~urllib.error."
"URLError`, unless a truly exceptional thing happens (for example, :exc:"
"`MemoryError` should not be mapped to :exc:`~urllib.error.URLError`)."
msgstr ""
"Este método, se implementado, será chamado pelo :class:`OpenerDirector` pai. "
"Deve retornar um objeto semelhante a um ficheiro como descrito no valor de "
"retorno do método :meth:`~OpenerDirector.open` de :class:`OpenerDirector`, "
"ou ``None``. Deve levantar :exc:`~urllib.error.URLError`, a menos que ocorra "
"algo realmente excepcional (por exemplo, :exc:`MemoryError` não deve ser "
"mapeado para :exc:`~urllib.error.URLError`)."

#: ../../library/urllib.request.rst:803
msgid "This method will be called before any protocol-specific open method."
msgstr ""
"Este método será chamado antes de qualquer método de abertura específico do "
"protocolo."

#: ../../library/urllib.request.rst:810
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to handle URLs with the given protocol."
msgstr ""
"Este método *não* está definido em :class:`BaseHandler`, mas as subclasses "
"devem defini-lo se quiserem tratar URLs com o protocolo dado."

#: ../../library/urllib.request.rst:813
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. Return values should be the same as for  :meth:"
"`~BaseHandler.default_open`."
msgstr ""
"Este método, se definido, será chamado pelo :class:`OpenerDirector` pai. Os "
"valores de retorno devem ser os mesmos que para :meth:`~BaseHandler."
"default_open`."

#: ../../library/urllib.request.rst:819
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to catch all URLs with no specific registered handler "
"to open it."
msgstr ""
"Este método *não* está definido em :class:`BaseHandler`, mas as subclasses "
"devem defini-lo se quiserem capturar todas as URLs sem um manipulador "
"registado específico para as abrir."

#: ../../library/urllib.request.rst:823
msgid ""
"This method, if implemented, will be called by the :attr:`parent` :class:"
"`OpenerDirector`.  Return values should be the same as for :meth:"
"`default_open`."
msgstr ""
"Este método, se implementado, será chamado pelo :attr:`parent` :class:"
"`OpenerDirector`. Os valores de retorno devem ser os mesmos que para :meth:"
"`default_open`."

#: ../../library/urllib.request.rst:830
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"override it if they intend to provide a catch-all for otherwise unhandled "
"HTTP errors.  It will be called automatically by the  :class:"
"`OpenerDirector` getting the error, and should not normally be called in "
"other circumstances."
msgstr ""
"Este método *não* está definido em :class:`BaseHandler`, mas as subclasses "
"devem substituí-lo se pretenderem fornecer um mecanismo abrangente para "
"erros HTTP não tratados. Será chamado automaticamente pelo :class:"
"`OpenerDirector` ao obter o erro e não deve ser chamado normalmente noutras "
"circunstâncias."

#: ../../library/urllib.request.rst:835
msgid ""
":class:`OpenerDirector` will call this method with five positional arguments:"
msgstr ""
":class:`OpenerDirector` chamará este método com cinco argumentos posicionais:"

#: ../../library/urllib.request.rst:837
msgid "a :class:`Request` object,"
msgstr "um objeto :class:`Request`,"

#: ../../library/urllib.request.rst:838
msgid "a file-like object with the HTTP error body,"
msgstr "um objeto semelhante a um ficheiro com o corpo do erro HTTP,"

#: ../../library/urllib.request.rst:839
msgid "the three-digit code of the error, as a string,"
msgstr "o código de três dígitos do erro, como uma string,"

#: ../../library/urllib.request.rst:840
msgid "the user-visible explanation of the code, as a string, and"
msgstr "a explicação visível para o utilizador do código, como uma string, e"

#: ../../library/urllib.request.rst:841
msgid "the headers of the error, as a mapping object."
msgstr "os cabeçalhos do erro, como um objeto de mapeamento."

#: ../../library/urllib.request.rst:843
msgid ""
"Return values and exceptions raised should be the same as those of :func:"
"`urlopen`."
msgstr ""
"Os valores de retorno e exceções levantadas devem ser os mesmos que os de :"
"func:`urlopen`."

#: ../../library/urllib.request.rst:850
msgid ""
"*nnn* should be a three-digit HTTP error code.  This method is also not "
"defined in :class:`BaseHandler`, but will be called, if it exists, on an "
"instance of a subclass, when an HTTP error with code *nnn* occurs."
msgstr ""
"*nnn* deve ser um código de erro HTTP de três dígitos. Este método também "
"não está definido em :class:`BaseHandler`, mas será chamado, se existir, "
"numa instância de uma subclasse, quando ocorrer um erro HTTP com o código "
"*nnn*."

#: ../../library/urllib.request.rst:854
msgid "Subclasses should override this method to handle specific HTTP errors."
msgstr ""
"As subclasses devem substituir este método para tratar erros HTTP "
"específicos."

#: ../../library/urllib.request.rst:856
msgid ""
"Arguments, return values and exceptions raised should be the same as for :"
"meth:`~BaseHandler.http_error_default`."
msgstr ""
"Os argumentos, valores de retorno e exceções levantadas devem ser os mesmos "
"que para :meth:`~BaseHandler.http_error_default`."

#: ../../library/urllib.request.rst:864
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to pre-process requests of the given protocol."
msgstr ""
"Este método *não* está definido em :class:`BaseHandler`, mas as subclasses "
"devem defini-lo se quiserem pré-processar pedidos do protocolo dado."

#: ../../library/urllib.request.rst:867
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. The return value "
"should be a :class:`Request` object."
msgstr ""
"Este método, se definido, será chamado pelo :class:`OpenerDirector` pai. "
"*req* será um objeto :class:`Request`. O valor de retorno deve ser um "
"objeto :class:`Request`."

#: ../../library/urllib.request.rst:876
msgid ""
"This method is *not* defined in :class:`BaseHandler`, but subclasses should "
"define it if they want to post-process responses of the given protocol."
msgstr ""
"Este método *não* está definido em :class:`BaseHandler`, mas as subclasses "
"devem defini-lo se quiserem pós-processar respostas do protocolo dado."

#: ../../library/urllib.request.rst:879
msgid ""
"This method, if defined, will be called by the parent :class:"
"`OpenerDirector`. *req* will be a :class:`Request` object. *response* will "
"be an object implementing the same interface as the return value of :func:"
"`urlopen`.  The return value should implement the same interface as the "
"return value of :func:`urlopen`."
msgstr ""
"Este método, se definido, será chamado pelo :class:`OpenerDirector` pai. "
"*req* será um objeto :class:`Request`. *response* será um objeto que "
"implementa a mesma interface que o valor de retorno de :func:`urlopen`. O "
"valor de retorno deve implementar a mesma interface que o valor de retorno "
"de :func:`urlopen`."

#: ../../library/urllib.request.rst:889
msgid "HTTPRedirectHandler Objects"
msgstr "Objetos HTTPRedirectHandler"

#: ../../library/urllib.request.rst:893
msgid ""
"Some HTTP redirections require action from this module's client code.  If "
"this is the case, :exc:`~urllib.error.HTTPError` is raised.  See :rfc:`2616` "
"for details of the precise meanings of the various redirection codes."
msgstr ""
"Alguns redirecionamentos HTTP requerem ação do código cliente deste módulo. "
"Se este for o caso, :exc:`~urllib.error.HTTPError` é levantado. Veja :rfc:"
"`2616` para detalhes sobre os significados precisos dos vários códigos de "
"redirecionamento."

#: ../../library/urllib.request.rst:897
msgid ""
"An :exc:`~urllib.error.HTTPError` exception raised as a security "
"consideration if the HTTPRedirectHandler is presented with a redirected URL "
"which is not an HTTP, HTTPS or FTP URL."
msgstr ""
"Uma exceção :exc:`~urllib.error.HTTPError` levantada como uma consideração "
"de segurança se o HTTPRedirectHandler for apresentado com uma URL "
"redirecionada que não seja uma URL HTTP, HTTPS ou FTP."

#: ../../library/urllib.request.rst:904
msgid ""
"Return a :class:`Request` or ``None`` in response to a redirect. This is "
"called by the default implementations of the :meth:`!http_error_30\\*` "
"methods when a redirection is received from the server.  If a redirection "
"should take place, return a new :class:`Request` to allow :meth:`!"
"http_error_30\\*` to perform the redirect to *newurl*.  Otherwise, raise :"
"exc:`~urllib.error.HTTPError` if no other handler should try to handle this "
"URL, or return ``None`` if you can't but another handler might."
msgstr ""
"Retorna um :class:`Request` ou ``None`` em resposta a um redirecionamento. "
"Isto é chamado pelas implementações predefinidas dos métodos :meth:`!"
"http_error_30\\*` quando um redirecionamento é recebido do servidor. Se um "
"redirecionamento deve ocorrer, retorna um novo :class:`Request` para "
"permitir que :meth:`!http_error_30\\*` execute o redirecionamento para "
"*newurl*. Caso contrário, levanta :exc:`~urllib.error.HTTPError` se nenhum "
"outro manipulador deve tentar tratar esta URL, ou retorna ``None`` se não "
"puder, mas outro manipulador possa."

#: ../../library/urllib.request.rst:914
msgid ""
"The default implementation of this method does not strictly follow :rfc:"
"`2616`, which says that 301 and 302 responses to ``POST`` requests must not "
"be automatically redirected without confirmation by the user.  In reality, "
"browsers do allow automatic redirection of these responses, changing the "
"POST to a ``GET``, and the default implementation reproduces this behavior."
msgstr ""
"A implementação predefinida deste método não segue estritamente :rfc:`2616`, "
"que diz que as respostas 301 e 302 a pedidos ``POST`` não devem ser "
"redirecionadas automaticamente sem confirmação do utilizador. Na realidade, "
"os navegadores permitem o redirecionamento automático destas respostas, "
"alterando o POST para um ``GET``, e a implementação predefinida reproduz "
"este comportamento."

#: ../../library/urllib.request.rst:923
msgid ""
"Redirect to the ``Location:`` or ``URI:`` URL.  This method is called by the "
"parent :class:`OpenerDirector` when getting an HTTP 'moved permanently' "
"response."
msgstr ""
"Redireciona para a URL ``Location:`` ou ``URI:``. Este método é chamado "
"pelo :class:`OpenerDirector` pai ao receber uma resposta HTTP 'moved "
"permanently'."

#: ../../library/urllib.request.rst:929
msgid ""
"The same as :meth:`http_error_301`, but called for the 'found' response."
msgstr ""
"O mesmo que :meth:`http_error_301`, mas chamado para a resposta 'found'."

#: ../../library/urllib.request.rst:934
msgid ""
"The same as :meth:`http_error_301`, but called for the 'see other' response."
msgstr ""
"O mesmo que :meth:`http_error_301`, mas chamado para a resposta 'see other'."

#: ../../library/urllib.request.rst:939
msgid ""
"The same as :meth:`http_error_301`, but called for the 'temporary redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr ""
"O mesmo que :meth:`http_error_301`, mas chamado para a resposta 'temporary "
"redirect'. Não permite alterar o método de pedido de ``POST`` para ``GET``."

#: ../../library/urllib.request.rst:946
msgid ""
"The same as :meth:`http_error_301`, but called for the 'permanent redirect' "
"response. It does not allow changing the request method from ``POST`` to "
"``GET``."
msgstr ""
"O mesmo que :meth:`http_error_301`, mas chamado para a resposta 'permanent "
"redirect'. Não permite alterar o método de pedido de ``POST`` para ``GET``."

#: ../../library/urllib.request.rst:956
msgid "HTTPCookieProcessor Objects"
msgstr "Objetos HTTPCookieProcessor"

#: ../../library/urllib.request.rst:958
msgid ":class:`HTTPCookieProcessor` instances have one attribute:"
msgstr "As instâncias :class:`HTTPCookieProcessor` têm um atributo:"

#: ../../library/urllib.request.rst:962
msgid "The :class:`http.cookiejar.CookieJar` in which cookies are stored."
msgstr "O :class:`http.cookiejar.CookieJar` onde os cookies são armazenados."

#: ../../library/urllib.request.rst:968
msgid "ProxyHandler Objects"
msgstr "Objetos ProxyHandler"

#: ../../library/urllib.request.rst:974
msgid ""
"The :class:`ProxyHandler` will have a method :meth:`!<protocol>_open` for "
"every *protocol* which has a proxy in the *proxies* dictionary given in the "
"constructor.  The method will modify requests to go through the proxy, by "
"calling ``request.set_proxy()``, and call the next handler in the chain to "
"actually execute the protocol."
msgstr ""
"O :class:`ProxyHandler` terá um método :meth:`!<protocol>_open` para cada "
"*protocol* que tenha um proxy no dicionário *proxies* fornecido no "
"construtor. O método modificará os pedidos para passar pelo proxy, chamando "
"``request.set_proxy()``, e chamará o próximo manipulador na cadeia para "
"executar efetivamente o protocolo."

#: ../../library/urllib.request.rst:984
msgid "HTTPPasswordMgr Objects"
msgstr "Objetos HTTPPasswordMgr"

#: ../../library/urllib.request.rst:986
msgid ""
"These methods are available on :class:`HTTPPasswordMgr` and :class:"
"`HTTPPasswordMgrWithDefaultRealm` objects."
msgstr ""
"Estes métodos estão disponíveis em objetos :class:`HTTPPasswordMgr` e :class:"
"`HTTPPasswordMgrWithDefaultRealm`."

#: ../../library/urllib.request.rst:992
msgid ""
"*uri* can be either a single URI, or a sequence of URIs. *realm*, *user* and "
"*passwd* must be strings. This causes ``(user, passwd)`` to be used as "
"authentication tokens when authentication for *realm* and a super-URI of any "
"of the given URIs is given."
msgstr ""
"*uri* pode ser um único URI ou uma sequência de URIs. *realm*, *user* e "
"*passwd* devem ser strings. Isto faz com que ``(user, passwd)`` seja usado "
"como tokens de autenticação quando a autenticação para *realm* e um super-"
"URI de qualquer um dos URIs dados for fornecida."

#: ../../library/urllib.request.rst:1000
msgid ""
"Get user/password for given realm and URI, if any.  This method will return "
"``(None, None)`` if there is no matching user/password."
msgstr ""
"Obtém utilizador/senha para o realm e URI dados, se existir. Este método "
"retornará ``(None, None)`` se não houver um utilizador/senha correspondente."

#: ../../library/urllib.request.rst:1003
msgid ""
"For :class:`HTTPPasswordMgrWithDefaultRealm` objects, the realm ``None`` "
"will be searched if the given *realm* has no matching user/password."
msgstr ""
"Para objetos :class:`HTTPPasswordMgrWithDefaultRealm`, o realm ``None`` será "
"procurado se o *realm* dado não tiver um utilizador/senha correspondente."

#: ../../library/urllib.request.rst:1010
msgid "HTTPPasswordMgrWithPriorAuth Objects"
msgstr "Objetos HTTPPasswordMgrWithPriorAuth"

#: ../../library/urllib.request.rst:1012
msgid ""
"This password manager extends :class:`HTTPPasswordMgrWithDefaultRealm` to "
"support tracking URIs for which authentication credentials should always be "
"sent."
msgstr ""
"Este gestor de senhas estende :class:`HTTPPasswordMgrWithDefaultRealm` para "
"suportar o rastreamento de URIs para os quais as credenciais de autenticação "
"devem sempre ser enviadas."

#: ../../library/urllib.request.rst:1019
msgid ""
"*realm*, *uri*, *user*, *passwd* are as for :meth:`HTTPPasswordMgr."
"add_password`.  *is_authenticated* sets the initial value of the "
"``is_authenticated`` flag for the given URI or list of URIs. If "
"*is_authenticated* is specified as ``True``, *realm* is ignored."
msgstr ""
"*realm*, *uri*, *user*, *passwd* são como em :meth:`HTTPPasswordMgr."
"add_password`. *is_authenticated* define o valor inicial da flag "
"``is_authenticated`` para o URI ou lista de URIs dados. Se "
"*is_authenticated* for especificado como ``True``, *realm* é ignorado."

#: ../../library/urllib.request.rst:1027
msgid "Same as for :class:`HTTPPasswordMgrWithDefaultRealm` objects"
msgstr "Igual aos objetos :class:`HTTPPasswordMgrWithDefaultRealm`"

#: ../../library/urllib.request.rst:1033
msgid ""
"Update the ``is_authenticated`` flag for the given *uri* or list of URIs."
msgstr ""
"Atualiza a flag ``is_authenticated`` para o *uri* dado ou lista de URIs."

#: ../../library/urllib.request.rst:1039
msgid ""
"Returns the current state of the ``is_authenticated`` flag for the given URI."
msgstr "Retorna o estado atual da flag ``is_authenticated`` para o URI dado."

#: ../../library/urllib.request.rst:1046
msgid "AbstractBasicAuthHandler Objects"
msgstr "Objetos AbstractBasicAuthHandler"

#: ../../library/urllib.request.rst:1051
msgid ""
"Handle an authentication request by getting a user/password pair, and re-"
"trying the request.  *authreq* should be the name of the header where the "
"information about the realm is included in the request, *host* specifies the "
"URL and path to authenticate for, *req* should be the (failed) :class:"
"`Request` object, and *headers* should be the error headers."
msgstr ""
"Trata um pedido de autenticação obtendo um par utilizador/senha e re-"
"tentando o pedido. *authreq* deve ser o nome do cabeçalho onde a informação "
"sobre o realm está incluída no pedido, *host* especifica a URL e o caminho "
"para autenticar, *req* deve ser o objeto :class:`Request` (falhado), e "
"*headers* deve ser os cabeçalhos de erro."

#: ../../library/urllib.request.rst:1057
msgid ""
"*host* is either an authority (e.g. ``\"python.org\"``) or a URL containing "
"an authority component (e.g. ``\"http://python.org/\"``). In either case, "
"the authority must not contain a userinfo component (so, ``\"python.org\"`` "
"and ``\"python.org:80\"`` are fine, ``\"joe:password@python.org\"`` is not)."
msgstr ""
"*host* é uma autoridade (por exemplo, ``\"python.org\"``) ou uma URL "
"contendo um componente de autoridade (por exemplo, ``\"http://python.org/"
"\"``). Em qualquer caso, a autoridade não deve conter um componente userinfo "
"(portanto, ``\"python.org\"`` e ``\"python.org:80\"`` estão corretos, mas "
"``\"joe:password@python.org\"`` não está)."

#: ../../library/urllib.request.rst:1066
msgid "HTTPBasicAuthHandler Objects"
msgstr "Objetos HTTPBasicAuthHandler"

#: ../../library/urllib.request.rst:1071 ../../library/urllib.request.rst:1082
#: ../../library/urllib.request.rst:1107 ../../library/urllib.request.rst:1118
msgid "Retry the request with authentication information, if available."
msgstr "Repete o pedido com informações de autenticação, se disponíveis."

#: ../../library/urllib.request.rst:1077
msgid "ProxyBasicAuthHandler Objects"
msgstr "Objetos ProxyBasicAuthHandler"

#: ../../library/urllib.request.rst:1088
msgid "AbstractDigestAuthHandler Objects"
msgstr "Objetos AbstractDigestAuthHandler"

#: ../../library/urllib.request.rst:1093
msgid ""
"*authreq* should be the name of the header where the information about the "
"realm is included in the request, *host* should be the host to authenticate "
"to, *req* should be the (failed) :class:`Request` object, and *headers* "
"should be the error headers."
msgstr ""
"*authreq* deve ser o nome do cabeçalho onde a informação sobre o realm está "
"incluída no pedido, *host* deve ser o host para autenticar, *req* deve ser o "
"objeto :class:`Request` (falhado), e *headers* deve ser os cabeçalhos de "
"erro."

#: ../../library/urllib.request.rst:1102
msgid "HTTPDigestAuthHandler Objects"
msgstr "Objetos HTTPDigestAuthHandler"

#: ../../library/urllib.request.rst:1113
msgid "ProxyDigestAuthHandler Objects"
msgstr "Objetos ProxyDigestAuthHandler"

#: ../../library/urllib.request.rst:1124
msgid "HTTPHandler Objects"
msgstr "Objetos HTTPHandler"

#: ../../library/urllib.request.rst:1129
msgid ""
"Send an HTTP request, which can be either GET or POST, depending on ``req."
"data``."
msgstr ""
"Envie um pedido HTTP, que pode ser GET ou POST, dependendo de ``req.data``."

#: ../../library/urllib.request.rst:1136
msgid "HTTPSHandler Objects"
msgstr "Objetos HTTPSHandler"

#: ../../library/urllib.request.rst:1141
msgid ""
"Send an HTTPS request, which can be either GET or POST, depending on ``req."
"data``."
msgstr ""
"Envie um pedido HTTPS, que pode ser GET ou POST, dependendo de ``req.data``."

#: ../../library/urllib.request.rst:1148
msgid "FileHandler Objects"
msgstr "Objetos FileHandler"

#: ../../library/urllib.request.rst:1153
msgid ""
"Open the file locally, if there is no host name, or the host name is "
"``'localhost'``."
msgstr ""
"Abre o ficheiro localmente, se não houver nome de host ou se o nome de host "
"for ``'localhost'``."

#: ../../library/urllib.request.rst:1156
msgid ""
"This method is applicable only for local hostnames.  When a remote hostname "
"is given, a :exc:`~urllib.error.URLError` is raised."
msgstr ""
"Este método é aplicável apenas para nomes de host locais. Quando um nome de "
"host remoto é fornecido, uma exceção :exc:`~urllib.error.URLError` é "
"levantada."

#: ../../library/urllib.request.rst:1164
msgid "DataHandler Objects"
msgstr "Objetos DataHandler"

#: ../../library/urllib.request.rst:1168
msgid ""
"Read a data URL. This kind of URL contains the content encoded in the URL "
"itself. The data URL syntax is specified in :rfc:`2397`. This implementation "
"ignores white spaces in base64 encoded data URLs so the URL may be wrapped "
"in whatever source file it comes from. But even though some browsers don't "
"mind about a missing padding at the end of a base64 encoded data URL, this "
"implementation will raise a :exc:`ValueError` in that case."
msgstr ""
"Lê uma URL de dados. Este tipo de URL contém o conteúdo codificado na "
"própria URL. A sintaxe da URL de dados é especificada em :rfc:`2397`. Esta "
"implementação ignora espaços em branco em URLs de dados codificados em "
"base64, de modo que a URL pode ser quebrada no ficheiro de origem de onde "
"provém. Embora alguns navegadores não se importem com a falta de "
"preenchimento no final de uma URL de dados codificada em base64, esta "
"implementação levantará uma :exc:`ValueError` nesse caso."

#: ../../library/urllib.request.rst:1179
msgid "FTPHandler Objects"
msgstr "Objetos FTPHandler"

#: ../../library/urllib.request.rst:1184
msgid ""
"Open the FTP file indicated by *req*. The login is always done with empty "
"username and password."
msgstr ""
"Abre o ficheiro FTP indicado por *req*. O login é sempre feito com nome de "
"utilizador e senha vazios."

#: ../../library/urllib.request.rst:1191
msgid "CacheFTPHandler Objects"
msgstr "Objetos CacheFTPHandler"

#: ../../library/urllib.request.rst:1193
msgid ""
":class:`CacheFTPHandler` objects are :class:`FTPHandler` objects with the "
"following additional methods:"
msgstr ""
"Os objetos :class:`CacheFTPHandler` são objetos :class:`FTPHandler` com os "
"seguintes métodos adicionais:"

#: ../../library/urllib.request.rst:1199
msgid "Set timeout of connections to *t* seconds."
msgstr "Define o tempo limite das conexões para *t* segundos."

#: ../../library/urllib.request.rst:1204
msgid "Set maximum number of cached connections to *m*."
msgstr "Define o número máximo de conexões em cache para *m*."

#: ../../library/urllib.request.rst:1210
msgid "UnknownHandler Objects"
msgstr "Objetos UnknownHandler"

#: ../../library/urllib.request.rst:1215
msgid "Raise a :exc:`~urllib.error.URLError` exception."
msgstr "Levanta uma exceção :exc:`~urllib.error.URLError`."

#: ../../library/urllib.request.rst:1221
msgid "HTTPErrorProcessor Objects"
msgstr "Objetos HTTPErrorProcessor"

#: ../../library/urllib.request.rst:1227
msgid "For 200 error codes, the response object is returned immediately."
msgstr ""
"Para códigos de erro 200, o objeto de resposta é retornado imediatamente."

#: ../../library/urllib.request.rst:1229
msgid ""
"For non-200 error codes, this simply passes the job on to the :meth:`!"
"http_error_\\<type\\>` handler methods, via :meth:`OpenerDirector.error`. "
"Eventually, :class:`HTTPDefaultErrorHandler` will raise an :exc:`~urllib."
"error.HTTPError` if no other handler handles the error."
msgstr ""
"Para códigos de erro não-200, isto simplesmente passa a tarefa para os "
"métodos de manipulador :meth:`!http_error_\\<type\\>`, através de :meth:"
"`OpenerDirector.error`. Eventualmente, :class:`HTTPDefaultErrorHandler` "
"levantará uma exceção :exc:`~urllib.error.HTTPError` se nenhum outro "
"manipulador tratar o erro."

#: ../../library/urllib.request.rst:1237
msgid "Process HTTPS error responses."
msgstr "Processa respostas de erro HTTPS."

#: ../../library/urllib.request.rst:1239
msgid "The behavior is same as :meth:`http_response`."
msgstr "O comportamento é o mesmo que :meth:`http_response`."

#: ../../library/urllib.request.rst:1245
msgid "Examples"
msgstr "Exemplos"

#: ../../library/urllib.request.rst:1247
msgid ""
"In addition to the examples below, more examples are given in :ref:`urllib-"
"howto`."
msgstr ""
"Além dos exemplos abaixo, mais exemplos são dados em :ref:`urllib-howto`."

#: ../../library/urllib.request.rst:1250
msgid ""
"This example gets the python.org main page and displays the first 300 bytes "
"of it::"
msgstr ""
"Este exemplo obtém a página principal do python.org e mostra os primeiros "
"300 bytes dela::"

#: ../../library/urllib.request.rst:1253
msgid ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-"
"ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js ie7 "
"lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html "
"class=\"no-js ie8 lt-ie9\">"
msgstr ""
">>> import urllib.request\n"
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(300))\n"
"...\n"
"b'<!doctype html>\\n<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-"
"ie8 lt-ie9\">   <![endif]-->\\n<!--[if IE 7]>      <html class=\"no-js ie7 "
"lt-ie8 lt-ie9\">          <![endif]-->\\n<!--[if IE 8]>      <html "
"class=\"no-js ie8 lt-ie9\">"

#: ../../library/urllib.request.rst:1259
msgid ""
"Note that urlopen returns a bytes object.  This is because there is no way "
"for urlopen to automatically determine the encoding of the byte stream it "
"receives from the HTTP server. In general, a program will decode the "
"returned bytes object to string once it determines or guesses the "
"appropriate encoding."
msgstr ""
"Note que urlopen retorna um objeto bytes. Isto porque não há maneira de o "
"urlopen determinar automaticamente a codificação do fluxo de bytes que "
"recebe do servidor HTTP. Em geral, um programa decodificará o objeto bytes "
"retornado para uma string assim que determinar ou adivinhar a codificação "
"apropriada."

#: ../../library/urllib.request.rst:1265
msgid ""
"The following HTML spec document, https://html.spec.whatwg.org/#charset, "
"lists the various ways in which an HTML or an XML document could have "
"specified its encoding information."
msgstr ""
"O seguinte documento de especificação HTML, https://html.spec.whatwg.org/"
"#charset, lista as várias maneiras pelas quais um documento HTML ou XML pode "
"ter especificado as suas informações de codificação."

#: ../../library/urllib.request.rst:1269
msgid ""
"For additional information, see the W3C document: https://www.w3.org/"
"International/questions/qa-html-encoding-declarations."
msgstr ""
"Para informações adicionais, consulte o documento W3C: https://www.w3.org/"
"International/questions/qa-html-encoding-declarations."

#: ../../library/urllib.request.rst:1271
msgid ""
"As the python.org website uses *utf-8* encoding as specified in its meta "
"tag, we will use the same for decoding the bytes object::"
msgstr ""
"Como o site python.org usa a codificação *utf-8* conforme especificado na "
"sua meta tag, usaremos a mesma para decodificar o objeto bytes::"

#: ../../library/urllib.request.rst:1274
msgid ""
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"<!-"
msgstr ""
">>> with urllib.request.urlopen('http://www.python.org/') as f:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"<!-"

#: ../../library/urllib.request.rst:1281
msgid ""
"It is also possible to achieve the same result without using the :term:"
"`context manager` approach::"
msgstr ""
"Também é possível alcançar o mesmo resultado sem usar a abordagem de :term:"
"`gestor de contexto`::"

#: ../../library/urllib.request.rst:1284
msgid ""
">>> import urllib.request\n"
">>> f = urllib.request.urlopen('http://www.python.org/')\n"
">>> try:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"... finally:\n"
"...     f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"<!--"
msgstr ""
">>> import urllib.request\n"
">>> f = urllib.request.urlopen('http://www.python.org/')\n"
">>> try:\n"
"...     print(f.read(100).decode('utf-8'))\n"
"... finally:\n"
"...     f.close()\n"
"...\n"
"<!doctype html>\n"
"<!--[if lt IE 7]>   <html class=\"no-js ie6 lt-ie7 lt-ie8 lt-ie9\">   <!"
"[endif]-->\n"
"<!--"

#: ../../library/urllib.request.rst:1295
msgid ""
"In the following example, we are sending a data-stream to the stdin of a CGI "
"and reading the data it returns to us. Note that this example will only work "
"when the Python installation supports SSL. ::"
msgstr ""
"No exemplo seguinte, estamos a enviar um fluxo de dados para o stdin de um "
"CGI e a ler os dados que nos retorna. Note que este exemplo só funcionará "
"quando a instalação do Python suportar SSL. ::"

#: ../../library/urllib.request.rst:1299
msgid ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',\n"
"...                       data=b'This data is passed to stdin of the CGI')\n"
">>> with urllib.request.urlopen(req) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"...\n"
"Got Data: \"This data is passed to stdin of the CGI\""
msgstr ""
">>> import urllib.request\n"
">>> req = urllib.request.Request(url='https://localhost/cgi-bin/test.cgi',\n"
"...                       data=b'This data is passed to stdin of the CGI')\n"
">>> with urllib.request.urlopen(req) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"...\n"
"Got Data: \"This data is passed to stdin of the CGI\""

#: ../../library/urllib.request.rst:1307
msgid "The code for the sample CGI used in the above example is::"
msgstr "O código para o CGI de exemplo usado no exemplo acima é::"

#: ../../library/urllib.request.rst:1309
msgid ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"
msgstr ""
"#!/usr/bin/env python\n"
"import sys\n"
"data = sys.stdin.read()\n"
"print('Content-type: text/plain\\n\\nGot Data: \"%s\"' % data)"

#: ../../library/urllib.request.rst:1314
msgid "Here is an example of doing a ``PUT`` request using :class:`Request`::"
msgstr ""
"Aqui está um exemplo de como fazer um pedido ``PUT`` usando :class:"
"`Request`::"

#: ../../library/urllib.request.rst:1316
msgid ""
"import urllib.request\n"
"DATA = b'some data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, "
"method='PUT')\n"
"with urllib.request.urlopen(req) as f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"
msgstr ""
"import urllib.request\n"
"DATA = b'some data'\n"
"req = urllib.request.Request(url='http://localhost:8080', data=DATA, "
"method='PUT')\n"
"with urllib.request.urlopen(req) as f:\n"
"    pass\n"
"print(f.status)\n"
"print(f.reason)"

#: ../../library/urllib.request.rst:1324
msgid "Use of Basic HTTP Authentication::"
msgstr "Uso de Autenticação HTTP Básica::"

#: ../../library/urllib.request.rst:1326
msgid ""
"import urllib.request\n"
"# Create an OpenerDirector with support for Basic HTTP Authentication...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...and install it globally so it can be used with urlopen.\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"# Criar um OpenerDirector com suporte para Autenticação HTTP Básica...\n"
"auth_handler = urllib.request.HTTPBasicAuthHandler()\n"
"auth_handler.add_password(realm='PDQ Application',\n"
"                          uri='https://mahler:8092/site-updates.py',\n"
"                          user='klem',\n"
"                          passwd='kadidd!ehopper')\n"
"opener = urllib.request.build_opener(auth_handler)\n"
"# ...e instalá-lo globalmente para que possa ser usado com urlopen.\n"
"urllib.request.install_opener(opener)\n"
"with urllib.request.urlopen('http://www.example.com/login.html') as f:\n"
"    print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1339
msgid ""
":func:`build_opener` provides many handlers by default, including a :class:"
"`ProxyHandler`.  By default, :class:`ProxyHandler` uses the environment "
"variables named ``<scheme>_proxy``, where ``<scheme>`` is the URL scheme "
"involved.  For example, the :envvar:`!http_proxy` environment variable is "
"read to obtain the HTTP proxy's URL."
msgstr ""
":func:`build_opener` fornece muitos manipuladores por padrão, incluindo um :"
"class:`ProxyHandler`. Por padrão, :class:`ProxyHandler` usa as variáveis de "
"ambiente nomeadas ``<scheme>_proxy``, onde ``<scheme>`` é o esquema de URL "
"envolvido. Por exemplo, a variável de ambiente :envvar:`!http_proxy` é lida "
"para obter a URL do proxy HTTP."

#: ../../library/urllib.request.rst:1345
msgid ""
"This example replaces the default :class:`ProxyHandler` with one that uses "
"programmatically supplied proxy URLs, and adds proxy authorization support "
"with :class:`ProxyBasicAuthHandler`. ::"
msgstr ""
"Este exemplo substitui o :class:`ProxyHandler` predefinido por um que usa "
"URLs de proxy fornecidas programaticamente e adiciona suporte de autorização "
"de proxy com :class:`ProxyBasicAuthHandler`. ::"

#: ../../library/urllib.request.rst:1349
msgid ""
"proxy_handler = urllib.request.ProxyHandler({'http': 'http://www.example."
"com:3128/'})\n"
"proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()\n"
"proxy_auth_handler.add_password('realm', 'host', 'username', 'password')\n"
"\n"
"opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)\n"
"# This time, rather than install the OpenerDirector, we use it directly:\n"
"with opener.open('http://www.example.com/login.html') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""

#: ../../library/urllib.request.rst:1358
msgid "Adding HTTP headers:"
msgstr "Adicionando cabeçalhos HTTP:"

#: ../../library/urllib.request.rst:1360
msgid "Use the *headers* argument to the :class:`Request` constructor, or::"
msgstr "Use o argumento *headers* no construtor :class:`Request`, ou::"

#: ../../library/urllib.request.rst:1362
msgid ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# Customize the default User-Agent header value:\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')\n"
"with urllib.request.urlopen(req) as f:\n"
"    print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"req = urllib.request.Request('http://www.example.com/')\n"
"req.add_header('Referer', 'http://www.python.org/')\n"
"# Personalizar o valor do cabeçalho User-Agent predefinido:\n"
"req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')\n"
"with urllib.request.urlopen(req) as f:\n"
"    print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1371
msgid ""
":class:`OpenerDirector` automatically adds a :mailheader:`User-Agent` header "
"to every :class:`Request`.  To change this::"
msgstr ""
":class:`OpenerDirector` adiciona automaticamente um cabeçalho :mailheader:"
"`User-Agent` a cada :class:`Request`. Para alterar isto::"

#: ../../library/urllib.request.rst:1374
msgid ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"with opener.open('http://www.example.com/') as f:\n"
"   print(f.read().decode('utf-8'))"
msgstr ""
"import urllib.request\n"
"opener = urllib.request.build_opener()\n"
"opener.addheaders = [('User-agent', 'Mozilla/5.0')]\n"
"with opener.open('http://www.example.com/') as f:\n"
"   print(f.read().decode('utf-8'))"

#: ../../library/urllib.request.rst:1380
msgid ""
"Also, remember that a few standard headers (:mailheader:`Content-Length`, :"
"mailheader:`Content-Type` and :mailheader:`Host`) are added when the :class:"
"`Request` is passed to :func:`urlopen` (or :meth:`OpenerDirector.open`)."
msgstr ""
"Além disso, lembre-se de que alguns cabeçalhos padrão (:mailheader:`Content-"
"Length`, :mailheader:`Content-Type` e :mailheader:`Host`) são adicionados "
"quando o :class:`Request` é passado para :func:`urlopen` (ou :meth:"
"`OpenerDirector.open`)."

#: ../../library/urllib.request.rst:1387
msgid ""
"Here is an example session that uses the ``GET`` method to retrieve a URL "
"containing parameters::"
msgstr ""
"Aqui está uma sessão de exemplo que usa o método ``GET`` para recuperar uma "
"URL contendo parâmetros::"

#: ../../library/urllib.request.rst:1390
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> params = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> url = \"http://www.musi-cal.com/cgi-bin/query?%s\" % params\n"
">>> with urllib.request.urlopen(url) as f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."

#: ../../library/urllib.request.rst:1398
msgid ""
"The following example uses the ``POST`` method instead. Note that params "
"output from urlencode is encoded to bytes before it is sent to urlopen as "
"data::"
msgstr ""
"O exemplo seguinte usa o método ``POST`` em vez disso. Note que a saída de "
"params de urlencode é codificada para bytes antes de ser enviada para "
"urlopen como dados::"

#: ../../library/urllib.request.rst:1401
msgid ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as "
"f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> import urllib.parse\n"
">>> data = urllib.parse.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})\n"
">>> data = data.encode('ascii')\n"
">>> with urllib.request.urlopen(\"http://requestb.in/xrbl82xr\", data) as "
"f:\n"
"...     print(f.read().decode('utf-8'))\n"
"..."

#: ../../library/urllib.request.rst:1409
msgid ""
"The following example uses an explicitly specified HTTP proxy, overriding "
"environment settings::"
msgstr ""
"O exemplo seguinte usa um proxy HTTP explicitamente especificado, "
"substituindo as configurações de ambiente::"

#: ../../library/urllib.request.rst:1412
msgid ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.build_opener(urllib.request."
"ProxyHandler(proxies))\n"
">>> with opener.open(\"http://www.python.org\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""
">>> import urllib.request\n"
">>> proxies = {'http': 'http://proxy.example.com:8080/'}\n"
">>> opener = urllib.request.build_opener(urllib.request."
"ProxyHandler(proxies))\n"
">>> with opener.open(\"http://www.python.org\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."

#: ../../library/urllib.request.rst:1419
msgid ""
"The following example uses no proxies at all, overriding environment "
"settings::"
msgstr ""
"O exemplo seguinte não usa proxies, substituindo as configurações de "
"ambiente::"

#: ../../library/urllib.request.rst:1421
msgid ""
">>> import urllib.request\n"
">>> opener = urllib.request.build_opener(urllib.request.ProxyHandler({}}))\n"
">>> with opener.open(\"http://www.python.org/\") as f:\n"
"...     f.read().decode('utf-8')\n"
"..."
msgstr ""

#: ../../library/urllib.request.rst:1429
msgid "Legacy interface"
msgstr "Interface legada"

#: ../../library/urllib.request.rst:1431
msgid ""
"The following functions and classes are ported from the Python 2 module "
"``urllib`` (as opposed to ``urllib2``).  They might become deprecated at "
"some point in the future."
msgstr ""
"As seguintes funções e classes são portadas do módulo Python 2 ``urllib`` "
"(em oposição a ``urllib2``). Podem tornar-se obsoletas em algum momento no "
"futuro."

#: ../../library/urllib.request.rst:1437
msgid ""
"Copy a network object denoted by a URL to a local file. If the URL points to "
"a local file, the object will not be copied unless filename is supplied. "
"Return a tuple ``(filename, headers)`` where *filename* is the local file "
"name under which the object can be found, and *headers* is whatever the :"
"meth:`!info` method of the object returned by :func:`urlopen` returned (for "
"a remote object). Exceptions are the same as for :func:`urlopen`."
msgstr ""
"Copiar um objeto de rede denotado por uma URL para um ficheiro local. Se a "
"URL apontar para um ficheiro local, o objeto não será copiado a menos que o "
"nome do ficheiro seja fornecido. Retorna um tuplo ``(filename, headers)`` "
"onde *filename* é o nome do ficheiro local sob o qual o objeto pode ser "
"encontrado, e *headers* é o que o método :meth:`!info` do objeto retornado "
"por :func:`urlopen` retornou (para um objeto remoto). As exceções são as "
"mesmas que para :func:`urlopen`."

#: ../../library/urllib.request.rst:1444
msgid ""
"The second argument, if present, specifies the file location to copy to (if "
"absent, the location will be a tempfile with a generated name). The third "
"argument, if present, is a callable that will be called once on "
"establishment of the network connection and once after each block read "
"thereafter.  The callable will be passed three arguments; a count of blocks "
"transferred so far, a block size in bytes, and the total size of the file.  "
"The third argument may be ``-1`` on older FTP servers which do not return a "
"file size in response to a retrieval request."
msgstr ""
"O segundo argumento, se presente, especifica a localização do ficheiro para "
"copiar (se ausente, a localização será um ficheiro temporário com um nome "
"gerado). O terceiro argumento, se presente, é um objeto chamável que será "
"chamado uma vez no estabelecimento da conexão de rede e uma vez após cada "
"bloco lido posteriormente. O objeto chamável receberá três argumentos: uma "
"contagem dos blocos transferidos até agora, um tamanho de bloco em bytes e o "
"tamanho total do ficheiro. O terceiro argumento pode ser ``-1`` em "
"servidores FTP mais antigos que não retornam um tamanho de ficheiro em "
"resposta a um pedido de recuperação."

#: ../../library/urllib.request.rst:1453
msgid "The following example illustrates the most common usage scenario::"
msgstr "O exemplo seguinte ilustra o cenário de uso mais comum::"

#: ../../library/urllib.request.rst:1455
msgid ""
">>> import urllib.request\n"
">>> local_filename, headers = urllib.request.urlretrieve('http://python."
"org/')\n"
">>> html = open(local_filename)\n"
">>> html.close()"
msgstr ""

#: ../../library/urllib.request.rst:1460
msgid ""
"If the *url* uses the :file:`http:` scheme identifier, the optional *data* "
"argument may be given to specify a ``POST`` request (normally the request "
"type is ``GET``).  The *data* argument must be a bytes object in standard :"
"mimetype:`application/x-www-form-urlencoded` format; see the :func:`urllib."
"parse.urlencode` function."
msgstr ""
"Se a *url* usar o identificador de esquema :file:`http:`, o argumento "
"opcional *data* pode ser fornecido para especificar um pedido ``POST`` "
"(normalmente o tipo de pedido é ``GET``). O argumento *data* deve ser um "
"objeto bytes no formato padrão :mimetype:`application/x-www-form-"
"urlencoded`; veja a função :func:`urllib.parse.urlencode`."

#: ../../library/urllib.request.rst:1466
msgid ""
":func:`urlretrieve` will raise :exc:`~urllib.error.ContentTooShortError` "
"when it detects that the amount of data available  was less than the "
"expected amount (which is the size reported by a  *Content-Length* header). "
"This can occur, for example, when the  download is interrupted."
msgstr ""
":func:`urlretrieve` levantará :exc:`~urllib.error.ContentTooShortError` "
"quando detetar que a quantidade de dados disponível foi menor do que a "
"quantidade esperada (que é o tamanho reportado pelo cabeçalho *Content-"
"Length*). Isto pode ocorrer, por exemplo, quando o download é interrompido."

#: ../../library/urllib.request.rst:1471
msgid ""
"The *Content-Length* is treated as a lower bound: if there's more data  to "
"read, urlretrieve reads more data, but if less data is available,  it raises "
"the exception."
msgstr ""
"O *Content-Length* é tratado como um limite inferior: se houver mais dados "
"para ler, urlretrieve lê mais dados, mas se houver menos dados disponíveis, "
"levanta a exceção."

#: ../../library/urllib.request.rst:1475
msgid ""
"You can still retrieve the downloaded data in this case, it is stored in "
"the :attr:`!content` attribute of the exception instance."
msgstr ""
"Neste caso, ainda pode recuperar os dados descarregados, que estão "
"armazenados no atributo :attr:`!content` da instância da exceção."

#: ../../library/urllib.request.rst:1478
msgid ""
"If no *Content-Length* header was supplied, urlretrieve can not check the "
"size of the data it has downloaded, and just returns it.  In this case you "
"just have to assume that the download was successful."
msgstr ""
"Se nenhum cabeçalho *Content-Length* for fornecido, urlretrieve não pode "
"verificar o tamanho dos dados que descarregou e simplesmente os retorna. "
"Neste caso, tem de assumir que o download foi bem-sucedido."

#: ../../library/urllib.request.rst:1484
msgid ""
"Cleans up temporary files that may have been left behind by previous calls "
"to :func:`urlretrieve`."
msgstr ""
"Limpa ficheiros temporários que podem ter sido deixados por chamadas "
"anteriores a :func:`urlretrieve`."

#: ../../library/urllib.request.rst:1489
msgid ":mod:`urllib.request` Restrictions"
msgstr "Restrições do :mod:`urllib.request`"

#: ../../library/urllib.request.rst:1495
msgid ""
"Currently, only the following protocols are supported: HTTP (versions 0.9 "
"and 1.0), FTP, local files, and data URLs."
msgstr ""
"Atualmente, apenas os seguintes protocolos são suportados: HTTP (versões 0.9 "
"e 1.0), FTP, ficheiros locais e URLs de dados."

#: ../../library/urllib.request.rst:1498
msgid "Added support for data URLs."
msgstr "Adicionado suporte para URLs de dados."

#: ../../library/urllib.request.rst:1500
msgid ""
"The caching feature of :func:`urlretrieve` has been disabled until someone "
"finds the time to hack proper processing of Expiration time headers."
msgstr ""
"A funcionalidade de cache de :func:`urlretrieve` foi desativada até que "
"alguém tenha tempo para implementar corretamente o processamento dos "
"cabeçalhos de tempo de expiração."

#: ../../library/urllib.request.rst:1503
msgid ""
"There should be a function to query whether a particular URL is in the cache."
msgstr ""
"Deve existir uma função para consultar se uma URL específica está na cache."

#: ../../library/urllib.request.rst:1505
msgid ""
"For backward compatibility, if a URL appears to point to a local file but "
"the file can't be opened, the URL is re-interpreted using the FTP protocol.  "
"This can sometimes cause confusing error messages."
msgstr ""
"Por compatibilidade retroativa, se uma URL parecer apontar para um ficheiro "
"local mas o ficheiro não puder ser aberto, a URL é re-interpretada usando o "
"protocolo FTP. Isto pode, por vezes, causar mensagens de erro confusas."

#: ../../library/urllib.request.rst:1509
msgid ""
"The :func:`urlopen` and :func:`urlretrieve` functions can cause arbitrarily "
"long delays while waiting for a network connection to be set up.  This means "
"that it is difficult to build an interactive web client using these "
"functions without using threads."
msgstr ""
"As funções :func:`urlopen` e :func:`urlretrieve` podem causar atrasos "
"arbitrariamente longos enquanto aguardam que uma ligação de rede seja "
"estabelecida. Isto significa que é difícil construir um cliente web "
"interativo usando estas funções sem recorrer a threads."

#: ../../library/urllib.request.rst:1518
msgid ""
"The data returned by :func:`urlopen` or :func:`urlretrieve` is the raw data "
"returned by the server.  This may be binary data (such as an image), plain "
"text or (for example) HTML.  The HTTP protocol provides type information in "
"the reply header, which can be inspected by looking at the :mailheader:"
"`Content-Type` header.  If the returned data is HTML, you can use the "
"module :mod:`html.parser` to parse it."
msgstr ""
"Os dados retornados por :func:`urlopen` ou :func:`urlretrieve` são os dados "
"brutos retornados pelo servidor. Estes podem ser dados binários (como uma "
"imagem), texto simples ou (por exemplo) HTML. O protocolo HTTP fornece "
"informações de tipo no cabeçalho da resposta, que podem ser inspecionadas "
"olhando para o cabeçalho :mailheader:`Content-Type`. Se os dados retornados "
"forem HTML, pode usar o módulo :mod:`html.parser` para os analisar."

#: ../../library/urllib.request.rst:1527
msgid ""
"The code handling the FTP protocol cannot differentiate between a file and a "
"directory.  This can lead to unexpected behavior when attempting to read a "
"URL that points to a file that is not accessible.  If the URL ends in a ``/"
"``, it is assumed to refer to a directory and will be handled accordingly.  "
"But if an attempt to read a file leads to a 550 error (meaning the URL "
"cannot be found or is not accessible, often for permission reasons), then "
"the path is treated as a directory in order to handle the case when a "
"directory is specified by a URL but the trailing ``/`` has been left off.  "
"This can cause misleading results when you try to fetch a file whose read "
"permissions make it inaccessible; the FTP code will try to read it, fail "
"with a 550 error, and then perform a directory listing for the unreadable "
"file. If fine-grained control is needed, consider using the :mod:`ftplib` "
"module."
msgstr ""
"O código que trata o protocolo FTP não consegue diferenciar entre um "
"ficheiro e um diretório. Isto pode levar a comportamentos inesperados ao "
"tentar ler uma URL que aponta para um ficheiro que não é acessível. Se a URL "
"terminar em ``/``, assume-se que se refere a um diretório e será tratada "
"como tal. Mas se uma tentativa de ler um ficheiro resultar num erro 550 "
"(significando que a URL não pode ser encontrada ou não é acessível, muitas "
"vezes por razões de permissão), então o caminho é tratado como um diretório "
"para lidar com o caso em que um diretório é especificado por uma URL, mas a "
"barra final ``/`` foi omitida. Isto pode causar resultados enganosos quando "
"tenta buscar um ficheiro cujas permissões de leitura o tornam inacessível; o "
"código FTP tentará lê-lo, falhará com um erro 550 e, em seguida, executará "
"uma listagem de diretório para o ficheiro ilegível. Se for necessário um "
"controlo mais fino, considere usar o módulo :mod:`ftplib`."

#: ../../library/urllib.request.rst:1543
msgid ":mod:`urllib.response` --- Response classes used by urllib"
msgstr ":mod:`urllib.response` --- Classes de resposta usadas pelo urllib"

#: ../../library/urllib.request.rst:1548
msgid ""
"The :mod:`urllib.response` module defines functions and classes which define "
"a minimal file-like interface, including ``read()`` and ``readline()``. "
"Functions defined by this module are used internally by the :mod:`urllib."
"request` module. The typical response object is a :class:`urllib.response."
"addinfourl` instance:"
msgstr ""
"O módulo :mod:`urllib.response` define funções e classes que definem uma "
"interface mínima semelhante a um ficheiro, incluindo ``read()`` e "
"``readline()``. As funções definidas por este módulo são usadas internamente "
"pelo módulo :mod:`urllib.request`. O objeto de resposta típico é uma "
"instância :class:`urllib.response.addinfourl`:"

#: ../../library/urllib.request.rst:1557
msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr ""
"URL do recurso recuperado, comumente usada para determinar se um "
"redirecionamento foi seguido."

#: ../../library/urllib.request.rst:1561
msgid ""
"Returns the headers of the response in the form of an :class:`~email.message."
"EmailMessage` instance."
msgstr ""
"Retorna os cabeçalhos da resposta na forma de uma instância :class:`~email."
"message.EmailMessage`."

#: ../../library/urllib.request.rst:1567
msgid "Status code returned by server."
msgstr "Código de estado retornado pelo servidor."

#: ../../library/urllib.request.rst:1571
msgid "Deprecated in favor of :attr:`~addinfourl.url`."
msgstr "Obsoleto em favor de :attr:`~addinfourl.url`."

#: ../../library/urllib.request.rst:1576
msgid "Deprecated in favor of :attr:`~addinfourl.headers`."
msgstr "Obsoleto em favor de :attr:`~addinfourl.headers`."

#: ../../library/urllib.request.rst:1581 ../../library/urllib.request.rst:1586
msgid "Deprecated in favor of :attr:`~addinfourl.status`."
msgstr "Obsoleto em favor de :attr:`~addinfourl.status`."

#: ../../library/urllib.request.rst:1491 ../../library/urllib.request.rst:1514
msgid "HTTP"
msgstr "HTTP"

#: ../../library/urllib.request.rst:1491 ../../library/urllib.request.rst:1514
msgid "protocol"
msgstr "protocolo"

#: ../../library/urllib.request.rst:1491 ../../library/urllib.request.rst:1525
msgid "FTP"
msgstr "FTP"

#: ../../library/urllib.request.rst:1514
msgid "HTML"
msgstr "HTML"
