# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 16:01+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "Guia de Programação Funcional"

#: ../../howto/functional.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../../howto/functional.rst:0
msgid "Release"
msgstr "Versão"

#: ../../howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../../howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"Neste documento, faremos um tour pelas funcionalidades do Python adequadas "
"para implementar programas num estilo funcional. Após uma introdução aos "
"conceitos de programação funcional, analisaremos funcionalidades da "
"linguagem, como :term:`iterador`\\es e :term:`gerador`\\es, e módulos de "
"biblioteca relevantes, como :mod:`itertools` e :mod:`functools`."

#: ../../howto/functional.rst:16
msgid "Introduction"
msgstr "Introdução"

#: ../../howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"Esta secção explica o conceito básico de programação funcional; se apenas "
"estiver interessado em aprender sobre as funcionalidades da linguagem "
"Python, pode avançar para a próxima secção sobre :ref:`functional-howto-"
"iterators`."

#: ../../howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr ""
"As linguagens de programação suportam a decomposição de problemas de várias "
"formas diferentes:"

#: ../../howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"A maioria das linguagens de programação são **procedimentais**: os programas "
"são listas de instruções que dizem ao computador o que fazer com a entrada "
"do programa. C, Pascal, e até mesmo os shells Unix são linguagens "
"procedimentais."

#: ../../howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"Nas linguagens **declarativas**, escreve-se uma especificação que descreve o "
"problema a ser resolvido, e a implementação da linguagem descobre como "
"realizar o cálculo de forma eficiente. SQL é a linguagem declarativa com que "
"provavelmente está mais familiarizado; uma consulta SQL descreve o conjunto "
"de dados que pretende recuperar, e o motor SQL decide se deve analisar "
"tabelas ou usar índices, quais subcláusulas devem ser executadas primeiro, "
"etc."

#: ../../howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"Os programas **orientados a objetos** manipulam coleções de objetos. Os "
"objetos têm um estado interno e suportam métodos que consultam ou modificam "
"esse estado de alguma forma. Smalltalk e Java são linguagens orientadas a "
"objetos. C++ e Python são linguagens que suportam programação orientada a "
"objetos, mas não obrigam ao uso de funcionalidades orientadas a objetos."

#: ../../howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"A programação **funcional** decompõe um problema num conjunto de funções. "
"Idealmente, as funções apenas recebem entradas e produzem saídas, e não têm "
"qualquer estado interno que afete a saída produzida para uma determinada "
"entrada. Linguagens funcionais bem conhecidas incluem a família ML (Standard "
"ML, OCaml, e outras variantes) e Haskell."

#: ../../howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"Os designers de algumas linguagens de computador escolhem enfatizar uma "
"abordagem particular à programação. Isto muitas vezes torna difícil escrever "
"programas que usam uma abordagem diferente. Outras linguagens são multi-"
"paradigma e suportam várias abordagens diferentes. Lisp, C++, e Python são "
"multi-paradigma; pode-se escrever programas ou bibliotecas que são "
"maioritariamente procedimentais, orientados a objetos, ou funcionais em "
"todas estas linguagens. Num grande programa, diferentes secções podem ser "
"escritas usando abordagens diferentes; por exemplo, a interface gráfica pode "
"ser orientada a objetos, enquanto a lógica de processamento pode ser "
"procedimental ou funcional."

#: ../../howto/functional.rst:58
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"Num programa funcional, a entrada flui através de um conjunto de funções. "
"Cada função opera na sua entrada e produz alguma saída. O estilo funcional "
"desencoraja funções com efeitos secundários que modificam o estado interno "
"ou fazem outras mudanças que não são visíveis no valor de retorno da função. "
"Funções que não têm efeitos secundários são chamadas **puras**. Evitar "
"efeitos secundários significa não usar estruturas de dados que são "
"atualizadas à medida que o programa é executado; a saída de cada função deve "
"depender apenas da sua entrada."

#: ../../howto/functional.rst:66
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects, such as printing to the screen or writing to a disk file. "
"Another example is a call to the :func:`print` or :func:`time.sleep` "
"function, neither of which returns a useful value. Both are called only for "
"their side effects of sending some text to the screen or pausing execution "
"for a second."
msgstr ""
"Algumas linguagens são muito rigorosas quanto à pureza e não têm sequer "
"instruções de atribuição como ``a=3`` ou ``c = a + b``, mas é difícil evitar "
"todos os efeitos secundários, como imprimir no ecrã ou escrever num ficheiro "
"de disco. Outro exemplo é uma chamada à função :func:`print` ou :func:`time."
"sleep`, nenhuma das quais retorna um valor útil. Ambas são chamadas apenas "
"pelos seus efeitos secundários de enviar algum texto para o ecrã ou pausar a "
"execução por um segundo."

#: ../../howto/functional.rst:73
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Programas Python escritos em estilo funcional geralmente não vão ao extremo "
"de evitar todo o I/O ou todas as atribuições; em vez disso, fornecem uma "
"interface que parece funcional, mas usam funcionalidades não funcionais "
"internamente. Por exemplo, a implementação de uma função ainda usará "
"atribuições a variáveis locais, mas não modificará variáveis globais ou terá "
"outros efeitos secundários."

#: ../../howto/functional.rst:79
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"A programação funcional pode ser considerada o oposto da programação "
"orientada a objetos. Os objetos são pequenas cápsulas que contêm algum "
"estado interno, juntamente com uma coleção de chamadas de métodos que "
"permitem modificar esse estado, e os programas consistem em fazer o conjunto "
"certo de mudanças de estado. A programação funcional quer evitar mudanças de "
"estado tanto quanto possível e trabalha com dados que fluem entre funções. "
"Em Python, pode combinar as duas abordagens escrevendo funções que recebem e "
"retornam instâncias que representam objetos na sua aplicação (mensagens de e-"
"mail, transações, etc.)."

#: ../../howto/functional.rst:88
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"O design funcional pode parecer uma restrição estranha sob a qual trabalhar. "
"Por que deve evitar objetos e efeitos secundários? Há vantagens teóricas e "
"práticas no estilo funcional:"

#: ../../howto/functional.rst:92
msgid "Formal provability."
msgstr "Capacidade de prova formal."

#: ../../howto/functional.rst:93
msgid "Modularity."
msgstr "Modularidade."

#: ../../howto/functional.rst:94
msgid "Composability."
msgstr "Componibilidade."

#: ../../howto/functional.rst:95
msgid "Ease of debugging and testing."
msgstr "Facilidade de depuração e teste."

#: ../../howto/functional.rst:99
msgid "Formal provability"
msgstr "Capacidade de prova formal"

#: ../../howto/functional.rst:101
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"Uma vantagem teórica é que é mais fácil construir uma prova matemática de "
"que um programa funcional está correto."

#: ../../howto/functional.rst:104
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"Há muito tempo que os investigadores estão interessados em encontrar formas "
"de provar matematicamente que os programas estão corretos. Isto é diferente "
"de testar um programa em inúmeras entradas e concluir que a sua saída está "
"geralmente correta, ou ler o código-fonte de um programa e concluir que o "
"código parece estar certo; o objetivo é, em vez disso, uma prova rigorosa de "
"que um programa produz o resultado certo para todas as entradas possíveis."

#: ../../howto/functional.rst:111
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"A técnica usada para provar que os programas estão corretos é escrever "
"**invariantes** — propriedades dos dados de entrada e das variáveis do "
"programa que são sempre verdadeiras. Para cada linha de código, mostra-se "
"então que, se os invariantes X e Y forem verdadeiros **antes** da linha ser "
"executada, os invariantes ligeiramente diferentes X' e Y' são verdadeiros "
"**depois** da linha ser executada. Isto continua até se atingir o final do "
"programa, altura em que os invariantes devem corresponder às condições "
"desejadas na saída do programa."

#: ../../howto/functional.rst:119
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"A evitação de atribuições na programação funcional surgiu porque as "
"atribuições são difíceis de lidar com esta técnica; as atribuições podem "
"quebrar invariantes que eram verdadeiros antes da atribuição, sem produzir "
"novos invariantes que possam ser propagados."

#: ../../howto/functional.rst:124
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"Infelizmente, provar que os programas estão corretos é em grande parte "
"impraticável e não relevante para o software Python. Mesmo programas "
"triviais requerem provas com várias páginas; a prova de correção para um "
"programa moderadamente complicado seria enorme, e poucos ou nenhum dos "
"programas que usa diariamente (o interpretador Python, o seu analisador XML, "
"o seu navegador web) poderiam ser provados corretos. Mesmo que escrevesse ou "
"gerasse uma prova, haveria então a questão de verificar a prova; talvez haja "
"um erro nela, e acredite erroneamente que provou que o programa está correto."

#: ../../howto/functional.rst:135
msgid "Modularity"
msgstr "Modularidade"

#: ../../howto/functional.rst:137
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"Uma vantagem mais prática da programação funcional é que obriga a dividir o "
"problema em pequenas partes. Os programas tornam-se mais modulares como "
"resultado. É mais fácil especificar e escrever uma pequena função que faz "
"uma coisa do que uma grande função que realiza uma transformação complicada. "
"Funções pequenas também são mais fáceis de ler e de verificar quanto a erros."

#: ../../howto/functional.rst:145
msgid "Ease of debugging and testing"
msgstr "Facilidade de depuração e teste"

#: ../../howto/functional.rst:147
msgid "Testing and debugging a functional-style program is easier."
msgstr "Testar e depurar um programa em estilo funcional é mais fácil."

#: ../../howto/functional.rst:149
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"A depuração é simplificada porque as funções são geralmente pequenas e "
"claramente especificadas. Quando um programa não funciona, cada função é um "
"ponto de interface onde pode verificar se os dados estão corretos. Pode "
"observar as entradas e saídas intermédias para isolar rapidamente a função "
"responsável por um erro."

#: ../../howto/functional.rst:154
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Os testes são mais fáceis porque cada função é um potencial assunto para um "
"teste unitário. As funções não dependem do estado do sistema que precisa ser "
"replicado antes de executar um teste; em vez disso, só tem de sintetizar a "
"entrada correta e depois verificar se a saída corresponde às expectativas."

#: ../../howto/functional.rst:161
msgid "Composability"
msgstr "Componibilidade"

#: ../../howto/functional.rst:163
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"À medida que trabalha num programa em estilo funcional, escreverá várias "
"funções com entradas e saídas variadas. Algumas destas funções serão "
"inevitavelmente especializadas para uma aplicação particular, mas outras "
"serão úteis numa grande variedade de programas. Por exemplo, uma função que "
"recebe um caminho de diretório e retorna todos os ficheiros XML no "
"diretório, ou uma função que recebe um nome de ficheiro e retorna o seu "
"conteúdo, pode ser aplicada a muitas situações diferentes."

#: ../../howto/functional.rst:170
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"Com o tempo, formará uma biblioteca pessoal de utilitários. Muitas vezes, "
"montará novos programas organizando funções existentes numa nova "
"configuração e escrevendo algumas funções especializadas para a tarefa atual."

#: ../../howto/functional.rst:178
msgid "Iterators"
msgstr "Iteradores"

#: ../../howto/functional.rst:180
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Começarei por analisar uma funcionalidade da linguagem Python que é uma base "
"importante para escrever programas em estilo funcional: os iteradores."

#: ../../howto/functional.rst:183
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"Um iterador é um objeto que representa um fluxo de dados; este objeto "
"devolve os dados um elemento de cada vez. Um iterador Python deve suportar "
"um método chamado :meth:`~iterator.__next__` que não recebe argumentos e "
"sempre devolve o próximo elemento do fluxo. Se não houver mais elementos no "
"fluxo, :meth:`~iterator.__next__` deve levantar a exceção :exc:"
"`StopIteration`. Os iteradores não têm de ser finitos; é perfeitamente "
"razoável escrever um iterador que produza um fluxo infinito de dados."

#: ../../howto/functional.rst:191
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"A função integrada :func:`iter` recebe um objeto arbitrário e tenta devolver "
"um iterador que retornará o conteúdo ou elementos do objeto, levantando :exc:"
"`TypeError` se o objeto não suportar iteração. Vários dos tipos de dados "
"integrados do Python suportam iteração, sendo os mais comuns listas e "
"dicionários. Um objeto é chamado :term:`iterável` se puder obter um iterador "
"para ele."

#: ../../howto/functional.rst:198
msgid "You can experiment with the iteration interface manually:"
msgstr "Pode experimentar manualmente a interface de iteração:"

#: ../../howto/functional.rst:216
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"O Python espera objetos iteráveis em vários contextos diferentes, sendo o "
"mais importante a instrução :keyword:`for`. Na instrução ``for X in Y``, Y "
"deve ser um iterador ou algum objeto para o qual :func:`iter` possa criar um "
"iterador. Estas duas instruções são equivalentes:"

#: ../../howto/functional.rst:228
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Os iteradores podem ser materializados como listas ou tuplos usando as "
"funções construtoras :func:`list` ou :func:`tuple`:"

#: ../../howto/functional.rst:237
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"A desempacotamento de sequências também suporta iteradores: se souber que um "
"iterador devolverá N elementos, pode desempacotá-los num N-tuplo:"

#: ../../howto/functional.rst:246
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Funções integradas como :func:`max` e :func:`min` podem receber um único "
"argumento iterador e devolverão o maior ou o menor elemento. Os operadores "
"``\"in\"`` e ``\"not in\"`` também suportam iteradores: ``X in iterator`` é "
"verdadeiro se X for encontrado no fluxo devolvido pelo iterador. Encontrará "
"problemas óbvios se o iterador for infinito; :func:`max`, :func:`min` nunca "
"retornarão, e se o elemento X nunca aparecer no fluxo, os operadores "
"``\"in\"`` e ``\"not in\"`` também não retornarão."

#: ../../howto/functional.rst:254
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"Note que só pode avançar num iterador; não há forma de obter o elemento "
"anterior, reiniciar o iterador, ou fazer uma cópia dele. Os objetos "
"iteradores podem opcionalmente fornecer estas capacidades adicionais, mas o "
"protocolo do iterador apenas especifica o método :meth:`~iterator.__next__`. "
"As funções podem, portanto, consumir toda a saída do iterador, e se precisar "
"de fazer algo diferente com o mesmo fluxo, terá de criar um novo iterador."

#: ../../howto/functional.rst:264
msgid "Data Types That Support Iterators"
msgstr "Tipos de Dados que Suportam Iteradores"

#: ../../howto/functional.rst:266
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Já vimos como listas e tuplos suportam iteradores. Na verdade, qualquer tipo "
"de sequência Python, como strings, suportará automaticamente a criação de um "
"iterador."

#: ../../howto/functional.rst:270
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr ""
"Chamar :func:`iter` num dicionário devolve um iterador que percorrerá as "
"chaves do dicionário:"

#: ../../howto/functional.rst:290
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Note que a partir do Python 3.7, a ordem de iteração do dicionário é "
"garantida como sendo a mesma que a ordem de inserção. Em versões anteriores, "
"o comportamento não era especificado e podia variar entre implementações."

#: ../../howto/functional.rst:294
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"Aplicar :func:`iter` a um dicionário percorre sempre as chaves, mas os "
"dicionários têm métodos que devolvem outros iteradores. Se quiser iterar "
"sobre valores ou pares chave/valor, pode chamar explicitamente os métodos :"
"meth:`~dict.values` ou :meth:`~dict.items` para obter um iterador apropriado."

#: ../../howto/functional.rst:300
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"O construtor :func:`dict` pode aceitar um iterador que devolve um fluxo "
"finito de tuplos ``(key, value)``:"

#: ../../howto/functional.rst:307
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"Os ficheiros também suportam iteração chamando o método :meth:`~io."
"TextIOBase.readline` até que não haja mais linhas no ficheiro. Isto "
"significa que pode ler cada linha de um ficheiro assim:"

#: ../../howto/functional.rst:315
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Os conjuntos podem obter os seus conteúdos de um iterável e permitir que "
"itere sobre os elementos do conjunto:"

#: ../../howto/functional.rst:331
msgid "Generator expressions and list comprehensions"
msgstr "Expressões de gerador e compreensões de lista"

#: ../../howto/functional.rst:333
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Duas operações comuns na saída de um iterador são: 1) realizar alguma "
"operação para cada elemento, 2) selecionar um subconjunto de elementos que "
"cumprem alguma condição. Por exemplo, dada uma lista de strings, pode querer "
"remover espaços em branco no final de cada linha ou extrair todas as strings "
"que contêm uma determinada substring."

#: ../../howto/functional.rst:339
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"As compreensões de lista e expressões de gerador (forma curta: \"listcomps\" "
"e \"genexps\") são uma notação concisa para tais operações, emprestadas da "
"linguagem de programação funcional Haskell (https://www.haskell.org/). Pode "
"remover todos os espaços em branco de um fluxo de strings com o seguinte "
"código:"

#: ../../howto/functional.rst:352
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr ""
"Pode selecionar apenas certos elementos adicionando uma condição ``\"if\"``:"

#: ../../howto/functional.rst:357
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"Com uma compreensão de lista, obtém uma lista Python; ``stripped_list`` é "
"uma lista que contém as linhas resultantes, não um iterador. As expressões "
"de gerador devolvem um iterador que calcula os valores conforme necessário, "
"sem precisar de materializar todos os valores de uma vez. Isto significa que "
"as compreensões de lista não são úteis se estiver a trabalhar com iteradores "
"que devolvem um fluxo infinito ou uma quantidade muito grande de dados. As "
"expressões de gerador são preferíveis nestas situações."

#: ../../howto/functional.rst:364
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"As expressões de gerador são envolvidas por parênteses (\"()\") e as "
"compreensões de lista são envolvidas por parênteses retos (\"[]\"). As "
"expressões de gerador têm a forma:"

#: ../../howto/functional.rst:378
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"Mais uma vez, para uma compreensão de lista, apenas os parênteses exteriores "
"são diferentes (parênteses retos em vez de parênteses)."

#: ../../howto/functional.rst:381
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Os elementos da saída gerada serão os valores sucessivos de ``expression``. "
"As cláusulas ``if`` são todas opcionais; se presentes, ``expression`` é "
"apenas avaliada e adicionada ao resultado quando ``condition`` for "
"verdadeira."

#: ../../howto/functional.rst:385
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"As expressões de gerador sempre têm de ser escritas dentro de parênteses, "
"mas os parênteses que sinalizam uma chamada de função também contam. Se "
"quiser criar um iterador que será imediatamente passado a uma função, pode "
"escrever:"

#: ../../howto/functional.rst:391
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"As cláusulas ``for...in`` contêm as sequências a serem iteradas. As "
"sequências não têm de ter o mesmo comprimento, porque são iteradas da "
"esquerda para a direita, **não** em paralelo. Para cada elemento em "
"``sequence1``, ``sequence2`` é percorrida desde o início. ``sequence3`` é "
"então percorrida para cada par resultante de elementos de ``sequence1`` e "
"``sequence2``."

#: ../../howto/functional.rst:397
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"Por outras palavras, uma compreensão de lista ou expressão de gerador é "
"equivalente ao seguinte código Python:"

#: ../../howto/functional.rst:414
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Isto significa que quando há várias cláusulas ``for...in`` mas nenhuma "
"cláusula ``if``, o comprimento da saída resultante será igual ao produto dos "
"comprimentos de todas as sequências. Se tiver duas listas de comprimento 3, "
"a lista de saída terá 9 elementos:"

#: ../../howto/functional.rst:426
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Para evitar introduzir uma ambiguidade na gramática do Python, se "
"``expression`` estiver a criar um tuplo, deve ser envolvida por parênteses. "
"A primeira compreensão de lista abaixo é um erro de sintaxe, enquanto a "
"segunda está correta:"

#: ../../howto/functional.rst:437
msgid "Generators"
msgstr "Geradores"

#: ../../howto/functional.rst:439
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Os geradores são uma classe especial de funções que simplificam a tarefa de "
"escrever iteradores. As funções regulares calculam um valor e devolvem-no, "
"mas os geradores devolvem um iterador que devolve um fluxo de valores."

#: ../../howto/functional.rst:443
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Sem dúvida que está familiarizado com o funcionamento das chamadas de função "
"regulares em Python ou C. Quando chama uma função, esta obtém um espaço de "
"nomes privado onde as suas variáveis locais são criadas. Quando a função "
"atinge uma instrução ``return``, as variáveis locais são destruídas e o "
"valor é devolvido ao chamador. Uma chamada posterior à mesma função cria um "
"novo espaço de nomes privado e um novo conjunto de variáveis locais. Mas, e "
"se as variáveis locais não fossem eliminadas ao sair de uma função? E se "
"pudesse retomar a função onde parou? Isto é o que os geradores fornecem; "
"podem ser pensados como funções retomáveis."

#: ../../howto/functional.rst:452
msgid "Here's the simplest example of a generator function:"
msgstr "Aqui está o exemplo mais simples de uma função geradora:"

#: ../../howto/functional.rst:458
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"Qualquer função que contenha a palavra-chave :keyword:`yield` é uma função "
"geradora; isto é detetado pelo compilador de :term:`bytecode` do Python, que "
"compila a função de forma especial como resultado."

#: ../../howto/functional.rst:462
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"Quando chama uma função geradora, esta não devolve um único valor; em vez "
"disso, devolve um objeto gerador que suporta o protocolo de iterador. Ao "
"executar a expressão ``yield``, o gerador produz o valor de ``i``, "
"semelhante a uma instrução ``return``. A grande diferença entre ``yield`` e "
"uma instrução ``return`` é que, ao atingir um ``yield``, o estado de "
"execução do gerador é suspenso e as variáveis locais são preservadas. Na "
"próxima chamada ao método :meth:`~generator.__next__` do gerador, a função "
"retomará a execução."

#: ../../howto/functional.rst:471
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Aqui está um exemplo de utilização do gerador ``generate_ints()``:"

#: ../../howto/functional.rst:488
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"Poderia igualmente escrever ``for i in generate_ints(5)``, ou ``a, b, c = "
"generate_ints(3)``."

#: ../../howto/functional.rst:491
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"Dentro de uma função geradora, ``return value`` faz com que "
"``StopIteration(value)`` seja levantado a partir do método :meth:`~generator."
"__next__`. Uma vez que isto acontece, ou quando o final da função é "
"atingido, o fluxo de valores termina e o gerador não pode produzir mais "
"valores."

#: ../../howto/functional.rst:496
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"Poderia alcançar o efeito dos geradores manualmente escrevendo a sua própria "
"classe e armazenando todas as variáveis locais do gerador como variáveis de "
"instância. Por exemplo, devolver uma lista de inteiros poderia ser feito "
"definindo ``self.count`` para 0, e tendo o método :meth:`~iterator.__next__` "
"incrementar ``self.count`` e devolvê-lo. No entanto, para um gerador "
"moderadamente complicado, escrever uma classe correspondente pode ser muito "
"mais confuso."

#: ../../howto/functional.rst:504
msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"O conjunto de testes incluído na biblioteca do Python, :source:`Lib/test/"
"test_generators.py`, contém vários exemplos mais interessantes. Aqui está um "
"gerador que implementa uma travessia em ordem de uma árvore usando geradores "
"de forma recursiva:"

#: ../../howto/functional.rst:520
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Dois outros exemplos em ``test_generators.py`` produzem soluções para o "
"problema das N-Rainhas (colocar N rainhas num tabuleiro de xadrez NxN de "
"forma a que nenhuma rainha ameace outra) e o Percurso do Cavalo (encontrar "
"uma rota que leve um cavalo a todas as casas de um tabuleiro de xadrez NxN "
"sem visitar nenhuma casa duas vezes)."

#: ../../howto/functional.rst:528
msgid "Passing values into a generator"
msgstr "Passar valores para um gerador"

#: ../../howto/functional.rst:530
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"Nas versões do Python 2.4 e anteriores, os geradores apenas produziam saída. "
"Uma vez que o código de um gerador era invocado para criar um iterador, não "
"havia forma de passar qualquer nova informação para a função quando a sua "
"execução era retomada. Poderia improvisar esta capacidade fazendo com que o "
"gerador olhasse para uma variável global ou passando algum objeto mutável "
"que os chamadores modificariam depois, mas estas abordagens são confusas."

#: ../../howto/functional.rst:537
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"No Python 2.5, há uma forma simples de passar valores para um gerador. :"
"keyword:`yield` tornou-se uma expressão, devolvendo um valor que pode ser "
"atribuído a uma variável ou operado de outra forma:"

#: ../../howto/functional.rst:543
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Recomendo que **sempre** coloque parênteses à volta de uma expressão "
"``yield`` quando estiver a fazer algo com o valor devolvido, como no exemplo "
"acima. Os parênteses nem sempre são necessários, mas é mais fácil adicioná-"
"los sempre em vez de ter de se lembrar quando são necessários."

#: ../../howto/functional.rst:548
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(A :pep:`342` explica as regras exatas, que são que uma expressão :keyword:"
"`yield` deve sempre ser colocada entre parênteses, exceto quando ocorre como "
"expressão de nível superior no lado direito de uma atribuição. Isto "
"significa que pode escrever ``val = yield i``, mas tem de usar parênteses "
"quando há uma operação, como em ``val = (yield i) + 12``.)"

#: ../../howto/functional.rst:554
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"Os valores são enviados para um gerador chamando o seu método :meth:"
"`send(value) <generator.send>`. Este método retoma o código do gerador e a "
"expressão ``yield`` devolve o valor especificado. Se o método regular :meth:"
"`~generator.__next__` for chamado, o ``yield`` devolve ``None``."

#: ../../howto/functional.rst:559
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Aqui está um contador simples que incrementa por 1 e permite alterar o valor "
"do contador interno."

#: ../../howto/functional.rst:574
msgid "And here's an example of changing the counter:"
msgstr "E aqui está um exemplo de alteração do contador:"

#: ../../howto/functional.rst:591
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"Como ``yield`` muitas vezes devolverá ``None``, deve sempre verificar este "
"caso. Não utilize simplesmente o seu valor em expressões, a menos que tenha "
"a certeza de que o método :meth:`~generator.send` será o único método usado "
"para retomar a sua função geradora."

#: ../../howto/functional.rst:596
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr ""
"Além de :meth:`~generator.send`, existem dois outros métodos nos geradores:"

#: ../../howto/functional.rst:599
msgid ""
":meth:`throw(value) <generator.throw>` is used to raise an exception inside "
"the generator; the exception is raised by the ``yield`` expression where the "
"generator's execution is paused."
msgstr ""
":meth:`throw(value) <generator.throw>` é usado para levantar uma exceção "
"dentro do gerador; a exceção é levantada pela expressão ``yield`` onde a "
"execução do gerador está pausada."

#: ../../howto/functional.rst:603
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""

#: ../../howto/functional.rst:611
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"Se precisar de executar código de limpeza quando ocorrer um :exc:"
"`GeneratorExit`, sugiro usar um bloco ``try: ... finally:`` em vez de "
"capturar :exc:`GeneratorExit`."

#: ../../howto/functional.rst:614
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"O efeito cumulativo destas alterações é transformar os geradores de "
"produtores unidirecionais de informação em produtores e consumidores."

#: ../../howto/functional.rst:617
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Os geradores também se tornam **corrotinas**, uma forma mais generalizada de "
"sub-rotinas. As sub-rotinas são entradas num ponto e saídas noutro ponto (o "
"topo da função e uma instrução ``return``), mas as corrotinas podem ser "
"entradas, saídas e retomadas em muitos pontos diferentes (as instruções "
"``yield``)."

#: ../../howto/functional.rst:624
msgid "Built-in functions"
msgstr "Funções integradas"

#: ../../howto/functional.rst:626
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Vamos analisar com mais detalhe as funções integradas frequentemente usadas "
"com iteradores."

#: ../../howto/functional.rst:628
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Duas das funções integradas do Python, :func:`map` e :func:`filter`, "
"duplicam as funcionalidades das expressões de gerador:"

#: ../../howto/functional.rst:640
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` devolve um iterador sobre a sequência"

#: ../../howto/functional.rst:632
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."

#: ../../howto/functional.rst:642
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "Pode, claro, alcançar o mesmo efeito com uma compreensão de lista."

#: ../../howto/functional.rst:644
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` devolve um iterador sobre todos os "
"elementos da sequência que cumprem uma determinada condição, e é igualmente "
"duplicado por compreensões de lista. Um **predicado** é uma função que "
"devolve o valor de verdade de alguma condição; para uso com :func:`filter`, "
"o predicado deve receber um único valor."

#: ../../howto/functional.rst:657
msgid "This can also be written as a list comprehension:"
msgstr "Isto também pode ser escrito como uma compreensão de lista:"

#: ../../howto/functional.rst:663
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` conta os elementos no iterável, "
"devolvendo tuplos de 2 elementos contendo a contagem (a partir de *start*) e "
"cada elemento:"

#: ../../howto/functional.rst:673
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` é frequentemente usado ao percorrer uma lista e registar "
"os índices nos quais certas condições são cumpridas:"

#: ../../howto/functional.rst:681
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` recolhe todos os "
"elementos do iterável numa lista, ordena a lista e devolve o resultado "
"ordenado. Os argumentos *key* e *reverse* são passados para o método :meth:"
"`~list.sort` da lista construída:"

#: ../../howto/functional.rst:696
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"(Para uma discussão mais detalhada sobre ordenação, veja o :ref:"
"`sortinghowto`.)"

#: ../../howto/functional.rst:699
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"As funções integradas :func:`any(iter) <any>` e :func:`all(iter) <all>` "
"analisam os valores de verdade do conteúdo de um iterável. :func:`any` "
"devolve ``True`` se algum elemento no iterável for um valor verdadeiro, e :"
"func:`all` devolve ``True`` se todos os elementos forem valores verdadeiros:"

#: ../../howto/functional.rst:718
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` recebe um elemento de cada iterável e "
"devolve-os num tuplo:"

#: ../../howto/functional.rst:724
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"Não constrói uma lista na memória e esgota todos os iteradores de entrada "
"antes de devolver; em vez disso, os tuplos são construídos e devolvidos "
"apenas se forem solicitados. (O termo técnico para este comportamento é "
"`avaliação preguiçosa <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"

#: ../../howto/functional.rst:729
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Este iterador destina-se a ser usado com iteráveis que tenham todos o mesmo "
"comprimento. Se os iteráveis tiverem comprimentos diferentes, o fluxo "
"resultante terá o mesmo comprimento que o iterável mais curto:"

#: ../../howto/functional.rst:736
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Deve evitar fazer isto, pois um elemento pode ser retirado dos iteradores "
"mais longos e descartado. Isto significa que não pode continuar a usar os "
"iteradores, pois corre o risco de ignorar um elemento descartado."

#: ../../howto/functional.rst:742
msgid "The itertools module"
msgstr "O módulo itertools"

#: ../../howto/functional.rst:744
msgid ""
"The :mod:`itertools` module contains a number of commonly used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"O módulo :mod:`itertools` contém vários iteradores comumente usados, bem "
"como funções para combinar vários iteradores. Esta secção introduzirá o "
"conteúdo do módulo através de pequenos exemplos."

#: ../../howto/functional.rst:748
msgid "The module's functions fall into a few broad classes:"
msgstr "As funções do módulo podem ser divididas em algumas classes amplas:"

#: ../../howto/functional.rst:750
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "Funções que criam um novo iterador com base num iterador existente."

#: ../../howto/functional.rst:751
msgid "Functions for treating an iterator's elements as function arguments."
msgstr ""
"Funções para tratar os elementos de um iterador como argumentos de função."

#: ../../howto/functional.rst:752
msgid "Functions for selecting portions of an iterator's output."
msgstr "Funções para selecionar porções da saída de um iterador."

#: ../../howto/functional.rst:753
msgid "A function for grouping an iterator's output."
msgstr "Uma função para agrupar a saída de um iterador."

#: ../../howto/functional.rst:756
msgid "Creating new iterators"
msgstr "Criar novos iteradores"

#: ../../howto/functional.rst:758
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` devolve um fluxo "
"infinito de valores igualmente espaçados. Pode opcionalmente fornecer o "
"número inicial, que por defeito é 0, e o intervalo entre os números, que por "
"defeito é 1:"

#: ../../howto/functional.rst:769
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` guarda uma cópia do conteúdo "
"de um iterável fornecido e devolve um novo iterador que retorna os seus "
"elementos do primeiro ao último. O novo iterador repetirá estes elementos "
"infinitamente:"

#: ../../howto/functional.rst:776
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` devolve o elemento "
"fornecido *n* vezes, ou devolve o elemento infinitamente se *n* não for "
"fornecido:"

#: ../../howto/functional.rst:784
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` recebe um "
"número arbitrário de iteráveis como entrada e devolve todos os elementos do "
"primeiro iterador, depois todos os elementos do segundo, e assim por diante, "
"até que todos os iteráveis tenham sido esgotados:"

#: ../../howto/functional.rst:792
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"devolve um fluxo que é uma fatia do iterador. Com um único argumento *stop*, "
"devolverá os primeiros *stop* elementos. Se fornecer um índice inicial, "
"obterá *stop-start* elementos, e se fornecer um valor para *step*, os "
"elementos serão ignorados de acordo. Ao contrário da fatiação de strings e "
"listas do Python, não pode usar valores negativos para *start*, *stop*, ou "
"*step*:"

#: ../../howto/functional.rst:806
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replica um iterador; "
"devolve *n* iteradores independentes que retornarão todos os conteúdos do "
"iterador de origem. Se não fornecer um valor para *n*, o valor predefinido é "
"2. A replicação de iteradores requer guardar alguns dos conteúdos do "
"iterador de origem, pelo que isto pode consumir memória significativa se o "
"iterador for grande e um dos novos iteradores for consumido mais do que os "
"outros:"

#: ../../howto/functional.rst:825
msgid "Calling functions on elements"
msgstr "Chamar funções em elementos"

#: ../../howto/functional.rst:827
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"O módulo :mod:`operator` contém um conjunto de funções correspondentes aos "
"operadores do Python. Alguns exemplos são :func:`operator.add(a, b) "
"<operator.add>` (soma dois valores), :func:`operator.ne(a, b) <operator.ne>` "
"(o mesmo que ``a != b``), e :func:`operator.attrgetter('id') <operator."
"attrgetter>` (devolve um objeto chamável que obtém o atributo ``.id``)."

#: ../../howto/functional.rst:833
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assume que o "
"iterável devolverá um fluxo de tuplos e chama *func* usando estes tuplos "
"como argumentos:"

#: ../../howto/functional.rst:845
msgid "Selecting elements"
msgstr "Selecionar elementos"

#: ../../howto/functional.rst:847
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"Outro grupo de funções escolhe um subconjunto dos elementos de um iterador "
"com base num predicado."

#: ../../howto/functional.rst:850
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` é o "
"oposto de :func:`filter`, devolvendo todos os elementos para os quais o "
"predicado devolve falso:"

#: ../../howto/functional.rst:857
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` devolve "
"elementos enquanto o predicado devolver verdadeiro. Assim que o predicado "
"devolver falso, o iterador sinalizará o fim dos seus resultados:"

#: ../../howto/functional.rst:870
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` descarta "
"elementos enquanto o predicado devolver verdadeiro e, em seguida, devolve o "
"resto dos resultados do iterável:"

#: ../../howto/functional.rst:880
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` recebe dois "
"iteradores e devolve apenas os elementos de *data* para os quais o elemento "
"correspondente de *selectors* é verdadeiro, parando sempre que um deles for "
"esgotado:"

#: ../../howto/functional.rst:889
msgid "Combinatoric functions"
msgstr "Funções combinatórias"

#: ../../howto/functional.rst:891
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` devolve "
"um iterador que fornece todas as combinações possíveis de *r*-tuplos dos "
"elementos contidos em *iterable*:"

#: ../../howto/functional.rst:906
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"Os elementos dentro de cada tuplo permanecem na mesma ordem em que "
"*iterable* os devolveu. Por exemplo, o número 1 está sempre antes de 2, 3, 4 "
"ou 5 nos exemplos acima. Uma função semelhante, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, remove esta "
"restrição de ordem, devolvendo todas as disposições possíveis de comprimento "
"*r*:"

#: ../../howto/functional.rst:925
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"Se não fornecer um valor para *r*, é usado o comprimento do iterável, o que "
"significa que todos os elementos são permutados."

#: ../../howto/functional.rst:928
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"Note que estas funções produzem todas as combinações possíveis por posição e "
"não exigem que os conteúdos de *iterable* sejam únicos:"

#: ../../howto/functional.rst:935
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"O tuplo idêntico ``('a', 'a', 'b')`` ocorre duas vezes, mas as duas strings "
"'a' vieram de posições diferentes."

#: ../../howto/functional.rst:938
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
"A função :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` relaxa uma restrição diferente: "
"os elementos podem ser repetidos dentro de um único tuplo. Conceitualmente, "
"um elemento é selecionado para a primeira posição de cada tuplo e depois é "
"substituído antes de o segundo elemento ser selecionado:"

#: ../../howto/functional.rst:953
msgid "Grouping elements"
msgstr "Agrupar elementos"

#: ../../howto/functional.rst:955
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"A última função que discutirei, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, é a mais complicada. ``key_func(elem)`` "
"é uma função que pode calcular um valor de chave para cada elemento "
"devolvido pelo iterável. Se não fornecer uma função de chave, a chave é "
"simplesmente cada elemento em si."

#: ../../howto/functional.rst:960
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` recolhe todos os elementos consecutivos do "
"iterável subjacente que têm o mesmo valor de chave e devolve um fluxo de 2-"
"tuplos contendo um valor de chave e um iterador para os elementos com essa "
"chave."

#: ../../howto/functional.rst:988
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby` assume que os conteúdos do iterável subjacente já "
"estarão ordenados com base na chave. Note que os iteradores devolvidos "
"também usam o iterável subjacente, pelo que tem de consumir os resultados do "
"iterador-1 antes de solicitar o iterador-2 e a sua chave correspondente."

#: ../../howto/functional.rst:995
msgid "The functools module"
msgstr "O módulo functools"

#: ../../howto/functional.rst:997
msgid ""
"The :mod:`functools` module contains some higher-order functions. A **higher-"
"order function** takes one or more functions as input and returns a new "
"function.  The most useful tool in this module is the :func:`functools."
"partial` function."
msgstr ""
"O módulo :mod:`functools` contém algumas funções de ordem superior. Uma "
"**função de ordem superior** recebe uma ou mais funções como entrada e "
"devolve uma nova função. A ferramenta mais útil neste módulo é a função :"
"func:`functools.partial`."

#: ../../howto/functional.rst:1002
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"Para programas escritos num estilo funcional, por vezes desejará construir "
"variantes de funções existentes que têm alguns dos parâmetros preenchidos. "
"Considere uma função Python ``f(a, b, c)``; pode desejar criar uma nova "
"função ``g(b, c)`` que seja equivalente a ``f(1, b, c)``; está a preencher "
"um valor para um dos parâmetros de ``f()``. Isto é chamado de \"aplicação "
"parcial de função\"."

#: ../../howto/functional.rst:1008
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
"O construtor para :func:`~functools.partial` recebe os argumentos "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``. O objeto "
"resultante é chamável, pelo que pode simplesmente chamá-lo para invocar "
"``function`` com os argumentos preenchidos."

#: ../../howto/functional.rst:1013
msgid "Here's a small but realistic example::"
msgstr "Aqui está um exemplo pequeno mas realista::"

#: ../../howto/functional.rst:1025
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"realiza cumulativamente uma operação em todos os elementos do iterável e, "
"portanto, não pode ser aplicada a iteráveis infinitos. *func* deve ser uma "
"função que recebe dois elementos e devolve um único valor. :func:`functools."
"reduce` recebe os dois primeiros elementos A e B devolvidos pelo iterador e "
"calcula ``func(A, B)``. Em seguida, solicita o terceiro elemento, C, calcula "
"``func(func(A, B), C)``, combina este resultado com o quarto elemento "
"devolvido e continua até que o iterável seja esgotado. Se o iterável não "
"devolver valores, é levantada uma exceção :exc:`TypeError`. Se o valor "
"inicial for fornecido, é usado como ponto de partida e ``func(initial_value, "
"A)`` é o primeiro cálculo:"

#: ../../howto/functional.rst:1049
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"Se usar :func:`operator.add` com :func:`functools.reduce`, somará todos os "
"elementos do iterável. Este caso é tão comum que existe uma função integrada "
"especial chamada :func:`sum` para calculá-lo:"

#: ../../howto/functional.rst:1061
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"Para muitas utilizações de :func:`functools.reduce`, no entanto, pode ser "
"mais claro escrever simplesmente um ciclo :keyword:`for` óbvio:"

#: ../../howto/functional.rst:1073
msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`~itertools.accumulate` returns an "
"iterator that also yields each partial result::"
msgstr ""
"Uma função relacionada é :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`. Realiza o mesmo cálculo, mas em vez de "
"devolver apenas o resultado final, :func:`~itertools.accumulate` devolve um "
"iterador que também produz cada resultado parcial:"

#: ../../howto/functional.rst:1086
msgid "The operator module"
msgstr "O módulo operator"

#: ../../howto/functional.rst:1088
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"O módulo :mod:`operator` foi mencionado anteriormente. Contém um conjunto de "
"funções correspondentes aos operadores do Python. Estas funções são "
"frequentemente úteis em código de estilo funcional porque evitam que tenha "
"de escrever funções triviais que realizam uma única operação."

#: ../../howto/functional.rst:1093
msgid "Some of the functions in this module are:"
msgstr "Algumas das funções neste módulo são:"

#: ../../howto/functional.rst:1095
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"Operações matemáticas: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

#: ../../howto/functional.rst:1096
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Operações lógicas: ``not_()``, ``truth()``."

#: ../../howto/functional.rst:1097
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Operações bit a bit: ``and_()``, ``or_()``, ``invert()``."

#: ../../howto/functional.rst:1098
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Comparações: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, e ``ge()``."

#: ../../howto/functional.rst:1099
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "Identidade de objeto: ``is_()``, ``is_not()``."

#: ../../howto/functional.rst:1101
msgid "Consult the operator module's documentation for a complete list."
msgstr "Consulte a documentação do módulo operator para uma lista completa."

#: ../../howto/functional.rst:1105
msgid "Small functions and the lambda expression"
msgstr "Pequenas funções e a expressão lambda"

#: ../../howto/functional.rst:1107
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"Ao escrever programas em estilo funcional, muitas vezes precisará de "
"pequenas funções que atuam como predicados ou que combinam elementos de "
"alguma forma."

#: ../../howto/functional.rst:1110
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"Se houver uma função integrada do Python ou uma função de módulo adequada, "
"não precisa de definir uma nova função:"

#: ../../howto/functional.rst:1116
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"Se a função de que necessita não existir, terá de a escrever. Uma forma de "
"escrever pequenas funções é usar a expressão :keyword:`lambda`. ``lambda`` "
"recebe um número de parâmetros e uma expressão que combina estes parâmetros "
"e cria uma função anónima que devolve o valor da expressão:"

#: ../../howto/functional.rst:1125
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr ""
"Uma alternativa é simplesmente usar a instrução ``def`` e definir uma função "
"da forma habitual:"

#: ../../howto/functional.rst:1134
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"Qual alternativa é preferível? Essa é uma questão de estilo; o meu curso "
"habitual é evitar o uso de ``lambda``."

#: ../../howto/functional.rst:1137
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"Uma razão para a minha preferência é que ``lambda`` é bastante limitado nas "
"funções que pode definir. O resultado tem de ser calculável como uma única "
"expressão, o que significa que não pode ter comparações ``if... elif... "
"else`` multi-caminho ou instruções ``try... except``. Se tentar fazer "
"demasiado numa instrução ``lambda``, acabará com uma expressão "
"excessivamente complicada que é difícil de ler. Rápido, o que está a fazer o "
"seguinte código? :"

#: ../../howto/functional.rst:1147
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"Pode perceber, mas leva tempo a desvendar a expressão para perceber o que "
"está a acontecer. Usar uma instrução ``def`` aninhada curta torna as coisas "
"um pouco melhores:"

#: ../../howto/functional.rst:1157
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "Mas seria melhor ainda se tivesse simplesmente usado um ciclo ``for``:"

#: ../../howto/functional.rst:1163
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "Ou a função integrada :func:`sum` e uma expressão de gerador:"

#: ../../howto/functional.rst:1167
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"Muitas utilizações de :func:`functools.reduce` são mais claras quando "
"escritas como ciclos ``for``."

#: ../../howto/functional.rst:1169
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Fredrik Lundh sugeriu uma vez o seguinte conjunto de regras para refatorar o "
"uso de ``lambda``:"

#: ../../howto/functional.rst:1172
msgid "Write a lambda function."
msgstr "Escreva uma função lambda."

#: ../../howto/functional.rst:1173
msgid "Write a comment explaining what the heck that lambda does."
msgstr "Escreva um comentário explicando o que raio essa lambda faz."

#: ../../howto/functional.rst:1174
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr ""
"Estude o comentário durante algum tempo e pense num nome que capture a "
"essência do comentário."

#: ../../howto/functional.rst:1176
msgid "Convert the lambda to a def statement, using that name."
msgstr "Converta a lambda numa instrução def, usando esse nome."

#: ../../howto/functional.rst:1177
msgid "Remove the comment."
msgstr "Remova o comentário."

#: ../../howto/functional.rst:1179
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"Gosto realmente destas regras, mas é livre de discordar se este estilo sem "
"lambda é melhor."

#: ../../howto/functional.rst:1184
msgid "Revision History and Acknowledgements"
msgstr "Histórico de revisões e agradecimentos"

#: ../../howto/functional.rst:1186
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"O autor gostaria de agradecer às seguintes pessoas por oferecerem sugestões, "
"correções e assistência com vários rascunhos deste artigo: Ian Bicking, Nick "
"Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike Krell, Leandro "
"Lameiro, Jussi Salmela, Collin Winter, Blake Winton."

#: ../../howto/functional.rst:1191
msgid "Version 0.1: posted June 30 2006."
msgstr "Versão 0.1: publicada a 30 de junho de 2006."

#: ../../howto/functional.rst:1193
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr ""
"Versão 0.11: publicada a 1 de julho de 2006. Correções de erros tipográficos."

#: ../../howto/functional.rst:1195
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Versão 0.2: publicada a 10 de julho de 2006. Fundiu as secções genexp e "
"listcomp numa só. Correções de erros tipográficos."

#: ../../howto/functional.rst:1198
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Versão 0.21: Adicionadas mais referências sugeridas na lista de correio "
"tutor."

#: ../../howto/functional.rst:1200
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Versão 0.30: Adicionada uma secção sobre o módulo ``functional`` escrita por "
"Collin Winter; adicionada uma pequena secção sobre o módulo operator; "
"algumas outras edições."

#: ../../howto/functional.rst:1205
msgid "References"
msgstr "Referências"

#: ../../howto/functional.rst:1208
msgid "General"
msgstr "Geral"

#: ../../howto/functional.rst:1210
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  The book can be found at https://"
"mitpress.mit.edu/sicp.  In this classic textbook of computer science, "
"chapters 2 and 3 discuss the use of sequences and streams to organize the "
"data flow inside a program.  The book uses Scheme for its examples, but many "
"of the design approaches described in these chapters are applicable to "
"functional-style Python code."
msgstr ""
"**Estrutura e Interpretação de Programas de Computador**, de Harold Abelson "
"e Gerald Jay Sussman com Julie Sussman. O livro pode ser encontrado em "
"https://mitpress.mit.edu/sicp. Neste livro clássico de ciência da "
"computação, os capítulos 2 e 3 discutem o uso de sequências e fluxos para "
"organizar o fluxo de dados dentro de um programa. O livro usa Scheme para os "
"seus exemplos, mas muitas das abordagens de design descritas nestes "
"capítulos são aplicáveis a código Python em estilo funcional."

#: ../../howto/functional.rst:1218
msgid ""
"https://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""

#: ../../howto/functional.rst:1221
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: Entrada geral na "
"Wikipedia que descreve a programação funcional."

#: ../../howto/functional.rst:1224
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: Entrada para corrotinas."

#: ../../howto/functional.rst:1226
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr ""
"https://en.wikipedia.org/wiki/Currying: Entrada para o conceito de currying."

#: ../../howto/functional.rst:1229
msgid "Python-specific"
msgstr "Específico do Python"

#: ../../howto/functional.rst:1231
msgid ""
"https://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"https://gnosis.cx/TPiP/: O primeiro capítulo do livro de David Mertz :title-"
"reference:`Processamento de Texto em Python` discute programação funcional "
"para processamento de texto, na secção intitulada \"Utilizando Funções de "
"Ordem Superior no Processamento de Texto\"."

#: ../../howto/functional.rst:1236
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://developer.ibm.com/articles/l-"
"prog/>`__, `part 2 <https://developer.ibm.com/tutorials/l-prog2/>`__, and "
"`part 3 <https://developer.ibm.com/tutorials/l-prog3/>`__,"
msgstr ""
"Mertz também escreveu uma série de três artigos sobre programação funcional "
"para o site DeveloperWorks da IBM; veja `parte 1 <https://developer.ibm.com/"
"articles/l-prog/>`__, `parte 2 <https://developer.ibm.com/tutorials/l-prog2/"
">`__, e `parte 3 <https://developer.ibm.com/tutorials/l-prog3/>`__."

#: ../../howto/functional.rst:1244
msgid "Python documentation"
msgstr "Documentação do Python"

#: ../../howto/functional.rst:1246
msgid "Documentation for the :mod:`itertools` module."
msgstr "Documentação para o módulo :mod:`itertools`."

#: ../../howto/functional.rst:1248
msgid "Documentation for the :mod:`functools` module."
msgstr "Documentação para o módulo :mod:`functools`."

#: ../../howto/functional.rst:1250
msgid "Documentation for the :mod:`operator` module."
msgstr "Documentação para o módulo :mod:`operator`."

#: ../../howto/functional.rst:1252
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Expressões de Gerador\""

#: ../../howto/functional.rst:1254
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Corrotinas via Geradores Melhorados\" descreve as novas "
"funcionalidades de geradores no Python 2.5."
