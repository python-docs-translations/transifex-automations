# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-03 14:56+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:5
msgid "A Conceptual Overview of :mod:`!asyncio`"
msgstr "Uma visão geral conceitual de :mod:`!asyncio`"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:7
msgid ""
"This :ref:`HOWTO <how-tos>` article seeks to help you build a sturdy mental "
"model of how :mod:`asyncio` fundamentally works, helping you understand the "
"how and why behind the recommended patterns."
msgstr ""
"Este artigo :ref:`Como Fazer <how-tos>` tem como objetivo ajudá-lo a "
"compilar um modelo mental sólido de como :mod:`asyncio` funciona "
"fundamentalmente, ajudando-o a compreender o como e o porquê por trás dos "
"padrões recomendados."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:11
msgid ""
"You might be curious about some key :mod:`!asyncio` concepts. By the end of "
"this article, you'll be able to comfortably answer these questions:"
msgstr ""
"Pode estar curioso sobre alguns conceitos-chave do :mod:`!asyncio`. No final "
"deste artigo, será capaz de responder confortavelmente a estas perguntas:"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:14
msgid "What's happening behind the scenes when an object is awaited?"
msgstr "O que acontece por trás das cenas quando um objeto é aguardado?"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:15
msgid ""
"How does :mod:`!asyncio` differentiate between a task which doesn't need CPU "
"time (such as a network request or file read) as opposed to a task that does "
"(such as computing n-factorial)?"
msgstr ""
"Como é que o :mod:`!asyncio` diferencia entre uma tarefa que não precisa de "
"tempo de CPU (como um pedido de rede ou leitura de ficheiro) e uma tarefa "
"que precisa (como calcular o fatorial de n)?"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:18
msgid ""
"How to write an asynchronous variant of an operation, such as an async sleep "
"or database request."
msgstr ""
"Como escrever uma variante assíncrona de uma operação, como uma espera "
"assíncrona ou um pedido de base de dados."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:23
msgid ""
"The `guide <https://github.com/anordin95/a-conceptual-overview-of-asyncio/ "
"tree/main>`_ that inspired this HOWTO article, by Alexander Nordin."
msgstr ""
"O `guia <https://github.com/anordin95/a-conceptual-overview-of-asyncio/ tree/"
"main>`_ que inspirou este artigo COMO FAZER, por Alexander Nordin."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:25
msgid ""
"This in-depth `YouTube tutorial series <https://www.youtube.com/ watch?"
"v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB>`_ on ``asyncio`` "
"created by Python core team member, Łukasz Langa."
msgstr ""
"Esta série de tutoriais aprofundados no `YouTube sobre ``asyncio`` <https://"
"www.youtube.com/ watch?"
"v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB>`_, criada por Łukasz "
"Langa, membro da equipa principal do Python."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:28
msgid ""
"`500 Lines or Less: A Web Crawler With asyncio Coroutines <https:// aosabook."
"org/en/500L/a-web-crawler-with-asyncio-coroutines.html>`_ by A. Jesse Jiryu "
"Davis and Guido van Rossum."
msgstr ""
"`500 Linhas ou Menos: Um Web Crawler com Corrotinas asyncio <https:// "
"aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html>`_, por A. "
"Jesse Jiryu Davis e Guido van Rossum."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:34
msgid "A conceptual overview part 1: the high-level"
msgstr "Uma visão geral conceitual, parte 1: o nível elevado"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:36
msgid ""
"In part 1, we'll cover the main, high-level building blocks of :mod:`!"
"asyncio`: the event loop, coroutine functions, coroutine objects, tasks, and "
"``await``."
msgstr ""
"Na parte 1, abordaremos os principais blocos de construção de alto nível do :"
"mod:`!asyncio`: o ciclo de eventos, funções de corrotina, objetos de "
"corrotina, tarefas e ``await``."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:41
msgid "Event Loop"
msgstr "Ciclo de Eventos"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:43
msgid ""
"Everything in :mod:`!asyncio` happens relative to the event loop. It's the "
"star of the show. It's like an orchestra conductor. It's behind the scenes "
"managing resources. Some power is explicitly granted to it, but a lot of its "
"ability to get things done comes from the respect and cooperation of its "
"worker bees."
msgstr ""
"Tudo no :mod:`!asyncio` acontece em relação ao ciclo de eventos. É a estrela "
"do espetáculo. É como um maestro de orquestra. Está por trás dos bastidores "
"a gerir recursos. Algum poder é explicitamente concedido a ele, mas grande "
"parte da sua capacidade de realizar tarefas vem do respeito e cooperação das "
"suas trabalhadoras."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:50
msgid ""
"In more technical terms, the event loop contains a collection of jobs to be "
"run. Some jobs are added directly by you, and some indirectly by :mod:`!"
"asyncio`. The event loop takes a job from its backlog of work and invokes it "
"(or \"gives it control\"), similar to calling a function, and then that job "
"runs. Once it pauses or completes, it returns control to the event loop. The "
"event loop will then select another job from its pool and invoke it. You can "
"*roughly* think of the collection of jobs as a queue: jobs are added and "
"then processed one at a time, generally (but not always) in order. This "
"process repeats indefinitely, with the event loop cycling endlessly onwards. "
"If there are no more jobs pending execution, the event loop is smart enough "
"to rest and avoid needlessly wasting CPU cycles, and will come back when "
"there's more work to be done."
msgstr ""
"Em termos mais técnicos, o ciclo de eventos contém uma coleção de tarefas a "
"serem executadas. Algumas tarefas são adicionadas diretamente por si, e "
"outras indiretamente pelo :mod:`!asyncio`. O ciclo de eventos retira uma "
"tarefa da sua lista de pendentes e invoca-a (ou \"dá-lhe controlo\"), "
"semelhante a chamar uma função, e depois essa tarefa é executada. Assim que "
"pausar ou terminar, devolve o controlo ao ciclo de eventos. O ciclo de "
"eventos selecionará então outra tarefa da sua lista e invocá-la-á. Pode "
"pensar *grosseiramente* na coleção de tarefas como uma fila: as tarefas são "
"adicionadas e depois processadas uma de cada vez, geralmente (mas nem "
"sempre) por ordem. Este processo repete-se indefinidamente, com o ciclo de "
"eventos a circular sem fim. Se não houver mais tarefas pendentes de "
"execução, o ciclo de eventos é inteligente o suficiente para descansar e "
"evitar desperdício desnecessário de ciclos de CPU, e voltará quando houver "
"mais trabalho a fazer."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:64
msgid ""
"Effective execution relies on jobs sharing well and cooperating; a greedy "
"job could hog control and leave the other jobs to starve, rendering the "
"overall event loop approach rather useless."
msgstr ""
"A execução eficaz depende de as tarefas partilharem bem e cooperarem; uma "
"tarefa gananciosa poderia monopolizar o controlo e deixar as outras tarefas "
"sem recursos, tornando a abordagem geral do ciclo de eventos bastante inútil."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:70
msgid ""
"import asyncio\n"
"\n"
"# This creates an event loop and indefinitely cycles through\n"
"# its collection of jobs.\n"
"event_loop = asyncio.new_event_loop()\n"
"event_loop.run_forever()"
msgstr ""
"import asyncio\n"
"\n"
"# Isto cria um ciclo de eventos e percorre indefinidamente\n"
"# a sua coleção de tarefas.\n"
"event_loop = asyncio.new_event_loop()\n"
"event_loop.run_forever()"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:79
msgid "Asynchronous functions and coroutines"
msgstr "Funções assíncronas e corrotinas"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:81
msgid "This is a basic, boring Python function::"
msgstr "Esta é uma função Python básica e aborrecida::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:83
msgid ""
"def hello_printer():\n"
"    print(\n"
"        \"Hi, I am a lowly, simple printer, though I have all I \"\n"
"        \"need in life -- \\nfresh paper and my dearly beloved octopus \"\n"
"        \"partner in crime.\"\n"
"    )"
msgstr ""
"def hello_printer():\n"
"    print(\n"
"        \"Olá, sou uma impressora humilde e simples, embora tenha tudo o que "
"\"\n"
"        \"preciso na vida -- \\npapel fresco e o meu amado parceiro polvo "
"\"\n"
"        \"em crimes.\"\n"
"    )"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:90
msgid "Calling a regular function invokes its logic or body::"
msgstr "Chamar uma função normal invoca a sua lógica ou corpo::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:92
msgid ""
">>> hello_printer()\n"
"Hi, I am a lowly, simple printer, though I have all I need in life --\n"
"fresh paper and my dearly beloved octopus partner in crime."
msgstr ""
">>> hello_printer()\n"
"Olá, sou uma impressora humilde e simples, embora tenha tudo o que preciso "
"na vida --\n"
"papel fresco e o meu amado parceiro polvo em crimes."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:96
msgid ""
"The :ref:`async def <async def>`, as opposed to just a plain ``def``, makes "
"this an asynchronous function (or \"coroutine function\"). Calling it "
"creates and returns a :ref:`coroutine <coroutine>` object."
msgstr ""
"O :ref:`async def <async def>`, em oposição a um simples ``def``, torna isto "
"uma função assíncrona (ou \"função de corrotina\"). Chamá-la cria e devolve "
"um objeto :ref:`coroutine <coroutine>`."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:102
msgid ""
"async def loudmouth_penguin(magic_number: int):\n"
"    print(\n"
"     \"I am a super special talking penguin. Far cooler than that printer. "
"\"\n"
"     f\"By the way, my lucky number is: {magic_number}.\"\n"
"    )"
msgstr ""
"async def loudmouth_penguin(magic_number: int):\n"
"    print(\n"
"     \"Sou um pinguim falador super especial. Muito mais fixe do que aquela "
"impressora. \"\n"
"     f\"Aliás, o meu número da sorte é: {magic_number}.\"\n"
"    )"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:108
msgid ""
"Calling the async function, ``loudmouth_penguin``, does not execute the "
"print statement; instead, it creates a coroutine object::"
msgstr ""
"Chamar a função assíncrona, ``loudmouth_penguin``, não executa a instrução "
"print; em vez disso, cria um objeto de corrotina::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:111
msgid ""
">>> loudmouth_penguin(magic_number=3)\n"
"<coroutine object loudmouth_penguin at 0x104ed2740>"
msgstr ""
">>> loudmouth_penguin(magic_number=3)\n"
"<objeto corrotina loudmouth_penguin em 0x104ed2740>"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:114
msgid ""
"The terms \"coroutine function\" and \"coroutine object\" are often "
"conflated as coroutine. That can be confusing! In this article, coroutine "
"specifically refers to a coroutine object, or more precisely, an instance "
"of :data:`types.CoroutineType` (native coroutine). Note that coroutines can "
"also exist as instances of :class:`collections.abc.Coroutine` -- a "
"distinction that matters for type checking."
msgstr ""
"Os termos \"função de corrotina\" e \"objeto de corrotina\" são "
"frequentemente confundidos como corrotina. Isso pode ser confuso! Neste "
"artigo, corrotina refere-se especificamente a um objeto de corrotina, ou "
"mais precisamente, a uma instância de :data:`types.CoroutineType` (corrotina "
"nativa). Note que as corrotinas também podem existir como instâncias de :"
"class:`collections.abc.Coroutine` — uma distinção que importa para a "
"verificação de tipos."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:123
msgid ""
"A coroutine represents the function's body or logic. A coroutine has to be "
"explicitly started; again, merely creating the coroutine does not start it. "
"Notably, the coroutine can be paused and resumed at various points within "
"the function's body. That pausing and resuming ability is what allows for "
"asynchronous behavior!"
msgstr ""
"Uma corrotina representa o corpo ou lógica da função. Uma corrotina tem de "
"ser iniciada explicitamente; novamente, criar simplesmente a corrotina não a "
"inicia. Notavelmente, a corrotina pode ser pausada e retomada em vários "
"pontos dentro do corpo da função. Essa capacidade de pausar e retomar é o "
"que permite o comportamento assíncrono!"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:130
msgid ""
"Coroutines and coroutine functions were built by leveraging the "
"functionality of :term:`generators <generator iterator>` and :term:"
"`generator functions <generator>`. Recall, a generator function is a "
"function that :keyword:`yield`\\s, like this one::"
msgstr ""
"As corrotinas e funções de corrotina foram construídas aproveitando a "
"funcionalidade dos :term:`geradores <generator iterator>` e das :term:"
"`funções geradoras <generator>`. Lembre-se, uma função geradora é uma função "
"que :keyword:`yield`\\s, como esta::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:136
msgid ""
"def get_random_number():\n"
"    # This would be a bad random number generator!\n"
"    print(\"Hi\")\n"
"    yield 1\n"
"    print(\"Hello\")\n"
"    yield 7\n"
"    print(\"Howdy\")\n"
"    yield 4\n"
"    ..."
msgstr ""
"def get_random_number():\n"
"    # Isto seria um mau gerador de números aleatórios!\n"
"    print(\"Olá\")\n"
"    yield 1\n"
"    print(\"Olá\")\n"
"    yield 7\n"
"    print(\"E aí\")\n"
"    yield 4\n"
"    ..."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:146
msgid ""
"Similar to a coroutine function, calling a generator function does not run "
"it. Instead, it creates a generator object::"
msgstr ""
"Semelhante a uma função de corrotina, chamar uma função geradora não a "
"executa. Em vez disso, cria um objeto gerador::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:149
msgid ""
">>> get_random_number()\n"
"<generator object get_random_number at 0x1048671c0>"
msgstr ""
">>> get_random_number()\n"
"<objeto gerador get_random_number em 0x1048671c0>"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:152
msgid ""
"You can proceed to the next ``yield`` of a generator by using the built-in "
"function :func:`next`. In other words, the generator runs, then pauses. For "
"example::"
msgstr ""
"Pode avançar para o próximo ``yield`` de um gerador usando a função "
"integrada :func:`next`. Em outras palavras, o gerador executa, depois "
"pausar. Por exemplo::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:157
msgid ""
">>> generator = get_random_number()\n"
">>> next(generator)\n"
"Hi\n"
"1\n"
">>> next(generator)\n"
"Hello\n"
"7"
msgstr ""
">>> generator = get_random_number()\n"
">>> next(generator)\n"
"Olá\n"
"1\n"
">>> next(generator)\n"
"Olá\n"
"7"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:167
msgid "Tasks"
msgstr "Tarefas"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:169
msgid ""
"Roughly speaking, :ref:`tasks <asyncio-task-obj>` are coroutines (not "
"coroutine functions) tied to an event loop. A task also maintains a list of "
"callback functions whose importance will become clear in a moment when we "
"discuss :keyword:`await`. The recommended way to create tasks is via :func:"
"`asyncio.create_task`."
msgstr ""
"Falando de forma geral, :ref:`tarefas <asyncio-task-obj>` são corrotinas "
"(não funções de corrotina) ligadas a um ciclo de eventos. Uma tarefa também "
"mantém uma lista de funções de retorno de chamada, cuja importância ficará "
"clara quando discutirmos :keyword:`await`. A forma recomendada de criar "
"tarefas é através de :func:`asyncio.create_task`."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:175
msgid ""
"Creating a task automatically schedules it for execution (by adding a "
"callback to run it in the event loop's to-do list, that is, collection of "
"jobs)."
msgstr ""
"A criação de uma tarefa agenda-a automaticamente para execução (adicionando "
"uma função de retorno de chamada para executá-la na lista de tarefas do "
"ciclo de eventos, ou seja, na coleção de tarefas)."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:178
msgid ""
":mod:`!asyncio` automatically associates tasks with the event loop for you. "
"This automatic association was purposely designed into :mod:`!asyncio` for "
"the sake of simplicity. Without it, you'd have to keep track of the event "
"loop object and pass it to any coroutine function that wants to create "
"tasks, adding redundant clutter to your code."
msgstr ""
"O :mod:`!asyncio` associa automaticamente tarefas ao ciclo de eventos por "
"si. Esta associação automática foi propositadamente concebida no :mod:`!"
"asyncio` por uma questão de simplicidade. Sem ela, teria de acompanhar o "
"objeto do ciclo de eventos e passá-lo a qualquer função de corrotina que "
"queira criar tarefas, adicionando redundância desnecessária ao seu código."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:187
msgid ""
"coroutine = loudmouth_penguin(magic_number=5)\n"
"# This creates a Task object and schedules its execution via the event "
"loop.\n"
"task = asyncio.create_task(coroutine)"
msgstr ""
"coroutine = loudmouth_penguin(magic_number=5)\n"
"# Isto cria um objeto Tarefa e agenda a sua execução através do ciclo de "
"eventos.\n"
"task = asyncio.create_task(coroutine)"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:191
msgid ""
"Earlier, we manually created the event loop and set it to run forever. In "
"practice, it's recommended to use (and common to see) :func:`asyncio.run`, "
"which takes care of managing the event loop and ensuring the provided "
"coroutine finishes before advancing. For example, many async programs follow "
"this setup::"
msgstr ""
"Anteriormente, criámos manualmente o ciclo de eventos e definimo-lo para "
"executar para sempre. Na prática, é recomendado usar (e é comum ver) :func:"
"`asyncio.run`, que cuida da gestão do ciclo de eventos e garante que a "
"corrotina fornecida termina antes de avançar. Por exemplo, muitos programas "
"assíncronos seguem esta configuração::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:197
msgid ""
"import asyncio\n"
"\n"
"async def main():\n"
"    # Perform all sorts of wacky, wild asynchronous things...\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    asyncio.run(main())\n"
"    # The program will not reach the following print statement until the\n"
"    # coroutine main() finishes.\n"
"    print(\"coroutine main() is done!\")"
msgstr ""
"import asyncio\n"
"\n"
"async def main():\n"
"    # Realizar todo o tipo de coisas assíncronas malucas e selvagens...\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    asyncio.run(main())\n"
"    # O programa não atingirá a seguinte instrução print até que a\n"
"    # corrotina main() termine.\n"
"    print(\"coroutine main() terminou!\")"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:209
msgid ""
"It's important to be aware that the task itself is not added to the event "
"loop, only a callback to the task is. This matters if the task object you "
"created is garbage collected before it's called by the event loop. For "
"example, consider this program:"
msgstr ""
"É importante estar ciente de que a tarefa em si não é adicionada ao ciclo de "
"eventos, apenas uma função de retorno de chamada para a tarefa é. Isto "
"importa se o objeto de tarefa que criou for recolhido pelo garbage collector "
"antes de ser chamado pelo ciclo de eventos. Por exemplo, considere este "
"programa:"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:215
msgid ""
"async def hello():\n"
"    print(\"hello!\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(hello())\n"
"    # Other asynchronous instructions which run for a while\n"
"    # and cede control to the event loop...\n"
"    ...\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def hello():\n"
"    print(\"olá!\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(hello())\n"
"    # Outras instruções assíncronas que executam durante algum tempo\n"
"    # e cedem controlo ao ciclo de eventos...\n"
"    ...\n"
"\n"
"asyncio.run(main())"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:229
msgid ""
"Because there's no reference to the task object created on line 5, it "
"*might* be garbage collected before the event loop invokes it. Later "
"instructions in the coroutine ``main()`` hand control back to the event loop "
"so it can invoke other jobs. When the event loop eventually tries to run the "
"task, it might fail and discover the task object does not exist! This can "
"also happen even if a coroutine keeps a reference to a task but completes "
"before that task finishes. When the coroutine exits, local variables go out "
"of scope and may be subject to garbage collection. In practice, ``asyncio`` "
"and Python's garbage collector work pretty hard to ensure this sort of thing "
"doesn't happen. But that's no reason to be reckless!"
msgstr ""
"Porque não há referência ao objeto de tarefa criado na linha 5, ele *pode* "
"ser recolhido pelo garbage collector antes de o ciclo de eventos o invocar. "
"Instruções posteriores na corrotina ``main()`` devolvem o controlo ao ciclo "
"de eventos para que possa invocar outras tarefas. Quando o ciclo de eventos "
"eventualmente tentar executar a tarefa, pode falhar e descobrir que o objeto "
"de tarefa não existe! Isto também pode acontecer mesmo que uma corrotina "
"mantenha uma referência a uma tarefa, mas termine antes que essa tarefa seja "
"concluída. Quando a corrotina sai, as variáveis locais saem do âmbito e "
"podem estar sujeitas à recolha de lixo. Na prática, ``asyncio`` e o garbage "
"collector do Python trabalham bastante para garantir que este tipo de coisa "
"não aconteça. Mas isso não é razão para ser descuidado!"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:245
msgid "await"
msgstr "aguardar"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:247
msgid ""
":keyword:`await` is a Python keyword that's commonly used in one of two "
"different ways::"
msgstr ""
":keyword:`await` é uma palavra-chave do Python que é comumente usada de duas "
"formas diferentes::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:250
msgid ""
"await task\n"
"await coroutine"
msgstr ""
"await task\n"
"await coroutine"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:253
msgid ""
"In a crucial way, the behavior of ``await`` depends on the type of object "
"being awaited."
msgstr ""
"De uma forma crucial, o comportamento de ``await`` depende do tipo de objeto "
"que está a ser aguardado."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:256
msgid ""
"Awaiting a task will cede control from the current task or coroutine to the "
"event loop. In the process of relinquishing control, a few important things "
"happen. We'll use the following code example to illustrate::"
msgstr ""
"Aguardar uma tarefa cederá o controlo da tarefa ou corrotina atual para o "
"ciclo de eventos. No processo de abdicar do controlo, algumas coisas "
"importantes acontecem. Usaremos o seguinte exemplo de código para ilustrar::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:261
msgid ""
"async def plant_a_tree():\n"
"    dig_the_hole_task = asyncio.create_task(dig_the_hole())\n"
"    await dig_the_hole_task\n"
"\n"
"    # Other instructions associated with planting a tree.\n"
"    ..."
msgstr ""
"async def plant_a_tree():\n"
"    dig_the_hole_task = asyncio.create_task(dig_the_hole())\n"
"    await dig_the_hole_task\n"
"\n"
"    # Outras instruções associadas ao plantar uma árvore.\n"
"    ..."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:268
msgid ""
"In this example, imagine the event loop has passed control to the start of "
"the coroutine ``plant_a_tree()``. As seen above, the coroutine creates a "
"task and then awaits it. The ``await dig_the_hole_task`` instruction adds a "
"callback (which will resume ``plant_a_tree()``) to the ``dig_the_hole_task`` "
"object's list of callbacks. And then, the instruction cedes control to the "
"event loop. Some time later, the event loop will pass control to "
"``dig_the_hole_task`` and the task will finish whatever it needs to do. Once "
"the task finishes, it will add its various callbacks to the event loop, in "
"this case, a call to resume ``plant_a_tree()``."
msgstr ""
"Neste exemplo, imagine que o ciclo de eventos passou o controlo para o "
"início da corrotina ``plant_a_tree()``. Como visto acima, a corrotina cria "
"uma tarefa e depois aguarda-a. A instrução ``await dig_the_hole_task`` "
"adiciona uma função de retorno de chamada (que retomará ``plant_a_tree()``) "
"à lista de funções de retorno de chamada do objeto ``dig_the_hole_task``. "
"Depois, a instrução cede o controlo ao ciclo de eventos. Algum tempo depois, "
"o ciclo de eventos passará o controlo para ``dig_the_hole_task`` e a tarefa "
"terminará o que precisa de fazer. Assim que a tarefa terminar, adicionará as "
"suas várias funções de retorno de chamada ao ciclo de eventos, neste caso, "
"uma chamada para retomar ``plant_a_tree()``."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:279
msgid ""
"Generally speaking, when the awaited task finishes (``dig_the_hole_task``), "
"the original task or coroutine (``plant_a_tree()``) is added back to the "
"event loop's to-do list to be resumed."
msgstr ""
"Falando de forma geral, quando a tarefa aguardada termina "
"(``dig_the_hole_task``), a tarefa ou corrotina original (``plant_a_tree()``) "
"é adicionada de volta à lista de tarefas do ciclo de eventos para ser "
"retomada."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:283
msgid ""
"This is a basic, yet reliable mental model. In practice, the control "
"handoffs are slightly more complex, but not by much. In part 2, we'll walk "
"through the details that make this possible."
msgstr ""
"Este é um modelo mental básico, mas confiável. Na prática, as transferências "
"de controle são um pouco mais complexas, mas não muito. Na parte 2, "
"passaremos pelos detalhes que tornam isto possível."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:287
msgid ""
"**Unlike tasks, awaiting a coroutine does not hand control back to the event "
"loop!** Wrapping a coroutine in a task first, then awaiting that would cede "
"control. The behavior of ``await coroutine`` is effectively the same as "
"invoking a regular, synchronous Python function. Consider this program::"
msgstr ""
"**Ao contrário das tarefas, aguardar uma corrotina não devolve o controlo ao "
"ciclo de eventos!** Envolver uma corrotina numa tarefa primeiro e depois "
"aguardar essa tarefa cederia o controlo. O comportamento de ``await "
"coroutine`` é efetivamente o mesmo que invocar uma função Python regular e "
"síncrona. Considere este programa::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:295
msgid ""
"import asyncio\n"
"\n"
"async def coro_a():\n"
"   print(\"I am coro_a(). Hi!\")\n"
"\n"
"async def coro_b():\n"
"   print(\"I am coro_b(). I sure hope no one hogs the event loop...\")\n"
"\n"
"async def main():\n"
"   task_b = asyncio.create_task(coro_b())\n"
"   num_repeats = 3\n"
"   for _ in range(num_repeats):\n"
"      await coro_a()\n"
"   await task_b\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def coro_a():\n"
"   print(\"Sou coro_a(). Olá!\")\n"
"\n"
"async def coro_b():\n"
"   print(\"Sou coro_b(). Espero que ninguém monopolize o ciclo de eventos..."
"\")\n"
"\n"
"async def main():\n"
"   task_b = asyncio.create_task(coro_b())\n"
"   num_repeats = 3\n"
"   for _ in range(num_repeats):\n"
"      await coro_a()\n"
"   await task_b\n"
"\n"
"asyncio.run(main())"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:312
msgid ""
"The first statement in the coroutine ``main()`` creates ``task_b`` and "
"schedules it for execution via the event loop. Then, ``coro_a()`` is "
"repeatedly awaited. Control never cedes to the event loop, which is why we "
"see the output of all three ``coro_a()`` invocations before ``coro_b()``'s "
"output:"
msgstr ""
"A primeira instrução na corrotina ``main()`` cria ``task_b`` e agenda-a para "
"execução através do ciclo de eventos. Depois, ``coro_a()`` é aguardada "
"repetidamente. O controlo nunca é cedido ao ciclo de eventos, o que explica "
"porque vemos a saída de todas as três invocações de ``coro_a()`` antes da "
"saída de ``coro_b()``:"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:318
msgid ""
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_b(). I sure hope no one hogs the event loop..."
msgstr ""
"Sou coro_a(). Olá!\n"
"Sou coro_a(). Olá!\n"
"Sou coro_a(). Olá!\n"
"Sou coro_b(). Espero que ninguém monopolize o ciclo de eventos..."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:325
msgid ""
"If we change ``await coro_a()`` to ``await asyncio.create_task(coro_a())``, "
"the behavior changes. The coroutine ``main()`` cedes control to the event "
"loop with that statement. The event loop then proceeds through its backlog "
"of work, calling ``task_b`` and then the task which wraps ``coro_a()`` "
"before resuming the coroutine ``main()``."
msgstr ""
"Se mudarmos ``await coro_a()`` para ``await asyncio.create_task(coro_a())``, "
"o comportamento muda. A corrotina ``main()`` cede o controlo ao ciclo de "
"eventos com essa instrução. O ciclo de eventos prossegue então através da "
"sua lista de tarefas pendentes, chamando ``task_b`` e depois a tarefa que "
"envolve ``coro_a()`` antes de retomar a corrotina ``main()``."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:332
msgid ""
"I am coro_b(). I sure hope no one hogs the event loop...\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!"
msgstr ""
"Sou coro_b(). Espero que ninguém monopolize o ciclo de eventos...\n"
"Sou coro_a(). Olá!\n"
"Sou coro_a(). Olá!\n"
"Sou coro_a(). Olá!"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:339
msgid ""
"This behavior of ``await coroutine`` can trip a lot of people up! That "
"example highlights how using only ``await coroutine`` could unintentionally "
"hog control from other tasks and effectively stall the event loop. :func:"
"`asyncio.run` can help you detect such occurrences via the ``debug=True`` "
"flag, which enables :ref:`debug mode <asyncio-debug-mode>`. Among other "
"things, it will log any coroutines that monopolize execution for 100ms or "
"longer."
msgstr ""
"Este comportamento de ``await coroutine`` pode confundir muitas pessoas! "
"Esse exemplo destaca como usar apenas ``await coroutine`` pode, sem "
"intenção, monopolizar o controlo de outras tarefas e efetivamente paralisar "
"o ciclo de eventos. :func:`asyncio.run` pode ajudá-lo a detetar tais "
"ocorrências através da flag ``debug=True``, que ativa o :ref:`modo de "
"depuração <asyncio-debug-mode>`. Entre outras coisas, registará quaisquer "
"corrotinas que monopolizem a execução por 100ms ou mais."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:349
msgid ""
"The design intentionally trades off some conceptual clarity around usage of "
"``await`` for improved performance. Each time a task is awaited, control "
"needs to be passed all the way up the call stack to the event loop. That "
"might sound minor, but in a large program with many ``await`` statements and "
"a deep call stack, that overhead can add up to a meaningful performance drag."
msgstr ""
"O design intencionalmente sacrifica alguma clareza conceitual em torno do "
"uso de ``await`` em troca de um melhor desempenho. Cada vez que uma tarefa é "
"aguardada, o controlo precisa de ser passado por toda a pilha de chamadas "
"até ao ciclo de eventos. Isso pode parecer menor, mas num grande programa "
"com muitas instruções ``await`` e uma pilha de chamadas profunda, essa "
"sobrecarga pode acumular-se num impacto significativo no desempenho."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:358
msgid "A conceptual overview part 2: the nuts and bolts"
msgstr "Uma visão geral conceitual, parte 2: os detalhes técnicos"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:360
msgid ""
"Part 2 goes into detail on the mechanisms :mod:`!asyncio` uses to manage "
"control flow. This is where the magic happens. You'll come away from this "
"section knowing what ``await`` does behind the scenes and how to make your "
"own asynchronous operators."
msgstr ""
"A parte 2 entra em detalhes sobre os mecanismos que o :mod:`!asyncio` usa "
"para gerir o fluxo de controlo. É aqui que a magia acontece. Sairá desta "
"secção a saber o que o ``await`` faz por trás das cenas e como criar os seus "
"próprios operadores assíncronos."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:368
msgid "The inner workings of coroutines"
msgstr "O funcionamento interno das corrotinas"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:370
msgid ":mod:`!asyncio` leverages four components to pass around control."
msgstr "O :mod:`!asyncio` utiliza quatro componentes para passar o controlo."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:372
msgid ""
":meth:`coroutine.send(arg) <generator.send>` is the method used to start or "
"resume a coroutine. If the coroutine was paused and is now being resumed, "
"the argument ``arg`` will be sent in as the return value of the ``yield`` "
"statement which originally paused it. If the coroutine is being used for the "
"first time (as opposed to being resumed), ``arg`` must be ``None``."
msgstr ""
":meth:`coroutine.send(arg) <generator.send>` é o método usado para iniciar "
"ou retomar uma corrotina. Se a corrotina estava pausada e agora está a ser "
"retomada, o argumento ``arg`` será enviado como o valor de retorno da "
"instrução ``yield`` que originalmente a pausou. Se a corrotina estiver a ser "
"usada pela primeira vez (em oposição a ser retomada), ``arg`` deve ser "
"``None``."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:380
msgid ""
"class Rock:\n"
"    def __await__(self):\n"
"        value_sent_in = yield 7\n"
"        print(f\"Rock.__await__ resuming with value: {value_sent_in}.\")\n"
"        return value_sent_in\n"
"\n"
"async def main():\n"
"    print(\"Beginning coroutine main().\")\n"
"    rock = Rock()\n"
"    print(\"Awaiting rock...\")\n"
"    value_from_rock = await rock\n"
"    print(f\"Coroutine received value: {value_from_rock} from rock.\")\n"
"    return 23\n"
"\n"
"coroutine = main()\n"
"intermediate_result = coroutine.send(None)\n"
"print(f\"Coroutine paused and returned intermediate value: "
"{intermediate_result}.\")\n"
"\n"
"print(f\"Resuming coroutine and sending in value: 42.\")\n"
"try:\n"
"    coroutine.send(42)\n"
"except StopIteration as e:\n"
"    returned_value = e.value\n"
"print(f\"Coroutine main() finished and provided value: {returned_value}.\")"
msgstr ""
"class Rock:\n"
"    def __await__(self):\n"
"        value_sent_in = yield 7\n"
"        print(f\"Rock.__await__ retomando com valor: {value_sent_in}.\")\n"
"        return value_sent_in\n"
"\n"
"async def main():\n"
"    print(\"A iniciar corrotina main().\")\n"
"    rock = Rock()\n"
"    print(\"A aguardar rock...\")\n"
"    value_from_rock = await rock\n"
"    print(f\"Corrotina recebeu valor: {value_from_rock} de rock.\")\n"
"    return 23\n"
"\n"
"coroutine = main()\n"
"intermediate_result = coroutine.send(None)\n"
"print(f\"Corrotina pausada e devolveu valor intermédio: "
"{intermediate_result}.\")\n"
"\n"
"print(f\"A retomar corrotina e a enviar valor: 42.\")\n"
"try:\n"
"    coroutine.send(42)\n"
"except StopIteration as e:\n"
"    returned_value = e.value\n"
"print(f\"Corrotina main() terminou e forneceu valor: {returned_value}.\")"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:408
msgid ""
":ref:`yield <yieldexpr>`, as usual, pauses execution and returns control to "
"the caller. In the example above, the ``yield``, on line 3, is called by "
"``... = await rock`` on line 11. More broadly speaking, ``await`` calls the :"
"meth:`~object.__await__` method of the given object. ``await`` also does one "
"more very special thing: it propagates (or \"passes along\") any ``yield``\\ "
"s it receives up the call chain. In this case, that's back to ``... = "
"coroutine.send(None)`` on line 16."
msgstr ""
":ref:`yield <yieldexpr>`, como de costume, pausar a execução e devolve o "
"controlo ao chamador. No exemplo acima, o ``yield``, na linha 3, é chamado "
"por ``... = await rock`` na linha 11. Falando de forma mais ampla, ``await`` "
"chama o método :meth:`~object.__await__` do objeto dado. ``await`` também "
"faz mais uma coisa muito especial: propaga (ou \"passa adiante\") quaisquer "
"``yield``\\s que recebe pela cadeia de chamadas. Neste caso, isso volta para "
"``... = coroutine.send(None)`` na linha 16."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:418
msgid ""
"The coroutine is resumed via the ``coroutine.send(42)`` call on line 21. The "
"coroutine picks back up from where it ``yield``\\ ed (or paused) on line 3 "
"and executes the remaining statements in its body. When a coroutine "
"finishes, it raises a :exc:`StopIteration` exception with the return value "
"attached in the :attr:`~StopIteration.value` attribute."
msgstr ""
"A corrotina é retomada através da chamada ``coroutine.send(42)`` na linha "
"21. A corrotina retoma de onde ``yield``\\ou (ou pausou) na linha 3 e "
"executa as instruções restantes no seu corpo. Quando uma corrotina termina, "
"levanta uma exceção :exc:`StopIteration` com o valor de retorno anexado no "
"atributo :attr:`~StopIteration.value`."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:424
msgid "That snippet produces this output:"
msgstr "Esse trecho produz a seguinte saída:"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:426
msgid ""
"Beginning coroutine main().\n"
"Awaiting rock...\n"
"Coroutine paused and returned intermediate value: 7.\n"
"Resuming coroutine and sending in value: 42.\n"
"Rock.__await__ resuming with value: 42.\n"
"Coroutine received value: 42 from rock.\n"
"Coroutine main() finished and provided value: 23."
msgstr ""
"A iniciar corrotina main().\n"
"A aguardar rock...\n"
"Corrotina pausada e devolveu valor intermédio: 7.\n"
"A retomar corrotina e a enviar valor: 42.\n"
"Rock.__await__ retomando com valor: 42.\n"
"Corrotina recebeu valor: 42 de rock.\n"
"Corrotina main() terminou e forneceu valor: 23."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:436
msgid ""
"It's worth pausing for a moment here and making sure you followed the "
"various ways that control flow and values were passed. A lot of important "
"ideas were covered and it's worth ensuring your understanding is firm."
msgstr ""
"Vale a pena fazer uma pausa por um momento aqui e certificar-se de que "
"seguiu as várias formas como o fluxo de controlo e os valores foram "
"passados. Muitas ideias importantes foram abordadas e vale a pena garantir "
"que a sua compreensão está firme."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:440
msgid ""
"The only way to yield (or effectively cede control) from a coroutine is to "
"``await`` an object that ``yield``\\ s in its ``__await__`` method. That "
"might sound odd to you. You might be thinking:"
msgstr ""
"A única forma de ceder (ou efetivamente passar o controlo) de uma corrotina "
"é ``await`` um objeto que ``yield``\\s no seu método ``__await__``. Isso "
"pode soar estranho para si. Pode estar a pensar:"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:444
msgid ""
"1. What about a ``yield`` directly within the coroutine function? The "
"coroutine function becomes an :ref:`async generator function <asynchronous-"
"generator-functions>`, a different beast entirely."
msgstr ""
"1. E quanto a um ``yield`` diretamente dentro da função de corrotina? A "
"função de corrotina torna-se uma :ref:`função geradora assíncrona "
"<asynchronous-generator-functions>`, uma criatura completamente diferente."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:449
msgid ""
"2. What about a :ref:`yield from <yieldexpr>` within the coroutine function "
"to a (plain) generator? That causes the error: ``SyntaxError: yield from not "
"allowed in a coroutine.`` This was intentionally designed for the sake of "
"simplicity -- mandating only one way of using coroutines. Initially "
"``yield`` was barred as well, but was re-accepted to allow for async "
"generators. Despite that, ``yield from`` and ``await`` effectively do the "
"same thing."
msgstr ""
"2. E quanto a um :ref:`yield from <yieldexpr>` dentro da função de corrotina "
"para um gerador (simples)? Isso causa o erro: ``SyntaxError: yield from not "
"allowed in a coroutine.`` Isto foi intencionalmente concebido por uma "
"questão de simplicidade — exigindo apenas uma forma de usar corrotinas. "
"Inicialmente, ``yield`` também foi proibido, mas foi reaceite para permitir "
"geradores assíncronos. Apesar disso, ``yield from`` e ``await`` fazem "
"efetivamente a mesma coisa."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:460
msgid "Futures"
msgstr "Futures"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:462
msgid ""
"A :ref:`future <asyncio-future-obj>` is an object meant to represent a "
"computation's status and result. The term is a nod to the idea of something "
"still to come or not yet happened, and the object is a way to keep an eye on "
"that something."
msgstr ""
"Um :ref:`future <asyncio-future-obj>` é um objeto destinado a representar o "
"estado e o resultado de um cálculo. O termo é uma referência à ideia de algo "
"que ainda está por vir ou que ainda não aconteceu, e o objeto é uma forma de "
"manter um olho nesse algo."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:467
msgid ""
"A future has a few important attributes. One is its state, which can be "
"either \"pending\", \"cancelled\", or \"done\". Another is its result, which "
"is set when the state transitions to done. Unlike a coroutine, a future does "
"not represent the actual computation to be done; instead, it represents the "
"status and result of that computation, kind of like a status light (red, "
"yellow, or green) or indicator."
msgstr ""
"Um future tem alguns atributos importantes. Um é o seu estado, que pode ser "
"\"pendente\", \"cancelado\" ou \"concluído\". Outro é o seu resultado, que é "
"definido quando o estado muda para concluído. Ao contrário de uma corrotina, "
"um future não representa o cálculo real a ser feito; em vez disso, "
"representa o estado e o resultado desse cálculo, como uma luz de estado "
"(vermelha, amarela ou verde) ou indicador."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:474
msgid ""
":class:`asyncio.Task` subclasses :class:`asyncio.Future` in order to gain "
"these various capabilities. The prior section said tasks store a list of "
"callbacks, which wasn't entirely accurate. It's actually the ``Future`` "
"class that implements this logic, which ``Task`` inherits."
msgstr ""
"A classe :class:`asyncio.Task` é uma subclasse de :class:`asyncio.Future` "
"para obter estas várias capacidades. A secção anterior disse que as tarefas "
"armazenam uma lista de funções de retorno de chamada, o que não era "
"totalmente preciso. Na verdade, é a classe ``Future`` que implementa esta "
"lógica, que ``Task`` herda."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:481
msgid ""
"Futures may also be used directly (not via tasks). Tasks mark themselves as "
"done when their coroutine is complete. Futures are much more versatile and "
"will be marked as done when you say so. In this way, they're the flexible "
"interface for you to make your own conditions for waiting and resuming."
msgstr ""
"Os Futures também podem ser usados diretamente (não através de tarefas). As "
"tarefas marcam-se como concluídas quando a sua corrotina está completa. Os "
"Futures são muito mais versáteis e serão marcados como concluídos quando "
"assim o determinar. Desta forma, são a interface flexível para criar as suas "
"próprias condições de espera e retomada."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:489
msgid "A homemade asyncio.sleep"
msgstr "Um asyncio.sleep caseiro"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:491
msgid ""
"We'll go through an example of how you could leverage a future to create "
"your own variant of asynchronous sleep (``async_sleep``) which mimics :func:"
"`asyncio.sleep`."
msgstr ""
"Vamos passar por um exemplo de como pode utilizar um future para criar a sua "
"própria variante de espera assíncrona (``async_sleep``) que imita :func:"
"`asyncio.sleep`."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:495
msgid ""
"This snippet registers a few tasks with the event loop and then awaits the "
"task created by ``asyncio.create_task``, which wraps the ``async_sleep(3)`` "
"coroutine. We want that task to finish only after three seconds have "
"elapsed, but without preventing other tasks from running."
msgstr ""
"Este trecho regista algumas tarefas com o ciclo de eventos e depois aguarda "
"a tarefa criada por ``asyncio.create_task``, que envolve a corrotina "
"``async_sleep(3)``. Queremos que essa tarefa termine apenas depois de terem "
"passado três segundos, mas sem impedir que outras tarefas sejam executadas."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:502
msgid ""
"async def other_work():\n"
"    print(\"I like work. Work work.\")\n"
"\n"
"async def main():\n"
"    # Add a few other tasks to the event loop, so there's something\n"
"    # to do while asynchronously sleeping.\n"
"    work_tasks = [\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work())\n"
"    ]\n"
"    print(\n"
"        \"Beginning asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    await asyncio.create_task(async_sleep(3))\n"
"    print(\n"
"        \"Done asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    # asyncio.gather effectively awaits each task in the collection.\n"
"    await asyncio.gather(*work_tasks)"
msgstr ""
"async def other_work():\n"
"    print(\"Gosto de trabalhar. Trabalhar, trabalhar.\")\n"
"\n"
"async def main():\n"
"    # Adicionar algumas tarefas ao ciclo de eventos, para que haja algo\n"
"    # para fazer enquanto dorme assincronamente.\n"
"    work_tasks = [\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work())\n"
"    ]\n"
"    print(\n"
"        \"A iniciar a espera assíncrona à hora: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    await asyncio.create_task(async_sleep(3))\n"
"    print(\n"
"        \"Terminou a espera assíncrona à hora: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    # asyncio.gather aguarda efetivamente cada tarefa na coleção.\n"
"    await asyncio.gather(*work_tasks)"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:526
msgid ""
"Below, we use a future to enable custom control over when that task will be "
"marked as done. If :meth:`future.set_result() <asyncio.Future.set_result>` "
"(the method responsible for marking that future as done) is never called, "
"then this task will never finish. We've also enlisted the help of another "
"task, which we'll see in a moment, that will monitor how much time has "
"elapsed and, accordingly, call ``future.set_result()``."
msgstr ""
"Em baixo, usamos um future para permitir controlo personalizado sobre quando "
"essa tarefa será marcada como concluída. Se :meth:`future.set_result() "
"<asyncio.Future.set_result>` (o método responsável por marcar esse future "
"como concluído) nunca for chamado, então esta tarefa nunca terminará. Também "
"recrutámos a ajuda de outra tarefa, que veremos em breve, que monitorizará "
"quanto tempo passou e, de acordo, chamará ``future.set_result()``."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:537
msgid ""
"async def async_sleep(seconds: float):\n"
"    future = asyncio.Future()\n"
"    time_to_wake = time.time() + seconds\n"
"    # Add the watcher-task to the event loop.\n"
"    watcher_task = asyncio.create_task(_sleep_watcher(future, "
"time_to_wake))\n"
"    # Block until the future is marked as done.\n"
"    await future"
msgstr ""
"async def async_sleep(seconds: float):\n"
"    future = asyncio.Future()\n"
"    time_to_wake = time.time() + seconds\n"
"    # Adicionar a tarefa de observação ao ciclo de eventos.\n"
"    watcher_task = asyncio.create_task(_sleep_watcher(future, "
"time_to_wake))\n"
"    # Bloquear até que o future seja marcado como concluído.\n"
"    await future"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:545
msgid ""
"Below, we use a rather bare ``YieldToEventLoop()`` object to ``yield`` from "
"its ``__await__`` method, ceding control to the event loop. This is "
"effectively the same as calling ``asyncio.sleep(0)``, but this approach "
"offers more clarity, not to mention it's somewhat cheating to use ``asyncio."
"sleep`` when showcasing how to implement it!"
msgstr ""
"Em baixo, usamos um objeto ``YieldToEventLoop()`` bastante simples para "
"``yield`` do seu método ``__await__``, cedendo controlo ao ciclo de eventos. "
"Isto é efetivamente o mesmo que chamar ``asyncio.sleep(0)``, mas esta "
"abordagem oferece mais clareza, para não mencionar que é um pouco trapaça "
"usar ``asyncio.sleep`` ao mostrar como implementá-lo!"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:551
msgid ""
"As usual, the event loop cycles through its tasks, giving them control and "
"receiving control back when they pause or finish. The ``watcher_task``, "
"which runs the coroutine ``_sleep_watcher(...)``, will be invoked once per "
"full cycle of the event loop. On each resumption, it'll check the time and "
"if not enough has elapsed, then it'll pause once again and hand control back "
"to the event loop. Once enough time has elapsed, ``_sleep_watcher(...)`` "
"marks the future as done and completes by exiting its infinite ``while`` "
"loop. Given this helper task is only invoked once per cycle of the event "
"loop, you'd be correct to note that this asynchronous sleep will sleep *at "
"least* three seconds, rather than exactly three seconds. Note this is also "
"true of ``asyncio.sleep``."
msgstr ""
"Como de costume, o ciclo de eventos percorre as suas tarefas, dando-lhes "
"controlo e recebendo controlo de volta quando pausam ou terminam. A "
"``watcher_task``, que executa a corrotina ``_sleep_watcher(...)``, será "
"invocada uma vez por cada ciclo completo do ciclo de eventos. Em cada "
"retomada, verificará a hora e, se não tiver passado tempo suficiente, "
"pausará novamente e devolverá o controlo ao ciclo de eventos. Assim que "
"tiver passado tempo suficiente, ``_sleep_watcher(...)`` marca o future como "
"concluído e termina saindo do seu ciclo ``while`` infinito. Dado que esta "
"tarefa auxiliar é invocada apenas uma vez por ciclo do ciclo de eventos, "
"estaria correto em notar que esta espera assíncrona dormirá *pelo menos* "
"três segundos, em vez de exatamente três segundos. Note que isto também é "
"verdade para ``asyncio.sleep``."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:567
msgid ""
"class YieldToEventLoop:\n"
"    def __await__(self):\n"
"        yield\n"
"\n"
"async def _sleep_watcher(future, time_to_wake):\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            # This marks the future as done.\n"
"            future.set_result(None)\n"
"            break\n"
"        else:\n"
"            await YieldToEventLoop()"
msgstr ""
"class YieldToEventLoop:\n"
"    def __await__(self):\n"
"        yield\n"
"\n"
"async def _sleep_watcher(future, time_to_wake):\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            # Isto marca o future como concluído.\n"
"            future.set_result(None)\n"
"            break\n"
"        else:\n"
"            await YieldToEventLoop()"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:580
msgid "Here is the full program's output:"
msgstr "Aqui está a saída completa do programa:"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:582
msgid ""
"$ python custom-async-sleep.py\n"
"Beginning asynchronous sleep at time: 14:52:22.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"Done asynchronous sleep at time: 14:52:25."
msgstr ""
"$ python custom-async-sleep.py\n"
"A iniciar a espera assíncrona à hora: 14:52:22.\n"
"Gosto de trabalhar. Trabalhar, trabalhar.\n"
"Gosto de trabalhar. Trabalhar, trabalhar.\n"
"Gosto de trabalhar. Trabalhar, trabalhar.\n"
"Terminou a espera assíncrona à hora: 14:52:25."

#: ../../howto/a-conceptual-overview-of-asyncio.rst:591
msgid ""
"You might feel this implementation of asynchronous sleep was unnecessarily "
"convoluted. And, well, it was. The example was meant to showcase the "
"versatility of futures with a simple example that could be mimicked for more "
"complex needs. For reference, you could implement it without futures, like "
"so::"
msgstr ""
"Pode achar que esta implementação de espera assíncrona foi "
"desnecessariamente complicada. E, bem, foi. O exemplo foi concebido para "
"mostrar a versatilidade dos futures com um exemplo simples que poderia ser "
"imitado para necessidades mais complexas. Para referência, poderia "
"implementá-lo sem futures, assim::"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:598
msgid ""
"async def simpler_async_sleep(seconds):\n"
"    time_to_wake = time.time() + seconds\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            return\n"
"        else:\n"
"            await YieldToEventLoop()"
msgstr ""
"async def simpler_async_sleep(seconds):\n"
"    time_to_wake = time.time() + seconds\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            return\n"
"        else:\n"
"            await YieldToEventLoop()"

#: ../../howto/a-conceptual-overview-of-asyncio.rst:606
msgid ""
"But that's all for now. Hopefully you're ready to more confidently dive into "
"some async programming or check out advanced topics in the :mod:`rest of the "
"documentation <asyncio>`."
msgstr ""
"Mas por agora é tudo. Esperamos que esteja pronto para mergulhar com mais "
"confiança na programação assíncrona ou explorar tópicos avançados no :mod:"
"`resto da documentação <asyncio>`."
