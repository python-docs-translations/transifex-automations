# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Andr√© Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-27 15:43+0000\n"
"PO-Revision-Date: 2025-07-18 19:57+0000\n"
"Last-Translator: Andr√© Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "Guia Unicode"

#: ../../howto/unicode.rst:0
msgid "Release"
msgstr "Vers√£o"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"Este guia discute o suporte do Python para a especifica√ß√£o Unicode para "
"representar dados textuais e explica v√°rios problemas que as pessoas "
"encontram comumente ao trabalhar com Unicode."

#: ../../howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "Introdu√ß√£o ao Unicode"

#: ../../howto/unicode.rst:18
msgid "Definitions"
msgstr "Defini√ß√µes"

#: ../../howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"Os programas atuais precisam ser capazes de lidar com uma ampla variedade de "
"caracteres. As aplica√ß√µes s√£o frequentemente internacionalizadas para exibir "
"mensagens e sa√≠da numa variedade de idiomas selecion√°veis pelo utilizador; o "
"mesmo programa pode precisar de exibir uma mensagem de erro em ingl√™s, "
"franc√™s, japon√™s, hebraico ou russo. O conte√∫do da web pode ser escrito em "
"qualquer um destes idiomas e tamb√©m pode incluir uma variedade de s√≠mbolos "
"emoji. O tipo de string do Python usa o padr√£o Unicode para representar "
"caracteres, o que permite que os programas Python trabalhem com todos estes "
"diferentes caracteres poss√≠veis."

#: ../../howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) √© uma especifica√ß√£o que visa listar todos "
"os caracteres usados pelas l√≠nguas humanas e dar a cada car√°cter o seu "
"pr√≥prio c√≥digo √∫nico. As especifica√ß√µes Unicode s√£o continuamente revistas e "
"atualizadas para adicionar novas l√≠nguas e s√≠mbolos."

#: ../../howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are '√à' and '√ç'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", '‚Ö†', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"Um **car√°cter** √© o menor componente poss√≠vel de um texto. 'A', 'B', 'C', "
"etc., s√£o todos caracteres diferentes. Tamb√©m o s√£o '√à' e '√ç'. Os caracteres "
"variam dependendo da l√≠ngua ou contexto de que se est√° a falar. Por exemplo, "
"existe um car√°cter para \"Algarismo Romano Um\", '‚Ö†', que √© separado da "
"letra mai√∫scula 'I'. Normalmente parecer√£o iguais, mas s√£o dois caracteres "
"diferentes que t√™m significados diferentes."

#: ../../howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"O padr√£o Unicode descreve como os caracteres s√£o representados por **pontos "
"de c√≥digo**. Um valor de ponto de c√≥digo √© um inteiro no intervalo de 0 a "
"0x10FFFF (cerca de 1,1 milh√£o de valores, o `n√∫mero real atribu√≠do <https://"
"www.unicode.org/versions/latest/#Summary>`_ √© menor do que isso). Na norma e "
"neste documento, um ponto de c√≥digo √© escrito usando a nota√ß√£o ``U+265E`` "
"para significar o car√°cter com o valor ``0x265e`` (9.822 em decimal)."

#: ../../howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr ""
"O padr√£o Unicode cont√©m muitas tabelas que listam caracteres e os seus "
"pontos de c√≥digo correspondentes:"

#: ../../howto/unicode.rst:53
msgid ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    '‚Öß'; ROMAN NUMERAL EIGHT\n"
"2168    '‚Ö®'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    '‚ôû'; BLACK CHESS KNIGHT\n"
"265F    '‚ôü'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'üòÄ'; GRINNING FACE\n"
"1F609   'üòâ'; WINKING FACE\n"
"..."
msgstr ""
"0061    'a'; LETRA MIN√öSCULA LATINA A\n"
"0062    'b'; LETRA MIN√öSCULA LATINA B\n"
"0063    'c'; LETRA MIN√öSCULA LATINA C\n"
"...\n"
"007B    '{'; CHAVETA ESQUERDA\n"
"...\n"
"2167    '‚Öß'; ALGARISMO ROMANO OITO\n"
"2168    '‚Ö®'; ALGARISMO ROMANO NOVE\n"
"...\n"
"265E    '‚ôû'; CAVALO DE XADREZ PRETO\n"
"265F    '‚ôü'; PE√ÉO DE XADREZ PRETO\n"
"...\n"
"1F600   'üòÄ'; ROSTO SORRIDENTE\n"
"1F609   'üòâ'; ROSTO PISCANDO O OLHO\n"
"..."

#: ../../howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '‚ôû'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"Estritamente, estas defini√ß√µes implicam que √© sem sentido dizer 'este √© o "
"car√°cter ``U+265E``'. ``U+265E`` √© um ponto de c√≥digo, que representa algum "
"car√°cter espec√≠fico; neste caso, representa o car√°cter 'CAVALO DE XADREZ "
"PRETO', '‚ôû'. Em contextos informais, esta distin√ß√£o entre pontos de c√≥digo e "
"caracteres √© por vezes esquecida."

#: ../../howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Um car√°cter √© representado num ecr√£ ou em papel por um conjunto de elementos "
"gr√°ficos chamado **glifo**. O glifo para um A mai√∫sculo, por exemplo, s√£o "
"dois tra√ßos diagonais e um tra√ßo horizontal, embora os detalhes exatos "
"dependam da fonte utilizada. A maioria do c√≥digo Python n√£o precisa de se "
"preocupar com glifos; descobrir o glifo correto a exibir √© geralmente "
"trabalho de um kit de ferramentas de interface gr√°fica ou de um renderizador "
"de fontes de um terminal."

#: ../../howto/unicode.rst:87
msgid "Encodings"
msgstr "Codifica√ß√µes"

#: ../../howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"Para resumir a sec√ß√£o anterior: uma string Unicode √© uma sequ√™ncia de pontos "
"de c√≥digo, que s√£o n√∫meros de 0 a ``0x10FFFF`` (1.114.111 em decimal). Esta "
"sequ√™ncia de pontos de c√≥digo precisa de ser representada na mem√≥ria como um "
"conjunto de **unidades de c√≥digo**, e as **unidades de c√≥digo** s√£o ent√£o "
"mapeadas para bytes de 8 bits. As regras para traduzir uma string Unicode "
"numa sequ√™ncia de bytes s√£o chamadas de **codifica√ß√£o de caracteres**, ou "
"simplesmente **codifica√ß√£o**."

#: ../../howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"A primeira codifica√ß√£o que pode pensar √© usar inteiros de 32 bits como "
"unidade de c√≥digo e depois usar a representa√ß√£o da CPU de inteiros de 32 "
"bits. Nesta representa√ß√£o, a string \"Python\" pode parecer assim:"

#: ../../howto/unicode.rst:101
msgid ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
msgstr ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"

#: ../../howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr ""
"Esta representa√ß√£o √© simples, mas o seu uso apresenta v√°rios problemas."

#: ../../howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr ""
"N√£o √© port√°til; diferentes processadores ordenam os bytes de forma diferente."

#: ../../howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"√â muito desperdi√ßador de espa√ßo. Na maioria dos textos, a maioria dos pontos "
"de c√≥digo s√£o menores que 127, ou menores que 255, ent√£o muito espa√ßo √© "
"ocupado por bytes ``0x00``. A string acima ocupa 24 bytes em compara√ß√£o com "
"os 6 bytes necess√°rios para uma representa√ß√£o ASCII. O aumento do uso de RAM "
"n√£o importa muito (os computadores de secret√°ria t√™m gigabytes de RAM, e as "
"strings geralmente n√£o s√£o t√£o grandes), mas expandir o uso de espa√ßo em "
"disco e largura de banda de rede por um fator de 4 √© inaceit√°vel."

#: ../../howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"N√£o √© compat√≠vel com fun√ß√µes C existentes como ``strlen()``, ent√£o uma nova "
"fam√≠lia de fun√ß√µes de strings largas teria de ser usada."

#: ../../howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""
"Portanto, esta codifica√ß√£o n√£o √© muito usada, e as pessoas escolhem, em vez "
"disso, outras codifica√ß√µes que s√£o mais eficientes e convenientes, como "
"UTF-8."

#: ../../howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 √© uma das codifica√ß√µes mais comumente usadas, e o Python "
"frequentemente usa-a por predefini√ß√£o. UTF significa \"Unicode "
"Transformation Format\", e o '8' significa que valores de 8 bits s√£o usados "
"na codifica√ß√£o. (Tamb√©m existem codifica√ß√µes UTF-16 e UTF-32, mas s√£o menos "
"frequentemente usadas do que UTF-8.) UTF-8 usa as seguintes regras:"

#: ../../howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr ""
"Se o ponto de c√≥digo for < 128, √© representado pelo valor de byte "
"correspondente."

#: ../../howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"Se o ponto de c√≥digo for >= 128, √© convertido numa sequ√™ncia de dois, tr√™s "
"ou quatro bytes, onde cada byte da sequ√™ncia est√° entre 128 e 255."

#: ../../howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 tem v√°rias propriedades convenientes:"

#: ../../howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "Pode lidar com qualquer ponto de c√≥digo Unicode."

#: ../../howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"Uma string Unicode √© convertida numa sequ√™ncia de bytes que cont√©m bytes "
"zero incorporados apenas onde representam o car√°cter nulo (U+0000). Isto "
"significa que strings UTF-8 podem ser processadas por fun√ß√µes C como "
"``strcpy()`` e enviadas atrav√©s de protocolos que n√£o podem lidar com bytes "
"zero para qualquer coisa al√©m de marcadores de fim de string."

#: ../../howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "Uma string de texto ASCII tamb√©m √© um texto UTF-8 v√°lido."

#: ../../howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 √© bastante compacto; a maioria dos caracteres comumente usados pode "
"ser representada com um ou dois bytes."

#: ../../howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"Se os bytes forem corrompidos ou perdidos, √© poss√≠vel determinar o in√≠cio do "
"pr√≥ximo ponto de c√≥digo codificado em UTF-8 e ressincronizar. Tamb√©m √© "
"improv√°vel que dados aleat√≥rios de 8 bits pare√ßam UTF-8 v√°lido."

#: ../../howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 √© uma codifica√ß√£o orientada a bytes. A codifica√ß√£o especifica que cada "
"car√°cter √© representado por uma sequ√™ncia espec√≠fica de um ou mais bytes. "
"Isto evita problemas de ordena√ß√£o de bytes que podem ocorrer com "
"codifica√ß√µes orientadas a inteiros e palavras, como UTF-16 e UTF-32, onde a "
"sequ√™ncia de bytes varia dependendo do hardware no qual a string foi "
"codificada."

#: ../../howto/unicode.rst:158 ../../howto/unicode.rst:514
#: ../../howto/unicode.rst:735
msgid "References"
msgstr "Refer√™ncias"

#: ../../howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"O `site do Unicode Consortium <https://www.unicode.org>`_ tem tabelas de "
"caracteres, um gloss√°rio e vers√µes PDF da especifica√ß√£o Unicode. Esteja "
"preparado para alguma leitura dif√≠cil. Uma `cronologia <https://www.unicode."
"org/history/>`_ da origem e desenvolvimento do Unicode tamb√©m est√° "
"dispon√≠vel no site."

#: ../../howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"No canal Computerphile do YouTube, Tom Scott discute brevemente a `hist√≥ria "
"do Unicode e UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9 "
"minutos e 36 segundos)."

#: ../../howto/unicode.rst:169
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"Para ajudar a entender o padr√£o, Jukka Korpela escreveu um `guia "
"introdut√≥rio <https://jkorpela.fi/unicode/guide.html>`_ para ler as tabelas "
"de caracteres Unicode."

#: ../../howto/unicode.rst:173
msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"Outro `bom artigo introdut√≥rio <https://www.joelonsoftware.com/2003/10/08/"
"the-absolute-minimum-every-software-developer-absolutely-positively-must-"
"know-about-unicode-and-character-sets-no-excuses/>`_ foi escrito por Joel "
"Spolsky. Se esta introdu√ß√£o n√£o deixou as coisas claras para si, deve tentar "
"ler este artigo alternativo antes de continuar."

#: ../../howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"As entradas da Wikipedia s√£o frequentemente √∫teis; veja as entradas para "
"\"`codifica√ß√£o de caracteres <https://en.wikipedia.org/wiki/"
"Character_encoding>`_\" e `UTF-8 <https://en.wikipedia.org/wiki/UTF-8>`_, "
"por exemplo."

#: ../../howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "Suporte Unicode do Python"

#: ../../howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"Agora que aprendeu os rudimentos do Unicode, podemos ver as funcionalidades "
"Unicode do Python."

#: ../../howto/unicode.rst:190
msgid "The String Type"
msgstr "O Tipo String"

#: ../../howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Desde o Python 3.0, o tipo :class:`str` da linguagem cont√©m caracteres "
"Unicode, o que significa que qualquer string criada usando ``\"unicode rocks!"
"\"``, ``'unicode rocks!'``, ou a sintaxe de string tripla √© armazenada como "
"Unicode."

#: ../../howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"A codifica√ß√£o predefinida para o c√≥digo-fonte Python √© UTF-8, por isso pode "
"simplesmente incluir um car√°cter Unicode num literal de string:"

#: ../../howto/unicode.rst:199
msgid ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouv√©\")"
msgstr ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # Mensagem de erro 'Ficheiro n√£o encontrado'.\n"
"    print(\"Ficheiro n√£o encontrado\")"

#: ../../howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr ""
"Nota lateral: O Python 3 tamb√©m suporta o uso de caracteres Unicode em "
"identificadores:"

#: ../../howto/unicode.rst:208
msgid ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"
msgstr ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"

#: ../../howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"Se n√£o conseguir inserir um car√°cter espec√≠fico no seu editor ou quiser "
"manter o c√≥digo-fonte apenas em ASCII por alguma raz√£o, tamb√©m pode usar "
"sequ√™ncias de escape em literais de string. (Dependendo do seu sistema, pode "
"ver o glifo real de delta mai√∫sculo em vez de uma escape \\u):"

#: ../../howto/unicode.rst:217
msgid ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"
msgstr ""
">>> \"\\N{LETRA GREGGA DELTA MAI√öSCULA}\"  # Usando o nome do car√°cter\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Usando um valor hexadecimal de 16 "
"bits\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Usando um valor hexadecimal de 32 "
"bits\n"
"'\\u0394'"

#: ../../howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"Al√©m disso, pode criar uma string usando o m√©todo :func:`~bytes.decode` de :"
"class:`bytes`. Este m√©todo aceita um argumento *encoding*, como ``UTF-8``, e "
"opcionalmente um argumento *errors*."

#: ../../howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"O argumento *errors* especifica a resposta quando a string de entrada n√£o "
"pode ser convertida de acordo com as regras da codifica√ß√£o. Os valores "
"legais para este argumento s√£o ``'strict'`` (lan√ßa uma exce√ß√£o :exc:"
"`UnicodeDecodeError`), ``'replace'`` (usa ``U+FFFD``, ``REPLACEMENT "
"CHARACTER``), ``'ignore'`` (simplesmente omite o caractere do resultado "
"Unicode), ou ``'backslashreplace'`` (insere uma sequ√™ncia de escape "
"``\\xNN``). Os seguintes exemplos mostram as diferen√ßas:"

#: ../../howto/unicode.rst:236
msgid ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"
msgstr ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: a codifica√ß√£o 'utf-8' n√£o pode descodificar o byte 0x80 "
"na posi√ß√£o 0:\n"
"  byte inicial inv√°lido\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"

#: ../../howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"As codifica√ß√µes s√£o especificadas como strings contendo o nome da "
"codifica√ß√£o. O Python vem com cerca de 100 codifica√ß√µes diferentes; veja a "
"Refer√™ncia da Biblioteca Python em :ref:`standard-encodings` para uma lista. "
"Algumas codifica√ß√µes t√™m v√°rios nomes; por exemplo, ``'latin-1'``, "
"``'iso_8859_1'`` e ``'8859`` s√£o todos sin√≥nimos para a mesma codifica√ß√£o."

#: ../../howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"Strings Unicode de um car√°cter tamb√©m podem ser criadas com a fun√ß√£o "
"integrada :func:`chr`, que aceita inteiros e retorna uma string Unicode de "
"comprimento 1 que cont√©m o ponto de c√≥digo correspondente. A opera√ß√£o "
"inversa √© a fun√ß√£o integrada :func:`ord`, que aceita uma string Unicode de "
"um car√°cter e retorna o valor do ponto de c√≥digo:"

#: ../../howto/unicode.rst:260
msgid ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"
msgstr ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"

#: ../../howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "Converter para Bytes"

#: ../../howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"O m√©todo oposto de :meth:`bytes.decode` √© :meth:`str.encode`, que retorna "
"uma representa√ß√£o :class:`bytes` da string Unicode, codificada na "
"*codifica√ß√£o* solicitada."

#: ../../howto/unicode.rst:272
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"O par√¢metro *errors* √© o mesmo que o par√¢metro do m√©todo :meth:`~bytes."
"decode`, mas suporta alguns manipuladores adicionais. Al√©m de ``'strict'``, "
"``'ignore'`` e ``'replace'`` (que neste caso insere um ponto de interroga√ß√£o "
"em vez do caractere n√£o codific√°vel), tamb√©m existe ``'xmlcharrefreplace'`` "
"(insere uma refer√™ncia de caractere XML), ``backslashreplace`` (insere uma "
"sequ√™ncia de escape ``\\uNNNN``) e ``namereplace`` (insere uma sequ√™ncia de "
"escape ``\\N{...}``)."

#: ../../howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "O exemplo seguinte mostra os diferentes resultados:"

#: ../../howto/unicode.rst:282
msgid ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"
msgstr ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: a codifica√ß√£o 'ascii' n√£o pode codificar o car√°cter "
"'\\ua000' na\n"
"  posi√ß√£o 0: ordinal fora do intervalo (128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{S√çLABA YI IT}abcd\\\\u07b4'"

#: ../../howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"As rotinas de baixo n√≠vel para registar e aceder √†s codifica√ß√µes dispon√≠veis "
"encontram-se no m√≥dulo :mod:`codecs`. A implementa√ß√£o de novas codifica√ß√µes "
"tamb√©m requer a compreens√£o do m√≥dulo :mod:`codecs`. No entanto, as fun√ß√µes "
"de codifica√ß√£o e descodifica√ß√£o retornadas por este m√≥dulo s√£o geralmente de "
"n√≠vel mais baixo do que √© confort√°vel, e a escrita de novas codifica√ß√µes √© "
"uma tarefa especializada, por isso o m√≥dulo n√£o ser√° abordado neste guia."

#: ../../howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "Literais Unicode no C√≥digo-Fonte Python"

#: ../../howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"No c√≥digo-fonte Python, pontos de c√≥digo Unicode espec√≠ficos podem ser "
"escritos usando a sequ√™ncia de escape ``\\u``, que √© seguida por quatro "
"d√≠gitos hexadecimais que indicam o ponto de c√≥digo. A sequ√™ncia de escape "
"``\\U`` √© semelhante, mas espera oito d√≠gitos hexadecimais, n√£o quatro:"

#: ../../howto/unicode.rst:317
msgid ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"
msgstr ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ escape hexadecimal de dois d√≠gitos\n"
"... #         ^^^^^^ escape Unicode de quatro d√≠gitos\n"
"... #                     ^^^^^^^^^^ escape Unicode de oito d√≠gitos\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"

#: ../../howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"Usar sequ√™ncias de escape para pontos de c√≥digo maiores que 127 √© aceit√°vel "
"em pequenas doses, mas torna-se um inc√≥modo se estiver a usar muitos "
"caracteres acentuados, como num programa com mensagens em franc√™s ou outra "
"l√≠ngua que use acentos. Tamb√©m pode montar strings usando a fun√ß√£o "
"integrada :func:`chr`, mas isso √© ainda mais tedioso."

#: ../../howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"Idealmente, gostaria de poder escrever literais na codifica√ß√£o natural da "
"sua l√≠ngua. Poderia ent√£o editar o c√≥digo-fonte Python com o seu editor "
"favorito, que exibiria os caracteres acentuados naturalmente, e ter os "
"caracteres corretos usados em tempo de execu√ß√£o."

#: ../../howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"O Python suporta a escrita de c√≥digo-fonte em UTF-8 por predefini√ß√£o, mas "
"pode usar quase qualquer codifica√ß√£o se declarar a codifica√ß√£o que est√° a "
"ser usada. Isto √© feito incluindo um coment√°rio especial como a primeira ou "
"segunda linha do ficheiro de origem:"

#: ../../howto/unicode.rst:339
msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"
msgstr ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"

#: ../../howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"A sintaxe √© inspirada na nota√ß√£o do Emacs para especificar vari√°veis locais "
"a um ficheiro. O Emacs suporta muitas vari√°veis diferentes, mas o Python s√≥ "
"suporta 'coding'. Os s√≠mbolos ``-*-`` indicam ao Emacs que o coment√°rio √© "
"especial; n√£o t√™m significado para o Python, mas s√£o uma conven√ß√£o. O Python "
"procura por ``coding: name`` ou ``coding=name`` no coment√°rio."

#: ../../howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"Se n√£o incluir tal coment√°rio, a codifica√ß√£o predefinida usada ser√° UTF-8, "
"como j√° mencionado. Veja tamb√©m :pep:`263` para mais informa√ß√µes."

#: ../../howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "Propriedades Unicode"

#: ../../howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"A especifica√ß√£o Unicode inclui uma base de dados de informa√ß√µes sobre pontos "
"de c√≥digo. Para cada ponto de c√≥digo definido, as informa√ß√µes incluem o nome "
"do car√°cter, a sua categoria, o valor num√©rico, se aplic√°vel (para "
"caracteres que representam conceitos num√©ricos como algarismos romanos, "
"fra√ß√µes como um-ter√ßo e quatro-quintos, etc.). Tamb√©m existem propriedades "
"relacionadas √† exibi√ß√£o, como a forma de usar o ponto de c√≥digo em texto "
"bidirecional."

#: ../../howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"O programa seguinte exibe algumas informa√ß√µes sobre v√°rios caracteres e "
"imprime o valor num√©rico de um car√°cter espec√≠fico:"

#: ../../howto/unicode.rst:369
msgid ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"
msgstr ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Obter valor num√©rico do segundo car√°cter\n"
"print(unicodedata.numeric(u[1]))"

#: ../../howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "Quando executado, isto imprime:"

#: ../../howto/unicode.rst:382
msgid ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"
msgstr ""
"0 00e9 Ll LETRA MIN√öSCULA LATINA E COM ACENTO AGUDO\n"
"1 0bf2 No ALGARISMO T√ÇMIL MIL\n"
"2 0f84 Mn MARCA TIBETANA HALANTA\n"
"3 1770 Lo LETRA TAGBANWA SA\n"
"4 33af So QUADRADO RAD SOBRE S QUADRADO\n"
"1000.0"

#: ../../howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"Os c√≥digos de categoria s√£o abreviaturas que descrevem a natureza do "
"car√°cter. Estes s√£o agrupados em categorias como \"Letra\", \"N√∫mero\", "
"\"Pontua√ß√£o\" ou \"S√≠mbolo\", que por sua vez s√£o divididos em "
"subcategorias. Para tomar os c√≥digos da sa√≠da acima, ``'Ll'`` significa "
"'Letra, min√∫scula', ``'No'`` significa \"N√∫mero, outro\", ``'Mn'`` √© "
"\"Marca, n√£o espa√ßada\", e ``'So'`` √© \"S√≠mbolo, outro\". Veja a `se√ß√£o "
"Valores de Categoria Geral da documenta√ß√£o da Base de Dados de Caracteres "
"Unicode <https://www.unicode.org/reports/tr44/#General_Category_Values>`_ "
"para uma lista de c√≥digos de categoria."

#: ../../howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "Comparar Strings"

#: ../../howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like '√™' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Unicode adiciona alguma complica√ß√£o √† compara√ß√£o de strings, porque o mesmo "
"conjunto de caracteres pode ser representado por diferentes sequ√™ncias de "
"pontos de c√≥digo. Por exemplo, uma letra como '√™' pode ser representada como "
"um √∫nico ponto de c√≥digo U+00EA, ou como U+0065 U+0302, que √© o ponto de "
"c√≥digo para 'e' seguido de um ponto de c√≥digo para 'ACENTO CIRCUNFLEXO DE "
"COMBINA√á√ÉO'. Estes produzir√£o a mesma sa√≠da quando impressos, mas um √© uma "
"string de comprimento 1 e o outro √© de comprimento 2."

#: ../../howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter '√ü' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"Uma ferramenta para compara√ß√£o sem distin√ß√£o de mai√∫sculas e min√∫sculas √© o "
"m√©todo de string :meth:`~str.casefold`, que converte uma string para uma "
"forma sem distin√ß√£o de mai√∫sculas e min√∫sculas seguindo um algoritmo "
"descrito pelo Padr√£o Unicode. Este algoritmo tem um tratamento especial para "
"caracteres como a letra alem√£ '√ü' (ponto de c√≥digo U+00DF), que se torna o "
"par de letras min√∫sculas 'ss'."

#: ../../howto/unicode.rst:421
msgid ""
">>> street = 'G√ºrzenichstra√üe'\n"
">>> street.casefold()\n"
"'g√ºrzenichstrasse'"
msgstr ""
">>> rua = 'G√ºrzenichstra√üe'\n"
">>> rua.casefold()\n"
"'g√ºrzenichstrasse'"

#: ../../howto/unicode.rst:425
msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`~unicodedata.normalize` can be used to perform string "
"comparisons that won't falsely report inequality if two strings use "
"combining characters differently:"
msgstr ""
"Uma segunda ferramenta √© a fun√ß√£o :func:`~unicodedata.normalize` do m√≥dulo :"
"mod:`unicodedata`, que converte strings para uma de v√°rias formas normais, "
"onde letras seguidas de um car√°cter de combina√ß√£o s√£o substitu√≠das por "
"caracteres √∫nicos. :func:`~unicodedata.normalize` pode ser usada para "
"realizar compara√ß√µes de strings que n√£o reportar√£o falsamente desigualdade "
"se duas strings usarem caracteres de combina√ß√£o de forma diferente:"

#: ../../howto/unicode.rst:434
msgid ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"
msgstr ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LETRA MIN√öSCULA LATINA E}\\N{ACENTO CIRCUNFLEXO DE "
"COMBINA√á√ÉO}'\n"
"print('comprimento da primeira string=', len(single_char))\n"
"print('comprimento da segunda string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"

#: ../../howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "Quando executado, isto produz:"

#: ../../howto/unicode.rst:450
msgid ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"
msgstr ""
"$ python compare-strs.py\n"
"comprimento da primeira string= 1\n"
"comprimento da segunda string= 2\n"
"True"

#: ../../howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
"O primeiro argumento para a fun√ß√£o :func:`~unicodedata.normalize` √© uma "
"string que indica a forma de normaliza√ß√£o desejada, que pode ser uma de "
"'NFC', 'NFKC', 'NFD' e 'NFKD'."

#: ../../howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr ""
"O Padr√£o Unicode tamb√©m especifica como fazer compara√ß√µes sem distin√ß√£o de "
"mai√∫sculas e min√∫sculas:"

#: ../../howto/unicode.rst:463
msgid ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"
msgstr ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Exemplo de uso\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LETRA MAI√öSCULA LATINA E}\\N{ACENTO CIRCUNFLEXO DE "
"COMBINA√á√ÉO}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"

#: ../../howto/unicode.rst:477
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"Isto imprimir√° ``True``. (Por que :func:`!NFD` √© invocado duas vezes? Porque "
"existem alguns caracteres que fazem com que :meth:`~str.casefold` retorne "
"uma string n√£o normalizada, ent√£o o resultado precisa de ser normalizado "
"novamente. Veja a sec√ß√£o 3.13 do Padr√£o Unicode para uma discuss√£o e um "
"exemplo.)"

#: ../../howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "Express√µes Regulares Unicode"

#: ../../howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"As express√µes regulares suportadas pelo m√≥dulo :mod:`re` podem ser "
"fornecidas como bytes ou strings. Algumas das sequ√™ncias de caracteres "
"especiais, como ``\\d`` e ``\\w``, t√™m significados diferentes dependendo se "
"o padr√£o √© fornecido como bytes ou uma string. Por exemplo, ``\\d`` "
"corresponder√° aos caracteres ``[0-9]`` em bytes, mas em strings "
"corresponder√° a qualquer car√°cter que esteja na categoria ``'Nd'``."

#: ../../howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"A string neste exemplo tem o n√∫mero 57 escrito em algarismos tailandeses e "
"√°rabes:"

#: ../../howto/unicode.rst:496
msgid ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"
msgstr ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 sabores\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"

#: ../../howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"Quando executado, ``\\d+`` corresponder√° aos algarismos tailandeses e "
"imprimir√°-os. Se fornecer a flag :const:`re.ASCII` para :func:`~re.compile`, "
"``\\d+`` corresponder√° √† substring \"57\"."

#: ../../howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Da mesma forma, ``\\w`` corresponde a uma grande variedade de caracteres "
"Unicode, mas apenas ``[a-zA-Z0-9_]`` em bytes ou se :const:`re.ASCII` for "
"fornecido, e ``\\s`` corresponder√° a caracteres de espa√ßo em branco Unicode "
"ou ``[ \\t\\n\\r\\f\\v]``."

#: ../../howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr ""
"Algumas boas discuss√µes alternativas sobre o suporte Unicode do Python s√£o:"

#: ../../howto/unicode.rst:520
msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`Processamento de Ficheiros de Texto em Python 3 <https://python-notes."
"curiousefficiency.org/en/latest/python3/text_file_processing.html>`_, por "
"Nick Coghlan."

#: ../../howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Unicode Pragm√°tico <https://nedbatchelder.com/text/unipain.html>`_, uma "
"apresenta√ß√£o da PyCon 2012 por Ned Batchelder."

#: ../../howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"O tipo :class:`str` √© descrito na refer√™ncia da biblioteca Python em :ref:"
"`textseq`."

#: ../../howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr "A documenta√ß√£o para o m√≥dulo :mod:`unicodedata`."

#: ../../howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr "A documenta√ß√£o para o m√≥dulo :mod:`codecs`."

#: ../../howto/unicode.rst:530
msgid ""
"Marc-Andr√© Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-Andr√© Lemburg deu `uma apresenta√ß√£o intitulada \"Python e "
"Unicode\" (diapositivos PDF) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ na EuroPython 2002. Os diapositivos s√£o uma excelente "
"vis√£o geral do design das funcionalidades Unicode do Python 2 (onde o tipo "
"de string Unicode √© chamado ``unicode`` e os literais come√ßam com ``u``)."

#: ../../howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "Ler e Escrever Dados Unicode"

#: ../../howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"Depois de ter escrito algum c√≥digo que trabalha com dados Unicode, o pr√≥ximo "
"problema √© a entrada/sa√≠da. Como obter strings Unicode no seu programa e "
"como converter Unicode numa forma adequada para armazenamento ou transmiss√£o?"

#: ../../howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"√â poss√≠vel que n√£o precise de fazer nada dependendo das suas fontes de "
"entrada e destinos de sa√≠da; deve verificar se as bibliotecas usadas na sua "
"aplica√ß√£o suportam Unicode nativamente. Os analisadores XML frequentemente "
"retornam dados Unicode, por exemplo. Muitas bases de dados relacionais "
"tamb√©m suportam colunas com valores Unicode e podem retornar valores Unicode "
"a partir de uma consulta SQL."

#: ../../howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Os dados Unicode s√£o geralmente convertidos para uma codifica√ß√£o espec√≠fica "
"antes de serem escritos em disco ou enviados atrav√©s de um socket. √â "
"poss√≠vel fazer todo o trabalho manualmente: abrir um ficheiro, ler um objeto "
"bytes de 8 bits dele e converter os bytes com ``bytes.decode(encoding)``. No "
"entanto, a abordagem manual n√£o √© recomendada."

#: ../../howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"Um problema √© a natureza multi-byte das codifica√ß√µes; um car√°cter Unicode "
"pode ser representado por v√°rios bytes. Se quiser ler o ficheiro em blocos "
"de tamanho arbitr√°rio (digamos, 1024 ou 4096 bytes), precisa de escrever "
"c√≥digo de tratamento de erros para capturar o caso em que apenas parte dos "
"bytes que codificam um √∫nico car√°cter Unicode s√£o lidos no final de um "
"bloco. Uma solu√ß√£o seria ler o ficheiro inteiro para a mem√≥ria e depois "
"realizar a descodifica√ß√£o, mas isso impede-o de trabalhar com ficheiros "
"extremamente grandes; se precisar de ler um ficheiro de 2 GiB, precisa de 2 "
"GiB de RAM. (Na verdade, mais, j√° que pelo menos por um momento precisaria "
"de ter tanto a string codificada como a sua vers√£o Unicode na mem√≥ria.)"

#: ../../howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"A solu√ß√£o seria usar a interface de descodifica√ß√£o de baixo n√≠vel para "
"capturar o caso de sequ√™ncias de codifica√ß√£o parciais. O trabalho de "
"implementar isto j√° foi feito por si: a fun√ß√£o integrada :func:`open` pode "
"retornar um objeto semelhante a um ficheiro que assume que o conte√∫do do "
"ficheiro est√° numa codifica√ß√£o especificada e aceita par√¢metros Unicode para "
"m√©todos como :meth:`~io.TextIOBase.read` e :meth:`~io.TextIOBase.write`. "
"Isto funciona atrav√©s dos par√¢metros *encoding* e *errors* de :func:`open`, "
"que s√£o interpretados da mesma forma que em :meth:`str.encode` e :meth:"
"`bytes.decode`."

#: ../../howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "Ler Unicode de um ficheiro √©, portanto, simples:"

#: ../../howto/unicode.rst:576
msgid ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"
msgstr ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"

#: ../../howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"Tamb√©m √© poss√≠vel abrir ficheiros em modo de atualiza√ß√£o, permitindo leitura "
"e escrita:"

#: ../../howto/unicode.rst:583
msgid ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"
msgstr ""
"with open('teste', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"

#: ../../howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"O car√°cter Unicode ``U+FEFF`` √© usado como uma marca de ordem de bytes (BOM) "
"e √© frequentemente escrito como o primeiro car√°cter de um ficheiro para "
"ajudar na dete√ß√£o autom√°tica da ordem de bytes do ficheiro. Algumas "
"codifica√ß√µes, como UTF-16, esperam que uma BOM esteja presente no in√≠cio de "
"um ficheiro; quando tal codifica√ß√£o √© usada, a BOM ser√° automaticamente "
"escrita como o primeiro car√°cter e ser√° silenciosamente ignorada quando o "
"ficheiro for lido. Existem variantes destas codifica√ß√µes, como 'utf-16-le' e "
"'utf-16-be' para codifica√ß√µes little-endian e big-endian, que especificam "
"uma ordem de bytes particular e n√£o ignoram a BOM."

#: ../../howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"Em algumas √°reas, tamb√©m √© conven√ß√£o usar uma \"BOM\" no in√≠cio de ficheiros "
"codificados em UTF-8; o nome √© enganador, j√° que UTF-8 n√£o depende da ordem "
"dos bytes. A marca simplesmente anuncia que o ficheiro est√° codificado em "
"UTF-8. Para ler tais ficheiros, use a codifica√ß√£o 'utf-8-sig' para ignorar "
"automaticamente a marca, se presente."

#: ../../howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "Nomes de ficheiros Unicode"

#: ../../howto/unicode.rst:606
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"A maioria dos sistemas operativos em uso comum hoje suporta nomes de "
"ficheiros que cont√™m caracteres Unicode arbitr√°rios. Normalmente, isto √© "
"implementado convertendo a string Unicode numa codifica√ß√£o que varia "
"dependendo do sistema. Hoje, o Python est√° a convergir para o uso de UTF-8: "
"o Python no MacOS tem usado UTF-8 em v√°rias vers√µes, e o Python 3.6 mudou "
"para usar UTF-8 no Windows tamb√©m. Em sistemas Unix, s√≥ haver√° uma :term:"
"`codifica√ß√£o de sistema de ficheiros <codifica√ß√£o de sistema de ficheiros e "
"manipulador de erros>`. se definir as vari√°veis de ambiente ``LANG`` ou "
"``LC_CTYPE``; se n√£o o fizer, a codifica√ß√£o predefinida √© novamente UTF-8."

#: ../../howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"A fun√ß√£o :func:`sys.getfilesystemencoding` retorna a codifica√ß√£o a usar no "
"seu sistema atual, caso queira fazer a codifica√ß√£o manualmente, mas n√£o h√° "
"muita raz√£o para se incomodar. Ao abrir um ficheiro para leitura ou escrita, "
"pode geralmente fornecer a string Unicode como o nome do ficheiro, e ela "
"ser√° automaticamente convertida para a codifica√ß√£o correta para si:"

#: ../../howto/unicode.rst:622
msgid ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"
msgstr ""
"nome_ficheiro = 'nome_ficheiro\\u4500abc'\n"
"with open(nome_ficheiro, 'w') as f:\n"
"    f.write('blah\\n')"

#: ../../howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"Fun√ß√µes no m√≥dulo :mod:`os`, como :func:`os.stat`, tamb√©m aceitar√£o nomes de "
"ficheiros Unicode."

#: ../../howto/unicode.rst:629
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
"A fun√ß√£o :func:`os.listdir` retorna nomes de ficheiros, o que levanta uma "
"quest√£o: deve retornar a vers√£o Unicode dos nomes de ficheiros ou deve "
"retornar bytes contendo as vers√µes codificadas? :func:`os.listdir` pode "
"fazer ambas, dependendo se forneceu o caminho do diret√≥rio como bytes ou uma "
"string Unicode. Se passar uma string Unicode como caminho, os nomes de "
"ficheiros ser√£o descodificados usando a codifica√ß√£o do sistema de ficheiros "
"e uma lista de strings Unicode ser√° retornada, enquanto passar um caminho em "
"bytes retornar√° os nomes de ficheiros como bytes. Por exemplo, assumindo que "
"a :term:`codifica√ß√£o do sistema de ficheiros <codifica√ß√£o do sistema de "
"ficheiros e manipulador de erros>` predefinida √© UTF-8, executar o seguinte "
"programa:"

#: ../../howto/unicode.rst:639
msgid ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"
msgstr ""
"fn = 'nome_ficheiro\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"

#: ../../howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "produzir√° a seguinte sa√≠da:"

#: ../../howto/unicode.rst:649
msgid ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"
msgstr ""
"$ python listdir-test.py\n"
"[b'nome_ficheiro\\xe4\\x94\\x80abc', ...]\n"
"['nome_ficheiro\\u4500abc', ...]"

#: ../../howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"A primeira lista cont√©m nomes de ficheiros codificados em UTF-8, e a segunda "
"lista cont√©m as vers√µes Unicode."

#: ../../howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"Note que na maioria das ocasi√µes, pode simplesmente continuar a usar Unicode "
"com estas APIs. As APIs de bytes s√≥ devem ser usadas em sistemas onde podem "
"estar presentes nomes de ficheiros n√£o descodific√°veis; isso √© praticamente "
"apenas sistemas Unix agora."

#: ../../howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Dicas para Escrever Programas Conscientes de Unicode"

#: ../../howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"Esta sec√ß√£o fornece algumas sugest√µes sobre como escrever software que lida "
"com Unicode."

#: ../../howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "A dica mais importante √©:"

#: ../../howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"O software deve trabalhar apenas com strings Unicode internamente, "
"descodificando os dados de entrada o mais cedo poss√≠vel e codificando a "
"sa√≠da apenas no final."

#: ../../howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"Se tentar escrever fun√ß√µes de processamento que aceitem tanto strings "
"Unicode como bytes, encontrar√° o seu programa vulner√°vel a bugs sempre que "
"combinar os dois tipos diferentes de strings. N√£o h√° codifica√ß√£o ou "
"descodifica√ß√£o autom√°tica: se fizer, por exemplo, ``str + bytes``, ser√° "
"levantada uma exce√ß√£o :exc:`TypeError`."

#: ../../howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"Ao usar dados provenientes de um navegador web ou outra fonte n√£o confi√°vel, "
"uma t√©cnica comum √© verificar caracteres ilegais numa string antes de usar a "
"string numa linha de comando gerada ou armazen√°-la numa base de dados. Se "
"estiver a fazer isto, tenha cuidado para verificar a string descodificada, "
"n√£o os dados de bytes codificados; algumas codifica√ß√µes podem ter "
"propriedades interessantes, como n√£o serem bijetivas ou n√£o serem totalmente "
"compat√≠veis com ASCII. Isto √© especialmente verdadeiro se os dados de "
"entrada tamb√©m especificarem a codifica√ß√£o, j√° que o atacante pode ent√£o "
"escolher uma forma inteligente de esconder texto malicioso no fluxo de bytes "
"codificado."

#: ../../howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "Converter Entre Codifica√ß√µes de Ficheiros"

#: ../../howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"A classe :class:`~codecs.StreamRecoder` pode converter transparente entre "
"codifica√ß√µes, tomando um fluxo que retorna dados na codifica√ß√£o #1 e "
"comportando-se como um fluxo que retorna dados na codifica√ß√£o #2."

#: ../../howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"Por exemplo, se tiver um ficheiro de entrada *f* que est√° em Latin-1, pode "
"envolv√™-lo com um :class:`~codecs.StreamRecoder` para retornar bytes "
"codificados em UTF-8:"

#: ../../howto/unicode.rst:701
msgid ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"
msgstr ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/descodificador: usado por read() para codificar os seus resultados "
"e\n"
"    # por write() para descodificar a sua entrada.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # leitor/escritor: usado para ler e escrever no fluxo.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"

#: ../../howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "Ficheiros com Codifica√ß√£o Desconhecida"

#: ../../howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"O que pode fazer se precisar de fazer uma altera√ß√£o a um ficheiro, mas n√£o "
"sabe a codifica√ß√£o do ficheiro? Se souber que a codifica√ß√£o √© compat√≠vel com "
"ASCII e s√≥ quiser examinar ou modificar as partes ASCII, pode abrir o "
"ficheiro com o manipulador de erros ``surrogateescape``:"

#: ../../howto/unicode.rst:718
msgid ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"
msgstr ""
"with open(nome_ficheiro, 'r', encoding=\"ascii\", "
"errors=\"surrogateescape\") as f:\n"
"    dados = f.read()\n"
"\n"
"# fazer altera√ß√µes √† string 'dados'\n"
"\n"
"with open(nome_ficheiro + '.novo', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(dados)"

#: ../../howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"O manipulador de erros ``surrogateescape`` descodificar√° quaisquer bytes n√£o-"
"ASCII como pontos de c√≥digo numa gama especial que vai de U+DC80 a U+DCFF. "
"Estes pontos de c√≥digo ser√£o ent√£o convertidos de volta nos mesmos bytes "
"quando o manipulador de erros ``surrogateescape`` for usado para codificar "
"os dados e escrev√™-los de volta."

#: ../../howto/unicode.rst:737
msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"Uma sec√ß√£o de `Dominar a Entrada/Sa√≠da em Python 3 <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, uma palestra da PyCon 2010 "
"por David Beazley, discute o processamento de texto e o manuseamento de "
"dados bin√°rios."

#: ../../howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-Andr√© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"Os `diapositivos PDF da apresenta√ß√£o de Marc-Andr√© Lemburg \"Escrever "
"Aplica√ß√µes Conscientes de Unicode em Python\" <https://downloads.egenix.com/"
"python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf>`_ "
"discutem quest√µes de codifica√ß√µes de caracteres, bem como como "
"internacionalizar e localizar uma aplica√ß√£o. Estes diapositivos cobrem "
"apenas o Python 2.x."

#: ../../howto/unicode.rst:747
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`O N√∫cleo do Unicode em Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ √© uma palestra da PyCon 2013 por Benjamin Peterson que "
"discute a representa√ß√£o interna do Unicode no Python 3.3."

#: ../../howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "Agradecimentos"

#: ../../howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"O rascunho inicial deste documento foi escrito por Andrew Kuchling. Desde "
"ent√£o, foi ainda mais revisto por Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling e Ezio Melotti."

#: ../../howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: √âric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von L√∂wis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"Agradecimentos √†s seguintes pessoas que notaram erros ou ofereceram "
"sugest√µes sobre este artigo: √âric Araujo, Nicholas Bastin, Nick Coghlan, "
"Marius Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von "
"L√∂wis, Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham "
"Wideman."
