# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-27 14:59+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "Livro de Receitas de Registo"

#: ../../howto/logging-cookbook.rst:0
msgid "Author"
msgstr "Autor"

#: ../../howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../../howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past. For links to tutorial and reference information, "
"please see :ref:`cookbook-ref-links`."
msgstr ""
"Esta página contém várias receitas relacionadas com registo, que se "
"revelaram úteis no passado. Para ligações a informações de tutorial e "
"referência, consulte :ref:`cookbook-ref-links`."

#: ../../howto/logging-cookbook.rst:16
msgid "Using logging in multiple modules"
msgstr "Utilizar registo em vários módulos"

#: ../../howto/logging-cookbook.rst:18
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module and "
"create (but not configure) a child logger in a separate module, and all "
"logger calls to the child will pass up to the parent.  Here is a main "
"module::"
msgstr ""
"Várias chamadas a ``logging.getLogger('someLogger')`` devolvem uma "
"referência para o mesmo objeto registador. Isto é verdade não só dentro do "
"mesmo módulo, mas também entre módulos, desde que esteja no mesmo processo "
"do interpretador Python. É verdade para referências ao mesmo objeto; além "
"disso, o código da aplicação pode definir e configurar um registador pai num "
"módulo e criar (mas não configurar) um registador filho num módulo separado, "
"e todas as chamadas ao registador filho passarão para o pai. Aqui está um "
"módulo principal::"

#: ../../howto/logging-cookbook.rst:26
msgid ""
"import logging\n"
"import auxiliary_module\n"
"\n"
"# create logger with 'spam_application'\n"
"logger = logging.getLogger('spam_application')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"fh.setFormatter(formatter)\n"
"ch.setFormatter(formatter)\n"
"# add the handlers to the logger\n"
"logger.addHandler(fh)\n"
"logger.addHandler(ch)\n"
"\n"
"logger.info('creating an instance of auxiliary_module.Auxiliary')\n"
"a = auxiliary_module.Auxiliary()\n"
"logger.info('created an instance of auxiliary_module.Auxiliary')\n"
"logger.info('calling auxiliary_module.Auxiliary.do_something')\n"
"a.do_something()\n"
"logger.info('finished auxiliary_module.Auxiliary.do_something')\n"
"logger.info('calling auxiliary_module.some_function()')\n"
"auxiliary_module.some_function()\n"
"logger.info('done with auxiliary_module.some_function()')"
msgstr ""
"import logging\n"
"import modulo_auxiliar\n"
"\n"
"# criar registador com 'spam_application'\n"
"logger = logging.getLogger('spam_application')\n"
"logger.setLevel(logging.DEBUG)\n"
"# criar manipulador de ficheiro que regista até mensagens de depuração\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# criar manipulador de consola com um nível de registo mais alto\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# criar formatador e adicioná-lo aos manipuladores\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"fh.setFormatter(formatter)\n"
"ch.setFormatter(formatter)\n"
"# adicionar os manipuladores ao registador\n"
"logger.addHandler(fh)\n"
"logger.addHandler(ch)\n"
"\n"
"logger.info('a criar uma instância de modulo_auxiliar.Auxiliar')\n"
"a = modulo_auxiliar.Auxiliar()\n"
"logger.info('criada uma instância de modulo_auxiliar.Auxiliar')\n"
"logger.info('a chamar modulo_auxiliar.Auxiliar.fazer_algo')\n"
"a.fazer_algo()\n"
"logger.info('terminado modulo_auxiliar.Auxiliar.fazer_algo')\n"
"logger.info('a chamar modulo_auxiliar.alguma_funcao()')\n"
"modulo_auxiliar.alguma_funcao()\n"
"logger.info('terminado modulo_auxiliar.alguma_funcao()')"

#: ../../howto/logging-cookbook.rst:56
msgid "Here is the auxiliary module::"
msgstr "Aqui está o módulo auxiliar::"

#: ../../howto/logging-cookbook.rst:58
msgid ""
"import logging\n"
"\n"
"# create logger\n"
"module_logger = logging.getLogger('spam_application.auxiliary')\n"
"\n"
"class Auxiliary:\n"
"    def __init__(self):\n"
"        self.logger = logging.getLogger('spam_application.auxiliary."
"Auxiliary')\n"
"        self.logger.info('creating an instance of Auxiliary')\n"
"\n"
"    def do_something(self):\n"
"        self.logger.info('doing something')\n"
"        a = 1 + 1\n"
"        self.logger.info('done doing something')\n"
"\n"
"def some_function():\n"
"    module_logger.info('received a call to \"some_function\"')"
msgstr ""
"import logging\n"
"\n"
"# criar registador\n"
"module_logger = logging.getLogger('spam_application.auxiliar')\n"
"\n"
"class Auxiliar:\n"
"    def __init__(self):\n"
"        self.logger = logging.getLogger('spam_application.auxiliar."
"Auxiliar')\n"
"        self.logger.info('a criar uma instância de Auxiliar')\n"
"\n"
"    def fazer_algo(self):\n"
"        self.logger.info('a fazer algo')\n"
"        a = 1 + 1\n"
"        self.logger.info('terminado de fazer algo')\n"
"\n"
"def alguma_funcao():\n"
"    module_logger.info('recebida uma chamada para \"alguma_funcao\"')"

#: ../../howto/logging-cookbook.rst:76
msgid "The output looks like this:"
msgstr "A saída parece-se com isto:"

#: ../../howto/logging-cookbook.rst:78
msgid ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   creating an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   creating an instance of Auxiliary\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   created an instance of auxiliary_module.Auxiliary\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   calling auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   doing something\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliary.Auxiliary - INFO -\n"
"   done doing something\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   finished auxiliary_module.Auxiliary.do_something\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   calling auxiliary_module.some_function()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliary - INFO -\n"
"   received a call to 'some_function'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   done with auxiliary_module.some_function()"
msgstr ""
"2005-03-23 23:47:11,663 - spam_application - INFO -\n"
"   a criar uma instância de modulo_auxiliar.Auxiliar\n"
"2005-03-23 23:47:11,665 - spam_application.auxiliar.Auxiliar - INFO -\n"
"   a criar uma instância de Auxiliar\n"
"2005-03-23 23:47:11,665 - spam_application - INFO -\n"
"   criada uma instância de modulo_auxiliar.Auxiliar\n"
"2005-03-23 23:47:11,668 - spam_application - INFO -\n"
"   a chamar modulo_auxiliar.Auxiliar.fazer_algo\n"
"2005-03-23 23:47:11,668 - spam_application.auxiliar.Auxiliar - INFO -\n"
"   a fazer algo\n"
"2005-03-23 23:47:11,669 - spam_application.auxiliar.Auxiliar - INFO -\n"
"   terminado de fazer algo\n"
"2005-03-23 23:47:11,670 - spam_application - INFO -\n"
"   terminado modulo_auxiliar.Auxiliar.fazer_algo\n"
"2005-03-23 23:47:11,671 - spam_application - INFO -\n"
"   a chamar modulo_auxiliar.alguma_funcao()\n"
"2005-03-23 23:47:11,672 - spam_application.auxiliar - INFO -\n"
"   recebida uma chamada para 'alguma_funcao'\n"
"2005-03-23 23:47:11,673 - spam_application - INFO -\n"
"   terminado modulo_auxiliar.alguma_funcao()"

#: ../../howto/logging-cookbook.rst:102
msgid "Logging from multiple threads"
msgstr "Registo a partir de múltiplas threads"

#: ../../howto/logging-cookbook.rst:104
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"O registo a partir de múltiplas threads não requer nenhum esforço especial. "
"O seguinte exemplo mostra o registo a partir da thread principal (inicial) e "
"de outra thread::"

#: ../../howto/logging-cookbook.rst:107
msgid ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def worker(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Hi from myfunc')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d "
"%(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=worker, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Hello from main')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"import threading\n"
"import time\n"
"\n"
"def trabalhador(arg):\n"
"    while not arg['stop']:\n"
"        logging.debug('Olá da minha função')\n"
"        time.sleep(0.5)\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(relativeCreated)6d "
"%(threadName)s %(message)s')\n"
"    info = {'stop': False}\n"
"    thread = threading.Thread(target=trabalhador, args=(info,))\n"
"    thread.start()\n"
"    while True:\n"
"        try:\n"
"            logging.debug('Olá da principal')\n"
"            time.sleep(0.75)\n"
"        except KeyboardInterrupt:\n"
"            info['stop'] = True\n"
"            break\n"
"    thread.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:133
msgid "When run, the script should print something like the following:"
msgstr "Quando executado, o script deve imprimir algo como o seguinte:"

#: ../../howto/logging-cookbook.rst:135
msgid ""
"   0 Thread-1 Hi from myfunc\n"
"   3 MainThread Hello from main\n"
" 505 Thread-1 Hi from myfunc\n"
" 755 MainThread Hello from main\n"
"1007 Thread-1 Hi from myfunc\n"
"1507 MainThread Hello from main\n"
"1508 Thread-1 Hi from myfunc\n"
"2010 Thread-1 Hi from myfunc\n"
"2258 MainThread Hello from main\n"
"2512 Thread-1 Hi from myfunc\n"
"3009 MainThread Hello from main\n"
"3013 Thread-1 Hi from myfunc\n"
"3515 Thread-1 Hi from myfunc\n"
"3761 MainThread Hello from main\n"
"4017 Thread-1 Hi from myfunc\n"
"4513 MainThread Hello from main\n"
"4518 Thread-1 Hi from myfunc"
msgstr ""
"   0 Thread-1 Olá da minha função\n"
"   3 MainThread Olá da principal\n"
" 505 Thread-1 Olá da minha função\n"
" 755 MainThread Olá da principal\n"
"1007 Thread-1 Olá da minha função\n"
"1507 MainThread Olá da principal\n"
"1508 Thread-1 Olá da minha função\n"
"2010 Thread-1 Olá da minha função\n"
"2258 MainThread Olá da principal\n"
"2512 Thread-1 Olá da minha função\n"
"3009 MainThread Olá da principal\n"
"3013 Thread-1 Olá da minha função\n"
"3515 Thread-1 Olá da minha função\n"
"3761 MainThread Olá da principal\n"
"4017 Thread-1 Olá da minha função\n"
"4513 MainThread Olá da principal\n"
"4518 Thread-1 Olá da minha função"

#: ../../howto/logging-cookbook.rst:155
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr ""
"Isto mostra a saída de registo intercalada como se poderia esperar. Esta "
"abordagem funciona para mais threads do que as mostradas aqui, claro."

#: ../../howto/logging-cookbook.rst:159
msgid "Multiple handlers and formatters"
msgstr "Vários manipuladores e formatadores"

#: ../../howto/logging-cookbook.rst:161
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has "
"no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers.  "
"The logging calls in the application code will remain unchanged.  Here is a "
"slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"Os registadores são objetos Python simples. O método :meth:`~Logger."
"addHandler` não tem quota mínima ou máxima para o número de manipuladores "
"que pode adicionar. Às vezes, será benéfico para uma aplicação registar "
"todas as mensagens de todas as severidades num ficheiro de texto enquanto "
"regista simultaneamente erros ou acima para a consola. Para configurar isto, "
"basta configurar os manipuladores apropriados. As chamadas de registo no "
"código da aplicação permanecerão inalteradas. Aqui está uma ligeira "
"modificação ao exemplo de configuração simples baseado em módulo anterior::"

#: ../../howto/logging-cookbook.rst:169
msgid ""
"import logging\n"
"\n"
"logger = logging.getLogger('simple_example')\n"
"logger.setLevel(logging.DEBUG)\n"
"# create file handler which logs even debug messages\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# create console handler with a higher log level\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# create formatter and add it to the handlers\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"ch.setFormatter(formatter)\n"
"fh.setFormatter(formatter)\n"
"# add the handlers to logger\n"
"logger.addHandler(ch)\n"
"logger.addHandler(fh)\n"
"\n"
"# 'application' code\n"
"logger.debug('debug message')\n"
"logger.info('info message')\n"
"logger.warning('warn message')\n"
"logger.error('error message')\n"
"logger.critical('critical message')"
msgstr ""
"import logging\n"
"\n"
"logger = logging.getLogger('exemplo_simples')\n"
"logger.setLevel(logging.DEBUG)\n"
"# criar manipulador de ficheiro que regista até mensagens de depuração\n"
"fh = logging.FileHandler('spam.log')\n"
"fh.setLevel(logging.DEBUG)\n"
"# criar manipulador de consola com um nível de registo mais alto\n"
"ch = logging.StreamHandler()\n"
"ch.setLevel(logging.ERROR)\n"
"# criar formatador e adicioná-lo aos manipuladores\n"
"formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - "
"%(message)s')\n"
"ch.setFormatter(formatter)\n"
"fh.setFormatter(formatter)\n"
"# adicionar os manipuladores ao registador\n"
"logger.addHandler(ch)\n"
"logger.addHandler(fh)\n"
"\n"
"# código da 'aplicação'\n"
"logger.debug('mensagem de depuração')\n"
"logger.info('mensagem de informação')\n"
"logger.warning('mensagem de aviso')\n"
"logger.error('mensagem de erro')\n"
"logger.critical('mensagem crítica')"

#: ../../howto/logging-cookbook.rst:194
msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr ""
"Note que o código da 'aplicação' não se preocupa com vários manipuladores. "
"Tudo o que mudou foi a adição e configuração de um novo manipulador chamado "
"*fh*."

#: ../../howto/logging-cookbook.rst:197
msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs "
"to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"A capacidade de criar novos manipuladores com filtros de severidade mais "
"alta ou mais baixa pode ser muito útil ao escrever e testar uma aplicação. "
"Em vez de usar muitas instruções ``print`` para depuração, use ``logger."
"debug``: Ao contrário das instruções print, que terá de apagar ou comentar "
"mais tarde, as instruções logger.debug podem permanecer intactas no código-"
"fonte e permanecer dormentes até precisar delas novamente. Nesse momento, a "
"única mudança necessária é modificar o nível de severidade do registador e/"
"ou manipulador para depuração."

#: ../../howto/logging-cookbook.rst:208
msgid "Logging to multiple destinations"
msgstr "Registo em vários destinos"

#: ../../howto/logging-cookbook.rst:210
msgid ""
"Let's say you want to log to console and file with different message formats "
"and in differing circumstances. Say you want to log messages with levels of "
"DEBUG and higher to file, and those messages at level INFO and higher to the "
"console. Let's also assume that the file should contain timestamps, but the "
"console messages should not. Here's how you can achieve this::"
msgstr ""
"Suponha que quer registar na consola e num ficheiro com formatos de mensagem "
"diferentes e em circunstâncias diferentes. Digamos que quer registar "
"mensagens com níveis de DEBUG e superiores num ficheiro, e essas mensagens "
"com nível INFO e superiores na consola. Vamos também assumir que o ficheiro "
"deve conter carimbos de data/hora, mas as mensagens da consola não devem "
"conter. Aqui está como pode conseguir isto::"

#: ../../howto/logging-cookbook.rst:216
msgid ""
"import logging\n"
"\n"
"# set up logging to file - see previous section for more details\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    format='%(asctime)s %(name)-12s %(levelname)-8s "
"%(message)s',\n"
"                    datefmt='%m-%d %H:%M',\n"
"                    filename='/tmp/myapp.log',\n"
"                    filemode='w')\n"
"# define a Handler which writes INFO messages or higher to the sys.stderr\n"
"console = logging.StreamHandler()\n"
"console.setLevel(logging.INFO)\n"
"# set a format which is simpler for console use\n"
"formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n"
"# tell the handler to use this format\n"
"console.setFormatter(formatter)\n"
"# add the handler to the root logger\n"
"logging.getLogger('').addHandler(console)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the "
"root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""
"import logging\n"
"\n"
"# configurar registo para ficheiro - veja a secção anterior para mais "
"detalhes\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    format='%(asctime)s %(name)-12s %(levelname)-8s "
"%(message)s',\n"
"                    datefmt='%m-%d %H:%M',\n"
"                    filename='/tmp/myapp.log',\n"
"                    filemode='w')\n"
"# definir um manipulador que escreve mensagens INFO ou superiores para sys."
"stderr\n"
"console = logging.StreamHandler()\n"
"console.setLevel(logging.INFO)\n"
"# definir um formato que é mais simples para uso na consola\n"
"formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')\n"
"# dizer ao manipulador para usar este formato\n"
"console.setFormatter(formatter)\n"
"# adicionar o manipulador ao registador raiz\n"
"logging.getLogger('').addHandler(console)\n"
"\n"
"# Agora, podemos registar no registador raiz, ou em qualquer outro "
"registador. Primeiro o raiz...\n"
"logging.info('Os gralhas adoram o meu grande esfinge de quartzo.')\n"
"\n"
"# Agora, definir alguns outros registadores que podem representar áreas na "
"sua\n"
"# aplicação:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Ventos rápidos sopram, irritando o Jim tolo.')\n"
"logger1.info('Quão rapidamente zebras saltitantes tolas irritam.')\n"
"logger2.warning('Prisão da raposa astuta que roubou o pagamento do pato.')\n"
"logger2.error('Os cinco mágicos boxeadores saltam rapidamente.')"

#: ../../howto/logging-cookbook.rst:248
msgid "When you run this, on the console you will see"
msgstr "Quando executar isto, na consola verá"

#: ../../howto/logging-cookbook.rst:250
msgid ""
"root        : INFO     Jackdaws love my big sphinx of quartz.\n"
"myapp.area1 : INFO     How quickly daft jumping zebras vex.\n"
"myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"myapp.area2 : ERROR    The five boxing wizards jump quickly."
msgstr ""
"root        : INFO     Os gralhas adoram o meu grande esfinge de quartzo.\n"
"myapp.area1 : INFO     Quão rapidamente zebras saltitantes tolas irritam.\n"
"myapp.area2 : AVISO    Prisão da raposa astuta que roubou o pagamento do "
"pato.\n"
"myapp.area2 : ERRO     Os cinco mágicos boxeadores saltam rapidamente."

#: ../../howto/logging-cookbook.rst:257
msgid "and in the file you will see something like"
msgstr "e no ficheiro verá algo como"

#: ../../howto/logging-cookbook.rst:259
msgid ""
"10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.\n"
"10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.\n"
"10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from "
"quack.\n"
"10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly."
msgstr ""
"10-22 22:19 root         INFO     Os gralhas adoram o meu grande esfinge de "
"quartzo.\n"
"10-22 22:19 myapp.area1  DEBUG    Ventos rápidos sopram, irritando o Jim "
"tolo.\n"
"10-22 22:19 myapp.area1  INFO     Quão rapidamente zebras saltitantes tolas "
"irritam.\n"
"10-22 22:19 myapp.area2  AVISO    Prisão da raposa astuta que roubou o "
"pagamento do pato.\n"
"10-22 22:19 myapp.area2  ERRO     Os cinco mágicos boxeadores saltam "
"rapidamente."

#: ../../howto/logging-cookbook.rst:267
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr ""
"Como pode ver, a mensagem DEBUG só aparece no ficheiro. As outras mensagens "
"são enviadas para ambos os destinos."

#: ../../howto/logging-cookbook.rst:270
msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr ""
"Este exemplo usa manipuladores de consola e ficheiro, mas pode usar qualquer "
"número e combinação de manipuladores que escolher."

#: ../../howto/logging-cookbook.rst:273
msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use of "
"a standard location for temporary files on POSIX systems. On Windows, you "
"may need to choose a different directory name for the log - just ensure that "
"the directory exists and that you have the permissions to create and update "
"files in it."
msgstr ""
"Note que a escolha acima do nome do ficheiro de registo ``/tmp/myapp.log`` "
"implica o uso de um local padrão para ficheiros temporários em sistemas "
"POSIX. No Windows, pode precisar de escolher um nome de diretório diferente "
"para o registo - apenas certifique-se de que o diretório existe e que tem "
"permissões para criar e atualizar ficheiros nele."

#: ../../howto/logging-cookbook.rst:282
msgid "Custom handling of levels"
msgstr "Tratamento personalizado de níveis"

#: ../../howto/logging-cookbook.rst:284
msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a threshold "
"get processed by a handler. To do this, you need to use filters. Let's look "
"at a scenario where you want to arrange things as follows:"
msgstr ""
"Às vezes, pode querer fazer algo ligeiramente diferente do tratamento padrão "
"de níveis nos manipuladores, onde todos os níveis acima de um limite são "
"processados por um manipulador. Para fazer isto, precisa de usar filtros. "
"Vamos ver um cenário onde quer organizar as coisas da seguinte forma:"

#: ../../howto/logging-cookbook.rst:289
msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr ""
"Enviar mensagens de severidade ``INFO`` e ``WARNING`` para ``sys.stdout``"

#: ../../howto/logging-cookbook.rst:290
msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr "Enviar mensagens de severidade ``ERROR`` e acima para ``sys.stderr``"

#: ../../howto/logging-cookbook.rst:291
msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr ""
"Enviar mensagens de severidade ``DEBUG`` e acima para o ficheiro ``app.log``"

#: ../../howto/logging-cookbook.rst:293
msgid "Suppose you configure logging with the following JSON:"
msgstr "Suponha que configura o registo com o seguinte JSON:"

#: ../../howto/logging-cookbook.rst:295
msgid ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\"\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:335
msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout`` "
"would show messages of severity ``ERROR`` and only events of this severity "
"and higher will be tracked as well as ``INFO`` and ``WARNING`` messages. To "
"prevent this, we can set up a filter which excludes those messages and add "
"it to the relevant handler. This can be configured by adding a ``filters`` "
"section parallel to ``formatters`` and ``handlers``:"
msgstr ""
"Esta configuração faz *quase* o que queremos, exceto que ``sys.stdout`` "
"mostraria mensagens de severidade ``ERROR`` e apenas eventos desta "
"severidade e superior seriam rastreados, bem como mensagens ``INFO`` e "
"``WARNING``. Para evitar isto, podemos configurar um filtro que exclui essas "
"mensagens e adicioná-lo ao manipulador relevante. Isto pode ser configurado "
"adicionando uma secção ``filters`` paralela a ``formatters`` e ``handlers``:"

#: ../../howto/logging-cookbook.rst:341
msgid ""
"{\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"filters\": {\n"
"        \"avisos_e_abaixo\": {\n"
"            \"()\" : \"__main__.criar_filtro\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:352
msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr "e alterando a secção no manipulador ``stdout`` para o adicionar:"

#: ../../howto/logging-cookbook.rst:354
msgid ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"warnings_and_below\"]\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"stdout\": {\n"
"        \"class\": \"logging.StreamHandler\",\n"
"        \"level\": \"INFO\",\n"
"        \"formatter\": \"simple\",\n"
"        \"stream\": \"ext://sys.stdout\",\n"
"        \"filters\": [\"avisos_e_abaixo\"]\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:366
msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr ""
"Um filtro é apenas uma função, por isso podemos definir o ``filter_maker`` "
"(uma função fábrica) da seguinte forma:"

#: ../../howto/logging-cookbook.rst:369
msgid ""
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter"
msgstr ""
"def criar_filtro(nivel):\n"
"    nivel = getattr(logging, nivel)\n"
"\n"
"    def filtro(registro):\n"
"        return registro.levelno <= nivel\n"
"\n"
"    return filtro"

#: ../../howto/logging-cookbook.rst:379
msgid ""
"This converts the string argument passed in to a numeric level, and returns "
"a function which only returns ``True`` if the level of the passed in record "
"is at or below the specified level. Note that in this example I have defined "
"the ``filter_maker`` in a test script ``main.py`` that I run from the "
"command line, so its module will be ``__main__`` - hence the ``__main__."
"filter_maker`` in the filter configuration. You will need to change that if "
"you define it in a different module."
msgstr ""
"Isto converte o argumento de string passado para um nível numérico, e "
"devolve uma função que só devolve ``True`` se o nível do registo passado "
"estiver no ou abaixo do nível especificado. Note que neste exemplo defini o "
"``filter_maker`` num script de teste ``main.py`` que executo a partir da "
"linha de comandos, por isso o seu módulo será ``__main__`` - daí o "
"``__main__.filter_maker`` na configuração do filtro. Terá de alterar isso se "
"o definir noutro módulo."

#: ../../howto/logging-cookbook.rst:387
msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr ""
"Com o filtro adicionado, podemos executar ``main.py``, que na íntegra é:"

#: ../../howto/logging-cookbook.rst:389
msgid ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"warnings_and_below\": {\n"
"            \"()\" : \"__main__.filter_maker\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"warnings_and_below\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def filter_maker(level):\n"
"    level = getattr(logging, level)\n"
"\n"
"    def filter(record):\n"
"        return record.levelno <= level\n"
"\n"
"    return filter\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('A DEBUG message')\n"
"logging.info('An INFO message')\n"
"logging.warning('A WARNING message')\n"
"logging.error('An ERROR message')\n"
"logging.critical('A CRITICAL message')"
msgstr ""
"import json\n"
"import logging\n"
"import logging.config\n"
"\n"
"CONFIG = '''\n"
"{\n"
"    \"version\": 1,\n"
"    \"disable_existing_loggers\": false,\n"
"    \"formatters\": {\n"
"        \"simple\": {\n"
"            \"format\": \"%(levelname)-8s - %(message)s\"\n"
"        }\n"
"    },\n"
"    \"filters\": {\n"
"        \"avisos_e_abaixo\": {\n"
"            \"()\" : \"__main__.criar_filtro\",\n"
"            \"level\": \"WARNING\"\n"
"        }\n"
"    },\n"
"    \"handlers\": {\n"
"        \"stdout\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"INFO\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stdout\",\n"
"            \"filters\": [\"avisos_e_abaixo\"]\n"
"        },\n"
"        \"stderr\": {\n"
"            \"class\": \"logging.StreamHandler\",\n"
"            \"level\": \"ERROR\",\n"
"            \"formatter\": \"simple\",\n"
"            \"stream\": \"ext://sys.stderr\"\n"
"        },\n"
"        \"file\": {\n"
"            \"class\": \"logging.FileHandler\",\n"
"            \"formatter\": \"simple\",\n"
"            \"filename\": \"app.log\",\n"
"            \"mode\": \"w\"\n"
"        }\n"
"    },\n"
"    \"root\": {\n"
"        \"level\": \"DEBUG\",\n"
"        \"handlers\": [\n"
"            \"stderr\",\n"
"            \"stdout\",\n"
"            \"file\"\n"
"        ]\n"
"    }\n"
"}\n"
"'''\n"
"\n"
"def criar_filtro(nivel):\n"
"    nivel = getattr(logging, nivel)\n"
"\n"
"    def filtro(registro):\n"
"        return registro.levelno <= nivel\n"
"\n"
"    return filtro\n"
"\n"
"logging.config.dictConfig(json.loads(CONFIG))\n"
"logging.debug('Uma mensagem DEBUG')\n"
"logging.info('Uma mensagem INFO')\n"
"logging.warning('Uma mensagem WARNING')\n"
"logging.error('Uma mensagem ERROR')\n"
"logging.critical('Uma mensagem CRITICAL')"

#: ../../howto/logging-cookbook.rst:457
msgid "And after running it like this:"
msgstr "E depois de o executar assim:"

#: ../../howto/logging-cookbook.rst:459
msgid "python main.py 2>stderr.log >stdout.log"
msgstr "python main.py 2>stderr.log >stdout.log"

#: ../../howto/logging-cookbook.rst:463
msgid "We can see the results are as expected:"
msgstr "Podemos ver que os resultados são como esperado:"

#: ../../howto/logging-cookbook.rst:465
msgid ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - A DEBUG message\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - An ERROR message\n"
"CRITICAL - A CRITICAL message\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - An INFO message\n"
"WARNING  - A WARNING message"
msgstr ""
"$ more *.log\n"
"::::::::::::::\n"
"app.log\n"
"::::::::::::::\n"
"DEBUG    - Uma mensagem DEBUG\n"
"INFO     - Uma mensagem INFO\n"
"WARNING  - Uma mensagem WARNING\n"
"ERROR    - Uma mensagem ERROR\n"
"CRITICAL - Uma mensagem CRITICAL\n"
"::::::::::::::\n"
"stderr.log\n"
"::::::::::::::\n"
"ERROR    - Uma mensagem ERROR\n"
"CRITICAL - Uma mensagem CRITICAL\n"
"::::::::::::::\n"
"stdout.log\n"
"::::::::::::::\n"
"INFO     - Uma mensagem INFO\n"
"WARNING  - Uma mensagem WARNING"

#: ../../howto/logging-cookbook.rst:489
msgid "Configuration server example"
msgstr "Exemplo de servidor de configuração"

#: ../../howto/logging-cookbook.rst:491
msgid "Here is an example of a module using the logging configuration server::"
msgstr ""
"Aqui está um exemplo de um módulo que usa o servidor de configuração de "
"registo::"

#: ../../howto/logging-cookbook.rst:493
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"import os\n"
"\n"
"# read initial config file\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# create and start listener on port 9999\n"
"t = logging.config.listen(9999)\n"
"t.start()\n"
"\n"
"logger = logging.getLogger('simpleExample')\n"
"\n"
"try:\n"
"    # loop through logging calls to see the difference\n"
"    # new configurations make, until Ctrl+C is pressed\n"
"    while True:\n"
"        logger.debug('debug message')\n"
"        logger.info('info message')\n"
"        logger.warning('warn message')\n"
"        logger.error('error message')\n"
"        logger.critical('critical message')\n"
"        time.sleep(5)\n"
"except KeyboardInterrupt:\n"
"    # cleanup\n"
"    logging.config.stopListening()\n"
"    t.join()"
msgstr ""
"import logging\n"
"import logging.config\n"
"import time\n"
"import os\n"
"\n"
"# ler ficheiro de configuração inicial\n"
"logging.config.fileConfig('logging.conf')\n"
"\n"
"# criar e iniciar ouvinte na porta 9999\n"
"t = logging.config.listen(9999)\n"
"t.start()\n"
"\n"
"logger = logging.getLogger('exemploSimples')\n"
"\n"
"try:\n"
"    # percorrer chamadas de registo para ver a diferença\n"
"    # que as novas configurações fazem, até ser premido Ctrl+C\n"
"    while True:\n"
"        logger.debug('mensagem de depuração')\n"
"        logger.info('mensagem de informação')\n"
"        logger.warning('mensagem de aviso')\n"
"        logger.error('mensagem de erro')\n"
"        logger.critical('mensagem crítica')\n"
"        time.sleep(5)\n"
"except KeyboardInterrupt:\n"
"    # limpeza\n"
"    logging.config.stopListening()\n"
"    t.join()"

#: ../../howto/logging-cookbook.rst:522
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging "
"configuration::"
msgstr ""
"E aqui está um script que recebe um nome de ficheiro e envia esse ficheiro "
"para o servidor, devidamente precedido pelo comprimento codificado em "
"binário, como a nova configuração de registo::"

#: ../../howto/logging-cookbook.rst:526
msgid ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('connecting...')\n"
"s.connect((HOST, PORT))\n"
"print('sending config...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('complete')"
msgstr ""
"#!/usr/bin/env python\n"
"import socket, sys, struct\n"
"\n"
"with open(sys.argv[1], 'rb') as f:\n"
"    data_to_send = f.read()\n"
"\n"
"HOST = 'localhost'\n"
"PORT = 9999\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"print('a conectar...')\n"
"s.connect((HOST, PORT))\n"
"print('a enviar configuração...')\n"
"s.send(struct.pack('>L', len(data_to_send)))\n"
"s.send(data_to_send)\n"
"s.close()\n"
"print('completo')"

#: ../../howto/logging-cookbook.rst:547
msgid "Dealing with handlers that block"
msgstr "Lidar com manipuladores que bloqueiam"

#: ../../howto/logging-cookbook.rst:551
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web applications, "
"though of course it also occurs in other scenarios."
msgstr ""
"Às vezes, tem de fazer com que os seus manipuladores de registo façam o seu "
"trabalho sem bloquear a thread da qual está a registar. Isto é comum em "
"aplicações web, embora também ocorra noutros cenários."

#: ../../howto/logging-cookbook.rst:555
msgid ""
"A common culprit which demonstrates sluggish behaviour is the :class:"
"`SMTPHandler`: sending emails can take a long time, for a number of reasons "
"outside the developer's control (for example, a poorly performing mail or "
"network infrastructure). But almost any network-based handler can block: "
"Even a :class:`SocketHandler` operation may do a DNS query under the hood "
"which is too slow (and this query can be deep in the socket library code, "
"below the Python layer, and outside your control)."
msgstr ""
"Um culpado comum que demonstra comportamento lento é o :class:`SMTPHandler`: "
"enviar emails pode demorar muito tempo, por várias razões fora do controlo "
"do desenvolvedor (por exemplo, uma infraestrutura de email ou rede com mau "
"desempenho). Mas quase qualquer manipulador baseado em rede pode bloquear: "
"Até uma operação :class:`SocketHandler` pode fazer uma consulta DNS por "
"baixo que é demasiado lenta (e esta consulta pode estar profundamente no "
"código da biblioteca de sockets, abaixo da camada Python, e fora do seu "
"controlo)."

#: ../../howto/logging-cookbook.rst:563
msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from performance-"
"critical threads. They simply write to their queue, which can be sized to a "
"large enough capacity or initialized with no upper bound to their size. The "
"write to the queue will typically be accepted quickly, though you will "
"probably need to catch the :exc:`queue.Full` exception as a precaution in "
"your code. If you are a library developer who has performance-critical "
"threads in their code, be sure to document this (together with a suggestion "
"to attach only ``QueueHandlers`` to your loggers) for the benefit of other "
"developers who will use your code."
msgstr ""
"Uma solução é usar uma abordagem em duas partes. Para a primeira parte, "
"anexe apenas um :class:`QueueHandler` àqueles registadores que são acedidos "
"a partir de threads críticas de desempenho. Eles simplesmente escrevem para "
"a sua fila, que pode ser dimensionada para uma capacidade suficientemente "
"grande ou inicializada sem limite superior para o seu tamanho. A escrita "
"para a fila será tipicamente aceite rapidamente, embora provavelmente "
"precise de capturar a exceção :exc:`queue.Full` como precaução no seu "
"código. Se for um desenvolvedor de bibliotecas que tem threads críticas de "
"desempenho no seu código, certifique-se de documentar isto (juntamente com "
"uma sugestão para anexar apenas ``QueueHandlers`` aos seus registadores) "
"para benefício de outros desenvolvedores que irão usar o seu código."

#: ../../howto/logging-cookbook.rst:574
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A :class:"
"`QueueListener` is very simple: it's passed a queue and some handlers, and "
"it fires up an internal thread which listens to its queue for LogRecords "
"sent from ``QueueHandlers`` (or any other source of ``LogRecords``, for that "
"matter). The ``LogRecords`` are removed from the queue and passed to the "
"handlers for processing."
msgstr ""
"A segunda parte da solução é :class:`QueueListener`, que foi concebido como "
"o complemento de :class:`QueueHandler`. Um :class:`QueueListener` é muito "
"simples: recebe uma fila e alguns manipuladores, e inicia uma thread interna "
"que ouve a sua fila para LogRecords enviados de ``QueueHandlers`` (ou "
"qualquer outra fonte de ``LogRecords``, já agora). Os ``LogRecords`` são "
"removidos da fila e passados aos manipuladores para processamento."

#: ../../howto/logging-cookbook.rst:582
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular "
"benefit."
msgstr ""
"A vantagem de ter uma classe :class:`QueueListener` separada é que pode usar "
"a mesma instância para servir vários ``QueueHandlers``. Isto é mais "
"eficiente em termos de recursos do que, por exemplo, ter versões com threads "
"das classes de manipuladores existentes, que consumiriam uma thread por "
"manipulador sem qualquer benefício particular."

#: ../../howto/logging-cookbook.rst:587
msgid "An example of using these two classes follows (imports omitted)::"
msgstr ""
"Segue-se um exemplo de utilização destas duas classes (importações "
"omitidas)::"

#: ../../howto/logging-cookbook.rst:589
msgid ""
"que = queue.Queue(-1)  # no limit on size\n"
"queue_handler = QueueHandler(que)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(que, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# The log output will display the thread which generated\n"
"# the event (the main thread) rather than the internal\n"
"# thread which monitors the internal queue. This is what\n"
"# you want to happen.\n"
"root.warning('Look out!')\n"
"listener.stop()"
msgstr ""
"fila = queue.Queue(-1)  # sem limite de tamanho\n"
"queue_handler = QueueHandler(fila)\n"
"handler = logging.StreamHandler()\n"
"listener = QueueListener(fila, handler)\n"
"root = logging.getLogger()\n"
"root.addHandler(queue_handler)\n"
"formatter = logging.Formatter('%(threadName)s: %(message)s')\n"
"handler.setFormatter(formatter)\n"
"listener.start()\n"
"# A saída de registo irá mostrar a thread que gerou\n"
"# o evento (a thread principal) em vez da thread interna\n"
"# que monitoriza a fila interna. Isto é o que\n"
"# quer que aconteça.\n"
"root.warning('Cuidado!')\n"
"listener.stop()"

#: ../../howto/logging-cookbook.rst:605
msgid "which, when run, will produce:"
msgstr "que, quando executado, produzirá:"

#: ../../howto/logging-cookbook.rst:607
msgid "MainThread: Look out!"
msgstr "MainThread: Cuidado!"

#: ../../howto/logging-cookbook.rst:611
msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that when "
"logging from async code, network and even file handlers could lead to "
"problems (blocking the event loop) because some logging is done from :mod:"
"`asyncio` internals. It might be best, if any async code is used in an "
"application, to use the above approach for logging, so that any blocking "
"code runs only in the ``QueueListener`` thread."
msgstr ""
"Embora a discussão anterior não estivesse a falar especificamente sobre "
"código assíncrono, mas sim sobre manipuladores de registo lentos, deve ser "
"notado que ao registar a partir de código assíncrono, manipuladores de rede "
"e até de ficheiros podem levar a problemas (bloqueando o loop de eventos) "
"porque algum registo é feito a partir dos internos de :mod:`asyncio`. Pode "
"ser melhor, se qualquer código assíncrono for usado numa aplicação, usar a "
"abordagem acima para registo, de modo a que qualquer código bloqueante seja "
"executado apenas na thread ``QueueListener``."

#: ../../howto/logging-cookbook.rst:619
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"Antes do Python 3.5, o :class:`QueueListener` passava sempre todas as "
"mensagens recebidas da fila para todos os manipuladores com que foi "
"inicializado. (Isto devia-se ao facto de se assumir que a filtragem de nível "
"era toda feita do outro lado, onde a fila é preenchida.) A partir do 3.5, "
"este comportamento pode ser alterado passando um argumento de palavra-chave "
"``respect_handler_level=True`` ao construtor do ouvinte. Quando isto é "
"feito, o ouvinte compara o nível de cada mensagem com o nível do "
"manipulador, e só passa uma mensagem a um manipulador se for apropriado fazê-"
"lo."

#: ../../howto/logging-cookbook.rst:632
msgid "Sending and receiving logging events across a network"
msgstr "Enviar e receber eventos de registo através de uma rede"

#: ../../howto/logging-cookbook.rst:634
msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a :class:"
"`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"Suponha que quer enviar eventos de registo através de uma rede, e tratá-los "
"no lado do receptor. Uma forma simples de fazer isto é anexar uma instância :"
"class:`SocketHandler` ao registador raiz no lado do envio::"

#: ../../howto/logging-cookbook.rst:638
msgid ""
"import logging, logging.handlers\n"
"\n"
"rootLogger = logging.getLogger('')\n"
"rootLogger.setLevel(logging.DEBUG)\n"
"socketHandler = logging.handlers.SocketHandler('localhost',\n"
"                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"# don't bother with a formatter, since a socket handler sends the event as\n"
"# an unformatted pickle\n"
"rootLogger.addHandler(socketHandler)\n"
"\n"
"# Now, we can log to the root logger, or any other logger. First the "
"root...\n"
"logging.info('Jackdaws love my big sphinx of quartz.')\n"
"\n"
"# Now, define a couple of other loggers which might represent areas in your\n"
"# application:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Quick zephyrs blow, vexing daft Jim.')\n"
"logger1.info('How quickly daft jumping zebras vex.')\n"
"logger2.warning('Jail zesty vixen who grabbed pay from quack.')\n"
"logger2.error('The five boxing wizards jump quickly.')"
msgstr ""
"import logging, logging.handlers\n"
"\n"
"rootLogger = logging.getLogger('')\n"
"rootLogger.setLevel(logging.DEBUG)\n"
"socketHandler = logging.handlers.SocketHandler('localhost',\n"
"                    logging.handlers.DEFAULT_TCP_LOGGING_PORT)\n"
"# não se preocupe com um formatador, uma vez que um manipulador de socket "
"envia o evento como\n"
"# um pickle não formatado\n"
"rootLogger.addHandler(socketHandler)\n"
"\n"
"# Agora, podemos registar no registador raiz, ou em qualquer outro "
"registador. Primeiro o raiz...\n"
"logging.info('Os gralhas adoram o meu grande esfinge de quartzo.')\n"
"\n"
"# Agora, definir alguns outros registadores que podem representar áreas na "
"sua\n"
"# aplicação:\n"
"\n"
"logger1 = logging.getLogger('myapp.area1')\n"
"logger2 = logging.getLogger('myapp.area2')\n"
"\n"
"logger1.debug('Ventos rápidos sopram, irritando o Jim tolo.')\n"
"logger1.info('Quão rapidamente zebras saltitantes tolas irritam.')\n"
"logger2.warning('Prisão da raposa astuta que roubou o pagamento do pato.')\n"
"logger2.error('Os cinco mágicos boxeadores saltam rapidamente.')"

#: ../../howto/logging-cookbook.rst:662
msgid ""
"At the receiving end, you can set up a receiver using the :mod:"
"`socketserver` module. Here is a basic working example::"
msgstr ""
"No lado do receptor, pode configurar um recetor usando o módulo :mod:"
"`socketserver`. Aqui está um exemplo básico funcional::"

#: ../../howto/logging-cookbook.rst:665
msgid ""
"import pickle\n"
"import logging\n"
"import logging.handlers\n"
"import socketserver\n"
"import struct\n"
"\n"
"\n"
"class LogRecordStreamHandler(socketserver.StreamRequestHandler):\n"
"    \"\"\"Handler for a streaming logging request.\n"
"\n"
"    This basically logs the record using whatever logging policy is\n"
"    configured locally.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        \"\"\"\n"
"        Handle multiple requests - each expected to be a 4-byte length,\n"
"        followed by the LogRecord in pickle format. Logs the record\n"
"        according to whatever policy is configured locally.\n"
"        \"\"\"\n"
"        while True:\n"
"            chunk = self.connection.recv(4)\n"
"            if len(chunk) < 4:\n"
"                break\n"
"            slen = struct.unpack('>L', chunk)[0]\n"
"            chunk = self.connection.recv(slen)\n"
"            while len(chunk) < slen:\n"
"                chunk = chunk + self.connection.recv(slen - len(chunk))\n"
"            obj = self.unPickle(chunk)\n"
"            record = logging.makeLogRecord(obj)\n"
"            self.handleLogRecord(record)\n"
"\n"
"    def unPickle(self, data):\n"
"        return pickle.loads(data)\n"
"\n"
"    def handleLogRecord(self, record):\n"
"        # if a name is specified, we use the named logger rather than the "
"one\n"
"        # implied by the record.\n"
"        if self.server.logname is not None:\n"
"            name = self.server.logname\n"
"        else:\n"
"            name = record.name\n"
"        logger = logging.getLogger(name)\n"
"        # N.B. EVERY record gets logged. This is because Logger.handle\n"
"        # is normally called AFTER logger-level filtering. If you want\n"
"        # to do filtering, do it at the client end to save wasting\n"
"        # cycles and network bandwidth!\n"
"        logger.handle(record)\n"
"\n"
"class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):\n"
"    \"\"\"\n"
"    Simple TCP socket-based logging receiver suitable for testing.\n"
"    \"\"\"\n"
"\n"
"    allow_reuse_address = True\n"
"\n"
"    def __init__(self, host='localhost',\n"
"                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n"
"                 handler=LogRecordStreamHandler):\n"
"        socketserver.ThreadingTCPServer.__init__(self, (host, port), "
"handler)\n"
"        self.abort = 0\n"
"        self.timeout = 1\n"
"        self.logname = None\n"
"\n"
"    def serve_until_stopped(self):\n"
"        import select\n"
"        abort = 0\n"
"        while not abort:\n"
"            rd, wr, ex = select.select([self.socket.fileno()],\n"
"                                       [], [],\n"
"                                       self.timeout)\n"
"            if rd:\n"
"                self.handle_request()\n"
"            abort = self.abort\n"
"\n"
"def main():\n"
"    logging.basicConfig(\n"
"        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s "
"%(message)s')\n"
"    tcpserver = LogRecordSocketReceiver()\n"
"    print('About to start TCP server...')\n"
"    tcpserver.serve_until_stopped()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import pickle\n"
"import logging\n"
"import logging.handlers\n"
"import socketserver\n"
"import struct\n"
"\n"
"\n"
"class LogRecordStreamHandler(socketserver.StreamRequestHandler):\n"
"    \"\"\"Manipulador para um pedido de registo em fluxo.\n"
"\n"
"    Isto basicamente regista o registo usando qualquer política de registo "
"que\n"
"    esteja configurada localmente.\n"
"    \"\"\"\n"
"\n"
"    def handle(self):\n"
"        \"\"\"\n"
"        Manipula vários pedidos - cada um esperado ser um comprimento de 4 "
"bytes,\n"
"        seguido do LogRecord em formato pickle. Regista o registo\n"
"        de acordo com qualquer política configurada localmente.\n"
"        \"\"\"\n"
"        while True:\n"
"            chunk = self.connection.recv(4)\n"
"            if len(chunk) < 4:\n"
"                break\n"
"            slen = struct.unpack('>L', chunk)[0]\n"
"            chunk = self.connection.recv(slen)\n"
"            while len(chunk) < slen:\n"
"                chunk = chunk + self.connection.recv(slen - len(chunk))\n"
"            obj = self.unPickle(chunk)\n"
"            record = logging.makeLogRecord(obj)\n"
"            self.handleLogRecord(record)\n"
"\n"
"    def unPickle(self, data):\n"
"        return pickle.loads(data)\n"
"\n"
"    def handleLogRecord(self, record):\n"
"        # se um nome for especificado, usamos o registador nomeado em vez "
"do\n"
"        # implícito pelo registo.\n"
"        if self.server.logname is not None:\n"
"            name = self.server.logname\n"
"        else:\n"
"            name = record.name\n"
"        logger = logging.getLogger(name)\n"
"        # N.B. TODOS os registos são registados. Isto porque Logger.handle\n"
"        # é normalmente chamado DEPOIS da filtragem ao nível do registador. "
"Se quiser\n"
"        # fazer filtragem, faça-a no lado do cliente para poupar ciclos e "
"largura de banda de rede!\n"
"        logger.handle(record)\n"
"\n"
"class LogRecordSocketReceiver(socketserver.ThreadingTCPServer):\n"
"    \"\"\"\n"
"    Recetor de registo baseado em socket TCP simples adequado para teste.\n"
"    \"\"\"\n"
"\n"
"    allow_reuse_address = True\n"
"\n"
"    def __init__(self, host='localhost',\n"
"                 port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,\n"
"                 handler=LogRecordStreamHandler):\n"
"        socketserver.ThreadingTCPServer.__init__(self, (host, port), "
"handler)\n"
"        self.abort = 0\n"
"        self.timeout = 1\n"
"        self.logname = None\n"
"\n"
"    def serve_until_stopped(self):\n"
"        import select\n"
"        abort = 0\n"
"        while not abort:\n"
"            rd, wr, ex = select.select([self.socket.fileno()],\n"
"                                       [], [],\n"
"                                       self.timeout)\n"
"            if rd:\n"
"                self.handle_request()\n"
"            abort = self.abort\n"
"\n"
"def main():\n"
"    logging.basicConfig(\n"
"        format='%(relativeCreated)5d %(name)-15s %(levelname)-8s "
"%(message)s')\n"
"    tcpserver = LogRecordSocketReceiver()\n"
"    print('A iniciar servidor TCP...')\n"
"    tcpserver.serve_until_stopped()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:750
msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr ""
"Primeiro execute o servidor, e depois o cliente. No lado do cliente, nada é "
"impresso na consola; no lado do servidor, deve ver algo como:"

#: ../../howto/logging-cookbook.rst:753
msgid ""
"About to start TCP server...\n"
"   59 root            INFO     Jackdaws love my big sphinx of quartz.\n"
"   59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.\n"
"   69 myapp.area1     INFO     How quickly daft jumping zebras vex.\n"
"   69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.\n"
"   69 myapp.area2     ERROR    The five boxing wizards jump quickly."
msgstr ""
"A iniciar servidor TCP...\n"
"   59 root            INFO     Os gralhas adoram o meu grande esfinge de "
"quartzo.\n"
"   59 myapp.area1     DEBUG    Ventos rápidos sopram, irritando o Jim tolo.\n"
"   69 myapp.area1     INFO     Quão rapidamente zebras saltitantes tolas "
"irritam.\n"
"   69 myapp.area2     AVISO    Prisão da raposa astuta que roubou o "
"pagamento do pato.\n"
"   69 myapp.area2     ERRO     Os cinco mágicos boxeadores saltam "
"rapidamente."

#: ../../howto/logging-cookbook.rst:762
msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~SocketHandler.makePickle` method and implementing "
"your alternative there, as well as adapting the above script to use your "
"alternative serialization."
msgstr ""
"Note que existem algumas questões de segurança com pickle em alguns "
"cenários. Se estas o afetam, pode usar um esquema de serialização "
"alternativo substituindo o método :meth:`~SocketHandler.makePickle` e "
"implementando a sua alternativa lá, bem como adaptando o script acima para "
"usar a sua serialização alternativa."

#: ../../howto/logging-cookbook.rst:770
msgid "Running a logging socket listener in production"
msgstr "Executar um ouvinte de socket de registo em produção"

#: ../../howto/logging-cookbook.rst:774
msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is a "
"Gist <socket-listener-gist_>`__ which provides the bare-bones files to run "
"the above functionality using Supervisor. It consists of the following files:"
msgstr ""
"Para executar um ouvinte de registo em produção, pode precisar de usar uma "
"ferramenta de gestão de processos como `Supervisor <http://supervisord.org/"
">`_. `Aqui está um Gist <socket-listener-gist_>`__ que fornece os ficheiros "
"básicos para executar a funcionalidade acima usando o Supervisor. Consiste "
"nos seguintes ficheiros:"

#: ../../howto/logging-cookbook.rst:781
msgid "File"
msgstr "Ficheiro"

#: ../../howto/logging-cookbook.rst:781
msgid "Purpose"
msgstr "Finalidade"

#: ../../howto/logging-cookbook.rst:783
msgid ":file:`prepare.sh`"
msgstr ":file:`prepare.sh`"

#: ../../howto/logging-cookbook.rst:783
msgid "A Bash script to prepare the environment for testing"
msgstr "Um script Bash para preparar o ambiente para teste"

#: ../../howto/logging-cookbook.rst:786
msgid ":file:`supervisor.conf`"
msgstr ":file:`supervisor.conf`"

#: ../../howto/logging-cookbook.rst:786
msgid ""
"The Supervisor configuration file, which has entries for the listener and a "
"multi-process web application"
msgstr ""
"O ficheiro de configuração do Supervisor, que contém entradas para o ouvinte "
"e uma aplicação web multi-processo"

#: ../../howto/logging-cookbook.rst:790
msgid ":file:`ensure_app.sh`"
msgstr ":file:`ensure_app.sh`"

#: ../../howto/logging-cookbook.rst:790
msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr ""
"Um script Bash para garantir que o Supervisor está a ser executado com a "
"configuração acima"

#: ../../howto/logging-cookbook.rst:793
msgid ":file:`log_listener.py`"
msgstr ":file:`log_listener.py`"

#: ../../howto/logging-cookbook.rst:793
msgid ""
"The socket listener program which receives log events and records them to a "
"file"
msgstr ""
"O programa ouvinte de socket que recebe eventos de registo e os regista num "
"ficheiro"

#: ../../howto/logging-cookbook.rst:796
msgid ":file:`main.py`"
msgstr ":file:`main.py`"

#: ../../howto/logging-cookbook.rst:796
msgid ""
"A simple web application which performs logging via a socket connected to "
"the listener"
msgstr ""
"Uma aplicação web simples que realiza registo através de um socket ligado ao "
"ouvinte"

#: ../../howto/logging-cookbook.rst:799
msgid ":file:`webapp.json`"
msgstr ":file:`webapp.json`"

#: ../../howto/logging-cookbook.rst:799
msgid "A JSON configuration file for the web application"
msgstr "Um ficheiro de configuração JSON para a aplicação web"

#: ../../howto/logging-cookbook.rst:801
msgid ":file:`client.py`"
msgstr ":file:`client.py`"

#: ../../howto/logging-cookbook.rst:801
msgid "A Python script to exercise the web application"
msgstr "Um script Python para testar a aplicação web"

#: ../../howto/logging-cookbook.rst:804
msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to the "
"same log file without conflicting with one another --- they all go through "
"the socket listener."
msgstr ""
"A aplicação web usa `Gunicorn <https://gunicorn.org/>`_, que é um servidor "
"de aplicações web popular que inicia vários processos de trabalho para lidar "
"com pedidos. Esta configuração de exemplo mostra como os trabalhadores podem "
"escrever para o mesmo ficheiro de registo sem conflitos entre si --- todos "
"passam pelo ouvinte de socket."

#: ../../howto/logging-cookbook.rst:809
msgid "To test these files, do the following in a POSIX environment:"
msgstr "Para testar estes ficheiros, faça o seguinte num ambiente POSIX:"

#: ../../howto/logging-cookbook.rst:811
msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the :"
"guilabel:`Download ZIP` button."
msgstr ""
"Descarregue `o Gist <socket-listener-gist_>`__ como um arquivo ZIP usando o "
"botão :guilabel:`Download ZIP`."

#: ../../howto/logging-cookbook.rst:814
msgid "Unzip the above files from the archive into a scratch directory."
msgstr ""
"Descompacte os ficheiros acima do arquivo para um diretório temporário."

#: ../../howto/logging-cookbook.rst:816
msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. This "
"creates a :file:`run` subdirectory to contain Supervisor-related and log "
"files, and a :file:`venv` subdirectory to contain a virtual environment into "
"which ``bottle``, ``gunicorn`` and ``supervisor`` are installed."
msgstr ""
"No diretório temporário, execute ``bash prepare.sh`` para preparar tudo. "
"Isto cria um subdiretório :file:`run` para conter ficheiros relacionados com "
"o Supervisor e de registo, e um subdiretório :file:`venv` para conter um "
"ambiente virtual no qual ``bottle``, ``gunicorn`` e ``supervisor`` são "
"instalados."

#: ../../howto/logging-cookbook.rst:821
msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr ""
"Execute ``bash ensure_app.sh`` para garantir que o Supervisor está a ser "
"executado com a configuração acima."

#: ../../howto/logging-cookbook.rst:824
msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr ""
"Execute ``venv/bin/python client.py`` para testar a aplicação web, o que "
"levará a que registos sejam escritos no ficheiro de registo."

#: ../../howto/logging-cookbook.rst:827
msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the "
"most recent log lines in files matching the pattern :file:`app.log*`. They "
"won't be in any particular order, since they have been handled concurrently "
"by different worker processes in a non-deterministic way."
msgstr ""
"Inspecione os ficheiros de registo no subdiretório :file:`run`. Deve ver as "
"linhas de registo mais recentes em ficheiros que correspondem ao padrão :"
"file:`app.log*`. Não estarão por qualquer ordem específica, uma vez que "
"foram tratadas concorrentemente por diferentes processos de trabalho de "
"forma não determinística."

#: ../../howto/logging-cookbook.rst:832
msgid ""
"You can shut down the listener and the web application by running ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."
msgstr ""
"Pode desligar o ouvinte e a aplicação web executando ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."

#: ../../howto/logging-cookbook.rst:835
msgid ""
"You may need to tweak the configuration files in the unlikely event that the "
"configured ports clash with something else in your test environment."
msgstr ""
"Pode precisar de ajustar os ficheiros de configuração no improvável caso de "
"as portas configuradas entrarem em conflito com outra coisa no seu ambiente "
"de teste."

#: ../../howto/logging-cookbook.rst:838
msgid ""
"The default configuration uses a TCP socket on port 9020. You can use a Unix "
"Domain socket instead of a TCP socket by doing the following:"
msgstr ""
"A configuração padrão usa um socket TCP na porta 9020. Pode usar um socket "
"de domínio Unix em vez de um socket TCP fazendo o seguinte:"

#: ../../howto/logging-cookbook.rst:841
msgid ""
"In :file:`listener.json`, add a ``socket`` key with the path to the domain "
"socket you want to use. If this key is present, the listener listens on the "
"corresponding domain socket and not on a TCP socket (the ``port`` key is "
"ignored)."
msgstr ""
"Em :file:`listener.json`, adicione uma chave ``socket`` com o caminho para o "
"socket de domínio que quer usar. Se esta chave estiver presente, o ouvinte "
"escuta no socket de domínio correspondente e não num socket TCP (a chave "
"``port`` é ignorada)."

#: ../../howto/logging-cookbook.rst:846
msgid ""
"In :file:`webapp.json`, change the socket handler configuration dictionary "
"so that the ``host`` value is the path to the domain socket, and set the "
"``port`` value to ``null``."
msgstr ""
"Em :file:`webapp.json`, altere o dicionário de configuração do manipulador "
"de socket para que o valor ``host`` seja o caminho para o socket de domínio, "
"e defina o valor ``port`` para ``null``."

#: ../../howto/logging-cookbook.rst:856
msgid "Adding contextual information to your logging output"
msgstr "Adicionar informações contextuais à saída de registo"

#: ../../howto/logging-cookbook.rst:858
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this "
"is not a good idea because these instances are not garbage collected. While "
"this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of :class:"
"`Logger` instances becomes effectively unbounded."
msgstr ""
"Às vezes, quer que a saída de registo contenha informações contextuais além "
"dos parâmetros passados para a chamada de registo. Por exemplo, numa "
"aplicação em rede, pode ser desejável registar informações específicas do "
"cliente no registo (por exemplo, nome de utilizador do cliente remoto ou "
"endereço IP). Embora possa usar o parâmetro *extra* para conseguir isto, nem "
"sempre é conveniente passar a informação desta forma. Embora possa ser "
"tentador criar instâncias :class:`Logger` por ligação, isto não é uma boa "
"ideia porque estas instâncias não são recolhidas pelo garbage collector. "
"Embora isto não seja um problema na prática, quando o número de instâncias :"
"class:`Logger` depende do nível de granularidade que quer usar no registo de "
"uma aplicação, pode ser difícil de gerir se o número de instâncias :class:"
"`Logger` se tornar efetivamente ilimitado."

#: ../../howto/logging-cookbook.rst:873
msgid "Using LoggerAdapters to impart contextual information"
msgstr "Usar LoggerAdapters para transmitir informações contextuais"

#: ../../howto/logging-cookbook.rst:875
msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call :"
"meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:"
"`exception`, :meth:`critical` and :meth:`log`. These methods have the same "
"signatures as their counterparts in :class:`Logger`, so you can use the two "
"types of instances interchangeably."
msgstr ""
"Uma forma fácil de passar informações contextuais para serem apresentadas "
"juntamente com as informações do evento de registo é usar a classe :class:"
"`LoggerAdapter`. Esta classe foi concebida para parecer um :class:`Logger`, "
"de modo a que possa chamar :meth:`debug`, :meth:`info`, :meth:`warning`, :"
"meth:`error`, :meth:`exception`, :meth:`critical` e :meth:`log`. Estes "
"métodos têm as mesmas assinaturas que os seus homólogos em :class:`Logger`, "
"pelo que pode usar os dois tipos de instâncias de forma intercambiável."

#: ../../howto/logging-cookbook.rst:883
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a :class:"
"`Logger` instance and a dict-like object which contains your contextual "
"information. When you call one of the logging methods on an instance of :"
"class:`LoggerAdapter`, it delegates the call to the underlying instance of :"
"class:`Logger` passed to its constructor, and arranges to pass the "
"contextual information in the delegated call. Here's a snippet from the code "
"of :class:`LoggerAdapter`::"
msgstr ""
"Quando cria uma instância de :class:`LoggerAdapter`, passa-lhe uma "
"instância :class:`Logger` e um objeto tipo dicionário que contém as suas "
"informações contextuais. Quando chama um dos métodos de registo numa "
"instância de :class:`LoggerAdapter`, este delega a chamada para a instância "
"subjacente de :class:`Logger` passada ao seu construtor, e organiza para "
"passar as informações contextuais na chamada delegada. Aqui está um excerto "
"do código de :class:`LoggerAdapter`::"

#: ../../howto/logging-cookbook.rst:891
msgid ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    Delegate a debug call to the underlying logger, after adding\n"
"    contextual information from this adapter instance.\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"
msgstr ""
"def debug(self, msg, /, *args, **kwargs):\n"
"    \"\"\"\n"
"    Delegar uma chamada de depuração ao registador subjacente, após "
"adicionar\n"
"    informações contextuais desta instância do adaptador.\n"
"    \"\"\"\n"
"    msg, kwargs = self.process(msg, kwargs)\n"
"    self.logger.debug(msg, *args, **kwargs)"

#: ../../howto/logging-cookbook.rst:899
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where "
"the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
"O método :meth:`~LoggerAdapter.process` da classe :class:`LoggerAdapter` é "
"onde as informações contextuais são adicionadas à saída de registo. Recebe a "
"mensagem e os argumentos de palavra-chave da chamada de registo, e devolve "
"(potencialmente) versões modificadas destes para usar na chamada ao "
"registador subjacente. A implementação padrão deste método deixa a mensagem "
"inalterada, mas insere uma chave 'extra' no argumento de palavra-chave cujo "
"valor é o objeto tipo dicionário passado ao construtor. Claro, se tiver "
"passado um argumento de palavra-chave 'extra' na chamada ao adaptador, este "
"será silenciosamente sobrescrito."

#: ../../howto/logging-cookbook.rst:908
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g. "
"if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override :meth:"
"`~LoggerAdapter.process` to do what you need. Here is a simple example::"
msgstr ""
"A vantagem de usar 'extra' é que os valores no objeto tipo dicionário são "
"fundidos no __dict__ da instância :class:`LogRecord`, permitindo-lhe usar "
"strings personalizadas com as suas instâncias :class:`Formatter` que "
"conhecem as chaves do objeto tipo dicionário. Se precisar de um método "
"diferente, por exemplo, se quiser antepor ou acrescentar as informações "
"contextuais à string da mensagem, basta criar uma subclasse de :class:"
"`LoggerAdapter` e substituir :meth:`~LoggerAdapter.process` para fazer o que "
"precisa. Aqui está um exemplo simples::"

#: ../../howto/logging-cookbook.rst:916
msgid ""
"class CustomAdapter(logging.LoggerAdapter):\n"
"    \"\"\"\n"
"    This example adapter expects the passed in dict-like object to have a\n"
"    'connid' key, whose value in brackets is prepended to the log message.\n"
"    \"\"\"\n"
"    def process(self, msg, kwargs):\n"
"        return '[%s] %s' % (self.extra['connid'], msg), kwargs"
msgstr ""
"class AdaptadorPersonalizado(logging.LoggerAdapter):\n"
"    \"\"\"\n"
"    Este adaptador de exemplo espera que o objeto tipo dicionário passado "
"tenha uma\n"
"    chave 'connid', cujo valor entre parênteses é anteposto à mensagem de "
"registo.\n"
"    \"\"\"\n"
"    def process(self, msg, kwargs):\n"
"        return '[%s] %s' % (self.extra['connid'], msg), kwargs"

#: ../../howto/logging-cookbook.rst:924
msgid "which you can use like this::"
msgstr "que pode usar assim::"

#: ../../howto/logging-cookbook.rst:926
msgid ""
"logger = logging.getLogger(__name__)\n"
"adapter = CustomAdapter(logger, {'connid': some_conn_id})"
msgstr ""
"logger = logging.getLogger(__name__)\n"
"adaptador = AdaptadorPersonalizado(logger, {'connid': algum_id_ligacao})"

#: ../../howto/logging-cookbook.rst:929
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr ""
"Depois, quaisquer eventos que registar no adaptador terão o valor de "
"``some_conn_id`` anteposto às mensagens de registo."

#: ../../howto/logging-cookbook.rst:933
msgid "Using objects other than dicts to pass contextual information"
msgstr ""
"Usar objetos diferentes de dicionários para passar informações contextuais"

#: ../../howto/logging-cookbook.rst:935
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"Não precisa de passar um dicionário real para um :class:`LoggerAdapter` - "
"pode passar uma instância de uma classe que implementa ``__getitem__`` e "
"``__iter__`` para que pareça um dicionário para o registo. Isto seria útil "
"se quiser gerar valores dinamicamente (enquanto os valores num dicionário "
"seriam constantes)."

#: ../../howto/logging-cookbook.rst:944
msgid "Using Filters to impart contextual information"
msgstr "Usar Filtros para transmitir informações contextuais"

#: ../../howto/logging-cookbook.rst:946
msgid ""
"You can also add contextual information to log output using a user-defined :"
"class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom :"
"class:`Formatter`."
msgstr ""
"Também pode adicionar informações contextuais à saída de registo usando um :"
"class:`Filter` definido pelo utilizador. As instâncias ``Filter`` podem "
"modificar os ``LogRecords`` passados a elas, incluindo a adição de atributos "
"adicionais que podem então ser apresentados usando uma string de formato "
"adequada, ou, se necessário, um :class:`Formatter` personalizado."

#: ../../howto/logging-cookbook.rst:951
msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal (:class:"
"`threading.local`) variable, and then accessed from a ``Filter`` to add, "
"say, information from the request - say, the remote IP address and remote "
"user's username - to the ``LogRecord``, using the attribute names 'ip' and "
"'user' as in the ``LoggerAdapter`` example above. In that case, the same "
"format string can be used to get similar output to that shown above. Here's "
"an example script::"
msgstr ""
"Por exemplo, numa aplicação web, o pedido a ser processado (ou pelo menos, "
"as partes interessantes dele) pode ser armazenado numa variável threadlocal "
"(:class:`threading.local`), e depois acedido a partir de um ``Filter`` para "
"adicionar, por exemplo, informações do pedido - como o endereço IP remoto e "
"o nome de utilizador do utilizador remoto - ao ``LogRecord``, usando os "
"nomes de atributos 'ip' e 'user' como no exemplo ``LoggerAdapter`` acima. "
"Nesse caso, a mesma string de formato pode ser usada para obter uma saída "
"semelhante à mostrada acima. Aqui está um exemplo de script::"

#: ../../howto/logging-cookbook.rst:960
msgid ""
"import logging\n"
"from random import choice\n"
"\n"
"class ContextFilter(logging.Filter):\n"
"    \"\"\"\n"
"    This is a filter which injects contextual information into the log.\n"
"\n"
"    Rather than use actual contextual information, we just use random\n"
"    data in this demo.\n"
"    \"\"\"\n"
"\n"
"    USERS = ['jim', 'fred', 'sheila']\n"
"    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']\n"
"\n"
"    def filter(self, record):\n"
"\n"
"        record.ip = choice(ContextFilter.IPS)\n"
"        record.user = choice(ContextFilter.USERS)\n"
"        return True\n"
"\n"
"if __name__ == '__main__':\n"
"    levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, "
"logging.CRITICAL)\n"
"    logging.basicConfig(level=logging.DEBUG,\n"
"                        format='%(asctime)-15s %(name)-5s %(levelname)-8s "
"IP: %(ip)-15s User: %(user)-8s %(message)s')\n"
"    a1 = logging.getLogger('a.b.c')\n"
"    a2 = logging.getLogger('d.e.f')\n"
"\n"
"    f = ContextFilter()\n"
"    a1.addFilter(f)\n"
"    a2.addFilter(f)\n"
"    a1.debug('A debug message')\n"
"    a1.info('An info message with %s', 'some parameters')\n"
"    for x in range(10):\n"
"        lvl = choice(levels)\n"
"        lvlname = logging.getLevelName(lvl)\n"
"        a2.log(lvl, 'A message at %s level with %d %s', lvlname, 2, "
"'parameters')"
msgstr ""
"import logging\n"
"from random import choice\n"
"\n"
"class FiltroContexto(logging.Filter):\n"
"    \"\"\"\n"
"    Este é um filtro que injeta informações contextuais no registo.\n"
"\n"
"    Em vez de usar informações contextuais reais, usamos apenas dados "
"aleatórios\n"
"    nesta demonstração.\n"
"    \"\"\"\n"
"\n"
"    UTILIZADORES = ['joao', 'maria', 'ana']\n"
"    IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1']\n"
"\n"
"    def filter(self, record):\n"
"\n"
"        record.ip = choice(FiltroContexto.IPS)\n"
"        record.user = choice(FiltroContexto.UTILIZADORES)\n"
"        return True\n"
"\n"
"if __name__ == '__main__':\n"
"    niveis = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, "
"logging.CRITICAL)\n"
"    logging.basicConfig(level=logging.DEBUG,\n"
"                        format='%(asctime)-15s %(name)-5s %(levelname)-8s "
"IP: %(ip)-15s Utilizador: %(user)-8s %(message)s')\n"
"    a1 = logging.getLogger('a.b.c')\n"
"    a2 = logging.getLogger('d.e.f')\n"
"\n"
"    f = FiltroContexto()\n"
"    a1.addFilter(f)\n"
"    a2.addFilter(f)\n"
"    a1.debug('Uma mensagem de depuração')\n"
"    a1.info('Uma mensagem de informação com %s', 'alguns parâmetros')\n"
"    for x in range(10):\n"
"        lvl = choice(niveis)\n"
"        lvlname = logging.getLevelName(lvl)\n"
"        a2.log(lvl, 'Uma mensagem no nível %s com %d %s', lvlname, 2, "
"'parâmetros')"

#: ../../howto/logging-cookbook.rst:997
msgid "which, when run, produces something like:"
msgstr "que, quando executado, produz algo como:"

#: ../../howto/logging-cookbook.rst:999
msgid ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 User: fred     A "
"debug message\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     User: sheila   An "
"info message with some parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       User: jim      A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       User: sheila   A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 User: fred     A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     User: jim      A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       User: sheila   A "
"message at CRITICAL level with 2 parameters\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     User: jim      A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       User: sheila   A "
"message at ERROR level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 User: fred     A "
"message at DEBUG level with 2 parameters\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 User: fred     A "
"message at INFO level with 2 parameters"
msgstr ""
"2010-09-06 22:38:15,292 a.b.c DEBUG    IP: 123.231.231.123 Utilizador: "
"fred     Uma mensagem de depuração\n"
"2010-09-06 22:38:15,300 a.b.c INFO     IP: 192.168.0.1     Utilizador: "
"sheila   Uma mensagem de informação com alguns parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       Utilizador: "
"sheila   Uma mensagem no nível CRITICAL com 2 parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 127.0.0.1       Utilizador: "
"joao      Uma mensagem no nível ERROR com 2 parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 127.0.0.1       Utilizador: "
"sheila   Uma mensagem no nível DEBUG com 2 parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f ERROR    IP: 123.231.231.123 Utilizador: "
"fred     Uma mensagem no nível ERROR com 2 parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 192.168.0.1     Utilizador: "
"joao      Uma mensagem no nível CRITICAL com 2 parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f CRITICAL IP: 127.0.0.1       Utilizador: "
"sheila   Uma mensagem no nível CRITICAL com 2 parâmetros\n"
"2010-09-06 22:38:15,300 d.e.f DEBUG    IP: 192.168.0.1     Utilizador: "
"joao      Uma mensagem no nível DEBUG com 2 parâmetros\n"
"2010-09-06 22:38:15,301 d.e.f ERROR    IP: 127.0.0.1       Utilizador: "
"sheila   Uma mensagem no nível ERROR com 2 parâmetros\n"
"2010-09-06 22:38:15,301 d.e.f DEBUG    IP: 123.231.231.123 Utilizador: "
"fred     Uma mensagem no nível DEBUG com 2 parâmetros\n"
"2010-09-06 22:38:15,301 d.e.f INFO     IP: 123.231.231.123 Utilizador: "
"fred     Uma mensagem no nível INFO com 2 parâmetros"

#: ../../howto/logging-cookbook.rst:1015
msgid "Use of ``contextvars``"
msgstr "Uso de ``contextvars``"

#: ../../howto/logging-cookbook.rst:1017
msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-local "
"storage which works for both :mod:`threading` and :mod:`asyncio` processing "
"needs. This type of storage may thus be generally preferable to thread-"
"locals. The following example shows how, in a multi-threaded environment, "
"logs can populated with contextual information such as, for example, request "
"attributes handled by web applications."
msgstr ""
"Desde o Python 3.7, o módulo :mod:`contextvars` forneceu armazenamento local "
"de contexto que funciona tanto para necessidades de processamento :mod:"
"`threading` como :mod:`asyncio`. Este tipo de armazenamento pode, portanto, "
"ser geralmente preferível a thread-locals. O exemplo seguinte mostra como, "
"num ambiente multi-thread, os registos podem ser preenchidos com informações "
"contextuais, como, por exemplo, atributos de pedido tratados por aplicações "
"web."

#: ../../howto/logging-cookbook.rst:1023
msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same Python "
"process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the library "
"(and other request processing code) are directed to the appropriate "
"application's log file, while including in the log additional contextual "
"information such as client IP, HTTP request method and client username?"
msgstr ""
"Para fins de ilustração, suponha que tem diferentes aplicações web, cada uma "
"independente das outras, mas a executar no mesmo processo Python e a usar "
"uma biblioteca comum a todas. Como pode cada uma destas aplicações ter o seu "
"próprio registo, onde todas as mensagens de registo da biblioteca (e outro "
"código de processamento de pedidos) são direcionadas para o ficheiro de "
"registo apropriado da aplicação, ao mesmo tempo que inclui no registo "
"informações contextuais adicionais, como o IP do cliente, o método de pedido "
"HTTP e o nome de utilizador do cliente?"

#: ../../howto/logging-cookbook.rst:1030
msgid "Let's assume that the library can be simulated by the following code:"
msgstr "Vamos assumir que a biblioteca pode ser simulada pelo seguinte código:"

#: ../../howto/logging-cookbook.rst:1032
msgid ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def useful():\n"
"    # Just a representative event logged from the library\n"
"    logger.debug('Hello from webapplib!')\n"
"    # Just sleep for a bit so other threads get to run\n"
"    time.sleep(0.01)"
msgstr ""
"# webapplib.py\n"
"import logging\n"
"import time\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def util():\n"
"    # Apenas um evento representativo registado a partir da biblioteca\n"
"    logger.debug('Olá da webapplib!')\n"
"    # Apenas dormir um pouco para que outras threads possam executar\n"
"    time.sleep(0.01)"

#: ../../howto/logging-cookbook.rst:1046
msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web "
"applications work - each request is handled by a thread:"
msgstr ""
"Podemos simular as várias aplicações web por meio de duas classes simples, "
"``Request`` e ``WebApp``. Estas simulam como as aplicações web com threads "
"reais funcionam - cada pedido é tratado por uma thread:"

#: ../../howto/logging-cookbook.rst:1050
msgid ""
"# main.py\n"
"import argparse\n"
"from contextvars import ContextVar\n"
"import logging\n"
"import os\n"
"from random import choice\n"
"import threading\n"
"import webapplib\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.DEBUG)\n"
"\n"
"class Request:\n"
"    \"\"\"\n"
"    A simple dummy request class which just holds dummy HTTP request "
"method,\n"
"    client IP address and client username\n"
"    \"\"\"\n"
"    def __init__(self, method, ip, user):\n"
"        self.method = method\n"
"        self.ip = ip\n"
"        self.user = user\n"
"\n"
"# A dummy set of requests which will be used in the simulation - we'll just "
"pick\n"
"# from this list randomly. Note that all GET requests are from 192.168.2."
"XXX\n"
"# addresses, whereas POST requests are from 192.16.3.XXX addresses. Three "
"users\n"
"# are represented in the sample requests.\n"
"\n"
"REQUESTS = [\n"
"    Request('GET', '192.168.2.20', 'jim'),\n"
"    Request('POST', '192.168.3.20', 'fred'),\n"
"    Request('GET', '192.168.2.21', 'sheila'),\n"
"    Request('POST', '192.168.3.21', 'jim'),\n"
"    Request('GET', '192.168.2.22', 'fred'),\n"
"    Request('POST', '192.168.3.22', 'sheila'),\n"
"]\n"
"\n"
"# Note that the format string includes references to request context "
"information\n"
"# such as HTTP method, client IP and username\n"
"\n"
"formatter = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s "
"%(user)-6s %(ip)s %(method)-4s %(message)s')\n"
"\n"
"# Create our context variables. These will be filled at the start of "
"request\n"
"# processing, and used in the logging that happens during that processing\n"
"\n"
"ctx_request = ContextVar('request')\n"
"ctx_appname = ContextVar('appname')\n"
"\n"
"class InjectingFilter(logging.Filter):\n"
"    \"\"\"\n"
"    A filter which injects context-specific information into logs and "
"ensures\n"
"    that only information for a specific webapp is included in its log\n"
"    \"\"\"\n"
"    def __init__(self, app):\n"
"        self.app = app\n"
"\n"
"    def filter(self, record):\n"
"        request = ctx_request.get()\n"
"        record.method = request.method\n"
"        record.ip = request.ip\n"
"        record.user = request.user\n"
"        record.appName = appName = ctx_appname.get()\n"
"        return appName == self.app.name\n"
"\n"
"class WebApp:\n"
"    \"\"\"\n"
"    A dummy web application class which has its own handler and filter for "
"a\n"
"    webapp-specific log.\n"
"    \"\"\"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        handler = logging.FileHandler(name + '.log', 'w')\n"
"        f = InjectingFilter(self)\n"
"        handler.setFormatter(formatter)\n"
"        handler.addFilter(f)\n"
"        root.addHandler(handler)\n"
"        self.num_requests = 0\n"
"\n"
"    def process_request(self, request):\n"
"        \"\"\"\n"
"        This is the dummy method for processing a request. It's called on a\n"
"        different thread for every request. We store the context information "
"into\n"
"        the context vars before doing anything else.\n"
"        \"\"\"\n"
"        ctx_request.set(request)\n"
"        ctx_appname.set(self.name)\n"
"        self.num_requests += 1\n"
"        logger.debug('Request processing started')\n"
"        webapplib.useful()\n"
"        logger.debug('Request processing finished')\n"
"\n"
"def main():\n"
"    fn = os.path.splitext(os.path.basename(__file__))[0]\n"
"    adhf = argparse.ArgumentDefaultsHelpFormatter\n"
"    ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,\n"
"                                 description='Simulate a couple of web '\n"
"                                             'applications handling some '\n"
"                                             'requests, showing how request "
"'\n"
"                                             'context can be used to '\n"
"                                             'populate logs')\n"
"    aa = ap.add_argument\n"
"    aa('--count', '-c', type=int, default=100, help='How many requests to "
"simulate')\n"
"    options = ap.parse_args()\n"
"\n"
"    # Create the dummy webapps and put them in a list which we can use to "
"select\n"
"    # from randomly\n"
"    app1 = WebApp('app1')\n"
"    app2 = WebApp('app2')\n"
"    apps = [app1, app2]\n"
"    threads = []\n"
"    # Add a common handler which will capture all events\n"
"    handler = logging.FileHandler('app.log', 'w')\n"
"    handler.setFormatter(formatter)\n"
"    root.addHandler(handler)\n"
"\n"
"    # Generate calls to process requests\n"
"    for i in range(options.count):\n"
"        try:\n"
"            # Pick an app at random and a request for it to process\n"
"            app = choice(apps)\n"
"            request = choice(REQUESTS)\n"
"            # Process the request in its own thread\n"
"            t = threading.Thread(target=app.process_request, "
"args=(request,))\n"
"            threads.append(t)\n"
"            t.start()\n"
"        except KeyboardInterrupt:\n"
"            break\n"
"\n"
"    # Wait for the threads to terminate\n"
"    for t in threads:\n"
"        t.join()\n"
"\n"
"    for app in apps:\n"
"        print('%s processed %s requests' % (app.name, app.num_requests))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"# main.py\n"
"import argparse\n"
"from contextvars import ContextVar\n"
"import logging\n"
"import os\n"
"from random import choice\n"
"import threading\n"
"import webapplib\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.DEBUG)\n"
"\n"
"class Pedido:\n"
"    \"\"\"\n"
"    Uma classe simples de pedido fictício que contém apenas o método de "
"pedido HTTP fictício,\n"
"    endereço IP do cliente e nome de utilizador do cliente\n"
"    \"\"\"\n"
"    def __init__(self, metodo, ip, utilizador):\n"
"        self.metodo = metodo\n"
"        self.ip = ip\n"
"        self.utilizador = utilizador\n"
"\n"
"# Um conjunto fictício de pedidos que será usado na simulação - vamos apenas "
"escolher\n"
"# aleatoriamente desta lista. Note que todos os pedidos GET são de endereços "
"192.168.2.XXX\n"
"# enquanto os pedidos POST são de endereços 192.16.3.XXX. Três utilizadores\n"
"# estão representados nos pedidos de exemplo.\n"
"\n"
"PEDIDOS = [\n"
"    Pedido('GET', '192.168.2.20', 'joao'),\n"
"    Pedido('POST', '192.168.3.20', 'maria'),\n"
"    Pedido('GET', '192.168.2.21', 'ana'),\n"
"    Pedido('POST', '192.168.3.21', 'joao'),\n"
"    Pedido('GET', '192.168.2.22', 'maria'),\n"
"    Pedido('POST', '192.168.3.22', 'ana'),\n"
"]\n"
"\n"
"# Note que a string de formato inclui referências a informações de contexto "
"de pedido\n"
"# como método HTTP, IP do cliente e nome de utilizador\n"
"\n"
"formatador = logging.Formatter('%(threadName)-11s %(appName)s %(name)-9s "
"%(user)-6s %(ip)s %(method)-4s %(message)s')\n"
"\n"
"# Criar as nossas variáveis de contexto. Estas serão preenchidas no início "
"do processamento do pedido,\n"
"# e usadas no registo que ocorre durante esse processamento\n"
"\n"
"ctx_pedido = ContextVar('pedido')\n"
"ctx_nomeapp = ContextVar('nomeapp')\n"
"\n"
"class FiltroInjetor(logging.Filter):\n"
"    \"\"\"\n"
"    Um filtro que injeta informações específicas de contexto nos registos e "
"garante\n"
"    que apenas informações para uma aplicação web específica são incluídas "
"no seu registo\n"
"    \"\"\"\n"
"    def __init__(self, app):\n"
"        self.app = app\n"
"\n"
"    def filter(self, record):\n"
"        pedido = ctx_pedido.get()\n"
"        record.method = pedido.metodo\n"
"        record.ip = pedido.ip\n"
"        record.user = pedido.utilizador\n"
"        record.appName = nomeApp = ctx_nomeapp.get()\n"
"        return nomeApp == self.app.name\n"
"\n"
"class AplicacaoWeb:\n"
"    \"\"\"\n"
"    Uma classe de aplicação web fictícia que tem o seu próprio manipulador e "
"filtro para um\n"
"    registo específico da aplicação web.\n"
"    \"\"\"\n"
"    def __init__(self, nome):\n"
"        self.nome = nome\n"
"        manipulador = logging.FileHandler(nome + '.log', 'w')\n"
"        f = FiltroInjetor(self)\n"
"        manipulador.setFormatter(formatador)\n"
"        manipulador.addFilter(f)\n"
"        root.addHandler(manipulador)\n"
"        self.num_pedidos = 0\n"
"\n"
"    def processar_pedido(self, pedido):\n"
"        \"\"\"\n"
"        Este é o método fictício para processar um pedido. É chamado numa\n"
"        thread diferente para cada pedido. Armazenamos as informações de "
"contexto nas\n"
"        variáveis de contexto antes de fazer qualquer outra coisa.\n"
"        \"\"\"\n"
"        ctx_pedido.set(pedido)\n"
"        ctx_nomeapp.set(self.nome)\n"
"        self.num_pedidos += 1\n"
"        logger.debug('Processamento do pedido iniciado')\n"
"        webapplib.util()\n"
"        logger.debug('Processamento do pedido terminado')\n"
"\n"
"def main():\n"
"    fn = os.path.splitext(os.path.basename(__file__))[0]\n"
"    adhf = argparse.ArgumentDefaultsHelpFormatter\n"
"    ap = argparse.ArgumentParser(formatter_class=adhf, prog=fn,\n"
"                                 description='Simular algumas aplicações web "
"'\n"
"                                             'a tratar de alguns pedidos, "
"mostrando como o contexto '\n"
"                                             'do pedido pode ser usado para "
"'\n"
"                                             'preencher registos')\n"
"    aa = ap.add_argument\n"
"    aa('--count', '-c', type=int, default=100, help='Quantos pedidos "
"simular')\n"
"    options = ap.parse_args()\n"
"\n"
"    # Criar as aplicações web fictícias e colocá-las numa lista da qual "
"podemos selecionar\n"
"    # aleatoriamente\n"
"    app1 = AplicacaoWeb('app1')\n"
"    app2 = AplicacaoWeb('app2')\n"
"    apps = [app1, app2]\n"
"    threads = []\n"
"    # Adicionar um manipulador comum que irá capturar todos os eventos\n"
"    manipulador = logging.FileHandler('app.log', 'w')\n"
"    manipulador.setFormatter(formatador)\n"
"    root.addHandler(manipulador)\n"
"\n"
"    # Gerar chamadas para processar pedidos\n"
"    for i in range(options.count):\n"
"        try:\n"
"            # Escolher uma aplicação aleatoriamente e um pedido para "
"processar\n"
"            app = choice(apps)\n"
"            pedido = choice(PEDIDOS)\n"
"            # Processar o pedido na sua própria thread\n"
"            t = threading.Thread(target=app.processar_pedido, "
"args=(pedido,))\n"
"            threads.append(t)\n"
"            t.start()\n"
"        except KeyboardInterrupt:\n"
"            break\n"
"\n"
"    # Esperar que as threads terminem\n"
"    for t in threads:\n"
"        t.join()\n"
"\n"
"    for app in apps:\n"
"        print('%s processou %s pedidos' % (app.nome, app.num_pedidos))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:1190
msgid ""
"If you run the above, you should find that roughly half the requests go "
"into :file:`app1.log` and the rest into :file:`app2.log`, and the all the "
"requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request information "
"will be displayed consistently in the log (i.e. the information in each "
"dummy request will always appear together in a log line). This is "
"illustrated by the following shell output:"
msgstr ""
"Se executar o acima, deve verificar que aproximadamente metade dos pedidos "
"vão para :file:`app1.log` e o resto para :file:`app2.log`, e todos os "
"pedidos são registados em :file:`app.log`. Cada registo específico da "
"aplicação web conterá apenas entradas de registo para essa aplicação web, e "
"as informações do pedido serão exibidas de forma consistente no registo (ou "
"seja, as informações em cada pedido fictício aparecerão sempre juntas numa "
"linha de registo). Isto é ilustrado pela seguinte saída de shell:"

#: ../../howto/logging-cookbook.rst:1197
msgid ""
"~/logging-contextual-webapp$ python main.py\n"
"app1 processed 51 requests\n"
"app2 processed 49 requests\n"
"~/logging-contextual-webapp$ wc -l *.log\n"
"  153 app1.log\n"
"  147 app2.log\n"
"  300 app.log\n"
"  600 total\n"
"~/logging-contextual-webapp$ head -3 app1.log\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"~/logging-contextual-webapp$ head -3 app2.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request "
"processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request "
"processing started\n"
"~/logging-contextual-webapp$ head app.log\n"
"Thread-1 (process_request) app2 __main__  sheila 192.168.2.21 GET  Request "
"processing started\n"
"Thread-1 (process_request) app2 webapplib sheila 192.168.2.21 GET  Hello "
"from webapplib!\n"
"Thread-2 (process_request) app2 __main__  jim    192.168.2.20 GET  Request "
"processing started\n"
"Thread-3 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-2 (process_request) app2 webapplib jim    192.168.2.20 GET  Hello "
"from webapplib!\n"
"Thread-3 (process_request) app1 webapplib jim    192.168.3.21 POST Hello "
"from webapplib!\n"
"Thread-4 (process_request) app2 __main__  fred   192.168.2.22 GET  Request "
"processing started\n"
"Thread-5 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"Thread-4 (process_request) app2 webapplib fred   192.168.2.22 GET  Hello "
"from webapplib!\n"
"Thread-6 (process_request) app1 __main__  jim    192.168.3.21 POST Request "
"processing started\n"
"~/logging-contextual-webapp$ grep app1 app1.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app2.log | wc -l\n"
"147\n"
"~/logging-contextual-webapp$ grep app1 app.log | wc -l\n"
"153\n"
"~/logging-contextual-webapp$ grep app2 app.log | wc -l\n"
"147"
msgstr ""

#: ../../howto/logging-cookbook.rst:1237
msgid "Imparting contextual information in handlers"
msgstr "Transmitir informações contextuais em manipuladores"

#: ../../howto/logging-cookbook.rst:1239
msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to other "
"handlers, you can use a filter that returns a new :class:`~LogRecord` "
"instead of modifying it in-place, as shown in the following script::"
msgstr ""
"Cada :class:`~Handler` tem a sua própria cadeia de filtros. Se quiser "
"adicionar informações contextuais a um :class:`LogRecord` sem as vazar para "
"outros manipuladores, pode usar um filtro que devolve um novo :class:"
"`~LogRecord` em vez de o modificar no local, como mostrado no seguinte "
"script::"

#: ../../howto/logging-cookbook.rst:1244
msgid ""
"import copy\n"
"import logging\n"
"\n"
"def filter(record: logging.LogRecord):\n"
"    record = copy.copy(record)\n"
"    record.user = 'jim'\n"
"    return record\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    handler = logging.StreamHandler()\n"
"    formatter = logging.Formatter('%(message)s from %(user)-8s')\n"
"    handler.setFormatter(formatter)\n"
"    handler.addFilter(filter)\n"
"    logger.addHandler(handler)\n"
"\n"
"    logger.info('A log message')"
msgstr ""
"import copy\n"
"import logging\n"
"\n"
"def filtro(registro: logging.LogRecord):\n"
"    registro = copy.copy(registro)\n"
"    registro.user = 'joao'\n"
"    return registro\n"
"\n"
"if __name__ == '__main__':\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.INFO)\n"
"    manipulador = logging.StreamHandler()\n"
"    formatador = logging.Formatter('%(message)s de %(user)-8s')\n"
"    manipulador.setFormatter(formatador)\n"
"    manipulador.addFilter(filtro)\n"
"    logger.addHandler(manipulador)\n"
"\n"
"    logger.info('Uma mensagem de registo')"

#: ../../howto/logging-cookbook.rst:1266
msgid "Logging to a single file from multiple processes"
msgstr "Registo num único ficheiro a partir de vários processos"

#: ../../howto/logging-cookbook.rst:1268
msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to "
"serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`, "
"and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) :ref:"
"`This section <network-logging>` documents this approach in more detail and "
"includes a working socket receiver which can be used as a starting point for "
"you to adapt in your own applications."
msgstr ""
"Embora o registo seja seguro para threads, e o registo num único ficheiro a "
"partir de várias threads num único processo *seja* suportado, o registo num "
"único ficheiro a partir de *vários processos* *não* é suportado, porque não "
"há uma forma padrão de serializar o acesso a um único ficheiro entre vários "
"processos em Python. Se precisar de registar num único ficheiro a partir de "
"vários processos, uma forma de fazer isto é fazer com que todos os processos "
"registem num :class:`~handlers.SocketHandler`, e ter um processo separado "
"que implementa um servidor de socket que lê do socket e regista no ficheiro. "
"(Se preferir, pode dedicar uma thread num dos processos existentes para "
"realizar esta função.) :ref:`Esta secção <network-logging>` documenta esta "
"abordagem com mais detalhe e inclui um recetor de socket funcional que pode "
"ser usado como ponto de partida para adaptar nas suas próprias aplicações."

#: ../../howto/logging-cookbook.rst:1281
msgid ""
"You could also write your own handler which uses the :class:"
"`~multiprocessing.Lock` class from the :mod:`multiprocessing` module to "
"serialize access to the file from your processes. The stdlib :class:"
"`FileHandler` and subclasses do not make use of :mod:`multiprocessing`."
msgstr ""
"Também poderia escrever o seu próprio manipulador que usa a classe :class:"
"`~multiprocessing.Lock` do módulo :mod:`multiprocessing` para serializar o "
"acesso ao ficheiro a partir dos seus processos. O manipulador :class:"
"`FileHandler` da biblioteca padrão e as suas subclasses não usam :mod:"
"`multiprocessing`."

#: ../../howto/logging-cookbook.rst:1288
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although "
"the example only demonstrates one way of doing it (for example, you may want "
"to use a listener thread rather than a separate listener process -- the "
"implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific "
"requirements::"
msgstr ""
"Alternativamente, pode usar uma ``Queue`` e um :class:`QueueHandler` para "
"enviar todos os eventos de registo para um dos processos na sua aplicação "
"multi-processo. O seguinte script de exemplo demonstra como pode fazer isto; "
"no exemplo, um processo ouvinte separado escuta eventos enviados por outros "
"processos e os regista de acordo com a sua própria configuração de registo. "
"Embora o exemplo demonstre apenas uma forma de fazer isto (por exemplo, pode "
"querer usar uma thread ouvinte em vez de um processo ouvinte separado -- a "
"implementação seria análoga), permite configurações de registo completamente "
"diferentes para o ouvinte e os outros processos na sua aplicação, e pode ser "
"usado como base para código que atenda aos seus requisitos específicos::"

#: ../../howto/logging-cookbook.rst:1299
msgid ""
"# You'll need these imports in your own code\n"
"import logging\n"
"import logging.handlers\n"
"import multiprocessing\n"
"\n"
"# Next two import lines for this demo only\n"
"from random import choice, random\n"
"import time\n"
"\n"
"#\n"
"# Because you'll want to define the logging configurations for listener and "
"workers, the\n"
"# listener and worker process functions take a configurer parameter which is "
"a callable\n"
"# for configuring logging for that process. These functions are also passed "
"the queue,\n"
"# which they use for communication.\n"
"#\n"
"# In practice, you can configure the listener however you want, but note "
"that in this\n"
"# simple example, the listener does not apply level or filter logic to "
"received records.\n"
"# In practice, you would probably want to do this logic in the worker "
"processes, to avoid\n"
"# sending events which would be filtered out between processes.\n"
"#\n"
"# The size of the rotated files is made small so you can see the results "
"easily.\n"
"def listener_configurer():\n"
"    root = logging.getLogger()\n"
"    h = logging.handlers.RotatingFileHandler('mptest.log', 'a', 300, 10)\n"
"    f = logging.Formatter('%(asctime)s %(processName)-10s %(name)s "
"%(levelname)-8s %(message)s')\n"
"    h.setFormatter(f)\n"
"    root.addHandler(h)\n"
"\n"
"# This is the listener process top-level loop: wait for logging events\n"
"# (LogRecords)on the queue and handle them, quit when you get a None for a\n"
"# LogRecord.\n"
"def listener_process(queue, configurer):\n"
"    configurer()\n"
"    while True:\n"
"        try:\n"
"            record = queue.get()\n"
"            if record is None:  # We send this as a sentinel to tell the "
"listener to quit.\n"
"                break\n"
"            logger = logging.getLogger(record.name)\n"
"            logger.handle(record)  # No level or filter logic applied - just "
"do it!\n"
"        except Exception:\n"
"            import sys, traceback\n"
"            print('Whoops! Problem:', file=sys.stderr)\n"
"            traceback.print_exc(file=sys.stderr)\n"
"\n"
"# Arrays used for random selections in this demo\n"
"\n"
"LEVELS = [logging.DEBUG, logging.INFO, logging.WARNING,\n"
"          logging.ERROR, logging.CRITICAL]\n"
"\n"
"LOGGERS = ['a.b.c', 'd.e.f']\n"
"\n"
"MESSAGES = [\n"
"    'Random message #1',\n"
"    'Random message #2',\n"
"    'Random message #3',\n"
"]\n"
"\n"
"# The worker configuration is done at the start of the worker process run.\n"
"# Note that on Windows you can't rely on fork semantics, so each process\n"
"# will run the logging configuration code when it starts.\n"
"def worker_configurer(queue):\n"
"    h = logging.handlers.QueueHandler(queue)  # Just the one handler needed\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # send all messages, for demo; no other level or filter logic applied.\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"# This is the worker process top-level loop, which just logs ten events "
"with\n"
"# random intervening delays before terminating.\n"
"# The print messages are just so you know it's doing something!\n"
"def worker_process(queue, configurer):\n"
"    configurer(queue)\n"
"    name = multiprocessing.current_process().name\n"
"    print('Worker started: %s' % name)\n"
"    for i in range(10):\n"
"        time.sleep(random())\n"
"        logger = logging.getLogger(choice(LOGGERS))\n"
"        level = choice(LEVELS)\n"
"        message = choice(MESSAGES)\n"
"        logger.log(level, message)\n"
"    print('Worker finished: %s' % name)\n"
"\n"
"# Here's where the demo gets orchestrated. Create the queue, create and "
"start\n"
"# the listener, create ten workers and start them, wait for them to finish,\n"
"# then send a None to the queue to tell the listener to finish.\n"
"def main():\n"
"    queue = multiprocessing.Queue(-1)\n"
"    listener = multiprocessing.Process(target=listener_process,\n"
"                                       args=(queue, listener_configurer))\n"
"    listener.start()\n"
"    workers = []\n"
"    for i in range(10):\n"
"        worker = multiprocessing.Process(target=worker_process,\n"
"                                         args=(queue, worker_configurer))\n"
"        workers.append(worker)\n"
"        worker.start()\n"
"    for w in workers:\n"
"        w.join()\n"
"    queue.put_nowait(None)\n"
"    listener.join()\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1404
msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr ""
"Uma variante do script acima mantém o logging no processo principal, num fio "
"de execução (*thread*) separado::"

#: ../../howto/logging-cookbook.rst:1407
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue\n"
"import random\n"
"import threading\n"
"import time\n"
"\n"
"def logger_thread(q):\n"
"    while True:\n"
"        record = q.get()\n"
"        if record is None:\n"
"            break\n"
"        logger = logging.getLogger(record.name)\n"
"        logger.handle(record)\n"
"\n"
"\n"
"def worker_process(q):\n"
"    qh = logging.handlers.QueueHandler(q)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(qh)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    d = {\n"
"        'version': 1,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO',\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'level': 'ERROR',\n"
"                'formatter': 'detailed',\n"
"            },\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'level': 'DEBUG',\n"
"            'handlers': ['console', 'file', 'errors']\n"
"        },\n"
"    }\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1), "
"args=(q,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"    logging.config.dictConfig(d)\n"
"    lp = threading.Thread(target=logger_thread, args=(q,))\n"
"    lp.start()\n"
"    # At this point, the main process could do some useful work of its own\n"
"    # Once it's done that, it can wait for the workers to terminate...\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # And now tell the logging thread to finish up, too\n"
"    q.put(None)\n"
"    lp.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1499
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"Esta variante mostra como pode, por exemplo, aplicar configurações para "
"registadores (*loggers*) específicos — por exemplo,o registador ``foo`` tem "
"um manipulador especial que armazena todos os eventos no subsistema ``foo`` "
"num ficheiro``mplog-foo.log``. Isto será usado pela maquinaria de logging no "
"processo principal (mesmo que os eventos de loggingsejam gerados nos "
"processos dos trabalhadores) para direcionar as mensagens para os destinos "
"apropriados."

#: ../../howto/logging-cookbook.rst:1506
msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "A utilizar concurrent.futures.ProcessPoolExecutor"

#: ../../howto/logging-cookbook.rst:1508
msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"Se pretender utilizar :class:`concurrent.futures.ProcessPoolExecutor` para "
"iniciaros seus processos de trabalhadores, precisa de criar a fila de forma "
"ligeiramente diferente. Em vez de"

#: ../../howto/logging-cookbook.rst:1512
msgid "queue = multiprocessing.Queue(-1)"
msgstr "queue = multiprocessing.Queue(-1)"

#: ../../howto/logging-cookbook.rst:1516
msgid "you should use"
msgstr "deve utilizar"

#: ../../howto/logging-cookbook.rst:1518
msgid ""
"queue = multiprocessing.Manager().Queue(-1)  # also works with the examples "
"above"
msgstr ""

#: ../../howto/logging-cookbook.rst:1522
msgid "and you can then replace the worker creation from this::"
msgstr "e pode então substituir a criação de trabalhadores de"

#: ../../howto/logging-cookbook.rst:1524
msgid ""
"workers = []\n"
"for i in range(10):\n"
"    worker = multiprocessing.Process(target=worker_process,\n"
"                                     args=(queue, worker_configurer))\n"
"    workers.append(worker)\n"
"    worker.start()\n"
"for w in workers:\n"
"    w.join()"
msgstr ""

#: ../../howto/logging-cookbook.rst:1533
msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr ""
"para isto (lembrando-se de importar primeiro :mod:`concurrent.futures`)::"

#: ../../howto/logging-cookbook.rst:1535
msgid ""
"with concurrent.futures.ProcessPoolExecutor(max_workers=10) as executor:\n"
"    for i in range(10):\n"
"        executor.submit(worker_process, queue, worker_configurer)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1540
msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr "Implementação de aplicações Web utilizando Gunicorn e uWSGI"

#: ../../howto/logging-cookbook.rst:1542
msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_ or "
"`uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar), "
"multiple worker processes are created to handle client requests. In such "
"environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using a "
"process management tool such as Supervisor - see `Running a logging socket "
"listener in production`_ for more details."
msgstr ""
"Ao implementar aplicações Web utilizando `Gunicorn <https://gunicorn.org/>`_ "
"ou`uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (ou similares),"
"múltiplos processos de trabalhadores são criados para lidar com pedidos de "
"clientes. Nestes ambientes,evite criar manipuladores baseados em ficheiros "
"diretamente na sua aplicação Web. Em vez disso,utilize um :class:"
"`SocketHandler` para registar a partir da aplicação Web para um ouvinte num "
"processo separado.Isto pode ser configurado utilizando uma ferramenta de "
"gestão de processos como o Supervisor — consulte`Running a logging socket "
"listener in production`_ para mais detalhes."

#: ../../howto/logging-cookbook.rst:1552
msgid "Using file rotation"
msgstr "Utilização de rotação de ficheiros"

#: ../../howto/logging-cookbook.rst:1557
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new "
"file and log to that. You may want to keep a certain number of these files, "
"and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`RotatingFileHandler`::"
msgstr ""
"Às vezes, pretende deixar um ficheiro de registo crescer até um certo "
"tamanho, depois abrir um novoficheiro e registar para esse. Pode querer "
"manter um certo número destes ficheiros,e quando esse número de ficheiros "
"for criado, rodar os ficheiros de forma a que onúmero de ficheiros e o "
"tamanho dos ficheiros permaneçam limitados. Para estepadrão de utilização, o "
"pacote de logging fornece um :class:`RotatingFileHandler`::"

#: ../../howto/logging-cookbook.rst:1563
msgid ""
"import glob\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"LOG_FILENAME = 'logging_rotatingfile_example.out'\n"
"\n"
"# Set up a specific logger with our desired output level\n"
"my_logger = logging.getLogger('MyLogger')\n"
"my_logger.setLevel(logging.DEBUG)\n"
"\n"
"# Add the log message handler to the logger\n"
"handler = logging.handlers.RotatingFileHandler(\n"
"              LOG_FILENAME, maxBytes=20, backupCount=5)\n"
"\n"
"my_logger.addHandler(handler)\n"
"\n"
"# Log some messages\n"
"for i in range(20):\n"
"    my_logger.debug('i = %d' % i)\n"
"\n"
"# See what files are created\n"
"logfiles = glob.glob('%s*' % LOG_FILENAME)\n"
"\n"
"for filename in logfiles:\n"
"    print(filename)"
msgstr ""

#: ../../howto/logging-cookbook.rst:1589
msgid ""
"The result should be 6 separate files, each with part of the log history for "
"the application:"
msgstr ""
"O resultado deve ser 6 ficheiros separados, cada um com parte do histórico "
"de registo da aplicação:"

#: ../../howto/logging-cookbook.rst:1592
msgid ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"
msgstr ""
"logging_rotatingfile_example.out\n"
"logging_rotatingfile_example.out.1\n"
"logging_rotatingfile_example.out.2\n"
"logging_rotatingfile_example.out.3\n"
"logging_rotatingfile_example.out.4\n"
"logging_rotatingfile_example.out.5"

#: ../../howto/logging-cookbook.rst:1601
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix "
"(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""

#: ../../howto/logging-cookbook.rst:1606
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr ""

#: ../../howto/logging-cookbook.rst:1614
msgid "Use of alternative formatting styles"
msgstr "Utilização de estilos de formatação alternativos"

#: ../../howto/logging-cookbook.rst:1616
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: :class:"
"`string.Template` (added in Python 2.4) and :meth:`str.format` (added in "
"Python 2.6)."
msgstr ""
"Quando o logging foi adicionado à biblioteca padrão do Python, a única forma "
"deformatar mensagens com conteúdo variável era utilizando o método de "
"formatação %-formatting.Desde então, o Python ganhou duas novas abordagens "
"de formatação: :class:`string.Template`(adicionado no Python 2.4) e :meth:"
"`str.format` (adicionado no Python 2.6)."

#: ../../howto/logging-cookbook.rst:1622
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond "
"to the other two formatting styles. Backwards compatibility is maintained by "
"default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with :"
"meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""

#: ../../howto/logging-cookbook.rst:1632
msgid ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}',\n"
"...                        style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message',\n"
"...                        style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"
msgstr ""
">>> import logging\n"
">>> root = logging.getLogger()\n"
">>> root.setLevel(logging.DEBUG)\n"
">>> handler = logging.StreamHandler()\n"
">>> bf = logging.Formatter('{asctime} {name} {levelname:8s} {message}', "
"style='{')\n"
">>> handler.setFormatter(bf)\n"
">>> root.addHandler(handler)\n"
">>> logger = logging.getLogger('foo.bar')\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:11:55,341 foo.bar DEBUG    This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:12:11,526 foo.bar CRITICAL This is a CRITICAL message\n"
">>> df = logging.Formatter('$asctime $name ${levelname} $message', "
"style='$')\n"
">>> handler.setFormatter(df)\n"
">>> logger.debug('This is a DEBUG message')\n"
"2010-10-28 15:13:06,924 foo.bar DEBUG This is a DEBUG message\n"
">>> logger.critical('This is a CRITICAL message')\n"
"2010-10-28 15:13:11,494 foo.bar CRITICAL This is a CRITICAL message\n"
">>>"

#: ../../howto/logging-cookbook.rst:1656
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr ""
"Note que a formatação das mensagens de registo para a saída final nos "
"registos é completamente independente da forma como uma mensagem de registo "
"individual é construída. Ainda pode ser utilizada a formatação com %-f, como "
"mostrado aqui:"

#: ../../howto/logging-cookbook.rst:1660
msgid ""
">>> logger.error('This is an%s %s %s', 'other,', 'ERROR,', 'message')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR This is another, ERROR, message\n"
">>>"
msgstr ""
">>> logger.error('Esta é uma%s %s %s', 'outra,', 'ERRO,', 'mensagem')\n"
"2010-10-28 15:19:29,833 foo.bar ERROR Esta é outra, ERRO, mensagem\n"
">>>"

#: ../../howto/logging-cookbook.rst:1664
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or :class:"
"`string.Template` syntax, because internally the logging package uses %-"
"formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"As chamadas de registo (``logger.debug()``, ``logger.info()``, etc.) apenas "
"aceitam parâmetros posicionais para a mensagem de registo em si, com "
"parâmetros nomeados usados apenas para determinar opções sobre como lidar "
"com a chamada de registo (por exemplo, o parâmetro nomeado ``exc_info`` para "
"indicar que a informação de traceback deve ser registada, ou o parâmetro "
"nomeado ``extra`` para indicar informações contextuais adicionais a serem "
"adicionadas ao registo). Portanto, não é possível fazer chamadas de registo "
"diretamente utilizando a sintaxe :meth:`str.format` ou :class:`string."
"Template`, porque internamente o pacote de registo utiliza formatação com %-"
"f para fundir a string de formatação e os argumentos variáveis. Não seria "
"possível alterar isto mantendo a compatibilidade retroativa, uma vez que "
"todas as chamadas de registo existentes no código utilizam strings de "
"formatação com %-f."

#: ../../howto/logging-cookbook.rst:1677
msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct "
"your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider "
"the following two classes::"
msgstr ""
"No entanto, existe uma forma de utilizar a formatação com {}- e $- para "
"construir as suas mensagens de registo individuais. Lembre-se que para uma "
"mensagem pode utilizar um objeto arbitrário como uma string de formatação de "
"mensagem, e que o pacote de registo chamará ``str()`` nesse objeto para "
"obter a string de formatação real. Considere as duas classes seguintes:"

#: ../../howto/logging-cookbook.rst:1683 ../../howto/logging-cookbook.rst:2771
msgid ""
"class BraceMessage:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class DollarMessage:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"
msgstr ""
"class MensagemChavetas:\n"
"    def __init__(self, fmt, /, *args, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args, **self.kwargs)\n"
"\n"
"class MensagemDolar:\n"
"    def __init__(self, fmt, /, **kwargs):\n"
"        self.fmt = fmt\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        from string import Template\n"
"        return Template(self.fmt).substitute(**self.kwargs)"

#: ../../howto/logging-cookbook.rst:1701
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"Qualquer uma destas classes pode ser usada no lugar de uma string de "
"formatação, para permitir a utilização de formatação com $- ou {}- para "
"construir a parte \"mensagem\" que aparece na saída de registo formatada, no "
"lugar de \"%(message)s\", \"{message}\" ou \"$message\". Pode ser um pouco "
"incómodo utilizar os nomes das classes sempre que quiser registar algo, mas "
"torna-se bastante aceitável se utilizar um alias como __ (duplo underscore — "
"não confundir com _, o underscore simples usado como sinónimo/alias para :"
"func:`gettext.gettext` ou funções similares)."

#: ../../howto/logging-cookbook.rst:1709
msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr ""
"As classes acima não estão incluídas no Python, embora sejam fáceis de "
"copiar e colar no seu próprio código. Podem ser usadas da seguinte forma "
"(assumindo que estão declaradas num módulo chamado ``wherever``):"

#: ../../howto/logging-cookbook.rst:1713
msgid ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Message with {0} {name}', 2, name='placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Message with coordinates: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""
">>> from wherever import BraceMessage as __\n"
">>> print(__('Mensagem com {0} {name}', 2, name='placeholders'))\n"
"Mensagem com 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Mensagem com coordenadas: ({point.x:.2f}, {point.y:.2f})',\n"
"...       point=p))\n"
"Mensagem com coordenadas: (0.50, 0.50)\n"
">>> from wherever import DollarMessage as __\n"
">>> print(__('Mensagem com $num $what', num=2, what='placeholders'))\n"
"Mensagem com 2 placeholders\n"
">>>"

#: ../../howto/logging-cookbook.rst:1731
msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"Embora os exemplos acima utilizem ``print()`` para mostrar como funciona a "
"formatação, utilizaria, claro, ``logger.debug()`` ou similar para registar "
"efetivamente utilizando esta abordagem."

#: ../../howto/logging-cookbook.rst:1735
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes."
msgstr ""
"Uma coisa a notar é que não há penalização significativa de desempenho com "
"esta abordagem: a formatação real não acontece quando faz a chamada de "
"registo, mas sim quando (e se) a mensagem registada estiver prestes a ser "
"enviada para um registo por um manipulador. Portanto, a única coisa "
"ligeiramente invulgar que pode confundir é que os parênteses envolvem a "
"string de formatação e os argumentos, não apenas a string de formatação. "
"Isto acontece porque a notação __ é apenas açúcar sintático para uma chamada "
"de construtor para uma das classes :samp:`{XXX}Message`."

#: ../../howto/logging-cookbook.rst:1743
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr ""
"Se preferir, pode utilizar um :class:`LoggerAdapter` para alcançar um efeito "
"semelhante ao acima, como no seguinte exemplo:"

#: ../../howto/logging-cookbook.rst:1746
msgid ""
"import logging\n"
"\n"
"class Message:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class StyleAdapter(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Message(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = StyleAdapter(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Hello, {}', 'world!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"class Mensagem:\n"
"    def __init__(self, fmt, args):\n"
"        self.fmt = fmt\n"
"        self.args = args\n"
"\n"
"    def __str__(self):\n"
"        return self.fmt.format(*self.args)\n"
"\n"
"class AdaptadorEstilo(logging.LoggerAdapter):\n"
"    def log(self, level, msg, /, *args, stacklevel=1, **kwargs):\n"
"        if self.isEnabledFor(level):\n"
"            msg, kwargs = self.process(msg, kwargs)\n"
"            self.logger.log(level, Mensagem(msg, args), **kwargs,\n"
"                            stacklevel=stacklevel+1)\n"
"\n"
"logger = AdaptadorEstilo(logging.getLogger(__name__))\n"
"\n"
"def main():\n"
"    logger.debug('Olá, {}', 'mundo!')\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    main()"

#: ../../howto/logging-cookbook.rst:1772
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.8 or later."
msgstr ""
"O script acima deve registar a mensagem ``Hello, world!`` quando executado "
"com Python 3.8 ou posterior."

#: ../../howto/logging-cookbook.rst:1781
msgid "Customizing ``LogRecord``"
msgstr "Personalizar ``LogRecord``"

#: ../../howto/logging-cookbook.rst:1783
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an "
"event is logged and not filtered out by a logger's level, a :class:"
"`LogRecord` is created, populated with information about the event and then "
"passed to the handlers for that logger (and its ancestors, up to and "
"including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation "
"was done:"
msgstr ""
"Cada evento de registo é representado por uma instância de :class:"
"`LogRecord`. Quando um evento é registado e não é filtrado pelo nível do "
"registador, um :class:`LogRecord` é criado, preenchido com informações sobre "
"o evento e depois passado aos manipuladores desse registador (e dos seus "
"antecessores, até e incluindo o registador onde a propagação adicional na "
"hierarquia é desativada). Antes do Python 3.2, havia apenas dois locais onde "
"esta criação era feita:"

#: ../../howto/logging-cookbook.rst:1790
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`, que é chamado no processo normal de registo de um "
"evento. Isto invocava diretamente :class:`LogRecord` para criar uma "
"instância."

#: ../../howto/logging-cookbook.rst:1793
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an :class:"
"`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`, que é chamado com um dicionário contendo atributos a "
"serem adicionados ao LogRecord. Isto é tipicamente invocado quando um "
"dicionário adequado é recebido através da rede (por exemplo, em formato "
"pickle através de um :class:`~handlers.SocketHandler`, ou em formato JSON "
"através de um :class:`~handlers.HTTPHandler`)."

#: ../../howto/logging-cookbook.rst:1799
msgid ""
"This has usually meant that if you need to do anything special with a :class:"
"`LogRecord`, you've had to do one of the following."
msgstr ""
"Isto geralmente significava que, se precisasse de fazer algo especial com "
"um :class:`LogRecord`, teria de fazer uma das seguintes ações:"

#: ../../howto/logging-cookbook.rst:1802
msgid ""
"Create your own :class:`Logger` subclass, which overrides :meth:`Logger."
"makeRecord`, and set it using :func:`~logging.setLoggerClass` before any "
"loggers that you care about are instantiated."
msgstr ""
"Criar a sua própria subclasse de :class:`Logger`, que substitui :meth:"
"`Logger.makeRecord`, e defini-la utilizando :func:`~logging.setLoggerClass` "
"antes de quaisquer registadores que lhe interessem serem instanciados."

#: ../../howto/logging-cookbook.rst:1805
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"Adicionar um :class:`Filter` a um registador ou manipulador, que faz a "
"manipulação especial necessária quando o seu método :meth:`~Filter.filter` é "
"chamado."

#: ../../howto/logging-cookbook.rst:1809
msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"A primeira abordagem seria um pouco incómoda num cenário em que (por "
"exemplo) várias bibliotecas diferentes quisessem fazer coisas diferentes. "
"Cada uma tentaria definir a sua própria subclasse de :class:`Logger`, e a "
"que fizesse isto por último ganharia."

#: ../../howto/logging-cookbook.rst:1814
msgid ""
"The second approach works reasonably well for many cases, but does not allow "
"you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"A segunda abordagem funciona razoavelmente bem para muitos casos, mas não "
"permite, por exemplo, utilizar uma subclasse especializada de :class:"
"`LogRecord`. Os desenvolvedores de bibliotecas podem definir um filtro "
"adequado nos seus registadores, mas teriam de se lembrar de fazer isto "
"sempre que introduzissem um novo registador (o que fariam simplesmente "
"adicionando novos pacotes ou módulos e fazendo:"

#: ../../howto/logging-cookbook.rst:1820
msgid "logger = logging.getLogger(__name__)"
msgstr "logger = logging.getLogger(__name__)"

#: ../../howto/logging-cookbook.rst:1822
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger --- "
"so output from that handler would not reflect the intentions of the library "
"developer."
msgstr ""
"ao nível do módulo). Provavelmente é mais uma coisa para pensar. Os "
"desenvolvedores também poderiam adicionar o filtro a um :class:`~logging."
"NullHandler` anexado ao seu registador de nível superior, mas isto não seria "
"invocado se um desenvolvedor de aplicação anexasse um manipulador a um "
"registador de biblioteca de nível inferior — assim, a saída desse "
"manipulador não refletiria as intenções do desenvolvedor da biblioteca."

#: ../../howto/logging-cookbook.rst:1828
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you "
"can set with :func:`~logging.setLogRecordFactory`, and interrogate with :"
"func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as :class:"
"`LogRecord` is the default setting for the factory."
msgstr ""
"No Python 3.2 e posteriores, a criação de :class:`~logging.LogRecord` é "
"feita através de uma fábrica, que pode especificar. A fábrica é apenas um "
"objeto chamável que pode definir com :func:`~logging.setLogRecordFactory` e "
"interrogar com :func:`~logging.getLogRecordFactory`. A fábrica é invocada "
"com a mesma assinatura do construtor :class:`~logging.LogRecord`, uma vez "
"que :class:`LogRecord` é a configuração predefinida para a fábrica."

#: ../../howto/logging-cookbook.rst:1835
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to "
"this::"
msgstr ""
"Esta abordagem permite que uma fábrica personalizada controle todos os "
"aspetos da criação de LogRecord. Por exemplo, pode retornar uma subclasse ou "
"simplesmente adicionar alguns atributos adicionais ao registo após a sua "
"criação, utilizando um padrão semelhante a este:"

#: ../../howto/logging-cookbook.rst:1839
msgid ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.custom_attribute = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"
msgstr ""
"old_factory = logging.getLogRecordFactory()\n"
"\n"
"def record_factory(*args, **kwargs):\n"
"    record = old_factory(*args, **kwargs)\n"
"    record.atributo_personalizado = 0xdecafbad\n"
"    return record\n"
"\n"
"logging.setLogRecordFactory(record_factory)"

#: ../../howto/logging-cookbook.rst:1848
msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises. "
"However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"Este padrão permite que diferentes bibliotecas encadeiem fábricas, e desde "
"que não substituam os atributos umas das outras ou substituam acidentalmente "
"os atributos fornecidos como padrão, não deve haver surpresas. No entanto, "
"deve ter-se em mente que cada elo na cadeia adiciona sobrecarga de tempo de "
"execução a todas as operações de registo, e a técnica só deve ser usada "
"quando o uso de um :class:`Filter` não fornecer o resultado desejado."

#: ../../howto/logging-cookbook.rst:1860
msgid "Subclassing QueueHandler and QueueListener- a ZeroMQ example"
msgstr "Subclasse de QueueHandler e QueueListener - um exemplo com ZeroMQ"

#: ../../howto/logging-cookbook.rst:1863 ../../howto/logging-cookbook.rst:1996
msgid "Subclass ``QueueHandler``"
msgstr "Subclasse ``QueueHandler``"

#: ../../howto/logging-cookbook.rst:1865
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds "
"of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"Pode utilizar uma subclasse de :class:`QueueHandler` para enviar mensagens "
"para outros tipos de filas, por exemplo, um socket 'publish' do ZeroMQ. No "
"exemplo abaixo, o socket é criado separadamente e passado para o manipulador "
"(como sua 'fila'):"

#: ../../howto/logging-cookbook.rst:1869
msgid ""
"import zmq   # using pyzmq, the Python binding for ZeroMQ\n"
"import json  # for serializing records portably\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB)  # or zmq.PUSH, or other suitable value\n"
"sock.bind('tcp://*:5556')        # or wherever\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"
msgstr ""
"import zmq   # utilizando pyzmq, a ligação Python para ZeroMQ\n"
"import json  # para serializar registos de forma portátil\n"
"\n"
"ctx = zmq.Context()\n"
"sock = zmq.Socket(ctx, zmq.PUB)  # ou zmq.PUSH, ou outro valor adequado\n"
"sock.bind('tcp://*:5556')        # ou outro local\n"
"\n"
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"\n"
"handler = ZeroMQSocketHandler(sock)"

#: ../../howto/logging-cookbook.rst:1884
msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr ""
"Claro que existem outras formas de organizar isto, por exemplo, passando os "
"dados necessários para o manipulador criar o socket:"

#: ../../howto/logging-cookbook.rst:1887
msgid ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"
msgstr ""
"class ZeroMQSocketHandler(QueueHandler):\n"
"    def __init__(self, uri, socktype=zmq.PUB, ctx=None):\n"
"        self.ctx = ctx or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, socktype)\n"
"        socket.bind(uri)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        self.queue.send_json(record.__dict__)\n"
"\n"
"    def close(self):\n"
"        self.queue.close()"

#: ../../howto/logging-cookbook.rst:1902 ../../howto/logging-cookbook.rst:1932
msgid "Subclass ``QueueListener``"
msgstr "Subclasse ``QueueListener``"

#: ../../howto/logging-cookbook.rst:1904
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an example::"
msgstr ""
"Também pode criar uma subclasse de :class:`QueueListener` para obter "
"mensagens de outros tipos de filas, por exemplo, um socket 'subscribe' do "
"ZeroMQ. Aqui está um exemplo:"

#: ../../howto/logging-cookbook.rst:1907
msgid ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscribe to "
"everything\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"
msgstr ""
"class ZeroMQSocketListener(QueueListener):\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        self.ctx = kwargs.get('ctx') or zmq.Context()\n"
"        socket = zmq.Socket(self.ctx, zmq.SUB)\n"
"        socket.setsockopt_string(zmq.SUBSCRIBE, '')  # subscrever tudo\n"
"        socket.connect(uri)\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self):\n"
"        msg = self.queue.recv_json()\n"
"        return logging.makeLogRecord(msg)"

#: ../../howto/logging-cookbook.rst:1922
msgid "Subclassing QueueHandler and QueueListener- a ``pynng`` example"
msgstr "Subclasse de QueueHandler e QueueListener - um exemplo com ``pynng``"

#: ../../howto/logging-cookbook.rst:1924
msgid ""
"In a similar way to the above section, we can implement a listener and "
"handler using :pypi:`pynng`, which is a Python binding to `NNG <https://nng."
"nanomsg.org/>`_, billed as a spiritual successor to ZeroMQ. The following "
"snippets illustrate -- you can test them in an environment which has "
"``pynng`` installed. Just for variety, we present the listener first."
msgstr ""
"De forma semelhante à secção acima, podemos implementar um ouvinte e um "
"manipulador utilizando :pypi:`pynng`, que é uma ligação Python para `NNG "
"<https://nng.nanomsg.org/>`_, apresentado como um sucessor espiritual do "
"ZeroMQ. Os seguintes excertos ilustram — pode testá-los num ambiente que "
"tenha ``pynng`` instalado. Apenas para variar, apresentamos primeiro o "
"ouvinte."

#: ../../howto/logging-cookbook.rst:1934
msgid ""
"# listener.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"interrupted = False\n"
"\n"
"class NNGSocketListener(logging.handlers.QueueListener):\n"
"\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        # Have a timeout for interruptability, and open a\n"
"        # subscriber socket\n"
"        socket = pynng.Sub0(listen=uri, recv_timeout=500)\n"
"        # The b'' subscription matches all topics\n"
"        topics = kwargs.pop('topics', None) or b''\n"
"        socket.subscribe(topics)\n"
"        # We treat the socket as a queue\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self, block):\n"
"        data = None\n"
"        # Keep looping while not interrupted and no data received over the\n"
"        # socket\n"
"        while not interrupted:\n"
"            try:\n"
"                data = self.queue.recv(block=block)\n"
"                break\n"
"            except pynng.Timeout:\n"
"                pass\n"
"            except pynng.Closed:  # sometimes happens when you hit Ctrl-C\n"
"                break\n"
"        if data is None:\n"
"            return None\n"
"        # Get the logging event sent from a publisher\n"
"        event = json.loads(data.decode('utf-8'))\n"
"        return logging.makeLogRecord(event)\n"
"\n"
"    def enqueue_sentinel(self):\n"
"        # Not used in this implementation, as the socket isn't really a\n"
"        # queue\n"
"        pass\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), "
"topics=b'')\n"
"listener.start()\n"
"print('Press Ctrl-C to stop.')\n"
"try:\n"
"    while True:\n"
"        pass\n"
"except KeyboardInterrupt:\n"
"    interrupted = True\n"
"finally:\n"
"    listener.stop()"
msgstr ""
"# listener.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"interrupted = False\n"
"\n"
"class NNGSocketListener(logging.handlers.QueueListener):\n"
"\n"
"    def __init__(self, uri, /, *handlers, **kwargs):\n"
"        # Ter um timeout para interrupção, e abrir um\n"
"        # socket de subscritor\n"
"        socket = pynng.Sub0(listen=uri, recv_timeout=500)\n"
"        # A subscricao b'' corresponde a todos os tópicos\n"
"        topics = kwargs.pop('topics', None) or b''\n"
"        socket.subscribe(topics)\n"
"        # Tratamos o socket como uma fila\n"
"        super().__init__(socket, *handlers, **kwargs)\n"
"\n"
"    def dequeue(self, block):\n"
"        data = None\n"
"        # Continuar em loop enquanto não for interrompido e não forem "
"recebidos dados no\n"
"        # socket\n"
"        while not interrupted:\n"
"            try:\n"
"                data = self.queue.recv(block=block)\n"
"                break\n"
"            except pynng.Timeout:\n"
"                pass\n"
"            except pynng.Closed:  # às vezes acontece quando prima Ctrl-C\n"
"                break\n"
"        if data is None:\n"
"            return None\n"
"        # Obter o evento de registo enviado por um publicador\n"
"        event = json.loads(data.decode('utf-8'))\n"
"        return logging.makeLogRecord(event)\n"
"\n"
"    def enqueue_sentinel(self):\n"
"        # Não é usado nesta implementação, uma vez que o socket não é "
"realmente uma\n"
"        # fila\n"
"        pass\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"listener = NNGSocketListener(DEFAULT_ADDR, logging.StreamHandler(), "
"topics=b'')\n"
"listener.start()\n"
"print('Pressione Ctrl-C para parar.')\n"
"try:\n"
"    while True:\n"
"        pass\n"
"except KeyboardInterrupt:\n"
"    interrupted = True\n"
"finally:\n"
"    listener.stop()"

#: ../../howto/logging-cookbook.rst:2000
msgid ""
"# sender.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"import time\n"
"import random\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"class NNGSocketHandler(logging.handlers.QueueHandler):\n"
"\n"
"    def __init__(self, uri):\n"
"        socket = pynng.Pub0(dial=uri, send_timeout=500)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        # Send the record as UTF-8 encoded JSON\n"
"        d = dict(record.__dict__)\n"
"        data = json.dumps(d)\n"
"        self.queue.send(data.encode('utf-8'))\n"
"\n"
"    def close(self):\n"
"        self.queue.close()\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"handler = NNGSocketHandler(DEFAULT_ADDR)\n"
"# Make sure the process ID is in the output\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    handlers=[logging.StreamHandler(), handler],\n"
"                    format='%(levelname)-8s %(name)10s %(process)6s "
"%(message)s')\n"
"levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')\n"
"msgno = 1\n"
"while True:\n"
"    # Just randomly select some loggers and levels and log away\n"
"    level = random.choice(levels)\n"
"    logger = logging.getLogger(random.choice(logger_names))\n"
"    logger.log(level, 'Message no. %5d' % msgno)\n"
"    msgno += 1\n"
"    delay = random.random() * 2 + 0.5\n"
"    time.sleep(delay)"
msgstr ""
"# sender.py\n"
"import json\n"
"import logging\n"
"import logging.handlers\n"
"import time\n"
"import random\n"
"\n"
"import pynng\n"
"\n"
"DEFAULT_ADDR = \"tcp://localhost:13232\"\n"
"\n"
"class NNGSocketHandler(logging.handlers.QueueHandler):\n"
"\n"
"    def __init__(self, uri):\n"
"        socket = pynng.Pub0(dial=uri, send_timeout=500)\n"
"        super().__init__(socket)\n"
"\n"
"    def enqueue(self, record):\n"
"        # Enviar o registo como JSON codificado em UTF-8\n"
"        d = dict(record.__dict__)\n"
"        data = json.dumps(d)\n"
"        self.queue.send(data.encode('utf-8'))\n"
"\n"
"    def close(self):\n"
"        self.queue.close()\n"
"\n"
"logging.getLogger('pynng').propagate = False\n"
"handler = NNGSocketHandler(DEFAULT_ADDR)\n"
"# Certificar-se de que o ID do processo está na saída\n"
"logging.basicConfig(level=logging.DEBUG,\n"
"                    handlers=[logging.StreamHandler(), handler],\n"
"                    format='%(levelname)-8s %(name)10s %(process)6s "
"%(message)s')\n"
"levels = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"logger_names = ('myapp', 'myapp.lib1', 'myapp.lib2')\n"
"msgno = 1\n"
"while True:\n"
"    # Apenas selecionar aleatoriamente alguns registadores e níveis e "
"registar\n"
"    level = random.choice(levels)\n"
"    logger = logging.getLogger(random.choice(logger_names))\n"
"    logger.log(level, 'Mensagem no. %5d' % msgno)\n"
"    msgno += 1\n"
"    delay = random.random() * 2 + 0.5\n"
"    time.sleep(delay)"

#: ../../howto/logging-cookbook.rst:2047
msgid ""
"You can run the above two snippets in separate command shells. If we run the "
"listener in one shell and run the sender in two separate shells, we should "
"see something like the following. In the first sender shell:"
msgstr ""
"Pode executar os dois excertos acima em shells de comando separados. Se "
"executarmos o ouvinte numa shell e o remetente em duas shells separadas, "
"devemos ver algo como o seguinte. Na primeira shell do remetente:"

#: ../../howto/logging-cookbook.rst:2051
msgid ""
"$ python sender.py\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python sender.py\n"
"DEBUG         myapp    613 Mensagem no.     1\n"
"WARNING  myapp.lib2    613 Mensagem no.     2\n"
"CRITICAL myapp.lib2    613 Mensagem no.     3\n"
"WARNING  myapp.lib2    613 Mensagem no.     4\n"
"CRITICAL myapp.lib1    613 Mensagem no.     5\n"
"DEBUG         myapp    613 Mensagem no.     6\n"
"CRITICAL myapp.lib1    613 Mensagem no.     7\n"
"INFO     myapp.lib1    613 Mensagem no.     8\n"
"(e assim sucessivamente)"

#: ../../howto/logging-cookbook.rst:2064
msgid "In the second sender shell:"
msgstr "Na segunda shell do remetente:"

#: ../../howto/logging-cookbook.rst:2066
msgid ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python sender.py\n"
"INFO     myapp.lib2    657 Mensagem no.     1\n"
"CRITICAL myapp.lib2    657 Mensagem no.     2\n"
"CRITICAL      myapp    657 Mensagem no.     3\n"
"CRITICAL myapp.lib1    657 Mensagem no.     4\n"
"INFO     myapp.lib1    657 Mensagem no.     5\n"
"WARNING  myapp.lib2    657 Mensagem no.     6\n"
"CRITICAL      myapp    657 Mensagem no.     7\n"
"DEBUG    myapp.lib1    657 Mensagem no.     8\n"
"(e assim sucessivamente)"

#: ../../howto/logging-cookbook.rst:2079
msgid "In the listener shell:"
msgstr "Na shell do ouvinte:"

#: ../../howto/logging-cookbook.rst:2081
msgid ""
"$ python listener.py\n"
"Press Ctrl-C to stop.\n"
"DEBUG         myapp    613 Message no.     1\n"
"WARNING  myapp.lib2    613 Message no.     2\n"
"INFO     myapp.lib2    657 Message no.     1\n"
"CRITICAL myapp.lib2    613 Message no.     3\n"
"CRITICAL myapp.lib2    657 Message no.     2\n"
"CRITICAL      myapp    657 Message no.     3\n"
"WARNING  myapp.lib2    613 Message no.     4\n"
"CRITICAL myapp.lib1    613 Message no.     5\n"
"CRITICAL myapp.lib1    657 Message no.     4\n"
"INFO     myapp.lib1    657 Message no.     5\n"
"DEBUG         myapp    613 Message no.     6\n"
"WARNING  myapp.lib2    657 Message no.     6\n"
"CRITICAL      myapp    657 Message no.     7\n"
"CRITICAL myapp.lib1    613 Message no.     7\n"
"INFO     myapp.lib1    613 Message no.     8\n"
"DEBUG    myapp.lib1    657 Message no.     8\n"
"(and so on)"
msgstr ""
"$ python listener.py\n"
"Pressione Ctrl-C para parar.\n"
"DEBUG         myapp    613 Mensagem no.     1\n"
"WARNING  myapp.lib2    613 Mensagem no.     2\n"
"INFO     myapp.lib2    657 Mensagem no.     1\n"
"CRITICAL myapp.lib2    613 Mensagem no.     3\n"
"CRITICAL myapp.lib2    657 Mensagem no.     2\n"
"CRITICAL      myapp    657 Mensagem no.     3\n"
"WARNING  myapp.lib2    613 Mensagem no.     4\n"
"CRITICAL myapp.lib1    613 Mensagem no.     5\n"
"CRITICAL myapp.lib1    657 Mensagem no.     4\n"
"INFO     myapp.lib1    657 Mensagem no.     5\n"
"DEBUG         myapp    613 Mensagem no.     6\n"
"WARNING  myapp.lib2    657 Mensagem no.     6\n"
"CRITICAL      myapp    657 Mensagem no.     7\n"
"CRITICAL myapp.lib1    613 Mensagem no.     7\n"
"INFO     myapp.lib1    613 Mensagem no.     8\n"
"DEBUG    myapp.lib1    657 Mensagem no.     8\n"
"(e assim sucessivamente)"

#: ../../howto/logging-cookbook.rst:2103
msgid ""
"As you can see, the logging from the two sender processes is interleaved in "
"the listener's output."
msgstr ""
"Como pode ver, o registo dos dois processos remetentes está intercalado na "
"saída do ouvinte."

#: ../../howto/logging-cookbook.rst:2108
msgid "An example dictionary-based configuration"
msgstr "Um exemplo de configuração baseada em dicionário"

#: ../../howto/logging-cookbook.rst:2110
msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project <https://docs.djangoproject.com/en/"
"stable/topics/logging/#configuring-logging>`_. This dictionary is passed to :"
"func:`~config.dictConfig` to put the configuration into effect::"
msgstr ""
"Em baixo está um exemplo de um dicionário de configuração de registo - foi "
"retirado da `documentação do projeto Django <https://docs.djangoproject.com/"
"en/stable/topics/logging/#configuring-logging>`_. Este dicionário é passado "
"para :func:`~config.dictConfig` para aplicar a configuração:"

#: ../../howto/logging-cookbook.rst:2114
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} {thread:d} "
"{message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    'filters': {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': False,\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'verbose': {\n"
"            'format': '{levelname} {asctime} {module} {process:d} {thread:d} "
"{message}',\n"
"            'style': '{',\n"
"        },\n"
"        'simple': {\n"
"            'format': '{levelname} {message}',\n"
"            'style': '{',\n"
"        },\n"
"    },\n"
"    'filters': {\n"
"        'special': {\n"
"            '()': 'project.logging.SpecialFilter',\n"
"            'foo': 'bar',\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'level': 'INFO',\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'simple',\n"
"        },\n"
"        'mail_admins': {\n"
"            'level': 'ERROR',\n"
"            'class': 'django.utils.log.AdminEmailHandler',\n"
"            'filters': ['special']\n"
"        }\n"
"    },\n"
"    'loggers': {\n"
"        'django': {\n"
"            'handlers': ['console'],\n"
"            'propagate': True,\n"
"        },\n"
"        'django.request': {\n"
"            'handlers': ['mail_admins'],\n"
"            'level': 'ERROR',\n"
"            'propagate': False,\n"
"        },\n"
"        'myproject.custom': {\n"
"            'handlers': ['console', 'mail_admins'],\n"
"            'level': 'INFO',\n"
"            'filters': ['special']\n"
"        }\n"
"    }\n"
"}"

#: ../../howto/logging-cookbook.rst:2163
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ of the Django documentation."
msgstr ""
"Para mais informações sobre esta configuração, pode consultar a `secção "
"relevante <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ da documentação do Django."

#: ../../howto/logging-cookbook.rst:2170
msgid "Using a rotator and namer to customize log rotation processing"
msgstr ""
"Utilizar um rotator e um namer para personalizar o processamento de rotação "
"de registos"

#: ../../howto/logging-cookbook.rst:2172
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following runnable script, which shows gzip compression of the log file::"
msgstr ""
"Um exemplo de como pode definir um namer e um rotator é apresentado no "
"seguinte script executável, que mostra a compressão gzip do ficheiro de "
"registo:"

#: ../../howto/logging-cookbook.rst:2175
msgid ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, "
"backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Message no. {i + 1}')"
msgstr ""
"import gzip\n"
"import logging\n"
"import logging.handlers\n"
"import os\n"
"import shutil\n"
"\n"
"def namer(name):\n"
"    return name + \".gz\"\n"
"\n"
"def rotator(source, dest):\n"
"    with open(source, 'rb') as f_in:\n"
"        with gzip.open(dest, 'wb') as f_out:\n"
"            shutil.copyfileobj(f_in, f_out)\n"
"    os.remove(source)\n"
"\n"
"\n"
"rh = logging.handlers.RotatingFileHandler('rotated.log', maxBytes=128, "
"backupCount=5)\n"
"rh.rotator = rotator\n"
"rh.namer = namer\n"
"\n"
"root = logging.getLogger()\n"
"root.setLevel(logging.INFO)\n"
"root.addHandler(rh)\n"
"f = logging.Formatter('%(asctime)s %(message)s')\n"
"rh.setFormatter(f)\n"
"for i in range(1000):\n"
"    root.info(f'Mensagem no. {i + 1}')"

#: ../../howto/logging-cookbook.rst:2203
msgid ""
"After running this, you will see six new files, five of which are compressed:"
msgstr ""
"Após executar isto, verá seis novos ficheiros, cinco dos quais estão "
"comprimidos:"

#: ../../howto/logging-cookbook.rst:2205
msgid ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Message no. 996\n"
"2023-01-20 02:28:17,767 Message no. 997\n"
"2023-01-20 02:28:17,767 Message no. 998"
msgstr ""
"$ ls rotated.log*\n"
"rotated.log       rotated.log.2.gz  rotated.log.4.gz\n"
"rotated.log.1.gz  rotated.log.3.gz  rotated.log.5.gz\n"
"$ zcat rotated.log.1.gz\n"
"2023-01-20 02:28:17,767 Mensagem no. 996\n"
"2023-01-20 02:28:17,767 Mensagem no. 997\n"
"2023-01-20 02:28:17,767 Mensagem no. 998"

#: ../../howto/logging-cookbook.rst:2216
msgid "A more elaborate multiprocessing example"
msgstr "Um exemplo mais elaborado de multiprocessamento"

#: ../../howto/logging-cookbook.rst:2218
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr ""
"O seguinte exemplo funcional mostra como o registo pode ser utilizado com "
"multiprocessamento usando ficheiros de configuração. As configurações são "
"relativamente simples, mas servem para ilustrar como configurações mais "
"complexas poderiam ser implementadas num cenário real de multiprocessamento."

#: ../../howto/logging-cookbook.rst:2223
msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three "
"separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the "
"handlers specified in the configuration. Note that these configurations are "
"purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"No exemplo, o processo principal cria um processo ouvinte e alguns processos "
"trabalhadores. Cada um dos processos principais, ouvintes e trabalhadores "
"têm três configurações separadas (os trabalhadores partilham todos a mesma "
"configuração). Podemos ver o registo no processo principal, como os "
"trabalhadores registam num QueueHandler e como o ouvinte implementa um "
"QueueListener e uma configuração de registo mais complexa, e organiza o "
"envio de eventos recebidos através da fila para os manipuladores "
"especificados na configuração. Note que estas configurações são puramente "
"ilustrativas, mas deve ser capaz de adaptar este exemplo ao seu próprio "
"cenário."

#: ../../howto/logging-cookbook.rst:2233
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it "
"works::"
msgstr ""
"Aqui está o script - as docstrings e os comentários explicam, "
"esperançosamente, como funciona:"

#: ../../howto/logging-cookbook.rst:2236
msgid ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue, Event, current_process\n"
"import os\n"
"import random\n"
"import time\n"
"\n"
"class MyHandler:\n"
"    \"\"\"\n"
"    A simple handler for logging events. It runs in the listener process "
"and\n"
"    dispatches events to loggers based on the name in the received record,\n"
"    which then get dispatched, by the logging system, to the handlers\n"
"    configured for those loggers.\n"
"    \"\"\"\n"
"\n"
"    def handle(self, record):\n"
"        if record.name == \"root\":\n"
"            logger = logging.getLogger()\n"
"        else:\n"
"            logger = logging.getLogger(record.name)\n"
"\n"
"        if logger.isEnabledFor(record.levelno):\n"
"            # The process name is transformed just to show that it's the "
"listener\n"
"            # doing the logging to files and console\n"
"            record.processName = '%s (for %s)' % (current_process().name, "
"record.processName)\n"
"            logger.handle(record)\n"
"\n"
"def listener_process(q, stop_event, config):\n"
"    \"\"\"\n"
"    This could be done in the main process, but is just done in a separate\n"
"    process for illustrative purposes.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    starts the listener and waits for the main process to signal completion\n"
"    via the event. The listener is then stopped, and the process exits.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    listener = logging.handlers.QueueListener(q, MyHandler())\n"
"    listener.start()\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled "
"logger ...')\n"
"    stop_event.wait()\n"
"    listener.stop()\n"
"\n"
"def worker_process(config):\n"
"    \"\"\"\n"
"    A number of these are spawned for the purpose of illustration. In\n"
"    practice, they could be a heterogeneous bunch of processes rather than\n"
"    ones which are identical to each other.\n"
"\n"
"    This initialises logging according to the specified configuration,\n"
"    and logs a hundred messages with random levels to randomly selected\n"
"    loggers.\n"
"\n"
"    A small sleep is added to allow other processes a chance to run. This\n"
"    is not strictly needed, but it mixes the output from the different\n"
"    processes a bit more than if it's left out.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    if os.name == 'posix':\n"
"        # On POSIX, the setup logger will have been configured in the\n"
"        # parent process, but should have been disabled following the\n"
"        # dictConfig call.\n"
"        # On Windows, since fork isn't used, the setup logger won't\n"
"        # exist in the child, so it would be created and the message\n"
"        # would appear - hence the \"if posix\" clause.\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Should not appear, because of disabled "
"logger ...')\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Message no. %d', i)\n"
"        time.sleep(0.01)\n"
"\n"
"def main():\n"
"    q = Queue()\n"
"    # The main process gets a simple configuration which prints to the "
"console.\n"
"    config_initial = {\n"
"        'version': 1,\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO'\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The worker process configuration is just a QueueHandler attached to "
"the\n"
"    # root logger, which allows all messages to be sent to the queue.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in "
"the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_worker = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'handlers': {\n"
"            'queue': {\n"
"                'class': 'logging.handlers.QueueHandler',\n"
"                'queue': q\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['queue'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # The listener process configuration shows that the full flexibility of\n"
"    # logging configuration is available to dispatch events to handlers "
"however\n"
"    # you want.\n"
"    # We disable existing loggers to disable the \"setup\" logger used in "
"the\n"
"    # parent process. This is needed on POSIX because the logger will\n"
"    # be there in the child following a fork().\n"
"    config_listener = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            },\n"
"            'simple': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(name)-15s %(levelname)-8s %(processName)-10s "
"%(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'formatter': 'simple',\n"
"                'level': 'INFO'\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"                'level': 'ERROR'\n"
"            }\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console', 'file', 'errors'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # Log some initial events, just to show that logging in the parent "
"works\n"
"    # normally.\n"
"    logging.config.dictConfig(config_initial)\n"
"    logger = logging.getLogger('setup')\n"
"    logger.info('About to create workers ...')\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='worker %d' % (i + 1),\n"
"                     args=(config_worker,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"        logger.info('Started worker: %s', wp.name)\n"
"    logger.info('About to create listener ...')\n"
"    stop_event = Event()\n"
"    lp = Process(target=listener_process, name='listener',\n"
"                 args=(q, stop_event, config_listener))\n"
"    lp.start()\n"
"    logger.info('Started listener')\n"
"    # We now hang around for the workers to finish their work.\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # Workers all done, listening can now stop.\n"
"    # Logging in the parent still works normally.\n"
"    logger.info('Telling listener to stop ...')\n"
"    stop_event.set()\n"
"    lp.join()\n"
"    logger.info('All done.')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"import logging.config\n"
"import logging.handlers\n"
"from multiprocessing import Process, Queue, Event, current_process\n"
"import os\n"
"import random\n"
"import time\n"
"\n"
"class MyHandler:\n"
"    \"\"\"\n"
"    Um manipulador simples para eventos de registo. É executado no processo "
"ouvinte e\n"
"    envia eventos para registadores com base no nome no registo recebido,\n"
"    que são então enviados, pelo sistema de registo, para os manipuladores\n"
"    configurados para esses registadores.\n"
"    \"\"\"\n"
"\n"
"    def handle(self, record):\n"
"        if record.name == \"root\":\n"
"            logger = logging.getLogger()\n"
"        else:\n"
"            logger = logging.getLogger(record.name)\n"
"\n"
"        if logger.isEnabledFor(record.levelno):\n"
"            # O nome do processo é transformado apenas para mostrar que é o "
"ouvinte\n"
"            # que está a fazer o registo em ficheiros e consola\n"
"            record.processName = '%s (para %s)' % (current_process().name, "
"record.processName)\n"
"            logger.handle(record)\n"
"\n"
"def listener_process(q, stop_event, config):\n"
"    \"\"\"\n"
"    Isto poderia ser feito no processo principal, mas é feito num processo\n"
"    separado apenas para fins ilustrativos.\n"
"\n"
"    Isto inicializa o registo de acordo com a configuração especificada,\n"
"    inicia o ouvinte e aguarda que o processo principal sinalize a "
"conclusão\n"
"    através do evento. O ouvinte é então parado e o processo termina.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    listener = logging.handlers.QueueListener(q, MyHandler())\n"
"    listener.start()\n"
"    if os.name == 'posix':\n"
"        # Em POSIX, o registador de configuração terá sido configurado no\n"
"        # processo pai, mas deve ter sido desativado após a chamada "
"dictConfig.\n"
"        # No Windows, uma vez que o fork não é usado, o registador de "
"configuração não\n"
"        # existirá no filho, por isso seria criado e a mensagem\n"
"        # apareceria - daí a cláusula \"if posix\".\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Não deve aparecer, devido ao registador "
"desativado ...')\n"
"    stop_event.wait()\n"
"    listener.stop()\n"
"\n"
"def worker_process(config):\n"
"    \"\"\"\n"
"    Vários destes são criados para fins de ilustração. Na prática,\n"
"    poderiam ser um conjunto heterogéneo de processos em vez de\n"
"    processos idênticos entre si.\n"
"\n"
"    Isto inicializa o registo de acordo com a configuração especificada,\n"
"    e regista cem mensagens com níveis aleatórios para registadores "
"selecionados aleatoriamente.\n"
"\n"
"    Um pequeno atraso é adicionado para permitir que outros processos tenham "
"uma oportunidade de executar.\n"
"    Isto não é estritamente necessário, mas mistura a saída dos diferentes\n"
"    processos um pouco mais do que se fosse omitido.\n"
"    \"\"\"\n"
"    logging.config.dictConfig(config)\n"
"    levels = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"              logging.CRITICAL]\n"
"    loggers = ['foo', 'foo.bar', 'foo.bar.baz',\n"
"               'spam', 'spam.ham', 'spam.ham.eggs']\n"
"    if os.name == 'posix':\n"
"        # Em POSIX, o registador de configuração terá sido configurado no\n"
"        # processo pai, mas deve ter sido desativado após a chamada "
"dictConfig.\n"
"        # No Windows, uma vez que o fork não é usado, o registador de "
"configuração não\n"
"        # existirá no filho, por isso seria criado e a mensagem\n"
"        # apareceria - daí a cláusula \"if posix\".\n"
"        logger = logging.getLogger('setup')\n"
"        logger.critical('Não deve aparecer, devido ao registador "
"desativado ...')\n"
"    for i in range(100):\n"
"        lvl = random.choice(levels)\n"
"        logger = logging.getLogger(random.choice(loggers))\n"
"        logger.log(lvl, 'Mensagem no. %d', i)\n"
"        time.sleep(0.01)\n"
"\n"
"def main():\n"
"    q = Queue()\n"
"    # O processo principal obtém uma configuração simples que imprime na "
"consola.\n"
"    config_initial = {\n"
"        'version': 1,\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'level': 'INFO'\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # A configuração do processo trabalhador é apenas um QueueHandler "
"anexado ao\n"
"    # registador raiz, que permite que todas as mensagens sejam enviadas "
"para a fila.\n"
"    # Desativamos os registadores existentes para desativar o registador "
"\"setup\" usado no\n"
"    # processo pai. Isto é necessário em POSIX porque o registador estará\n"
"    # presente no filho após um fork().\n"
"    config_worker = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'handlers': {\n"
"            'queue': {\n"
"                'class': 'logging.handlers.QueueHandler',\n"
"                'queue': q\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['queue'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # A configuração do processo ouvinte mostra que toda a flexibilidade de\n"
"    # configuração de registo está disponível para enviar eventos para "
"manipuladores da forma que desejar.\n"
"    # Desativamos os registadores existentes para desativar o registador "
"\"setup\" usado no\n"
"    # processo pai. Isto é necessário em POSIX porque o registador estará\n"
"    # presente no filho após um fork().\n"
"    config_listener = {\n"
"        'version': 1,\n"
"        'disable_existing_loggers': True,\n"
"        'formatters': {\n"
"            'detailed': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(asctime)s %(name)-15s %(levelname)-8s "
"%(processName)-10s %(message)s'\n"
"            },\n"
"            'simple': {\n"
"                'class': 'logging.Formatter',\n"
"                'format': '%(name)-15s %(levelname)-8s %(processName)-10s "
"%(message)s'\n"
"            }\n"
"        },\n"
"        'handlers': {\n"
"            'console': {\n"
"                'class': 'logging.StreamHandler',\n"
"                'formatter': 'simple',\n"
"                'level': 'INFO'\n"
"            },\n"
"            'file': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'foofile': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-foo.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed'\n"
"            },\n"
"            'errors': {\n"
"                'class': 'logging.FileHandler',\n"
"                'filename': 'mplog-errors.log',\n"
"                'mode': 'w',\n"
"                'formatter': 'detailed',\n"
"                'level': 'ERROR'\n"
"            }\n"
"        },\n"
"        'loggers': {\n"
"            'foo': {\n"
"                'handlers': ['foofile']\n"
"            }\n"
"        },\n"
"        'root': {\n"
"            'handlers': ['console', 'file', 'errors'],\n"
"            'level': 'DEBUG'\n"
"        }\n"
"    }\n"
"    # Registar alguns eventos iniciais, apenas para mostrar que o registo no "
"pai funciona\n"
"    # normalmente.\n"
"    logging.config.dictConfig(config_initial)\n"
"    logger = logging.getLogger('setup')\n"
"    logger.info('A criar trabalhadores ...')\n"
"    workers = []\n"
"    for i in range(5):\n"
"        wp = Process(target=worker_process, name='trabalhador %d' % (i + "
"1),\n"
"                     args=(config_worker,))\n"
"        workers.append(wp)\n"
"        wp.start()\n"
"        logger.info('Iniciado trabalhador: %s', wp.name)\n"
"    logger.info('A criar ouvinte ...')\n"
"    stop_event = Event()\n"
"    lp = Process(target=listener_process, name='ouvinte',\n"
"                 args=(q, stop_event, config_listener))\n"
"    lp.start()\n"
"    logger.info('Iniciado ouvinte')\n"
"    # Agora aguardamos que os trabalhadores terminem o seu trabalho.\n"
"    for wp in workers:\n"
"        wp.join()\n"
"    # Trabalhadores terminados, a escuta pode agora parar.\n"
"    # O registo no pai ainda funciona normalmente.\n"
"    logger.info('A dizer ao ouvinte para parar ...')\n"
"    stop_event.set()\n"
"    lp.join()\n"
"    logger.info('Tudo feito.')\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2445
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "Inserir um BOM em mensagens enviadas para um SysLogHandler"

#: ../../howto/logging-cookbook.rst:2447
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
"A :rfc:`5424` exige que uma mensagem Unicode seja enviada para um daemon "
"syslog como um conjunto de bytes com a seguinte estrutura: um componente "
"opcional puro-ASCII, seguido de uma Marca de Ordem de Bytes UTF-8 (BOM), "
"seguida de Unicode codificado usando UTF-8. (Veja a :rfc:`secção relevante "
"da especificação <5424#section-6>`.)"

#: ../../howto/logging-cookbook.rst:2453
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to "
"insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"No Python 3.1, foi adicionado código a :class:`~logging.handlers."
"SysLogHandler` para inserir um BOM na mensagem, mas infelizmente foi "
"implementado incorretamente, com o BOM a aparecer no início da mensagem e, "
"portanto, não permitindo que qualquer componente puro-ASCII aparecesse antes "
"dele."

#: ../../howto/logging-cookbook.rst:2459
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"Como este comportamento está quebrado, o código de inserção de BOM incorreto "
"está a ser removido do Python 3.2.4 e posteriores. No entanto, não está a "
"ser substituído, e se quiser produzir mensagens compatíveis com :rfc:`5424` "
"que incluam um BOM, uma sequência opcional puro-ASCII antes dele e Unicode "
"arbitrário depois dele, codificado usando UTF-8, então precisa de fazer o "
"seguinte:"

#: ../../howto/logging-cookbook.rst:2465
msgid ""
"Attach a :class:`~logging.Formatter` instance to your :class:`~logging."
"handlers.SysLogHandler` instance, with a format string such as::"
msgstr ""
"Anexar uma instância de :class:`~logging.Formatter` à sua instância de :"
"class:`~logging.handlers.SysLogHandler`, com uma string de formatação como::"

#: ../../howto/logging-cookbook.rst:2469
msgid "'ASCII section\\ufeffUnicode section'"
msgstr "'Secção ASCII\\ufeffSecção Unicode'"

#: ../../howto/logging-cookbook.rst:2471
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"O ponto de código Unicode U+FEFF, quando codificado usando UTF-8, será "
"codificado como um BOM UTF-8 — a string de bytes ``b'\\xef\\xbb\\xbf'``."

#: ../../howto/logging-cookbook.rst:2474
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure "
"that the data that appears in there after substitution is always ASCII (that "
"way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"Substitua a secção ASCII pelos espaços reservados que desejar, mas "
"certifique-se de que os dados que aparecem lá após a substituição são sempre "
"ASCII (dessa forma, permanecerão inalterados após a codificação UTF-8)."

#: ../../howto/logging-cookbook.rst:2478
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data "
"which appears there after substitution contains characters outside the ASCII "
"range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Substitua a secção Unicode pelos espaços reservados que desejar; se os dados "
"que aparecem lá após a substituição contiverem caracteres fora do intervalo "
"ASCII, não há problema — serão codificados usando UTF-8."

#: ../../howto/logging-cookbook.rst:2482
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"A mensagem formatada *será* codificada usando a codificação UTF-8 pelo "
"``SysLogHandler``. Se seguir as regras acima, deve ser capaz de produzir "
"mensagens compatíveis com :rfc:`5424`. Se não o fizer, o registo pode não "
"reclamar, mas as suas mensagens não serão compatíveis com RFC 5424, e o seu "
"daemon syslog pode reclamar."

#: ../../howto/logging-cookbook.rst:2489
msgid "Implementing structured logging"
msgstr "Implementar registo estruturado"

#: ../../howto/logging-cookbook.rst:2491
msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed "
"by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"Embora a maioria das mensagens de registo sejam destinadas à leitura por "
"humanos, e, portanto, não sejam facilmente analisáveis por máquinas, podem "
"existir circunstâncias em que deseja emitir mensagens num formato "
"estruturado que *possa* ser analisado por um programa (sem necessidade de "
"expressões regulares complexas para analisar a mensagem de registo). Isto é "
"simples de alcançar usando o pacote de registo. Existem várias formas de o "
"conseguir, mas a seguinte é uma abordagem simples que usa JSON para "
"serializar o evento de uma forma analisável por máquinas:"

#: ../../howto/logging-cookbook.rst:2499
msgid ""
"import json\n"
"import logging\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.message, json.dumps(self.kwargs))\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('message 1', foo='bar', bar='baz', num=123, fnum=123.456))"
msgstr ""
"import json\n"
"import logging\n"
"\n"
"class MensagemEstruturada:\n"
"    def __init__(self, mensagem, /, **kwargs):\n"
"        self.mensagem = mensagem\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        return '%s >>> %s' % (self.mensagem, json.dumps(self.kwargs))\n"
"\n"
"_ = MensagemEstruturada   # opcional, para melhorar a legibilidade\n"
"\n"
"logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"logging.info(_('mensagem 1', foo='bar', bar='baz', num=123, fnum=123.456))"

#: ../../howto/logging-cookbook.rst:2515
msgid "If the above script is run, it prints:"
msgstr "Se o script acima for executado, imprime:"

#: ../../howto/logging-cookbook.rst:2517
msgid ""
"message 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", \"foo\": "
"\"bar\"}"
msgstr ""
"mensagem 1 >>> {\"fnum\": 123.456, \"num\": 123, \"bar\": \"baz\", \"foo\": "
"\"bar\"}"

#: ../../howto/logging-cookbook.rst:2521 ../../howto/logging-cookbook.rst:2563
msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr ""
"Note que a ordem dos itens pode ser diferente de acordo com a versão do "
"Python utilizada."

#: ../../howto/logging-cookbook.rst:2524
msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr ""
"Se precisar de processamento mais especializado, pode usar um codificador "
"JSON personalizado, como no seguinte exemplo completo:"

#: ../../howto/logging-cookbook.rst:2527
msgid ""
"import json\n"
"import logging\n"
"\n"
"\n"
"class Encoder(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class StructuredMessage:\n"
"    def __init__(self, message, /, **kwargs):\n"
"        self.message = message\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Encoder().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.message, s)\n"
"\n"
"_ = StructuredMessage   # optional, to improve readability\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('message 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import json\n"
"import logging\n"
"\n"
"class Codificador(json.JSONEncoder):\n"
"    def default(self, o):\n"
"        if isinstance(o, set):\n"
"            return tuple(o)\n"
"        elif isinstance(o, str):\n"
"            return o.encode('unicode_escape').decode('ascii')\n"
"        return super().default(o)\n"
"\n"
"class MensagemEstruturada:\n"
"    def __init__(self, mensagem, /, **kwargs):\n"
"        self.mensagem = mensagem\n"
"        self.kwargs = kwargs\n"
"\n"
"    def __str__(self):\n"
"        s = Codificador().encode(self.kwargs)\n"
"        return '%s >>> %s' % (self.mensagem, s)\n"
"\n"
"_ = MensagemEstruturada   # opcional, para melhorar a legibilidade\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.INFO, format='%(message)s')\n"
"    logging.info(_('mensagem 1', set_value={1, 2, 3}, snowman='\\u2603'))\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2557
msgid "When the above script is run, it prints:"
msgstr "Quando o script acima é executado, imprime:"

#: ../../howto/logging-cookbook.rst:2559
msgid "message 1 >>> {\"snowman\": \"\\u2603\", \"set_value\": [1, 2, 3]}"
msgstr "mensagem 1 >>> {\"snowman\": \"\\u2603\", \"set_value\": [1, 2, 3]}"

#: ../../howto/logging-cookbook.rst:2572
msgid "Customizing handlers with :func:`dictConfig`"
msgstr "Personalizar manipuladores com :func:`dictConfig`"

#: ../../howto/logging-cookbook.rst:2574
msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but "
"the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"Existem momentos em que deseja personalizar manipuladores de registo de "
"formas específicas, e se usar :func:`dictConfig`, pode ser capaz de fazer "
"isso sem criar subclasses. Por exemplo, pode querer definir a propriedade de "
"um ficheiro de registo. Em POSIX, isto é facilmente feito usando :func:"
"`shutil.chown`, mas os manipuladores de ficheiros na biblioteca padrão não "
"oferecem suporte integrado. Pode personalizar a criação de manipuladores "
"usando uma função simples, como:"

#: ../../howto/logging-cookbook.rst:2581
msgid ""
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)"
msgstr ""
"def manipulador_ficheiro_proprio(nome_ficheiro, modo='a', codificacao=None, "
"proprietario=None):\n"
"    if proprietario:\n"
"        if not os.path.exists(nome_ficheiro):\n"
"            open(nome_ficheiro, 'a').close()\n"
"        shutil.chown(nome_ficheiro, *proprietario)\n"
"    return logging.FileHandler(nome_ficheiro, modo, codificacao)"

#: ../../howto/logging-cookbook.rst:2588
msgid ""
"You can then specify, in a logging configuration passed to :func:"
"`dictConfig`, that a logging handler be created by calling this function::"
msgstr ""
"Pode então especificar, numa configuração de registo passada para :func:"
"`dictConfig`, que um manipulador de registo seja criado chamando esta função:"

#: ../../howto/logging-cookbook.rst:2591
msgid ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}"
msgstr ""
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # Os valores abaixo são retirados deste dicionário e\n"
"            # usados para criar o manipulador, definir o nível do "
"manipulador e\n"
"            # o seu formatador.\n"
"            '()': manipulador_ficheiro_proprio,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # Os valores abaixo são passados para a função criadora do "
"manipulador\n"
"            # como argumentos nomeados.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}"

#: ../../howto/logging-cookbook.rst:2621
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"Neste exemplo, estou a definir a propriedade usando o utilizador e grupo "
"``pulse``, apenas para fins de ilustração. Juntando tudo num script "
"funcional, ``chowntest.py``:"

#: ../../howto/logging-cookbook.rst:2625
msgid ""
"import logging, logging.config, os, shutil\n"
"\n"
"def owned_file_handler(filename, mode='a', encoding=None, owner=None):\n"
"    if owner:\n"
"        if not os.path.exists(filename):\n"
"            open(filename, 'a').close()\n"
"        shutil.chown(filename, *owner)\n"
"    return logging.FileHandler(filename, mode, encoding)\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # The values below are popped from this dictionary and\n"
"            # used to create the handler, set the handler's level and\n"
"            # its formatter.\n"
"            '()': owned_file_handler,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # The values below are passed to the handler creator callable\n"
"            # as keyword arguments.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}\n"
"\n"
"logging.config.dictConfig(LOGGING)\n"
"logger = logging.getLogger('mylogger')\n"
"logger.debug('A debug message')"
msgstr ""
"import logging, logging.config, os, shutil\n"
"\n"
"def manipulador_ficheiro_proprio(nome_ficheiro, modo='a', codificacao=None, "
"proprietario=None):\n"
"    if proprietario:\n"
"        if not os.path.exists(nome_ficheiro):\n"
"            open(nome_ficheiro, 'a').close()\n"
"        shutil.chown(nome_ficheiro, *proprietario)\n"
"    return logging.FileHandler(nome_ficheiro, modo, codificacao)\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'default': {\n"
"            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'\n"
"        },\n"
"    },\n"
"    'handlers': {\n"
"        'file':{\n"
"            # Os valores abaixo são retirados deste dicionário e\n"
"            # usados para criar o manipulador, definir o nível do "
"manipulador e\n"
"            # o seu formatador.\n"
"            '()': manipulador_ficheiro_proprio,\n"
"            'level':'DEBUG',\n"
"            'formatter': 'default',\n"
"            # Os valores abaixo são passados para a função criadora do "
"manipulador\n"
"            # como argumentos nomeados.\n"
"            'owner': ['pulse', 'pulse'],\n"
"            'filename': 'chowntest.log',\n"
"            'mode': 'w',\n"
"            'encoding': 'utf-8',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['file'],\n"
"        'level': 'DEBUG',\n"
"    },\n"
"}\n"
"\n"
"logging.config.dictConfig(LOGGING)\n"
"logger = logging.getLogger('mylogger')\n"
"logger.debug('Uma mensagem de depuração')"

#: ../../howto/logging-cookbook.rst:2668
msgid "To run this, you will probably need to run as ``root``:"
msgstr "Para executar isto, provavelmente precisará de executar como ``root``:"

#: ../../howto/logging-cookbook.rst:2670
msgid ""
"$ sudo python3.3 chowntest.py\n"
"$ cat chowntest.log\n"
"2013-11-05 09:34:51,128 DEBUG mylogger A debug message\n"
"$ ls -l chowntest.log\n"
"-rw-r--r-- 1 pulse pulse 55 2013-11-05 09:34 chowntest.log"
msgstr ""

#: ../../howto/logging-cookbook.rst:2678
msgid ""
"Note that this example uses Python 3.3 because that's where :func:`shutil."
"chown` makes an appearance. This approach should work with any Python "
"version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 or later. "
"With pre-3.3 versions, you would need to implement the actual ownership "
"change using e.g. :func:`os.chown`."
msgstr ""
"Note que este exemplo usa Python 3.3 porque é onde :func:`shutil.chown` faz "
"a sua aparição. Esta abordagem deve funcionar com qualquer versão do Python "
"que suporte :func:`dictConfig` — nomeadamente, Python 2.7, 3.2 ou posterior. "
"Com versões anteriores à 3.3, precisaria de implementar a alteração real de "
"propriedade usando, por exemplo, :func:`os.chown`."

#: ../../howto/logging-cookbook.rst:2684
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr ""
"Na prática, a função de criação de manipuladores pode estar num módulo "
"utilitário em algum lugar do seu projeto. Em vez da linha na configuração:"

#: ../../howto/logging-cookbook.rst:2687
msgid "'()': owned_file_handler,"
msgstr "'()': manipulador_ficheiro_proprio,"

#: ../../howto/logging-cookbook.rst:2689
msgid "you could use e.g.::"
msgstr "pode usar, por exemplo:"

#: ../../howto/logging-cookbook.rst:2691
msgid "'()': 'ext://project.util.owned_file_handler',"
msgstr "'()': 'ext://projecto.util.manipulador_ficheiro_proprio',"

#: ../../howto/logging-cookbook.rst:2693
msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using ``'ext://"
"__main__.owned_file_handler'`` should work. Here, the actual callable is "
"resolved by :func:`dictConfig` from the ``ext://`` specification."
msgstr ""
"onde ``project.util`` pode ser substituído pelo nome real do pacote onde a "
"função reside. No script funcional acima, usar ``'ext://__main__."
"owned_file_handler'`` deve funcionar. Aqui, o objeto chamável real é "
"resolvido por :func:`dictConfig` a partir da especificação ``ext://``."

#: ../../howto/logging-cookbook.rst:2698
msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr ""
"Este exemplo também aponta, esperançosamente, para como poderia implementar "
"outros tipos de alterações de ficheiros — por exemplo, definir bits de "
"permissão POSIX específicos — da mesma forma, usando :func:`os.chmod`."

#: ../../howto/logging-cookbook.rst:2702
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file "
"handlers, or a different type of handler altogether."
msgstr ""
"Claro, a abordagem também pode ser estendida a tipos de manipuladores "
"diferentes de :class:`~logging.FileHandler` — por exemplo, um dos "
"manipuladores de ficheiros rotativos, ou um tipo de manipulador "
"completamente diferente."

#: ../../howto/logging-cookbook.rst:2712
msgid "Using particular formatting styles throughout your application"
msgstr "Utilizar estilos de formatação específicos em toda a sua aplicação"

#: ../../howto/logging-cookbook.rst:2714
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"No Python 3.2, o :class:`~logging.Formatter` ganhou um parâmetro de palavra-"
"chave ``style`` que, embora o valor predefinido seja ``%`` para "
"compatibilidade retroativa, permitiu a especificação de ``{`` ou ``$`` para "
"suportar as abordagens de formatação suportadas por :meth:`str.format` e :"
"class:`string.Template`. Note que isto governa a formatação das mensagens de "
"registo para saída final nos registos, e é completamente ortogonal à forma "
"como uma mensagem de registo individual é construída."

#: ../../howto/logging-cookbook.rst:2721
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate "
"additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or :class:`string."
"Template` syntax, because internally the logging package uses %-formatting "
"to merge the format string and the variable arguments. There would be no "
"changing this while preserving backward compatibility, since all logging "
"calls which are out there in existing code will be using %-format strings."
msgstr ""
"As chamadas de registo (:meth:`~Logger.debug`, :meth:`~Logger.info`, etc.) "
"apenas aceitam parâmetros posicionais para a mensagem de registo em si, com "
"parâmetros nomeados usados apenas para determinar opções sobre como lidar "
"com a chamada de registo (por exemplo, o parâmetro nomeado ``exc_info`` para "
"indicar que a informação de traceback deve ser registada, ou o parâmetro "
"nomeado ``extra`` para indicar informações contextuais adicionais a serem "
"adicionadas ao registo). Portanto, não é possível fazer chamadas de registo "
"diretamente utilizando a sintaxe :meth:`str.format` ou :class:`string."
"Template`, porque internamente o pacote de registo utiliza formatação com %-"
"f para fundir a string de formatação e os argumentos variáveis. Não seria "
"possível alterar isto mantendo a compatibilidade retroativa, uma vez que "
"todas as chamadas de registo existentes no código utilizam strings de "
"formatação com %-f."

#: ../../howto/logging-cookbook.rst:2733
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using %-"
"formatting."
msgstr ""
"Houve sugestões para associar estilos de formatação a registadores "
"específicos, mas essa abordagem também enfrenta problemas de compatibilidade "
"retroativa porque qualquer código existente pode estar a usar um nome de "
"registador específico e a usar formatação com %-f."

#: ../../howto/logging-cookbook.rst:2737
msgid ""
"For logging to work interoperably between any third-party libraries and your "
"code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative "
"formatting styles can be accommodated."
msgstr ""
"Para que o registo funcione de forma interoperável entre quaisquer "
"bibliotecas de terceiros e o seu código, as decisões sobre formatação "
"precisam de ser tomadas ao nível da chamada de registo individual. Isto abre "
"algumas formas de acomodar estilos de formatação alternativos."

#: ../../howto/logging-cookbook.rst:2744
msgid "Using LogRecord factories"
msgstr "Utilizar fábricas de LogRecord"

#: ../../howto/logging-cookbook.rst:2746
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other "
"code. Care should also be taken to call ``str(self.msg)``, just as the base "
"implementation does."
msgstr ""
"No Python 3.2, juntamente com as alterações ao :class:`~logging.Formatter` "
"mencionadas acima, o pacote de registo ganhou a capacidade de permitir que "
"os utilizadores definam as suas próprias subclasses de :class:`LogRecord`, "
"usando a função :func:`setLogRecordFactory`. Pode usar isto para definir a "
"sua própria subclasse de :class:`LogRecord`, que faz a coisa certa "
"substituindo o método :meth:`~LogRecord.getMessage`. A implementação da "
"classe base deste método é onde a formatação ``msg % args`` acontece, e onde "
"pode substituir a sua formatação alternativa; no entanto, deve ter cuidado "
"para suportar todos os estilos de formatação e permitir a formatação com %-f "
"como predefinição, para garantir interoperabilidade com outro código. Também "
"deve ser tomado cuidado para chamar ``str(self.msg)``, tal como a "
"implementação base faz."

#: ../../howto/logging-cookbook.rst:2757
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and :"
"class:`LogRecord` for more information."
msgstr ""
"Consulte a documentação de referência sobre :func:`setLogRecordFactory` e :"
"class:`LogRecord` para mais informações."

#: ../../howto/logging-cookbook.rst:2762
msgid "Using custom message objects"
msgstr "Utilizar objetos de mensagem personalizados"

#: ../../howto/logging-cookbook.rst:2764
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting "
"to construct your individual log messages. You may recall (from :ref:"
"`arbitrary-object-messages`) that when logging you can use an arbitrary "
"object as a message format string, and that the logging package will call :"
"func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"Existe outra forma, talvez mais simples, de utilizar formatação com {}- e $- "
"para construir as suas mensagens de registo individuais. Pode recordar (de :"
"ref:`arbitrary-object-messages`) que, ao registar, pode usar um objeto "
"arbitrário como uma string de formatação de mensagem, e que o pacote de "
"registo chamará :func:`str` nesse objeto para obter a string de formatação "
"real. Considere as duas classes seguintes:"

#: ../../howto/logging-cookbook.rst:2789
msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever "
"you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""

#: ../../howto/logging-cookbook.rst:2797
msgid ""
"Examples of this approach are given below. Firstly, formatting with :meth:"
"`str.format`::"
msgstr ""
"Exemplos desta abordagem são dados abaixo. Primeiro, formatação com :meth:"
"`str.format`:"

#: ../../howto/logging-cookbook.rst:2800
msgid ""
">>> __ = BraceMessage\n"
">>> print(__('Message with {0} {1}', 2, 'placeholders'))\n"
"Message with 2 placeholders\n"
">>> class Point: pass\n"
"...\n"
">>> p = Point()\n"
">>> p.x = 0.5\n"
">>> p.y = 0.5\n"
">>> print(__('Message with coordinates: ({point.x:.2f}, {point.y:.2f})', "
"point=p))\n"
"Message with coordinates: (0.50, 0.50)"
msgstr ""

#: ../../howto/logging-cookbook.rst:2811
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "Em segundo lugar, formatação com :class:`string.Template`:"

#: ../../howto/logging-cookbook.rst:2813
msgid ""
">>> __ = DollarMessage\n"
">>> print(__('Message with $num $what', num=2, what='placeholders'))\n"
"Message with 2 placeholders\n"
">>>"
msgstr ""

#: ../../howto/logging-cookbook.rst:2818
msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the :samp:`{XXX}Message` classes "
"shown above."
msgstr ""
"Uma coisa a notar é que não há penalização significativa de desempenho com "
"esta abordagem: a formatação real não acontece quando faz a chamada de "
"registo, mas sim quando (e se) a mensagem registada estiver prestes a ser "
"enviada para um registo por um manipulador. Portanto, a única coisa "
"ligeiramente invulgar que pode confundir é que os parênteses envolvem a "
"string de formatação e os argumentos, não apenas a string de formatação. "
"Isto acontece porque a notação __ é apenas açúcar sintático para uma chamada "
"de construtor para uma das classes :samp:`{XXX}Message` mostradas acima."

#: ../../howto/logging-cookbook.rst:2832
msgid "Configuring filters with :func:`dictConfig`"
msgstr "Configurar filtros com :func:`dictConfig`"

#: ../../howto/logging-cookbook.rst:2834
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though "
"it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own :"
"class:`~logging.Filter` subclass with an overridden :meth:`~logging.Filter."
"filter` method. To do this, specify the ``()`` key in the configuration "
"dictionary for the filter, specifying a callable which will be used to "
"create the filter (a class is the most obvious, but you can provide any "
"callable which returns a :class:`~logging.Filter` instance). Here is a "
"complete example::"
msgstr ""
"Pode configurar filtros usando :func:`~logging.config.dictConfig`, embora "
"possa não ser óbvio à primeira vista como fazê-lo (daí esta receita). Uma "
"vez que :class:`~logging.Filter` é a única classe de filtro incluída na "
"biblioteca padrão, e é improvável que atenda a muitos requisitos (está "
"apenas presente como uma classe base), normalmente precisará de definir a "
"sua própria subclasse de :class:`~logging.Filter` com um método :meth:"
"`~logging.Filter.filter` substituído. Para fazer isto, especifique a chave "
"``()`` no dicionário de configuração para o filtro, especificando um objeto "
"chamável que será usado para criar o filtro (uma classe é a opção mais "
"óbvia, mas pode fornecer qualquer objeto chamável que retorne uma instância "
"de :class:`~logging.Filter`). Aqui está um exemplo completo:"

#: ../../howto/logging-cookbook.rst:2845
msgid ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MyFilter(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'changed: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'myfilter': {\n"
"            '()': MyFilter,\n"
"            'param': 'noshow',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['myfilter']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['console']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('hello')\n"
"    logging.debug('hello - noshow')"
msgstr ""
"import logging\n"
"import logging.config\n"
"import sys\n"
"\n"
"class MeuFiltro(logging.Filter):\n"
"    def __init__(self, param=None):\n"
"        self.param = param\n"
"\n"
"    def filter(self, record):\n"
"        if self.param is None:\n"
"            allow = True\n"
"        else:\n"
"            allow = self.param not in record.msg\n"
"        if allow:\n"
"            record.msg = 'alterado: ' + record.msg\n"
"        return allow\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'filters': {\n"
"        'meufiltro': {\n"
"            '()': MeuFiltro,\n"
"            'param': 'naomostrar',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'consola': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'filters': ['meufiltro']\n"
"        }\n"
"    },\n"
"    'root': {\n"
"        'level': 'DEBUG',\n"
"        'handlers': ['consola']\n"
"    },\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.debug('olá')\n"
"    logging.debug('olá - naomostrar')"

#: ../../howto/logging-cookbook.rst:2887
msgid ""
"This example shows how you can pass configuration data to the callable which "
"constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr ""
"Este exemplo mostra como pode passar dados de configuração para o objeto "
"chamável que constrói a instância, na forma de parâmetros nomeados. Quando "
"executado, o script acima imprimirá:"

#: ../../howto/logging-cookbook.rst:2891
msgid "changed: hello"
msgstr "alterado: olá"

#: ../../howto/logging-cookbook.rst:2895
msgid "which shows that the filter is working as configured."
msgstr "o que mostra que o filtro está a funcionar conforme configurado."

#: ../../howto/logging-cookbook.rst:2897
msgid "A couple of extra points to note:"
msgstr "Alguns pontos adicionais a notar:"

#: ../../howto/logging-cookbook.rst:2899
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it "
"lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"Se não puder referenciar o objeto chamável diretamente na configuração (por "
"exemplo, se ele estiver num módulo diferente, e não puder importá-lo "
"diretamente onde o dicionário de configuração está), pode usar a forma "
"``ext://...`` como descrito em :ref:`logging-config-dict-externalobj`. Por "
"exemplo, poderia ter usado o texto ``'ext://__main__.MyFilter'`` em vez de "
"``MyFilter`` no exemplo acima."

#: ../../howto/logging-cookbook.rst:2906
msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"Além de filtros, esta técnica também pode ser usada para configurar "
"manipuladores e formatadores personalizados. Consulte :ref:`logging-config-"
"dict-userdef` para mais informações sobre como o registo suporta o uso de "
"objetos definidos pelo utilizador na sua configuração, e veja a outra "
"receita do livro de receitas :ref:`custom-handlers` acima."

#: ../../howto/logging-cookbook.rst:2915
msgid "Customized exception formatting"
msgstr "Formatação de exceções personalizada"

#: ../../howto/logging-cookbook.rst:2917
msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"Pode haver momentos em que deseja fazer formatação de exceções personalizada "
"— por exemplo, digamos que deseja exatamente uma linha por evento registado, "
"mesmo quando a informação da exceção está presente. Pode fazer isto com uma "
"classe de formatador personalizada, como mostrado no seguinte exemplo:"

#: ../../howto/logging-cookbook.rst:2922
msgid ""
"import logging\n"
"\n"
"class OneLineExceptionFormatter(logging.Formatter):\n"
"    def formatException(self, exc_info):\n"
"        \"\"\"\n"
"        Format an exception so that it prints on a single line.\n"
"        \"\"\"\n"
"        result = super().formatException(exc_info)\n"
"        return repr(result)  # or format into one line however you want to\n"
"\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        if record.exc_text:\n"
"            s = s.replace('\\n', '') + '|'\n"
"        return s\n"
"\n"
"def configure_logging():\n"
"    fh = logging.FileHandler('output.txt', 'w')\n"
"    f = OneLineExceptionFormatter('%(asctime)s|%(levelname)s|%(message)s|',\n"
"                                  '%d/%m/%Y %H:%M:%S')\n"
"    fh.setFormatter(f)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(fh)\n"
"\n"
"def main():\n"
"    configure_logging()\n"
"    logging.info('Sample message')\n"
"    try:\n"
"        x = 1 / 0\n"
"    except ZeroDivisionError as e:\n"
"        logging.exception('ZeroDivisionError: %s', e)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"class FormatadorExcecaoUmaLinha(logging.Formatter):\n"
"    def formatException(self, exc_info):\n"
"        \"\"\"\n"
"        Formatar uma exceção para que seja impressa numa única linha.\n"
"        \"\"\"\n"
"        result = super().formatException(exc_info)\n"
"        return repr(result)  # ou formatar numa linha como desejar\n"
"\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        if record.exc_text:\n"
"            s = s.replace('\\n', '') + '|'\n"
"        return s\n"
"\n"
"def configurar_registo():\n"
"    fh = logging.FileHandler('output.txt', 'w')\n"
"    f = FormatadorExcecaoUmaLinha('%(asctime)s|%(levelname)s|%(message)s|',\n"
"                                  '%d/%m/%Y %H:%M:%S')\n"
"    fh.setFormatter(f)\n"
"    root = logging.getLogger()\n"
"    root.setLevel(logging.DEBUG)\n"
"    root.addHandler(fh)\n"
"\n"
"def main():\n"
"    configurar_registo()\n"
"    logging.info('Mensagem de exemplo')\n"
"    try:\n"
"        x = 1 / 0\n"
"    except ZeroDivisionError as e:\n"
"        logging.exception('ZeroDivisionError: %s', e)\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:2958
msgid "When run, this produces a file with exactly two lines:"
msgstr "Quando executado, isto produz um ficheiro com exatamente duas linhas:"

#: ../../howto/logging-cookbook.rst:2960
msgid ""
"28/01/2015 07:21:23|INFO|Sample message|\n"
"28/01/2015 07:21:23|ERROR|ZeroDivisionError: integer division or modulo by "
"zero|'Traceback (most recent call last):\\n  File \"logtest7.py\", line 30, "
"in main\\n    x = 1 / 0\\nZeroDivisionError: integer division or modulo by "
"zero'|"
msgstr ""

#: ../../howto/logging-cookbook.rst:2965
msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may "
"be helpful for more specialized needs."
msgstr ""
"Embora o tratamento acima seja simplista, aponta o caminho para como a "
"informação de exceção pode ser formatada ao seu gosto. O módulo :mod:"
"`traceback` pode ser útil para necessidades mais especializadas."

#: ../../howto/logging-cookbook.rst:2972
msgid "Speaking logging messages"
msgstr "Falar mensagens de registo"

#: ../../howto/logging-cookbook.rst:2974
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using :mod:"
"`subprocess`. It's assumed here that TTS command line programs won't expect "
"to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time "
"rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"Pode haver situações em que é desejável que as mensagens de registo sejam "
"apresentadas num formato audível em vez de visível. Isto é fácil de fazer se "
"tiver funcionalidade de texto para fala (TTS) disponível no seu sistema, "
"mesmo que não tenha uma ligação Python. A maioria dos sistemas TTS tem um "
"programa de linha de comandos que pode executar, e este pode ser invocado a "
"partir de um manipulador usando :mod:`subprocess`. Assume-se aqui que os "
"programas de linha de comandos TTS não esperam interagir com os utilizadores "
"ou demorar muito tempo a completar, e que a frequência das mensagens "
"registadas não será tão alta a ponto de sobrecarregar o utilizador com "
"mensagens, e que é aceitável que as mensagens sejam faladas uma de cada vez "
"em vez de concorrentemente. A implementação de exemplo abaixo aguarda que "
"uma mensagem seja falada antes de processar a próxima, e isto pode fazer com "
"que outros manipuladores tenham de esperar. Aqui está um exemplo curto "
"mostrando a abordagem, que assume que o pacote TTS ``espeak`` está "
"disponível:"

#: ../../howto/logging-cookbook.rst:2987
msgid ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class TTSHandler(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # Speak slowly in a female English voice\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # wait for the program to finish\n"
"        p.communicate()\n"
"\n"
"def configure_logging():\n"
"    h = TTSHandler()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # the default formatter just returns the message\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Hello')\n"
"    logging.debug('Goodbye')\n"
"\n"
"if __name__ == '__main__':\n"
"    configure_logging()\n"
"    sys.exit(main())"
msgstr ""
"import logging\n"
"import subprocess\n"
"import sys\n"
"\n"
"class ManipuladorTTS(logging.Handler):\n"
"    def emit(self, record):\n"
"        msg = self.format(record)\n"
"        # Falar devagar numa voz feminina em inglês\n"
"        cmd = ['espeak', '-s150', '-ven+f3', msg]\n"
"        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,\n"
"                             stderr=subprocess.STDOUT)\n"
"        # esperar que o programa termine\n"
"        p.communicate()\n"
"\n"
"def configurar_registo():\n"
"    h = ManipuladorTTS()\n"
"    root = logging.getLogger()\n"
"    root.addHandler(h)\n"
"    # o formatador predefinido apenas retorna a mensagem\n"
"    root.setLevel(logging.DEBUG)\n"
"\n"
"def main():\n"
"    logging.info('Olá')\n"
"    logging.debug('Adeus')\n"
"\n"
"if __name__ == '__main__':\n"
"    configurar_registo()\n"
"    sys.exit(main())"

#: ../../howto/logging-cookbook.rst:3016
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr ""
"Quando executado, este script deve dizer \"Olá\" e depois \"Adeus\" numa voz "
"feminina."

#: ../../howto/logging-cookbook.rst:3018
msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr ""
"A abordagem acima pode, claro, ser adaptada a outros sistemas TTS e até "
"mesmo a outros sistemas que possam processar mensagens através de programas "
"externos executados a partir de uma linha de comandos."

#: ../../howto/logging-cookbook.rst:3026
msgid "Buffering logging messages and outputting them conditionally"
msgstr "Armazenar mensagens de registo em buffer e emitir condicionalmente"

#: ../../howto/logging-cookbook.rst:3028
msgid ""
"There might be situations where you want to log messages in a temporary area "
"and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"Pode haver situações em que deseja registar mensagens numa área temporária e "
"só emitir essas mensagens se ocorrer uma determinada condição. Por exemplo, "
"pode querer começar a registar eventos de depuração numa função, e se a "
"função for concluída sem erros, não quer sobrecarregar o registo com as "
"informações de depuração recolhidas, mas se houver um erro, quer que todas "
"as informações de depuração sejam emitidas juntamente com o erro."

#: ../../howto/logging-cookbook.rst:3035
msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised "
"subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"Aqui está um exemplo que mostra como pode fazer isto usando um decorador "
"para as suas funções onde deseja que o registo se comporte desta forma. "
"Utiliza o :class:`logging.handlers.MemoryHandler`, que permite armazenar "
"eventos registados em buffer até que ocorra alguma condição, altura em que "
"os eventos armazenados em buffer são ``flushed`` — passados para outro "
"manipulador (o manipulador ``target``) para processamento. Por predefinição, "
"o ``MemoryHandler`` é esvaziado quando o seu buffer fica cheio ou quando um "
"evento cujo nível é maior ou igual a um limite especificado é visto. Pode "
"usar esta receita com uma subclasse mais especializada de ``MemoryHandler`` "
"se desejar um comportamento de esvaziamento personalizado."

#: ../../howto/logging-cookbook.rst:3045
msgid ""
"The example script has a simple function, ``foo``, which just cycles through "
"all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"O script de exemplo tem uma função simples, ``foo``, que percorre todos os "
"níveis de registo, escrevendo em ``sys.stderr`` para indicar em que nível "
"está prestes a registar, e depois regista efetivamente uma mensagem nesse "
"nível. Pode passar um parâmetro para ``foo`` que, se for verdadeiro, "
"registará nos níveis ERROR e CRITICAL — caso contrário, só registará nos "
"níveis DEBUG, INFO e WARNING."

#: ../../howto/logging-cookbook.rst:3051
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a :class:`~logging."
"StreamHandler` which writes to ``sys.stderr``, ``logging.ERROR`` and ``100`` "
"respectively."
msgstr ""
"O script apenas organiza para decorar ``foo`` com um decorador que fará o "
"registo condicional necessário. O decorador recebe um registador como "
"parâmetro e anexa um manipulador de memória durante a chamada à função "
"decorada. O decorador pode ser adicionalmente parametrizado usando um "
"manipulador alvo, um nível em que o esvaziamento deve ocorrer, e uma "
"capacidade para o buffer (número de registos armazenados em buffer). Estes "
"valores predefinidos são um :class:`~logging.StreamHandler` que escreve para "
"``sys.stderr``, ``logging.ERROR`` e ``100``, respetivamente."

#: ../../howto/logging-cookbook.rst:3059
msgid "Here's the script::"
msgstr "Aqui está o script:"

#: ../../howto/logging-cookbook.rst:3061
msgid ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def log_if_errors(logger, target_handler=None, flush_level=None, "
"capacity=None):\n"
"    if target_handler is None:\n"
"        target_handler = logging.StreamHandler()\n"
"    if flush_level is None:\n"
"        flush_level = logging.ERROR\n"
"    if capacity is None:\n"
"        capacity = 100\n"
"    handler = MemoryHandler(capacity, flushLevel=flush_level, "
"target=target_handler)\n"
"\n"
"    def decorator(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(handler)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('call failed')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, handler).flush()\n"
"                logger.removeHandler(handler)\n"
"        return wrapper\n"
"\n"
"    return decorator\n"
"\n"
"def write_line(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(fail=False):\n"
"    write_line('about to log at DEBUG ...')\n"
"    logger.debug('Actually logged at DEBUG')\n"
"    write_line('about to log at INFO ...')\n"
"    logger.info('Actually logged at INFO')\n"
"    write_line('about to log at WARNING ...')\n"
"    logger.warning('Actually logged at WARNING')\n"
"    if fail:\n"
"        write_line('about to log at ERROR ...')\n"
"        logger.error('Actually logged at ERROR')\n"
"        write_line('about to log at CRITICAL ...')\n"
"        logger.critical('Actually logged at CRITICAL')\n"
"    return fail\n"
"\n"
"decorated_foo = log_if_errors(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    write_line('Calling undecorated foo with False')\n"
"    assert not foo(False)\n"
"    write_line('Calling undecorated foo with True')\n"
"    assert foo(True)\n"
"    write_line('Calling decorated foo with False')\n"
"    assert not decorated_foo(False)\n"
"    write_line('Calling decorated foo with True')\n"
"    assert decorated_foo(True)"
msgstr ""
"import logging\n"
"from logging.handlers import MemoryHandler\n"
"import sys\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"logger.addHandler(logging.NullHandler())\n"
"\n"
"def registar_se_erros(logger, manipulador_alvo=None, "
"nivel_esvaziamento=None, capacidade=None):\n"
"    if manipulador_alvo is None:\n"
"        manipulador_alvo = logging.StreamHandler()\n"
"    if nivel_esvaziamento is None:\n"
"        nivel_esvaziamento = logging.ERROR\n"
"    if capacidade is None:\n"
"        capacidade = 100\n"
"    manipulador = MemoryHandler(capacidade, flushLevel=nivel_esvaziamento, "
"target=manipulador_alvo)\n"
"\n"
"    def decorador(fn):\n"
"        def wrapper(*args, **kwargs):\n"
"            logger.addHandler(manipulador)\n"
"            try:\n"
"                return fn(*args, **kwargs)\n"
"            except Exception:\n"
"                logger.exception('chamada falhou')\n"
"                raise\n"
"            finally:\n"
"                super(MemoryHandler, manipulador).flush()\n"
"                logger.removeHandler(manipulador)\n"
"        return wrapper\n"
"\n"
"    return decorador\n"
"\n"
"def escrever_linha(s):\n"
"    sys.stderr.write('%s\\n' % s)\n"
"\n"
"def foo(falhar=False):\n"
"    escrever_linha('prestes a registar em DEBUG ...')\n"
"    logger.debug('Realmente registado em DEBUG')\n"
"    escrever_linha('prestes a registar em INFO ...')\n"
"    logger.info('Realmente registado em INFO')\n"
"    escrever_linha('prestes a registar em WARNING ...')\n"
"    logger.warning('Realmente registado em WARNING')\n"
"    if falhar:\n"
"        escrever_linha('prestes a registar em ERROR ...')\n"
"        logger.error('Realmente registado em ERROR')\n"
"        escrever_linha('prestes a registar em CRITICAL ...')\n"
"        logger.critical('Realmente registado em CRITICAL')\n"
"    return falhar\n"
"\n"
"foo_decorado = registar_se_erros(logger)(foo)\n"
"\n"
"if __name__ == '__main__':\n"
"    logger.setLevel(logging.DEBUG)\n"
"    escrever_linha('Chamar foo não decorado com False')\n"
"    assert not foo(False)\n"
"    escrever_linha('Chamar foo não decorado com True')\n"
"    assert foo(True)\n"
"    escrever_linha('Chamar foo decorado com False')\n"
"    assert not foo_decorado(False)\n"
"    escrever_linha('Chamar foo decorado com True')\n"
"    assert foo_decorado(True)"

#: ../../howto/logging-cookbook.rst:3122
msgid "When this script is run, the following output should be observed:"
msgstr "Quando este script é executado, a seguinte saída deve ser observada:"

#: ../../howto/logging-cookbook.rst:3124
msgid ""
"Calling undecorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling undecorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"about to log at CRITICAL ...\n"
"Calling decorated foo with False\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"Calling decorated foo with True\n"
"about to log at DEBUG ...\n"
"about to log at INFO ...\n"
"about to log at WARNING ...\n"
"about to log at ERROR ...\n"
"Actually logged at DEBUG\n"
"Actually logged at INFO\n"
"Actually logged at WARNING\n"
"Actually logged at ERROR\n"
"about to log at CRITICAL ...\n"
"Actually logged at CRITICAL"
msgstr ""
"A chamar foo não decorado com False\n"
"prestes a registar em DEBUG ...\n"
"prestes a registar em INFO ...\n"
"prestes a registar em WARNING ...\n"
"A chamar foo não decorado com True\n"
"prestes a registar em DEBUG ...\n"
"prestes a registar em INFO ...\n"
"prestes a registar em WARNING ...\n"
"prestes a registar em ERROR ...\n"
"prestes a registar em CRITICAL ...\n"
"A chamar foo decorado com False\n"
"prestes a registar em DEBUG ...\n"
"prestes a registar em INFO ...\n"
"prestes a registar em WARNING ...\n"
"A chamar foo decorado com True\n"
"prestes a registar em DEBUG ...\n"
"prestes a registar em INFO ...\n"
"prestes a registar em WARNING ...\n"
"prestes a registar em ERROR ...\n"
"Realmente registado em DEBUG\n"
"Realmente registado em INFO\n"
"Realmente registado em WARNING\n"
"Realmente registado em ERROR\n"
"prestes a registar em CRITICAL ...\n"
"Realmente registado em CRITICAL"

#: ../../howto/logging-cookbook.rst:3152
msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at "
"lower severities are also logged."
msgstr ""
"Como pode ver, a saída real de registo só ocorre quando um evento é "
"registado com gravidade ERROR ou superior, mas nesse caso, quaisquer eventos "
"anteriores com gravidades mais baixas também são registados."

#: ../../howto/logging-cookbook.rst:3156
msgid "You can of course use the conventional means of decoration::"
msgstr "Pode, claro, usar os meios convencionais de decoração:"

#: ../../howto/logging-cookbook.rst:3158
msgid ""
"@log_if_errors(logger)\n"
"def foo(fail=False):\n"
"    ..."
msgstr ""
"@registar_se_erros(logger)\n"
"def foo(falhar=False):\n"
"    ..."

#: ../../howto/logging-cookbook.rst:3166
msgid "Sending logging messages to email, with buffering"
msgstr "Enviar mensagens de registo por email, com armazenamento em buffer"

#: ../../howto/logging-cookbook.rst:3168
msgid ""
"To illustrate how you can send log messages via email, so that a set number "
"of messages are sent per email, you can subclass :class:`~logging.handlers."
"BufferingHandler`. In the following  example, which you can adapt to suit "
"your specific needs, a simple test harness is provided which allows you to "
"run the script with command line arguments specifying what you typically "
"need to send things via SMTP. (Run the downloaded script with the ``-h`` "
"argument to see the required and optional arguments.)"
msgstr ""
"Para ilustrar como pode enviar mensagens de registo por email, de forma a "
"que um número definido de mensagens seja enviado por email, pode criar uma "
"subclasse de :class:`~logging.handlers.BufferingHandler`. No exemplo "
"seguinte, que pode adaptar às suas necessidades específicas, é fornecido um "
"simples mecanismo de teste que permite executar o script com argumentos de "
"linha de comandos que especificam o que normalmente precisa para enviar "
"coisas via SMTP. (Execute o script descarregado com o argumento ``-h`` para "
"ver os argumentos obrigatórios e opcionais.)"

#: ../../howto/logging-cookbook.rst:3176
msgid ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class BufferingSMTPHandler(logging.handlers.BufferingHandler):\n"
"    def __init__(self, mailhost, port, username, password, fromaddr, "
"toaddrs,\n"
"                 subject, capacity):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacity)\n"
"        self.mailhost = mailhost\n"
"        self.mailport = port\n"
"        self.username = username\n"
"        self.password = password\n"
"        self.fromaddr = fromaddr\n"
"        if isinstance(toaddrs, str):\n"
"            toaddrs = [toaddrs]\n"
"        self.toaddrs = toaddrs\n"
"        self.subject = subject\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s "
"%(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.mailhost, self.mailport)\n"
"                smtp.starttls()\n"
"                smtp.login(self.username, self.password)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n\" "
"% (self.fromaddr, ','.join(self.toaddrs), self.subject)\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='SMTP server')\n"
"    aa('--port', '-p', type=int, default=587, help='SMTP port')\n"
"    aa('user', metavar='USER', help='SMTP username')\n"
"    aa('password', metavar='PASSWORD', help='SMTP password')\n"
"    aa('to', metavar='TO', help='Addressee for emails')\n"
"    aa('sender', metavar='SENDER', help='Sender email address')\n"
"    aa('--subject', '-s',\n"
"       default='Test Logging email from Python logging module (buffering)',\n"
"       help='Subject of email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = BufferingSMTPHandler(options.host, options.port, options.user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Info index = %d\", i)\n"
"    h.flush()\n"
"    h.close()"
msgstr ""
"import logging\n"
"import logging.handlers\n"
"import smtplib\n"
"\n"
"class ManipuladorSMTPBufferizado(logging.handlers.BufferingHandler):\n"
"    def __init__(self, servidor_email, porta, nome_utilizador, "
"palavra_passe, remetente, destinatarios,\n"
"                 assunto, capacidade):\n"
"        logging.handlers.BufferingHandler.__init__(self, capacidade)\n"
"        self.servidor_email = servidor_email\n"
"        self.porta_email = porta\n"
"        self.nome_utilizador = nome_utilizador\n"
"        self.palavra_passe = palavra_passe\n"
"        self.remetente = remetente\n"
"        if isinstance(destinatarios, str):\n"
"            destinatarios = [destinatarios]\n"
"        self.destinatarios = destinatarios\n"
"        self.assunto = assunto\n"
"        self.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-5s "
"%(message)s\"))\n"
"\n"
"    def flush(self):\n"
"        if len(self.buffer) > 0:\n"
"            try:\n"
"                smtp = smtplib.SMTP(self.servidor_email, self.porta_email)\n"
"                smtp.starttls()\n"
"                smtp.login(self.nome_utilizador, self.palavra_passe)\n"
"                msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\n\\r\\n\" "
"% (self.remetente, ','.join(self.destinatarios), self.assunto)\n"
"                for record in self.buffer:\n"
"                    s = self.format(record)\n"
"                    msg = msg + s + \"\\r\\n\"\n"
"                smtp.sendmail(self.remetente, self.destinatarios, msg)\n"
"                smtp.quit()\n"
"            except Exception:\n"
"                if logging.raiseExceptions:\n"
"                    raise\n"
"            self.buffer = []\n"
"\n"
"if __name__ == '__main__':\n"
"    import argparse\n"
"\n"
"    ap = argparse.ArgumentParser()\n"
"    aa = ap.add_argument\n"
"    aa('host', metavar='HOST', help='Servidor SMTP')\n"
"    aa('--port', '-p', type=int, default=587, help='Porta SMTP')\n"
"    aa('user', metavar='UTILIZADOR', help='Nome de utilizador SMTP')\n"
"    aa('password', metavar='PASSWORD', help='Palavra-passe SMTP')\n"
"    aa('to', metavar='PARA', help='Destinatário para emails')\n"
"    aa('sender', metavar='REMETENTE', help='Endereço de email do "
"remetente')\n"
"    aa('--subject', '-s',\n"
"       default='Teste de email de registo do módulo de registo Python (com "
"bufferização)',\n"
"       help='Assunto do email')\n"
"    options = ap.parse_args()\n"
"    logger = logging.getLogger()\n"
"    logger.setLevel(logging.DEBUG)\n"
"    h = ManipuladorSMTPBufferizado(options.host, options.port, options."
"user,\n"
"                             options.password, options.sender,\n"
"                             options.to, options.subject, 10)\n"
"    logger.addHandler(h)\n"
"    for i in range(102):\n"
"        logger.info(\"Índice de info = %d\", i)\n"
"    h.flush()\n"
"    h.close()"

#: ../../howto/logging-cookbook.rst:3240
msgid ""
"If you run this script and your SMTP server is correctly set up, you should "
"find that it sends eleven emails to the addressee you specify. The first ten "
"emails will each have ten log messages, and the eleventh will have two "
"messages. That makes up 102 messages as specified in the script."
msgstr ""
"Se executar este script e o seu servidor SMTP estiver corretamente "
"configurado, deve verificar que ele envia onze emails para o destinatário "
"que especificar. Os primeiros dez emails terão cada um dez mensagens de "
"registo, e o décimo primeiro terá duas mensagens. Isso totaliza 102 "
"mensagens, como especificado no script."

#: ../../howto/logging-cookbook.rst:3248
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "Formatar tempos usando UTC (GMT) através de configuração"

#: ../../howto/logging-cookbook.rst:3250
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr ""
"Às vezes, deseja formatar tempos usando UTC, o que pode ser feito usando uma "
"classe como ``UTCFormatter``, mostrada abaixo:"

#: ../../howto/logging-cookbook.rst:3253
msgid ""
"import logging\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime"
msgstr ""
"import logging\n"
"import time\n"
"\n"
"class FormatadorUTC(logging.Formatter):\n"
"    converter = time.gmtime"

#: ../../howto/logging-cookbook.rst:3259
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of :class:"
"`~logging.Formatter`. If you want to do that via configuration, you can use "
"the :func:`~logging.config.dictConfig` API with an approach illustrated by "
"the following complete example::"
msgstr ""
"e pode então usar o ``UTCFormatter`` no seu código em vez de :class:"
"`~logging.Formatter`. Se quiser fazer isso através de configuração, pode "
"usar a API :func:`~logging.config.dictConfig` com uma abordagem ilustrada "
"pelo seguinte exemplo completo:"

#: ../../howto/logging-cookbook.rst:3264
msgid ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class UTCFormatter(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': UTCFormatter,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'console1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'console2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['console1', 'console2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('The local time is %s', time.asctime())"
msgstr ""
"import logging\n"
"import logging.config\n"
"import time\n"
"\n"
"class FormatadorUTC(logging.Formatter):\n"
"    converter = time.gmtime\n"
"\n"
"LOGGING = {\n"
"    'version': 1,\n"
"    'disable_existing_loggers': False,\n"
"    'formatters': {\n"
"        'utc': {\n"
"            '()': FormatadorUTC,\n"
"            'format': '%(asctime)s %(message)s',\n"
"        },\n"
"        'local': {\n"
"            'format': '%(asctime)s %(message)s',\n"
"        }\n"
"    },\n"
"    'handlers': {\n"
"        'consola1': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'utc',\n"
"        },\n"
"        'consola2': {\n"
"            'class': 'logging.StreamHandler',\n"
"            'formatter': 'local',\n"
"        },\n"
"    },\n"
"    'root': {\n"
"        'handlers': ['consola1', 'consola2'],\n"
"   }\n"
"}\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.config.dictConfig(LOGGING)\n"
"    logging.warning('A hora local é %s', time.asctime())"

#: ../../howto/logging-cookbook.rst:3302
msgid "When this script is run, it should print something like:"
msgstr "Quando este script é executado, deve imprimir algo como:"

#: ../../howto/logging-cookbook.rst:3304
msgid ""
"2015-10-17 12:53:29,501 The local time is Sat Oct 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 The local time is Sat Oct 17 13:53:29 2015"
msgstr ""
"2015-10-17 12:53:29,501 A hora local é Sáb Out 17 13:53:29 2015\n"
"2015-10-17 13:53:29,501 A hora local é Sáb Out 17 13:53:29 2015"

#: ../../howto/logging-cookbook.rst:3309
msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr ""
"mostrando como a hora é formatada tanto como hora local quanto UTC, uma para "
"cada manipulador."

#: ../../howto/logging-cookbook.rst:3316
msgid "Using a context manager for selective logging"
msgstr "Utilizar um gestor de contexto para registo seletivo"

#: ../../howto/logging-cookbook.rst:3318
msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context. "
"Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"Existem momentos em que seria útil alterar temporariamente a configuração de "
"registo e reverter depois de fazer algo. Para isso, um gestor de contexto é "
"a forma mais óbvia de guardar e restaurar o contexto de registo. Aqui está "
"um exemplo simples de um gestor de contexto, que permite alterar "
"opcionalmente o nível de registo e adicionar um manipulador de registo "
"apenas no âmbito do gestor de contexto:"

#: ../../howto/logging-cookbook.rst:3325
msgid ""
"import logging\n"
"import sys\n"
"\n"
"class LoggingContext:\n"
"    def __init__(self, logger, level=None, handler=None, close=True):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"        self.handler = handler\n"
"        self.close = close\n"
"\n"
"    def __enter__(self):\n"
"        if self.level is not None:\n"
"            self.old_level = self.logger.level\n"
"            self.logger.setLevel(self.level)\n"
"        if self.handler:\n"
"            self.logger.addHandler(self.handler)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.level is not None:\n"
"            self.logger.setLevel(self.old_level)\n"
"        if self.handler:\n"
"            self.logger.removeHandler(self.handler)\n"
"        if self.handler and self.close:\n"
"            self.handler.close()\n"
"        # implicit return of None => don't swallow exceptions"
msgstr ""
"import logging\n"
"import sys\n"
"\n"
"class ContextoRegisto:\n"
"    def __init__(self, registador, nivel=None, manipulador=None, "
"fechar=True):\n"
"        self.registador = registador\n"
"        self.nivel = nivel\n"
"        self.manipulador = manipulador\n"
"        self.fechar = fechar\n"
"\n"
"    def __enter__(self):\n"
"        if self.nivel is not None:\n"
"            self.nivel_antigo = self.registador.level\n"
"            self.registador.setLevel(self.nivel)\n"
"        if self.manipulador:\n"
"            self.registador.addHandler(self.manipulador)\n"
"\n"
"    def __exit__(self, et, ev, tb):\n"
"        if self.nivel is not None:\n"
"            self.registador.setLevel(self.nivel_antigo)\n"
"        if self.manipulador:\n"
"            self.registador.removeHandler(self.manipulador)\n"
"        if self.manipulador and self.fechar:\n"
"            self.manipulador.close()\n"
"        # retorno implícito de None => não engolir exceções"

#: ../../howto/logging-cookbook.rst:3351
msgid ""
"If you specify a level value, the logger's level is set to that value in the "
"scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit "
"from the block. You can also ask the manager to close the handler for you on "
"block exit - you could do this if you don't need the handler any more."
msgstr ""
"Se especificar um valor de nível, o nível do registador é definido para esse "
"valor no âmbito do bloco with coberto pelo gestor de contexto. Se "
"especificar um manipulador, ele é adicionado ao registador na entrada do "
"bloco e removido na saída do bloco. Também pode pedir ao gestor para fechar "
"o manipulador por si na saída do bloco — pode fazer isto se não precisar "
"mais do manipulador."

#: ../../howto/logging-cookbook.rst:3357
msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr ""
"Para ilustrar como funciona, podemos adicionar o seguinte bloco de código ao "
"acima:"

#: ../../howto/logging-cookbook.rst:3360
msgid ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. This should appear just once on stderr.')\n"
"    logger.debug('2. This should not appear.')\n"
"    with LoggingContext(logger, level=logging.DEBUG):\n"
"        logger.debug('3. This should appear once on stderr.')\n"
"    logger.debug('4. This should not appear.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with LoggingContext(logger, level=logging.DEBUG, handler=h, "
"close=True):\n"
"        logger.debug('5. This should appear twice - once on stderr and once "
"on stdout.')\n"
"    logger.info('6. This should appear just once on stderr.')\n"
"    logger.debug('7. This should not appear.')"
msgstr ""
"if __name__ == '__main__':\n"
"    logger = logging.getLogger('foo')\n"
"    logger.addHandler(logging.StreamHandler())\n"
"    logger.setLevel(logging.INFO)\n"
"    logger.info('1. Isto deve aparecer apenas uma vez em stderr.')\n"
"    logger.debug('2. Isto não deve aparecer.')\n"
"    with ContextoRegisto(logger, nivel=logging.DEBUG):\n"
"        logger.debug('3. Isto deve aparecer uma vez em stderr.')\n"
"    logger.debug('4. Isto não deve aparecer.')\n"
"    h = logging.StreamHandler(sys.stdout)\n"
"    with ContextoRegisto(logger, nivel=logging.DEBUG, manipulador=h, "
"fechar=True):\n"
"        logger.debug('5. Isto deve aparecer duas vezes - uma vez em stderr e "
"uma vez em stdout.')\n"
"    logger.info('6. Isto deve aparecer apenas uma vez em stderr.')\n"
"    logger.debug('7. Isto não deve aparecer.')"

#: ../../howto/logging-cookbook.rst:3375
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the "
"following ``with`` block, and so message #3 appears. After the block exits, "
"the logger's level is restored to ``INFO`` and so message #4 doesn't appear. "
"In the next ``with`` block, we set the level to ``DEBUG`` again but also add "
"a handler writing to ``sys.stdout``. Thus, message #5 appears twice on the "
"console (once via ``stderr`` and once via ``stdout``). After the ``with`` "
"statement's completion, the status is as it was before so message #6 appears "
"(like message #1) whereas message #7 doesn't (just like message #2)."
msgstr ""
"Inicialmente, definimos o nível do registador para ``INFO``, então a "
"mensagem #1 aparece e a mensagem #2 não. Depois, alteramos o nível para "
"``DEBUG`` temporariamente no bloco ``with`` seguinte, e assim a mensagem #3 "
"aparece. Após a saída do bloco, o nível do registador é restaurado para "
"``INFO`` e, portanto, a mensagem #4 não aparece. No próximo bloco ``with``, "
"definimos o nível para ``DEBUG`` novamente, mas também adicionamos um "
"manipulador que escreve para ``sys.stdout``. Assim, a mensagem #5 aparece "
"duas vezes na consola (uma vez via ``stderr`` e outra via ``stdout``). Após "
"a conclusão da instrução ``with``, o estado é como estava antes, então a "
"mensagem #6 aparece (como a mensagem #1), enquanto a mensagem #7 não aparece "
"(assim como a mensagem #2)."

#: ../../howto/logging-cookbook.rst:3385
msgid "If we run the resulting script, the result is as follows:"
msgstr "Se executarmos o script resultante, o resultado é o seguinte:"

#: ../../howto/logging-cookbook.rst:3387
msgid ""
"$ python logctx.py\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""

#: ../../howto/logging-cookbook.rst:3396
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"Se o executarmos novamente, mas redirecionarmos ``stderr`` para ``/dev/"
"null``, vemos o seguinte, que é a única mensagem escrita em ``stdout``:"

#: ../../howto/logging-cookbook.rst:3399
msgid ""
"$ python logctx.py 2>/dev/null\n"
"5. This should appear twice - once on stderr and once on stdout."
msgstr ""

#: ../../howto/logging-cookbook.rst:3404
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr ""
"Mais uma vez, mas redirecionando ``stdout`` para ``/dev/null``, obtemos:"

#: ../../howto/logging-cookbook.rst:3406
msgid ""
"$ python logctx.py >/dev/null\n"
"1. This should appear just once on stderr.\n"
"3. This should appear once on stderr.\n"
"5. This should appear twice - once on stderr and once on stdout.\n"
"6. This should appear just once on stderr."
msgstr ""

#: ../../howto/logging-cookbook.rst:3414
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr ""
"Neste caso, a mensagem #5 impressa em ``stdout`` não aparece, como esperado."

#: ../../howto/logging-cookbook.rst:3416
msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python "
"2 as well as Python 3."
msgstr ""
"Claro, a abordagem descrita aqui pode ser generalizada, por exemplo, para "
"anexar filtros de registo temporariamente. Note que o código acima funciona "
"em Python 2 e também em Python 3."

#: ../../howto/logging-cookbook.rst:3424
msgid "A CLI application starter template"
msgstr "Um modelo inicial para uma aplicação CLI"

#: ../../howto/logging-cookbook.rst:3426
msgid "Here's an example which shows how you can:"
msgstr "Aqui está um exemplo que mostra como pode:"

#: ../../howto/logging-cookbook.rst:3428
msgid "Use a logging level based on command-line arguments"
msgstr ""
"Utilizar um nível de registo baseado em argumentos de linha de comandos"

#: ../../howto/logging-cookbook.rst:3429
msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr ""
"Enviar para vários subcomandos em ficheiros separados, todos a registar no "
"mesmo nível de forma consistente"

#: ../../howto/logging-cookbook.rst:3431
msgid "Make use of simple, minimal configuration"
msgstr "Utilizar uma configuração simples e mínima"

#: ../../howto/logging-cookbook.rst:3433
msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, ``stop."
"py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"Suponha que temos uma aplicação de linha de comandos cujo trabalho é parar, "
"iniciar ou reiniciar alguns serviços. Isto pode ser organizado, para fins de "
"ilustração, como um ficheiro ``app.py`` que é o script principal da "
"aplicação, com comandos individuais implementados em ``start.py``, ``stop."
"py`` e ``restart.py``. Suponha ainda que queremos controlar a verbosidade da "
"aplicação através de um argumento de linha de comandos, com o valor "
"predefinido ``logging.INFO``. Aqui está uma forma de como ``app.py`` poderia "
"ser escrito:"

#: ../../howto/logging-cookbook.rst:3441
msgid ""
"import argparse\n"
"import importlib\n"
"import logging\n"
"import os\n"
"import sys\n"
"\n"
"def main(args=None):\n"
"    scriptname = os.path.basename(__file__)\n"
"    parser = argparse.ArgumentParser(scriptname)\n"
"    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n"
"    parser.add_argument('--log-level', default='INFO', choices=levels)\n"
"    subparsers = parser.add_subparsers(dest='command',\n"
"                                       help='Available commands:')\n"
"    start_cmd = subparsers.add_parser('start', help='Start a service')\n"
"    start_cmd.add_argument('name', metavar='NAME',\n"
"                           help='Name of service to start')\n"
"    stop_cmd = subparsers.add_parser('stop',\n"
"                                     help='Stop one or more services')\n"
"    stop_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                          help='Name of service to stop')\n"
"    restart_cmd = subparsers.add_parser('restart',\n"
"                                        help='Restart one or more "
"services')\n"
"    restart_cmd.add_argument('names', metavar='NAME', nargs='+',\n"
"                             help='Name of service to restart')\n"
"    options = parser.parse_args()\n"
"    # the code to dispatch commands could all be in this file. For the "
"purposes\n"
"    # of illustration only, we implement each command in a separate module.\n"
"    try:\n"
"        mod = importlib.import_module(options.command)\n"
"        cmd = getattr(mod, 'command')\n"
"    except (ImportError, AttributeError):\n"
"        print('Unable to find the code for command \\'%s\\'' % options."
"command)\n"
"        return 1\n"
"    # Could get fancy here and load configuration from file or dictionary\n"
"    logging.basicConfig(level=options.log_level,\n"
"                        format='%(levelname)s %(name)s %(message)s')\n"
"    cmd(options)\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())"
msgstr ""
"import argparse\n"
"import importlib\n"
"import logging\n"
"import os\n"
"import sys\n"
"\n"
"def main(args=None):\n"
"    scriptname = os.path.basename(__file__)\n"
"    parser = argparse.ArgumentParser(scriptname)\n"
"    levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')\n"
"    parser.add_argument('--log-level', default='INFO', choices=levels)\n"
"    subparsers = parser.add_subparsers(dest='command',\n"
"                                       help='Comandos disponíveis:')\n"
"    start_cmd = subparsers.add_parser('start', help='Iniciar um serviço')\n"
"    start_cmd.add_argument('name', metavar='NOME',\n"
"                           help='Nome do serviço a iniciar')\n"
"    stop_cmd = subparsers.add_parser('stop',\n"
"                                     help='Parar um ou mais serviços')\n"
"    stop_cmd.add_argument('names', metavar='NOME', nargs='+',\n"
"                          help='Nome do serviço a parar')\n"
"    restart_cmd = subparsers.add_parser('restart',\n"
"                                        help='Reiniciar um ou mais "
"serviços')\n"
"    restart_cmd.add_argument('names', metavar='NOME', nargs='+',\n"
"                             help='Nome do serviço a reiniciar')\n"
"    options = parser.parse_args()\n"
"    # o código para enviar comandos poderia estar todo neste ficheiro. "
"Apenas para fins\n"
"    # de ilustração, implementamos cada comando num módulo separado.\n"
"    try:\n"
"        mod = importlib.import_module(options.command)\n"
"        cmd = getattr(mod, 'command')\n"
"    except (ImportError, AttributeError):\n"
"        print('Não foi possível encontrar o código para o comando \\'%s\\'' "
"% options.command)\n"
"        return 1\n"
"    # Poderia ser mais sofisticado aqui e carregar a configuração de um "
"ficheiro ou dicionário\n"
"    logging.basicConfig(level=options.log_level,\n"
"                        format='%(levelname)s %(name)s %(message)s')\n"
"    cmd(options)\n"
"\n"
"if __name__ == '__main__':\n"
"    sys.exit(main())"

#: ../../howto/logging-cookbook.rst:3482
msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr ""
"E os comandos ``start``, ``stop`` e ``restart`` podem ser implementados em "
"módulos separados, como este para iniciar:"

#: ../../howto/logging-cookbook.rst:3485
msgid ""
"# start.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    logger.debug('About to start %s', options.name)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Started the \\'%s\\' service.', options.name)"
msgstr ""
"# start.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    logger.debug('Prestes a iniciar %s', options.name)\n"
"    # realmente fazer o processamento do comando aqui...\n"
"    logger.info('Iniciado o serviço \\'%s\\'.', options.name)"

#: ../../howto/logging-cookbook.rst:3495
msgid "and thus for stopping::"
msgstr "e assim para parar:"

#: ../../howto/logging-cookbook.rst:3497
msgid ""
"# stop.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to stop %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Stopped the %s service%s.', services, plural)"
msgstr ""
"# stop.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' e ' + services[i + 2:]\n"
"    logger.debug('Prestes a parar %s', services)\n"
"    # realmente fazer o processamento do comando aqui...\n"
"    logger.info('Parado o serviço %s%s.', services, plural)"

#: ../../howto/logging-cookbook.rst:3516
msgid "and similarly for restarting::"
msgstr "e de forma semelhante para reiniciar:"

#: ../../howto/logging-cookbook.rst:3518
msgid ""
"# restart.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' and ' + services[i + 2:]\n"
"    logger.debug('About to restart %s', services)\n"
"    # actually do the command processing here ...\n"
"    logger.info('Restarted the %s service%s.', services, plural)"
msgstr ""
"# restart.py\n"
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"def command(options):\n"
"    n = len(options.names)\n"
"    if n == 1:\n"
"        plural = ''\n"
"        services = '\\'%s\\'' % options.names[0]\n"
"    else:\n"
"        plural = 's'\n"
"        services = ', '.join('\\'%s\\'' % name for name in options.names)\n"
"        i = services.rfind(', ')\n"
"        services = services[:i] + ' e ' + services[i + 2:]\n"
"    logger.debug('Prestes a reiniciar %s', services)\n"
"    # realmente fazer o processamento do comando aqui...\n"
"    logger.info('Reiniciado o serviço %s%s.', services, plural)"

#: ../../howto/logging-cookbook.rst:3537
msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr ""
"Se executarmos esta aplicação com o nível de registo predefinido, obtemos "
"uma saída como esta:"

#: ../../howto/logging-cookbook.rst:3539
msgid ""
"$ python app.py start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py stop foo bar\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py restart foo bar baz\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""

#: ../../howto/logging-cookbook.rst:3550
msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr ""
"A primeira palavra é o nível de registo, e a segunda palavra é o nome do "
"módulo ou pacote do local onde o evento foi registado."

#: ../../howto/logging-cookbook.rst:3553
msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr ""
"Se alterarmos o nível de registo, podemos alterar as informações enviadas "
"para o registo. Por exemplo, se quisermos mais informações:"

#: ../../howto/logging-cookbook.rst:3556
msgid ""
"$ python app.py --log-level DEBUG start foo\n"
"DEBUG start About to start foo\n"
"INFO start Started the 'foo' service.\n"
"\n"
"$ python app.py --log-level DEBUG stop foo bar\n"
"DEBUG stop About to stop 'foo' and 'bar'\n"
"INFO stop Stopped the 'foo' and 'bar' services.\n"
"\n"
"$ python app.py --log-level DEBUG restart foo bar baz\n"
"DEBUG restart About to restart 'foo', 'bar' and 'baz'\n"
"INFO restart Restarted the 'foo', 'bar' and 'baz' services."
msgstr ""

#: ../../howto/logging-cookbook.rst:3570
msgid "And if we want less:"
msgstr "E se quisermos menos:"

#: ../../howto/logging-cookbook.rst:3572
msgid ""
"$ python app.py --log-level WARNING start foo\n"
"$ python app.py --log-level WARNING stop foo bar\n"
"$ python app.py --log-level WARNING restart foo bar baz"
msgstr ""

#: ../../howto/logging-cookbook.rst:3578
msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr ""
"Neste caso, os comandos não imprimem nada na consola, uma vez que nada no "
"nível ``WARNING`` ou acima é registado por eles."

#: ../../howto/logging-cookbook.rst:3584
msgid "A Qt GUI for logging"
msgstr "Uma GUI Qt para registo"

#: ../../howto/logging-cookbook.rst:3586
msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using :pypi:`PySide2` or :pypi:"
"`PyQt5` libraries."
msgstr ""
"Uma questão que surge de vez em quando é sobre como registar numa aplicação "
"GUI. O framework `Qt <https://www.qt.io/>`_ é um popular framework de "
"interface de utilizador multiplataforma com ligações Python usando as "
"bibliotecas :pypi:`PySide2` ou :pypi:`PyQt5`."

#: ../../howto/logging-cookbook.rst:3591
msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple "
"``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just "
"logging messages at random levels with random short delays in between)."
msgstr ""
"O exemplo seguinte mostra como registar numa GUI Qt. Isto introduz uma "
"classe ``QtHandler`` simples que recebe um objeto chamável, que deve ser um "
"slot na thread principal que faz atualizações de GUI. Uma thread de trabalho "
"também é criada para mostrar como pode registar na GUI tanto a partir da "
"própria UI (através de um botão para registo manual) como de uma thread de "
"trabalho que faz trabalho em segundo plano (aqui, apenas registando "
"mensagens em níveis aleatórios com atrasos curtos aleatórios entre elas)."

#: ../../howto/logging-cookbook.rst:3598
msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use "
"``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"A thread de trabalho é implementada usando a classe ``QThread`` do Qt em vez "
"do módulo :mod:`threading`, uma vez que existem circunstâncias em que é "
"necessário usar ``QThread``, que oferece melhor integração com outros "
"componentes ``Qt``."

#: ../../howto/logging-cookbook.rst:3602
msgid ""
"The code should work with recent releases of any of ``PySide6``, ``PyQt6``, "
"``PySide2`` or ``PyQt5``. You should be able to adapt the approach to "
"earlier versions of Qt. Please refer to the comments in the code snippet for "
"more detailed information."
msgstr ""
"O código deve funcionar com versões recentes de qualquer uma das bibliotecas "
"``PySide6``, ``PyQt6``, ``PySide2`` ou ``PyQt5``. Deve ser capaz de adaptar "
"a abordagem a versões anteriores do Qt. Consulte os comentários no trecho de "
"código para obter mais informações detalhadas."

#: ../../howto/logging-cookbook.rst:3607
msgid ""
"import datetime\n"
"import logging\n"
"import random\n"
"import sys\n"
"import time\n"
"\n"
"# Deal with minor differences between different Qt packages\n"
"try:\n"
"    from PySide6 import QtCore, QtGui, QtWidgets\n"
"    Signal = QtCore.Signal\n"
"    Slot = QtCore.Slot\n"
"except ImportError:\n"
"    try:\n"
"        from PyQt6 import QtCore, QtGui, QtWidgets\n"
"        Signal = QtCore.pyqtSignal\n"
"        Slot = QtCore.pyqtSlot\n"
"    except ImportError:\n"
"        try:\n"
"            from PySide2 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.Signal\n"
"            Slot = QtCore.Slot\n"
"        except ImportError:\n"
"            from PyQt5 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.pyqtSignal\n"
"            Slot = QtCore.pyqtSlot\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"#\n"
"# Signals need to be contained in a QObject or subclass in order to be "
"correctly\n"
"# initialized.\n"
"#\n"
"class Signaller(QtCore.QObject):\n"
"    signal = Signal(str, logging.LogRecord)\n"
"\n"
"#\n"
"# Output to a Qt GUI is only supposed to happen on the main thread. So, "
"this\n"
"# handler is designed to take a slot function which is set up to run in the "
"main\n"
"# thread. In this example, the function takes a string argument which is a\n"
"# formatted log message, and the log record which generated it. The "
"formatted\n"
"# string is just a convenience - you could format a string for output any "
"way\n"
"# you like in the slot function itself.\n"
"#\n"
"# You specify the slot function to do whatever GUI updates you want. The "
"handler\n"
"# doesn't know or care about specific UI elements.\n"
"#\n"
"class QtHandler(logging.Handler):\n"
"    def __init__(self, slotfunc, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"        self.signaller = Signaller()\n"
"        self.signaller.signal.connect(slotfunc)\n"
"\n"
"    def emit(self, record):\n"
"        s = self.format(record)\n"
"        self.signaller.signal.emit(s, record)\n"
"\n"
"#\n"
"# This example uses QThreads, which means that the threads at the Python "
"level\n"
"# are named something like \"Dummy-1\". The function below gets the Qt name "
"of the\n"
"# current thread.\n"
"#\n"
"def ctname():\n"
"    return QtCore.QThread.currentThread().objectName()\n"
"\n"
"\n"
"#\n"
"# Used to generate random levels for logging.\n"
"#\n"
"LEVELS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"\n"
"#\n"
"# This worker class represents work that is done in a thread separate to "
"the\n"
"# main thread. The way the thread is kicked off to do work is via a button "
"press\n"
"# that connects to a slot in the worker.\n"
"#\n"
"# Because the default threadName value in the LogRecord isn't much use, we "
"add\n"
"# a qThreadName which contains the QThread name as computed above, and pass "
"that\n"
"# value in an \"extra\" dictionary which is used to update the LogRecord "
"with the\n"
"# QThread name.\n"
"#\n"
"# This example worker just outputs messages sequentially, interspersed with\n"
"# random delays of the order of a few seconds.\n"
"#\n"
"class Worker(QtCore.QObject):\n"
"    @Slot()\n"
"    def start(self):\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.debug('Started work', extra=extra)\n"
"        i = 1\n"
"        # Let the thread run until interrupted. This allows reasonably "
"clean\n"
"        # thread termination.\n"
"        while not QtCore.QThread.currentThread().isInterruptionRequested():\n"
"            delay = 0.5 + random.random() * 2\n"
"            time.sleep(delay)\n"
"            try:\n"
"                if random.random() < 0.1:\n"
"                    raise ValueError('Exception raised: %d' % i)\n"
"                else:\n"
"                    level = random.choice(LEVELS)\n"
"                    logger.log(level, 'Message after delay of %3.1f: %d', "
"delay, i, extra=extra)\n"
"            except ValueError as e:\n"
"                logger.exception('Failed: %s', e, extra=extra)\n"
"            i += 1\n"
"\n"
"#\n"
"# Implement a simple UI for this cookbook example. This contains:\n"
"#\n"
"# * A read-only text edit window which holds formatted log messages\n"
"# * A button to start work and log stuff in a separate thread\n"
"# * A button to log something from the main thread\n"
"# * A button to clear the log window\n"
"#\n"
"class Window(QtWidgets.QWidget):\n"
"\n"
"    COLORS = {\n"
"        logging.DEBUG: 'black',\n"
"        logging.INFO: 'blue',\n"
"        logging.WARNING: 'orange',\n"
"        logging.ERROR: 'red',\n"
"        logging.CRITICAL: 'purple',\n"
"    }\n"
"\n"
"    def __init__(self, app):\n"
"        super().__init__()\n"
"        self.app = app\n"
"        self.textedit = te = QtWidgets.QPlainTextEdit(self)\n"
"        # Set whatever the default monospace font is for the platform\n"
"        f = QtGui.QFont('nosuchfont')\n"
"        if hasattr(f, 'Monospace'):\n"
"            f.setStyleHint(f.Monospace)\n"
"        else:\n"
"            f.setStyleHint(f.StyleHint.Monospace)  # for Qt6\n"
"        te.setFont(f)\n"
"        te.setReadOnly(True)\n"
"        PB = QtWidgets.QPushButton\n"
"        self.work_button = PB('Start background work', self)\n"
"        self.log_button = PB('Log a message at a random level', self)\n"
"        self.clear_button = PB('Clear log window', self)\n"
"        self.handler = h = QtHandler(self.update_status)\n"
"        # Remember to use qThreadName rather than threadName in the format "
"string.\n"
"        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'\n"
"        formatter = logging.Formatter(fs)\n"
"        h.setFormatter(formatter)\n"
"        logger.addHandler(h)\n"
"        # Set up to terminate the QThread when we exit\n"
"        app.aboutToQuit.connect(self.force_quit)\n"
"\n"
"        # Lay out all the widgets\n"
"        layout = QtWidgets.QVBoxLayout(self)\n"
"        layout.addWidget(te)\n"
"        layout.addWidget(self.work_button)\n"
"        layout.addWidget(self.log_button)\n"
"        layout.addWidget(self.clear_button)\n"
"        self.setFixedSize(900, 400)\n"
"\n"
"        # Connect the non-worker slots and signals\n"
"        self.log_button.clicked.connect(self.manual_update)\n"
"        self.clear_button.clicked.connect(self.clear_display)\n"
"\n"
"        # Start a new worker thread and connect the slots for the worker\n"
"        self.start_thread()\n"
"        self.work_button.clicked.connect(self.worker.start)\n"
"        # Once started, the button should be disabled\n"
"        self.work_button.clicked.connect(lambda : self.work_button."
"setEnabled(False))\n"
"\n"
"    def start_thread(self):\n"
"        self.worker = Worker()\n"
"        self.worker_thread = QtCore.QThread()\n"
"        self.worker.setObjectName('Worker')\n"
"        self.worker_thread.setObjectName('WorkerThread')  # for qThreadName\n"
"        self.worker.moveToThread(self.worker_thread)\n"
"        # This will start an event loop in the worker thread\n"
"        self.worker_thread.start()\n"
"\n"
"    def kill_thread(self):\n"
"        # Just tell the worker to stop, then tell it to quit and wait for "
"that\n"
"        # to happen\n"
"        self.worker_thread.requestInterruption()\n"
"        if self.worker_thread.isRunning():\n"
"            self.worker_thread.quit()\n"
"            self.worker_thread.wait()\n"
"        else:\n"
"            print('worker has already exited.')\n"
"\n"
"    def force_quit(self):\n"
"        # For use when the window is closed\n"
"        if self.worker_thread.isRunning():\n"
"            self.kill_thread()\n"
"\n"
"    # The functions below update the UI and run in the main thread because\n"
"    # that's where the slots are set up\n"
"\n"
"    @Slot(str, logging.LogRecord)\n"
"    def update_status(self, status, record):\n"
"        color = self.COLORS.get(record.levelno, 'black')\n"
"        s = '<pre><font color=\"%s\">%s</font></pre>' % (color, status)\n"
"        self.textedit.appendHtml(s)\n"
"\n"
"    @Slot()\n"
"    def manual_update(self):\n"
"        # This function uses the formatted message passed in, but also uses\n"
"        # information from the record to format the message in an "
"appropriate\n"
"        # color according to its severity (level).\n"
"        level = random.choice(LEVELS)\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.log(level, 'Manually logged!', extra=extra)\n"
"\n"
"    @Slot()\n"
"    def clear_display(self):\n"
"        self.textedit.clear()\n"
"\n"
"\n"
"def main():\n"
"    QtCore.QThread.currentThread().setObjectName('MainThread')\n"
"    logging.getLogger().setLevel(logging.DEBUG)\n"
"    app = QtWidgets.QApplication(sys.argv)\n"
"    example = Window(app)\n"
"    example.show()\n"
"    if hasattr(app, 'exec'):\n"
"        rc = app.exec()\n"
"    else:\n"
"        rc = app.exec_()\n"
"    sys.exit(rc)\n"
"\n"
"if __name__=='__main__':\n"
"    main()"
msgstr ""
"import datetime\n"
"import logging\n"
"import random\n"
"import sys\n"
"import time\n"
"\n"
"# Lidar com pequenas diferenças entre diferentes pacotes Qt\n"
"try:\n"
"    from PySide6 import QtCore, QtGui, QtWidgets\n"
"    Signal = QtCore.Signal\n"
"    Slot = QtCore.Slot\n"
"except ImportError:\n"
"    try:\n"
"        from PyQt6 import QtCore, QtGui, QtWidgets\n"
"        Signal = QtCore.pyqtSignal\n"
"        Slot = QtCore.pyqtSlot\n"
"    except ImportError:\n"
"        try:\n"
"            from PySide2 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.Signal\n"
"            Slot = QtCore.Slot\n"
"        except ImportError:\n"
"            from PyQt5 import QtCore, QtGui, QtWidgets\n"
"            Signal = QtCore.pyqtSignal\n"
"            Slot = QtCore.pyqtSlot\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"\n"
"#\n"
"# Os sinais precisam de estar contidos num QObject ou subclasse para serem "
"corretamente\n"
"# inicializados.\n"
"#\n"
"class Sinalizador(QtCore.QObject):\n"
"    signal = Signal(str, logging.LogRecord)\n"
"\n"
"#\n"
"# A saída para uma GUI Qt só deve acontecer na thread principal. Assim, "
"este\n"
"# manipulador é projetado para receber uma função slot que é configurada "
"para executar na thread principal.\n"
"# Neste exemplo, a função recebe um argumento de string que é uma mensagem "
"de registo formatada,\n"
"# e o registo que a gerou. A string formatada é apenas uma conveniência - "
"pode formatar uma string\n"
"# para saída da maneira que preferir na própria função slot.\n"
"#\n"
"# Especifica a função slot para fazer as atualizações de GUI que desejar. O "
"manipulador\n"
"# não sabe nem se importa com elementos específicos da UI.\n"
"#\n"
"class ManipuladorQt(logging.Handler):\n"
"    def __init__(self, funcao_slot, *args, **kwargs):\n"
"        super().__init__(*args, **kwargs)\n"
"        self.sinalizador = Sinalizador()\n"
"        self.sinalizador.signal.connect(funcao_slot)\n"
"\n"
"    def emit(self, record):\n"
"        s = self.format(record)\n"
"        self.sinalizador.signal.emit(s, record)\n"
"\n"
"#\n"
"# Este exemplo usa QThreads, o que significa que as threads ao nível do "
"Python\n"
"# são nomeadas algo como \"Dummy-1\". A função abaixo obtém o nome Qt da\n"
"# thread atual.\n"
"#\n"
"def ctname():\n"
"    return QtCore.QThread.currentThread().objectName()\n"
"\n"
"\n"
"#\n"
"# Usado para gerar níveis aleatórios para registo.\n"
"#\n"
"NIVEIS = (logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR,\n"
"          logging.CRITICAL)\n"
"\n"
"#\n"
"# Esta classe de trabalho representa o trabalho que é feito numa thread "
"separada da\n"
"# thread principal. A forma como a thread é iniciada para fazer o trabalho é "
"através de um clique\n"
"# num botão que se conecta a um slot no trabalhador.\n"
"#\n"
"# Porque o valor threadName predefinido no LogRecord não é muito útil, "
"adicionamos\n"
"# um qThreadName que contém o nome QThread como calculado acima, e passamos "
"esse\n"
"# valor num dicionário \"extra\" que é usado para atualizar o LogRecord com "
"o\n"
"# nome QThread.\n"
"#\n"
"# Este trabalhador de exemplo apenas emite mensagens sequencialmente, "
"intercaladas com\n"
"# atrasos aleatórios da ordem de alguns segundos.\n"
"#\n"
"class Trabalhador(QtCore.QObject):\n"
"    @Slot()\n"
"    def start(self):\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.debug('Iniciado trabalho', extra=extra)\n"
"        i = 1\n"
"        # Deixar a thread executar até ser interrompida. Isto permite uma "
"terminação\n"
"        # razoavelmente limpa da thread.\n"
"        while not QtCore.QThread.currentThread().isInterruptionRequested():\n"
"            delay = 0.5 + random.random() * 2\n"
"            time.sleep(delay)\n"
"            try:\n"
"                if random.random() < 0.1:\n"
"                    raise ValueError('Exceção levantada: %d' % i)\n"
"                else:\n"
"                    level = random.choice(NIVEIS)\n"
"                    logger.log(level, 'Mensagem após atraso de %3.1f: %d', "
"delay, i, extra=extra)\n"
"            except ValueError as e:\n"
"                logger.exception('Falhou: %s', e, extra=extra)\n"
"            i += 1\n"
"\n"
"#\n"
"# Implementar uma UI simples para este exemplo do livro de receitas. Isto "
"contém:\n"
"#\n"
"# * Uma janela de edição de texto apenas de leitura que contém mensagens de "
"registo formatadas\n"
"# * Um botão para iniciar o trabalho e registar coisas numa thread separada\n"
"# * Um botão para registar algo a partir da thread principal\n"
"# * Um botão para limpar a janela de registo\n"
"#\n"
"class Janela(QtWidgets.QWidget):\n"
"\n"
"    CORES = {\n"
"        logging.DEBUG: 'black',\n"
"        logging.INFO: 'blue',\n"
"        logging.WARNING: 'orange',\n"
"        logging.ERROR: 'red',\n"
"        logging.CRITICAL: 'purple',\n"
"    }\n"
"\n"
"    def __init__(self, app):\n"
"        super().__init__()\n"
"        self.app = app\n"
"        self.textedit = te = QtWidgets.QPlainTextEdit(self)\n"
"        # Definir a fonte monoespaçada predefinida para a plataforma\n"
"        f = QtGui.QFont('nosuchfont')\n"
"        if hasattr(f, 'Monospace'):\n"
"            f.setStyleHint(f.Monospace)\n"
"        else:\n"
"            f.setStyleHint(f.StyleHint.Monospace)  # para Qt6\n"
"        te.setFont(f)\n"
"        te.setReadOnly(True)\n"
"        PB = QtWidgets.QPushButton\n"
"        self.work_button = PB('Iniciar trabalho em segundo plano', self)\n"
"        self.log_button = PB('Registar uma mensagem num nível aleatório', "
"self)\n"
"        self.clear_button = PB('Limpar janela de registo', self)\n"
"        self.handler = h = ManipuladorQt(self.atualizar_estado)\n"
"        # Lembre-se de usar qThreadName em vez de threadName na string de "
"formato.\n"
"        fs = '%(asctime)s %(qThreadName)-12s %(levelname)-8s %(message)s'\n"
"        formatter = logging.Formatter(fs)\n"
"        h.setFormatter(formatter)\n"
"        logger.addHandler(h)\n"
"        # Configurar para terminar a QThread quando sairmos\n"
"        app.aboutToQuit.connect(self.fechar_forcado)\n"
"\n"
"        # Organizar todos os widgets\n"
"        layout = QtWidgets.QVBoxLayout(self)\n"
"        layout.addWidget(te)\n"
"        layout.addWidget(self.work_button)\n"
"        layout.addWidget(self.log_button)\n"
"        layout.addWidget(self.clear_button)\n"
"        self.setFixedSize(900, 400)\n"
"\n"
"        # Conectar os slots e sinais não trabalhadores\n"
"        self.log_button.clicked.connect(self.atualizacao_manual)\n"
"        self.clear_button.clicked.connect(self.limpar_ecra)\n"
"\n"
"        # Iniciar uma nova thread de trabalho e conectar os slots para o "
"trabalhador\n"
"        self.iniciar_thread()\n"
"        self.work_button.clicked.connect(self.worker.start)\n"
"        # Uma vez iniciado, o botão deve ser desativado\n"
"        self.work_button.clicked.connect(lambda : self.work_button."
"setEnabled(False))\n"
"\n"
"    def iniciar_thread(self):\n"
"        self.worker = Trabalhador()\n"
"        self.worker_thread = QtCore.QThread()\n"
"        self.worker.setObjectName('Worker')\n"
"        self.worker_thread.setObjectName('WorkerThread')  # para "
"qThreadName\n"
"        self.worker.moveToThread(self.worker_thread)\n"
"        # Isto iniciará um loop de eventos na thread de trabalho\n"
"        self.worker_thread.start()\n"
"\n"
"    def matar_thread(self):\n"
"        # Apenas dizer ao trabalhador para parar, depois dizer-lhe para sair "
"e esperar que\n"
"        # isso aconteça\n"
"        self.worker_thread.requestInterruption()\n"
"        if self.worker_thread.isRunning():\n"
"            self.worker_thread.quit()\n"
"            self.worker_thread.wait()\n"
"        else:\n"
"            print('a thread já terminou.')\n"
"\n"
"    def fechar_forcado(self):\n"
"        # Para uso quando a janela é fechada\n"
"        if self.worker_thread.isRunning():\n"
"            self.matar_thread()\n"
"\n"
"    # As funções abaixo atualizam a UI e executam na thread principal "
"porque\n"
"    # é onde os slots são configurados\n"
"\n"
"    @Slot(str, logging.LogRecord)\n"
"    def atualizar_estado(self, estado, record):\n"
"        cor = self.CORES.get(record.levelno, 'black')\n"
"        s = '<pre><font color=\"%s\">%s</font></pre>' % (cor, estado)\n"
"        self.textedit.appendHtml(s)\n"
"\n"
"    @Slot()\n"
"    def atualizacao_manual(self):\n"
"        # Esta função usa a mensagem formatada passada, mas também usa\n"
"        # informações do registo para formatar a mensagem numa cor "
"apropriada\n"
"        # de acordo com a sua gravidade (nível).\n"
"        level = random.choice(NIVEIS)\n"
"        extra = {'qThreadName': ctname() }\n"
"        logger.log(level, 'Registo manual!', extra=extra)\n"
"\n"
"    @Slot()\n"
"    def limpar_ecra(self):\n"
"        self.textedit.clear()\n"
"\n"
"\n"
"def main():\n"
"    QtCore.QThread.currentThread().setObjectName('MainThread')\n"
"    logging.getLogger().setLevel(logging.DEBUG)\n"
"    app = QtWidgets.QApplication(sys.argv)\n"
"    example = Janela(app)\n"
"    example.show()\n"
"    if hasattr(app, 'exec'):\n"
"        rc = app.exec()\n"
"    else:\n"
"        rc = app.exec_()\n"
"    sys.exit(rc)\n"
"\n"
"if __name__=='__main__':\n"
"    main()"

#: ../../howto/logging-cookbook.rst:3839
msgid "Logging to syslog with RFC5424 support"
msgstr "Registar em syslog com suporte para RFC5424"

#: ../../howto/logging-cookbook.rst:3841
msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured by "
"default to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and only "
"existing) protocol at the time. Since RFC5424 came out, as there has not "
"been widespread deployment of it in syslog servers, the :class:`~logging."
"handlers.SysLogHandler` functionality has not been updated."
msgstr ""
"Embora a :rfc:`5424` date de 2009, a maioria dos servidores syslog estão "
"configurados por predefinição para usar a mais antiga :rfc:`3164`, que data "
"de 2001. Quando o ``logging`` foi adicionado ao Python em 2003, suportava o "
"protocolo anterior (e único existente) na altura. Desde que a RFC5424 foi "
"publicada, como não houve uma implementação generalizada nos servidores "
"syslog, a funcionalidade do :class:`~logging.handlers.SysLogHandler` não foi "
"atualizada."

#: ../../howto/logging-cookbook.rst:3848
msgid ""
"RFC 5424 contains some useful features such as support for structured data, "
"and if you need to be able to log to a syslog server with support for it, "
"you can do so with a subclassed handler which looks something like this::"
msgstr ""
"A RFC 5424 contém algumas funcionalidades úteis, como suporte para dados "
"estruturados, e se precisar de registar num servidor syslog com suporte para "
"isso, pode fazê-lo com um manipulador de subclasse que se parece com isto:"

#: ../../howto/logging-cookbook.rst:3852
msgid ""
"import datetime\n"
"import logging.handlers\n"
"import re\n"
"import socket\n"
"import time\n"
"\n"
"class SysLogHandler5424(logging.handlers.SysLogHandler):\n"
"\n"
"    tz_offset = re.compile(r'([+-]\\d{2})(\\d{2})$')\n"
"    escaped = re.compile(r'([\\]\"\\\\])')\n"
"\n"
"    def __init__(self, *args, **kwargs):\n"
"        self.msgid = kwargs.pop('msgid', None)\n"
"        self.appname = kwargs.pop('appname', None)\n"
"        super().__init__(*args, **kwargs)\n"
"\n"
"    def format(self, record):\n"
"        version = 1\n"
"        asctime = datetime.datetime.fromtimestamp(record.created)."
"isoformat()\n"
"        m = self.tz_offset.match(time.strftime('%z'))\n"
"        has_offset = False\n"
"        if m and time.timezone:\n"
"            hrs, mins = m.groups()\n"
"            if int(hrs) or int(mins):\n"
"                has_offset = True\n"
"        if not has_offset:\n"
"            asctime += 'Z'\n"
"        else:\n"
"            asctime += f'{hrs}:{mins}'\n"
"        try:\n"
"            hostname = socket.gethostname()\n"
"        except Exception:\n"
"            hostname = '-'\n"
"        appname = self.appname or '-'\n"
"        procid = record.process\n"
"        msgid = '-'\n"
"        msg = super().format(record)\n"
"        sdata = '-'\n"
"        if hasattr(record, 'structured_data'):\n"
"            sd = record.structured_data\n"
"            # This should be a dict where the keys are SD-ID and the value "
"is a\n"
"            # dict mapping PARAM-NAME to PARAM-VALUE (refer to the RFC for "
"what these\n"
"            # mean)\n"
"            # There's no error checking here - it's purely for illustration, "
"and you\n"
"            # can adapt this code for use in production environments\n"
"            parts = []\n"
"\n"
"            def replacer(m):\n"
"                g = m.groups()\n"
"                return '\\\\' + g[0]\n"
"\n"
"            for sdid, dv in sd.items():\n"
"                part = f'[{sdid}'\n"
"                for k, v in dv.items():\n"
"                    s = str(v)\n"
"                    s = self.escaped.sub(replacer, s)\n"
"                    part += f' {k}=\"{s}\"'\n"
"                part += ']'\n"
"                parts.append(part)\n"
"            sdata = ''.join(parts)\n"
"        return f'{version} {asctime} {hostname} {appname} {procid} {msgid} "
"{sdata} {msg}'"
msgstr ""

#: ../../howto/logging-cookbook.rst:3914
msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above code, "
"and it may be that you have slightly different needs (e.g. for how you pass "
"structural data to the log). Nevertheless, the above should be adaptable to "
"your speciric needs. With the above handler, you'd pass structured data "
"using something like this::"
msgstr ""

#: ../../howto/logging-cookbook.rst:3919
msgid ""
"sd = {\n"
"    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},\n"
"    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}\n"
"}\n"
"extra = {'structured_data': sd}\n"
"i = 1\n"
"logger.debug('Message %d', i, extra=extra)"
msgstr ""
"sd = {\n"
"    'foo@12345': {'bar': 'baz', 'baz': 'bozz', 'fizz': r'buzz'},\n"
"    'foo@54321': {'rab': 'baz', 'zab': 'bozz', 'zzif': r'buzz'}\n"
"}\n"
"extra = {'structured_data': sd}\n"
"i = 1\n"
"logger.debug('Mensagem %d', i, extra=extra)"

#: ../../howto/logging-cookbook.rst:3928
msgid "How to treat a logger like an output stream"
msgstr "Como tratar um registador como um fluxo de saída"

#: ../../howto/logging-cookbook.rst:3930
msgid ""
"Sometimes, you need to interface to a third-party API which expects a file-"
"like object to write to, but you want to direct the API's output to a "
"logger. You can do this using a class which wraps a logger with a file-like "
"API. Here's a short script illustrating such a class:"
msgstr ""
"Às vezes, precisa de interagir com uma API de terceiros que espera um objeto "
"semelhante a um ficheiro para escrever, mas deseja direcionar a saída da API "
"para um registador. Pode fazer isto usando uma classe que envolve um "
"registador com uma API semelhante a um ficheiro. Aqui está um script curto "
"que ilustra tal classe:"

#: ../../howto/logging-cookbook.rst:3935
msgid ""
"import logging\n"
"\n"
"class LoggerWriter:\n"
"    def __init__(self, logger, level):\n"
"        self.logger = logger\n"
"        self.level = level\n"
"\n"
"    def write(self, message):\n"
"        if message != '\\n':  # avoid printing bare newlines, if you like\n"
"            self.logger.log(self.level, message)\n"
"\n"
"    def flush(self):\n"
"        # doesn't actually do anything, but might be expected of a file-"
"like\n"
"        # object - so optional depending on your situation\n"
"        pass\n"
"\n"
"    def close(self):\n"
"        # doesn't actually do anything, but might be expected of a file-"
"like\n"
"        # object - so optional depending on your situation. You might want\n"
"        # to set a flag so that later calls to write raise an exception\n"
"        pass\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    logger = logging.getLogger('demo')\n"
"    info_fp = LoggerWriter(logger, logging.INFO)\n"
"    debug_fp = LoggerWriter(logger, logging.DEBUG)\n"
"    print('An INFO message', file=info_fp)\n"
"    print('A DEBUG message', file=debug_fp)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"
msgstr ""
"import logging\n"
"\n"
"class EscritorRegisto:\n"
"    def __init__(self, registador, nivel):\n"
"        self.registador = registador\n"
"        self.nivel = nivel\n"
"\n"
"    def write(self, mensagem):\n"
"        if mensagem != '\\n':  # evitar imprimir linhas em branco, se "
"preferir\n"
"            self.registador.log(self.nivel, mensagem)\n"
"\n"
"    def flush(self):\n"
"        # não faz realmente nada, mas pode ser esperado de um objeto "
"semelhante a um ficheiro\n"
"        # - então opcional dependendo da sua situação\n"
"        pass\n"
"\n"
"    def close(self):\n"
"        # não faz realmente nada, mas pode ser esperado de um objeto "
"semelhante a um ficheiro\n"
"        # - então opcional dependendo da sua situação. Pode querer definir "
"uma flag\n"
"        # para que chamadas posteriores a write levantem uma exceção\n"
"        pass\n"
"\n"
"def main():\n"
"    logging.basicConfig(level=logging.DEBUG)\n"
"    logger = logging.getLogger('demo')\n"
"    info_fp = EscritorRegisto(logger, logging.INFO)\n"
"    debug_fp = EscritorRegisto(logger, logging.DEBUG)\n"
"    print('Uma mensagem INFO', file=info_fp)\n"
"    print('Uma mensagem DEBUG', file=debug_fp)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    main()"

#: ../../howto/logging-cookbook.rst:3970
msgid "When this script is run, it prints"
msgstr "Quando este script é executado, imprime"

#: ../../howto/logging-cookbook.rst:3972
msgid ""
"INFO:demo:An INFO message\n"
"DEBUG:demo:A DEBUG message"
msgstr ""
"INFO:demo:Uma mensagem INFO\n"
"DEBUG:demo:Uma mensagem DEBUG"

#: ../../howto/logging-cookbook.rst:3977
msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and ``sys."
"stderr`` by doing something like this:"
msgstr ""
"Também pode usar ``LoggerWriter`` para redirecionar ``sys.stdout`` e ``sys."
"stderr`` fazendo algo como isto:"

#: ../../howto/logging-cookbook.rst:3980
msgid ""
"import sys\n"
"\n"
"sys.stdout = LoggerWriter(logger, logging.INFO)\n"
"sys.stderr = LoggerWriter(logger, logging.WARNING)"
msgstr ""
"import sys\n"
"\n"
"sys.stdout = EscritorRegisto(logger, logging.INFO)\n"
"sys.stderr = EscritorRegisto(logger, logging.WARNING)"

#: ../../howto/logging-cookbook.rst:3987
msgid ""
"You should do this *after* configuring logging for your needs. In the above "
"example, the :func:`~logging.basicConfig` call does this (using the ``sys."
"stderr`` value *before* it is overwritten by a ``LoggerWriter`` instance). "
"Then, you'd get this kind of result:"
msgstr ""
"Deve fazer isto *depois* de configurar o registo para as suas necessidades. "
"No exemplo acima, a chamada :func:`~logging.basicConfig` faz isto (usando o "
"valor ``sys.stderr`` *antes* de ser sobrescrito por uma instância "
"``LoggerWriter``). Depois, obteria este tipo de resultado:"

#: ../../howto/logging-cookbook.rst:3992
msgid ""
">>> print('Foo')\n"
"INFO:demo:Foo\n"
">>> print('Bar', file=sys.stderr)\n"
"WARNING:demo:Bar\n"
">>>"
msgstr ""
">>> print('Foo')\n"
"INFO:demo:Foo\n"
">>> print('Bar', file=sys.stderr)\n"
"WARNING:demo:Bar\n"
">>>"

#: ../../howto/logging-cookbook.rst:4000
msgid ""
"Of course, the examples above show output according to the format used by :"
"func:`~logging.basicConfig`, but you can use a different formatter when you "
"configure logging."
msgstr ""
"Claro, os exemplos acima mostram a saída de acordo com o formato usado por :"
"func:`~logging.basicConfig`, mas pode usar um formatador diferente quando "
"configurar o registo."

#: ../../howto/logging-cookbook.rst:4004
msgid ""
"Note that with the above scheme, you are somewhat at the mercy of buffering "
"and the sequence of write calls which you are intercepting. For example, "
"with the definition of ``LoggerWriter`` above, if you have the snippet"
msgstr ""
"Note que, com o esquema acima, está um pouco à mercê do buffer e da "
"sequência de chamadas de escrita que está a interceptar. Por exemplo, com a "
"definição de ``LoggerWriter`` acima, se tiver o trecho"

#: ../../howto/logging-cookbook.rst:4008
msgid ""
"sys.stderr = LoggerWriter(logger, logging.WARNING)\n"
"1 / 0"
msgstr ""
"sys.stderr = EscritorRegisto(logger, logging.WARNING)\n"
"1 / 0"

#: ../../howto/logging-cookbook.rst:4013
msgid "then running the script results in"
msgstr "então executar o script resulta em"

#: ../../howto/logging-cookbook.rst:4015
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 53, "
"in <module>\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 49, "
"in main\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:1 / 0\n"
"WARNING:demo:ZeroDivisionError\n"
"WARNING:demo::\n"
"WARNING:demo:division by zero"
msgstr ""
"WARNING:demo:Traceback (most recent call last):\n"
"\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 53, "
"in <module>\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/test.py\", line 49, "
"in main\n"
"\n"
"WARNING:demo:\n"
"WARNING:demo:1 / 0\n"
"WARNING:demo:ZeroDivisionError\n"
"WARNING:demo::\n"
"WARNING:demo:divisão por zero"

#: ../../howto/logging-cookbook.rst:4031
msgid ""
"As you can see, this output isn't ideal. That's because the underlying code "
"which writes to ``sys.stderr`` makes multiple writes, each of which results "
"in a separate logged line (for example, the last three lines above). To get "
"around this problem, you need to buffer things and only output log lines "
"when newlines are seen. Let's use a slightly better implementation of "
"``LoggerWriter``:"
msgstr ""
"Como pode ver, esta saída não é ideal. Isto acontece porque o código "
"subjacente que escreve em ``sys.stderr`` faz várias escritas, cada uma das "
"quais resulta numa linha de registo separada (por exemplo, as últimas três "
"linhas acima). Para contornar este problema, precisa de armazenar as coisas "
"em buffer e só emitir linhas de registo quando forem vistas novas linhas. "
"Vamos usar uma implementação um pouco melhor de ``LoggerWriter``:"

#: ../../howto/logging-cookbook.rst:4037
msgid ""
"class BufferingLoggerWriter(LoggerWriter):\n"
"    def __init__(self, logger, level):\n"
"        super().__init__(logger, level)\n"
"        self.buffer = ''\n"
"\n"
"    def write(self, message):\n"
"        if '\\n' not in message:\n"
"            self.buffer += message\n"
"        else:\n"
"            parts = message.split('\\n')\n"
"            if self.buffer:\n"
"                s = self.buffer + parts.pop(0)\n"
"                self.logger.log(self.level, s)\n"
"            self.buffer = parts.pop()\n"
"            for part in parts:\n"
"                self.logger.log(self.level, part)"
msgstr ""
"class EscritorRegistoBufferizado(EscritorRegisto):\n"
"    def __init__(self, registador, nivel):\n"
"        super().__init__(registador, nivel)\n"
"        self.buffer = ''\n"
"\n"
"    def write(self, mensagem):\n"
"        if '\\n' not in mensagem:\n"
"            self.buffer += mensagem\n"
"        else:\n"
"            partes = mensagem.split('\\n')\n"
"            if self.buffer:\n"
"                s = self.buffer + partes.pop(0)\n"
"                self.registador.log(self.nivel, s)\n"
"            self.buffer = partes.pop()\n"
"            for parte in partes:\n"
"                self.registador.log(self.nivel, parte)"

#: ../../howto/logging-cookbook.rst:4056
msgid ""
"This just buffers up stuff until a newline is seen, and then logs complete "
"lines. With this approach, you get better output:"
msgstr ""
"Isto apenas armazena as coisas em buffer até que uma nova linha seja vista, "
"e depois regista linhas completas. Com esta abordagem, obtém uma saída "
"melhor:"

#: ../../howto/logging-cookbook.rst:4059
msgid ""
"WARNING:demo:Traceback (most recent call last):\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 55, "
"in <module>\n"
"WARNING:demo:    main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 52, "
"in main\n"
"WARNING:demo:    1/0\n"
"WARNING:demo:ZeroDivisionError: division by zero"
msgstr ""
"WARNING:demo:Traceback (most recent call last):\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 55, "
"in <module>\n"
"WARNING:demo:    main()\n"
"WARNING:demo:  File \"/home/runner/cookbook-loggerwriter/main.py\", line 52, "
"in main\n"
"WARNING:demo:    1/0\n"
"WARNING:demo:ZeroDivisionError: divisão por zero"

#: ../../howto/logging-cookbook.rst:4069
msgid "How to uniformly handle newlines in logging output"
msgstr "Como lidar uniformemente com novas linhas na saída de registo"

#: ../../howto/logging-cookbook.rst:4071
msgid ""
"Usually, messages that are logged (say to console or file) consist of a "
"single line of text. However, sometimes there is a need to handle messages "
"with multiple lines - whether because a logging format string contains "
"newlines, or logged data contains newlines. If you want to handle such "
"messages uniformly, so that each line in the logged message appears "
"uniformly formatted as if it was logged separately, you can do this using a "
"handler mixin, as in the following snippet:"
msgstr ""
"Normalmente, as mensagens que são registadas (por exemplo, na consola ou num "
"ficheiro) consistem numa única linha de texto. No entanto, às vezes há "
"necessidade de lidar com mensagens com várias linhas — seja porque uma "
"string de formato de registo contém novas linhas, ou porque os dados "
"registados contêm novas linhas. Se quiser lidar com tais mensagens "
"uniformemente, de modo que cada linha na mensagem registada apareça "
"uniformemente formatada como se fosse registada separadamente, pode fazer "
"isto usando um mixin de manipulador, como no seguinte trecho:"

#: ../../howto/logging-cookbook.rst:4079
msgid ""
"# Assume this is in a module mymixins.py\n"
"import copy\n"
"\n"
"class MultilineMixin:\n"
"    def emit(self, record):\n"
"        s = record.getMessage()\n"
"        if '\\n' not in s:\n"
"            super().emit(record)\n"
"        else:\n"
"            lines = s.splitlines()\n"
"            rec = copy.copy(record)\n"
"            rec.args = None\n"
"            for line in lines:\n"
"                rec.msg = line\n"
"                super().emit(rec)"
msgstr ""
"# Assuma que isto está num módulo mymixins.py\n"
"import copy\n"
"\n"
"class MultilineMixin:\n"
"    def emit(self, record):\n"
"        s = record.getMessage()\n"
"        if '\\n' not in s:\n"
"            super().emit(record)\n"
"        else:\n"
"            lines = s.splitlines()\n"
"            rec = copy.copy(record)\n"
"            rec.args = None\n"
"            for line in lines:\n"
"                rec.msg = line\n"
"                super().emit(rec)"

#: ../../howto/logging-cookbook.rst:4097
msgid "You can use the mixin as in the following script:"
msgstr "Pode usar o mixin como no seguinte script:"

#: ../../howto/logging-cookbook.rst:4099
msgid ""
"import logging\n"
"\n"
"from mymixins import MultilineMixin\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"class StreamHandler(MultilineMixin, logging.StreamHandler):\n"
"    pass\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s "
"%(levelname)-9s %(message)s',\n"
"                        handlers = [StreamHandler()])\n"
"    logger.debug('Single line')\n"
"    logger.debug('Multiple lines:\\nfool me once ...')\n"
"    logger.debug('Another single line')\n"
"    logger.debug('Multiple lines:\\n%s', 'fool me ...\\ncan\\'t get fooled "
"again')"
msgstr ""
"import logging\n"
"\n"
"from mymixins import MultilineMixin\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"class StreamHandler(MultilineMixin, logging.StreamHandler):\n"
"    pass\n"
"\n"
"if __name__ == '__main__':\n"
"    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s "
"%(levelname)-9s %(message)s',\n"
"                        handlers = [StreamHandler()])\n"
"    logger.debug('Linha única')\n"
"    logger.debug('Múltiplas linhas:\\nengana-me uma vez ...')\n"
"    logger.debug('Outra linha única')\n"
"    logger.debug('Múltiplas linhas:\\n%s', 'engana-me ...\\nnão posso ser "
"enganado novamente')"

#: ../../howto/logging-cookbook.rst:4118
msgid "The script, when run, prints something like:"
msgstr "O script, quando executado, imprime algo como:"

#: ../../howto/logging-cookbook.rst:4120
msgid ""
"2025-07-02 13:54:47,234 DEBUG     Single line\n"
"2025-07-02 13:54:47,234 DEBUG     Multiple lines:\n"
"2025-07-02 13:54:47,234 DEBUG     fool me once ...\n"
"2025-07-02 13:54:47,234 DEBUG     Another single line\n"
"2025-07-02 13:54:47,234 DEBUG     Multiple lines:\n"
"2025-07-02 13:54:47,234 DEBUG     fool me ...\n"
"2025-07-02 13:54:47,234 DEBUG     can't get fooled again"
msgstr ""
"2025-07-02 13:54:47,234 DEBUG     Linha única\n"
"2025-07-02 13:54:47,234 DEBUG     Múltiplas linhas:\n"
"2025-07-02 13:54:47,234 DEBUG     engana-me uma vez ...\n"
"2025-07-02 13:54:47,234 DEBUG     Outra linha única\n"
"2025-07-02 13:54:47,234 DEBUG     Múltiplas linhas:\n"
"2025-07-02 13:54:47,234 DEBUG     engana-me ...\n"
"2025-07-02 13:54:47,234 DEBUG     não posso ser enganado novamente"

#: ../../howto/logging-cookbook.rst:4130
msgid ""
"If, on the other hand, you are concerned about `log injection <https://owasp."
"org/www-community/attacks/Log_Injection>`_, you can use a formatter which "
"escapes newlines, as per the following example:"
msgstr ""
"Por outro lado, se estiver preocupado com `injeção de registo <https://owasp."
"org/www-community/attacks/Log_Injection>`_, pode usar um formatador que "
"escape novas linhas, como no seguinte exemplo:"

#: ../../howto/logging-cookbook.rst:4134
msgid ""
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"class EscapingFormatter(logging.Formatter):\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        return s.replace('\\n', r'\\n')\n"
"\n"
"if __name__ == '__main__':\n"
"    h = logging.StreamHandler()\n"
"    h.setFormatter(EscapingFormatter('%(asctime)s %(levelname)-9s "
"%(message)s'))\n"
"    logging.basicConfig(level=logging.DEBUG, handlers = [h])\n"
"    logger.debug('Single line')\n"
"    logger.debug('Multiple lines:\\nfool me once ...')\n"
"    logger.debug('Another single line')\n"
"    logger.debug('Multiple lines:\\n%s', 'fool me ...\\ncan\\'t get fooled "
"again')"
msgstr ""
"import logging\n"
"\n"
"logger = logging.getLogger(__name__)\n"
"\n"
"class FormatadorEscape(logging.Formatter):\n"
"    def format(self, record):\n"
"        s = super().format(record)\n"
"        return s.replace('\\n', r'\\n')\n"
"\n"
"if __name__ == '__main__':\n"
"    h = logging.StreamHandler()\n"
"    h.setFormatter(FormatadorEscape('%(asctime)s %(levelname)-9s "
"%(message)s'))\n"
"    logging.basicConfig(level=logging.DEBUG, handlers = [h])\n"
"    logger.debug('Linha única')\n"
"    logger.debug('Múltiplas linhas:\\nengana-me uma vez ...')\n"
"    logger.debug('Outra linha única')\n"
"    logger.debug('Múltiplas linhas:\\n%s', 'engana-me ...\\nnão posso ser "
"enganado novamente')"

#: ../../howto/logging-cookbook.rst:4154
msgid ""
"You can, of course, use whatever escaping scheme makes the most sense for "
"you. The script, when run, should produce output like this:"
msgstr ""
"Pode, claro, usar qualquer esquema de escape que faça mais sentido para si. "
"O script, quando executado, deve produzir uma saída como esta:"

#: ../../howto/logging-cookbook.rst:4157
msgid ""
"2025-07-09 06:47:33,783 DEBUG     Single line\n"
"2025-07-09 06:47:33,783 DEBUG     Multiple lines:\\nfool me once ...\n"
"2025-07-09 06:47:33,783 DEBUG     Another single line\n"
"2025-07-09 06:47:33,783 DEBUG     Multiple lines:\\nfool me ...\\ncan't get "
"fooled again"
msgstr ""
"2025-07-09 06:47:33,783 DEBUG     Linha única\n"
"2025-07-09 06:47:33,783 DEBUG     Múltiplas linhas:\\nengana-me uma vez ...\n"
"2025-07-09 06:47:33,783 DEBUG     Outra linha única\n"
"2025-07-09 06:47:33,783 DEBUG     Múltiplas linhas:\\nengana-me ...\\nnão "
"posso ser enganado novamente"

#: ../../howto/logging-cookbook.rst:4164
msgid ""
"Escaping behaviour can't be the stdlib default , as it would break backwards "
"compatibility."
msgstr ""
"O comportamento de escape não pode ser o predefinido da biblioteca padrão, "
"pois quebraria a compatibilidade retroativa."

#: ../../howto/logging-cookbook.rst:4170
msgid "Patterns to avoid"
msgstr "Padrões a evitar"

#: ../../howto/logging-cookbook.rst:4172
msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns "
"which are *unhelpful*, and which should therefore be avoided in most cases. "
"The following sections are in no particular order."
msgstr ""
"Embora as secções anteriores tenham descrito formas de fazer coisas que pode "
"precisar de fazer ou lidar, vale a pena mencionar alguns padrões de uso que "
"são *pouco úteis*, e que, portanto, devem ser evitados na maioria dos casos. "
"As seguintes secções não estão numa ordem específica."

#: ../../howto/logging-cookbook.rst:4178
msgid "Opening the same log file multiple times"
msgstr "Abrir o mesmo ficheiro de registo várias vezes"

#: ../../howto/logging-cookbook.rst:4180
msgid ""
"On Windows, you will generally not be able to open the same file multiple "
"times as this will lead to a \"file is in use by another process\" error. "
"However, on POSIX platforms you'll not get any errors if you open the same "
"file multiple times. This could be done accidentally, for example by:"
msgstr ""
"No Windows, geralmente não será capaz de abrir o mesmo ficheiro várias "
"vezes, pois isso levará a um erro \"o ficheiro está a ser usado por outro "
"processo\". No entanto, em plataformas POSIX, não obterá quaisquer erros se "
"abrir o mesmo ficheiro várias vezes. Isto pode ser feito acidentalmente, por "
"exemplo:"

#: ../../howto/logging-cookbook.rst:4185
msgid ""
"Adding a file handler more than once which references the same file (e.g. by "
"a copy/paste/forget-to-change error)."
msgstr ""
"Adicionar um manipulador de ficheiro mais do que uma vez que referencia o "
"mesmo ficheiro (por exemplo, por um erro de copiar/colar/esquecer-se de "
"alterar)."

#: ../../howto/logging-cookbook.rst:4188
msgid ""
"Opening two files that look different, as they have different names, but are "
"the same because one is a symbolic link to the other."
msgstr ""
"Abrir dois ficheiros que parecem diferentes, pois têm nomes diferentes, mas "
"são o mesmo porque um é uma ligação simbólica para o outro."

#: ../../howto/logging-cookbook.rst:4191
msgid ""
"Forking a process, following which both parent and child have a reference to "
"the same file. This might be through use of the :mod:`multiprocessing` "
"module, for example."
msgstr ""
"Criar um processo filho, após o qual tanto o processo pai como o filho têm "
"uma referência para o mesmo ficheiro. Isto pode ser através do uso do "
"módulo :mod:`multiprocessing`, por exemplo."

#: ../../howto/logging-cookbook.rst:4195
msgid ""
"Opening a file multiple times might *appear* to work most of the time, but "
"can lead to a number of problems in practice:"
msgstr ""
"Abrir um ficheiro várias vezes pode *parecer* funcionar na maioria das "
"vezes, mas pode levar a vários problemas na prática:"

#: ../../howto/logging-cookbook.rst:4198
msgid ""
"Logging output can be garbled because multiple threads or processes try to "
"write to the same file. Although logging guards against concurrent use of "
"the same handler instance by multiple threads, there is no such protection "
"if concurrent writes are attempted by two different threads using two "
"different handler instances which happen to point to the same file."
msgstr ""
"A saída de registo pode ficar corrompida porque várias threads ou processos "
"tentam escrever no mesmo ficheiro. Embora o registo proteja contra o uso "
"concorrente da mesma instância de manipulador por várias threads, não existe "
"tal proteção se forem tentadas escritas concorrentes por duas threads "
"diferentes que usam duas instâncias de manipulador diferentes que, por "
"acaso, apontam para o mesmo ficheiro."

#: ../../howto/logging-cookbook.rst:4204
msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based rotation "
"being supposedly in place."
msgstr ""
"Uma tentativa de apagar um ficheiro (por exemplo, durante a rotação de "
"ficheiros) falha silenciosamente, porque existe outra referência a apontar "
"para ele. Isto pode levar a confusão e perda de tempo de depuração — as "
"entradas de registo acabam em locais inesperados, ou são perdidas por "
"completo. Ou um ficheiro que deveria ter sido movido permanece no lugar, e "
"cresce de tamanho inesperadamente apesar da rotação baseada em tamanho estar "
"supostamente em vigor."

#: ../../howto/logging-cookbook.rst:4211
msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent such "
"issues."
msgstr ""
"Use as técnicas descritas em :ref:`multiple-processes` para contornar tais "
"problemas."

#: ../../howto/logging-cookbook.rst:4215
msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr ""
"Utilizar registadores como atributos numa classe ou passá-los como parâmetros"

#: ../../howto/logging-cookbook.rst:4217
msgid ""
"While there might be unusual cases where you'll need to do this, in general "
"there is no point because loggers are singletons. Code can always access a "
"given logger instance by name using ``logging.getLogger(name)``, so passing "
"instances around and holding them as instance attributes is pointless. Note "
"that in other languages such as Java and C#, loggers are often static class "
"attributes. However, this pattern doesn't make sense in Python, where the "
"module (and not the class) is the unit of software decomposition."
msgstr ""
"Embora possam existir casos invulgares em que precise de fazer isto, em "
"geral não faz sentido porque os registadores são singletons. O código pode "
"sempre aceder a uma instância de registador específica pelo nome usando "
"``logging.getLogger(name)``, por isso passar instâncias e mantê-las como "
"atributos de instância é inútil. Note que em outras linguagens como Java e "
"C#, os registadores são frequentemente atributos estáticos de classe. No "
"entanto, este padrão não faz sentido em Python, onde o módulo (e não a "
"classe) é a unidade de decomposição de software."

#: ../../howto/logging-cookbook.rst:4226
msgid ""
"Adding handlers other than :class:`~logging.NullHandler` to a logger in a "
"library"
msgstr ""
"Adicionar manipuladores diferentes de :class:`~logging.NullHandler` a um "
"registador numa biblioteca"

#: ../../howto/logging-cookbook.rst:4228
msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. If "
"you are maintaining a library, ensure that you don't add handlers to any of "
"your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""
"Configurar o registo adicionando manipuladores, formatadores e filtros é "
"responsabilidade do desenvolvedor da aplicação, não do desenvolvedor da "
"biblioteca. Se estiver a manter uma biblioteca, certifique-se de que não "
"adiciona manipuladores a nenhum dos seus registadores, exceto uma instância "
"de :class:`~logging.NullHandler`."

#: ../../howto/logging-cookbook.rst:4234
msgid "Creating a lot of loggers"
msgstr "Criar muitos registadores"

#: ../../howto/logging-cookbook.rst:4236
msgid ""
"Loggers are singletons that are never freed during a script execution, and "
"so creating lots of loggers will use up memory which can't then be freed. "
"Rather than create a logger per e.g. file processed or network connection "
"made, use the :ref:`existing mechanisms <context-info>` for passing "
"contextual information into your logs and restrict the loggers created to "
"those describing areas within your application (generally modules, but "
"occasionally slightly more fine-grained than that)."
msgstr ""
"Os registadores são singletons que nunca são libertados durante a execução "
"de um script, e, portanto, criar muitos registadores consumirá memória que "
"não pode ser libertada. Em vez de criar um registador por ficheiro "
"processado ou ligação de rede estabelecida, use os :ref:`mecanismos "
"existentes <context-info>` para passar informações contextuais para os seus "
"registos e restrinja os registadores criados àqueles que descrevem áreas "
"dentro da sua aplicação (geralmente módulos, mas ocasionalmente um pouco "
"mais granular do que isso)."

#: ../../howto/logging-cookbook.rst:4247
msgid "Other resources"
msgstr "Outros recursos"

#: ../../howto/logging-cookbook.rst:4251
msgid "Module :mod:`logging`"
msgstr "Módulo :mod:`logging`"

#: ../../howto/logging-cookbook.rst:4252
msgid "API reference for the logging module."
msgstr "Referência da API para o módulo de registo."

#: ../../howto/logging-cookbook.rst:4254
msgid "Module :mod:`logging.config`"
msgstr "Módulo :mod:`logging.config`"

#: ../../howto/logging-cookbook.rst:4255
msgid "Configuration API for the logging module."
msgstr "API de configuração para o módulo de registo."

#: ../../howto/logging-cookbook.rst:4257
msgid "Module :mod:`logging.handlers`"
msgstr "Módulo :mod:`logging.handlers`"

#: ../../howto/logging-cookbook.rst:4258
msgid "Useful handlers included with the logging module."
msgstr "Manipuladores úteis incluídos com o módulo de registo."

#: ../../howto/logging-cookbook.rst:4260
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Tutorial Básico <logging-basic-tutorial>`"

#: ../../howto/logging-cookbook.rst:4262
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Tutorial Avançado <logging-advanced-tutorial>`"
