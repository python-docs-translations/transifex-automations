# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-07 14:13+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../howto/remote_debugging.rst:4
msgid "Remote debugging attachment protocol"
msgstr "Protocolo de anexação para depuração remota"

#: ../../howto/remote_debugging.rst:6
msgid ""
"This protocol enables external tools to attach to a running CPython process "
"and execute Python code remotely."
msgstr ""
"Este protocolo permite que ferramentas externas se anexem a um processo "
"CPython em execução e executem código Python remotamente."

#: ../../howto/remote_debugging.rst:9
msgid ""
"Most platforms require elevated privileges to attach to another Python "
"process."
msgstr ""
"A maioria das plataformas requer privilégios elevados para anexar a outro "
"processo Python."

#: ../../howto/remote_debugging.rst:14
msgid "Permission requirements"
msgstr "Requisitos de permissão"

#: ../../howto/remote_debugging.rst:16
msgid ""
"Attaching to a running Python process for remote debugging requires elevated "
"privileges on most platforms. The specific requirements and troubleshooting "
"steps depend on your operating system:"
msgstr ""
"Anexar a um processo Python em execução para depuração remota requer "
"privilégios elevados na maioria das plataformas. Os requisitos específicos e "
"os passos de resolução de problemas dependem do sistema operativo:"

#: ../../howto/remote_debugging.rst:21
msgid "Linux"
msgstr "Linux"

#: ../../howto/remote_debugging.rst:22
msgid ""
"The tracer process must have the ``CAP_SYS_PTRACE`` capability or equivalent "
"privileges. You can only trace processes you own and can signal. Tracing may "
"fail if the process is already being traced, or if it is running with set-"
"user-ID or set-group-ID. Security modules like Yama may further restrict "
"tracing."
msgstr ""
"O processo de rastreio deve ter a capacidade ``CAP_SYS_PTRACE`` ou "
"privilégios equivalentes. Só pode rastrear processos que possui e aos quais "
"pode enviar sinais. O rastreio pode falhar se o processo já estiver a ser "
"rastreado, ou se estiver a ser executado com set-user-ID ou set-group-ID. "
"Módulos de segurança como o Yama podem restringir ainda mais o rastreio."

#: ../../howto/remote_debugging.rst:28
msgid "To temporarily relax ptrace restrictions (until reboot), run:"
msgstr ""
"Para relaxar temporariamente as restrições de ptrace (até reiniciar), "
"execute:"

#: ../../howto/remote_debugging.rst:30
msgid "``echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope``"
msgstr "``echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope``"

#: ../../howto/remote_debugging.rst:34
msgid ""
"Disabling ``ptrace_scope`` reduces system hardening and should only be done "
"in trusted environments."
msgstr ""
"Desativar ``ptrace_scope`` reduz o endurecimento do sistema e só deve ser "
"feito em ambientes confiáveis."

#: ../../howto/remote_debugging.rst:37
msgid ""
"If running inside a container, use ``--cap-add=SYS_PTRACE`` or ``--"
"privileged``, and run as root if needed."
msgstr ""
"Se estiver a executar dentro de um contentor, use ``--cap-add=SYS_PTRACE`` "
"ou ``--privileged``, e execute como root se necessário."

#: ../../howto/remote_debugging.rst:40
msgid "Try re-running the command with elevated privileges:"
msgstr "Tente executar novamente o comando com privilégios elevados:"

#: ../../howto/remote_debugging.rst:42
msgid "``sudo -E !!``"
msgstr "``sudo -E !!``"

#: ../../howto/remote_debugging.rst:46
msgid "macOS"
msgstr "macOS"

#: ../../howto/remote_debugging.rst:47
msgid ""
"To attach to another process, you typically need to run your debugging tool "
"with elevated privileges. This can be done by using ``sudo`` or running as "
"root."
msgstr ""
"Para anexar a outro processo, normalmente precisa de executar a sua "
"ferramenta de depuração com privilégios elevados. Isto pode ser feito usando "
"``sudo`` ou executando como root."

#: ../../howto/remote_debugging.rst:51
msgid ""
"Even when attaching to processes you own, macOS may block debugging unless "
"the debugger is run with root privileges due to system security restrictions."
msgstr ""
"Mesmo ao anexar a processos que possui, o macOS pode bloquear a depuração a "
"menos que o depurador seja executado com privilégios de root devido a "
"restrições de segurança do sistema."

#: ../../howto/remote_debugging.rst:56
msgid "Windows"
msgstr "Windows"

#: ../../howto/remote_debugging.rst:57
msgid ""
"To attach to another process, you usually need to run your debugging tool "
"with administrative privileges. Start the command prompt or terminal as "
"Administrator."
msgstr ""
"Para anexar a outro processo, normalmente precisa de executar a sua "
"ferramenta de depuração com privilégios administrativos. Inicie o prompt de "
"comando ou o terminal como Administrador."

#: ../../howto/remote_debugging.rst:61
msgid ""
"Some processes may still be inaccessible even with Administrator rights, "
"unless you have the ``SeDebugPrivilege`` privilege enabled."
msgstr ""
"Alguns processos podem ainda ser inacessíveis mesmo com direitos de "
"Administrador, a menos que tenha o privilégio ``SeDebugPrivilege`` ativado."

#: ../../howto/remote_debugging.rst:64
msgid ""
"To resolve file or folder access issues, adjust the security permissions:"
msgstr ""
"Para resolver problemas de acesso a ficheiros ou pastas, ajuste as "
"permissões de segurança:"

#: ../../howto/remote_debugging.rst:66
msgid "Right-click the file or folder and select **Properties**."
msgstr ""
"Clique com o botão direito no ficheiro ou pasta e selecione **Propriedades**."

#: ../../howto/remote_debugging.rst:67
msgid "Go to the **Security** tab to view users and groups with access."
msgstr ""
"Vá ao separador **Segurança** para ver utilizadores e grupos com acesso."

#: ../../howto/remote_debugging.rst:68
msgid "Click **Edit** to modify permissions."
msgstr "Clique em **Editar** para modificar permissões."

#: ../../howto/remote_debugging.rst:69
msgid "Select your user account."
msgstr "Selecione a sua conta de utilizador."

#: ../../howto/remote_debugging.rst:70
msgid "In **Permissions**, check **Read** or **Full control** as needed."
msgstr ""
"Em **Permissões**, marque **Leitura** ou **Controlo total** conforme "
"necessário."

#: ../../howto/remote_debugging.rst:71
msgid "Click **Apply**, then **OK** to confirm."
msgstr "Clique em **Aplicar**, depois em **OK** para confirmar."

#: ../../howto/remote_debugging.rst:76
msgid ""
"Ensure you've satisfied all :ref:`permission-requirements` before proceeding."
msgstr ""
"Certifique-se de que cumpriu todos os :ref:`permission-requirements` antes "
"de continuar."

#: ../../howto/remote_debugging.rst:78
msgid ""
"This section describes the low-level protocol that enables external tools to "
"inject and execute a Python script within a running CPython process."
msgstr ""
"Esta secção descreve o protocolo de baixo nível que permite que ferramentas "
"externas injetem e executem um script Python dentro de um processo CPython "
"em execução."

#: ../../howto/remote_debugging.rst:81
msgid ""
"This mechanism forms the basis of the :func:`sys.remote_exec` function, "
"which instructs a remote Python process to execute a ``.py`` file. However, "
"this section does not document the usage of that function. Instead, it "
"provides a detailed explanation of the underlying protocol, which takes as "
"input the ``pid`` of a target Python process and the path to a Python source "
"file to be executed. This information supports independent reimplementation "
"of the protocol, regardless of programming language."
msgstr ""
"Este mecanismo constitui a base da função :func:`sys.remote_exec`, que "
"instrui um processo Python remoto a executar um ficheiro ``.py``. No "
"entanto, esta secção não documenta a utilização dessa função. Em vez disso, "
"fornece uma explicação detalhada do protocolo subjacente, que recebe como "
"entrada o ``pid`` de um processo Python de destino e o caminho para um "
"ficheiro fonte Python a ser executado. Estas informações suportam a "
"reimplementação independente do protocolo, independentemente da linguagem de "
"programação."

#: ../../howto/remote_debugging.rst:91
msgid ""
"The execution of the injected script depends on the interpreter reaching a "
"safe evaluation point. As a result, execution may be delayed depending on "
"the runtime state of the target process."
msgstr ""
"A execução do script injetado depende do interpretador atingir um ponto de "
"avaliação seguro. Como resultado, a execução pode ser adiada dependendo do "
"estado de execução do processo de destino."

#: ../../howto/remote_debugging.rst:95
msgid ""
"Once injected, the script is executed by the interpreter within the target "
"process the next time a safe evaluation point is reached. This approach "
"enables remote execution capabilities without modifying the behavior or "
"structure of the running Python application."
msgstr ""
"Uma vez injetado, o script é executado pelo interpretador dentro do processo "
"de destino na próxima vez que um ponto de avaliação seguro é atingido. Esta "
"abordagem permite capacidades de execução remota sem modificar o "
"comportamento ou a estrutura da aplicação Python em execução."

#: ../../howto/remote_debugging.rst:100
msgid ""
"Subsequent sections provide a step-by-step description of the protocol, "
"including techniques for locating interpreter structures in memory, safely "
"accessing internal fields, and triggering code execution. Platform-specific "
"variations are noted where applicable, and example implementations are "
"included to clarify each operation."
msgstr ""
"As secções seguintes fornecem uma descrição passo a passo do protocolo, "
"incluindo técnicas para localizar estruturas do interpretador na memória, "
"aceder em segurança a campos internos e desencadear a execução de código. "
"São indicadas variações específicas da plataforma, quando aplicáveis, e são "
"incluídas implementações de exemplo para clarificar cada operação."

#: ../../howto/remote_debugging.rst:107
msgid "Locating the PyRuntime structure"
msgstr "Localizar a estrutura PyRuntime"

#: ../../howto/remote_debugging.rst:109
msgid ""
"CPython places the ``PyRuntime`` structure in a dedicated binary section to "
"help external tools find it at runtime. The name and format of this section "
"vary by platform. For example, ``.PyRuntime`` is used on ELF systems, and "
"``__DATA,__PyRuntime`` is used on macOS. Tools can find the offset of this "
"structure by examining the binary on disk."
msgstr ""
"O CPython coloca a estrutura ``PyRuntime`` numa secção binária dedicada para "
"ajudar ferramentas externas a encontrá-la em tempo de execução. O nome e "
"formato desta secção variam conforme a plataforma. Por exemplo, ``."
"PyRuntime`` é usado em sistemas ELF, e ``__DATA,__PyRuntime`` é usado no "
"macOS. As ferramentas podem encontrar o deslocamento desta estrutura "
"examinando o binário no disco."

#: ../../howto/remote_debugging.rst:115
msgid ""
"The ``PyRuntime`` structure contains CPython’s global interpreter state and "
"provides access to other internal data, including the list of interpreters, "
"thread states, and debugger support fields."
msgstr ""
"A estrutura ``PyRuntime`` contém o estado global do interpretador do CPython "
"e fornece acesso a outros dados internos, incluindo a lista de "
"interpretadores, estados de threads e campos de suporte ao depurador."

#: ../../howto/remote_debugging.rst:119
msgid ""
"To work with a remote Python process, a debugger must first find the memory "
"address of the ``PyRuntime`` structure in the target process. This address "
"can’t be hardcoded or calculated from a symbol name, because it depends on "
"where the operating system loaded the binary."
msgstr ""
"Para trabalhar com um processo Python remoto, um depurador deve primeiro "
"encontrar o endereço de memória da estrutura ``PyRuntime`` no processo de "
"destino. Este endereço não pode ser codificado ou calculado a partir de um "
"nome de símbolo, porque depende de onde o sistema operativo carregou o "
"binário."

#: ../../howto/remote_debugging.rst:124
msgid ""
"The method for finding ``PyRuntime`` depends on the platform, but the steps "
"are the same in general:"
msgstr ""
"O método para encontrar ``PyRuntime`` depende da plataforma, mas os passos "
"são geralmente os mesmos:"

#: ../../howto/remote_debugging.rst:127
msgid ""
"Find the base address where the Python binary or shared library was loaded "
"in the target process."
msgstr ""
"Encontrar o endereço base onde o binário Python ou a biblioteca partilhada "
"foi carregado no processo de destino."

#: ../../howto/remote_debugging.rst:129
msgid ""
"Use the on-disk binary to locate the offset of the ``.PyRuntime`` section."
msgstr ""
"Usar o binário no disco para localizar o deslocamento da secção ``."
"PyRuntime``."

#: ../../howto/remote_debugging.rst:130
msgid ""
"Add the section offset to the base address to compute the address in memory."
msgstr ""
"Adicionar o deslocamento da secção ao endereço base para calcular o endereço "
"na memória."

#: ../../howto/remote_debugging.rst:132
msgid ""
"The sections below explain how to do this on each supported platform and "
"include example code."
msgstr ""
"As secções seguintes explicam como fazer isto em cada plataforma suportada e "
"incluem código de exemplo."

#: ../../howto/remote_debugging.rst:136
msgid "Linux (ELF)"
msgstr "Linux (ELF)"

#: ../../howto/remote_debugging.rst:137
msgid "To find the ``PyRuntime`` structure on Linux:"
msgstr "Para encontrar a estrutura ``PyRuntime`` no Linux:"

#: ../../howto/remote_debugging.rst:139
msgid ""
"Read the process’s memory map (for example, ``/proc/<pid>/maps``) to find "
"the address where the Python executable or ``libpython`` was loaded."
msgstr ""
"Ler o mapa de memória do processo (por exemplo, ``/proc/<pid>/maps``) para "
"encontrar o endereço onde o executável Python ou ``libpython`` foi carregado."

#: ../../howto/remote_debugging.rst:141
msgid ""
"Parse the ELF section headers in the binary to get the offset of the ``."
"PyRuntime`` section."
msgstr ""
"Analisar os cabeçalhos de secção ELF no binário para obter o deslocamento da "
"secção ``.PyRuntime``."

#: ../../howto/remote_debugging.rst:143
msgid ""
"Add that offset to the base address from step 1 to get the memory address of "
"``PyRuntime``."
msgstr ""
"Adicionar esse deslocamento ao endereço base do passo 1 para obter o "
"endereço de memória do ``PyRuntime``."

#: ../../howto/remote_debugging.rst:146 ../../howto/remote_debugging.rst:208
#: ../../howto/remote_debugging.rst:278 ../../howto/remote_debugging.rst:547
msgid "The following is an example implementation::"
msgstr "A seguinte é uma implementação de exemplo:"

#: ../../howto/remote_debugging.rst:148
msgid ""
"def find_py_runtime_linux(pid: int) -> int:\n"
"    # Step 1: Try to find the Python executable in memory\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Step 2: Fallback to shared library if executable is not found\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            pid, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Step 3: Parse ELF headers to get .PyRuntime section offset\n"
"    section_offset = parse_elf_section_offset(\n"
"        binary_path, \".PyRuntime\"\n"
"    )\n"
"\n"
"    # Step 4: Compute PyRuntime address in memory\n"
"    return base_address + section_offset"
msgstr ""

#: ../../howto/remote_debugging.rst:169
msgid ""
"On Linux systems, there are two main approaches to read memory from another "
"process. The first is through the ``/proc`` filesystem, specifically by "
"reading from ``/proc/[pid]/mem`` which provides direct access to the "
"process's memory. This requires appropriate permissions - either being the "
"same user as the target process or having root access. The second approach "
"is using the ``process_vm_readv()`` system call which provides a more "
"efficient way to copy memory between processes. While ptrace's "
"``PTRACE_PEEKTEXT`` operation can also be used to read memory, it is "
"significantly slower as it only reads one word at a time and requires "
"multiple context switches between the tracer and tracee processes."
msgstr ""
"Nos sistemas Linux, existem duas abordagens principais para ler a memória de "
"outro processo. A primeira é através do sistema de ficheiros ``/proc``, "
"especificamente lendo de ``/proc/[pid]/mem``, que fornece acesso direto à "
"memória do processo. Isto requer permissões adequadas - ser o mesmo "
"utilizador que o processo de destino ou ter acesso root. A segunda abordagem "
"é usar a chamada de sistema ``process_vm_readv()``, que fornece uma forma "
"mais eficiente de copiar memória entre processos. Embora a operação "
"``PTRACE_PEEKTEXT`` do ptrace também possa ser usada para ler memória, é "
"significativamente mais lenta, pois lê apenas uma palavra de cada vez e "
"requer múltiplas trocas de contexto entre os processos de rastreio e "
"rastreado."

#: ../../howto/remote_debugging.rst:180
msgid ""
"For parsing ELF sections, the process involves reading and interpreting the "
"ELF file format structures from the binary file on disk. The ELF header "
"contains a pointer to the section header table. Each section header contains "
"metadata about a section including its name (stored in a separate string "
"table), offset, and size. To find a specific section like .PyRuntime, you "
"need to walk through these headers and match the section name. The section "
"header then provides the offset where that section exists in the file, which "
"can be used to calculate its runtime address when the binary is loaded into "
"memory."
msgstr ""
"Para analisar secções ELF, o processo envolve ler e interpretar as "
"estruturas do formato de ficheiro ELF a partir do ficheiro binário no disco. "
"O cabeçalho ELF contém um ponteiro para a tabela de cabeçalhos de secção. "
"Cada cabeçalho de secção contém metadados sobre uma secção, incluindo o seu "
"nome (armazenado numa tabela de strings separada), deslocamento e tamanho. "
"Para encontrar uma secção específica como .PyRuntime, precisa de percorrer "
"estes cabeçalhos e corresponder ao nome da secção. O cabeçalho da secção "
"fornece então o deslocamento onde essa secção existe no ficheiro, que pode "
"ser usado para calcular o seu endereço em tempo de execução quando o binário "
"é carregado na memória."

#: ../../howto/remote_debugging.rst:189
msgid ""
"You can read more about the ELF file format in the `ELF specification "
"<https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>`_."
msgstr ""
"Pode ler mais sobre o formato de ficheiro ELF na `especificação ELF <https://"
"en.wikipedia.org/wiki/Executable_and_Linkable_Format>`_."

#: ../../howto/remote_debugging.rst:194
msgid "macOS (Mach-O)"
msgstr "macOS (Mach-O)"

#: ../../howto/remote_debugging.rst:195
msgid "To find the ``PyRuntime`` structure on macOS:"
msgstr "Para encontrar a estrutura ``PyRuntime`` no macOS:"

#: ../../howto/remote_debugging.rst:197
msgid ""
"Call ``task_for_pid()`` to get the ``mach_port_t`` task port for the target "
"process. This handle is needed to read memory using APIs like "
"``mach_vm_read_overwrite`` and ``mach_vm_region``."
msgstr ""
"Chame ``task_for_pid()`` para obter a porta de tarefa ``mach_port_t`` para o "
"processo de destino. Este identificador é necessário para ler a memória "
"usando APIs como ``mach_vm_read_overwrite`` e ``mach_vm_region``."

#: ../../howto/remote_debugging.rst:200
msgid ""
"Scan the memory regions to find the one containing the Python executable or "
"``libpython``."
msgstr ""
"Analisar as regiões de memória para encontrar a que contém o executável "
"Python ou ``libpython``."

#: ../../howto/remote_debugging.rst:202
msgid ""
"Load the binary file from disk and parse the Mach-O headers to find the "
"section named ``PyRuntime`` in the ``__DATA`` segment.  On macOS, symbol "
"names are automatically prefixed with an underscore, so the ``PyRuntime`` "
"symbol appears as ``_PyRuntime`` in the symbol table, but the section name "
"is not affected."
msgstr ""
"Carregar o ficheiro binário do disco e analisar os cabeçalhos Mach-O para "
"encontrar a secção chamada ``PyRuntime`` no segmento ``__DATA``. No macOS, "
"os nomes dos símbolos são automaticamente prefixados com um sublinhado, pelo "
"que o símbolo ``PyRuntime`` aparece como ``_PyRuntime`` na tabela de "
"símbolos, mas o nome da secção não é afetado."

#: ../../howto/remote_debugging.rst:210
msgid ""
"def find_py_runtime_macos(pid: int) -> int:\n"
"    # Step 1: Get access to the process's memory\n"
"    handle = get_memory_access_handle(pid)\n"
"\n"
"    # Step 2: Try to find the Python executable in memory\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        handle, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Step 3: Fallback to libpython if the executable is not found\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            handle, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Step 4: Parse Mach-O headers to get __DATA,__PyRuntime section offset\n"
"    section_offset = parse_macho_section_offset(\n"
"        binary_path, \"__DATA\", \"__PyRuntime\"\n"
"    )\n"
"\n"
"    # Step 5: Compute the PyRuntime address in memory\n"
"    return base_address + section_offset"
msgstr ""
"def find_py_runtime_macos(pid: int) -> int:\n"
"    # Passo 1: Obter acesso à memória do processo\n"
"    handle = get_memory_access_handle(pid)\n"
"\n"
"    # Passo 2: Tentar encontrar o executável Python na memória\n"
"    binary_path, base_address = find_mapped_binary(\n"
"        handle, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Passo 3: Recorrer à libpython se o executável não for encontrado\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_mapped_binary(\n"
"            handle, name_contains=\"libpython\"\n"
"        )\n"
"\n"
"    # Passo 4: Analisar os cabeçalhos Mach-O para obter o deslocamento da "
"secção __DATA,__PyRuntime\n"
"    section_offset = parse_macho_section_offset(\n"
"        binary_path, \"__DATA\", \"__PyRuntime\"\n"
"    )\n"
"\n"
"    # Passo 5: Calcular o endereço do PyRuntime na memória\n"
"    return base_address + section_offset"

#: ../../howto/remote_debugging.rst:233
msgid ""
"On macOS, accessing another process's memory requires using Mach-O specific "
"APIs and file formats. The first step is obtaining a ``task_port`` handle "
"via ``task_for_pid()``, which provides access to the target process's memory "
"space. This handle enables memory operations through APIs like "
"``mach_vm_read_overwrite()``."
msgstr ""
"No macOS, aceder à memória de outro processo requer o uso de APIs e formatos "
"de ficheiro específicos do Mach-O. O primeiro passo é obter um identificador "
"``task_port`` através de ``task_for_pid()``, que fornece acesso ao espaço de "
"memória do processo de destino. Este identificador permite operações de "
"memória através de APIs como ``mach_vm_read_overwrite()``."

#: ../../howto/remote_debugging.rst:239
msgid ""
"The process memory can be examined using ``mach_vm_region()`` to scan "
"through the virtual memory space, while ``proc_regionfilename()`` helps "
"identify which binary files are loaded at each memory region. When the "
"Python binary or library is found, its Mach-O headers need to be parsed to "
"locate the ``PyRuntime`` structure."
msgstr ""
"A memória do processo pode ser examinada usando ``mach_vm_region()`` para "
"analisar o espaço de memória virtual, enquanto ``proc_regionfilename()`` "
"ajuda a identificar quais ficheiros binários estão carregados em cada região "
"de memória. Quando o binário Python ou a biblioteca são encontrados, os seus "
"cabeçalhos Mach-O precisam de ser analisados para localizar a estrutura "
"``PyRuntime``."

#: ../../howto/remote_debugging.rst:244
msgid ""
"The Mach-O format organizes code and data into segments and sections. The "
"``PyRuntime`` structure lives in a section named ``__PyRuntime`` within the "
"``__DATA`` segment. The actual runtime address calculation involves finding "
"the ``__TEXT`` segment which serves as the binary's base address, then "
"locating the ``__DATA`` segment containing our target section. The final "
"address is computed by combining the base address with the appropriate "
"section offsets from the Mach-O headers."
msgstr ""
"O formato Mach-O organiza o código e os dados em segmentos e secções. A "
"estrutura ``PyRuntime`` reside numa secção chamada ``__PyRuntime`` dentro do "
"segmento ``__DATA``. O cálculo do endereço real em tempo de execução envolve "
"encontrar o segmento ``__TEXT``, que serve como o endereço base do binário, "
"e depois localizar o segmento ``__DATA`` que contém a nossa secção de "
"destino. O endereço final é calculado combinando o endereço base com os "
"deslocamentos de secção apropriados dos cabeçalhos Mach-O."

#: ../../howto/remote_debugging.rst:252
msgid ""
"Note that accessing another process's memory on macOS typically requires "
"elevated privileges - either root access or special security entitlements "
"granted to the debugging process."
msgstr ""
"Note que aceder à memória de outro processo no macOS geralmente requer "
"privilégios elevados - acesso root ou autorizações de segurança especiais "
"concedidas ao processo de depuração."

#: ../../howto/remote_debugging.rst:258
msgid "Windows (PE)"
msgstr "Windows (PE)"

#: ../../howto/remote_debugging.rst:259
msgid "To find the ``PyRuntime`` structure on Windows:"
msgstr "Para encontrar a estrutura ``PyRuntime`` no Windows:"

#: ../../howto/remote_debugging.rst:261
msgid ""
"Use the ToolHelp API to enumerate all modules loaded in the target process. "
"This is done using functions such as `CreateToolhelp32Snapshot <https://"
"learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-"
"createtoolhelp32snapshot>`_, `Module32First <https://learn.microsoft.com/en-"
"us/windows/win32/api/tlhelp32/nf-tlhelp32-module32first>`_, and "
"`Module32Next <https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/"
"nf-tlhelp32-module32next>`_."
msgstr ""
"Use a API ToolHelp para enumerar todos os módulos carregados no processo de "
"destino. Isto é feito usando funções como `CreateToolhelp32Snapshot <https://"
"learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-"
"createtoolhelp32snapshot>`_, `Module32First <https://learn.microsoft.com/en-"
"us/windows/win32/api/tlhelp32/nf-tlhelp32-module32first>`_, e `Module32Next "
"<https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-"
"module32next>`_."

#: ../../howto/remote_debugging.rst:268
msgid ""
"Identify the module corresponding to :file:`python.exe` or :file:`python{XY}."
"dll`, where ``X`` and ``Y`` are the major and minor version numbers of the "
"Python version, and record its base address."
msgstr ""
"Identificar o módulo correspondente a :file:`python.exe` ou :file:"
"`python{XY}.dll`, onde ``X`` e ``Y`` são os números de versão principal e "
"secundária da versão do Python, e registar o seu endereço base."

#: ../../howto/remote_debugging.rst:271
msgid ""
"Locate the ``PyRuntim`` section. Due to the PE format's 8-character limit on "
"section names (defined as ``IMAGE_SIZEOF_SHORT_NAME``), the original name "
"``PyRuntime`` is truncated. This section contains the ``PyRuntime`` "
"structure."
msgstr ""
"Localizar a secção ``PyRuntim``. Devido ao limite de 8 caracteres do formato "
"PE nos nomes das secções (definido como ``IMAGE_SIZEOF_SHORT_NAME``), o nome "
"original ``PyRuntime`` é truncado. Esta secção contém a estrutura "
"``PyRuntime``."

#: ../../howto/remote_debugging.rst:275
msgid ""
"Retrieve the section’s relative virtual address (RVA) and add it to the base "
"address of the module."
msgstr ""
"Recuperar o endereço virtual relativo (RVA) da secção e adicioná-lo ao "
"endereço base do módulo."

#: ../../howto/remote_debugging.rst:280
msgid ""
"def find_py_runtime_windows(pid: int) -> int:\n"
"    # Step 1: Try to find the Python executable in memory\n"
"    binary_path, base_address = find_loaded_module(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Step 2: Fallback to shared pythonXY.dll if the executable is not\n"
"    # found\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_loaded_module(\n"
"            pid, name_contains=\"python3\"\n"
"        )\n"
"\n"
"    # Step 3: Parse PE section headers to get the RVA of the PyRuntime\n"
"    # section. The section name appears as \"PyRuntim\" due to the\n"
"    # 8-character limit defined by the PE format (IMAGE_SIZEOF_SHORT_NAME).\n"
"    section_rva = parse_pe_section_offset(binary_path, \"PyRuntim\")\n"
"\n"
"    # Step 4: Compute PyRuntime address in memory\n"
"    return base_address + section_rva"
msgstr ""
"def find_py_runtime_windows(pid: int) -> int:\n"
"    # Passo 1: Tentar encontrar o executável Python na memória\n"
"    binary_path, base_address = find_loaded_module(\n"
"        pid, name_contains=\"python\"\n"
"    )\n"
"\n"
"    # Passo 2: Recorrer ao pythonXY.dll partilhado se o executável não for "
"encontrado\n"
"    if binary_path is None:\n"
"        binary_path, base_address = find_loaded_module(\n"
"            pid, name_contains=\"python3\"\n"
"        )\n"
"\n"
"    # Passo 3: Analisar os cabeçalhos de secção PE para obter o RVA da "
"secção PyRuntime\n"
"    # O nome da secção aparece como \"PyRuntim\" devido ao limite de 8 "
"caracteres\n"
"    # definido pelo formato PE (IMAGE_SIZEOF_SHORT_NAME).\n"
"    section_rva = parse_pe_section_offset(binary_path, \"PyRuntim\")\n"
"\n"
"    # Passo 4: Calcular o endereço do PyRuntime na memória\n"
"    return base_address + section_rva"

#: ../../howto/remote_debugging.rst:302
msgid ""
"On Windows, accessing another process's memory requires using the Windows "
"API functions like ``CreateToolhelp32Snapshot()`` and ``Module32First()/"
"Module32Next()`` to enumerate loaded modules. The ``OpenProcess()`` function "
"provides a handle to access the target process's memory space, enabling "
"memory operations through ``ReadProcessMemory()``."
msgstr ""
"No Windows, aceder à memória de outro processo requer o uso de funções da "
"API do Windows como ``CreateToolhelp32Snapshot()`` e ``Module32First()/"
"Module32Next()`` para enumerar módulos carregados. A função "
"``OpenProcess()`` fornece um identificador para aceder ao espaço de memória "
"do processo de destino, permitindo operações de memória através de "
"``ReadProcessMemory()``."

#: ../../howto/remote_debugging.rst:308
msgid ""
"The process memory can be examined by enumerating loaded modules to find the "
"Python binary or DLL. When found, its PE headers need to be parsed to locate "
"the ``PyRuntime`` structure."
msgstr ""
"A memória do processo pode ser examinada enumerando os módulos carregados "
"para encontrar o binário Python ou a DLL. Quando encontrado, os seus "
"cabeçalhos PE precisam de ser analisados para localizar a estrutura "
"``PyRuntime``."

#: ../../howto/remote_debugging.rst:312
msgid ""
"The PE format organizes code and data into sections. The ``PyRuntime`` "
"structure lives in a section named \"PyRuntim\" (truncated from "
"\"PyRuntime\" due to PE's 8-character name limit). The actual runtime "
"address calculation involves finding the module's base address from the "
"module entry, then locating our target section in the PE headers. The final "
"address is computed by combining the base address with the section's virtual "
"address from the PE section headers."
msgstr ""
"O formato PE organiza o código e os dados em secções. A estrutura "
"``PyRuntime`` reside numa secção chamada \"PyRuntim\" (truncada de "
"\"PyRuntime\" devido ao limite de 8 caracteres do PE). O cálculo do endereço "
"real em tempo de execução envolve encontrar o endereço base do módulo a "
"partir da entrada do módulo, depois localizar a secção de destino nos "
"cabeçalhos PE. O endereço final é calculado combinando o endereço base com o "
"endereço virtual da secção dos cabeçalhos da secção PE."

#: ../../howto/remote_debugging.rst:319
msgid ""
"Note that accessing another process's memory on Windows typically requires "
"appropriate privileges - either administrative access or the "
"``SeDebugPrivilege`` privilege granted to the debugging process."
msgstr ""
"Note que aceder à memória de outro processo no Windows geralmente requer "
"privilégios adequados - acesso administrativo ou o privilégio "
"``SeDebugPrivilege`` concedido ao processo de depuração."

#: ../../howto/remote_debugging.rst:325
msgid "Reading _Py_DebugOffsets"
msgstr "Ler _Py_DebugOffsets"

#: ../../howto/remote_debugging.rst:327
msgid ""
"Once the address of the ``PyRuntime`` structure has been determined, the "
"next step is to read the ``_Py_DebugOffsets`` structure located at the "
"beginning of the ``PyRuntime`` block."
msgstr ""
"Uma vez determinado o endereço da estrutura ``PyRuntime``, o próximo passo é "
"ler a estrutura ``_Py_DebugOffsets`` localizada no início do bloco "
"``PyRuntime``."

#: ../../howto/remote_debugging.rst:331
msgid ""
"This structure provides version-specific field offsets that are needed to "
"safely read interpreter and thread state memory. These offsets vary between "
"CPython versions and must be checked before use to ensure they are "
"compatible."
msgstr ""
"Esta estrutura fornece deslocamentos de campo específicos da versão que são "
"necessários para ler com segurança a memória do estado do interpretador e da "
"thread. Estes deslocamentos variam entre versões do CPython e devem ser "
"verificados antes do uso para garantir que são compatíveis."

#: ../../howto/remote_debugging.rst:335
msgid "To read and check the debug offsets, follow these steps:"
msgstr "Para ler e verificar os deslocamentos de depuração, siga estes passos:"

#: ../../howto/remote_debugging.rst:337
msgid ""
"Read memory from the target process starting at the ``PyRuntime`` address, "
"covering the same number of bytes as the ``_Py_DebugOffsets`` structure. "
"This structure is located at the very start of the ``PyRuntime`` memory "
"block. Its layout is defined in CPython’s internal headers and stays the "
"same within a given minor version, but may change in major versions."
msgstr ""
"Ler a memória do processo de destino a partir do endereço ``PyRuntime``, "
"cobrindo o mesmo número de bytes que a estrutura ``_Py_DebugOffsets``. Esta "
"estrutura está localizada no início do bloco de memória ``PyRuntime``. O seu "
"layout é definido nos cabeçalhos internos do CPython e permanece o mesmo "
"dentro de uma versão secundária, mas pode mudar em versões principais."

#: ../../howto/remote_debugging.rst:343
msgid "Check that the structure contains valid data:"
msgstr "Verificar se a estrutura contém dados válidos:"

#: ../../howto/remote_debugging.rst:345
msgid "The ``cookie`` field must match the expected debug marker."
msgstr ""
"O campo ``cookie`` deve corresponder ao marcador de depuração esperado."

#: ../../howto/remote_debugging.rst:346
msgid ""
"The ``version`` field must match the version of the Python interpreter used "
"by the debugger."
msgstr ""
"O campo ``version`` deve corresponder à versão do interpretador Python usado "
"pelo depurador."

#: ../../howto/remote_debugging.rst:348
msgid ""
"If either the debugger or the target process is using a pre-release version "
"(for example, an alpha, beta, or release candidate), the versions must match "
"exactly."
msgstr ""
"Se o depurador ou o processo de destino estiver a usar uma versão pré-"
"lançamento (por exemplo, alpha, beta ou candidato a lançamento), as versões "
"devem corresponder exatamente."

#: ../../howto/remote_debugging.rst:351
msgid ""
"The ``free_threaded`` field must have the same value in both the debugger "
"and the target process."
msgstr ""
"O campo ``free_threaded`` deve ter o mesmo valor no depurador e no processo "
"de destino."

#: ../../howto/remote_debugging.rst:354
msgid ""
"If the structure is valid, the offsets it contains can be used to locate "
"fields in memory. If any check fails, the debugger should stop the operation "
"to avoid reading memory in the wrong format."
msgstr ""
"Se a estrutura for válida, os deslocamentos que contém podem ser usados para "
"localizar campos na memória. Se alguma verificação falhar, o depurador deve "
"parar a operação para evitar ler a memória no formato errado."

#: ../../howto/remote_debugging.rst:358
msgid ""
"The following is an example implementation that reads and checks "
"``_Py_DebugOffsets``::"
msgstr ""
"A seguinte é uma implementação de exemplo que lê e verifica "
"``_Py_DebugOffsets``:"

#: ../../howto/remote_debugging.rst:361
msgid ""
"def read_debug_offsets(pid: int, py_runtime_addr: int) -> DebugOffsets:\n"
"    # Step 1: Read memory from the target process at the PyRuntime address\n"
"    data = read_process_memory(\n"
"        pid, address=py_runtime_addr, size=DEBUG_OFFSETS_SIZE\n"
"    )\n"
"\n"
"    # Step 2: Deserialize the raw bytes into a _Py_DebugOffsets structure\n"
"    debug_offsets = parse_debug_offsets(data)\n"
"\n"
"    # Step 3: Validate the contents of the structure\n"
"    if debug_offsets.cookie != EXPECTED_COOKIE:\n"
"        raise RuntimeError(\"Invalid or missing debug cookie\")\n"
"    if debug_offsets.version != LOCAL_PYTHON_VERSION:\n"
"        raise RuntimeError(\n"
"            \"Mismatch between caller and target Python versions\"\n"
"        )\n"
"    if debug_offsets.free_threaded != LOCAL_FREE_THREADED:\n"
"        raise RuntimeError(\"Mismatch in free-threaded configuration\")\n"
"\n"
"    return debug_offsets"
msgstr ""
"def read_debug_offsets(pid: int, py_runtime_addr: int) -> DebugOffsets:\n"
"    # Passo 1: Ler a memória do processo de destino no endereço PyRuntime\n"
"    data = read_process_memory(\n"
"        pid, address=py_runtime_addr, size=DEBUG_OFFSETS_SIZE\n"
"    )\n"
"\n"
"    # Passo 2: Desserializar os bytes brutos numa estrutura "
"_Py_DebugOffsets\n"
"    debug_offsets = parse_debug_offsets(data)\n"
"\n"
"    # Passo 3: Validar o conteúdo da estrutura\n"
"    if debug_offsets.cookie != EXPECTED_COOKIE:\n"
"        raise RuntimeError(\"Cookie de depuração inválido ou em falta\")\n"
"    if debug_offsets.version != LOCAL_PYTHON_VERSION:\n"
"        raise RuntimeError(\n"
"            \"Incompatibilidade entre as versões Python do chamador e do "
"destino\"\n"
"        )\n"
"    if debug_offsets.free_threaded != LOCAL_FREE_THREADED:\n"
"        raise RuntimeError(\"Incompatibilidade na configuração free-"
"threaded\")\n"
"\n"
"    return debug_offsets"

#: ../../howto/remote_debugging.rst:386
msgid "**Process suspension recommended**"
msgstr "**Recomendada a suspensão do processo**"

#: ../../howto/remote_debugging.rst:388
msgid ""
"To avoid race conditions and ensure memory consistency, it is strongly "
"recommended that the target process be suspended before performing any "
"operations that read or write internal interpreter state. The Python runtime "
"may concurrently mutate interpreter data structures—such as creating or "
"destroying threads—during normal execution. This can result in invalid "
"memory reads or writes."
msgstr ""
"Para evitar condições de corrida e garantir a consistência da memória, é "
"fortemente recomendado que o processo de destino seja suspenso antes de "
"realizar quaisquer operações que leiam ou escrevam no estado interno do "
"interpretador. O runtime do Python pode mutar concorrentemente estruturas de "
"dados do interpretador — como criar ou destruir threads — durante a execução "
"normal. Isto pode resultar em leituras ou escritas de memória inválidas."

#: ../../howto/remote_debugging.rst:395
msgid ""
"A debugger may suspend execution by attaching to the process with ``ptrace`` "
"or by sending a ``SIGSTOP`` signal. Execution should only be resumed after "
"debugger-side memory operations are complete."
msgstr ""
"Um depurador pode suspender a execução anexando-se ao processo com "
"``ptrace`` ou enviando um sinal ``SIGSTOP``. A execução só deve ser retomada "
"após a conclusão das operações de memória do lado do depurador."

#: ../../howto/remote_debugging.rst:401
msgid ""
"Some tools, such as profilers or sampling-based debuggers, may operate on a "
"running process without suspension. In such cases, tools must be explicitly "
"designed to handle partially updated or inconsistent memory. For most "
"debugger implementations, suspending the process remains the safest and most "
"robust approach."
msgstr ""
"Algumas ferramentas, como perfiladores ou depuradores baseados em "
"amostragem, podem operar num processo em execução sem suspensão. Nesses "
"casos, as ferramentas devem ser explicitamente concebidas para lidar com "
"memória parcialmente atualizada ou inconsistente. Para a maioria das "
"implementações de depuradores, suspender o processo continua a ser a "
"abordagem mais segura e robusta."

#: ../../howto/remote_debugging.rst:409
msgid "Locating the interpreter and thread state"
msgstr "Localizar o interpretador e o estado da thread"

#: ../../howto/remote_debugging.rst:411
msgid ""
"Before code can be injected and executed in a remote Python process, the "
"debugger must choose a thread in which to schedule execution. This is "
"necessary because the control fields used to perform remote code injection "
"are located in the ``_PyRemoteDebuggerSupport`` structure, which is embedded "
"in a ``PyThreadState`` object. These fields are modified by the debugger to "
"request execution of injected scripts."
msgstr ""
"Antes que o código possa ser injetado e executado num processo Python "
"remoto, o depurador deve escolher uma thread na qual agendar a execução. "
"Isto é necessário porque os campos de controlo usados para realizar a "
"injeção de código remoto estão localizados na estrutura "
"``_PyRemoteDebuggerSupport``, que está incorporada num objeto "
"``PyThreadState``. Estes campos são modificados pelo depurador para "
"solicitar a execução de scripts injetados."

#: ../../howto/remote_debugging.rst:418
msgid ""
"The ``PyThreadState`` structure represents a thread running inside a Python "
"interpreter.  It maintains the thread’s evaluation context and contains the "
"fields required for debugger coordination.  Locating a valid "
"``PyThreadState`` is therefore a key prerequisite for triggering execution "
"remotely."
msgstr ""
"A estrutura ``PyThreadState`` representa uma thread em execução dentro de um "
"interpretador Python. Mantém o contexto de avaliação da thread e contém os "
"campos necessários para a coordenação do depurador. Localizar um "
"``PyThreadState`` válido é, portanto, um pré-requisito chave para "
"desencadear a execução remotamente."

#: ../../howto/remote_debugging.rst:423
msgid ""
"A thread is typically selected based on its role or ID. In most cases, the "
"main thread is used, but some tools may target a specific thread by its "
"native thread ID. Once the target thread is chosen, the debugger must locate "
"both the interpreter and the associated thread state structures in memory."
msgstr ""
"Uma thread é tipicamente selecionada com base no seu papel ou ID. Na maioria "
"dos casos, a thread principal é usada, mas algumas ferramentas podem "
"direcionar uma thread específica pelo seu ID de thread nativo. Uma vez "
"escolhida a thread de destino, o depurador deve localizar tanto o "
"interpretador quanto as estruturas de estado da thread associada na memória."

#: ../../howto/remote_debugging.rst:428
msgid "The relevant internal structures are defined as follows:"
msgstr "As estruturas internas relevantes são definidas da seguinte forma:"

#: ../../howto/remote_debugging.rst:430
msgid ""
"``PyInterpreterState`` represents an isolated Python interpreter instance. "
"Each interpreter maintains its own set of imported modules, built-in state, "
"and thread state list. Although most Python applications use a single "
"interpreter, CPython supports multiple interpreters in the same process."
msgstr ""
"``PyInterpreterState`` representa uma instância isolada do interpretador "
"Python. Cada interpretador mantém o seu próprio conjunto de módulos "
"importados, estado integrado e lista de estados de thread. Embora a maioria "
"das aplicações Python use um único interpretador, o CPython suporta vários "
"interpretadores no mesmo processo."

#: ../../howto/remote_debugging.rst:435
msgid ""
"``PyThreadState`` represents a thread running within an interpreter. It "
"contains execution state and the control fields used by the debugger."
msgstr ""
"``PyThreadState`` representa uma thread em execução dentro de um "
"interpretador. Contém o estado de execução e os campos de controlo usados "
"pelo depurador."

#: ../../howto/remote_debugging.rst:438
msgid "To locate a thread:"
msgstr "Para localizar uma thread:"

#: ../../howto/remote_debugging.rst:440
msgid ""
"Use the offset ``runtime_state.interpreters_head`` to obtain the address of "
"the first interpreter in the ``PyRuntime`` structure. This is the entry "
"point to the linked list of active interpreters."
msgstr ""
"Use o deslocamento ``runtime_state.interpreters_head`` para obter o endereço "
"do primeiro interpretador na estrutura ``PyRuntime``. Este é o ponto de "
"entrada para a lista ligada de interpretadores ativos."

#: ../../howto/remote_debugging.rst:444
msgid ""
"Use the offset ``interpreter_state.threads_main`` to access the main thread "
"state associated with the selected interpreter. This is typically the most "
"reliable thread to target."
msgstr ""
"Use o deslocamento ``interpreter_state.threads_main`` para aceder ao estado "
"da thread principal associado ao interpretador selecionado. Esta é "
"tipicamente a thread mais confiável para direcionar."

#: ../../howto/remote_debugging.rst:448
msgid ""
"Optionally, use the offset ``interpreter_state.threads_head`` to iterate "
"through the linked list of all thread states. Each ``PyThreadState`` "
"structure contains a ``native_thread_id`` field, which may be compared to a "
"target thread ID to find a specific thread."
msgstr ""
"Opcionalmente, use o deslocamento ``interpreter_state.threads_head`` para "
"iterar através da lista ligada de todos os estados de thread. Cada estrutura "
"``PyThreadState`` contém um campo ``native_thread_id``, que pode ser "
"comparado com um ID de thread de destino para encontrar uma thread "
"específica."

#: ../../howto/remote_debugging.rst:453
msgid ""
"Once a valid ``PyThreadState`` has been found, its address can be used in "
"later steps of the protocol, such as writing debugger control fields and "
"scheduling execution."
msgstr ""
"Uma vez encontrado um ``PyThreadState`` válido, o seu endereço pode ser "
"usado em passos posteriores do protocolo, como escrever campos de controlo "
"do depurador e agendar a execução."

#: ../../howto/remote_debugging.rst:457
msgid ""
"The following is an example implementation that locates the main thread "
"state::"
msgstr ""
"A seguinte é uma implementação de exemplo que localiza o estado da thread "
"principal:"

#: ../../howto/remote_debugging.rst:459
msgid ""
"def find_main_thread_state(\n"
"    pid: int, py_runtime_addr: int, debug_offsets: DebugOffsets,\n"
") -> int:\n"
"    # Step 1: Read interpreters_head from PyRuntime\n"
"    interp_head_ptr = (\n"
"        py_runtime_addr + debug_offsets.runtime_state.interpreters_head\n"
"    )\n"
"    interp_addr = read_pointer(pid, interp_head_ptr)\n"
"    if interp_addr == 0:\n"
"        raise RuntimeError(\"No interpreter found in the target process\")\n"
"\n"
"    # Step 2: Read the threads_main pointer from the interpreter\n"
"    threads_main_ptr = (\n"
"        interp_addr + debug_offsets.interpreter_state.threads_main\n"
"    )\n"
"    thread_state_addr = read_pointer(pid, threads_main_ptr)\n"
"    if thread_state_addr == 0:\n"
"        raise RuntimeError(\"Main thread state is not available\")\n"
"\n"
"    return thread_state_addr"
msgstr ""
"def find_main_thread_state(\n"
"    pid: int, py_runtime_addr: int, debug_offsets: DebugOffsets,\n"
") -> int:\n"
"    # Passo 1: Ler interpreters_head do PyRuntime\n"
"    interp_head_ptr = (\n"
"        py_runtime_addr + debug_offsets.runtime_state.interpreters_head\n"
"    )\n"
"    interp_addr = read_pointer(pid, interp_head_ptr)\n"
"    if interp_addr == 0:\n"
"        raise RuntimeError(\"Nenhum interpretador encontrado no processo de "
"destino\")\n"
"\n"
"    # Passo 2: Ler o ponteiro threads_main do interpretador\n"
"    threads_main_ptr = (\n"
"        interp_addr + debug_offsets.interpreter_state.threads_main\n"
"    )\n"
"    thread_state_addr = read_pointer(pid, threads_main_ptr)\n"
"    if thread_state_addr == 0:\n"
"        raise RuntimeError(\"O estado da thread principal não está "
"disponível\")\n"
"\n"
"    return thread_state_addr"

#: ../../howto/remote_debugging.rst:480
msgid ""
"The following example demonstrates how to locate a thread by its native "
"thread ID::"
msgstr ""
"O seguinte exemplo demonstra como localizar uma thread pelo seu ID de thread "
"nativo:"

#: ../../howto/remote_debugging.rst:483
msgid ""
"def find_thread_by_id(\n"
"    pid: int,\n"
"    interp_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    target_tid: int,\n"
") -> int:\n"
"    # Start at threads_head and walk the linked list\n"
"    thread_ptr = read_pointer(\n"
"        pid,\n"
"        interp_addr + debug_offsets.interpreter_state.threads_head\n"
"    )\n"
"\n"
"    while thread_ptr:\n"
"        native_tid_ptr = (\n"
"            thread_ptr + debug_offsets.thread_state.native_thread_id\n"
"        )\n"
"        native_tid = read_int(pid, native_tid_ptr)\n"
"        if native_tid == target_tid:\n"
"            return thread_ptr\n"
"        thread_ptr = read_pointer(\n"
"            pid,\n"
"            thread_ptr + debug_offsets.thread_state.next\n"
"        )\n"
"\n"
"    raise RuntimeError(\"Thread with the given ID was not found\")"
msgstr ""
"def find_thread_by_id(\n"
"    pid: int,\n"
"    interp_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    target_tid: int,\n"
") -> int:\n"
"    # Começar em threads_head e percorrer a lista ligada\n"
"    thread_ptr = read_pointer(\n"
"        pid,\n"
"        interp_addr + debug_offsets.interpreter_state.threads_head\n"
"    )\n"
"\n"
"    while thread_ptr:\n"
"        native_tid_ptr = (\n"
"            thread_ptr + debug_offsets.thread_state.native_thread_id\n"
"        )\n"
"        native_tid = read_int(pid, native_tid_ptr)\n"
"        if native_tid == target_tid:\n"
"            return thread_ptr\n"
"        thread_ptr = read_pointer(\n"
"            pid,\n"
"            thread_ptr + debug_offsets.thread_state.next\n"
"        )\n"
"\n"
"    raise RuntimeError(\"Thread com o ID dado não foi encontrada\")"

#: ../../howto/remote_debugging.rst:510
msgid ""
"Once a valid thread state has been located, the debugger can proceed with "
"modifying its control fields and scheduling execution, as described in the "
"next section."
msgstr ""
"Uma vez localizado um estado de thread válido, o depurador pode prosseguir "
"com a modificação dos seus campos de controlo e agendar a execução, como "
"descrito na próxima secção."

#: ../../howto/remote_debugging.rst:515
msgid "Writing control information"
msgstr "Escrever informações de controlo"

#: ../../howto/remote_debugging.rst:517
msgid ""
"Once a valid ``PyThreadState`` structure has been identified, the debugger "
"may modify control fields within it to schedule the execution of a specified "
"Python script. These control fields are checked periodically by the "
"interpreter, and when set correctly, they trigger the execution of remote "
"code at a safe point in the evaluation loop."
msgstr ""
"Uma vez identificada uma estrutura ``PyThreadState`` válida, o depurador "
"pode modificar os campos de controlo dentro dela para agendar a execução de "
"um script Python especificado. Estes campos de controlo são verificados "
"periodicamente pelo interpretador e, quando definidos corretamente, "
"desencadeiam a execução de código remoto num ponto seguro no ciclo de "
"avaliação."

#: ../../howto/remote_debugging.rst:523
msgid ""
"Each ``PyThreadState`` contains a ``_PyRemoteDebuggerSupport`` structure "
"used for communication between the debugger and the interpreter. The "
"locations of its fields are defined by the ``_Py_DebugOffsets`` structure "
"and include the following:"
msgstr ""
"Cada ``PyThreadState`` contém uma estrutura ``_PyRemoteDebuggerSupport`` "
"usada para comunicação entre o depurador e o interpretador. As localizações "
"dos seus campos são definidas pela estrutura ``_Py_DebugOffsets`` e incluem "
"o seguinte:"

#: ../../howto/remote_debugging.rst:528
msgid ""
"``debugger_script_path``: A fixed-size buffer that holds the full path to a "
"Python source file (``.py``).  This file must be accessible and readable by "
"the target process when execution is triggered."
msgstr ""
"``debugger_script_path``: Um buffer de tamanho fixo que contém o caminho "
"completo para um ficheiro fonte Python (``.py``). Este ficheiro deve ser "
"acessível e legível pelo processo de destino quando a execução é "
"desencadeada."

#: ../../howto/remote_debugging.rst:532
msgid ""
"``debugger_pending_call``: An integer flag. Setting this to ``1`` tells the "
"interpreter that a script is ready to be executed."
msgstr ""
"``debugger_pending_call``: Uma flag inteira. Definir isto para ``1`` informa "
"o interpretador que um script está pronto para ser executado."

#: ../../howto/remote_debugging.rst:535
msgid ""
"``eval_breaker``: A field checked by the interpreter during execution. "
"Setting bit 5 (``_PY_EVAL_PLEASE_STOP_BIT``, value ``1U << 5``) in this "
"field causes the interpreter to pause and check for debugger activity."
msgstr ""
"``eval_breaker``: Um campo verificado pelo interpretador durante a execução. "
"Definir o bit 5 (``_PY_EVAL_PLEASE_STOP_BIT``, valor ``1U << 5``) neste "
"campo faz com que o interpretador pause e verifique a atividade do depurador."

#: ../../howto/remote_debugging.rst:539
msgid ""
"To complete the injection, the debugger must perform the following steps:"
msgstr ""
"Para completar a injeção, o depurador deve realizar os seguintes passos:"

#: ../../howto/remote_debugging.rst:541
msgid "Write the full script path into the ``debugger_script_path`` buffer."
msgstr ""
"Escrever o caminho completo do script no buffer ``debugger_script_path``."

#: ../../howto/remote_debugging.rst:542
msgid "Set ``debugger_pending_call`` to ``1``."
msgstr "Definir ``debugger_pending_call`` para ``1``."

#: ../../howto/remote_debugging.rst:543
msgid ""
"Read the current value of ``eval_breaker``, set bit 5 "
"(``_PY_EVAL_PLEASE_STOP_BIT``), and write the updated value back. This "
"signals the interpreter to check for debugger activity."
msgstr ""
"Ler o valor atual de ``eval_breaker``, definir o bit 5 "
"(``_PY_EVAL_PLEASE_STOP_BIT``), e escrever o valor atualizado de volta. Isto "
"sinaliza ao interpretador para verificar a atividade do depurador."

#: ../../howto/remote_debugging.rst:549
msgid ""
"def inject_script(\n"
"    pid: int,\n"
"    thread_state_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    script_path: str\n"
") -> None:\n"
"    # Compute the base offset of _PyRemoteDebuggerSupport\n"
"    support_base = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.remote_debugger_support\n"
"    )\n"
"\n"
"    # Step 1: Write the script path into debugger_script_path\n"
"    script_path_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_script_path\n"
"    )\n"
"    write_string(pid, script_path_ptr, script_path)\n"
"\n"
"    # Step 2: Set debugger_pending_call to 1\n"
"    pending_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_pending_call\n"
"    )\n"
"    write_int(pid, pending_ptr, 1)\n"
"\n"
"    # Step 3: Set _PY_EVAL_PLEASE_STOP_BIT (bit 5, value 1 << 5) in\n"
"    # eval_breaker\n"
"    eval_breaker_ptr = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.eval_breaker\n"
"    )\n"
"    breaker = read_int(pid, eval_breaker_ptr)\n"
"    breaker |= (1 << 5)\n"
"    write_int(pid, eval_breaker_ptr, breaker)"
msgstr ""
"def inject_script(\n"
"    pid: int,\n"
"    thread_state_addr: int,\n"
"    debug_offsets: DebugOffsets,\n"
"    script_path: str\n"
") -> None:\n"
"    # Calcular o deslocamento base de _PyRemoteDebuggerSupport\n"
"    support_base = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.remote_debugger_support\n"
"    )\n"
"\n"
"    # Passo 1: Escrever o caminho do script em debugger_script_path\n"
"    script_path_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_script_path\n"
"    )\n"
"    write_string(pid, script_path_ptr, script_path)\n"
"\n"
"    # Passo 2: Definir debugger_pending_call para 1\n"
"    pending_ptr = (\n"
"        support_base +\n"
"        debug_offsets.debugger_support.debugger_pending_call\n"
"    )\n"
"    write_int(pid, pending_ptr, 1)\n"
"\n"
"    # Passo 3: Definir _PY_EVAL_PLEASE_STOP_BIT (bit 5, valor 1 << 5) em\n"
"    # eval_breaker\n"
"    eval_breaker_ptr = (\n"
"        thread_state_addr +\n"
"        debug_offsets.debugger_support.eval_breaker\n"
"    )\n"
"    breaker = read_int(pid, eval_breaker_ptr)\n"
"    breaker |= (1 << 5)\n"
"    write_int(pid, eval_breaker_ptr, breaker)"

#: ../../howto/remote_debugging.rst:586
msgid ""
"Once these fields are set, the debugger may resume the process (if it was "
"suspended).  The interpreter will process the request at the next safe "
"evaluation point, load the script from disk, and execute it."
msgstr ""
"Uma vez definidos estes campos, o depurador pode retomar o processo (se este "
"estava suspenso). O interpretador processará o pedido no próximo ponto de "
"avaliação seguro, carregará o script do disco e executá-lo-á."

#: ../../howto/remote_debugging.rst:590
msgid ""
"It is the responsibility of the debugger to ensure that the script file "
"remains present and accessible to the target process during execution."
msgstr ""
"É responsabilidade do depurador garantir que o ficheiro do script permaneça "
"presente e acessível ao processo de destino durante a execução."

#: ../../howto/remote_debugging.rst:595
msgid ""
"Script execution is asynchronous. The script file cannot be deleted "
"immediately after injection. The debugger should wait until the injected "
"script has produced an observable effect before removing the file. This "
"effect depends on what the script is designed to do. For example, a debugger "
"might wait until the remote process connects back to a socket before "
"removing the script. Once such an effect is observed, it is safe to assume "
"the file is no longer needed."
msgstr ""
"A execução do script é assíncrona. O ficheiro do script não pode ser "
"eliminado imediatamente após a injeção. O depurador deve esperar até que o "
"script injetado tenha produzido um efeito observável antes de remover o "
"ficheiro. Este efeito depende do que o script foi concebido para fazer. Por "
"exemplo, um depurador pode esperar até que o processo remoto se reconecte a "
"um socket antes de remover o script. Uma vez observado tal efeito, é seguro "
"assumir que o ficheiro já não é necessário."

#: ../../howto/remote_debugging.rst:604
msgid "Summary"
msgstr "Resumo"

#: ../../howto/remote_debugging.rst:606
msgid "To inject and execute a Python script in a remote process:"
msgstr "Para injetar e executar um script Python num processo remoto:"

#: ../../howto/remote_debugging.rst:608
msgid "Locate the ``PyRuntime`` structure in the target process’s memory."
msgstr "Localizar a estrutura ``PyRuntime`` na memória do processo de destino."

#: ../../howto/remote_debugging.rst:609
msgid ""
"Read and validate the ``_Py_DebugOffsets`` structure at the beginning of "
"``PyRuntime``."
msgstr ""
"Ler e validar a estrutura ``_Py_DebugOffsets`` no início do ``PyRuntime``."

#: ../../howto/remote_debugging.rst:611
msgid "Use the offsets to locate a valid ``PyThreadState``."
msgstr "Usar os deslocamentos para localizar um ``PyThreadState`` válido."

#: ../../howto/remote_debugging.rst:612
msgid "Write the path to a Python script into ``debugger_script_path``."
msgstr "Escrever o caminho para um script Python em ``debugger_script_path``."

#: ../../howto/remote_debugging.rst:613
msgid "Set the ``debugger_pending_call`` flag to ``1``."
msgstr "Definir a flag ``debugger_pending_call`` para ``1``."

#: ../../howto/remote_debugging.rst:614
msgid "Set ``_PY_EVAL_PLEASE_STOP_BIT`` in the ``eval_breaker`` field."
msgstr "Definir ``_PY_EVAL_PLEASE_STOP_BIT`` no campo ``eval_breaker``."

#: ../../howto/remote_debugging.rst:615
msgid ""
"Resume the process (if suspended). The script will execute at the next safe "
"evaluation point."
msgstr ""
"Retomar o processo (se suspenso). O script será executado no próximo ponto "
"de avaliação seguro."
