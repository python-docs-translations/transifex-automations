# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# NyaPuma <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-29 14:13+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: NyaPuma <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Estruturas Comuns de Objetos"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Existe um grande número de estruturas utilizadas na definição de tipos de "
"objetos em Python. Esta secção descreve essas estruturas e como são "
"utilizadas."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Tipos base de objetos e macros"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"Todos os objetos Python partilham, em última instância, um pequeno número de "
"campos no início da representação do objeto na memória. Estes são "
"representados pelos tipos :c:type:`PyObject` e :c:type:`PyVarObject`, que "
"são definidos, por sua vez, pelas expansões de algumas macros também "
"utilizadas, direta ou indiretamente, na definição de todos os outros objetos "
"Python. Macros adicionais podem ser encontradas em :ref:`contagem de "
"referências <countingrefs>`."

#: ../../c-api/structures.rst:26
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`."
msgstr ""
"Todos os tipos de objetos são extensões deste tipo. Este é um tipo que "
"contém a informação que o Python necessita para tratar um ponteiro para um "
"objeto como um objeto. Numa compilação \"release\" normal, contém apenas a "
"contagem de referências do objeto e um ponteiro para o objeto de tipo "
"correspondente. Nada é declarado explicitamente como :c:type:`PyObject`, mas "
"qualquer ponteiro para um objeto Python pode ser convertido para :c:expr:"
"`PyObject*`."

#: ../../c-api/structures.rst:33
msgid ""
"The members must not be accessed directly; instead use macros such as :c:"
"macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Os membros não devem ser acedidos diretamente; em vez disso, utilize macros "
"como :c:macro:`Py_REFCNT` e :c:macro:`Py_TYPE`."

#: ../../c-api/structures.rst:38
msgid ""
"The object's reference count, as returned by :c:macro:`Py_REFCNT`. Do not "
"use this field directly; instead use functions and macros such as :c:macro:`!"
"Py_REFCNT`, :c:func:`Py_INCREF` and :c:func:`Py_DecRef`."
msgstr ""
"A contagem de referências do objeto, conforme retornado por :c:macro:"
"`Py_REFCNT`. Não utilize este campo diretamente; em vez disso, utilize "
"funções e macros como :c:macro:`!Py_REFCNT`, :c:func:`Py_INCREF` e :c:func:"
"`Py_DecRef`."

#: ../../c-api/structures.rst:42
msgid ""
"The field type may be different from ``Py_ssize_t``, depending on build "
"configuration and platform."
msgstr ""
"O tipo do campo pode ser diferente de ``Py_ssize_t``, dependendo da "
"configuração da compilação e da plataforma."

#: ../../c-api/structures.rst:47
msgid ""
"The object's type. Do not use this field directly; use :c:macro:`Py_TYPE` "
"and :c:func:`Py_SET_TYPE` instead."
msgstr ""
"O tipo do objeto. Não utilize este campo diretamente; utilize :c:macro:"
"`Py_TYPE` e :c:func:`Py_SET_TYPE` em vez disso."

#: ../../c-api/structures.rst:54
msgid ""
"An extension of :c:type:`PyObject` that adds the :c:member:`~PyVarObject."
"ob_size` field. This is intended for objects that have some notion of "
"*length*."
msgstr ""
"Uma extensão de :c:type:`PyObject` que adiciona o campo :c:member:"
"`~PyVarObject.ob_size`. Isto destina-se a objetos que têm uma noção de "
"*comprimento*."

#: ../../c-api/structures.rst:58
msgid ""
"As with :c:type:`!PyObject`, the members must not be accessed directly; "
"instead use macros such as :c:macro:`Py_SIZE`, :c:macro:`Py_REFCNT` and :c:"
"macro:`Py_TYPE`."
msgstr ""
"Tal como com :c:type:`!PyObject`, os membros não devem ser acedidos "
"diretamente; em vez disso, utilize macros como :c:macro:`Py_SIZE`, :c:macro:"
"`Py_REFCNT` e :c:macro:`Py_TYPE`."

#: ../../c-api/structures.rst:64
msgid ""
"A size field, whose contents should be considered an object's internal "
"implementation detail."
msgstr ""
"Um campo de tamanho, cujo conteúdo deve ser considerado um detalhe interno "
"da implementação do objeto."

#: ../../c-api/structures.rst:67
msgid "Do not use this field directly; use :c:macro:`Py_SIZE` instead."
msgstr ""
"Não utilize este campo diretamente; utilize :c:macro:`Py_SIZE` em vez disso."

#: ../../c-api/structures.rst:69
msgid ""
"Object creation functions such as :c:func:`PyObject_NewVar` will generally "
"set this field to the requested size (number of items). After creation, "
"arbitrary values can be stored in :c:member:`!ob_size` using :c:macro:"
"`Py_SET_SIZE`."
msgstr ""
"Funções de criação de objetos, como :c:func:`PyObject_NewVar`, geralmente "
"definem este campo para o tamanho solicitado (número de itens). Após a "
"criação, valores arbitrários podem ser armazenados em :c:member:`!ob_size` "
"utilizando :c:macro:`Py_SET_SIZE`."

#: ../../c-api/structures.rst:74
msgid ""
"To get an object's publicly exposed length, as returned by the Python "
"function :py:func:`len`, use :c:func:`PyObject_Length` instead."
msgstr ""
"Para obter o comprimento publicamente exposto de um objeto, conforme "
"retornado pela função Python :py:func:`len`, utilize :c:func:"
"`PyObject_Length` em vez disso."

#: ../../c-api/structures.rst:81
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Esta é uma macro utilizada ao declarar novos tipos que representam objetos "
"sem comprimento variável. A macro PyObject_HEAD expande-se para::"

#: ../../c-api/structures.rst:84
msgid "PyObject ob_base;"
msgstr "PyObject ob_base;"

#: ../../c-api/structures.rst:86
msgid "See documentation of :c:type:`PyObject` above."
msgstr "Consulte a documentação de :c:type:`PyObject` acima."

#: ../../c-api/structures.rst:91
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Esta é uma macro utilizada ao declarar novos tipos que representam objetos "
"com um comprimento que varia de instância para instância. A macro "
"PyObject_VAR_HEAD expande-se para::"

#: ../../c-api/structures.rst:95
msgid "PyVarObject ob_base;"
msgstr "PyVarObject ob_base;"

#: ../../c-api/structures.rst:97
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Consulte a documentação de :c:type:`PyVarObject` acima."

#: ../../c-api/structures.rst:102
msgid ""
"The base class of all other objects, the same as :class:`object` in Python."
msgstr ""
"A classe base de todos os outros objetos, a mesma que :class:`object` em "
"Python."

#: ../../c-api/structures.rst:107
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Testa se o objeto *x* é o objeto *y*, o mesmo que ``x is y`` em Python."

#: ../../c-api/structures.rst:114
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Testa se um objeto é o singleton ``None``, o mesmo que ``x is None`` em "
"Python."

#: ../../c-api/structures.rst:122
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Testa se um objeto é o singleton ``True``, o mesmo que ``x is True`` em "
"Python."

#: ../../c-api/structures.rst:130
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Testa se um objeto é o singleton ``False``, o mesmo que ``x is False`` em "
"Python."

#: ../../c-api/structures.rst:138
msgid "Get the type of the Python object *o*."
msgstr "Obtém o tipo do objeto Python *o*."

#: ../../c-api/structures.rst:140
msgid ""
"The returned reference is :term:`borrowed <borrowed reference>` from *o*. Do "
"not release it with :c:func:`Py_DECREF` or similar."
msgstr ""
"A referência retornada é :term:`emprestada <borrowed reference>` de *o*. Não "
"a libere com :c:func:`Py_DECREF` ou similar."

#: ../../c-api/structures.rst:143
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` foi alterada para uma função estática em linha. O "
"parâmetro type já não é :c:expr:`const PyObject*`."

#: ../../c-api/structures.rst:150
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Retorna um valor não-zero se o tipo do objeto *o* for *type*. Retorna zero "
"caso contrário. Equivalente a: ``Py_TYPE(o) == type``."

#: ../../c-api/structures.rst:158
msgid ""
"Set the type of object *o* to *type*, without any checking or reference "
"counting."
msgstr ""
"Define o tipo do objeto *o* para *type*, sem qualquer verificação ou "
"contagem de referências."

#: ../../c-api/structures.rst:161
msgid ""
"This is a very low-level operation. Consider instead setting the Python "
"attribute :attr:`~object.__class__` using :c:func:`PyObject_SetAttrString` "
"or similar."
msgstr ""
"Esta é uma operação de muito baixo nível. Considere, em vez disso, definir o "
"atributo Python :attr:`~object.__class__` utilizando :c:func:"
"`PyObject_SetAttrString` ou similar."

#: ../../c-api/structures.rst:165
msgid ""
"Note that assigning an incompatible type can lead to undefined behavior."
msgstr ""
"Note que atribuir um tipo incompatível pode levar a comportamento indefinido."

#: ../../c-api/structures.rst:167
msgid ""
"If *type* is a :ref:`heap type <heap-types>`, the caller must create a new "
"reference to it. Similarly, if the old type of *o* is a heap type, the "
"caller must release a reference to that type."
msgstr ""
"Se *type* for um :ref:`tipo heap <heap-types>`, o chamador deve criar uma "
"nova referência para ele. Da mesma forma, se o tipo antigo de *o* for um "
"tipo heap, o chamador deve libertar uma referência para esse tipo."

#: ../../c-api/structures.rst:177
msgid "Get the :c:member:`~PyVarObject.ob_size` field of *o*."
msgstr "Obtém o campo :c:member:`~PyVarObject.ob_size` de *o*."

#: ../../c-api/structures.rst:179
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` foi alterada para uma função estática em linha. O "
"parâmetro type já não é :c:expr:`const PyVarObject*`."

#: ../../c-api/structures.rst:186
msgid "Set the :c:member:`~PyVarObject.ob_size` field of *o* to *size*."
msgstr "Define o campo :c:member:`~PyVarObject.ob_size` de *o* para *size*."

#: ../../c-api/structures.rst:193
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Esta é uma macro que se expande para valores de inicialização para um novo "
"tipo :c:type:`PyObject`. Esta macro expande-se para::"

#: ../../c-api/structures.rst:196
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type,"

#: ../../c-api/structures.rst:202
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field. "
"This macro expands to::"
msgstr ""
"Esta é uma macro que se expande para valores de inicialização para um novo "
"tipo :c:type:`PyVarObject`, incluindo o campo :c:member:`~PyVarObject."
"ob_size`. Esta macro expande-se para::"

#: ../../c-api/structures.rst:206
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"

#: ../../c-api/structures.rst:211
msgid "Implementing functions and methods"
msgstr "Implementação de funções e métodos"

#: ../../c-api/structures.rst:215
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Tipo das funções utilizadas para implementar a maioria dos objetos chamáveis "
"em Python em C. Funções deste tipo recebem dois parâmetros :c:expr:"
"`PyObject*` e retornam um valor desse tipo. Se o valor de retorno for "
"``NULL``, uma exceção deve ter sido definida. Se não for ``NULL``, o valor "
"de retorno é interpretado como o valor de retorno da função conforme exposto "
"em Python. A função deve retornar uma nova referência."

#: ../../c-api/structures.rst:222
msgid "The function signature is::"
msgstr "A assinatura da função é::"

#: ../../c-api/structures.rst:224
msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"

#: ../../c-api/structures.rst:229
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-"
"METH_KEYWORDS>`. A assinatura da função é::"

#: ../../c-api/structures.rst:233
msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"

#: ../../c-api/structures.rst:240
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :c:macro:`METH_FASTCALL`. A assinatura da função é::"

#: ../../c-api/structures.rst:244
msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"

#: ../../c-api/structures.rst:250
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. A assinatura da função é::"

#: ../../c-api/structures.rst:254
msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"

#: ../../c-api/structures.rst:261
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo das funções utilizadas para implementar objetos chamáveis em Python em "
"C com a assinatura :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS "
"<METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`. A assinatura da função é::"

#: ../../c-api/structures.rst:265
msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"

#: ../../c-api/structures.rst:276
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Estrutura utilizada para descrever um método de um tipo de extensão. Esta "
"estrutura tem quatro campos:"

#: ../../c-api/structures.rst:281
msgid "Name of the method."
msgstr "Nome do método."

#: ../../c-api/structures.rst:285
msgid "Pointer to the C implementation."
msgstr "Ponteiro para a implementação em C."

#: ../../c-api/structures.rst:289
msgid "Flags bits indicating how the call should be constructed."
msgstr "Bits de flags que indicam como a chamada deve ser construída."

#: ../../c-api/structures.rst:293
msgid "Points to the contents of the docstring."
msgstr "Aponta para o conteúdo da docstring."

#: ../../c-api/structures.rst:295
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
"O :c:member:`~PyMethodDef.ml_meth` é um ponteiro para uma função em C. As "
"funções podem ser de tipos diferentes, mas sempre retornam :c:expr:"
"`PyObject*`. Se a função não for do tipo :c:type:`PyCFunction`, o compilador "
"exigirá um cast na tabela de métodos. Embora :c:type:`PyCFunction` defina o "
"primeiro parâmetro como :c:expr:`PyObject*`, é comum que a implementação do "
"método utilize o tipo C específico do objeto *self*."

#: ../../c-api/structures.rst:303
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"O campo :c:member:`~PyMethodDef.ml_flags` é um campo de bits que pode "
"incluir as seguintes flags. As flags individuais indicam uma convenção de "
"chamada ou uma convenção de ligação."

#: ../../c-api/structures.rst:308
msgid "There are these calling conventions:"
msgstr "Existem as seguintes convenções de chamada:"

#: ../../c-api/structures.rst:312
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Esta é a convenção de chamada típica, onde os métodos têm o tipo :c:type:"
"`PyCFunction`. A função espera dois valores :c:expr:`PyObject*`. O primeiro "
"é o objeto *self* para métodos; para funções de módulo, é o objeto módulo. O "
"segundo parâmetro (geralmente chamado *args*) é um objeto tuplo que "
"representa todos os argumentos. Este parâmetro é tipicamente processado "
"utilizando :c:func:`PyArg_ParseTuple` ou :c:func:`PyArg_UnpackTuple`."

#: ../../c-api/structures.rst:322
msgid ""
"Can only be used in certain combinations with other flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."
msgstr ""
"Pode ser utilizada apenas em certas combinações com outras flags: :ref:"
"`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`, :ref:"
"`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` e :ref:"
"`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-"
"METH_KEYWORDS>`."

#: ../../c-api/structures.rst:330
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ":c:expr:`METH_VARARGS | METH_KEYWORDS`"

#: ../../c-api/structures.rst:331
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Métodos com estas flags devem ser do tipo :c:type:`PyCFunctionWithKeywords`. "
"A função espera três parâmetros: *self*, *args*, *kwargs*, onde *kwargs* é "
"um dicionário de todos os argumentos nomeados ou possivelmente ``NULL`` se "
"não houver argumentos nomeados. Os parâmetros são tipicamente processados "
"utilizando :c:func:`PyArg_ParseTupleAndKeywords`."

#: ../../c-api/structures.rst:340
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Convenção de chamada rápida que suporta apenas argumentos posicionais. Os "
"métodos têm o tipo :c:type:`PyCFunctionFast`. O primeiro parâmetro é *self*, "
"o segundo parâmetro é um array C de valores :c:expr:`PyObject*` que indicam "
"os argumentos e o terceiro parâmetro é o número de argumentos (o comprimento "
"do array)."

#: ../../c-api/structures.rst:350
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr "``METH_FASTCALL`` faz agora parte da :ref:`ABI estável <stable-abi>`."

#: ../../c-api/structures.rst:355
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:356
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Extensão de :c:macro:`METH_FASTCALL` que suporta também argumentos nomeados, "
"com métodos do tipo :c:type:`PyCFunctionFastWithKeywords`. Os argumentos "
"nomeados são passados da mesma forma que no protocolo :ref:`vectorcall "
"<vectorcall>`: existe um quarto parâmetro adicional :c:expr:`PyObject*` que "
"é um tuplo representando os nomes dos argumentos nomeados (que são "
"garantidamente strings) ou possivelmente ``NULL`` se não houver argumentos "
"nomeados. Os valores dos argumentos nomeados são armazenados no array "
"*args*, após os argumentos posicionais."

#: ../../c-api/structures.rst:371
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""
"Pode ser utilizada apenas em combinação com outras flags: :ref:`METH_METHOD "
"| METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."

#: ../../c-api/structures.rst:377
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"

#: ../../c-api/structures.rst:378
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Extensão de :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` que suporta a *classe de definição*, ou seja, a classe que "
"contém o método em questão. A classe de definição pode ser uma superclasse "
"de ``Py_TYPE(self)``."

#: ../../c-api/structures.rst:383
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"O método precisa de ser do tipo :c:type:`PyCMethod`, o mesmo que para "
"``METH_FASTCALL | METH_KEYWORDS`` com o argumento ``defining_class`` "
"adicionado após ``self``."

#: ../../c-api/structures.rst:392
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Métodos sem parâmetros não precisam de verificar se são fornecidos "
"argumentos se forem listados com a flag :c:macro:`METH_NOARGS`. Devem ser do "
"tipo :c:type:`PyCFunction`. O primeiro parâmetro é tipicamente chamado "
"*self* e conterá uma referência ao módulo ou instância do objeto. Em todos "
"os casos, o segundo parâmetro será ``NULL``."

#: ../../c-api/structures.rst:398
msgid ""
"The function must have 2 parameters. Since the second parameter is unused, :"
"c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"A função deve ter 2 parâmetros. Como o segundo parâmetro não é utilizado, "
"pode ser usada a macro :c:macro:`Py_UNUSED` para evitar um aviso do "
"compilador."

#: ../../c-api/structures.rst:404
msgid ""
"Methods with a single object argument can be listed with the :c:macro:"
"`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` with a "
"``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with the "
"*self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Métodos com um único argumento de objeto podem ser listados com a flag :c:"
"macro:`METH_O`, em vez de invocar :c:func:`PyArg_ParseTuple` com um "
"argumento ``\"O\"``. Têm o tipo :c:type:`PyCFunction`, com o parâmetro "
"*self* e um parâmetro :c:expr:`PyObject*` que representa o argumento único."

#: ../../c-api/structures.rst:410
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Estas duas constantes não são utilizadas para indicar a convenção de "
"chamada, mas sim a ligação quando usadas com métodos de classes. Não podem "
"ser utilizadas para funções definidas para módulos. No máximo, uma destas "
"flags pode ser definida para qualquer método dado."

#: ../../c-api/structures.rst:420
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"O método receberá o objeto de tipo como primeiro parâmetro em vez de uma "
"instância do tipo. Isto é utilizado para criar *métodos de classe*, "
"semelhante ao que é criado ao utilizar a função incorporada :func:"
"`classmethod`."

#: ../../c-api/structures.rst:430
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"O método receberá ``NULL`` como primeiro parâmetro em vez de uma instância "
"do tipo. Isto é utilizado para criar *métodos estáticos*, semelhante ao que "
"é criado ao utilizar a função incorporada :func:`staticmethod`."

#: ../../c-api/structures.rst:434
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Outra constante controla se um método é carregado no lugar de outra "
"definição com o mesmo nome de método."

#: ../../c-api/structures.rst:440
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`~object.__contains__` and preclude the loading of a corresponding "
"PyCFunction with the same name.  With the flag defined, the PyCFunction will "
"be loaded in place of the wrapper object and will co-exist with the slot.  "
"This is helpful because calls to PyCFunctions are optimized more than "
"wrapper object calls."
msgstr ""
"O método será carregado no lugar de definições existentes. Sem "
"*METH_COEXIST*, o comportamento predefinido é ignorar definições repetidas. "
"Como os wrappers de slots são carregados antes da tabela de métodos, a "
"existência de um slot *sq_contains*, por exemplo, geraria um método "
"encapsulado chamado :meth:`~object.__contains__` e impediria o carregamento "
"de uma PyCFunction correspondente com o mesmo nome. Com a flag definida, a "
"PyCFunction será carregada no lugar do objeto wrapper e coexistirá com o "
"slot. Isto é útil porque as chamadas para PyCFunctions são mais otimizadas "
"do que as chamadas para objetos wrapper."

#: ../../c-api/structures.rst:453
msgid ""
"The type object corresponding to Python C method objects. This is available "
"as :class:`types.BuiltinMethodType` in the Python layer."
msgstr ""
"O objeto de tipo correspondente a objetos de métodos C em Python. Isto está "
"disponível como :class:`types.BuiltinMethodType` na camada Python."

#: ../../c-api/structures.rst:459
msgid ""
"Return true if *op* is an instance of the :c:type:`PyCMethod_Type` type or a "
"subtype of it. This function always succeeds."
msgstr ""
"Retorna verdadeiro se *op* for uma instância do tipo :c:type:"
"`PyCMethod_Type` ou de um subtipo deste. Esta função sempre tem sucesso."

#: ../../c-api/structures.rst:465
msgid ""
"This is the same as :c:func:`PyCMethod_Check`, but does not account for "
"subtypes."
msgstr ""
"Isto é o mesmo que :c:func:`PyCMethod_Check`, mas não considera subtipos."

#: ../../c-api/structures.rst:471
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""
"Converte *ml* num objeto Python :term:`chamável`. O chamador deve garantir "
"que *ml* sobrevive ao objeto :term:`chamável`. Tipicamente, *ml* é definido "
"como uma variável estática."

#: ../../c-api/structures.rst:475
msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""
"O parâmetro *self* será passado como argumento *self* para a função C em "
"``ml->ml_meth`` quando invocada. *self* pode ser ``NULL``."

#: ../../c-api/structures.rst:479
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""
"O atributo ``__module__`` do objeto :term:`chamável` pode ser definido a "
"partir do argumento *module*. *module* deve ser uma string Python, que será "
"utilizada como nome do módulo onde a função está definida. Se não estiver "
"disponível, pode ser definido como :const:`None` ou ``NULL``."

#: ../../c-api/structures.rst:485
msgid ":attr:`function.__module__`"
msgstr ":attr:`function.__module__`"

#: ../../c-api/structures.rst:487
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""
"O parâmetro *cls* será passado como argumento *defining_class* para a função "
"C. Deve ser definido se :c:macro:`METH_METHOD` estiver definido em ``ml-"
">ml_flags``."

#: ../../c-api/structures.rst:496
msgid ""
"The type object corresponding to Python C function objects. This is "
"available as :class:`types.BuiltinFunctionType` in the Python layer."
msgstr ""
"O objeto de tipo correspondente a objetos de funções C em Python. Isto está "
"disponível como :class:`types.BuiltinFunctionType` na camada Python."

#: ../../c-api/structures.rst:502
msgid ""
"Return true if *op* is an instance of the :c:type:`PyCFunction_Type` type or "
"a subtype of it. This function always succeeds."
msgstr ""
"Retorna verdadeiro se *op* for uma instância do tipo :c:type:"
"`PyCFunction_Type` ou de um subtipo deste. Esta função sempre tem sucesso."

#: ../../c-api/structures.rst:508
msgid ""
"This is the same as :c:func:`PyCFunction_Check`, but does not account for "
"subtypes."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_Check`, mas não considera subtipos."

#: ../../c-api/structures.rst:514
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, module, NULL)``."

#: ../../c-api/structures.rst:519
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr "Equivalente a ``PyCMethod_New(ml, self, NULL, NULL)``."

#: ../../c-api/structures.rst:524
msgid ""
"Get the function's flags on *func* as they were passed to :c:member:"
"`~PyMethodDef.ml_flags`."
msgstr ""
"Obtém as flags da função em *func* conforme foram passadas para :c:member:"
"`~PyMethodDef.ml_flags`."

#: ../../c-api/structures.rst:527 ../../c-api/structures.rst:545
#: ../../c-api/structures.rst:565
msgid ""
"If *func* is not a C function object, this fails with an exception. *func* "
"must not be ``NULL``."
msgstr ""
"Se *func* não for um objeto de função C, isto falha com uma exceção. *func* "
"não deve ser ``NULL``."

#: ../../c-api/structures.rst:530
msgid ""
"This function returns the function's flags on success, and ``-1`` with an "
"exception set on failure."
msgstr ""
"Esta função retorna as flags da função em caso de sucesso, e ``-1`` com uma "
"exceção definida em caso de falha."

#: ../../c-api/structures.rst:536
msgid ""
"This is the same as :c:func:`PyCFunction_GetFlags`, but without error or "
"type checking."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_GetFlags`, mas sem verificação de "
"erros ou de tipo."

#: ../../c-api/structures.rst:542
msgid ""
"Get the function pointer on *func* as it was passed to :c:member:"
"`~PyMethodDef.ml_meth`."
msgstr ""
"Obtém o ponteiro da função em *func* conforme foi passado para :c:member:"
"`~PyMethodDef.ml_meth`."

#: ../../c-api/structures.rst:548
msgid ""
"This function returns the function pointer on success, and ``NULL`` with an "
"exception set on failure."
msgstr ""
"Esta função retorna o ponteiro da função em caso de sucesso, e ``NULL`` com "
"uma exceção definida em caso de falha."

#: ../../c-api/structures.rst:554
msgid ""
"This is the same as :c:func:`PyCFunction_GetFunction`, but without error or "
"type checking."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_GetFunction`, mas sem verificação de "
"erros ou de tipo."

#: ../../c-api/structures.rst:560
msgid ""
"Get the \"self\" object on *func*. This is the object that would be passed "
"to the first argument of a :c:type:`PyCFunction`. For C function objects "
"created through a :c:type:`PyMethodDef` on a :c:type:`PyModuleDef`, this is "
"the resulting module object."
msgstr ""
"Obtém o objeto \"self\" em *func*. Este é o objeto que seria passado para o "
"primeiro argumento de uma :c:type:`PyCFunction`. Para objetos de função C "
"criados através de uma :c:type:`PyMethodDef` num :c:type:`PyModuleDef`, este "
"é o objeto módulo resultante."

#: ../../c-api/structures.rst:568
msgid ""
"This function returns a :term:`borrowed reference` to the \"self\" object on "
"success, and ``NULL`` with an exception set on failure."
msgstr ""
"Esta função retorna uma :term:`referência emprestada` para o objeto \"self\" "
"em caso de sucesso, e ``NULL`` com uma exceção definida em caso de falha."

#: ../../c-api/structures.rst:574
msgid ""
"This is the same as :c:func:`PyCFunction_GetSelf`, but without error or type "
"checking."
msgstr ""
"Isto é o mesmo que :c:func:`PyCFunction_GetSelf`, mas sem verificação de "
"erros ou de tipo."

#: ../../c-api/structures.rst:579
msgid "Accessing attributes of extension types"
msgstr "Acesso a atributos de tipos de extensão"

#: ../../c-api/structures.rst:583
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"Estrutura que descreve um atributo de um tipo que corresponde a um membro de "
"uma struct C. Ao definir uma classe, coloque um array terminado por NULL "
"destas estruturas no slot :c:member:`~PyTypeObject.tp_members`."

#: ../../c-api/structures.rst:588
msgid "Its fields are, in order:"
msgstr "Os seus campos são, por ordem:"

#: ../../c-api/structures.rst:592
msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr ""
"Nome do membro. Um valor NULL marca o fim de um array ``PyMemberDef[]``."

#: ../../c-api/structures.rst:595
msgid "The string should be static, no copy is made of it."
msgstr "A string deve ser estática, não é feita nenhuma cópia."

#: ../../c-api/structures.rst:599
msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the "
"possible values."
msgstr ""
"O tipo do membro na struct C. Consulte :ref:`PyMemberDef-types` para os "
"valores possíveis."

#: ../../c-api/structures.rst:604
msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr ""
"O deslocamento em bytes onde o membro está localizado na struct do objeto do "
"tipo."

#: ../../c-api/structures.rst:608
msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""
"Zero ou mais das :ref:`PyMemberDef-flags`, combinadas utilizando OR bit a "
"bit."

#: ../../c-api/structures.rst:612
msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""
"A docstring, ou NULL. A string deve ser estática, não é feita nenhuma cópia. "
"Tipicamente, é definida utilizando :c:macro:`PyDoc_STR`."

#: ../../c-api/structures.rst:616
msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, imply :c:macro:"
"`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and legacy :c:macro:"
"`T_OBJECT`) members can be deleted."
msgstr ""
"Por predefinição (quando :c:member:`~PyMemberDef.flags` é ``0``), os membros "
"permitem acesso de leitura e escrita. Utilize a flag :c:macro:`Py_READONLY` "
"para acesso apenas de leitura. Certos tipos, como :c:macro:`Py_T_STRING`, "
"implicam :c:macro:`Py_READONLY`. Apenas membros :c:macro:`Py_T_OBJECT_EX` (e "
"legados :c:macro:`T_OBJECT`) podem ser eliminados."

#: ../../c-api/structures.rst:625
msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding to :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. This member must be defined with "
"``Py_T_PYSSIZET``, and either ``Py_READONLY`` or ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. For example::"
msgstr ""
"Para tipos alocados em heap (criados utilizando :c:func:`PyType_FromSpec` ou "
"similar), ``PyMemberDef`` pode conter uma definição para o membro especial "
"``\"__vectorcalloffset__\"``, correspondente a :c:member:`~PyTypeObject."
"tp_vectorcall_offset` em objetos de tipo. Este membro deve ser definido com "
"``Py_T_PYSSIZET``, e com ``Py_READONLY`` ou ``Py_READONLY | "
"Py_RELATIVE_OFFSET``. Por exemplo::"

#: ../../c-api/structures.rst:632
msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinela */\n"
"};"

#: ../../c-api/structures.rst:638
msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr ""
"(Pode ser necessário ``#include <stddef.h>`` para :c:func:`!offsetof`.)"

#: ../../c-api/structures.rst:640
msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` and :c:member:"
"`~PyTypeObject.tp_weaklistoffset` can be defined similarly using "
"``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""
"Os deslocamentos legados :c:member:`~PyTypeObject.tp_dictoffset` e :c:member:"
"`~PyTypeObject.tp_weaklistoffset` podem ser definidos de forma semelhante "
"utilizando membros ``\"__dictoffset__\"`` e ``\"__weaklistoffset__\"``, mas "
"é fortemente recomendado que as extensões utilizem :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT` e :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` em vez "
"disso."

#: ../../c-api/structures.rst:648
msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMemberDef`` está sempre disponível. Anteriormente, era necessário "
"incluir ``\"structmember.h\"``."

#: ../../c-api/structures.rst:653
msgid ""
":c:macro:`Py_RELATIVE_OFFSET` is now allowed for "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` and "
"``\"__weaklistoffset__\"``."
msgstr ""
"A macro :c:macro:`Py_RELATIVE_OFFSET` é agora permitida para "
"``\"__vectorcalloffset__\"``, ``\"__dictoffset__\"`` e "
"``\"__weaklistoffset__\"``."

#: ../../c-api/structures.rst:659
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Obtém um atributo pertencente ao objeto no endereço *obj_addr*. O atributo é "
"descrito por ``PyMemberDef`` *m*. Retorna ``NULL`` em caso de erro."

#: ../../c-api/structures.rst:665
msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_GetOne`` está sempre disponível. Anteriormente, era necessário "
"incluir ``\"structmember.h\"``."

#: ../../c-api/structures.rst:670
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Define um atributo pertencente ao objeto no endereço *obj_addr* para o "
"objeto *o*. O atributo a definir é descrito por ``PyMemberDef`` *m*. Retorna "
"``0`` em caso de sucesso e um valor negativo em caso de falha."

#: ../../c-api/structures.rst:676
msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""
"``PyMember_SetOne`` está sempre disponível. Anteriormente, era necessário "
"incluir ``\"structmember.h\"``."

#: ../../c-api/structures.rst:682
msgid "Member flags"
msgstr "Flags de membros"

#: ../../c-api/structures.rst:684
msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr ""
"As seguintes flags podem ser utilizadas com :c:member:`PyMemberDef.flags`:"

#: ../../c-api/structures.rst:688
msgid "Not writable."
msgstr "Não gravável."

#: ../../c-api/structures.rst:692
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""
"Emite um evento de auditoria :ref:`audit event <audit-events>` de ``object."
"__getattr__`` antes da leitura."

#: ../../c-api/structures.rst:697
msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""
"Indica que o :c:member:`~PyMemberDef.offset` desta entrada ``PyMemberDef`` "
"indica um deslocamento a partir dos dados específicos da subclasse, em vez "
"de a partir de ``PyObject``."

#: ../../c-api/structures.rst:701
msgid ""
"Can only be used as part of the :c:data:`Py_tp_members` :c:type:`slot "
"<PyType_Slot>` when creating a class using negative :c:member:`~PyType_Spec."
"basicsize`. It is mandatory in that case. When setting :c:member:"
"`~PyTypeObject.tp_members` from the slot during class creation, Python "
"clears the flag and sets :c:member:`PyMemberDef.offset` to the offset from "
"the ``PyObject`` struct."
msgstr ""
"Pode ser utilizada apenas como parte do :c:data:`Py_tp_members` :c:type:"
"`slot <PyType_Slot>` ao criar uma classe utilizando um :c:member:"
"`~PyType_Spec.basicsize` negativo. É obrigatório nesse caso. Ao definir :c:"
"member:`~PyTypeObject.tp_members` a partir do slot durante a criação da "
"classe, o Python limpa a flag e define :c:member:`PyMemberDef.offset` para o "
"deslocamento a partir da struct ``PyObject``."

#: ../../c-api/structures.rst:716
msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and :c:macro:`!"
"WRITE_RESTRICTED` macros available with ``#include \"structmember.h\"`` are "
"deprecated. :c:macro:`!READ_RESTRICTED` and :c:macro:`!RESTRICTED` are "
"equivalent to :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` does "
"nothing."
msgstr ""
"As macros :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` e :c:macro:`!"
"WRITE_RESTRICTED`, disponíveis com ``#include \"structmember.h\"``, estão "
"obsoleta. :c:macro:`!READ_RESTRICTED` e :c:macro:`!RESTRICTED` são "
"equivalentes a :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` não "
"faz nada."

#: ../../c-api/structures.rst:727
msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. The :c:"
"macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The new "
"names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""
"A macro :c:macro:`!READONLY` foi renomeada para :c:macro:`Py_READONLY`. A "
"macro :c:macro:`!PY_AUDIT_READ` foi renomeada com o prefixo ``Py_``. Os "
"novos nomes estão agora sempre disponíveis. Anteriormente, era necessário "
"``#include \"structmember.h\"``. O cabeçalho ainda está disponível e fornece "
"os nomes antigos."

#: ../../c-api/structures.rst:736
msgid "Member types"
msgstr "Tipos de membros"

#: ../../c-api/structures.rst:738
msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python, "
"it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""
"O :c:member:`PyMemberDef.type` pode ser uma das seguintes macros "
"correspondentes a vários tipos C. Quando o membro é acedido em Python, será "
"convertido para o tipo Python equivalente. Quando é definido a partir do "
"Python, será convertido de volta para o tipo C. Se isso não for possível, é "
"levantada uma exceção como :exc:`TypeError` ou :exc:`ValueError`."

#: ../../c-api/structures.rst:746
msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using e.g. :"
"keyword:`del` or :py:func:`delattr`."
msgstr ""
"A menos que marcado com (D), os atributos definidos desta forma não podem "
"ser eliminados utilizando, por exemplo, :keyword:`del` ou :py:func:`delattr`."

#: ../../c-api/structures.rst:750
msgid "Macro name"
msgstr "Nome da macro"

#: ../../c-api/structures.rst:750
msgid "C type"
msgstr "tipo C"

#: ../../c-api/structures.rst:750
msgid "Python type"
msgstr "tipo Python"

#: ../../c-api/structures.rst:752
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: ../../c-api/structures.rst:752 ../../c-api/structures.rst:753
#: ../../c-api/structures.rst:754 ../../c-api/structures.rst:755
#: ../../c-api/structures.rst:756 ../../c-api/structures.rst:757
#: ../../c-api/structures.rst:758 ../../c-api/structures.rst:759
#: ../../c-api/structures.rst:760 ../../c-api/structures.rst:761
#: ../../c-api/structures.rst:762
msgid ":py:class:`int`"
msgstr ":py:class:`int`"

#: ../../c-api/structures.rst:753
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: ../../c-api/structures.rst:754
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: ../../c-api/structures.rst:755
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: ../../c-api/structures.rst:756
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: ../../c-api/structures.rst:757
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: ../../c-api/structures.rst:758
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: ../../c-api/structures.rst:759
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: ../../c-api/structures.rst:760
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: ../../c-api/structures.rst:761
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: ../../c-api/structures.rst:762
msgid ":c:expr:`Py_ssize_t`"
msgstr ":c:expr:`Py_ssize_t`"

#: ../../c-api/structures.rst:763
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: ../../c-api/structures.rst:763 ../../c-api/structures.rst:764
msgid ":py:class:`float`"
msgstr ":py:class:`float`"

#: ../../c-api/structures.rst:764
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: ../../c-api/structures.rst:765
msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ":c:expr:`char` (escrito como 0 ou 1)"

#: ../../c-api/structures.rst:765
msgid ":py:class:`bool`"
msgstr ":py:class:`bool`"

#: ../../c-api/structures.rst:767
msgid ":c:expr:`const char *` (*)"
msgstr ":c:expr:`const char *` (*)"

#: ../../c-api/structures.rst:767 ../../c-api/structures.rst:768
msgid ":py:class:`str` (RO)"
msgstr ":py:class:`str` (SO)"

#: ../../c-api/structures.rst:768
msgid ":c:expr:`const char[]` (*)"
msgstr ":c:expr:`const char[]` (*)"

#: ../../c-api/structures.rst:769
msgid ":c:expr:`char` (0-127)"
msgstr ":c:expr:`char` (0-127)"

#: ../../c-api/structures.rst:769
msgid ":py:class:`str` (**)"
msgstr ":py:class:`str` (**)"

#: ../../c-api/structures.rst:770
msgid ":c:expr:`PyObject *`"
msgstr ":c:expr:`PyObject *`"

#: ../../c-api/structures.rst:770
msgid ":py:class:`object` (D)"
msgstr ":py:class:`object` (E)"

#: ../../c-api/structures.rst:773
msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""
"(*): String C terminada por zero, codificada em UTF8. Com :c:macro:`!"
"Py_T_STRING`, a representação C é um ponteiro; com :c:macro:`!"
"Py_T_STRING_INPLACE`, a string é armazenada diretamente na estrutura."

#: ../../c-api/structures.rst:778
msgid "(**): String of length 1. Only ASCII is accepted."
msgstr "(**): String de comprimento 1. Apenas ASCII é aceite."

#: ../../c-api/structures.rst:780
msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr "(SO): Implica :c:macro:`Py_READONLY`."

#: ../../c-api/structures.rst:782
msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a "
"``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""
"(E): Pode ser eliminado, caso em que o ponteiro é definido para ``NULL``. A "
"leitura de um ponteiro ``NULL`` levanta :py:exc:`AttributeError`."

#: ../../c-api/structures.rst:808
msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""
"Em versões anteriores, as macros estavam disponíveis apenas com ``#include "
"\"structmember.h\"`` e eram nomeadas sem o prefixo ``Py_`` (por exemplo, "
"como ``T_INT``). O cabeçalho ainda está disponível e contém os nomes "
"antigos, juntamente com os seguintes tipos obsoletos:"

#: ../../c-api/structures.rst:816
msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results "
"in surprising behavior in Python: deleting the attribute effectively sets it "
"to ``None``."
msgstr ""
"Semelhante a ``Py_T_OBJECT_EX``, mas ``NULL`` é convertido para ``None``. "
"Isto resulta em comportamento surpreendente em Python: eliminar o atributo "
"define-o efetivamente para ``None``."

#: ../../c-api/structures.rst:822
msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr "Sempre ``None``. Deve ser utilizado com :c:macro:`Py_READONLY`."

#: ../../c-api/structures.rst:825
msgid "Defining Getters and Setters"
msgstr "Definição de Getters e Setters"

#: ../../c-api/structures.rst:829
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Estrutura para definir acesso semelhante a propriedades para um tipo. Veja "
"também a descrição do slot :c:member:`PyTypeObject.tp_getset`."

#: ../../c-api/structures.rst:834
msgid "attribute name"
msgstr "nome do atributo"

#: ../../c-api/structures.rst:838
msgid "C function to get the attribute."
msgstr "Função C para obter o atributo."

#: ../../c-api/structures.rst:842
msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr ""
"Função C opcional para definir ou eliminar o atributo. Se ``NULL``, o "
"atributo é apenas de leitura."

#: ../../c-api/structures.rst:847
msgid "optional docstring"
msgstr "docstring opcional"

#: ../../c-api/structures.rst:851
msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr ""
"Ponteiro de dados do utilizador opcional, fornecendo dados adicionais para "
"getter e setter."

#: ../../c-api/structures.rst:855
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"A função ``get`` recebe um parâmetro :c:expr:`PyObject*` (a instância) e um "
"ponteiro de dados do utilizador (o ``closure`` associado):"

#: ../../c-api/structures.rst:858
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Deve retornar uma nova referência em caso de sucesso ou ``NULL`` com uma "
"exceção definida em caso de falha."

#: ../../c-api/structures.rst:863
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"As funções ``set`` recebem dois parâmetros :c:expr:`PyObject*` (a instância "
"e o valor a definir) e um ponteiro de dados do utilizador (o ``closure`` "
"associado):"

#: ../../c-api/structures.rst:866
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"Caso o atributo deva ser eliminado, o segundo parâmetro é ``NULL``. Deve "
"retornar ``0`` em caso de sucesso ou ``-1`` com uma exceção definida em caso "
"de falha."

#: ../../c-api/structures.rst:418 ../../c-api/structures.rst:428
msgid "built-in function"
msgstr "função incorporada"

#: ../../c-api/structures.rst:418
msgid "classmethod"
msgstr "método de classe"

#: ../../c-api/structures.rst:428
msgid "staticmethod"
msgstr "método estático"

#: ../../c-api/structures.rst:709
msgid "READ_RESTRICTED (C macro)"
msgstr "LEITURA_RESTRITA (macro C)"

#: ../../c-api/structures.rst:709
msgid "WRITE_RESTRICTED (C macro)"
msgstr "ESCRITA_RESTRITA (macro C)"

#: ../../c-api/structures.rst:709
msgid "RESTRICTED (C macro)"
msgstr "RESTRITA (macro C)"

#: ../../c-api/structures.rst:722
msgid "READONLY (C macro)"
msgstr "APENAS_LEITURA (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_BYTE (C macro)"
msgstr "T_BYTE (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_SHORT (C macro)"
msgstr "T_SHORT (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_INT (C macro)"
msgstr "T_INT (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_LONG (C macro)"
msgstr "T_LONG (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_UBYTE (C macro)"
msgstr "T_UBYTE (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_USHORT (C macro)"
msgstr "T_USHORT (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_UINT (C macro)"
msgstr "T_UINT (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_ULONG (C macro)"
msgstr "T_ULONG (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGULONG (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_FLOAT (C macro)"
msgstr "T_FLOAT (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_BOOL (C macro)"
msgstr "T_BOOL (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_CHAR (C macro)"
msgstr "T_CHAR (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_STRING (C macro)"
msgstr "T_STRING (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING_INPLACE (macro C)"

#: ../../c-api/structures.rst:785
msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX (macro C)"

#: ../../c-api/structures.rst:785
msgid "structmember.h"
msgstr "structmember.h"
