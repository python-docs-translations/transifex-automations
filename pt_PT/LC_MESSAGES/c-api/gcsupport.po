# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 16:01+0000\n"
"PO-Revision-Date: 2025-09-22 16:49+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/gcsupport.rst:6
msgid "Supporting Cyclic Garbage Collection"
msgstr "Suporta a Coleta Cíclica de Lixo"

#: ../../c-api/gcsupport.rst:8
msgid ""
"Python's support for detecting and collecting garbage which involves "
"circular references requires support from object types which are "
"\"containers\" for other objects which may also be containers.  Types which "
"do not store references to other objects, or which only store references to "
"atomic types (such as numbers or strings), do not need to provide any "
"explicit support for garbage collection."
msgstr ""
"O suporte do Python para detectar e coletar o lixo, que envolve referencias "
"circulares, requer suporte dos tipos de objetos que são \"contentores\" para "
"outros objetos que também podem ser contentores. Tipos que não armazenam "
"referências a outros tipos de objetos, ou que apenas armazenam referências a "
"tipos atômicos (como números ou strings), não precisam fornecer nenhum "
"suporte explicito para coleta de lixo."

#: ../../c-api/gcsupport.rst:15
msgid ""
"To create a container type, the :c:member:`~PyTypeObject.tp_flags` field of "
"the type object must include the :c:macro:`Py_TPFLAGS_HAVE_GC` and provide "
"an implementation of the :c:member:`~PyTypeObject.tp_traverse` handler.  If "
"instances of the type are mutable, a :c:member:`~PyTypeObject.tp_clear` "
"implementation must also be provided."
msgstr ""
"Para criar um tipo de contentor, o campo :c:member:`~PyTypeObject.tp_flags` "
"do objeto de tipo deve incluir o :c:macro:`Py_TPFLAGS_HAVE_GC` e fornecer "
"uma implementação do manipulador :c:member:`~PyTypeObject.tp_traverse`. Se "
"as instâncias do tipo forem mutáveis, uma implementação :c:member:"
"`~PyTypeObject.tp_clear` também deve ser fornecida."

#: ../../c-api/gcsupport.rst:24
msgid ":c:macro:`Py_TPFLAGS_HAVE_GC`"
msgstr ":c:macro:`Py_TPFLAGS_HAVE_GC`"

#: ../../c-api/gcsupport.rst:22
msgid ""
"Objects with a type with this flag set must conform with the rules "
"documented here.  For convenience these objects will be referred to as "
"container objects."
msgstr ""
"Os objetos com um tipo com este sinalizador definido devem estar em "
"conformidade com as regras aqui documentadas. Por conveniência, esses "
"objetos serão referidos como objetos contentores."

#: ../../c-api/gcsupport.rst:26
msgid "Constructors for container types must conform to two rules:"
msgstr ""
"Os construtores para tipos de contentores devem estar em conformidade com "
"duas regras:"

#: ../../c-api/gcsupport.rst:28
msgid ""
"The memory for the object must be allocated using :c:macro:`PyObject_GC_New` "
"or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"A memória para o objeto deve ser alocada usando :c:macro:`PyObject_GC_New` "
"ou :c:macro:`PyObject_GC_NewVar`."

#: ../../c-api/gcsupport.rst:31
msgid ""
"Once all the fields which may contain references to other containers are "
"initialized, it must call :c:func:`PyObject_GC_Track`."
msgstr ""
"Depois de todos os campos que podem conter referências a outros contentores "
"serem inicializados, deve chamar :c:func:`PyObject_GC_Track`."

#: ../../c-api/gcsupport.rst:34
msgid ""
"Similarly, the deallocator for the object must conform to a similar pair of "
"rules:"
msgstr ""
"Da mesma forma, o desalocador para o objeto deve estar em conformidade com "
"regras semelhantes:"

#: ../../c-api/gcsupport.rst:37
msgid ""
"Before fields which refer to other containers are invalidated, :c:func:"
"`PyObject_GC_UnTrack` must be called."
msgstr ""
"Antes que os campos que se referem a outros contentores sejam invalidados, :"
"c:func:`PyObject_GC_UnTrack` deve ser chamado."

#: ../../c-api/gcsupport.rst:40
msgid ""
"The object's memory must be deallocated using :c:func:`PyObject_GC_Del`."
msgstr ""
"A memória destinada ao objeto deve ser desalocada usando :c:func:"
"`PyObject_GC_Del`."

#: ../../c-api/gcsupport.rst:43
msgid ""
"If a type adds the Py_TPFLAGS_HAVE_GC, then it *must* implement at least a :"
"c:member:`~PyTypeObject.tp_traverse` handler or explicitly use one from its "
"subclass or subclasses."
msgstr ""
"Se um tipo adicionar Py_TPFLAGS_HAVE_GC, então ele *deve* implementar pelo "
"menos um manipulador :c:member:`~PyTypeObject.tp_traverse` ou usar "
"explicitamente um da sua subclasse ou subclasses."

#: ../../c-api/gcsupport.rst:47
msgid ""
"When calling :c:func:`PyType_Ready` or some of the APIs that indirectly call "
"it like :c:func:`PyType_FromSpecWithBases` or :c:func:`PyType_FromSpec` the "
"interpreter will automatically populate the :c:member:`~PyTypeObject."
"tp_flags`, :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields if the type inherits from a class that "
"implements the garbage collector protocol and the child class does *not* "
"include the :c:macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"Ao chamar :c:func:`PyType_Ready` ou algumas das APIs que o chamam "
"indiretamente, como :c:func:`PyType_FromSpecWithBases` ou :c:func:"
"`PyType_FromSpec`, o interpretador preencherá automaticamente os campos :c:"
"member:`~PyTypeObject.tp_flags`, :c:member:`~PyTypeObject.tp_traverse` e :c:"
"member:`~PyTypeObject.tp_clear` se o tipo herdar de uma classe que "
"implementa o protocolo do coletor de lixo e a classe filha *não* incluir o "
"sinalizador :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/gcsupport.rst:57
msgid ""
"Analogous to :c:macro:`PyObject_New` but for container objects with the :c:"
"macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Análogo a :c:macro:`PyObject_New`, mas para objetos contentores com o "
"sinalizador :c:macro:`Py_TPFLAGS_HAVE_GC` definido."

#: ../../c-api/gcsupport.rst:63
msgid ""
"Analogous to :c:macro:`PyObject_NewVar` but for container objects with the :"
"c:macro:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Análogo a :c:macro:`PyObject_NewVar`, mas para objetos contentores com o "
"sinalizador :c:macro:`Py_TPFLAGS_HAVE_GC` definido."

#: ../../c-api/gcsupport.rst:69
msgid ""
"Resize an object allocated by :c:macro:`PyObject_NewVar`. Returns the "
"resized object of type ``TYPE*`` (refers to any C type) or ``NULL`` on "
"failure."
msgstr ""
"Redimensiona um objeto alocado por :c:macro:`PyObject_NewVar`. Retorna o "
"objeto redimensionado do tipo ``TYPE*`` (refere-se a qualquer tipo C) ou "
"``NULL`` em caso de falha."

#: ../../c-api/gcsupport.rst:73
msgid ""
"*op* must be of type :c:expr:`PyVarObject *` and must not be tracked by the "
"collector yet. *newsize* must be of type :c:type:`Py_ssize_t`."
msgstr ""
"*op* deve ser do tipo :c:expr:`PyVarObject *` e não deve ser rastreado pelo "
"coletor ainda. *newsize* deve ser do tipo :c:type:`Py_ssize_t`."

#: ../../c-api/gcsupport.rst:80
msgid ""
"Adds the object *op* to the set of container objects tracked by the "
"collector.  The collector can run at unexpected times so objects must be "
"valid while being tracked.  This should be called once all the fields "
"followed by the :c:member:`~PyTypeObject.tp_traverse` handler become valid, "
"usually near the end of the constructor."
msgstr ""
"Adiciona o objeto *op* ao conjunto de objetos contentores rastreados pelo "
"coletor. O coletor pode ser executado em momentos inesperados, portanto os "
"objetos devem ser válidos enquanto são rastreados. Isso deve ser chamado "
"assim que todos os campos seguidos pelo manipulador :c:member:`~PyTypeObject."
"tp_traverse` se tornarem válidos, geralmente perto do final do construtor."

#: ../../c-api/gcsupport.rst:89
msgid ""
"Returns non-zero if the object implements the garbage collector protocol, "
"otherwise returns 0."
msgstr ""
"Retorna um valor diferente de zero se o objeto implementar o protocolo do "
"coletor de lixo, caso contrário, retorna 0."

#: ../../c-api/gcsupport.rst:92
msgid ""
"The object cannot be tracked by the garbage collector if this function "
"returns 0."
msgstr ""
"O objeto não pode ser rastreado pelo coletor de lixo se esta função retornar "
"0."

#: ../../c-api/gcsupport.rst:97
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* is "
"being currently tracked by the garbage collector and 0 otherwise."
msgstr ""
"Retorna 1 se o tipo de objeto de *op* implementar o protocolo GC e *op* "
"estiver a ser rastreado pelo coletor de lixo, e 0 caso contrário."

#: ../../c-api/gcsupport.rst:100
msgid "This is analogous to the Python function :func:`gc.is_tracked`."
msgstr "Isso é análogo à função Python :func:`gc.is_tracked`."

#: ../../c-api/gcsupport.rst:107
msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* has "
"been already finalized by the garbage collector and 0 otherwise."
msgstr ""
"Retorna 1 se o tipo de objeto de *op* implementar o protocolo GC e *op* já "
"tiver sido finalizado pelo coletor de lixo, e 0 caso contrário."

#: ../../c-api/gcsupport.rst:110
msgid "This is analogous to the Python function :func:`gc.is_finalized`."
msgstr "Isso é análogo à função Python :func:`gc.is_finalized`."

#: ../../c-api/gcsupport.rst:117
msgid ""
"Releases memory allocated to an object using :c:macro:`PyObject_GC_New` or :"
"c:macro:`PyObject_GC_NewVar`."
msgstr ""
"Libera a memória alocada para um objeto usando :c:macro:`PyObject_GC_New` "
"ou :c:macro:`PyObject_GC_NewVar`."

#: ../../c-api/gcsupport.rst:123
msgid ""
"Remove the object *op* from the set of container objects tracked by the "
"collector.  Note that :c:func:`PyObject_GC_Track` can be called again on "
"this object to add it back to the set of tracked objects.  The deallocator (:"
"c:member:`~PyTypeObject.tp_dealloc` handler) should call this for the object "
"before any of the fields used by the :c:member:`~PyTypeObject.tp_traverse` "
"handler become invalid."
msgstr ""
"Remova o objeto *op* do conjunto de objetos contentores rastreados pelo "
"coletor. Observe que :c:func:`PyObject_GC_Track` pode ser chamado novamente "
"neste objeto para adicioná-lo de volta ao conjunto de objetos rastreados. O "
"desalocador (manipulador :c:member:`~PyTypeObject.tp_dealloc`) deve chamar "
"isso para o objeto antes que qualquer um dos campos usados pelo manipulador :"
"c:member:`~PyTypeObject.tp_traverse` se torne inválido."

#: ../../c-api/gcsupport.rst:132
msgid ""
"The :c:func:`!_PyObject_GC_TRACK` and :c:func:`!_PyObject_GC_UNTRACK` macros "
"have been removed from the public C API."
msgstr ""
"As macros :c:func:`!_PyObject_GC_TRACK` e :c:func:`!_PyObject_GC_UNTRACK` "
"foram removidas da API C pública."

#: ../../c-api/gcsupport.rst:135
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function "
"parameter of this type:"
msgstr ""
"O manipulador :c:member:`~PyTypeObject.tp_traverse` aceita um parâmetro de "
"função deste tipo:"

#: ../../c-api/gcsupport.rst:140
msgid ""
"Type of the visitor function passed to the :c:member:`~PyTypeObject."
"tp_traverse` handler. The function should be called with an object to "
"traverse as *object* and the third parameter to the :c:member:`~PyTypeObject."
"tp_traverse` handler as *arg*.  The Python core uses several visitor "
"functions to implement cyclic garbage detection; it's not expected that "
"users will need to write their own visitor functions."
msgstr ""
"Tipo da função visitante passada para o manipulador :c:member:`~PyTypeObject."
"tp_traverse`. A função deve ser chamada com um objeto a ser percorrido como "
"*object* e o terceiro parâmetro para o manipulador :c:member:`~PyTypeObject."
"tp_traverse` como *arg*. O núcleo do Python usa várias funções visitante "
"para implementar a deteção de lixo cíclico; não se espera que os "
"utilizadores precisem escrever as suas próprias funções visitante."

#: ../../c-api/gcsupport.rst:147
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler must have the following "
"type:"
msgstr ""
"O manipulador :c:member:`~PyTypeObject.tp_traverse` deve ter o seguinte tipo:"

#: ../../c-api/gcsupport.rst:152
msgid ""
"Traversal function for a container object.  Implementations must call the "
"*visit* function for each object directly contained by *self*, with the "
"parameters to *visit* being the contained object and the *arg* value passed "
"to the handler.  The *visit* function must not be called with a ``NULL`` "
"object argument.  If *visit* returns a non-zero value that value should be "
"returned immediately."
msgstr ""
"Função transversal para um objeto contentor. As implementações devem chamar "
"a função *visit* para cada objeto diretamente contido em *self*, com os "
"parâmetros para *visit* sendo o objeto contido e o valor *arg* passado para "
"o manipulador. A função *visit* não deve ser chamada com um argumento de "
"objeto ``NULL``. Se *visit* retornar um valor diferente de zero, esse valor "
"deve ser retornado imediatamente."

#: ../../c-api/gcsupport.rst:159
msgid ""
"To simplify writing :c:member:`~PyTypeObject.tp_traverse` handlers, a :c:"
"func:`Py_VISIT` macro is provided.  In order to use this macro, the :c:"
"member:`~PyTypeObject.tp_traverse` implementation must name its arguments "
"exactly *visit* and *arg*:"
msgstr ""
"Para simplificar a escrita de manipuladores :c:member:`~PyTypeObject."
"tp_traverse`, é fornecida uma macro :c:func:`Py_VISIT`. Para usar essa "
"macro, a implementação :c:member:`~PyTypeObject.tp_traverse` deve nomear "
"seus argumentos exatamente como *visit* e *arg*:"

#: ../../c-api/gcsupport.rst:166
msgid ""
"If *o* is not ``NULL``, call the *visit* callback, with arguments *o* and "
"*arg*.  If *visit* returns a non-zero value, then return it. Using this "
"macro, :c:member:`~PyTypeObject.tp_traverse` handlers look like::"
msgstr ""

#: ../../c-api/gcsupport.rst:179
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` handler must be of the :c:type:"
"`inquiry` type, or ``NULL`` if the object is immutable."
msgstr ""
"O manipulador :c:member:`~PyTypeObject.tp_clear` deve ser do tipo :c:type:"
"`inquiry` ou ``NULL`` se o objeto for imutável."

#: ../../c-api/gcsupport.rst:185
msgid ""
"Drop references that may have created reference cycles.  Immutable objects "
"do not have to define this method since they can never directly create "
"reference cycles.  Note that the object must still be valid after calling "
"this method (don't just call :c:func:`Py_DECREF` on a reference).  The "
"collector will call this method if it detects that this object is involved "
"in a reference cycle."
msgstr ""
"Elimine referências que possam ter criado ciclos de referência. Objetos "
"imutáveis não precisam definir este método, pois nunca podem criar ciclos de "
"referência diretamente. Observe que o objeto ainda deve ser válido após "
"chamar este método (não basta chamar :c:func:`Py_DECREF` em uma referência). "
"O coletor chamará este método se detectar que este objeto está envolvido em "
"um ciclo de referência."

#: ../../c-api/gcsupport.rst:194
msgid "Controlling the Garbage Collector State"
msgstr "Controlando o estado do coletor de lixo"

#: ../../c-api/gcsupport.rst:196
msgid ""
"The C-API provides the following functions for controlling garbage "
"collection runs."
msgstr ""
"A C-API fornece as seguintes funções para controlar as execuções da recolha "
"de lixo."

#: ../../c-api/gcsupport.rst:201
msgid ""
"Perform a full garbage collection, if the garbage collector is enabled. "
"(Note that :func:`gc.collect` runs it unconditionally.)"
msgstr ""
"Executa uma recolha completa de lixo, se o recolhedor de lixo estiver "
"ativado. (Observe que :func:`gc.collect` o executa incondicionalmente.)"

#: ../../c-api/gcsupport.rst:204
msgid ""
"Returns the number of collected + unreachable objects which cannot be "
"collected. If the garbage collector is disabled or already collecting, "
"returns ``0`` immediately. Errors during garbage collection are passed to :"
"data:`sys.unraisablehook`. This function does not raise exceptions."
msgstr ""
"Retorna o número de objetos recolhidos + inacessíveis que não podem ser "
"recolhidos. Se o coletor de lixo estiver desativado ou já estiver a "
"recolher, retorna ``0`` imediatamente. Os erros durante a recolha de lixo "
"são passados para :data:`sys.unraisablehook`. Esta função não gera exceções."

#: ../../c-api/gcsupport.rst:214
msgid ""
"Enable the garbage collector: similar to :func:`gc.enable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Ativar o coletor de lixo: semelhante a :func:`gc.enable`. Retorna o estado "
"anterior, 0 para desativado e 1 para ativado."

#: ../../c-api/gcsupport.rst:222
msgid ""
"Disable the garbage collector: similar to :func:`gc.disable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Desativar o coletor de lixo: semelhante a :func:`gc.disable`. Retorna o "
"estado anterior, 0 para desativado e 1 para ativado."

#: ../../c-api/gcsupport.rst:230
msgid ""
"Query the state of the garbage collector: similar to :func:`gc.isenabled`. "
"Returns the current state, 0 for disabled and 1 for enabled."
msgstr ""
"Consultar o estado do coletor de lixo: semelhante a :func:`gc.isenabled`. "
"Retorna o estado atual, 0 para desativado e 1 para ativado."
