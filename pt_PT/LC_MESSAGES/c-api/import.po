# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-09 14:19+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/import.rst:6
msgid "Importing Modules"
msgstr "A importar módulos"

#: ../../c-api/import.rst:16
msgid ""
"This is a wrapper around :c:func:`PyImport_Import()` which takes a :c:expr:"
"`const char *` as an argument instead of a :c:expr:`PyObject *`."
msgstr ""
"Esta é uma wrapper em torno de :c:func:`PyImport_Import()` que recebe um :c:"
"expr:`const char *` como argumento em vez de um :c:expr:`PyObject *`."

#: ../../c-api/import.rst:21
msgid "This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr ""
"Esta função é um alias descontinuado de :c:func:`PyImport_ImportModule`."

#: ../../c-api/import.rst:23
msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"Esta função costumava falhar imediatamente quando o bloqueio de importação "
"era mantido por outro thread. No entanto, no Python 3.3, o esquema de "
"bloqueio mudou para bloqueios por módulo para a maioria dos fins, portanto, "
"o comportamento especial desta função não é mais necessário."

#: ../../c-api/import.rst:29
msgid "Use :c:func:`PyImport_ImportModule` instead."
msgstr "Use :c:func:`PyImport_ImportModule` em vez disso."

#: ../../c-api/import.rst:37
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`."
msgstr ""
"Importa um módulo. Isso é melhor descrito referindo-se à função embutida do "
"Python :func:`__import__`."

#: ../../c-api/import.rst:40 ../../c-api/import.rst:56
msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for :func:"
"`__import__`, the return value when a submodule of a package was requested "
"is normally the top-level package, unless a non-empty *fromlist* was given."
msgstr ""
"O valor de retorno é uma nova referência ao módulo importado ou pacote de "
"nível superior, ou ``NULL`` com uma exceção definida em caso de falha. Como "
"para :func:`__import__`, o valor de retorno quando um submódulo de um pacote "
"é solicitado é normalmente o pacote de nível superior, a menos que um "
"*fromlist* não vazio seja fornecido."

#: ../../c-api/import.rst:46
msgid ""
"Failing imports remove incomplete module objects, like with :c:func:"
"`PyImport_ImportModule`."
msgstr ""
"As importações com falhas removem objetos incompletos do módulo, como em :c:"
"func:`PyImport_ImportModule`."

#: ../../c-api/import.rst:52
msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"Importa um módulo. Isso é melhor descrito referindo-se à função embutida do "
"Python :func:`__import__`, já que a função padrão :func:`__import__` chama "
"essa função diretamente."

#: ../../c-api/import.rst:66
msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Semelhante a :c:func:`PyImport_ImportModuleLevelObject`, mas o nome é uma "
"string codificada em UTF-8 em vez de um objeto Unicode."

#: ../../c-api/import.rst:69
msgid "Negative values for *level* are no longer accepted."
msgstr "Valores negativos para *level* já não são aceites."

#: ../../c-api/import.rst:74
msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"Esta é uma interface de nível superior que chama a \"função de gancho de "
"importação\" atual (com um *nível* explícito de 0, significando importação "
"absoluta). Ela invoca a função :func:`__import__` a partir do "
"``__builtins__`` dos globais atuais. Isso significa que a importação é feita "
"usando quaisquer ganchos de importação instalados no ambiente atual."

#: ../../c-api/import.rst:80
msgid "This function always uses absolute imports."
msgstr "Esta função utiliza sempre importações absolutas."

#: ../../c-api/import.rst:85
msgid ""
"Reload a module.  Return a new reference to the reloaded module, or ``NULL`` "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"Recarregar um módulo. Retornar uma nova referência ao módulo recarregado ou "
"``NULL`` com uma exceção definida em caso de falha (o módulo ainda existe "
"neste caso)."

#: ../../c-api/import.rst:91
msgid "Return the module object corresponding to a module name."
msgstr "Retorne o objeto do módulo correspondente a um nome de módulo."

#: ../../c-api/import.rst:93
msgid ""
"The *name* argument may be of the form ``package.module``. First check the "
"modules dictionary if there's one there, and if not, create a new one and "
"insert it in the modules dictionary."
msgstr ""
"O argumento *name* pode ter o formato ``package.module``. Primeiro, "
"verifique se existe um no dicionário de módulos e, caso não exista, crie um "
"novo e insira-o no dicionário de módulos."

#: ../../c-api/import.rst:97
msgid ""
"Return a :term:`strong reference` to the module on success. Return ``NULL`` "
"with an exception set on failure."
msgstr ""
"Retorna uma :term:`referência forte` ao módulo em caso de sucesso. Retorna "
"``NULL`` com uma exceção definida em caso de falha."

#: ../../c-api/import.rst:100
msgid "The module name *name* is decoded from UTF-8."
msgstr "O nome do módulo *name* é descodificado a partir de UTF-8."

#: ../../c-api/import.rst:102
msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use :c:func:"
"`PyImport_ImportModule` or one of its variants to import a module. Package "
"structures implied by a dotted name for *name* are not created if not "
"already present."
msgstr ""
"Esta função não carrega nem importa o módulo; se o módulo ainda não estiver "
"carregado, obterá um objeto de módulo vazio. Use :c:func:"
"`PyImport_ImportModule` ou uma das suas variantes para importar um módulo. "
"As estruturas de pacotes implícitas por um nome pontilhado para *name* não "
"são criadas se ainda não estiverem presentes."

#: ../../c-api/import.rst:113
msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference` and *name* is a Python :class:`str` object."
msgstr ""
"Semelhante a :c:func:`PyImport_AddModuleRef`, mas retorna uma :term:"
"`referência emprestada` e *name* é um objeto Python :class:`str`."

#: ../../c-api/import.rst:121
msgid ""
"Similar to :c:func:`PyImport_AddModuleRef`, but return a :term:`borrowed "
"reference`."
msgstr ""
"Semelhante a :c:func:`PyImport_AddModuleRef`, mas retorna uma :term:"
"`referência emprestada`."

#: ../../c-api/import.rst:129
msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :data:`sys.modules` in error cases, even if *name* "
"was already in :data:`sys.modules` on entry to :c:func:"
"`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules in :"
"data:`sys.modules` is dangerous, as imports of such modules have no way to "
"know that the module object is an unknown (and probably damaged with respect "
"to the module author's intents) state."
msgstr ""
"Dado um nome de módulo (possivelmente na forma ``package.module``) e um "
"objeto de código lido de um ficheiro de bytecode Python ou obtido da função "
"embutida :func:`compile`, carregue o módulo. Retorne uma nova referência ao "
"objeto do módulo ou ``NULL`` com uma exceção definida se ocorrer um erro. "
"*name* é removido de :data:`sys.modules` em casos de erro, mesmo que *name* "
"já estivesse em :data:`sys.modules` na entrada para :c:func:"
"`PyImport_ExecCodeModule`. Deixar módulos incompletamente inicializados em :"
"data:`sys.modules` é perigoso, pois as importações desses módulos não têm "
"como saber que o objeto do módulo está em um estado desconhecido (e "
"provavelmente danificado em relação às intenções do autor do módulo)."

#: ../../c-api/import.rst:139
msgid ""
"The module's :attr:`~module.__spec__` and :attr:`~module.__loader__` will be "
"set, if not set already, with the appropriate values.  The spec's loader "
"will be set to the module's :attr:`!__loader__` (if set) and to an instance "
"of :class:`~importlib.machinery.SourceFileLoader` otherwise."
msgstr ""
"Os atributos :attr:`~module.__spec__` e :attr:`~module.__loader__` do módulo "
"serão definidos, se ainda não estiverem definidos, com os valores "
"apropriados. O carregador da especificação será definido como :attr:`!"
"__loader__` do módulo (se definido) e, caso contrário, como uma instância "
"de :class:`~importlib.machinery.SourceFileLoader`."

#: ../../c-api/import.rst:144
msgid ""
"The module's :attr:`~module.__file__` attribute will be set to the code "
"object's :attr:`~codeobject.co_filename`.  If applicable, :attr:`~module."
"__cached__` will also be set."
msgstr ""
"O atributo :attr:`~module.__file__` do módulo será definido como :attr:"
"`~codeobject.co_filename` do objeto de código. Se aplicável, :attr:`~module."
"__cached__` também será definido."

#: ../../c-api/import.rst:148
msgid ""
"This function will reload the module if it was already imported.  See :c:"
"func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"Esta função irá recarregar o módulo se ele já tiver sido importado. "
"Consulte :c:func:`PyImport_ReloadModule` para saber a forma correta de "
"recarregar um módulo."

#: ../../c-api/import.rst:151
msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"Se *nome* apontar para um nome pontilhado do tipo ``package.module``, "
"quaisquer estruturas de pacote ainda não criadas continuarão sem ser criadas."

#: ../../c-api/import.rst:154
msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
"Veja também :c:func:`PyImport_ExecCodeModuleEx` e :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."

#: ../../c-api/import.rst:157
msgid ""
"The setting of :attr:`~module.__cached__` and :attr:`~module.__loader__` is "
"deprecated. See :class:`~importlib.machinery.ModuleSpec` for alternatives."
msgstr ""
"A configuração de :attr:`~module.__cached__` e :attr:`~module.__loader__` "
"está obsoleta. Consulte :class:`~importlib.machinery.ModuleSpec` para "
"alternativas."

#: ../../c-api/import.rst:165
msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`~module.__file__` "
"attribute of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
"Semelhante a :c:func:`PyImport_ExecCodeModule`, mas o atributo :attr:"
"`~module.__file__` do objeto módulo é definido como *pathname* se não for "
"``NULL``."

#: ../../c-api/import.rst:168
msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr "Veja também :c:func:`PyImport_ExecCodeModuleWithPathnames`."

#: ../../c-api/import.rst:173
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`~module.__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``.  "
"Of the three functions, this is the preferred one to use."
msgstr ""
"Semelhante a :c:func:`PyImport_ExecCodeModuleEx`, mas o atributo :attr:"
"`~module.__cached__` do objeto módulo é definido como *cpathname* se não for "
"``NULL``. Das três funções, esta é a preferida para uso."

#: ../../c-api/import.rst:179
msgid ""
"Setting :attr:`~module.__cached__` is deprecated. See :class:`~importlib."
"machinery.ModuleSpec` for alternatives."
msgstr ""
"A configuração :attr:`~module.__cached__` está obsoleta. Consulte :class:"
"`~importlib.machinery.ModuleSpec` para alternativas."

#: ../../c-api/import.rst:186
msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
"Semelhante a :c:func:`PyImport_ExecCodeModuleObject`, mas *name*, *pathname* "
"e *cpathname* são strings codificadas em UTF-8. Também são feitas tentativas "
"para determinar qual deve ser o valor de *pathname* a partir de *cpathname* "
"se o primeiro estiver definido como ``NULL``."

#: ../../c-api/import.rst:192
msgid ""
"Uses :func:`!imp.source_from_cache` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""
"Utiliza :func:`!imp.source_from_cache` no cálculo do caminho de origem se "
"apenas o caminho do bytecode for fornecido."

#: ../../c-api/import.rst:195
msgid "No longer uses the removed :mod:`!imp` module."
msgstr "Já não utiliza o módulo removido :mod:`!imp`."

#: ../../c-api/import.rst:201
msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"Retorna o número mágico para ficheiros de bytecode Python (também conhecidos "
"como ficheiros :file:`.pyc`). O número mágico deve estar presente nos "
"primeiros quatro bytes do ficheiro de bytecode, na ordem de bytes little-"
"endian. Retorna ``-1`` em caso de erro."

#: ../../c-api/import.rst:205
msgid "Return value of ``-1`` upon failure."
msgstr "Retorna o valor ``-1`` em caso de falha."

#: ../../c-api/import.rst:211
msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"Retorne a string da tag mágica para nomes de ficheiros de bytecode Python no "
"formato :pep:`3147`. Tenha em mente que o valor em ``sys.implementation."
"cache_tag`` é autoritativo e deve ser usado em vez desta função."

#: ../../c-api/import.rst:219
msgid ""
"Return the dictionary used for the module administration (a.k.a. ``sys."
"modules``).  Note that this is a per-interpreter variable."
msgstr ""
"Retorna o dicionário usado para a administração do módulo (também conhecido "
"como ``sys.modules``). Observe que esta é uma variável por interpretador."

#: ../../c-api/import.rst:224
msgid ""
"Return the already imported module with the given name.  If the module has "
"not been imported yet then returns ``NULL`` but does not set an error.  "
"Returns ``NULL`` and sets an error if the lookup failed."
msgstr ""
"Retorna o módulo já importado com o nome fornecido. Se o módulo ainda não "
"tiver sido importado, retorna ``NULL``, mas não define um erro. Retorna "
"``NULL`` e define um erro se a pesquisa falhar."

#: ../../c-api/import.rst:232
msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`!pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook "
"is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in :data:`sys."
"path_importer_cache`. Return a new reference to the finder object."
msgstr ""
"Retorna um objeto localizador para um item :data:`sys.path`/:attr:`!pkg."
"__path__` *path*, possivelmente obtendo-o do dicionário :data:`sys."
"path_importer_cache`. Se ainda não estiver em cache, percorra :data:`sys."
"path_hooks` até encontrar um gancho que possa lidar com o item do caminho. "
"Retorne ``None`` se nenhum gancho puder; isso informa ao nosso chamador que "
"o :term:`localizador baseado em caminho` não conseguiu encontrar um "
"localizador para este item de caminho. Armazene o resultado em cache em :"
"data:`sys.path_importer_cache`. Retorne uma nova referência ao objeto "
"localizador."

#: ../../c-api/import.rst:243
msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use :c:func:"
"`PyImport_ImportModule`.  (Note the misnomer --- this function would reload "
"the module if it was already imported.)"
msgstr ""
"Carregue um módulo congelado chamado *name*. Retorne ``1`` para sucesso, "
"``0`` se o módulo não for encontrado e ``-1`` com uma exceção definida se a "
"inicialização falhar. Para aceder ao módulo importado após um carregamento "
"bem-sucedido, use :c:func:`PyImport_ImportModule`. (Observe o nome impróprio "
"--- esta função recarregaria o módulo se ele já tivesse sido importado.)"

#: ../../c-api/import.rst:251
msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "O atributo ``__file__`` já não está definido no módulo."

#: ../../c-api/import.rst:257
msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Semelhante a :c:func:`PyImport_ImportFrozenModuleObject`, mas o nome é uma "
"string codificada em UTF-8 em vez de um objeto Unicode."

#: ../../c-api/import.rst:265
msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the "
"Python source distribution).  Its definition, found in :file:`Include/import."
"h`, is::"
msgstr ""
"Esta é a definição do tipo de estrutura para descritores de módulos "
"congelados, conforme gerada pelo utilitário :program:`freeze` (consulte :"
"file:`Tools/freeze/` na distribuição de código-fonte do Python). A sua "
"definição, encontrada em :file:`Include/import.h`, é::"

#: ../../c-api/import.rst:270
msgid ""
"struct _frozen {\n"
"    const char *name;\n"
"    const unsigned char *code;\n"
"    int size;\n"
"    bool is_package;\n"
"};"
msgstr ""
"struct _frozen {\n"
"    const char *name;\n"
"    const unsigned char *code;\n"
"    int size;\n"
"    bool is_package;\n"
"};"

#: ../../c-api/import.rst:277
msgid ""
"The new ``is_package`` field indicates whether the module is a package or "
"not. This replaces setting the ``size`` field to a negative value."
msgstr ""
"O novo campo ``is_package`` indica se o módulo é um pacote ou não. Isso "
"substitui a configuração do campo ``size`` para um valor negativo."

#: ../../c-api/import.rst:283
msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""
"Este ponteiro é inicializado para apontar para uma array de registos :c:"
"struct:`_frozen`, terminada por um cujos membros são todos ``NULL`` ou zero. "
"Quando um módulo congelado é importado, ele é procurado nesta tabela. Código "
"de terceiros poderia usar isso para fornecer uma coleção criada "
"dinamicamente de módulos congelados."

#: ../../c-api/import.rst:291
msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Adicione um único módulo à tabela existente de módulos incorporados. Este é "
"um invólucro conveniente em torno de :c:func:`PyImport_ExtendInittab`, "
"retornando ``-1`` se a tabela não puder ser estendida. O novo módulo pode "
"ser importado pelo nome *name* e usa a função *initfunc* como a função de "
"inicialização chamada na primeira tentativa de importação. Isso deve ser "
"chamado antes de :c:func:`Py_Initialize`."

#: ../../c-api/import.rst:301
msgid ""
"Structure describing a single entry in the list of built-in modules. "
"Programs which embed Python may use an array of these structures in "
"conjunction with :c:func:`PyImport_ExtendInittab` to provide additional "
"built-in modules. The structure consists of two members:"
msgstr ""
"Estrutura que descreve uma única entrada na lista de módulos incorporados. "
"Os programas que incorporam Python podem usar uma matriz dessas estruturas "
"em conjunto com :c:func:`PyImport_ExtendInittab` para fornecer módulos "
"incorporados adicionais. A estrutura consiste em dois membros:"

#: ../../c-api/import.rst:309
msgid "The module name, as an ASCII encoded string."
msgstr "O nome do módulo, como uma cadeia codificada em ASCII."

#: ../../c-api/import.rst:313
msgid "Initialization function for a module built into the interpreter."
msgstr "Função de inicialização para um módulo incorporado no interpretador."

#: ../../c-api/import.rst:318
msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains ``NULL`` for the :c:"
"member:`~_inittab.name` field; failure to provide the sentinel value can "
"result in a memory fault. Returns ``0`` on success or ``-1`` if insufficient "
"memory could be allocated to extend the internal table.  In the event of "
"failure, no modules are added to the internal table.  This must be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Adiciona uma coleção de módulos à tabela de módulos incorporados. A matriz "
"*newtab* deve terminar com uma entrada sentinela que contenha ``NULL`` para "
"o campo :c:member:`~_inittab.name`; a falha em fornecer o valor sentinela "
"pode resultar numa falha de memória. Retorna ``0`` em caso de sucesso ou "
"``-1`` se não for possível alocar memória suficiente para estender a tabela "
"interna. Em caso de falha, nenhum módulo é adicionado à tabela interna. Isso "
"deve ser chamado antes de :c:func:`Py_Initialize`."

#: ../../c-api/import.rst:325
msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab` "
"or :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""
"Se o Python for inicializado várias vezes, :c:func:`PyImport_AppendInittab` "
"ou :c:func:`PyImport_ExtendInittab` devem ser chamados antes de cada "
"inicialização do Python."

#: ../../c-api/import.rst:332
msgid "Import the module *mod_name* and get its attribute *attr_name*."
msgstr "Importe o módulo *mod_name* e obtenha o seu atributo *attr_name*."

#: ../../c-api/import.rst:334
msgid "Names must be Python :class:`str` objects."
msgstr "Os nomes devem ser objetos Python :class:`str`."

#: ../../c-api/import.rst:336
msgid ""
"Helper function combining :c:func:`PyImport_Import` and :c:func:"
"`PyObject_GetAttr`. For example, it can raise :exc:`ImportError` if the "
"module is not found, and :exc:`AttributeError` if the attribute doesn't "
"exist."
msgstr ""
"Função auxiliar que combina :c:func:`PyImport_Import` e :c:func:"
"`PyObject_GetAttr`. Por exemplo, pode levantar :exc:`ImportError` se o "
"módulo não for encontrado e :exc:`AttributeError` se o atributo não existir."

#: ../../c-api/import.rst:345
msgid ""
"Similar to :c:func:`PyImport_ImportModuleAttr`, but names are UTF-8 encoded "
"strings instead of Python :class:`str` objects."
msgstr ""
"Semelhante a :c:func:`PyImport_ImportModuleAttr`, mas os nomes são cadeias "
"codificadas em UTF-8 em vez de objetos Python :class:`str`."

#: ../../c-api/import.rst:11
msgid "package variable"
msgstr "variável de pacote"

#: ../../c-api/import.rst:11
msgid "__all__"
msgstr "__all__"

#: ../../c-api/import.rst:11
msgid "__all__ (package variable)"
msgstr "__all__ (variável do pacote)"

#: ../../c-api/import.rst:11
msgid "modules (in module sys)"
msgstr "módulos (no módulo sys)"

#: ../../c-api/import.rst:35 ../../c-api/import.rst:127
msgid "built-in function"
msgstr "função incorporada"

#: ../../c-api/import.rst:35
msgid "__import__"
msgstr "__import__"

#: ../../c-api/import.rst:127
msgid "compile"
msgstr "compile"

#: ../../c-api/import.rst:263
msgid "freeze utility"
msgstr "utilitário freeze"
